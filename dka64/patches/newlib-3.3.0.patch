diff --git a/libgloss/configure b/libgloss/configure
index 0d2918c..bccfb07 100755
--- a/libgloss/configure
+++ b/libgloss/configure
@@ -2604,6 +2604,8 @@ if test "${config_libnosys}" = "true"; then
 
 fi
 
+subdirs="$subdirs libsysbase"
+
 DEPDIR="${am__leading_dot}deps"
 
 ac_config_commands="$ac_config_commands depfiles"
diff --git a/libgloss/configure.in b/libgloss/configure.in
index f38d529..509c310 100644
--- a/libgloss/configure.in
+++ b/libgloss/configure.in
@@ -2,6 +2,7 @@ dnl Process this file with autoconf to produce a configure script.
 AC_PREREQ(2.59)
 AC_INIT([libgloss],[LIBGLOSS_VERSION])
 AC_CONFIG_SRCDIR([libnosys])
+AC_CONFIG_SRCDIR([libsysbase])
 
 if test "${enable_shared}" = "yes" ; then
     echo "Shared libraries not supported for cross compiling, ignored"
@@ -193,6 +194,7 @@ dnl fi
 if test "${config_libnosys}" = "true"; then
   AC_CONFIG_SUBDIRS([libnosys])
 fi
+AC_CONFIG_SUBDIRS(libsysbase)
 
 LIB_AC_PROG_CC
 AS=${AS-as}
diff --git a/libgloss/libsysbase/Makefile.in b/libgloss/libsysbase/Makefile.in
new file mode 100644
index 0000000..3db0c08
--- /dev/null
+++ b/libgloss/libsysbase/Makefile.in
@@ -0,0 +1,151 @@
+# Copyright (c) 1998 Cygnus Support
+#
+# The authors hereby grant permission to use, copy, modify, distribute,
+# and license this software and its documentation for any purpose, provided
+# that existing copyright notices are retained in all copies and that this
+# notice is included verbatim in any distributions. No written agreement,
+# license, or royalty fee is required for any of the authorized uses.
+# Modifications to this software may be copyrighted by their authors
+# and need not follow the licensing terms described here, provided that
+# the new terms are clearly indicated on the first page of each file where
+# they apply.
+
+DESTDIR =
+VPATH = @srcdir@
+srcdir = @srcdir@
+objdir = .
+srcroot = $(srcdir)/../..
+objroot = $(objdir)/../..
+
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+
+host_alias = @host_alias@
+target_alias = @target_alias@
+program_transform_name = @program_transform_name@
+
+bindir = @bindir@
+libdir = @libdir@
+tooldir = $(exec_prefix)/$(target_alias)
+
+# Multilib support variables.
+# TOP is used instead of MULTI{BUILD,SRC}TOP.
+MULTIDIRS =
+MULTISUBDIR =
+MULTIDO = true
+MULTICLEAN = true
+
+INSTALL = @INSTALL@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_DATA = @INSTALL_DATA@
+
+SHELL =	/bin/sh
+
+CC = @CC@
+
+#AS = @AS@
+AS = `if [ -f ${objroot}/../gas/as.new ] ; \
+	then echo ${objroot}/../gas/as.new ; \
+	else echo as ; fi`
+
+AR = @AR@
+
+#LD = @LD@
+LD = `if [ -f ${objroot}/../ld/ld.new ] ; \
+	then echo ${objroot}/../ld/ld.new ; \
+	else echo ld ; fi`
+
+RANLIB = @RANLIB@
+
+OBJDUMP = `if [ -f ${objroot}/../binutils/objdump ] ; \
+	then echo ${objroot}/../binutils/objdump ; \
+	else t='$(program_transform_name)'; echo objdump | sed -e $$t ; fi`
+OBJCOPY = `if [ -f ${objroot}/../binutils/objcopy ] ; \
+	then echo ${objroot}/../binutils/objcopy ; \
+	else t='$(program_transform_name)'; echo objcopy | sed -e $$t ; fi`
+
+# object files needed
+OBJS = abort.o iosupport.o clocks.o close.o environ.o execve.o fork.o fstat.o getpid.o gettod.o \
+	isatty.o kill.o link.o lseek.o lstat.o nanosleep.o open.o read.o sbrk.o sleep.o stat.o usleep.o times.o \
+	unlink.o wait.o write.o _exit.o malloc_vars.o \
+	chdir.o mkdir.o rename.o statvfs.o \
+	flock.o locks.o handle_manager.o truncate.o ftruncate.o dirent.o fsync.o \
+	fchmod.o chmod.o getreent.o rmdir.o utime.o scandir.o fnmatch.o pthread.o
+
+# Object files specific to particular targets.
+EVALOBJS = ${OBJS}
+
+GCC_LDFLAGS = `if [ -d ${objroot}/../gcc ] ; \
+	then echo -L${objroot}/../gcc ; fi`
+
+OUTPUTS = libsysbase.a libpthread.a
+
+NEWLIB_CFLAGS = `if [ -d ${objroot}/newlib ]; then echo -I${objroot}/newlib/targ-include -I${srcroot}/newlib/libc/include; fi`
+NEWLIB_LDFLAGS = `if [ -d ${objroot}/newlib ]; then echo -B${objroot}/newlib/ -L${objroot}/newlib/; fi`
+
+INCLUDES = -I. -I$(srcdir)/..
+# Note that when building the library, ${MULTILIB} is not the way multilib
+# options are passed; they're passed in $(CFLAGS).
+CFLAGS_FOR_TARGET = ${MULTILIB} ${INCLUDES} ${NEWLIB_CFLAGS}
+LDFLAGS_FOR_TARGET = ${MULTILIB} ${NEWLIB_LDFLAGS}
+AR_FLAGS = qc
+
+.c.o:
+	$(CC) $(CFLAGS_FOR_TARGET) -O2 -D_BUILDING_LIBSYSBASE $(INCLUDES) -c $(CFLAGS) $<
+
+.C.o:
+	$(CC) $(CFLAGS_FOR_TARGET) -O2 -D_BUILDING_LIBSYSBASE $(INCLUDES) -c $(CFLAGS) $<
+.s.o:
+	$(AS) $(ASFLAGS_FOR_TARGET) $(INCLUDES) $(ASFLAGS) -o $*.o $<
+
+#
+# GCC knows to run the preprocessor on .S files before it assembles them.
+#
+.S.o:
+	$(CC) $(CFLAGS_FOR_TARGET) $(INCLUDES) $(CFLAGS) -c $<
+
+#
+# this is a bogus target that'll produce an assembler from the
+# C source with the right compiler options. this is so we can
+# track down code generation or debug symbol bugs.
+#
+.c.s:
+	$(CC) $(CFLAGS_FOR_TARGET) -S $(INCLUDES) $(CFLAGS) $<
+
+all: ${OUTPUTS}
+
+#
+# here's where we build the library for each target
+#
+
+libsysbase.a: $(EVALOBJS)
+	${AR} ${ARFLAGS} $@ $(EVALOBJS)
+	${RANLIB} $@
+
+libpthread.a:
+	${AR} rc $@
+
+doc:
+
+clean mostlyclean:
+	rm -f $(OUTPUTS) *.i *~ *.o *-test *.srec *.dis *.map *.x
+
+distclean maintainer-clean realclean: clean
+	rm -f Makefile config.status $(OUTPUTS)
+
+.PHONY: install info install-info clean-info
+install:
+	@for outputs in ${OUTPUTS}; do\
+	 mkdir -p $(DESTDIR)$(tooldir)/lib${MULTISUBDIR}; \
+	 $(INSTALL_PROGRAM) $${outputs} $(DESTDIR)$(tooldir)/lib${MULTISUBDIR}; \
+	done
+
+info:
+install-info:
+clean-info:
+
+Makefile: Makefile.in config.status @host_makefile_frag_path@
+	$(SHELL) config.status
+
+config.status: configure
+	$(SHELL) config.status --recheck
diff --git a/libgloss/libsysbase/_exit.c b/libgloss/libsysbase/_exit.c
new file mode 100644
index 0000000..6effb11
--- /dev/null
+++ b/libgloss/libsysbase/_exit.c
@@ -0,0 +1,17 @@
+/* Stub version of _exit.  */
+
+#include <limits.h>
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/iosupport.h>
+
+void _exit(int rc)
+{
+
+	if ( __has_syscall(exit) ) {
+		__syscall_exit(rc);
+	}
+
+	while(1);
+}
diff --git a/libgloss/libsysbase/abort.c b/libgloss/libsysbase/abort.c
new file mode 100644
index 0000000..9272e22
--- /dev/null
+++ b/libgloss/libsysbase/abort.c
@@ -0,0 +1,8 @@
+#include <stdlib.h>
+#include <unistd.h>
+
+void abort(void) {
+  write (2, "Abort called.\n", sizeof("Abort called.\n")-1);
+  _exit (1);
+}
+
diff --git a/libgloss/libsysbase/acconfig.h b/libgloss/libsysbase/acconfig.h
new file mode 100644
index 0000000..200ea78
--- /dev/null
+++ b/libgloss/libsysbase/acconfig.h
@@ -0,0 +1,29 @@
+/* Name of package.  */
+#undef PACKAGE
+
+/* Version of package.  */
+#undef VERSION
+
+/* Missing syscall names */
+#undef MISSING_SYSCALL_NAMES
+
+/* Reentrant syscalls */
+#undef REENTRANT_SYSCALLS_PROVIDED
+
+/* Using ELF format */
+#undef HAVE_ELF
+
+/* Using GNU LD */
+#undef HAVE_GNU_LD
+
+/* .previous directive allowed */
+#undef HAVE_ASM_PREVIOUS_DIRECTIVE
+
+/* .pushsection/.popsection directives allowed */
+#undef HAVE_ASM_POPSECTION_DIRECTIVE
+
+/* support for section attributes */
+#undef HAVE_SECTION_ATTRIBUTES
+
+/* symbol prefix */
+#undef __SYMBOL_PREFIX
diff --git a/libgloss/libsysbase/aclocal.m4 b/libgloss/libsysbase/aclocal.m4
new file mode 100644
index 0000000..b6cdfae
--- /dev/null
+++ b/libgloss/libsysbase/aclocal.m4
@@ -0,0 +1,344 @@
+# generated automatically by aclocal 1.9.5 -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
+# 2005  Free Software Foundation, Inc.
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+# AM_CONDITIONAL                                            -*- Autoconf -*-
+
+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 7
+
+# AM_CONDITIONAL(NAME, SHELL-CONDITION)
+# -------------------------------------
+# Define a conditional.
+AC_DEFUN([AM_CONDITIONAL],
+[AC_PREREQ(2.52)dnl
+ ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
+	[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
+AC_SUBST([$1_TRUE])
+AC_SUBST([$1_FALSE])
+if $2; then
+  $1_TRUE=
+  $1_FALSE='#'
+else
+  $1_TRUE='#'
+  $1_FALSE=
+fi
+AC_CONFIG_COMMANDS_PRE(
+[if test -z "${$1_TRUE}" && test -z "${$1_FALSE}"; then
+  AC_MSG_ERROR([[conditional "$1" was never defined.
+Usually this means the macro was only invoked conditionally.]])
+fi])])
+
+
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 8
+
+# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
+# written in clear, in which case automake, when reading aclocal.m4,
+# will think it sees a *use*, and therefore will trigger all it's
+# C support machinery.  Also note that it means that autoscan, seeing
+# CC etc. in the Makefile, will ask for an AC_PROG_CC use...
+
+
+# _AM_DEPENDENCIES(NAME)
+# ----------------------
+# See how the compiler implements dependency checking.
+# NAME is "CC", "CXX", "GCJ", or "OBJC".
+# We try a few techniques and use that to set a single cache variable.
+#
+# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was
+# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular
+# dependency, and given that the user is not expected to run this macro,
+# just rely on AC_PROG_CC.
+AC_DEFUN([_AM_DEPENDENCIES],
+[AC_REQUIRE([AM_SET_DEPDIR])dnl
+AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl
+AC_REQUIRE([AM_MAKE_INCLUDE])dnl
+AC_REQUIRE([AM_DEP_TRACK])dnl
+
+ifelse([$1], CC,   [depcc="$CC"   am_compiler_list=],
+       [$1], CXX,  [depcc="$CXX"  am_compiler_list=],
+       [$1], OBJC, [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
+       [$1], GCJ,  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
+                   [depcc="$$1"   am_compiler_list=])
+
+AC_CACHE_CHECK([dependency style of $depcc],
+               [am_cv_$1_dependencies_compiler_type],
+[if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_$1_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n ['s/^#*\([a-zA-Z0-9]*\))$/\1/p'] < ./depcomp`
+  fi
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    case $depmode in
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    none) break ;;
+    esac
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.
+    if depmode=$depmode \
+       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_$1_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_$1_dependencies_compiler_type=none
+fi
+])
+AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])
+AM_CONDITIONAL([am__fastdep$1], [
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_$1_dependencies_compiler_type" = gcc3])
+])
+
+
+# AM_SET_DEPDIR
+# -------------
+# Choose a directory name for dependency files.
+# This macro is AC_REQUIREd in _AM_DEPENDENCIES
+AC_DEFUN([AM_SET_DEPDIR],
+[AC_REQUIRE([AM_SET_LEADING_DOT])dnl
+AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
+])
+
+
+# AM_DEP_TRACK
+# ------------
+AC_DEFUN([AM_DEP_TRACK],
+[AC_ARG_ENABLE(dependency-tracking,
+[  --disable-dependency-tracking  speeds up one-time build
+  --enable-dependency-tracking   do not reject slow dependency extractors])
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+fi
+AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
+AC_SUBST([AMDEPBACKSLASH])
+])
+
+# Generate code to set up dependency tracking.              -*- Autoconf -*-
+
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+#serial 3
+
+# _AM_OUTPUT_DEPENDENCY_COMMANDS
+# ------------------------------
+AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
+[for mf in $CONFIG_FILES; do
+  # Strip MF so we end up with the name of the file.
+  mf=`echo "$mf" | sed -e 's/:.*$//'`
+  # Check whether this is an Automake generated Makefile or not.
+  # We used to match only the files named `Makefile.in', but
+  # some people rename them; so instead we look at the file content.
+  # Grep'ing the first line is not enough: some people post-process
+  # each Makefile.in and add a new line on top of each file to say so.
+  # So let's grep whole file.
+  if grep '^#.*generated by automake' $mf > /dev/null 2>&1; then
+    dirpart=`AS_DIRNAME("$mf")`
+  else
+    continue
+  fi
+  # Extract the definition of DEPDIR, am__include, and am__quote
+  # from the Makefile without running `make'.
+  DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+  test -z "$DEPDIR" && continue
+  am__include=`sed -n 's/^am__include = //p' < "$mf"`
+  test -z "am__include" && continue
+  am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+  # When using ansi2knr, U may be empty or an underscore; expand it
+  U=`sed -n 's/^U = //p' < "$mf"`
+  # Find all dependency output files, they are included files with
+  # $(DEPDIR) in their names.  We invoke sed twice because it is the
+  # simplest approach to changing $(DEPDIR) to its actual value in the
+  # expansion.
+  for file in `sed -n "
+    s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+       sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+    # Make sure the directory exists.
+    test -f "$dirpart/$file" && continue
+    fdir=`AS_DIRNAME(["$file"])`
+    AS_MKDIR_P([$dirpart/$fdir])
+    # echo "creating $dirpart/$file"
+    echo '# dummy' > "$dirpart/$file"
+  done
+done
+])# _AM_OUTPUT_DEPENDENCY_COMMANDS
+
+
+# AM_OUTPUT_DEPENDENCY_COMMANDS
+# -----------------------------
+# This macro should only be invoked once -- use via AC_REQUIRE.
+#
+# This code is only required when automatic dependency tracking
+# is enabled.  FIXME.  This creates each `.P' file that we will
+# need in order to bootstrap the dependency handling code.
+AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
+[AC_CONFIG_COMMANDS([depfiles],
+     [test x"$AMDEP_TRUE" != x"" || _AM_OUTPUT_DEPENDENCY_COMMANDS],
+     [AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"])
+])
+
+# Copyright (C) 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 2
+
+# Check whether the underlying file-system supports filenames
+# with a leading dot.  For instance MS-DOS doesn't.
+AC_DEFUN([AM_SET_LEADING_DOT],
+[rm -rf .tst 2>/dev/null
+mkdir .tst 2>/dev/null
+if test -d .tst; then
+  am__leading_dot=.
+else
+  am__leading_dot=_
+fi
+rmdir .tst 2>/dev/null
+AC_SUBST([am__leading_dot])])
+
+# Check to see how 'make' treats includes.	            -*- Autoconf -*-
+
+# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 3
+
+# AM_MAKE_INCLUDE()
+# -----------------
+# Check to see how make treats includes.
+AC_DEFUN([AM_MAKE_INCLUDE],
+[am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo done
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+AC_MSG_CHECKING([for style of include used by $am_make])
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# We grep out `Entering directory' and `Leaving directory'
+# messages which can occur if `w' ends up in MAKEFLAGS.
+# In particular we don't look at `^make:' because GNU make might
+# be invoked under some other name (usually "gmake"), in which
+# case it prints its new name instead of `make'.
+if test "`$am_make -s -f confmf 2> /dev/null | grep -v 'ing directory'`" = "done"; then
+   am__include=include
+   am__quote=
+   _am_result=GNU
+fi
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   if test "`$am_make -s -f confmf 2> /dev/null`" = "done"; then
+      am__include=.include
+      am__quote="\""
+      _am_result=BSD
+   fi
+fi
+AC_SUBST([am__include])
+AC_SUBST([am__quote])
+AC_MSG_RESULT([$_am_result])
+rm -f confinc confmf
+])
+
+m4_include([../acinclude.m4])
diff --git a/libgloss/libsysbase/chdir.c b/libgloss/libsysbase/chdir.c
new file mode 100644
index 0000000..b94f6a8
--- /dev/null
+++ b/libgloss/libsysbase/chdir.c
@@ -0,0 +1,200 @@
+#include <unistd.h>
+#include <limits.h>
+#include <reent.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <sys/iosupport.h>
+#include <sys/param.h>
+
+/* CWD always start with "/" */
+static char _current_working_directory [PATH_MAX] = "/";
+static char temp_cwd [PATH_MAX];
+
+#define DIRECTORY_SEPARATOR_CHAR '/'
+const char DIRECTORY_SEPARATOR[] = "/";
+const char DIRECTORY_THIS[] = ".";
+const char DIRECTORY_PARENT[] = "..";
+
+int _concatenate_path (struct _reent *r, char *path, const char *extra, int maxLength) {
+	char *pathEnd;
+	int pathLength;
+	const char *extraEnd;
+	int extraSize;
+
+	pathLength = strnlen (path, maxLength);
+
+	/* assumes path ends in a directory separator */
+	if (pathLength >= maxLength) {
+		r->_errno = ENAMETOOLONG;
+		return -1;
+	}
+	pathEnd = path + pathLength;
+	if (pathEnd[-1] != DIRECTORY_SEPARATOR_CHAR) {
+		pathEnd[0] = DIRECTORY_SEPARATOR_CHAR;
+		pathEnd += 1;
+	}
+
+	extraEnd = extra;
+
+	/* If the extra bit starts with a slash, start at root */
+	if (extra[0] == DIRECTORY_SEPARATOR_CHAR) {
+		pathEnd = strchr (path, DIRECTORY_SEPARATOR_CHAR) + 1;
+		pathEnd[0] = '\0';
+	}
+	do {
+		/* Advance past any separators in extra */
+		while (extra[0] == DIRECTORY_SEPARATOR_CHAR) {
+			extra += 1;
+		}
+
+		/* Grab the next directory name from extra */
+		extraEnd = strchr (extra, DIRECTORY_SEPARATOR_CHAR);
+		if (extraEnd == NULL) {
+			extraEnd = strrchr (extra, '\0');
+		} else {
+			extraEnd += 1;
+		}
+
+		extraSize = (extraEnd - extra);
+		if (extraSize == 0) {
+			break;
+		}
+
+		if ((strncmp (extra, DIRECTORY_THIS, sizeof(DIRECTORY_THIS) - 1) == 0)
+			&& ((extra[sizeof(DIRECTORY_THIS)-1] == DIRECTORY_SEPARATOR_CHAR)
+				||(extra[sizeof(DIRECTORY_THIS)-1] == '\0')))
+		{
+			/* Don't copy anything */
+		} else 	if ((strncmp (extra, DIRECTORY_PARENT, sizeof(DIRECTORY_PARENT) - 1) == 0)
+			&& ((extra[sizeof(DIRECTORY_PARENT)-1] == DIRECTORY_SEPARATOR_CHAR)
+				||(extra[sizeof(DIRECTORY_PARENT)-1] == '\0')))
+		{
+			/* Go up one level of in the path */
+			if (pathEnd[-1] == DIRECTORY_SEPARATOR_CHAR) {
+				// Remove trailing separator
+				pathEnd[-1] = '\0';
+			}
+			pathEnd = strrchr (path, DIRECTORY_SEPARATOR_CHAR);
+			if (pathEnd == NULL) {
+				/* Can't go up any higher, return false */
+				r->_errno = ENOENT;
+				return -1;
+			}
+			pathLength = pathEnd - path;
+			pathEnd += 1;
+		} else {
+			pathLength += extraSize;
+			if (pathLength >= maxLength) {
+				r->_errno = ENAMETOOLONG;
+				return -1;
+			}
+			/* Copy the next part over */
+			strncpy (pathEnd, extra, extraSize);
+			pathEnd += extraSize;
+		}
+		pathEnd[0] = '\0';
+		extra += extraSize;
+	} while (extraSize != 0);
+
+        if (strlen(path) > 2 ) {
+                if (pathEnd[-1] == DIRECTORY_SEPARATOR_CHAR && pathEnd[-2] != ':')
+                        pathEnd[-1] = '\0';
+        }
+
+	return 0;
+}
+
+int chdir (const char *path) {
+	struct _reent *r = _REENT;
+
+	int dev;
+	const char *pathPosition;
+
+	/* Make sure the path is short enough */
+	if (strnlen (path, PATH_MAX) >= PATH_MAX) {
+		r->_errno = ENAMETOOLONG;
+		return -1;
+	}
+
+	if (strchr (path, ':') != NULL) {
+		strncpy (temp_cwd, path, PATH_MAX);
+		/* Move path past device name */
+		path = strchr (path, ':') + 1;
+	} else {
+		strncpy (temp_cwd, _current_working_directory, PATH_MAX);
+	}
+
+	pathPosition = strchr (temp_cwd , ':');
+
+	if (pathPosition == NULL) {
+		pathPosition = temp_cwd;
+	} else {
+		pathPosition++;
+	}
+
+	/* Make sure the path starts in the root directory */
+	if (pathPosition[0] != DIRECTORY_SEPARATOR_CHAR) {
+		r->_errno = ENOENT;
+		return -1;
+	}
+
+	/* Concatenate the path to the CWD */
+	if (_concatenate_path (r, temp_cwd, path, PATH_MAX) == -1) {
+		return -1;
+	}
+
+	/* Get device from path name */
+	dev = FindDevice(temp_cwd);
+
+	if (dev < 0) {
+		r->_errno = ENODEV;
+		return -1;
+	}
+
+	r->deviceData = devoptab_list[dev]->deviceData;
+
+	if ( devoptab_list[dev]->chdir_r == NULL) {
+		r->_errno = ENOSYS;
+		return -1;
+	}
+
+	/* Try changing directories on the device */
+	if (devoptab_list[dev]->chdir_r (r, temp_cwd) == -1) {
+		return -1;
+	}
+
+	/* Since it worked, set the new CWD and default device */
+	setDefaultDevice(dev);
+	strncpy (_current_working_directory, temp_cwd, PATH_MAX);
+
+	return 0;
+}
+
+char *getcwd(char *buf, size_t size) {
+
+	struct _reent *r = _REENT;
+
+	if (size == 0) {
+		if (buf != NULL) {
+			r->_errno = EINVAL;
+			return NULL;
+		}
+		buf = malloc(PATH_MAX);
+		size = PATH_MAX;
+	}
+
+	if (buf == NULL) {
+		r->_errno = EINVAL;
+		return NULL;
+	}
+
+	if ( size < (strnlen (_current_working_directory, PATH_MAX) + 1)) {
+		r->_errno = ERANGE;
+		return NULL;
+	}
+
+	strncpy (buf, _current_working_directory, size);
+
+	return buf;
+}
diff --git a/libgloss/libsysbase/chmod.c b/libgloss/libsysbase/chmod.c
new file mode 100644
index 0000000..3668b58
--- /dev/null
+++ b/libgloss/libsysbase/chmod.c
@@ -0,0 +1,30 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/iosupport.h>
+#include <errno.h>
+
+int chmod(const char *path, mode_t mode) {
+	int	ret,dev;
+	struct _reent *r = _REENT;
+
+	/* Get device from path name */
+	dev = FindDevice(path);
+
+	if (dev < 0) {
+		r->_errno = ENODEV;
+		ret = -1;
+	} else {
+		if (devoptab_list[dev]->chmod_r == NULL) {
+			r->_errno=ENOSYS;
+		} else {
+			r->deviceData = devoptab_list[dev]->deviceData;
+			ret = devoptab_list[dev]->chmod_r(r,path,mode);
+		}
+	}
+
+	return ret;
+}
+
diff --git a/libgloss/libsysbase/clocks.c b/libgloss/libsysbase/clocks.c
new file mode 100644
index 0000000..b36b5c0
--- /dev/null
+++ b/libgloss/libsysbase/clocks.c
@@ -0,0 +1,34 @@
+#include <errno.h>
+#include <time.h>
+#include <sys/iosupport.h>
+
+int clock_gettime(clockid_t clock_id, struct timespec *tp)
+{
+   if ( __has_syscall(clock_gettime) ) {
+      return __syscall_clock_gettime(clock_id, tp);
+   } else {
+      errno = ENOSYS;
+      return -1;
+   }
+}
+
+int clock_settime(clockid_t clock_id, const struct timespec *tp)
+{
+   if ( __has_syscall(clock_settime) ) {
+      return __syscall_clock_settime(clock_id, tp);
+   } else {
+      errno = ENOSYS;
+      return -1;
+   }
+}
+
+int clock_getres (clockid_t clock_id, struct timespec *res)
+{
+   if ( __has_syscall(clock_getres) ) {
+      return __syscall_clock_getres(clock_id, res);
+   } else {
+      errno = ENOSYS;
+      return -1;
+   }
+}
+
diff --git a/libgloss/libsysbase/close.c b/libgloss/libsysbase/close.c
new file mode 100644
index 0000000..931ad07
--- /dev/null
+++ b/libgloss/libsysbase/close.c
@@ -0,0 +1,46 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <stdio.h>
+#include <errno.h>
+
+#include <sys/iosupport.h>
+
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+//---------------------------------------------------------------------------------
+int _close_r(struct _reent *ptr, int fileDesc) {
+//---------------------------------------------------------------------------------
+#else
+//---------------------------------------------------------------------------------
+int _close(int fileDesc) {
+//---------------------------------------------------------------------------------
+	struct _reent *ptr = _REENT;
+#endif
+	int ret = -1;
+	unsigned int dev = 0;
+
+	if(fileDesc!=-1) {
+
+		__handle *handle = __get_handle(fileDesc);
+
+		if ( handle != NULL) {
+			dev = handle->device;
+			handle->refcount--;
+			if (handle->refcount == 0 ) {
+
+				if(devoptab_list[dev]->close_r) {
+					ptr->deviceData = devoptab_list[dev]->deviceData;
+					ret = devoptab_list[dev]->close_r(ptr,handle->fileStruct);
+				}
+				else
+					ret = 0;
+
+				__release_handle(fileDesc);
+			} else {
+				ret = 0;
+			}
+
+		}
+	}
+	return ret;
+}
diff --git a/libgloss/libsysbase/config.h.in b/libgloss/libsysbase/config.h.in
new file mode 100644
index 0000000..48ce950
--- /dev/null
+++ b/libgloss/libsysbase/config.h.in
@@ -0,0 +1,25 @@
+/* config.h.in.  Generated automatically from configure.in by autoheader.  */
+
+/* Missing syscall names */
+#undef MISSING_SYSCALL_NAMES
+
+/* Reentrant syscalls */
+#undef REENTRANT_SYSCALLS_PROVIDED
+
+/* Using ELF format */
+#undef HAVE_ELF
+
+/* Using GNU LD */
+#undef HAVE_GNU_LD
+
+/* .previous directive allowed */
+#undef HAVE_ASM_PREVIOUS_DIRECTIVE
+
+/* .pushsection/.popsection directives allowed */
+#undef HAVE_ASM_POPSECTION_DIRECTIVE
+
+/* support for section attributes */
+#undef HAVE_SECTION_ATTRIBUTES
+
+/* symbol prefix */
+#undef __SYMBOL_PREFIX
diff --git a/libgloss/libsysbase/configure b/libgloss/libsysbase/configure
new file mode 100644
index 0000000..aa653c2
--- /dev/null
+++ b/libgloss/libsysbase/configure
@@ -0,0 +1,4160 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.69.
+#
+#
+# Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
+#
+#
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in #(
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+as_myself=
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
+
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+# Use a proper internal environment variable to ensure we don't fall
+  # into an infinite loop, continuously re-executing ourselves.
+  if test x"${_as_can_reexec}" != xno && test "x$CONFIG_SHELL" != x; then
+    _as_can_reexec=no; export _as_can_reexec;
+    # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+as_fn_exit 255
+  fi
+  # We don't want this to propagate to other subprocesses.
+          { _as_can_reexec=; unset _as_can_reexec;}
+if test "x$CONFIG_SHELL" = x; then
+  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '\${1+\"\$@\"}'='\"\$@\"'
+  setopt NO_GLOB_SUBST
+else
+  case \`(set -o) 2>/dev/null\` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+"
+  as_required="as_fn_return () { (exit \$1); }
+as_fn_success () { as_fn_return 0; }
+as_fn_failure () { as_fn_return 1; }
+as_fn_ret_success () { return 0; }
+as_fn_ret_failure () { return 1; }
+
+exitcode=0
+as_fn_success || { exitcode=1; echo as_fn_success failed.; }
+as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
+as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
+as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
+if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
+
+else
+  exitcode=1; echo positional parameters were not saved.
+fi
+test x\$exitcode = x0 || exit 1
+test -x / || exit 1"
+  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
+  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
+  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
+  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1"
+  if (eval "$as_required") 2>/dev/null; then :
+  as_have_required=yes
+else
+  as_have_required=no
+fi
+  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :
+
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_found=false
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  as_found=:
+  case $as_dir in #(
+	 /*)
+	   for as_base in sh bash ksh sh5; do
+	     # Try only shells that exist, to save several forks.
+	     as_shell=$as_dir/$as_base
+	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
+		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  CONFIG_SHELL=$as_shell as_have_required=yes
+		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  break 2
+fi
+fi
+	   done;;
+       esac
+  as_found=false
+done
+$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
+	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
+  CONFIG_SHELL=$SHELL as_have_required=yes
+fi; }
+IFS=$as_save_IFS
+
+
+      if test "x$CONFIG_SHELL" != x; then :
+  export CONFIG_SHELL
+             # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+exit 255
+fi
+
+    if test x$as_have_required = xno; then :
+  $as_echo "$0: This script requires a shell more modern than all"
+  $as_echo "$0: the shells that I found on your system."
+  if test x${ZSH_VERSION+set} = xset ; then
+    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
+    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
+  else
+    $as_echo "$0: Please tell bug-autoconf@gnu.org about your system,
+$0: including any error possibly output before this
+$0: message. Then install a modern shell, or manually run
+$0: the script under such a shell if you do have one."
+  fi
+  exit 1
+fi
+fi
+fi
+SHELL=${CONFIG_SHELL-/bin/sh}
+export SHELL
+# Unset more variables known to interfere with behavior of common tools.
+CLICOLOR_FORCE= GREP_OPTIONS=
+unset CLICOLOR_FORCE GREP_OPTIONS
+
+## --------------------- ##
+## M4sh Shell Functions. ##
+## --------------------- ##
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with STATUS, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+  fi
+  $as_echo "$as_me: error: $2" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+
+  as_lineno_1=$LINENO as_lineno_1a=$LINENO
+  as_lineno_2=$LINENO as_lineno_2a=$LINENO
+  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
+  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
+  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
+
+  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
+  # already done that, so ensure we don't try to do so again and fall
+  # in an infinite loop.  This has already happened in practice.
+  _as_can_reexec=no; export _as_can_reexec
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -pR'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -pR'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -pR'
+  fi
+else
+  as_ln_s='cp -pR'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+test -n "$DJDIR" || exec 7<&0 </dev/null
+exec 6>&1
+
+# Name of the host.
+# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_clean_files=
+ac_config_libobj_dir=.
+LIBOBJS=
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+
+# Identity of this package.
+PACKAGE_NAME=
+PACKAGE_TARNAME=
+PACKAGE_VERSION=
+PACKAGE_STRING=
+PACKAGE_BUGREPORT=
+PACKAGE_URL=
+
+ac_unique_file="close.c"
+ac_subst_vars='LTLIBOBJS
+LIBOBJS
+host_makefile_frag_path
+CCASFLAGS
+CCAS
+RANLIB
+LD
+AR
+AS
+am__fastdepCC_FALSE
+am__fastdepCC_TRUE
+CCDEPMODE
+AMDEPBACKSLASH
+AMDEP_FALSE
+AMDEP_TRUE
+am__quote
+am__include
+DEPDIR
+am__leading_dot
+CC
+INSTALL_DATA
+INSTALL_SCRIPT
+INSTALL_PROGRAM
+target_os
+target_vendor
+target_cpu
+target
+host_os
+host_vendor
+host_cpu
+host
+build_os
+build_vendor
+build_cpu
+build
+target_alias
+host_alias
+build_alias
+LIBS
+ECHO_T
+ECHO_N
+ECHO_C
+DEFS
+mandir
+localedir
+libdir
+psdir
+pdfdir
+dvidir
+htmldir
+infodir
+docdir
+oldincludedir
+includedir
+localstatedir
+sharedstatedir
+sysconfdir
+datadir
+datarootdir
+libexecdir
+sbindir
+bindir
+program_transform_name
+prefix
+exec_prefix
+PACKAGE_URL
+PACKAGE_BUGREPORT
+PACKAGE_STRING
+PACKAGE_VERSION
+PACKAGE_TARNAME
+PACKAGE_NAME
+PATH_SEPARATOR
+SHELL'
+ac_subst_files='host_makefile_frag'
+ac_user_opts='
+enable_option_checking
+enable_dependency_tracking
+'
+      ac_precious_vars='build_alias
+host_alias
+target_alias
+CCAS
+CCASFLAGS'
+
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+ac_unrecognized_opts=
+ac_unrecognized_sep=
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+# (The list follows the same order as the GNU Coding Standards.)
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datarootdir='${prefix}/share'
+datadir='${datarootdir}'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+docdir='${datarootdir}/doc/${PACKAGE}'
+infodir='${datarootdir}/info'
+htmldir='${docdir}'
+dvidir='${docdir}'
+pdfdir='${docdir}'
+psdir='${docdir}'
+libdir='${exec_prefix}/lib'
+localedir='${datarootdir}/locale'
+mandir='${datarootdir}/man'
+
+ac_prev=
+ac_dashdash=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval $ac_prev=\$ac_option
+    ac_prev=
+    continue
+  fi
+
+  case $ac_option in
+  *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *=)   ac_optarg= ;;
+  *)    ac_optarg=yes ;;
+  esac
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_dashdash$ac_option in
+  --)
+    ac_dashdash=yes ;;
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=*)
+    datadir=$ac_optarg ;;
+
+  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
+  | --dataroo | --dataro | --datar)
+    ac_prev=datarootdir ;;
+  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
+  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
+    datarootdir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid feature name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=no ;;
+
+  -docdir | --docdir | --docdi | --doc | --do)
+    ac_prev=docdir ;;
+  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
+    docdir=$ac_optarg ;;
+
+  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
+    ac_prev=dvidir ;;
+  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
+    dvidir=$ac_optarg ;;
+
+  -enable-* | --enable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid feature name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=\$ac_optarg ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
+    ac_prev=htmldir ;;
+  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
+  | --ht=*)
+    htmldir=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localedir | --localedir | --localedi | --localed | --locale)
+    ac_prev=localedir ;;
+  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
+    localedir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst | --locals)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
+    ac_prev=pdfdir ;;
+  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
+    pdfdir=$ac_optarg ;;
+
+  -psdir | --psdir | --psdi | --psd | --ps)
+    ac_prev=psdir ;;
+  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
+    psdir=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid package name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=\$ac_optarg ;;
+
+  -without-* | --without-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid package name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=no ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) as_fn_error $? "unrecognized option: \`$ac_option'
+Try \`$0 --help' for more information"
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    case $ac_envvar in #(
+      '' | [0-9]* | *[!_$as_cr_alnum]* )
+      as_fn_error $? "invalid variable name: \`$ac_envvar'" ;;
+    esac
+    eval $ac_envvar=\$ac_optarg
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : "${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}"
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  as_fn_error $? "missing argument to $ac_option"
+fi
+
+if test -n "$ac_unrecognized_opts"; then
+  case $enable_option_checking in
+    no) ;;
+    fatal) as_fn_error $? "unrecognized options: $ac_unrecognized_opts" ;;
+    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
+  esac
+fi
+
+# Check all directory arguments for consistency.
+for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
+		datadir sysconfdir sharedstatedir localstatedir includedir \
+		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
+		libdir localedir mandir
+do
+  eval ac_val=\$$ac_var
+  # Remove trailing slashes.
+  case $ac_val in
+    */ )
+      ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
+      eval $ac_var=\$ac_val;;
+  esac
+  # Be sure to have absolute directory names.
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* )  continue;;
+    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
+  esac
+  as_fn_error $? "expected an absolute directory name for --$ac_var: $ac_val"
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+ac_pwd=`pwd` && test -n "$ac_pwd" &&
+ac_ls_di=`ls -di .` &&
+ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
+  as_fn_error $? "working directory cannot be determined"
+test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
+  as_fn_error $? "pwd does not report name of working directory"
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then the parent directory.
+  ac_confdir=`$as_dirname -- "$as_myself" ||
+$as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_myself" : 'X\(//\)[^/]' \| \
+	 X"$as_myself" : 'X\(//\)$' \| \
+	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_myself" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r "$srcdir/$ac_unique_file"; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r "$srcdir/$ac_unique_file"; then
+  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
+  as_fn_error $? "cannot find sources ($ac_unique_file) in $srcdir"
+fi
+ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
+ac_abs_confdir=`(
+	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error $? "$ac_msg"
+	pwd)`
+# When building in place, set srcdir=.
+if test "$ac_abs_confdir" = "$ac_pwd"; then
+  srcdir=.
+fi
+# Remove unnecessary trailing slashes from srcdir.
+# Double slashes in file names in object file debugging info
+# mess up M-x gdb in Emacs.
+case $srcdir in
+*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
+esac
+for ac_var in $ac_precious_vars; do
+  eval ac_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_env_${ac_var}_value=\$${ac_var}
+  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_cv_env_${ac_var}_value=\$${ac_var}
+done
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures this package to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking ...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR            user executables [EPREFIX/bin]
+  --sbindir=DIR           system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR        program executables [EPREFIX/libexec]
+  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --libdir=DIR            object code libraries [EPREFIX/lib]
+  --includedir=DIR        C header files [PREFIX/include]
+  --oldincludedir=DIR     C header files for non-gcc [/usr/include]
+  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]
+  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]
+  --infodir=DIR           info documentation [DATAROOTDIR/info]
+  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
+  --mandir=DIR            man documentation [DATAROOTDIR/man]
+  --docdir=DIR            documentation root [DATAROOTDIR/doc/PACKAGE]
+  --htmldir=DIR           html documentation [DOCDIR]
+  --dvidir=DIR            dvi documentation [DOCDIR]
+  --pdfdir=DIR            pdf documentation [DOCDIR]
+  --psdir=DIR             ps documentation [DOCDIR]
+_ACEOF
+
+  cat <<\_ACEOF
+
+Program names:
+  --program-prefix=PREFIX            prepend PREFIX to installed program names
+  --program-suffix=SUFFIX            append SUFFIX to installed program names
+  --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+  --target=TARGET   configure for building compilers for TARGET [HOST]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-option-checking  ignore unrecognized --enable/--with options
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --disable-dependency-tracking  speeds up one-time build
+  --enable-dependency-tracking   do not reject slow dependency extractors
+
+Some influential environment variables:
+  CCAS        assembler compiler command (defaults to CC)
+  CCASFLAGS   assembler compiler flags (defaults to CFLAGS)
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+Report bugs to the package provider.
+_ACEOF
+ac_status=$?
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d "$ac_dir" ||
+      { cd "$srcdir" && ac_pwd=`pwd` && srcdir=. && test -d "$ac_dir"; } ||
+      continue
+    ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+    cd "$ac_dir" || { ac_status=$?; continue; }
+    # Check for guested configure.
+    if test -f "$ac_srcdir/configure.gnu"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
+    elif test -f "$ac_srcdir/configure"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure" --help=recursive
+    else
+      $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi || ac_status=$?
+    cd "$ac_pwd" || { ac_status=$?; break; }
+  done
+fi
+
+test -n "$ac_init_help" && exit $ac_status
+if $ac_init_version; then
+  cat <<\_ACEOF
+configure
+generated by GNU Autoconf 2.69
+
+Copyright (C) 2012 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit
+fi
+
+## ------------------------ ##
+## Autoconf initialization. ##
+## ------------------------ ##
+
+# ac_fn_c_try_compile LINENO
+# --------------------------
+# Try to compile conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext
+  if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_compile
+cat >config.log <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by $as_me, which was
+generated by GNU Autoconf 2.69.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+exec 5>>config.log
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    $as_echo "PATH: $as_dir"
+  done
+IFS=$as_save_IFS
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *\'*)
+      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) as_fn_append ac_configure_args0 " '$ac_arg'" ;;
+    2)
+      as_fn_append ac_configure_args1 " '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      as_fn_append ac_configure_args " '$ac_arg'"
+      ;;
+    esac
+  done
+done
+{ ac_configure_args0=; unset ac_configure_args0;}
+{ ac_configure_args1=; unset ac_configure_args1;}
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Use '\'' to represent an apostrophe within the trap.
+# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    $as_echo "## ---------------- ##
+## Cache variables. ##
+## ---------------- ##"
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+(
+  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+  (set) 2>&1 |
+    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      sed -n \
+	"s/'\''/'\''\\\\'\'''\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
+      ;; #(
+    *)
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+)
+    echo
+
+    $as_echo "## ----------------- ##
+## Output variables. ##
+## ----------------- ##"
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=\$$ac_var
+      case $ac_val in
+      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+      esac
+      $as_echo "$ac_var='\''$ac_val'\''"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      $as_echo "## ------------------- ##
+## File substitutions. ##
+## ------------------- ##"
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=\$$ac_var
+	case $ac_val in
+	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+	esac
+	$as_echo "$ac_var='\''$ac_val'\''"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      $as_echo "## ----------- ##
+## confdefs.h. ##
+## ----------- ##"
+      echo
+      cat confdefs.h
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      $as_echo "$as_me: caught signal $ac_signal"
+    $as_echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core core.conftest.* &&
+    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -f -r conftest* confdefs.h
+
+$as_echo "/* confdefs.h */" > confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_URL "$PACKAGE_URL"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer an explicitly selected file to automatically selected ones.
+ac_site_file1=NONE
+ac_site_file2=NONE
+if test -n "$CONFIG_SITE"; then
+  # We do not want a PATH search for config.site.
+  case $CONFIG_SITE in #((
+    -*)  ac_site_file1=./$CONFIG_SITE;;
+    */*) ac_site_file1=$CONFIG_SITE;;
+    *)   ac_site_file1=./$CONFIG_SITE;;
+  esac
+elif test "x$prefix" != xNONE; then
+  ac_site_file1=$prefix/share/config.site
+  ac_site_file2=$prefix/etc/config.site
+else
+  ac_site_file1=$ac_default_prefix/share/config.site
+  ac_site_file2=$ac_default_prefix/etc/config.site
+fi
+for ac_site_file in "$ac_site_file1" "$ac_site_file2"
+do
+  test "x$ac_site_file" = xNONE && continue
+  if test /dev/null != "$ac_site_file" && test -r "$ac_site_file"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
+$as_echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file" \
+      || { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "failed to load site script $ac_site_file
+See \`config.log' for more details" "$LINENO" 5; }
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special files
+  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.
+  if test /dev/null != "$cache_file" && test -f "$cache_file"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
+$as_echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . "$cache_file";;
+      *)                      . "./$cache_file";;
+    esac
+  fi
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
+$as_echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in $ac_precious_vars; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val=\$ac_cv_env_${ac_var}_value
+  eval ac_new_val=\$ac_env_${ac_var}_value
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	# differences in whitespace do not lead to failure.
+	ac_old_val_w=`echo x $ac_old_val`
+	ac_new_val_w=`echo x $ac_new_val`
+	if test "$ac_old_val_w" != "$ac_new_val_w"; then
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
+$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	  ac_cache_corrupted=:
+	else
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
+$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
+	  eval $ac_var=\$ac_old_val
+	fi
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
+$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
+$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) as_fn_append ac_configure_args " '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
+$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  as_fn_error $? "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
+fi
+## -------------------- ##
+## Main body of script. ##
+## -------------------- ##
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+ac_config_headers="$ac_config_headers config.h"
+
+
+if test "${enable_shared}" = "yes" ; then
+    echo "Shared libraries not supported for cross compiling, ignored"
+fi
+
+if test "$srcdir" = "." ; then
+  if test "${with_target_subdir}" != "." ; then
+    libgloss_topdir="${srcdir}/${with_multisrctop}../../.."
+  else
+    libgloss_topdir="${srcdir}/${with_multisrctop}../.."
+  fi
+else
+  libgloss_topdir="${srcdir}/../.."
+fi
+ac_aux_dir=
+for ac_dir in $libgloss_topdir "$srcdir"/$libgloss_topdir; do
+  if test -f "$ac_dir/install-sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f "$ac_dir/install.sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f "$ac_dir/shtool"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  as_fn_error $? "cannot find install-sh, install.sh, or shtool in $libgloss_topdir \"$srcdir\"/$libgloss_topdir" "$LINENO" 5
+fi
+
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
+ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
+
+
+
+# Make sure we can run config.sub.
+$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
+  as_fn_error $? "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
+$as_echo_n "checking build system type... " >&6; }
+if ${ac_cv_build+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_build_alias=$build_alias
+test "x$ac_build_alias" = x &&
+  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
+test "x$ac_build_alias" = x &&
+  as_fn_error $? "cannot guess build type; you must specify one" "$LINENO" 5
+ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
+  as_fn_error $? "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
+$as_echo "$ac_cv_build" >&6; }
+case $ac_cv_build in
+*-*-*) ;;
+*) as_fn_error $? "invalid value of canonical build" "$LINENO" 5;;
+esac
+build=$ac_cv_build
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_build
+shift
+build_cpu=$1
+build_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+build_os=$*
+IFS=$ac_save_IFS
+case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
+$as_echo_n "checking host system type... " >&6; }
+if ${ac_cv_host+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test "x$host_alias" = x; then
+  ac_cv_host=$ac_cv_build
+else
+  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
+    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
+$as_echo "$ac_cv_host" >&6; }
+case $ac_cv_host in
+*-*-*) ;;
+*) as_fn_error $? "invalid value of canonical host" "$LINENO" 5;;
+esac
+host=$ac_cv_host
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_host
+shift
+host_cpu=$1
+host_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+host_os=$*
+IFS=$ac_save_IFS
+case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking target system type" >&5
+$as_echo_n "checking target system type... " >&6; }
+if ${ac_cv_target+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test "x$target_alias" = x; then
+  ac_cv_target=$ac_cv_host
+else
+  ac_cv_target=`$SHELL "$ac_aux_dir/config.sub" $target_alias` ||
+    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $target_alias failed" "$LINENO" 5
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_target" >&5
+$as_echo "$ac_cv_target" >&6; }
+case $ac_cv_target in
+*-*-*) ;;
+*) as_fn_error $? "invalid value of canonical target" "$LINENO" 5;;
+esac
+target=$ac_cv_target
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_target
+shift
+target_cpu=$1
+target_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+target_os=$*
+IFS=$ac_save_IFS
+case $target_os in *\ *) target_os=`echo "$target_os" | sed 's/ /-/g'`;; esac
+
+
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+test -n "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+
+test "$program_prefix" != NONE &&
+  program_transform_name="s&^&$program_prefix&;$program_transform_name"
+# Use a double $ so make ignores it.
+test "$program_suffix" != NONE &&
+  program_transform_name="s&\$&$program_suffix&;$program_transform_name"
+# Double any \ or $.
+# By default was `s,x,x', remove it if useless.
+ac_script='s/[\\$]/&&/g;s/;s,x,x,$//'
+program_transform_name=`$as_echo "$program_transform_name" | sed "$ac_script"`
+
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+# Reject install programs that cannot install multiple files.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a BSD-compatible install" >&5
+$as_echo_n "checking for a BSD-compatible install... " >&6; }
+if test -z "$INSTALL"; then
+if ${ac_cv_path_install+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in #((
+  ./ | .// | /[cC]/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:[\\/]os2[\\/]install[\\/]* | ?:[\\/]OS2[\\/]INSTALL[\\/]* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if as_fn_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    rm -rf conftest.one conftest.two conftest.dir
+	    echo one > conftest.one
+	    echo two > conftest.two
+	    mkdir conftest.dir
+	    if "$as_dir/$ac_prog$ac_exec_ext" -c conftest.one conftest.two "`pwd`/conftest.dir" &&
+	      test -s conftest.one && test -s conftest.two &&
+	      test -s conftest.dir/conftest.one &&
+	      test -s conftest.dir/conftest.two
+	    then
+	      ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	      break 3
+	    fi
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+
+  done
+IFS=$as_save_IFS
+
+rm -rf conftest.one conftest.two conftest.dir
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    INSTALL=$ac_install_sh
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $INSTALL" >&5
+$as_echo "$INSTALL" >&6; }
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+
+$as_echo "#define HAVE_GNU_LD 1" >>confdefs.h
+
+case "${target}" in
+  *-*-cygwin*)
+	;;
+  a29k-amd-udi)
+	;;
+  aarch64-*-elf)
+  $as_echo "#define REENTRANT_SYSCALLS_PROVIDED 1" >>confdefs.h
+  ;;
+  arc-*-*)
+	;;
+  arm-*-eabi)
+	$as_echo "#define REENTRANT_SYSCALLS_PROVIDED 1" >>confdefs.h
+	;;
+  arm*-*-*)
+	;;
+  bfin-*-*)
+	;;
+  cris-*-* | crisv32-*-*)
+	;;
+  d10v*)
+	;;
+  h8300*-*-*)
+	;;
+  h8500-*-*)
+	;;
+  i345686-*-sco*)
+	;;
+  lm32-*-*)
+	;;
+  m32r-*-*)
+	;;
+  mn10?00-*-*)
+	;;
+  powerpcle-*-pe)
+	;;
+  sh*-*-*)
+	;;
+  sparc-sun-sunos*)
+	;;
+  sparc64-*-*)
+	;;
+  v850*-*-*)
+	;;
+  w65-*-*)
+	;;
+  xstormy16-*-*)
+	;;
+  z8k-*-*)
+	;;
+  *)
+	$as_echo "#define MISSING_SYSCALL_NAMES 1" >>confdefs.h
+
+	;;
+esac
+
+case "${target}" in
+  *-*-elf)
+        $as_echo "#define HAVE_ELF 1" >>confdefs.h
+
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for .previous assembler directive" >&5
+$as_echo_n "checking for .previous assembler directive... " >&6; }
+if ${libc_cv_asm_previous_directive+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+          libc_cv_asm_previous_directive=no
+        cat > conftest.s <<EOF
+.section foo_section
+.previous
+EOF
+        if { ac_try='${CC-cc} -c $CFLAGS conftest.s 1>&5'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then
+          libc_cv_asm_previous_directive=yes
+        fi
+        rm -f conftest*
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $libc_cv_asm_previous_directive" >&5
+$as_echo "$libc_cv_asm_previous_directive" >&6; }
+
+	if test "x${libc_cv_asm_previous_directive}" = "xyes"; then
+          $as_echo "#define HAVE_ASM_PREVIOUS_DIRECTIVE 1" >>confdefs.h
+
+	fi
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for .popsection assembler directive" >&5
+$as_echo_n "checking for .popsection assembler directive... " >&6; }
+if ${libc_cv_asm_popsection_directive+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+          libc_cv_asm_popsection_directive=no
+        cat > conftest.s <<EOF
+.pushsection foo_section
+.popsection
+EOF
+        if { ac_try='${CC-cc} -c $CFLAGS conftest.s 1>&5'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then
+          libc_cv_asm_popsection_directive=yes
+        fi
+        rm -f conftest*
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $libc_cv_asm_popsection_directive" >&5
+$as_echo "$libc_cv_asm_popsection_directive" >&6; }
+
+	if test "x${libc_cv_asm_popsection_directive}" = "xyes"; then
+          $as_echo "#define HAVE_ASM_POPSECTION_DIRECTIVE 1" >>confdefs.h
+
+	fi
+
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for section attributes" >&5
+$as_echo_n "checking for section attributes... " >&6; }
+if ${libc_cv_section_attributes+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+          libc_cv_section_attributes=no
+        cat > conftest.c <<EOF
+int secttest __attribute__ ((section (".gnu.warning.secttest"))) = 10;
+int main() {}
+EOF
+        if { ac_try='${CC-cc} -c $CFLAGS conftest.c 1>&5'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then
+          libc_cv_section_attributes=yes
+        fi
+        rm -f conftest*
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $libc_cv_section_attributes" >&5
+$as_echo "$libc_cv_section_attributes" >&6; }
+	if test "x${libc_cv_section_attributes}" = "xyes"; then
+          $as_echo "#define HAVE_SECTION_ATTRIBUTES 1" >>confdefs.h
+
+	fi
+        ;;
+esac
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for symbol prefix" >&5
+$as_echo_n "checking for symbol prefix... " >&6; }
+if ${libc_cv_symbol_prefix+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat > conftest.c <<\EOF
+foo () { }
+EOF
+libc_cv_symbol_prefix=none
+if { ac_try='${CC-cc} -S conftest.c -o - | fgrep "\$foo" > /dev/null'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; };
+then
+  libc_cv_symbol_prefix='$'
+else
+  if { ac_try='${CC-cc} -S conftest.c -o - | fgrep "_foo" > /dev/null'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; };
+  then
+    libc_cv_symbol_prefix=_
+  fi
+fi
+rm -f conftest*
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $libc_cv_symbol_prefix" >&5
+$as_echo "$libc_cv_symbol_prefix" >&6; }
+if test $libc_cv_symbol_prefix != none; then
+  cat >>confdefs.h <<_ACEOF
+#define __SYMBOL_PREFIX "$libc_cv_symbol_prefix"
+_ACEOF
+
+else
+  $as_echo "#define __SYMBOL_PREFIX \"\"" >>confdefs.h
+
+fi
+
+rm -rf .tst 2>/dev/null
+mkdir .tst 2>/dev/null
+if test -d .tst; then
+  am__leading_dot=.
+else
+  am__leading_dot=_
+fi
+rmdir .tst 2>/dev/null
+
+DEPDIR="${am__leading_dot}deps"
+
+ac_config_commands="$ac_config_commands depfiles"
+
+
+am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo done
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for style of include used by $am_make" >&5
+$as_echo_n "checking for style of include used by $am_make... " >&6; }
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# We grep out `Entering directory' and `Leaving directory'
+# messages which can occur if `w' ends up in MAKEFLAGS.
+# In particular we don't look at `^make:' because GNU make might
+# be invoked under some other name (usually "gmake"), in which
+# case it prints its new name instead of `make'.
+if test "`$am_make -s -f confmf 2> /dev/null | grep -v 'ing directory'`" = "done"; then
+   am__include=include
+   am__quote=
+   _am_result=GNU
+fi
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   if test "`$am_make -s -f confmf 2> /dev/null`" = "done"; then
+      am__include=.include
+      am__quote="\""
+      _am_result=BSD
+   fi
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $_am_result" >&5
+$as_echo "$_am_result" >&6; }
+rm -f confinc confmf
+
+# Check whether --enable-dependency-tracking was given.
+if test "${enable_dependency_tracking+set}" = set; then :
+  enableval=$enable_dependency_tracking;
+fi
+
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+fi
+
+
+if test "x$enable_dependency_tracking" != xno; then
+  AMDEP_TRUE=
+  AMDEP_FALSE='#'
+else
+  AMDEP_TRUE='#'
+  AMDEP_FALSE=
+fi
+
+
+
+# Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+
+depcc="$CC"   am_compiler_list=
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
+$as_echo_n "checking dependency style of $depcc... " >&6; }
+if ${am_cv_CC_dependencies_compiler_type+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_CC_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
+  fi
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    case $depmode in
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    none) break ;;
+    esac
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.
+    if depmode=$depmode \
+       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_CC_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_CC_dependencies_compiler_type=none
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_CC_dependencies_compiler_type" >&5
+$as_echo "$am_cv_CC_dependencies_compiler_type" >&6; }
+CCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type
+
+
+
+if
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_CC_dependencies_compiler_type" = gcc3; then
+  am__fastdepCC_TRUE=
+  am__fastdepCC_FALSE='#'
+else
+  am__fastdepCC_TRUE='#'
+  am__fastdepCC_FALSE=
+fi
+
+
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -z "$CC" && as_fn_error $? "no acceptable cc found in \$PATH" "$LINENO" 5
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using GNU C" >&5
+$as_echo_n "checking whether we are using GNU C... " >&6; }
+if ${ac_cv_c_compiler_gnu+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat > conftest.c <<EOF
+#ifdef __GNUC__
+  yes;
+#endif
+EOF
+if { ac_try='${CC-cc} -E conftest.c'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; } | egrep yes >/dev/null 2>&1; then
+  ac_cv_c_compiler_gnu=yes
+else
+  ac_cv_c_compiler_gnu=no
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
+$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+
+if test $ac_cv_c_compiler_gnu = yes; then
+  GCC=yes
+  ac_test_CFLAGS="${CFLAGS+set}"
+  ac_save_CFLAGS="$CFLAGS"
+  CFLAGS=
+  ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
+$as_echo_n "checking whether $CC accepts -g... " >&6; }
+if ${ac_cv_prog_cc_g+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_c_werror_flag=$ac_c_werror_flag
+   ac_c_werror_flag=yes
+   ac_cv_prog_cc_g=no
+   CFLAGS="-g"
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+else
+  CFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+else
+  ac_c_werror_flag=$ac_save_c_werror_flag
+	 CFLAGS="-g"
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_c_werror_flag=$ac_save_c_werror_flag
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
+$as_echo "$ac_cv_prog_cc_g" >&6; }
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+  if test "$ac_test_CFLAGS" = set; then
+    CFLAGS="$ac_save_CFLAGS"
+  elif test $ac_cv_prog_cc_g = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-O2"
+  fi
+else
+  GCC=
+  test "${CFLAGS+set}" = set || CFLAGS="-g"
+fi
+
+AS=${AS-as}
+
+AR=${AR-ar}
+
+LD=${LD-ld}
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_RANLIB+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
+$as_echo "$RANLIB" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_RANLIB+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
+$as_echo "$ac_ct_RANLIB" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_RANLIB" = x; then
+    RANLIB=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    RANLIB=$ac_ct_RANLIB
+  fi
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+# By default we simply use the C compiler to build assembly code.
+
+test "${CCAS+set}" = set || CCAS=$CC
+test "${CCASFLAGS+set}" = set || CCASFLAGS=$CFLAGS
+
+
+
+
+host_makefile_frag=${srcdir}/../config/default.mh
+
+host_makefile_frag_path=$host_makefile_frag
+
+
+
+ac_config_files="$ac_config_files Makefile"
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, we kill variables containing newlines.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(
+  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+
+  (set) 2>&1 |
+    case $as_nl`(ac_space=' '; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      # `set' does not quote correctly, so add quotes: double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \.
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;; #(
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+) |
+  sed '
+     /^ac_cv_env_/b end
+     t clear
+     :clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     :end' >>confcache
+if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
+  if test -w "$cache_file"; then
+    if test "x$cache_file" != "x/dev/null"; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
+$as_echo "$as_me: updating cache $cache_file" >&6;}
+      if test ! -f "$cache_file" || test -h "$cache_file"; then
+	cat confcache >"$cache_file"
+      else
+        case $cache_file in #(
+        */* | ?:*)
+	  mv -f confcache "$cache_file"$$ &&
+	  mv -f "$cache_file"$$ "$cache_file" ;; #(
+        *)
+	  mv -f confcache "$cache_file" ;;
+	esac
+      fi
+    fi
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
+$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+DEFS=-DHAVE_CONFIG_H
+
+ac_libobjs=
+ac_ltlibobjs=
+U=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
+  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
+  as_fn_error $? "conditional \"AMDEP\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
+  as_fn_error $? "conditional \"am__fastdepCC\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+
+: "${CONFIG_STATUS=./config.status}"
+ac_write_fail=0
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
+$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
+as_write_fail=0
+cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+
+SHELL=\${CONFIG_SHELL-$SHELL}
+export SHELL
+_ASEOF
+cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in #(
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+as_myself=
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
+
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with STATUS, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+  fi
+  $as_echo "$as_me: error: $2" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -pR'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -pR'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -pR'
+  fi
+else
+  as_ln_s='cp -pR'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+exec 6>&1
+## ----------------------------------- ##
+## Main body of $CONFIG_STATUS script. ##
+## ----------------------------------- ##
+_ASEOF
+test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# Save the log message, to keep $0 and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.
+ac_log="
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.69.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+on `(hostname || uname -n) 2>/dev/null | sed 1q`
+"
+
+_ACEOF
+
+case $ac_config_files in *"
+"*) set x $ac_config_files; shift; ac_config_files=$*;;
+esac
+
+case $ac_config_headers in *"
+"*) set x $ac_config_headers; shift; ac_config_headers=$*;;
+esac
+
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+# Files that config.status was made for.
+config_files="$ac_config_files"
+config_headers="$ac_config_headers"
+config_commands="$ac_config_commands"
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+ac_cs_usage="\
+\`$as_me' instantiates files and other configuration actions
+from templates according to the current configuration.  Unless the files
+and actions are specified as TAGs, all are instantiated by default.
+
+Usage: $0 [OPTION]... [TAG]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number and configuration settings, then exit
+      --config     print configuration, then exit
+  -q, --quiet, --silent
+                   do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+      --file=FILE[:TEMPLATE]
+                   instantiate the configuration file FILE
+      --header=FILE[:TEMPLATE]
+                   instantiate the configuration header FILE
+
+Configuration files:
+$config_files
+
+Configuration headers:
+$config_headers
+
+Configuration commands:
+$config_commands
+
+Report bugs to the package provider."
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
+ac_cs_version="\\
+config.status
+configured by $0, generated by GNU Autoconf 2.69,
+  with options \\"\$ac_cs_config\\"
+
+Copyright (C) 2012 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+
+ac_pwd='$ac_pwd'
+srcdir='$srcdir'
+INSTALL='$INSTALL'
+test -n "\$AWK" || AWK=awk
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# The default lists apply if the user does not specify any file.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=?*)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  --*=)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=
+    ac_shift=:
+    ;;
+  *)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
+    $as_echo "$ac_cs_version"; exit ;;
+  --config | --confi | --conf | --con | --co | --c )
+    $as_echo "$ac_cs_config"; exit ;;
+  --debug | --debu | --deb | --de | --d | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    '') as_fn_error $? "missing file argument" ;;
+    esac
+    as_fn_append CONFIG_FILES " '$ac_optarg'"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    as_fn_append CONFIG_HEADERS " '$ac_optarg'"
+    ac_need_defaults=false;;
+  --he | --h)
+    # Conflict between --help and --header
+    as_fn_error $? "ambiguous option: \`$1'
+Try \`$0 --help' for more information.";;
+  --help | --hel | -h )
+    $as_echo "$ac_cs_usage"; exit ;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) as_fn_error $? "unrecognized option: \`$1'
+Try \`$0 --help' for more information." ;;
+
+  *) as_fn_append ac_config_targets " $1"
+     ac_need_defaults=false ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+if \$ac_cs_recheck; then
+  set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  shift
+  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
+  CONFIG_SHELL='$SHELL'
+  export CONFIG_SHELL
+  exec "\$@"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+  $as_echo "$ac_log"
+} >&5
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+#
+# INIT-COMMANDS
+#
+AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
+srcdir=${srcdir}
+target=${target}
+with_multisubdir=${with_multisubdir}
+ac_configure_args="${ac_configure_args} --enable-multilib"
+CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
+libgloss_topdir=${libgloss_topdir}
+
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+
+# Handling of arguments.
+for ac_config_target in $ac_config_targets
+do
+  case $ac_config_target in
+    "config.h") CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
+    "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
+    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+
+  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
+  esac
+done
+
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason against having it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Hook for its removal unless debugging.
+# Note that there is a small window in which the directory will not be cleaned:
+# after its creation but before its name has been assigned to `$tmp'.
+$debug ||
+{
+  tmp= ac_tmp=
+  trap 'exit_status=$?
+  : "${ac_tmp:=$tmp}"
+  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
+' 0
+  trap 'as_fn_exit 1' 1 2 13 15
+}
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
+  test -d "$tmp"
+}  ||
+{
+  tmp=./conf$$-$RANDOM
+  (umask 077 && mkdir "$tmp")
+} || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
+ac_tmp=$tmp
+
+# Set up the scripts for CONFIG_FILES section.
+# No need to generate them if there are no CONFIG_FILES.
+# This happens for instance with `./config.status config.h'.
+if test -n "$CONFIG_FILES"; then
+
+if $AWK 'BEGIN { getline <"/dev/null" }' </dev/null 2>/dev/null; then
+  ac_cs_awk_getline=:
+  ac_cs_awk_pipe_init=
+  ac_cs_awk_read_file='
+      while ((getline aline < (F[key])) > 0)
+	print(aline)
+      close(F[key])'
+  ac_cs_awk_pipe_fini=
+else
+  ac_cs_awk_getline=false
+  ac_cs_awk_pipe_init="print \"cat <<'|#_!!_#|' &&\""
+  ac_cs_awk_read_file='
+      print "|#_!!_#|"
+      print "cat " F[key] " &&"
+      '$ac_cs_awk_pipe_init
+  # The final `:' finishes the AND list.
+  ac_cs_awk_pipe_fini='END { print "|#_!!_#|"; print ":" }'
+fi
+ac_cr=`echo X | tr X '\015'`
+# On cygwin, bash can eat \r inside `` if the user requested igncr.
+# But we know of no other shell where ac_cr would be empty at this
+# point, so we can use a bashism as a fallback.
+if test "x$ac_cr" = x; then
+  eval ac_cr=\$\'\\r\'
+fi
+ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
+if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
+  ac_cs_awk_cr='\\r'
+else
+  ac_cs_awk_cr=$ac_cr
+fi
+
+echo 'BEGIN {' >"$ac_tmp/subs1.awk" &&
+_ACEOF
+
+# Create commands to substitute file output variables.
+{
+  echo "cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1" &&
+  echo 'cat >>"\$ac_tmp/subs1.awk" <<\\_ACAWK &&' &&
+  echo "$ac_subst_files" | sed 's/.*/F["&"]="$&"/' &&
+  echo "_ACAWK" &&
+  echo "_ACEOF"
+} >conf$$files.sh &&
+. ./conf$$files.sh ||
+  as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+rm -f conf$$files.sh
+
+{
+  echo "cat >conf$$subs.awk <<_ACEOF" &&
+  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
+  echo "_ACEOF"
+} >conf$$subs.sh ||
+  as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '^'`
+ac_delim='%!_!# '
+for ac_last_try in false false false false false :; do
+  . ./conf$$subs.sh ||
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+
+  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
+  if test $ac_delim_n = $ac_delim_num; then
+    break
+  elif $ac_last_try; then
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+rm -f conf$$subs.sh
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+cat >>"\$ac_tmp/subs1.awk" <<\\_ACAWK &&
+_ACEOF
+sed -n '
+h
+s/^/S["/; s/!.*/"]=/
+p
+g
+s/^[^!]*!//
+:repl
+t repl
+s/'"$ac_delim"'$//
+t delim
+:nl
+h
+s/\(.\{148\}\)..*/\1/
+t more1
+s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
+p
+n
+b repl
+:more1
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t nl
+:delim
+h
+s/\(.\{148\}\)..*/\1/
+t more2
+s/["\\]/\\&/g; s/^/"/; s/$/"/
+p
+b
+:more2
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t delim
+' <conf$$subs.awk | sed '
+/^[^""]/{
+  N
+  s/\n//
+}
+' >>$CONFIG_STATUS || ac_write_fail=1
+rm -f conf$$subs.awk
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+_ACAWK
+cat >>"\$ac_tmp/subs1.awk" <<_ACAWK &&
+  for (key in S) S_is_set[key] = 1
+  FS = ""
+  \$ac_cs_awk_pipe_init
+}
+{
+  line = $ 0
+  nfields = split(line, field, "@")
+  substed = 0
+  len = length(field[1])
+  for (i = 2; i < nfields; i++) {
+    key = field[i]
+    keylen = length(key)
+    if (S_is_set[key]) {
+      value = S[key]
+      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
+      len += length(value) + length(field[++i])
+      substed = 1
+    } else
+      len += 1 + keylen
+  }
+  if (nfields == 3 && !substed) {
+    key = field[2]
+    if (F[key] != "" && line ~ /^[	 ]*@.*@[	 ]*$/) {
+      \$ac_cs_awk_read_file
+      next
+    }
+  }
+  print line
+}
+\$ac_cs_awk_pipe_fini
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
+  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
+else
+  cat
+fi < "$ac_tmp/subs1.awk" > "$ac_tmp/subs.awk" \
+  || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
+_ACEOF
+
+# VPATH may cause trouble with some makes, so we remove sole $(srcdir),
+# ${srcdir} and @srcdir@ entries from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=[	 ]*/{
+h
+s///
+s/^/:/
+s/[	 ]*$/:/
+s/:\$(srcdir):/:/g
+s/:\${srcdir}:/:/g
+s/:@srcdir@:/:/g
+s/^:*//
+s/:*$//
+x
+s/\(=[	 ]*\).*/\1/
+G
+s/\n//
+s/^[^=]*=[	 ]*$//
+}'
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+fi # test -n "$CONFIG_FILES"
+
+# Set up the scripts for CONFIG_HEADERS section.
+# No need to generate them if there are no CONFIG_HEADERS.
+# This happens for instance with `./config.status Makefile'.
+if test -n "$CONFIG_HEADERS"; then
+cat >"$ac_tmp/defines.awk" <<\_ACAWK ||
+BEGIN {
+_ACEOF
+
+# Transform confdefs.h into an awk script `defines.awk', embedded as
+# here-document in config.status, that substitutes the proper values into
+# config.h.in to produce config.h.
+
+# Create a delimiter string that does not exist in confdefs.h, to ease
+# handling of long lines.
+ac_delim='%!_!# '
+for ac_last_try in false false :; do
+  ac_tt=`sed -n "/$ac_delim/p" confdefs.h`
+  if test -z "$ac_tt"; then
+    break
+  elif $ac_last_try; then
+    as_fn_error $? "could not make $CONFIG_HEADERS" "$LINENO" 5
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+
+# For the awk script, D is an array of macro values keyed by name,
+# likewise P contains macro parameters if any.  Preserve backslash
+# newline sequences.
+
+ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
+sed -n '
+s/.\{148\}/&'"$ac_delim"'/g
+t rset
+:rset
+s/^[	 ]*#[	 ]*define[	 ][	 ]*/ /
+t def
+d
+:def
+s/\\$//
+t bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3"/p
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2"/p
+d
+:bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3\\\\\\n"\\/p
+t cont
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2\\\\\\n"\\/p
+t cont
+d
+:cont
+n
+s/.\{148\}/&'"$ac_delim"'/g
+t clear
+:clear
+s/\\$//
+t bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/"/p
+d
+:bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/\\\\\\n"\\/p
+b cont
+' <confdefs.h | sed '
+s/'"$ac_delim"'/"\\\
+"/g' >>$CONFIG_STATUS || ac_write_fail=1
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  for (key in D) D_is_set[key] = 1
+  FS = ""
+}
+/^[\t ]*#[\t ]*(define|undef)[\t ]+$ac_word_re([\t (]|\$)/ {
+  line = \$ 0
+  split(line, arg, " ")
+  if (arg[1] == "#") {
+    defundef = arg[2]
+    mac1 = arg[3]
+  } else {
+    defundef = substr(arg[1], 2)
+    mac1 = arg[2]
+  }
+  split(mac1, mac2, "(") #)
+  macro = mac2[1]
+  prefix = substr(line, 1, index(line, defundef) - 1)
+  if (D_is_set[macro]) {
+    # Preserve the white space surrounding the "#".
+    print prefix "define", macro P[macro] D[macro]
+    next
+  } else {
+    # Replace #undef with comments.  This is necessary, for example,
+    # in the case of _POSIX_SOURCE, which is predefined and required
+    # on some systems where configure will not decide to define it.
+    if (defundef == "undef") {
+      print "/*", prefix defundef, macro, "*/"
+      next
+    }
+  }
+}
+{ print }
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+  as_fn_error $? "could not setup config headers machinery" "$LINENO" 5
+fi # test -n "$CONFIG_HEADERS"
+
+
+eval set X "  :F $CONFIG_FILES  :H $CONFIG_HEADERS    :C $CONFIG_COMMANDS"
+shift
+for ac_tag
+do
+  case $ac_tag in
+  :[FHLC]) ac_mode=$ac_tag; continue;;
+  esac
+  case $ac_mode$ac_tag in
+  :[FHL]*:*);;
+  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5;;
+  :[FH]-) ac_tag=-:-;;
+  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
+  esac
+  ac_save_IFS=$IFS
+  IFS=:
+  set x $ac_tag
+  IFS=$ac_save_IFS
+  shift
+  ac_file=$1
+  shift
+
+  case $ac_mode in
+  :L) ac_source=$1;;
+  :[FH])
+    ac_file_inputs=
+    for ac_f
+    do
+      case $ac_f in
+      -) ac_f="$ac_tmp/stdin";;
+      *) # Look for the file first in the build tree, then in the source tree
+	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
+	 # because $ac_f cannot contain `:'.
+	 test -f "$ac_f" ||
+	   case $ac_f in
+	   [\\/$]*) false;;
+	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
+	   esac ||
+	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
+      esac
+      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
+      as_fn_append ac_file_inputs " '$ac_f'"
+    done
+
+    # Let's still pretend it is `configure' which instantiates (i.e., don't
+    # use $as_me), people would be surprised to read:
+    #    /* config.h.  Generated by config.status.  */
+    configure_input='Generated from '`
+	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
+	`' by configure.'
+    if test x"$ac_file" != x-; then
+      configure_input="$ac_file.  $configure_input"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
+$as_echo "$as_me: creating $ac_file" >&6;}
+    fi
+    # Neutralize special characters interpreted by sed in replacement strings.
+    case $configure_input in #(
+    *\&* | *\|* | *\\* )
+       ac_sed_conf_input=`$as_echo "$configure_input" |
+       sed 's/[\\\\&|]/\\\\&/g'`;; #(
+    *) ac_sed_conf_input=$configure_input;;
+    esac
+
+    case $ac_tag in
+    *:-:* | *:-) cat >"$ac_tmp/stdin" \
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
+    esac
+    ;;
+  esac
+
+  ac_dir=`$as_dirname -- "$ac_file" ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  as_dir="$ac_dir"; as_fn_mkdir_p
+  ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+
+  case $ac_mode in
+  :F)
+  #
+  # CONFIG_FILE
+  #
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
+  esac
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# If the template does not know about datarootdir, expand it.
+# FIXME: This hack should be removed a few years after 2.60.
+ac_datarootdir_hack=; ac_datarootdir_seen=
+ac_sed_dataroot='
+/datarootdir/ {
+  p
+  q
+}
+/@datadir@/p
+/@docdir@/p
+/@infodir@/p
+/@localedir@/p
+/@mandir@/p'
+case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
+*datarootdir*) ac_datarootdir_seen=yes;;
+*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  ac_datarootdir_hack='
+  s&@datadir@&$datadir&g
+  s&@docdir@&$docdir&g
+  s&@infodir@&$infodir&g
+  s&@localedir@&$localedir&g
+  s&@mandir@&$mandir&g
+  s&\\\${datarootdir}&$datarootdir&g' ;;
+esac
+_ACEOF
+
+# Neutralize VPATH when `$srcdir' = `.'.
+# Shell code in configure.ac might set extrasub.
+# FIXME: do we really want to maintain this feature?
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_sed_extra="$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s|@configure_input@|$ac_sed_conf_input|;t t
+s&@top_builddir@&$ac_top_builddir_sub&;t t
+s&@top_build_prefix@&$ac_top_build_prefix&;t t
+s&@srcdir@&$ac_srcdir&;t t
+s&@abs_srcdir@&$ac_abs_srcdir&;t t
+s&@top_srcdir@&$ac_top_srcdir&;t t
+s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
+s&@builddir@&$ac_builddir&;t t
+s&@abs_builddir@&$ac_abs_builddir&;t t
+s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
+s&@INSTALL@&$ac_INSTALL&;t t
+$ac_datarootdir_hack
+"
+eval sed \"\$ac_sed_extra\" "$ac_file_inputs" |
+if $ac_cs_awk_getline; then
+  $AWK -f "$ac_tmp/subs.awk"
+else
+  $AWK -f "$ac_tmp/subs.awk" | $SHELL
+fi \
+  >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+
+test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
+      "$ac_tmp/out"`; test -z "$ac_out"; } &&
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined" >&5
+$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined" >&2;}
+
+  rm -f "$ac_tmp/stdin"
+  case $ac_file in
+  -) cat "$ac_tmp/out" && rm -f "$ac_tmp/out";;
+  *) rm -f "$ac_file" && mv "$ac_tmp/out" "$ac_file";;
+  esac \
+  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+ ;;
+  :H)
+  #
+  # CONFIG_HEADER
+  #
+  if test x"$ac_file" != x-; then
+    {
+      $as_echo "/* $configure_input  */" \
+      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs"
+    } >"$ac_tmp/config.h" \
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+    if diff "$ac_file" "$ac_tmp/config.h" >/dev/null 2>&1; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
+$as_echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      rm -f "$ac_file"
+      mv "$ac_tmp/config.h" "$ac_file" \
+	|| as_fn_error $? "could not create $ac_file" "$LINENO" 5
+    fi
+  else
+    $as_echo "/* $configure_input  */" \
+      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs" \
+      || as_fn_error $? "could not create -" "$LINENO" 5
+  fi
+ ;;
+
+  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
+$as_echo "$as_me: executing $ac_file commands" >&6;}
+ ;;
+  esac
+
+
+  case $ac_file$ac_mode in
+    "depfiles":C) test x"$AMDEP_TRUE" != x"" || for mf in $CONFIG_FILES; do
+  # Strip MF so we end up with the name of the file.
+  mf=`echo "$mf" | sed -e 's/:.*$//'`
+  # Check whether this is an Automake generated Makefile or not.
+  # We used to match only the files named `Makefile.in', but
+  # some people rename them; so instead we look at the file content.
+  # Grep'ing the first line is not enough: some people post-process
+  # each Makefile.in and add a new line on top of each file to say so.
+  # So let's grep whole file.
+  if grep '^#.*generated by automake' $mf > /dev/null 2>&1; then
+    dirpart=`$as_dirname -- "$mf" ||
+$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$mf" : 'X\(//\)[^/]' \| \
+	 X"$mf" : 'X\(//\)$' \| \
+	 X"$mf" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$mf" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  else
+    continue
+  fi
+  # Extract the definition of DEPDIR, am__include, and am__quote
+  # from the Makefile without running `make'.
+  DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+  test -z "$DEPDIR" && continue
+  am__include=`sed -n 's/^am__include = //p' < "$mf"`
+  test -z "am__include" && continue
+  am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+  # When using ansi2knr, U may be empty or an underscore; expand it
+  U=`sed -n 's/^U = //p' < "$mf"`
+  # Find all dependency output files, they are included files with
+  # $(DEPDIR) in their names.  We invoke sed twice because it is the
+  # simplest approach to changing $(DEPDIR) to its actual value in the
+  # expansion.
+  for file in `sed -n "
+    s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+       sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+    # Make sure the directory exists.
+    test -f "$dirpart/$file" && continue
+    fdir=`$as_dirname -- "$file" ||
+$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$file" : 'X\(//\)[^/]' \| \
+	 X"$file" : 'X\(//\)$' \| \
+	 X"$file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+    as_dir=$dirpart/$fdir; as_fn_mkdir_p
+    # echo "creating $dirpart/$file"
+    echo '# dummy' > "$dirpart/$file"
+  done
+done
+ ;;
+    "Makefile":F) ac_file=Makefile . ${libgloss_topdir}/config-ml.in ;;
+
+  esac
+done # for ac_tag
+
+
+as_fn_exit 0
+_ACEOF
+ac_clean_files=$ac_clean_files_save
+
+test $ac_write_fail = 0 ||
+  as_fn_error $? "write failure creating $CONFIG_STATUS" "$LINENO" 5
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || as_fn_exit 1
+fi
+if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
+fi
+
+
+
diff --git a/libgloss/libsysbase/configure.in b/libgloss/libsysbase/configure.in
new file mode 100644
index 0000000..da85a3f
--- /dev/null
+++ b/libgloss/libsysbase/configure.in
@@ -0,0 +1,202 @@
+# Copyright (c) 1995, 1996 Cygnus Support
+#
+# The authors hereby grant permission to use, copy, modify, distribute,
+# and license this software and its documentation for any purpose, provided
+# that existing copyright notices are retained in all copies and that this
+# notice is included verbatim in any distributions. No written agreement,
+# license, or royalty fee is required for any of the authorized uses.
+# Modifications to this software may be copyrighted by their authors
+# and need not follow the licensing terms described here, provided that
+# the new terms are clearly indicated on the first page of each file where
+# they apply.
+#
+# Process this file with autoconf to produce a configure script.
+#
+AC_PREREQ(2.59)
+AC_INIT(close.c)
+AC_CONFIG_HEADER(config.h)
+
+if test "${enable_shared}" = "yes" ; then
+    echo "Shared libraries not supported for cross compiling, ignored"
+fi
+
+if test "$srcdir" = "." ; then
+  if test "${with_target_subdir}" != "." ; then
+    libgloss_topdir="${srcdir}/${with_multisrctop}../../.."
+  else
+    libgloss_topdir="${srcdir}/${with_multisrctop}../.."
+  fi
+else
+  libgloss_topdir="${srcdir}/../.."
+fi
+AC_CONFIG_AUX_DIR($libgloss_topdir)
+
+AC_CANONICAL_SYSTEM
+AC_ARG_PROGRAM
+
+AC_PROG_INSTALL
+
+AC_DEFINE(HAVE_GNU_LD)
+dnl Make sure syscall names match those being used by newlib
+case "${target}" in
+  *-*-cygwin*)
+	;;
+  a29k-amd-udi)
+	;;
+  aarch64-*-elf)
+  AC_DEFINE(REENTRANT_SYSCALLS_PROVIDED)
+  ;;
+  arc-*-*)
+	;;
+  arm-*-eabi)
+	AC_DEFINE(REENTRANT_SYSCALLS_PROVIDED)
+	;;
+  arm*-*-*)
+	;;
+  bfin-*-*)
+	;;
+  cris-*-* | crisv32-*-*)
+	;;
+  d10v*)
+	;;
+  h8300*-*-*)
+	;;
+  h8500-*-*)
+	;;
+  i[3456]86-*-sco*)
+	;;
+  lm32-*-*)
+	;;
+  m32r-*-*)
+	;;
+  mn10?00-*-*)
+	;;
+  powerpcle-*-pe)
+	;;
+  sh*-*-*)
+	;;
+  sparc-sun-sunos*)
+	;;
+  sparc64-*-*)
+	;;
+  v850*-*-*)
+	;;
+  w65-*-*)
+	;;
+  xstormy16-*-*)
+	;;
+  z8k-*-*)
+	;;
+  *)
+	AC_DEFINE(MISSING_SYSCALL_NAMES)
+	;;
+esac
+
+dnl Make sure we know if elf format used
+case "${target}" in
+  *-*-elf)
+        AC_DEFINE(HAVE_ELF)
+
+        AC_CACHE_CHECK([for .previous assembler directive],
+                         libc_cv_asm_previous_directive, [dnl
+        libc_cv_asm_previous_directive=no
+        cat > conftest.s <<EOF
+.section foo_section
+.previous
+EOF
+        if AC_TRY_COMMAND(${CC-cc} -c $CFLAGS conftest.s 1>&AC_FD_CC); then
+          libc_cv_asm_previous_directive=yes
+        fi
+        rm -f conftest*])
+
+	if test "x${libc_cv_asm_previous_directive}" = "xyes"; then
+          AC_DEFINE(HAVE_ASM_PREVIOUS_DIRECTIVE)
+	fi
+
+        AC_CACHE_CHECK([for .popsection assembler directive],
+                         libc_cv_asm_popsection_directive, [dnl
+        libc_cv_asm_popsection_directive=no
+        cat > conftest.s <<EOF
+.pushsection foo_section
+.popsection
+EOF
+        if AC_TRY_COMMAND(${CC-cc} -c $CFLAGS conftest.s 1>&AC_FD_CC); then
+          libc_cv_asm_popsection_directive=yes
+        fi
+        rm -f conftest*])
+
+	if test "x${libc_cv_asm_popsection_directive}" = "xyes"; then
+          AC_DEFINE(HAVE_ASM_POPSECTION_DIRECTIVE)
+	fi
+
+        AC_CACHE_CHECK([for section attributes],
+                         libc_cv_section_attributes, [dnl
+        libc_cv_section_attributes=no
+        cat > conftest.c <<EOF
+int secttest __attribute__ ((section (".gnu.warning.secttest"))) = 10;
+int main() {}
+EOF
+        if AC_TRY_COMMAND(${CC-cc} -c $CFLAGS conftest.c 1>&AC_FD_CC); then
+          libc_cv_section_attributes=yes
+        fi
+        rm -f conftest*])
+	if test "x${libc_cv_section_attributes}" = "xyes"; then
+          AC_DEFINE(HAVE_SECTION_ATTRIBUTES)
+	fi
+        ;;
+esac
+
+AC_CACHE_CHECK([for symbol prefix], libc_cv_symbol_prefix, [dnl
+cat > conftest.c <<\EOF
+foo () { }
+EOF
+dnl
+libc_cv_symbol_prefix=none
+if AC_TRY_COMMAND([${CC-cc} -S conftest.c -o - | fgrep "\$foo" > /dev/null]);
+then
+  libc_cv_symbol_prefix='$'
+else
+  if AC_TRY_COMMAND([${CC-cc} -S conftest.c -o - | fgrep "_foo" > /dev/null]);
+  then
+    libc_cv_symbol_prefix=_
+  fi
+fi
+rm -f conftest* ])
+if test $libc_cv_symbol_prefix != none; then
+  AC_DEFINE_UNQUOTED(__SYMBOL_PREFIX, "$libc_cv_symbol_prefix")
+else
+  AC_DEFINE(__SYMBOL_PREFIX, "")
+fi
+
+LIB_AC_PROG_CC
+AS=${AS-as}
+AC_SUBST(AS)
+AR=${AR-ar}
+AC_SUBST(AR)
+LD=${LD-ld}
+AC_SUBST(LD)
+AC_PROG_RANLIB
+LIB_AM_PROG_AS
+
+host_makefile_frag=${srcdir}/../config/default.mh
+
+dnl We have to assign the same value to other variables because autoconf
+dnl doesn't provide a mechanism to substitute a replacement keyword with
+dnl arbitrary data or pathnames.
+dnl
+host_makefile_frag_path=$host_makefile_frag
+AC_SUBST(host_makefile_frag_path)
+AC_SUBST_FILE(host_makefile_frag)
+
+AC_CONFIG_FILES(Makefile,
+ac_file=Makefile . ${libgloss_topdir}/config-ml.in,
+srcdir=${srcdir}
+target=${target}
+with_multisubdir=${with_multisubdir}
+ac_configure_args="${ac_configure_args} --enable-multilib"
+CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
+libgloss_topdir=${libgloss_topdir}
+)
+AC_OUTPUT
+
+
diff --git a/libgloss/libsysbase/dirent.c b/libgloss/libsysbase/dirent.c
new file mode 100644
index 0000000..7d1f454
--- /dev/null
+++ b/libgloss/libsysbase/dirent.c
@@ -0,0 +1,256 @@
+#include <malloc.h>
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <limits.h>
+#include <sys/param.h>
+#include <sys/dirent.h>
+#include <sys/iosupport.h>
+
+static DIR_ITER * __diropen (const char *path) {
+	struct _reent *r = _REENT;
+	DIR_ITER *handle = NULL;
+	DIR_ITER *dir = NULL;
+	int dev;
+
+	dev = FindDevice(path);
+
+	if(dev!=-1) {
+		if(devoptab_list[dev]->diropen_r) {
+
+			r->deviceData = devoptab_list[dev]->deviceData;
+
+			handle = (DIR_ITER *)malloc( sizeof(DIR_ITER) + devoptab_list[dev]->dirStateSize );
+
+			if ( NULL != handle ) {
+				handle->device = dev;
+				handle->dirStruct = ((void *)handle) + sizeof(DIR_ITER);
+
+				dir = devoptab_list[dev]->diropen_r(r, handle, path);
+
+				if ( dir == NULL ) {
+					free (handle);
+					handle = NULL;
+				}
+			} else {
+				r->_errno = ENOSR;
+				handle = NULL;
+			}
+		} else {
+			r->_errno = ENOSYS;
+		}
+	} else {
+		r->_errno = ENODEV;
+	}
+
+	return handle;
+}
+
+static int __dirreset (DIR_ITER *dirState) {
+	struct _reent *r = _REENT;
+	int ret = -1;
+	int dev = 0;
+
+	if (dirState != NULL) {
+		dev = dirState->device;
+
+		if(devoptab_list[dev]->dirreset_r) {
+			r->deviceData = devoptab_list[dev]->deviceData;
+			ret = devoptab_list[dev]->dirreset_r(r, dirState);
+		} else {
+			r->_errno = ENOSYS;
+		}
+	}
+	return ret;
+}
+
+static int __dirnext (DIR_ITER *dirState, char *filename, struct stat *filestat) {
+	struct _reent *r = _REENT;
+	int ret = -1;
+	int dev = 0;
+
+	if (dirState != NULL) {
+		dev = dirState->device;
+
+		if(devoptab_list[dev]->dirnext_r) {
+			r->deviceData = devoptab_list[dev]->deviceData;
+			ret = devoptab_list[dev]->dirnext_r(r, dirState, filename, filestat);
+		} else {
+			r->_errno = ENOSYS;
+		}
+	}
+	return ret;
+}
+
+static int __dirclose (DIR_ITER *dirState) {
+	struct _reent *r = _REENT;
+	int ret = -1;
+	int dev = 0;
+
+	if (dirState != NULL) {
+		dev = dirState->device;
+
+		if (devoptab_list[dev]->dirclose_r) {
+			r->deviceData = devoptab_list[dev]->deviceData;
+			ret = devoptab_list[dev]->dirclose_r (r, dirState);
+		} else {
+			r->_errno = ENOSYS;
+		}
+
+		free (dirState);
+	}
+	return ret;
+}
+
+DIR* opendir (const char *dirname) {
+	DIR* dirp = malloc (sizeof(DIR));
+	if (!dirp) {
+		errno = ENOMEM;
+		return NULL;
+	}
+
+	dirp->dirData = __diropen (dirname);
+	if (!dirp->dirData) {
+		free (dirp);
+		return NULL;
+	}
+
+	dirp->position = 0;	// 0th position means no file name has been returned yet
+	dirp->fileData.d_ino = -1;
+	dirp->fileData.d_name[0] = '\0';
+
+	return dirp;
+}
+
+
+int closedir (DIR *dirp) {
+	int res;
+
+	if (!dirp) {
+		errno = EBADF;
+		return -1;
+	}
+
+	res = __dirclose (dirp->dirData);
+	free (dirp);
+	return res;
+}
+
+
+struct dirent* readdir (DIR *dirp) {
+	struct stat st;
+	char filename[NAME_MAX];
+	int res;
+	int olderrno = errno;
+
+	if (!dirp) {
+		errno = EBADF;
+		return NULL;
+	}
+
+	res = __dirnext (dirp->dirData, filename, &st);
+
+	if (res < 0) {
+		if (errno == ENOENT) {
+			// errno == ENONENT set by dirnext means it's end of directory
+			// But readdir should not touch errno in case of dir end
+			errno = olderrno;
+		}
+		return NULL;
+	}
+
+	// We've moved forward in the directory
+	dirp->position += 1;
+
+	if (strnlen(filename, NAME_MAX) >= sizeof(dirp->fileData.d_name)) {
+		errno = EOVERFLOW;
+		return NULL;
+	}
+
+	strncpy (dirp->fileData.d_name, filename, sizeof(dirp->fileData.d_name));
+	dirp->fileData.d_ino = st.st_ino;
+	dirp->fileData.d_type = S_ISDIR(st.st_mode)?DT_DIR:DT_REG;
+
+	return &(dirp->fileData);
+}
+
+
+int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result) {
+	struct stat st;
+	char filename[NAME_MAX];
+	int res;
+
+	if (!dirp) {
+		return EBADF;
+	}
+
+	res = __dirnext (dirp->dirData, filename, &st);
+
+	if (res < 0) {
+		res = errno;
+		*result = NULL;
+		if (errno == ENOENT) {
+			// errno == ENONENT set by dirnext means it's end of directory
+			// But readdir should not touch errno in case of dir end
+			res = 0;
+		}
+		return res;
+	}
+
+	// We've moved forward in the directory
+	dirp->position += 1;
+
+	if (strnlen(filename, NAME_MAX) >= sizeof(entry->d_name)) {
+		errno = EOVERFLOW;
+		return EOVERFLOW;
+	}
+
+	strncpy (entry->d_name, filename, sizeof(entry->d_name));
+	entry->d_ino = st.st_ino;
+	entry->d_type = S_ISDIR(st.st_mode)?DT_DIR:DT_REG;
+
+	*result = entry;
+	return 0;
+}
+
+
+void rewinddir (DIR *dirp) {
+	if (!dirp) {
+		return;
+	}
+
+	__dirreset (dirp->dirData);
+	dirp->position = 0;
+}
+
+
+void seekdir(DIR *dirp, long int loc) {
+	char filename[NAME_MAX];
+
+	if (!dirp || loc < 0) {
+		return;
+	}
+
+	if (dirp->position > loc) {
+		// The entry we want is before the one we have,
+		// so we have to start again from the begining
+		__dirreset (dirp->dirData);
+		dirp->position = 0;
+	}
+
+	// Keep reading entries until we reach the one we want
+	while ((dirp->position < loc) &&
+		   (__dirnext (dirp->dirData, filename, NULL) >= 0))
+	{
+		dirp->position += 1;
+	}
+}
+
+
+long int telldir(DIR *dirp) {
+	if (!dirp) {
+		return -1;
+	}
+
+	return dirp->position;
+}
diff --git a/libgloss/libsysbase/environ.c b/libgloss/libsysbase/environ.c
new file mode 100644
index 0000000..1c485b2
--- /dev/null
+++ b/libgloss/libsysbase/environ.c
@@ -0,0 +1,6 @@
+/*
+ * Version of environ for no OS.
+ */
+
+char *__env[1] = { 0 };
+char **environ = __env;
diff --git a/libgloss/libsysbase/execve.c b/libgloss/libsysbase/execve.c
new file mode 100644
index 0000000..82e7013
--- /dev/null
+++ b/libgloss/libsysbase/execve.c
@@ -0,0 +1,30 @@
+/*
+ * Stub version of execve.
+ */
+
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+//---------------------------------------------------------------------------------
+int _execve_r(
+        struct _reent *r,
+        char  *name,
+        char **argv,
+        char **env) {
+//---------------------------------------------------------------------------------
+#else
+//---------------------------------------------------------------------------------
+int _execve(
+        char  *name,
+        char **argv,
+        char **env) {
+//---------------------------------------------------------------------------------
+	struct _reent *r = _REENT;
+#endif
+	r->_errno = ENOSYS;
+	return -1;
+}
+
diff --git a/libgloss/libsysbase/fchmod.c b/libgloss/libsysbase/fchmod.c
new file mode 100644
index 0000000..5c5831c
--- /dev/null
+++ b/libgloss/libsysbase/fchmod.c
@@ -0,0 +1,31 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/iosupport.h>
+#include <errno.h>
+
+#include <sys/iosupport.h>
+
+int fchmod(int fd, mode_t mode) {
+	int	ret = -1, dev;
+	struct _reent *r = _REENT;
+
+	if(fd!=-1) {
+
+		__handle *handle = __get_handle(fd);
+
+		if ( handle != NULL) {
+
+			dev = handle->device;
+
+			if(devoptab_list[dev]->fchmod_r) {
+				r->deviceData = devoptab_list[dev]->deviceData;
+				ret = devoptab_list[dev]->fchmod_r(r,handle->fileStruct,mode);
+			} else
+				r->_errno=ENOSYS;
+		}
+	}
+	return ret;
+}
diff --git a/libgloss/libsysbase/flock.c b/libgloss/libsysbase/flock.c
new file mode 100644
index 0000000..c6b8c92
--- /dev/null
+++ b/libgloss/libsysbase/flock.c
@@ -0,0 +1,21 @@
+#include <config.h>
+#include <_ansi.h>
+#include <_syslist.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#ifndef REENTRANT_SYSCALLS_PROVIDED
+#include <reent.h>
+#endif
+#include <errno.h>
+#include <sys/lock.h>
+
+void __flockfile(FILE *fp)
+{
+	__lock_acquire_recursive(*(_LOCK_RECURSIVE_T*)&fp->_lock);
+}
+
+void __funlockfile(FILE *fp)
+{
+	__lock_release_recursive(*(_LOCK_RECURSIVE_T*)&fp->_lock);
+}
diff --git a/libgloss/libsysbase/fnmatch.c b/libgloss/libsysbase/fnmatch.c
new file mode 100644
index 0000000..893b662
--- /dev/null
+++ b/libgloss/libsysbase/fnmatch.c
@@ -0,0 +1,201 @@
+/*
+ * Copyright (c) 1989, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Guido van Rossum.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * From FreeBSD fnmatch.c 1.11
+ * $Id: fnmatch.c,v 1.3 1997/08/19 02:34:30 jdp Exp $
+ */
+
+#define _GNU_SOURCE
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static char sccsid[] = "@(#)fnmatch.c	8.2 (Berkeley) 4/16/94";
+#endif /* LIBC_SCCS and not lint */
+
+/*
+ * Function fnmatch() as specified in POSIX 1003.2-1992, section B.6.
+ * Compares a filename or pathname to a pattern.
+ */
+
+#include <ctype.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "fnmatch.h"
+
+#define	EOS	'\0'
+
+static const char *rangematch(const char *, char, int);
+
+int
+fnmatch(const char *pattern, const char *string, int flags)
+{
+	const char *stringstart;
+	char c, test;
+
+	for (stringstart = string;;)
+		switch (c = *pattern++) {
+		case EOS:
+			if ((flags & FNM_LEADING_DIR) && *string == '/')
+				return (0);
+			return (*string == EOS ? 0 : FNM_NOMATCH);
+		case '?':
+			if (*string == EOS)
+				return (FNM_NOMATCH);
+			if (*string == '/' && (flags & FNM_PATHNAME))
+				return (FNM_NOMATCH);
+			if (*string == '.' && (flags & FNM_PERIOD) &&
+			    (string == stringstart ||
+			    ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
+				return (FNM_NOMATCH);
+			++string;
+			break;
+		case '*':
+			c = *pattern;
+			/* Collapse multiple stars. */
+			while (c == '*')
+				c = *++pattern;
+
+			if (*string == '.' && (flags & FNM_PERIOD) &&
+			    (string == stringstart ||
+			    ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
+				return (FNM_NOMATCH);
+
+			/* Optimize for pattern with * at end or before /. */
+			if (c == EOS)
+				if (flags & FNM_PATHNAME)
+					return ((flags & FNM_LEADING_DIR) ||
+					    strchr(string, '/') == NULL ?
+					    0 : FNM_NOMATCH);
+				else
+					return (0);
+			else if (c == '/' && flags & FNM_PATHNAME) {
+				if ((string = strchr(string, '/')) == NULL)
+					return (FNM_NOMATCH);
+				break;
+			}
+
+			/* General case, use recursion. */
+			while ((test = *string) != EOS) {
+				if (!fnmatch(pattern, string, flags & ~FNM_PERIOD))
+					return (0);
+				if (test == '/' && flags & FNM_PATHNAME)
+					break;
+				++string;
+			}
+			return (FNM_NOMATCH);
+		case '[':
+			if (*string == EOS)
+				return (FNM_NOMATCH);
+			if (*string == '/' && flags & FNM_PATHNAME)
+				return (FNM_NOMATCH);
+			if ((pattern =
+			    rangematch(pattern, *string, flags)) == NULL)
+				return (FNM_NOMATCH);
+			++string;
+			break;
+		case '\\':
+			if (!(flags & FNM_NOESCAPE)) {
+				if ((c = *pattern++) == EOS) {
+					c = '\\';
+					--pattern;
+				}
+			}
+			/* FALLTHROUGH */
+		default:
+			if (c == *string)
+				;
+			else if ((flags & FNM_CASEFOLD) &&
+				 (tolower((unsigned char)c) ==
+				  tolower((unsigned char)*string)))
+				;
+			else if ((flags & FNM_PREFIX_DIRS) && *string == EOS &&
+			     ((c == '/' && string != stringstart) ||
+			     (string == stringstart+1 && *stringstart == '/')))
+				return (0);
+			else
+				return (FNM_NOMATCH);
+			string++;
+			break;
+		}
+	/* NOTREACHED */
+}
+
+static const char *
+rangematch(const char *pattern, char test, int flags)
+{
+	int negate, ok;
+	char c, c2;
+
+	/*
+	 * A bracket expression starting with an unquoted circumflex
+	 * character produces unspecified results (IEEE 1003.2-1992,
+	 * 3.13.2).  This implementation treats it like '!', for
+	 * consistency with the regular expression syntax.
+	 * J.T. Conklin (conklin@ngai.kaleida.com)
+	 */
+	if ( (negate = (*pattern == '!' || *pattern == '^')) )
+		++pattern;
+
+	if (flags & FNM_CASEFOLD)
+		test = tolower((unsigned char)test);
+
+	for (ok = 0; (c = *pattern++) != ']';) {
+		if (c == '\\' && !(flags & FNM_NOESCAPE))
+			c = *pattern++;
+		if (c == EOS)
+			return (NULL);
+
+		if (flags & FNM_CASEFOLD)
+			c = tolower((unsigned char)c);
+
+		if (*pattern == '-'
+		    && (c2 = *(pattern+1)) != EOS && c2 != ']') {
+			pattern += 2;
+			if (c2 == '\\' && !(flags & FNM_NOESCAPE))
+				c2 = *pattern++;
+			if (c2 == EOS)
+				return (NULL);
+
+			if (flags & FNM_CASEFOLD)
+				c2 = tolower((unsigned char)c2);
+
+			if ((unsigned char)c <= (unsigned char)test &&
+			    (unsigned char)test <= (unsigned char)c2)
+				ok = 1;
+		} else if (c == test)
+			ok = 1;
+	}
+	return (ok == negate ? NULL : pattern);
+}
diff --git a/libgloss/libsysbase/fork.c b/libgloss/libsysbase/fork.c
new file mode 100644
index 0000000..efb6a34
--- /dev/null
+++ b/libgloss/libsysbase/fork.c
@@ -0,0 +1,21 @@
+/*
+ * Stub version of fork.
+ */
+
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+//---------------------------------------------------------------------------------
+int _fork_r (struct _reent * r) {
+//---------------------------------------------------------------------------------
+#else
+//---------------------------------------------------------------------------------
+int _fork(void) {
+//---------------------------------------------------------------------------------
+	struct _reent *r = _REENT;
+#endif
+	r->_errno = ENOSYS;
+	return -1;
+}
diff --git a/libgloss/libsysbase/fstat.c b/libgloss/libsysbase/fstat.c
new file mode 100644
index 0000000..e32b067
--- /dev/null
+++ b/libgloss/libsysbase/fstat.c
@@ -0,0 +1,44 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <sys/iosupport.h>
+
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+//---------------------------------------------------------------------------------
+int _fstat_r(
+			struct _reent * r,
+			int fileDesc,
+			struct stat *st) {
+//---------------------------------------------------------------------------------
+#else
+//---------------------------------------------------------------------------------
+int _fstat(
+			int fileDesc,
+			struct stat *st) {
+//---------------------------------------------------------------------------------
+	struct _reent *r = _REENT;
+#endif
+	int ret = -1;
+	unsigned int dev = 0;
+
+	__handle * handle = NULL;
+
+	if(fileDesc!=-1) {
+		handle = __get_handle(fileDesc);
+
+		if ( NULL == handle ) return ret;
+
+		dev = handle->device;
+
+		if(devoptab_list[dev]->fstat_r) {
+			r->deviceData = devoptab_list[dev]->deviceData;
+			ret = devoptab_list[dev]->fstat_r(r,handle->fileStruct,st);
+		} else {
+			r->_errno = ENOSYS;
+		}
+	}
+	return ret;
+}
diff --git a/libgloss/libsysbase/fsync.c b/libgloss/libsysbase/fsync.c
new file mode 100644
index 0000000..fb06cb6
--- /dev/null
+++ b/libgloss/libsysbase/fsync.c
@@ -0,0 +1,34 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+
+#include <sys/iosupport.h>
+
+int fsync(int   fileDesc ) {
+	int ret = -1;
+	unsigned int dev = 0;
+	unsigned int fd = -1;
+	struct _reent *r = _REENT;
+
+	__handle * handle;
+
+	handle = __get_handle(fileDesc);
+
+	if ( NULL == handle ) {
+		errno = EINVAL;
+		return ret;
+	}
+
+	dev = handle->device;
+
+	if(devoptab_list[dev]->fsync_r) {
+		r->deviceData = devoptab_list[dev]->deviceData;
+		ret = devoptab_list[dev]->fsync_r(r, handle->fileStruct);
+	} else
+		r->_errno=ENOSYS;
+
+	return ret;
+}
diff --git a/libgloss/libsysbase/ftruncate.c b/libgloss/libsysbase/ftruncate.c
new file mode 100644
index 0000000..2cc03a3
--- /dev/null
+++ b/libgloss/libsysbase/ftruncate.c
@@ -0,0 +1,34 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+
+#include <sys/iosupport.h>
+
+int ftruncate(int fileDesc, off_t   len) {
+	int ret = -1;
+	unsigned int dev = 0;
+	unsigned int fd = -1;
+	struct _reent *r = _REENT;
+
+	__handle * handle;
+
+	handle = __get_handle(fileDesc);
+
+	if ( NULL == handle ) {
+		r->_errno = EINVAL;
+		return ret;
+	}
+
+	dev = handle->device;
+
+	if(devoptab_list[dev]->ftruncate_r) {
+		r->deviceData = devoptab_list[dev]->deviceData;
+		ret = devoptab_list[dev]->ftruncate_r(r, handle->fileStruct, len);
+	} else
+		r->_errno=ENOSYS;
+
+	return ret;
+}
diff --git a/libgloss/libsysbase/getpid.c b/libgloss/libsysbase/getpid.c
new file mode 100644
index 0000000..fdce14b
--- /dev/null
+++ b/libgloss/libsysbase/getpid.c
@@ -0,0 +1,19 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+//---------------------------------------------------------------------------------
+int _getpid_r(struct _reent *ptr) {
+//---------------------------------------------------------------------------------
+#else
+//---------------------------------------------------------------------------------
+int _getpid(void) {
+//---------------------------------------------------------------------------------
+	struct _reent *ptr = _REENT;
+#endif
+	ptr->_errno = ENOSYS;
+	return -1;
+}
+
diff --git a/libgloss/libsysbase/getreent.c b/libgloss/libsysbase/getreent.c
new file mode 100644
index 0000000..a3f1e98
--- /dev/null
+++ b/libgloss/libsysbase/getreent.c
@@ -0,0 +1,20 @@
+
+/* default reentrant pointer when multithread enabled */
+
+#include <_ansi.h>
+#include <reent.h>
+#include <sys/iosupport.h>
+
+#ifdef __getreent
+#undef __getreent
+#endif
+
+struct _reent *__getreent() {
+	if ( __has_syscall(getreent) ) {
+		return __syscall_getreent();
+	} else {
+		return _impure_ptr;
+	}
+}
+
+
diff --git a/libgloss/libsysbase/gettod.c b/libgloss/libsysbase/gettod.c
new file mode 100644
index 0000000..f18c59b
--- /dev/null
+++ b/libgloss/libsysbase/gettod.c
@@ -0,0 +1,34 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/time.h>
+#include <sys/times.h>
+#include <sys/iosupport.h>
+#include <errno.h>
+
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+//---------------------------------------------------------------------------------
+int _gettimeofday_r(
+			struct _reent *ptr,
+			struct timeval *ptimeval,
+			void *ptimezone)
+{
+//---------------------------------------------------------------------------------
+#else
+//---------------------------------------------------------------------------------
+int _gettimeofday(
+        struct timeval  *ptimeval,
+        void *ptimezone)
+{
+//---------------------------------------------------------------------------------
+	struct _reent *ptr = _REENT;
+#endif
+
+	if ( __has_syscall(gettod_r) )
+		return __syscall_gettod_r(ptr, ptimeval, ptimezone);
+
+	ptr->_errno = ENOSYS;
+	return -1;
+
+}
+
diff --git a/libgloss/libsysbase/handle_manager.c b/libgloss/libsysbase/handle_manager.c
new file mode 100644
index 0000000..f3fcc88
--- /dev/null
+++ b/libgloss/libsysbase/handle_manager.c
@@ -0,0 +1,173 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <errno.h>
+
+#include <sys/iosupport.h>
+
+#define MAX_HANDLES 1024
+
+static __handle __stdin_handle  = {0, 1, NULL};
+static __handle __stdout_handle = {1, 1, NULL};
+static __handle __stderr_handle = {2, 1, NULL};
+
+static __handle* handles[MAX_HANDLES] = {
+	&__stdin_handle,
+	&__stdout_handle,
+	&__stderr_handle
+};
+
+__LOCK_INIT(static, __hndl_lock);
+
+void __free_handle(__handle *handle) {
+
+	if ( NULL != handle
+	&& handle != &__stdin_handle
+	&& handle != &__stdout_handle
+	&& handle != &__stderr_handle ) {
+
+		free(handle);
+
+	}
+
+}
+
+void __release_handle(int fd) {
+
+	if ( fd <0 || fd >= MAX_HANDLES ) return;
+
+	__lock_acquire (__hndl_lock);
+
+	__free_handle(handles[fd]);
+	handles[fd] = NULL;
+
+	__lock_release (__hndl_lock);
+
+}
+
+int __alloc_handle(int device) {
+
+	int i, ret = -1;
+
+	__lock_acquire (__hndl_lock);
+
+	for ( i = 0; i < MAX_HANDLES; i++ ) {
+		if ( handles[i] == NULL ) break;
+	}
+
+	size_t size = sizeof(__handle) + devoptab_list[device]->structSize;
+
+	if ( i < MAX_HANDLES ) {
+		handles[i] = malloc(size);
+		__handle *handle = handles[i];
+		if ( NULL != handles[i] ) {
+
+			handles[i]->refcount = 1;
+			ret =  i;
+			handles[i]->device = device;
+			handles[i]->fileStruct = (void *)&handle[1];
+
+		} else {
+
+			errno = ENOMEM;
+
+		}
+	} else {
+
+		errno = ENFILE;
+
+	}
+
+	__lock_release (__hndl_lock);
+
+	return ret;
+}
+
+__handle *__get_handle(int fd) {
+
+	if ( fd < 0 || fd >= MAX_HANDLES ) return NULL;
+
+	return handles[fd];
+
+}
+
+int dup(int oldfd) {
+	int i, ret =-1;
+
+	__lock_acquire (__hndl_lock);
+
+	if (handles[oldfd]==NULL) {
+		__lock_release (__hndl_lock);
+		errno = EBADF;
+		return -1;
+	}
+
+
+	for ( i = 0; i < MAX_HANDLES; i++ ) {
+		if ( handles[i] == NULL ) break;
+	}
+
+	if (i<MAX_HANDLES) {
+		handles[i] = handles[oldfd];
+		handles[oldfd]->refcount++;
+		ret = i;
+	}
+	__lock_release (__hndl_lock);
+
+	return ret;
+
+}
+
+int dup2(int oldfd, int newfd) {
+
+
+	__lock_acquire (__hndl_lock);
+
+	if ( newfd < 0 || newfd >= MAX_HANDLES ||
+
+		 oldfd < 0 || oldfd >= MAX_HANDLES ||
+		 handles[oldfd] == NULL ) {
+
+		__lock_release (__hndl_lock);
+		errno = EBADF;
+
+		return -1;
+	}
+
+	if ( newfd == oldfd ) {
+		__lock_release (__hndl_lock);
+		return newfd;
+	}
+
+
+	__handle *handle = handles[newfd];
+
+	if ( NULL != handle ) {
+
+		handle->refcount--;
+
+	}
+
+	handles[newfd] = handles[oldfd];
+	handles[newfd]->refcount++;
+
+	__lock_release (__hndl_lock);
+
+	if ( NULL != handle ) {
+
+		if (handle->refcount == 0 ) {
+
+			if( devoptab_list[handle->device]->close_r != NULL) {
+
+				devoptab_list[handle->device]->close_r(_REENT,handle->fileStruct);
+
+			} else {
+
+				__free_handle(handle);
+
+			}
+		}
+	}
+
+	return newfd;
+
+}
diff --git a/libgloss/libsysbase/iosupport.c b/libgloss/libsysbase/iosupport.c
new file mode 100644
index 0000000..948c6ef
--- /dev/null
+++ b/libgloss/libsysbase/iosupport.c
@@ -0,0 +1,140 @@
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <sys/iosupport.h>
+
+static int defaultDevice = -1;
+
+//---------------------------------------------------------------------------------
+void setDefaultDevice( int device ) {
+//---------------------------------------------------------------------------------
+
+	if ( device >2 && device <= STD_MAX)
+		defaultDevice = device;
+}
+
+//---------------------------------------------------------------------------------
+static ssize_t null_write(struct _reent *r,void *fd,const char *ptr, size_t len) {
+//---------------------------------------------------------------------------------
+	return len;
+}
+
+//---------------------------------------------------------------------------------
+const devoptab_t dotab_stdnull = {
+//---------------------------------------------------------------------------------
+	"stdnull",	// device name
+	0,			// size of file structure
+	NULL,		// device open
+	NULL,		// device close
+	null_write,	// device write
+	NULL,		// device read
+	NULL,		// device seek
+	NULL,		// device fstat
+	NULL,		// device stat
+	NULL,		// device link
+	NULL,		// device unlink
+	NULL,		// device chdir
+	NULL,		// device rename
+	NULL,		// device mkdir
+	0,		// dirStateSize
+	NULL,		// device diropen_r
+	NULL,		// device dirreset_r
+	NULL,		// device dirnext_r
+	NULL,		// device dirclose_r
+	NULL,		// device statvfs_r
+	NULL,		// device ftruncate_r
+	NULL,		// device fsync_r
+	NULL,		// deviceData
+	NULL,		// chmod_r
+	NULL,		// fchmod_r
+	NULL,		// rmdir_r
+	NULL,		// lstat_r
+	NULL,		// utimes_r
+};
+
+//---------------------------------------------------------------------------------
+const devoptab_t *devoptab_list[STD_MAX] = {
+//---------------------------------------------------------------------------------
+	&dotab_stdnull, &dotab_stdnull, &dotab_stdnull, &dotab_stdnull,
+	&dotab_stdnull, &dotab_stdnull, &dotab_stdnull, &dotab_stdnull,
+	&dotab_stdnull, &dotab_stdnull, &dotab_stdnull, &dotab_stdnull,
+	&dotab_stdnull, &dotab_stdnull, &dotab_stdnull, &dotab_stdnull
+};
+
+//---------------------------------------------------------------------------------
+int FindDevice(const char* name) {
+//---------------------------------------------------------------------------------
+	int i = 0, namelen, dev_namelen, dev = -1;
+	char *separator;
+
+	separator = strchr(name, ':');
+
+	if (separator == NULL) return defaultDevice;
+
+	dev_namelen = separator - name;
+
+	while(i<STD_MAX) {
+		if(devoptab_list[i]) {
+			namelen = strlen(devoptab_list[i]->name);
+			if(dev_namelen == namelen && strncmp(devoptab_list[i]->name,name,namelen)==0 ) {
+				if ( name[namelen] == ':' || (isdigit(name[namelen]) && name[namelen+1] ==':' )) {
+					dev = i;
+					break;
+				}
+			}
+		}
+		i++;
+	}
+
+	return dev;
+}
+
+//---------------------------------------------------------------------------------
+int RemoveDevice( const char* name) {
+//---------------------------------------------------------------------------------
+	int dev = FindDevice(name);
+
+	if ( -1 != dev ) {
+		devoptab_list[dev] = &dotab_stdnull;
+		return 0;
+	}
+
+	return -1;
+
+}
+
+//---------------------------------------------------------------------------------
+int AddDevice( const devoptab_t* device) {
+//---------------------------------------------------------------------------------
+
+	int devnum;
+
+	for ( devnum = 3;devnum <STD_MAX; devnum++ ) {
+
+		if ( (!strcmp(devoptab_list[devnum]->name, device->name) &&
+					strlen(devoptab_list[devnum]->name) == strlen(device->name) ) ||
+			 		!strcmp(devoptab_list[devnum]->name, "stdnull")
+			 )
+			 break;
+	}
+
+	if ( devnum == STD_MAX ) {
+		devnum = -1;
+	} else {
+		devoptab_list[devnum] = device;
+	}
+	return devnum;
+}
+
+//---------------------------------------------------------------------------------
+const devoptab_t* GetDeviceOpTab (const char *name) {
+//---------------------------------------------------------------------------------
+	int dev = FindDevice(name);
+	if (dev >= 0 && dev < STD_MAX) {
+		return devoptab_list[dev];
+	} else {
+		return NULL;
+	}
+}
+
+
diff --git a/libgloss/libsysbase/isatty.c b/libgloss/libsysbase/isatty.c
new file mode 100644
index 0000000..280a457
--- /dev/null
+++ b/libgloss/libsysbase/isatty.c
@@ -0,0 +1,17 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+//---------------------------------------------------------------------------------
+int _isatty_r( struct _reent *ptr, int file) {
+//---------------------------------------------------------------------------------
+#else
+//---------------------------------------------------------------------------------
+int _isatty(int file) {
+//---------------------------------------------------------------------------------
+	struct _reent *ptr = _REENT;
+#endif
+	return 0;
+}
diff --git a/libgloss/libsysbase/kill.c b/libgloss/libsysbase/kill.c
new file mode 100644
index 0000000..13bd0fb
--- /dev/null
+++ b/libgloss/libsysbase/kill.c
@@ -0,0 +1,21 @@
+/*
+ * Stub version of kill.
+ */
+
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+int _kill_r(
+		   struct _reent *ptr,
+           int			 pid,
+           int			 sig) {
+#else
+int _kill(int pid, int sig)	{
+	struct _reent *ptr = _REENT;
+#endif
+  ptr->_errno = ENOSYS;
+  return -1;
+}
diff --git a/libgloss/libsysbase/link.c b/libgloss/libsysbase/link.c
new file mode 100644
index 0000000..162f70f
--- /dev/null
+++ b/libgloss/libsysbase/link.c
@@ -0,0 +1,36 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <reent.h>
+#include <errno.h>
+#include <sys/iosupport.h>
+
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+int _link_r(struct _reent *r, const char *existing, const char *new) {
+#else
+int _link(const char *existing, const char *new) {
+	struct _reent *r = _REENT;
+#endif
+	int ret = -1;
+	int sourceDev = FindDevice(existing);
+	int destDev = FindDevice(new);
+
+	if (sourceDev == -1 || destDev == -1 ) {
+		r->_errno = ENODEV;
+		return ret;
+	}
+
+	if ( sourceDev == destDev) {
+		if (devoptab_list[destDev]->link_r) {
+			r->deviceData = devoptab_list[destDev]->deviceData;
+			ret = devoptab_list[destDev]->link_r( r, existing, new);
+		} else {
+			r->_errno = ENOSYS;
+		}
+	} else {
+		r->_errno = EXDEV;
+	}
+
+	return ret;
+}
+
diff --git a/libgloss/libsysbase/locks.c b/libgloss/libsysbase/locks.c
new file mode 100644
index 0000000..c41d91f
--- /dev/null
+++ b/libgloss/libsysbase/locks.c
@@ -0,0 +1,158 @@
+#include <errno.h>
+#include <sys/iosupport.h>
+#include <sys/time.h>
+
+static int
+timespec_subtract(struct timespec x, struct timespec y, struct timespec *__restrict result)
+{
+	// Perform the carry for the later subtraction by updating y
+	if (x.tv_nsec < y.tv_nsec) {
+		int seconds = (y.tv_nsec - x.tv_nsec) / 1000000000 + 1;
+		y.tv_nsec -= 1000000000 * seconds;
+		y.tv_sec += seconds;
+	}
+	if (x.tv_nsec - y.tv_nsec > 1000000000) {
+		int seconds = (x.tv_nsec - y.tv_nsec) / 1000000000;
+		y.tv_nsec += 1000000000 * seconds;
+		y.tv_sec -= seconds;
+	}
+
+	// Compute the time remaining to wait
+	result->tv_sec = x.tv_sec - y.tv_sec;
+	result->tv_nsec = x.tv_nsec - y.tv_nsec;
+
+	// Return true if result is negative
+	return x.tv_sec < y.tv_sec;
+}
+
+__uint64_t
+timespec2nsec(const struct timespec *__restrict ts)
+{
+	return (__uint64_t)ts->tv_sec * 1000000000 + ts->tv_nsec;
+}
+
+__uint64_t
+abstimespec2nsec(__clockid_t clock_id, const struct timespec *__restrict ts)
+{
+	struct timespec now, diff;
+	clock_gettime(clock_id, &now);
+	if (timespec_subtract(*ts, now, &diff))
+		return 0;
+	return timespec2nsec(&diff);
+}
+
+void __libc_lock_init(_LOCK_T *lock) {
+
+	*lock = __LOCK_INITIALIZER;
+
+}
+
+void __libc_lock_acquire(_LOCK_T *lock ) {
+
+	if ( __has_syscall(lock_acquire) ) {
+		__syscall_lock_acquire(lock);
+	}
+}
+
+int __libc_lock_try_acquire(_LOCK_T *lock ) {
+
+	if ( __has_syscall(lock_acquire) ) {
+		return __syscall_lock_try_acquire(lock);
+	} else {
+		return 0;
+	}
+}
+
+void __libc_lock_release(_LOCK_T *lock ) {
+
+	if ( __has_syscall(lock_release) ) {
+		__syscall_lock_release(lock);
+	}
+}
+
+void __libc_lock_close(_LOCK_T *lock ) {
+
+}
+
+
+
+void __libc_lock_init_recursive(_LOCK_RECURSIVE_T *lock) {
+
+	*lock = __LOCK_INITIALIZER_RECURSIVE;
+
+}
+
+void __libc_lock_acquire_recursive(_LOCK_RECURSIVE_T *lock ) {
+
+	if ( __has_syscall(lock_acquire_recursive) ) {
+		__syscall_lock_acquire_recursive(lock);
+	}
+}
+
+int __libc_lock_try_acquire_recursive(_LOCK_RECURSIVE_T *lock ) {
+
+	if ( __has_syscall(lock_acquire_recursive) ) {
+		return __syscall_lock_try_acquire_recursive(lock);
+	} else {
+		return 0;
+	}
+}
+
+void __libc_lock_release_recursive(_LOCK_RECURSIVE_T *lock ) {
+
+	if ( __has_syscall(lock_release_recursive) ) {
+		__syscall_lock_release_recursive(lock);
+	}
+}
+
+void __libc_lock_close_recursive(_LOCK_RECURSIVE_T *lock ) {
+
+}
+
+
+int __libc_cond_init(_COND_T *cond) {
+
+	*cond = __COND_INITIALIZER;
+
+}
+
+int __libc_cond_signal(_COND_T *cond) {
+
+	if ( __has_syscall(cond_signal) ) {
+		return __syscall_cond_signal(cond);
+	}
+
+	return ENOSYS;
+
+}
+
+int __libc_cond_broadcast(_COND_T *cond) {
+
+	if ( __has_syscall(cond_broadcast) ) {
+		return __syscall_cond_broadcast(cond);
+	}
+
+	return ENOSYS;
+
+}
+
+int __libc_cond_wait(_COND_T *cond, _LOCK_T *lock, uint64_t timeout_ns) {
+
+	if ( __has_syscall(cond_wait) ) {
+		return __syscall_cond_wait(cond, lock, timeout_ns);
+	}
+
+	return ENOSYS;
+
+}
+
+int __libc_cond_wait_recursive(_COND_T *cond, _LOCK_RECURSIVE_T *lock, uint64_t timeout_ns) {
+
+	if ( __has_syscall(cond_wait_recursive) ) {
+		return __syscall_cond_wait_recursive(cond, lock, timeout_ns);
+	}
+
+	return ENOSYS;
+
+}
+
diff --git a/libgloss/libsysbase/lseek.c b/libgloss/libsysbase/lseek.c
new file mode 100644
index 0000000..eb232c8
--- /dev/null
+++ b/libgloss/libsysbase/lseek.c
@@ -0,0 +1,45 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+
+#include <sys/iosupport.h>
+
+#include <sys/iosupport.h>
+
+//---------------------------------------------------------------------------------
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+//---------------------------------------------------------------------------------
+_off_t _lseek_r(struct _reent * r, int fileDesc, _off_t pos, int dir) {
+//---------------------------------------------------------------------------------
+#else
+//---------------------------------------------------------------------------------
+_off_t _lseek(int fileDesc, _off_t pos, int dir) {
+//---------------------------------------------------------------------------------
+	struct _reent *r = _REENT;
+//---------------------------------------------------------------------------------
+#endif
+//---------------------------------------------------------------------------------
+	_off_t ret = -1;
+	unsigned int dev = 0;
+
+	__handle * handle;
+
+	if(fileDesc!=-1) {
+
+		handle = __get_handle(fileDesc);
+
+		if ( NULL == handle ) return ret;
+
+		dev = handle->device;
+
+		if(devoptab_list[dev]->seek_r) {
+			r->deviceData = devoptab_list[dev]->deviceData;
+			ret = devoptab_list[dev]->seek_r( r, handle->fileStruct, pos, dir);
+		} else
+			r->_errno=ENOSYS;
+
+	}
+	return ret;
+
+}
diff --git a/libgloss/libsysbase/lstat.c b/libgloss/libsysbase/lstat.c
new file mode 100644
index 0000000..fc39343
--- /dev/null
+++ b/libgloss/libsysbase/lstat.c
@@ -0,0 +1,31 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/iosupport.h>
+#include <errno.h>
+
+
+//---------------------------------------------------------------------------------
+int lstat (const char *__restrict __path, struct stat *__restrict __buf ) {
+//---------------------------------------------------------------------------------
+	struct _reent *r = _REENT;
+	int dev,ret;
+
+	dev = FindDevice(__path);
+
+	if(dev!=-1) {
+		if (devoptab_list[dev]->lstat_r) {
+			r->deviceData = devoptab_list[dev]->deviceData;
+			ret = devoptab_list[dev]->lstat_r(r,__path,__buf);
+		} else {
+			r->_errno=ENOSYS;
+		}
+	} else {
+		ret = -1;
+		r->_errno = ENODEV;
+	}
+	return ret;
+}
+
diff --git a/libgloss/libsysbase/malloc_vars.c b/libgloss/libsysbase/malloc_vars.c
new file mode 100644
index 0000000..4565909
--- /dev/null
+++ b/libgloss/libsysbase/malloc_vars.c
@@ -0,0 +1,2 @@
+char *fake_heap_end = (char*)0;
+char *fake_heap_start = (char*)0;
diff --git a/libgloss/libsysbase/mkdir.c b/libgloss/libsysbase/mkdir.c
new file mode 100644
index 0000000..19742b7
--- /dev/null
+++ b/libgloss/libsysbase/mkdir.c
@@ -0,0 +1,23 @@
+#include <reent.h>
+#include <sys/iosupport.h>
+#include <errno.h>
+
+int mkdir (const char *path, mode_t mode) {
+	struct _reent *r = _REENT;
+	int ret = -1;
+
+        int dev = FindDevice(path);
+
+        if(dev!=-1) {
+                if(devoptab_list[dev]->mkdir_r) {
+                        r->deviceData = devoptab_list[dev]->deviceData;
+                        ret = devoptab_list[dev]->mkdir_r(r,path,mode);
+                } else {
+                        r->_errno = ENOSYS;
+                }
+        } else {
+                r->_errno =     ENODEV;
+        }
+
+	return ret;
+}
diff --git a/libgloss/libsysbase/nanosleep.c b/libgloss/libsysbase/nanosleep.c
new file mode 100644
index 0000000..a233b9d
--- /dev/null
+++ b/libgloss/libsysbase/nanosleep.c
@@ -0,0 +1,14 @@
+#include <errno.h>
+#include <time.h>
+#include <sys/iosupport.h>
+
+int nanosleep(const struct timespec *req, struct timespec *rem)
+{
+   if ( __has_syscall(nanosleep) ) {
+      return __syscall_nanosleep(req, rem);
+   } else {
+      *rem = *req;
+      errno = ENOSYS;
+      return -1;
+   }
+}
diff --git a/libgloss/libsysbase/open.c b/libgloss/libsysbase/open.c
new file mode 100644
index 0000000..f8d98fd
--- /dev/null
+++ b/libgloss/libsysbase/open.c
@@ -0,0 +1,53 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <string.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <errno.h>
+
+#include <sys/iosupport.h>
+
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+//---------------------------------------------------------------------------------
+int _open_r(struct _reent * r, const char *file, int flags, int mode) {
+//---------------------------------------------------------------------------------
+#else
+//---------------------------------------------------------------------------------
+int _open(struct _reent * r, const char *file, int flags, int mode) {
+//---------------------------------------------------------------------------------
+	struct _reent *r = _REENT;
+#endif
+	__handle *handle;
+	int dev, fd, ret;
+
+	dev = FindDevice(file);
+
+	fd = -1;
+	if(dev!=-1) {
+		if (devoptab_list[dev]->open_r) {
+			fd = __alloc_handle(dev);
+
+			if ( -1 != fd ) {
+				handle = __get_handle(fd);
+
+				r->deviceData = devoptab_list[dev]->deviceData;
+
+				ret = devoptab_list[dev]->open_r(r, handle->fileStruct, file, flags, mode);
+
+				if ( ret == -1 ) {
+					__release_handle(fd);
+					fd = -1;
+				}
+			} else {
+				r->_errno = ENOSR;
+			}
+		} else {
+			r->_errno=ENOSYS;
+		}
+	} else {
+		r->_errno = ENOSYS;
+	}
+
+	return fd;
+}
diff --git a/libgloss/libsysbase/pthread.c b/libgloss/libsysbase/pthread.c
new file mode 100755
index 0000000..ff84cd3
--- /dev/null
+++ b/libgloss/libsysbase/pthread.c
@@ -0,0 +1,1083 @@
+#include <pthread.h>
+#include <semaphore.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/time.h>
+#include <sys/iosupport.h>
+
+static inline uint64_t
+__pthread_abstime_to_ns (const struct timespec *__abstime)
+{
+	return __abstime ? abstimespec2nsec(CLOCK_REALTIME, __abstime) : UINT64_MAX;
+}
+
+int
+pthread_atfork (void (*prepare)(void), void (*parent)(void), void (*child)(void))
+{
+	return ENOSYS; // Unsupported
+}
+
+//-----------------------------------------------------------------------------
+// Mutex attributes
+//-----------------------------------------------------------------------------
+
+int
+pthread_mutexattr_init (pthread_mutexattr_t *__attr)
+{
+	if (!__attr)
+		return EINVAL;
+	__attr->type = PTHREAD_MUTEX_NORMAL;
+	return 0;
+}
+
+int
+pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
+{
+	if (!__attr)
+		return EINVAL;
+	return 0;
+}
+
+int
+pthread_mutexattr_getpshared (const pthread_mutexattr_t *__attr, int *__pshared)
+{
+	return ENOSYS;
+}
+
+int
+pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr, int __pshared)
+{
+	return ENOSYS;
+}
+
+int
+pthread_mutexattr_gettype (const pthread_mutexattr_t *__attr, int *__kind)
+{
+	if (!__attr || !__kind)
+		return EINVAL;
+	*__kind = __attr->type;
+	return 0;
+}
+
+int
+pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
+{
+	if (!__attr)
+		return EINVAL;
+	__attr->type = __kind;
+	return 0;
+}
+
+//-----------------------------------------------------------------------------
+// Mutex
+//-----------------------------------------------------------------------------
+
+int
+pthread_mutex_init (pthread_mutex_t *__mutex, const pthread_mutexattr_t *__attr)
+{
+	pthread_mutexattr_t __default;
+	if (!__attr) {
+		pthread_mutexattr_init(&__default);
+		__attr = &__default;
+	}
+	if (!__mutex)
+		return EINVAL;
+
+	__mutex->type = __attr->type;
+	switch (__mutex->type) {
+		case PTHREAD_MUTEX_NORMAL:
+		case PTHREAD_MUTEX_ERRORCHECK:
+		case PTHREAD_MUTEX_DEFAULT:
+			__mutex->normal = __LOCK_INITIALIZER;
+			break;
+		case PTHREAD_MUTEX_RECURSIVE:
+			__mutex->recursive = __LOCK_INITIALIZER_RECURSIVE;
+			break;
+		default:
+			return EINVAL;
+	}
+
+	return 0;
+}
+
+int
+pthread_mutex_destroy (pthread_mutex_t *__mutex)
+{
+	if (!__mutex)
+		return EINVAL;
+	return 0;
+}
+
+int
+pthread_mutex_lock (pthread_mutex_t *__mutex)
+{
+	if (!__mutex)
+		return EINVAL;
+
+	switch (__mutex->type) {
+		case PTHREAD_MUTEX_NORMAL:
+		case PTHREAD_MUTEX_ERRORCHECK: // todo: error check
+		case PTHREAD_MUTEX_DEFAULT:
+			__lock_acquire(__mutex->normal);
+			break;
+		case PTHREAD_MUTEX_RECURSIVE:
+			__lock_acquire_recursive(__mutex->recursive);
+			break;
+		default:
+			return EINVAL;
+	}
+
+	return 0;
+}
+
+int
+pthread_mutex_trylock (pthread_mutex_t *__mutex)
+{
+	if (!__mutex)
+		return EINVAL;
+
+	int rc = 0;
+	switch (__mutex->type) {
+		case PTHREAD_MUTEX_NORMAL:
+		case PTHREAD_MUTEX_ERRORCHECK: // todo: error check
+		case PTHREAD_MUTEX_DEFAULT:
+			rc = __lock_try_acquire(__mutex->normal);
+			break;
+		case PTHREAD_MUTEX_RECURSIVE:
+			rc = __lock_try_acquire_recursive(__mutex->recursive);
+			break;
+		default:
+			return EINVAL;
+	}
+
+	if (rc)
+		return EBUSY;
+	return 0;
+}
+
+int
+pthread_mutex_unlock (pthread_mutex_t *__mutex)
+{
+	if (!__mutex)
+		return EINVAL;
+
+	switch (__mutex->type) {
+		case PTHREAD_MUTEX_NORMAL:
+		case PTHREAD_MUTEX_ERRORCHECK: // todo: error check
+		case PTHREAD_MUTEX_DEFAULT:
+			__lock_release(__mutex->normal);
+			break;
+		case PTHREAD_MUTEX_RECURSIVE:
+			__lock_release_recursive(__mutex->recursive);
+			break;
+		default:
+			return EINVAL;
+	}
+
+	return 0;
+}
+
+//-----------------------------------------------------------------------------
+// Condition variable attributes
+//-----------------------------------------------------------------------------
+
+int
+pthread_condattr_init (pthread_condattr_t *__attr)
+{
+	if (!__attr)
+		return EINVAL;
+	__attr->clock_id = CLOCK_REALTIME;
+	return 0;
+}
+
+int
+pthread_condattr_destroy (pthread_condattr_t *__attr)
+{
+	if (!__attr)
+		return EINVAL;
+	return 0;
+}
+
+int
+pthread_condattr_getclock (const pthread_condattr_t *__restrict __attr, clockid_t *__restrict __clock_id)
+{
+	if (!__attr || !__clock_id)
+		return EINVAL;
+	*__clock_id = __attr->clock_id;
+	return 0;
+}
+
+int
+pthread_condattr_setclock (pthread_condattr_t *__attr, clockid_t __clock_id)
+{
+	if (!__attr)
+		return EINVAL;
+	__attr->clock_id = __clock_id;
+	return 0;
+}
+
+int
+pthread_condattr_getpshared (const pthread_condattr_t *__attr, int *__pshared)
+{
+	return ENOSYS;
+}
+
+int
+pthread_condattr_setpshared (pthread_condattr_t *__attr, int __pshared)
+{
+	return ENOSYS;
+}
+
+//-----------------------------------------------------------------------------
+// Condition variable
+//-----------------------------------------------------------------------------
+
+int
+pthread_cond_init (pthread_cond_t *__cond, const pthread_condattr_t *__attr)
+{
+	pthread_condattr_t __default;
+	if (!__attr) {
+		pthread_condattr_init(&__default);
+		__attr = &__default;
+	}
+	if (!__cond)
+		return EINVAL;
+
+	__cond->clock_id = __attr->clock_id;
+	__cond->cond = __COND_INITIALIZER;
+	return 0;
+}
+
+int
+pthread_cond_destroy (pthread_cond_t *__cond)
+{
+	if (!__cond)
+		return EINVAL;
+	return 0;
+}
+
+int
+pthread_cond_signal (pthread_cond_t *__cond)
+{
+	if (!__cond)
+		return EINVAL;
+	return __cond_signal(__cond->cond);
+}
+
+int
+pthread_cond_broadcast (pthread_cond_t *__cond)
+{
+	if (!__cond)
+		return EINVAL;
+	return __cond_broadcast(__cond->cond);
+}
+
+static int
+__pthread_cond_wait_common (pthread_cond_t *__cond, pthread_mutex_t *__mutex, uint64_t timeout_ns)
+{
+	switch (__mutex->type) {
+		case PTHREAD_MUTEX_NORMAL:
+		case PTHREAD_MUTEX_ERRORCHECK: // todo: error check
+		case PTHREAD_MUTEX_DEFAULT:
+			return __cond_wait(__cond->cond, __mutex->normal, timeout_ns);
+		case PTHREAD_MUTEX_RECURSIVE:
+			return __cond_wait_recursive(__cond->cond, __mutex->recursive, timeout_ns);
+		default:
+			return EINVAL;
+	}
+}
+
+int
+pthread_cond_wait (pthread_cond_t *__cond, pthread_mutex_t *__mutex)
+{
+	if (!__cond || !__mutex)
+		return EINVAL;
+	return __pthread_cond_wait_common(__cond, __mutex, UINT64_MAX);
+}
+
+int
+pthread_cond_timedwait (pthread_cond_t *__cond, pthread_mutex_t *__mutex, const struct timespec *__abstime)
+{
+	if (!__cond || !__mutex || !__abstime)
+		return EINVAL;
+	return __pthread_cond_wait_common(__cond, __mutex, abstimespec2nsec(__cond->clock_id, __abstime));
+}
+
+//-----------------------------------------------------------------------------
+// Thread attributes
+//-----------------------------------------------------------------------------
+
+int
+pthread_attr_setschedparam (pthread_attr_t *__attr, const struct sched_param *__param)
+{
+	if (!__attr || !__param)
+		return EINVAL;
+	__attr->schedparam = *__param;
+	return 0;
+}
+
+int
+pthread_attr_getschedparam (const pthread_attr_t *__attr, struct sched_param *__param)
+{
+	if (!__attr || !__param)
+		return EINVAL;
+	*__param = __attr->schedparam;
+	return 0;
+}
+
+int
+pthread_attr_init (pthread_attr_t *__attr)
+{
+	if (!__attr)
+		return EINVAL;
+	memset(__attr, 0, sizeof(*__attr));
+	return 0;
+}
+
+int
+pthread_attr_destroy (pthread_attr_t *__attr)
+{
+	if (!__attr)
+		return EINVAL;
+	return 0;
+}
+
+int
+pthread_attr_setstack (pthread_attr_t *attr, void *__stackaddr, size_t __stacksize)
+{
+	if (!attr || !__stackaddr || !__stacksize)
+		return EINVAL;
+	attr->stackaddr = __stackaddr;
+	attr->stacksize = __stacksize;
+	return 0;
+}
+
+int
+pthread_attr_getstack (const pthread_attr_t *attr, void **__stackaddr, size_t *__stacksize)
+{
+	if (!attr || !__stackaddr || !__stacksize)
+		return EINVAL;
+	*__stackaddr = attr->stackaddr;
+	*__stacksize = attr->stacksize;
+	return 0;
+}
+
+int
+pthread_attr_getstacksize (const pthread_attr_t *__attr, size_t *__stacksize)
+{
+	if (!__attr || !__stacksize)
+		return EINVAL;
+	*__stacksize = __attr->stacksize;
+	return 0;
+}
+
+int
+pthread_attr_setstacksize (pthread_attr_t *__attr, size_t __stacksize)
+{
+	if (!__attr || !__stacksize)
+		return EINVAL;
+	__attr->stacksize = __stacksize;
+	return 0;
+}
+
+int
+pthread_attr_getstackaddr (const pthread_attr_t *__attr, void **__stackaddr)
+{
+	if (!__attr || !__stackaddr)
+		return EINVAL;
+	*__stackaddr = __attr->stackaddr;
+	return 0;
+}
+
+int
+pthread_attr_setstackaddr (pthread_attr_t  *__attr, void *__stackaddr)
+{
+	if (!__attr || !__stackaddr)
+		return EINVAL;
+	__attr->stackaddr = __stackaddr;
+	return 0;
+}
+
+int
+pthread_attr_getdetachstate (const pthread_attr_t *__attr, int *__detachstate)
+{
+	if (!__attr || !__detachstate)
+		return EINVAL;
+	*__detachstate = __attr->detachstate;
+	return 0;
+}
+
+int
+pthread_attr_setdetachstate (pthread_attr_t *__attr, int __detachstate)
+{
+	if (!__attr)
+		return EINVAL;
+	__attr->detachstate = __detachstate;
+	return 0;
+}
+
+int
+pthread_attr_getguardsize (const pthread_attr_t *__attr, size_t *__guardsize)
+{
+	return ENOSYS; // Unsupported
+}
+
+int
+pthread_attr_setguardsize (pthread_attr_t *__attr, size_t __guardsize)
+{
+	return ENOSYS; // Unsupported
+}
+
+//-----------------------------------------------------------------------------
+// Thread
+//-----------------------------------------------------------------------------
+
+int
+pthread_create (pthread_t *__pthread, const pthread_attr_t *__attr, void *(*__start_routine)(void *), void *__arg)
+{
+	pthread_attr_t __default;
+	if (!__attr) {
+		pthread_attr_init(&__default);
+		__attr = &__default;
+	}
+	if (!__pthread || !__start_routine)
+		return EINVAL;
+	if (!__has_syscall(thread_create))
+		return ENOSYS;
+	return __syscall_thread_create(__pthread, __start_routine, __arg, __attr->stackaddr, __attr->stacksize);
+}
+
+int
+pthread_join (pthread_t __pthread, void **__value_ptr)
+{
+	if (!__has_syscall(thread_join))
+		return ENOSYS;
+	void* value = __syscall_thread_join(__pthread);
+	if (__value_ptr)
+		*__value_ptr = value;
+	return 0;
+}
+
+int
+pthread_detach (pthread_t __pthread)
+{
+	if (!__has_syscall(thread_detach))
+		return ENOSYS;
+	return __syscall_thread_detach(__pthread);
+}
+
+void
+pthread_exit (void *__value_ptr)
+{
+	if (__has_syscall(thread_exit))
+		__syscall_thread_exit(__value_ptr);
+	for (;;);
+}
+
+pthread_t
+pthread_self (void)
+{
+	if (__has_syscall(thread_self))
+		return __syscall_thread_self();
+	return NULL;
+}
+
+int
+pthread_equal (pthread_t __t1, pthread_t __t2)
+{
+	return __t1 == __t2;
+}
+
+int
+pthread_getcpuclockid (pthread_t thread, clockid_t *clock_id)
+{
+	if (!thread || !clock_id)
+		return EINVAL;
+	*clock_id = CLOCK_REALTIME;
+	return 0;
+}
+
+int
+pthread_setconcurrency (int new_level)
+{
+	return ENOSYS; // Unsupported
+}
+
+int
+pthread_getconcurrency (void)
+{
+	return ENOSYS; // Unsupported
+}
+
+//-----------------------------------------------------------------------------
+// Run-once
+//-----------------------------------------------------------------------------
+
+__LOCK_INIT(static, __pthread_once_lock)
+__COND_INIT(static, __pthread_once_cv)
+
+int
+pthread_once (pthread_once_t *__once_control, void (*__init_routine)(void))
+{
+	if (!__once_control || !__init_routine)
+		return EINVAL;
+
+	__lock_acquire(__pthread_once_lock);
+
+	if (__once_control->status == 0) {
+		__once_control->status = 1;
+		__lock_release(__pthread_once_lock);
+		__init_routine();
+		__lock_acquire(__pthread_once_lock);
+		__once_control->status = 2;
+		__cond_broadcast(__pthread_once_cv);
+	} else {
+		while (__once_control->status == 1)
+			__cond_wait(__pthread_once_cv, __pthread_once_lock, UINT64_MAX);
+	}
+
+	__lock_release(__pthread_once_lock);
+	return 0;
+}
+
+//-----------------------------------------------------------------------------
+// Thread-specific keys (TLS)
+//-----------------------------------------------------------------------------
+
+int
+pthread_key_create (pthread_key_t *__key, void (*__destructor)(void *))
+{
+	if (!__key)
+		return EINVAL;
+	if (!__has_syscall(tls_create))
+		return ENOSYS;
+	return __syscall_tls_create(__key, __destructor);
+}
+
+int
+pthread_setspecific (pthread_key_t __key, const void *__value)
+{
+	if (!__has_syscall(tls_set))
+		return ENOSYS;
+	return __syscall_tls_set(__key, __value);
+}
+
+void *
+pthread_getspecific (pthread_key_t __key)
+{
+	if (__has_syscall(tls_get))
+		return __syscall_tls_get(__key);
+	return NULL;
+}
+
+int
+pthread_key_delete (pthread_key_t __key)
+{
+	if (!__has_syscall(tls_delete))
+		return ENOSYS;
+	return __syscall_tls_delete(__key);
+}
+
+//-----------------------------------------------------------------------------
+// Cancel
+//-----------------------------------------------------------------------------
+
+int
+pthread_cancel (pthread_t __pthread)
+{
+	return ENOSYS; // Unsupported
+}
+
+int
+pthread_setcancelstate (int __state, int *__oldstate)
+{
+	return ENOSYS; // Unsupported
+}
+
+int
+pthread_setcanceltype (int __type, int *__oldtype)
+{
+	return ENOSYS; // Unsupported
+}
+
+void
+pthread_testcancel (void)
+{
+	// Unsupported
+}
+
+//-----------------------------------------------------------------------------
+// Cleanup
+//-----------------------------------------------------------------------------
+
+static pthread_once_t __pthread_cleanup_once;
+static pthread_key_t __pthread_cleanup_key;
+
+static void
+__pthread_cleanup_dtor (void *arg)
+{
+	struct _pthread_cleanup_context *cur;
+	for (cur = (struct _pthread_cleanup_context *)arg; cur; cur = cur->_previous)
+		cur->_routine(cur->_arg);
+}
+
+static void
+__pthread_cleanup_setup (void)
+{
+	int err = pthread_key_create(&__pthread_cleanup_key, __pthread_cleanup_dtor);
+	if (err)
+		abort();
+}
+
+void
+_pthread_cleanup_push (struct _pthread_cleanup_context *_context, void (*_routine)(void *), void *_arg)
+{
+	pthread_once(&__pthread_cleanup_once, __pthread_cleanup_setup);
+	_context->_routine = _routine;
+	_context->_arg = _arg;
+	_context->_previous = (struct _pthread_cleanup_context *)pthread_getspecific(__pthread_cleanup_key);
+	pthread_setspecific(__pthread_cleanup_key, _context);
+}
+
+void
+_pthread_cleanup_pop (struct _pthread_cleanup_context *_context, int _execute)
+{
+	struct _pthread_cleanup_context *cur = (struct _pthread_cleanup_context *)pthread_getspecific(__pthread_cleanup_key);
+	if (cur) {
+		if (_execute)
+			cur->_routine(cur->_arg);
+		pthread_setspecific(__pthread_cleanup_key, cur->_previous);
+	}
+}
+
+//-----------------------------------------------------------------------------
+// Barrier
+//-----------------------------------------------------------------------------
+
+int
+pthread_barrierattr_init (pthread_barrierattr_t *__attr)
+{
+	if (!__attr)
+		return EINVAL;
+	return 0;
+}
+
+int
+pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
+{
+	if (!__attr)
+		return EINVAL;
+	return 0;
+}
+
+int
+pthread_barrierattr_getpshared (const pthread_barrierattr_t *__attr, int *__pshared)
+{
+	return ENOSYS;
+}
+
+int
+pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr, int __pshared)
+{
+	return ENOSYS;
+}
+
+int
+pthread_barrier_init (pthread_barrier_t *__barrier, const pthread_barrierattr_t *__attr, unsigned __count)
+{
+	if (!__barrier || !__count)
+		return EINVAL;
+
+	__barrier->lock = __LOCK_INITIALIZER;
+	__barrier->cond = __COND_INITIALIZER;
+	__barrier->reload = __count;
+	__barrier->counter = __count;
+	__barrier->cycle = 0;
+	return 0;
+}
+
+int
+pthread_barrier_destroy (pthread_barrier_t *__barrier)
+{
+	if (!__barrier)
+		return EINVAL;
+	return 0;
+}
+
+int
+pthread_barrier_wait (pthread_barrier_t *__barrier)
+{
+	if (!__barrier)
+		return EINVAL;
+
+	__lock_acquire(__barrier->lock);
+
+	int is_last_thread = !--__barrier->counter;
+	if (is_last_thread) {
+		__barrier->cycle ++;
+		__barrier->counter = __barrier->reload;
+		__cond_broadcast(__barrier->cond);
+	} else {
+		unsigned my_cycle = __barrier->cycle;
+		do
+			__cond_wait(__barrier->cond, __barrier->lock, UINT64_MAX);
+		while (__barrier->cycle == my_cycle);
+	}
+
+	__lock_release(__barrier->lock);
+	return is_last_thread ? PTHREAD_BARRIER_SERIAL_THREAD : 0;
+}
+
+//-----------------------------------------------------------------------------
+// Read/write lock
+//-----------------------------------------------------------------------------
+
+int
+pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
+{
+	if (!__attr)
+		return EINVAL;
+	return 0;
+}
+
+int
+pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
+{
+	if (!__attr)
+		return EINVAL;
+	return 0;
+}
+
+int
+pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *__attr, int *__pshared)
+{
+	return ENOSYS;
+}
+
+int
+pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr, int __pshared)
+{
+	return ENOSYS;
+}
+
+int
+pthread_rwlock_init (pthread_rwlock_t *__rwlock, const pthread_rwlockattr_t *__attr)
+{
+	if (!__rwlock)
+		return EINVAL;
+	*__rwlock = PTHREAD_RWLOCK_INITIALIZER;
+	return 0;
+}
+
+int
+pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
+{
+	if (!__rwlock)
+		return EINVAL;
+	return 0;
+}
+
+static int
+__pthread_rwlock_rdlock_common (pthread_rwlock_t *__rwlock, const struct timespec *__abstime)
+{
+	int rc = 0;
+	__lock_acquire(__rwlock->lock);
+
+	while (__rwlock->cnt_w) {
+		rc = __cond_wait(__rwlock->cond_w, __rwlock->lock, __pthread_abstime_to_ns(__abstime));
+		if (rc) break;
+	}
+
+	if (!rc)
+		__rwlock->cnt_r ++;
+
+	__lock_release(__rwlock->lock);
+	return rc;
+}
+
+int
+pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
+{
+	if (!__rwlock)
+		return EINVAL;
+	return __pthread_rwlock_rdlock_common(__rwlock, NULL);
+}
+
+int
+pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
+{
+	if (!__rwlock)
+		return EINVAL;
+
+	__lock_acquire(__rwlock->lock);
+
+	int failed = __rwlock->cnt_w != 0;
+	if (!failed)
+		__rwlock->cnt_r ++;
+
+	__lock_release(__rwlock->lock);
+	return failed ? EBUSY : 0;
+}
+
+int
+pthread_rwlock_timedrdlock (pthread_rwlock_t *__rwlock, const struct timespec *__abstime)
+{
+	if (!__rwlock || !__abstime)
+		return EINVAL;
+	return __pthread_rwlock_rdlock_common(__rwlock, __abstime);
+}
+
+int
+pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
+{
+	if (!__rwlock)
+		return EINVAL;
+
+	__lock_acquire(__rwlock->lock);
+
+	if (__rwlock->cnt_w != 2) {
+		if (!--__rwlock->cnt_r)
+			__cond_broadcast(__rwlock->cond_r);
+	} else {
+		__rwlock->cnt_w = 0;
+		__cond_broadcast(__rwlock->cond_w);
+	}
+
+	__lock_release(__rwlock->lock);
+	return 0;
+}
+
+static int
+__pthread_rwlock_wrlock_common (pthread_rwlock_t *__rwlock, const struct timespec *__abstime)
+{
+	int rc = 0;
+	__lock_acquire(__rwlock->lock);
+
+	while (__rwlock->cnt_w) {
+		rc = __cond_wait(__rwlock->cond_w, __rwlock->lock, __pthread_abstime_to_ns(__abstime));
+		if (rc) break;
+	}
+
+	if (!rc) {
+		__rwlock->cnt_w = 1;
+
+		while (__rwlock->cnt_r) {
+			rc = __cond_wait(__rwlock->cond_r, __rwlock->lock, __pthread_abstime_to_ns(__abstime));
+			if (rc) break;
+		}
+
+		if (rc) {
+			__rwlock->cnt_w = 0;
+			__cond_broadcast(__rwlock->cond_w);
+		} else
+			__rwlock->cnt_w = 2;
+	}
+
+	__lock_release(__rwlock->lock);
+	return rc;
+}
+
+int
+pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
+{
+	if (!__rwlock)
+		return EINVAL;
+	return __pthread_rwlock_wrlock_common(__rwlock, NULL);
+}
+
+int
+pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
+{
+	if (!__rwlock)
+		return EINVAL;
+
+	__lock_acquire(__rwlock->lock);
+
+	int failed = __rwlock->cnt_w != 0 || __rwlock->cnt_r != 0;
+	if (!failed)
+		__rwlock->cnt_w = 2;
+
+	__lock_release(__rwlock->lock);
+	return failed ? EBUSY : 0;
+}
+
+int
+pthread_rwlock_timedwrlock (pthread_rwlock_t *__rwlock, const struct timespec *__abstime)
+{
+	if (!__rwlock || !__abstime)
+		return EINVAL;
+	return __pthread_rwlock_wrlock_common(__rwlock, __abstime);
+}
+
+//-----------------------------------------------------------------------------
+// semaphore.h
+//-----------------------------------------------------------------------------
+
+int
+sem_close(sem_t *__sem)
+{
+	errno = ENOSYS;
+	return -1;
+}
+
+int
+sem_destroy(sem_t *__sem)
+{
+	if (!__sem) {
+		errno = EINVAL;
+		return -1;
+	}
+	return 0;
+}
+
+int
+sem_getvalue(sem_t *__sem, int *__sval)
+{
+	if (!__sem || !__sval) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	__lock_acquire(__sem->lock);
+	*__sval = __sem->value;
+	__lock_release(__sem->lock);
+	return 0;
+}
+
+int
+sem_init(sem_t *__sem, int __pshared, unsigned int __value)
+{
+	if (!__sem || __value > SEM_VALUE_MAX) {
+		errno = EINVAL;
+		return -1;
+	}
+	if (__pshared) {
+		errno = ENOSYS;
+		return -1;
+	}
+
+	__sem->lock = __LOCK_INITIALIZER;
+	__sem->cond = __COND_INITIALIZER;
+	__sem->value = __value;
+	return 0;
+}
+
+sem_t *
+sem_open(const char *__name, int __oflag, ...)
+{
+	errno = ENOSYS;
+	return SEM_FAILED;
+}
+
+int
+sem_post(sem_t *__sem)
+{
+	if (!__sem) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	__lock_acquire(__sem->lock);
+	if (__sem->value++ < 0)
+		__cond_signal(__sem->cond);
+	__lock_release(__sem->lock);
+	return 0;
+}
+
+static int
+__sem_wait_common(sem_t *__sem, const struct timespec *__abstime)
+{
+	int rc = 0;
+	__lock_acquire(__sem->lock);
+
+	__sem->value --;
+	if (__sem->value < 0)
+		rc = __cond_wait(__sem->cond, __sem->lock, __pthread_abstime_to_ns(__abstime));
+	if (rc) {
+		if (__sem->value < 0)
+			__sem->value ++;
+		else
+			rc = 0;
+	}
+
+	__lock_release(__sem->lock);
+
+	if (rc) {
+		errno = rc;
+		return -1;
+	}
+
+	return 0;
+}
+
+int
+sem_timedwait(sem_t *__sem, const struct timespec *__abstime)
+{
+	if (!__sem || !__abstime) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	return __sem_wait_common(__sem, __abstime);
+}
+
+int
+sem_trywait(sem_t *__sem)
+{
+	if (!__sem) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	__lock_acquire(__sem->lock);
+
+	int failed = __sem->value <= 0;
+	if (!failed)
+		__sem->value --;
+
+	__lock_release(__sem->lock);
+
+	if (failed) {
+		errno = EAGAIN;
+		return -1;
+	}
+
+	return 0;
+}
+
+int
+sem_unlink(const char *__name)
+{
+	errno = ENOSYS;
+	return -1;
+}
+
+int
+sem_wait(sem_t *__sem)
+{
+	if (!__sem) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	return __sem_wait_common(__sem, NULL);
+}
+
+//-----------------------------------------------------------------------------
+// sched.h
+//-----------------------------------------------------------------------------
+
+int __attribute__((weak))
+sched_yield (void)
+{
+	errno = ENOSYS;
+	return -1;
+}
+
+int __attribute__((weak))
+sched_getcpu (void)
+{
+	errno = ENOSYS;
+	return -1;
+}
diff --git a/libgloss/libsysbase/read.c b/libgloss/libsysbase/read.c
new file mode 100644
index 0000000..838a8c7
--- /dev/null
+++ b/libgloss/libsysbase/read.c
@@ -0,0 +1,39 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <stdio.h>
+#include <errno.h>
+
+#include <sys/iosupport.h>
+
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+//---------------------------------------------------------------------------------
+_ssize_t _read_r(struct _reent *r, int fileDesc, void *ptr, size_t len) {
+//---------------------------------------------------------------------------------
+#else
+//---------------------------------------------------------------------------------
+_ssize_t _read(int fileDesc, void *ptr, size_t len) {
+//---------------------------------------------------------------------------------
+	struct _reent *r = _REENT;
+#endif
+	int ret = -1;
+	unsigned int dev = 0;
+
+	__handle * handle = NULL;
+
+	if(fileDesc!=-1) {
+		handle = __get_handle(fileDesc);
+
+		if ( NULL == handle ) return ret;
+
+		dev = handle->device;
+
+		if(devoptab_list[dev]->read_r) {
+			r->deviceData = devoptab_list[dev]->deviceData;
+			ret = devoptab_list[dev]->read_r(r,handle->fileStruct,ptr,len);
+		} else
+			r->_errno=ENOSYS;
+	}
+	return ret;
+}
+
diff --git a/libgloss/libsysbase/rename.c b/libgloss/libsysbase/rename.c
new file mode 100644
index 0000000..b54e0ce
--- /dev/null
+++ b/libgloss/libsysbase/rename.c
@@ -0,0 +1,37 @@
+#include "config.h"
+#include <reent.h>
+#include <sys/iosupport.h>
+#include <errno.h>
+
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+int _rename_r(struct _reent *ptr, const char *existing, const char *newName)
+{
+#else
+int rename(const char *existing, const char *newName)
+{
+	struct _reent *ptr = _REENT;
+#endif
+	struct _reent *r = _REENT;
+
+	int ret = -1;
+	int sourceDev = FindDevice(existing);
+	int destDev = FindDevice(newName);
+
+        if (sourceDev == -1 || destDev == -1 ) {
+                r->_errno = ENODEV;
+                return ret;
+        }
+
+	if ( sourceDev == destDev) {
+		if (devoptab_list[destDev]->rename_r) {
+			r->deviceData = devoptab_list[destDev]->deviceData;
+			ret = devoptab_list[destDev]->rename_r( r, existing, newName);
+		} else {
+			r->_errno = ENOSYS;
+		}
+	} else {
+		r->_errno = EXDEV;
+	}
+
+	return ret;
+}
diff --git a/libgloss/libsysbase/rmdir.c b/libgloss/libsysbase/rmdir.c
new file mode 100644
index 0000000..2692a29
--- /dev/null
+++ b/libgloss/libsysbase/rmdir.c
@@ -0,0 +1,25 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <reent.h>
+#include <errno.h>
+#include <sys/iosupport.h>
+
+int	rmdir (const char *name) {
+	struct _reent *r = _REENT;
+	int	dev,ret=-1;
+
+	dev	= FindDevice(name);
+	if(dev!=-1) {
+		if(devoptab_list[dev]->rmdir_r) {
+			r->deviceData = devoptab_list[dev]->deviceData;
+			ret = devoptab_list[dev]->rmdir_r(r,name);
+		} else {
+			r->_errno = ENOSYS;
+		}
+	} else {
+		r->_errno =	ENODEV;
+	}
+
+	return ret;
+}
diff --git a/libgloss/libsysbase/sbrk.c b/libgloss/libsysbase/sbrk.c
new file mode 100644
index 0000000..5dd550c
--- /dev/null
+++ b/libgloss/libsysbase/sbrk.c
@@ -0,0 +1,60 @@
+#include "config.h"
+#include <_ansi.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/fcntl.h>
+#include <stdio.h>
+#include <time.h>
+#include <sys/time.h>
+#include <sys/times.h>
+#include <errno.h>
+#include <reent.h>
+#include <unistd.h>
+
+
+extern char *fake_heap_end;
+extern char *fake_heap_start;
+
+/* Register name faking - works in collusion with the linker.  */
+register char * stack_ptr asm ("sp");
+
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+//---------------------------------------------------------------------------------
+void * _sbrk_r (struct _reent *ptr, ptrdiff_t incr) {
+//---------------------------------------------------------------------------------
+#else
+//---------------------------------------------------------------------------------
+caddr_t _sbrk (int incr) {
+//---------------------------------------------------------------------------------
+	struct _reent *ptr = _REENT;
+#endif
+	extern char   end asm ("__end__");	/* Defined by the linker.  */
+	static char * heap_start;
+
+	char *	prev_heap_start;
+	char *	heap_end;
+
+	if (heap_start == NULL) {
+		if (fake_heap_start == NULL) {
+			heap_start = &end;
+		} else {
+			heap_start = fake_heap_start;
+		}
+	}
+
+	prev_heap_start = heap_start;
+
+	if (fake_heap_end == NULL) {
+		heap_end = stack_ptr;
+	} else {
+		heap_end = fake_heap_end;
+	}
+
+	if (heap_start + incr > heap_end) {
+		ptr->_errno = ENOMEM;
+		return (caddr_t) -1;
+	}
+
+	heap_start += incr;
+	return (caddr_t) prev_heap_start;
+}
diff --git a/libgloss/libsysbase/scandir.c b/libgloss/libsysbase/scandir.c
new file mode 100644
index 0000000..5c673af
--- /dev/null
+++ b/libgloss/libsysbase/scandir.c
@@ -0,0 +1,76 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stddef.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+/*
+ * The DIRSIZ macro gives the minimum record length which will hold
+ * the directory entry.  This requires the amount of space in struct dirent
+ * without the d_name field, plus enough space for the name with a terminating
+ * null byte (dp->d_namlen+1), rounded up to a 4 byte boundary.
+ */
+#undef DIRSIZ
+#ifdef _DIRENT_HAVE_D_NAMLEN
+#define DIRSIZ(dp) \
+    (offsetof (struct dirent, d_name) + (((dp)->d_namlen+1 + 3) &~ 3))
+#else
+#define DIRSIZ(dp) \
+    (offsetof (struct dirent, d_name) + ((strlen((dp)->d_name)+1 + 3) &~ 3))
+#endif
+
+int
+scandir (const char *dirname,
+	struct dirent ***namelist,
+	int (*filter) __P((const struct dirent *)),
+	int (*compar) __P((const struct dirent **, const struct dirent **)))
+{
+	errno = 0;
+
+	DIR *d = opendir(dirname);
+
+	if (!d) return -1;
+
+	struct dirent *de, **names = NULL, **tmp;
+	size_t cnt = 0, len = 0;
+
+	while (de = readdir(d)) {
+		if (filter && ! filter(de)) continue;
+		if (cnt >= len) {
+			len = 2*len+1;
+			if (len > SIZE_MAX/sizeof(*names)) break;
+			tmp = realloc(names, len * sizeof(*names));
+			if (!tmp) break;
+			names = tmp;
+		}
+		names[cnt] = malloc(DIRSIZ(de));
+		if (!names[cnt]) break;
+		memcpy(names[cnt++], de, DIRSIZ(de));
+	}
+
+	closedir(d);
+
+	if(errno) {
+		if (names) while(cnt-- > 0) free(names[cnt]);
+		free(names);
+		return -1;
+	}
+
+	if (compar) qsort(names, cnt, sizeof(*names), (int (*)(const void *, const void *))compar);
+
+	*namelist = names;
+	return cnt;
+}
+
+/*
+ * Alphabetic order comparison routine for those who want it.
+ */
+int
+alphasort (const struct dirent **d1,
+       const struct dirent **d2)
+{
+       return(strcmp((*d1)->d_name, (*d2)->d_name));
+}
+
diff --git a/libgloss/libsysbase/sleep.c b/libgloss/libsysbase/sleep.c
new file mode 100644
index 0000000..f3aa979
--- /dev/null
+++ b/libgloss/libsysbase/sleep.c
@@ -0,0 +1,18 @@
+/* Copied from libc/posix/sleep.c, removed the check for HAVE_NANOSLEEP */
+
+/* Written 2000 by Werner Almesberger */
+
+#include <errno.h>
+#include <time.h>
+#include <unistd.h>
+
+unsigned sleep(unsigned seconds)
+{
+    struct timespec ts;
+
+    ts.tv_sec = seconds;
+    ts.tv_nsec = 0;
+    if (!nanosleep(&ts,&ts)) return 0;
+    if (errno == EINTR) return ts.tv_sec;
+    return -1;
+}
diff --git a/libgloss/libsysbase/stat.c b/libgloss/libsysbase/stat.c
new file mode 100644
index 0000000..d0ad002
--- /dev/null
+++ b/libgloss/libsysbase/stat.c
@@ -0,0 +1,38 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/iosupport.h>
+#include <errno.h>
+
+
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+//---------------------------------------------------------------------------------
+int _stat_r(struct _reent * r, const char *file, struct stat *st) {
+//---------------------------------------------------------------------------------
+#else
+//---------------------------------------------------------------------------------
+int _stat(const char *file, struct stat *st) {
+{
+//---------------------------------------------------------------------------------
+	struct _reent *r = _REENT;
+#endif
+	int dev,ret;
+
+	dev = FindDevice(file);
+
+	if(dev!=-1) {
+		if (devoptab_list[dev]->stat_r) {
+			r->deviceData = devoptab_list[dev]->deviceData;
+			ret = devoptab_list[dev]->stat_r(r,file,st);
+		} else {
+			r->_errno=ENOSYS;
+		}
+	} else {
+		ret = -1;
+		r->_errno = ENODEV;
+	}
+	return ret;
+}
+
diff --git a/libgloss/libsysbase/statvfs.c b/libgloss/libsysbase/statvfs.c
new file mode 100644
index 0000000..84e2213
--- /dev/null
+++ b/libgloss/libsysbase/statvfs.c
@@ -0,0 +1,24 @@
+#include <reent.h>
+#include <sys/iosupport.h>
+#include <errno.h>
+
+
+int statvfs(const char *path, struct statvfs *buf) {
+	struct _reent *r = _REENT;
+
+	int ret;
+	int device = FindDevice(path);
+
+	ret = -1;
+
+	if ( device != -1 && devoptab_list[device]->statvfs_r) {
+
+		r->deviceData = devoptab_list[device]->deviceData;
+		ret = devoptab_list[device]->statvfs_r(r, path, buf );
+
+	} else {
+		r->_errno = ENOSYS;
+	}
+
+	return ret;
+}
diff --git a/libgloss/libsysbase/times.c b/libgloss/libsysbase/times.c
new file mode 100644
index 0000000..79484e7
--- /dev/null
+++ b/libgloss/libsysbase/times.c
@@ -0,0 +1,17 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/times.h>
+#include <errno.h>
+
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+clock_t _times_r(struct _reent *r, struct tms *ptms) {
+#else
+clock_t _times(struct tms *buf) {
+
+	struct _reent *r = _REENT;
+#endif
+	r->_errno = ENOSYS;
+	return (clock_t)-1;
+}
+
diff --git a/libgloss/libsysbase/truncate.c b/libgloss/libsysbase/truncate.c
new file mode 100644
index 0000000..8495259
--- /dev/null
+++ b/libgloss/libsysbase/truncate.c
@@ -0,0 +1,54 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+
+#include <sys/iosupport.h>
+
+int truncate(const char *file, off_t len)
+{
+
+	__handle *handle;
+	int dev, fd, ret;
+
+	struct _reent * r = _REENT;
+
+	dev = FindDevice(file);
+
+	if(dev!=-1 && devoptab_list[dev]->open_r && devoptab_list[dev]->close_r &&
+	   devoptab_list[dev]->ftruncate_r)
+	{
+
+		fd = __alloc_handle(dev);
+
+		if ( -1 != fd ) {
+			handle = __get_handle(fd);
+
+			r->deviceData = devoptab_list[dev]->deviceData;
+
+			ret = devoptab_list[dev]->open_r(r, handle->fileStruct, file, O_WRONLY, 0);
+
+			if ( ret < 0 ) {
+				__release_handle(fd);
+				return ret;
+			}
+
+			ret = devoptab_list[dev]->ftruncate_r(r, handle->fileStruct, len);
+
+			if (ret >= 0) {
+				ret = devoptab_list[dev]->close_r(r, handle->fileStruct);
+			} else {
+				// Close it anyway, we don't want to leak memory
+				devoptab_list[dev]->close_r(r, handle->fileStruct);
+			}
+		} else {
+			r->_errno = ENOSR;
+		}
+	} else {
+		r->_errno = ENOSYS;
+	}
+
+	return ret;
+}
diff --git a/libgloss/libsysbase/unlink.c b/libgloss/libsysbase/unlink.c
new file mode 100644
index 0000000..7920b79
--- /dev/null
+++ b/libgloss/libsysbase/unlink.c
@@ -0,0 +1,34 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <reent.h>
+#include <errno.h>
+#include <sys/iosupport.h>
+
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+//---------------------------------------------------------------------------------
+int _unlink_r(struct _reent * r, const char *name ) {
+//---------------------------------------------------------------------------------
+#else
+//---------------------------------------------------------------------------------
+int _unlink_r(const char *name ) {
+//---------------------------------------------------------------------------------
+	struct _reent *r = _REENT;
+#endif
+	int dev,ret=-1;
+
+	dev = FindDevice(name);
+	if(dev<0) {
+		r->_errno = ENODEV;
+	} else {
+		if (devoptab_list[dev]->unlink_r) {
+			r->deviceData = devoptab_list[dev]->deviceData;
+			ret = devoptab_list[dev]->unlink_r(r,name);
+		} else {
+			r->_errno=ENOSYS;
+		}
+	}
+
+	return ret;
+}
+
diff --git a/libgloss/libsysbase/usleep.c b/libgloss/libsysbase/usleep.c
new file mode 100644
index 0000000..b547147
--- /dev/null
+++ b/libgloss/libsysbase/usleep.c
@@ -0,0 +1,18 @@
+/* Copied from libc/posix/sleep.c, removed the check for HAVE_NANOSLEEP */
+
+/* Written 2000 by Werner Almesberger */
+
+#include <errno.h>
+#include <time.h>
+#include <unistd.h>
+
+int usleep(useconds_t useconds)
+{
+	struct timespec ts;
+
+	ts.tv_sec = (long int)useconds / 1000000;
+	ts.tv_nsec = ((long int)useconds % 1000000) * 1000;
+	if (!nanosleep(&ts,&ts)) return 0;
+	if (errno == EINTR) return ts.tv_sec;
+	return -1;
+}
diff --git a/libgloss/libsysbase/utime.c b/libgloss/libsysbase/utime.c
new file mode 100644
index 0000000..f72bf9f
--- /dev/null
+++ b/libgloss/libsysbase/utime.c
@@ -0,0 +1,45 @@
+#include "config.h"
+
+#include <errno.h>
+#include <stdio.h>
+#include <time.h>
+#include <utime.h>
+#include <sys/iosupport.h>
+
+int utimes(const char *filename, const struct timeval times[2])
+{
+        struct _reent *r = _REENT;
+        int dev,ret;
+
+        dev = FindDevice(filename);
+
+        if(dev!=-1) {
+                if (devoptab_list[dev]->utimes_r) {
+                        r->deviceData = devoptab_list[dev]->deviceData;
+                        ret = devoptab_list[dev]->utimes_r(r,filename,times);
+                } else {
+                        r->_errno=ENOSYS;
+                }
+        } else {
+                ret = -1;
+                r->_errno = ENODEV;
+        }
+        return ret;
+
+
+
+}
+
+
+int utime(const char *filename, const struct utimbuf *times)
+{
+        struct timeval t[2];
+        if (times) {
+                t[0].tv_sec  = times->actime;
+                t[0].tv_usec = 0;
+                t[1].tv_sec  = times->modtime;
+                t[1].tv_usec = 0;
+        }
+
+        return utimes(filename, t);
+}
diff --git a/libgloss/libsysbase/wait.c b/libgloss/libsysbase/wait.c
new file mode 100644
index 0000000..247486e
--- /dev/null
+++ b/libgloss/libsysbase/wait.c
@@ -0,0 +1,24 @@
+/*
+ * Stub version of wait.
+ */
+
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+
+//---------------------------------------------------------------------------------
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+//---------------------------------------------------------------------------------
+int _wait_r(struct _reent *r, int  *status) {
+#else
+//---------------------------------------------------------------------------------
+int
+int _wait_r(int  *status) {
+	struct _reent *r = _REENT;
+#endif
+//---------------------------------------------------------------------------------
+	r->_errno = ENOSYS;
+	return -1;
+}
+
diff --git a/libgloss/libsysbase/warning.h b/libgloss/libsysbase/warning.h
new file mode 100644
index 0000000..2c29982
--- /dev/null
+++ b/libgloss/libsysbase/warning.h
@@ -0,0 +1,43 @@
+#ifndef __WARNING_H__
+#define __WARNING_H__
+
+#ifdef HAVE_GNU_LD
+# ifdef HAVE_ELF
+
+/* We want the .gnu.warning.SYMBOL section to be unallocated.  */
+#  ifdef HAVE_ASM_PREVIOUS_DIRECTIVE
+#   define __make_section_unallocated(section_string)   \
+  asm(".section " section_string "; .previous");
+#  elif defined (HAVE_ASM_POPSECTION_DIRECTIVE)
+#   define __make_section_unallocated(section_string)   \
+  asm(".pushsection " section_string "; .popsection");
+#  else
+#   define __make_section_unallocated(section_string)
+#  endif
+
+#  ifdef HAVE_SECTION_ATTRIBUTES
+#   define link_warning(symbol, msg)                     \
+  __make_section_unallocated (".gnu.warning." #symbol)  \
+  static const char __evoke_link_warning_##symbol[]     \
+    __attribute__ ((section (".gnu.warning." #symbol))) = msg;
+#  else
+#   define link_warning(symbol, msg)
+#  endif
+
+#else /* !ELF */
+
+#  define link_warning(symbol, msg)             \
+  asm(".stabs \"" msg "\",30,0,0,0\n"   \
+      ".stabs \"" __SYMBOL_PREFIX #symbol "\",1,0,0,0\n");
+# endif
+#else /* !GNULD */
+/* We will never be heard; they will all die horribly.  */
+# define link_warning(symbol, msg)
+#endif
+
+/* A canned warning for sysdeps/stub functions.  */
+#define stub_warning(name) \
+  link_warning (name, \
+                "warning: " #name " is not implemented and will always fail")
+
+#endif /* __WARNING_H__ */
diff --git a/libgloss/libsysbase/write.c b/libgloss/libsysbase/write.c
new file mode 100644
index 0000000..61de918
--- /dev/null
+++ b/libgloss/libsysbase/write.c
@@ -0,0 +1,38 @@
+#include "config.h"
+#include <_ansi.h>
+#include <_syslist.h>
+#include <stdio.h>
+#include <errno.h>
+
+#include <sys/iosupport.h>
+
+#ifdef REENTRANT_SYSCALLS_PROVIDED
+//---------------------------------------------------------------------------------
+_ssize_t _write_r(struct _reent * r, int fileDesc, const void *ptr, size_t len) {
+//---------------------------------------------------------------------------------
+#else
+//---------------------------------------------------------------------------------
+_ssize_t _write(int fileDesc, const void *ptr, size_t len) {
+//---------------------------------------------------------------------------------
+	struct _reent *r = _REENT;
+#endif
+	int ret = -1;
+	unsigned int dev = 0;
+
+	__handle * handle = NULL;
+
+	if(fileDesc!=-1) {
+		handle = __get_handle(fileDesc);
+
+		if ( NULL == handle ) return ret;
+
+		dev = handle->device;
+
+		if(devoptab_list[dev]->write_r) {
+			r->deviceData = devoptab_list[dev]->deviceData;
+			ret = devoptab_list[dev]->write_r(r,handle->fileStruct,ptr,len);
+		} else
+			r->_errno=ENOSYS;
+	}
+	return ret;
+}
diff --git a/newlib/configure.host b/newlib/configure.host
index a84c0c8..aa9ea05 100644
--- a/newlib/configure.host
+++ b/newlib/configure.host
@@ -680,13 +680,25 @@ newlib_cflags="${newlib_cflags} -DCLOCK_PROVIDED -DMALLOC_PROVIDED -DEXIT_PROVID
 	syscall_dir=syscalls
 	;;
   aarch64*-*-*)
+	default_newlib_io_c99_formats="yes"
 	default_newlib_io_long_long="yes"
+	default_newlib_io_pos_args="yes"
+	newlib_cflags="${newlib_cflags} -D__DYNAMIC_REENT__ -DREENTRANT_SYSCALLS_PROVIDED -D__DEFAULT_UTF8__"
+	newlib_cflags="${newlib_cflags} -ffunction-sections -fdata-sections"
 	syscall_dir=syscalls
 	;;
   arc*-*-*)
 	syscall_dir=syscalls
 	default_newlib_io_long_long="yes"
 	;;
+  arm*-*-eabi)
+	default_newlib_io_c99_formats="yes"
+	default_newlib_io_long_long="yes"
+	default_newlib_io_pos_args="yes"
+	newlib_cflags="${newlib_cflags} -D__DYNAMIC_REENT__ -DREENTRANT_SYSCALLS_PROVIDED -D__DEFAULT_UTF8__"
+	newlib_cflags="${newlib_cflags} -ffunction-sections -fdata-sections"
+	syscall_dir=syscalls
+	;;
   arm*-*-pe)
 	syscall_dir=syscalls
 	;;
diff --git a/newlib/libc/include/fnmatch.h b/newlib/libc/include/fnmatch.h
index a94e923..9171e98 100644
--- a/newlib/libc/include/fnmatch.h
+++ b/newlib/libc/include/fnmatch.h
@@ -44,6 +44,7 @@
 #if __GNU_VISIBLE
 #define	FNM_LEADING_DIR	0x08	/* Ignore /<tail> after Imatch. */
 #define	FNM_CASEFOLD	0x10	/* Case insensitive search. */
+#define FNM_PREFIX_DIRS 0x20    /* Directory prefixes of pattern match too. */
 #define	FNM_IGNORECASE	FNM_CASEFOLD
 #define	FNM_FILE_NAME	FNM_PATHNAME
 #endif
diff --git a/newlib/libc/include/machine/_threads.h b/newlib/libc/include/machine/_threads.h
new file mode 100755
index 0000000..a71a5d8
--- /dev/null
+++ b/newlib/libc/include/machine/_threads.h
@@ -0,0 +1,44 @@
+/*-
+ * Copyright (c) 2019 fincs <fincs@devkitpro.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _MACHINE__THREADS_H_
+#define _MACHINE__THREADS_H_
+
+#include <pthread.h>
+#include <limits.h>
+
+#define ONCE_FLAG_INIT      PTHREAD_ONCE_INIT
+#define TSS_DTOR_ITERATIONS PTHREAD_DESTRUCTOR_ITERATIONS
+#define _MTX_INITIALIZER_NP PTHREAD_MUTEX_INITIALIZER
+#define _CND_INITIALIZER_NP PTHREAD_COND_INITIALIZER
+
+typedef pthread_once_t  once_flag;
+typedef pthread_key_t   tss_t;
+typedef pthread_mutex_t mtx_t;
+typedef pthread_cond_t  cnd_t;
+typedef pthread_t       thrd_t;
+
+#endif
diff --git a/newlib/libc/include/math.h b/newlib/libc/include/math.h
index 1efc5b9..91a8d74 100644
--- a/newlib/libc/include/math.h
+++ b/newlib/libc/include/math.h
@@ -416,7 +416,7 @@ extern float hypotf (float, float);
    simply call the double functions.  On Cygwin the long double functions
    are implemented independently from newlib to be able to use optimized
    assembler functions despite using the Microsoft x86_64 ABI. */
-#if defined (_LDBL_EQ_DBL) || defined (__CYGWIN__)
+#if defined (_LDBL_EQ_DBL) || defined (__CYGWIN__) || defined (__DEVKITA64__)
 /* Reentrant ANSI C functions.  */
 #ifndef __math_68881
 extern long double atanl (long double);
diff --git a/newlib/libc/include/semaphore.h b/newlib/libc/include/semaphore.h
new file mode 100755
index 0000000..4afb0e4
--- /dev/null
+++ b/newlib/libc/include/semaphore.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2010 David Xu <davidxu@freebsd.org>
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD: head/include/semaphore.h 314424 2017-02-28 21:47:00Z vangyzen $
+ */
+
+/* semaphore.h: POSIX 1003.1b semaphores */
+
+#ifndef _SEMAPHORE_H_
+#define _SEMAPHORE_H_
+
+#include <sys/features.h>
+
+#if defined(_POSIX_SEMAPHORES)
+
+#include <limits.h>
+#include <sys/cdefs.h>
+#include <sys/lock.h>
+#include <sys/_types.h>
+#include <sys/_timespec.h>
+
+typedef struct {
+	_LOCK_T  lock;
+	_COND_T  cond;
+	int      value;
+} sem_t;
+
+#define SEM_VALUE_MAX	INT_MAX
+#define	SEM_FAILED	((sem_t *)0)
+
+__BEGIN_DECLS
+int	 sem_close(sem_t *);
+int	 sem_destroy(sem_t *);
+int	 sem_getvalue(sem_t * __restrict, int * __restrict);
+int	 sem_init(sem_t *, int, unsigned int);
+sem_t	*sem_open(const char *, int, ...);
+int	 sem_post(sem_t *);
+int	 sem_timedwait(sem_t * __restrict, const struct timespec * __restrict);
+int	 sem_trywait(sem_t *);
+int	 sem_unlink(const char *);
+int	 sem_wait(sem_t *);
+__END_DECLS
+
+#endif /* defined(_POSIX_SEMAPHORES) */
+
+#endif /* !_SEMAPHORE_H_ */
diff --git a/newlib/libc/include/sys/_pthreadtypes.h b/newlib/libc/include/sys/_pthreadtypes.h
index 75e9e1c..dc63dbe 100644
--- a/newlib/libc/include/sys/_pthreadtypes.h
+++ b/newlib/libc/include/sys/_pthreadtypes.h
@@ -18,19 +18,18 @@
 #ifndef _SYS__PTHREADTYPES_H_
 #define	_SYS__PTHREADTYPES_H_
 
+#include <sys/features.h>
+
 #if defined(_POSIX_THREADS) || __POSIX_VISIBLE >= 199506
 
 #include <sys/sched.h>
+#include <sys/lock.h>
 
 /*
  *  2.5 Primitive System Data Types,  P1003.1c/D10, p. 19.
  */
 
-#if defined(__XMK__)
-typedef unsigned int pthread_t;          /* identify a thread */
-#else
-typedef __uint32_t pthread_t;            /* identify a thread */
-#endif
+typedef struct __pthread_t *pthread_t;   /* identify a thread */
 
 /* P1003.1c/D10, p. 118-119 */
 #define PTHREAD_SCOPE_PROCESS 0
@@ -46,25 +45,14 @@ typedef __uint32_t pthread_t;            /* identify a thread */
 #define PTHREAD_CREATE_DETACHED 0
 #define PTHREAD_CREATE_JOINABLE  1
 
-#if defined(__XMK__)
-typedef struct pthread_attr_s {
-  int contentionscope;
-  struct sched_param schedparam;
-  int  detachstate;
-  void *stackaddr;
-  size_t stacksize;
-} pthread_attr_t;
-
-#define PTHREAD_STACK_MIN       200
-
-#else /* !defined(__XMK__) */
 typedef struct {
-  int is_initialized;
   void *stackaddr;
   int stacksize;
+#if defined(_POSIX_THREAD_PRIORITY_SCHEDULING)
   int contentionscope;
   int inheritsched;
   int schedpolicy;
+#endif
   struct sched_param schedparam;
 
   /* P1003.4b/D8, p. 54 adds cputime_clock_allowed attribute.  */
@@ -74,8 +62,6 @@ typedef struct {
   int  detachstate;
 } pthread_attr_t;
 
-#endif /* !defined(__XMK__) */
-
 #if defined(_POSIX_THREAD_PROCESS_SHARED)
 /* NOTE: P1003.1c/D10, p. 81 defines following values for process_shared.  */
 
@@ -143,18 +129,15 @@ typedef struct {
 
 #endif /* !defined(_UNIX98_THREAD_MUTEX_ATTRIBUTES) */
 
-#if defined(__XMK__)
-typedef unsigned int pthread_mutex_t;    /* identify a mutex */
-
 typedef struct {
   int type;
-} pthread_mutexattr_t;
-
-#else /* !defined(__XMK__) */
-typedef __uint32_t pthread_mutex_t;      /* identify a mutex */
+  union {
+    _LOCK_T normal;
+    _LOCK_RECURSIVE_T recursive;
+  };
+} pthread_mutex_t;      /* identify a mutex */
 
 typedef struct {
-  int   is_initialized;
 #if defined(_POSIX_THREAD_PROCESS_SHARED)
   int   process_shared;  /* allow mutex to be shared amongst processes */
 #endif
@@ -163,23 +146,25 @@ typedef struct {
   int   protocol;
 #endif
 #if defined(_UNIX98_THREAD_MUTEX_ATTRIBUTES)
-  int type;
+  int   type;
 #endif
-  int   recursive;
 } pthread_mutexattr_t;
-#endif /* !defined(__XMK__) */
 
-#define _PTHREAD_MUTEX_INITIALIZER ((pthread_mutex_t) 0xFFFFFFFF)
+#define _PTHREAD_MUTEX_INITIALIZER ((pthread_mutex_t){ PTHREAD_MUTEX_NORMAL, { .normal = __LOCK_INITIALIZER } })
+#define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP ((pthread_mutex_t){ PTHREAD_MUTEX_RECURSIVE, { .recursive = __LOCK_INITIALIZER_RECURSIVE } })
+#define PTHREAD_RECURSIVE_MUTEX_INITIALIZER PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 
 /* Condition Variables */
 
-typedef __uint32_t pthread_cond_t;       /* identify a condition variable */
+typedef struct {
+  clockid_t clock_id;
+  _COND_T   cond;
+} pthread_cond_t;       /* identify a condition variable */
 
-#define _PTHREAD_COND_INITIALIZER ((pthread_cond_t) 0xFFFFFFFF)
+#define _PTHREAD_COND_INITIALIZER ((pthread_cond_t){ CLOCK_REALTIME, __COND_INITIALIZER })
 
 typedef struct {
-  int      is_initialized;
-  clock_t  clock;             /* specifiy clock for timeouts */
+  clockid_t clock_id;         /* specifiy clock for timeouts */
 #if defined(_POSIX_THREAD_PROCESS_SHARED)
   int      process_shared;    /* allow this to be shared amongst processes */
 #endif
@@ -190,19 +175,23 @@ typedef struct {
 typedef __uint32_t pthread_key_t;        /* thread-specific data keys */
 
 typedef struct {
-  int   is_initialized;  /* is this structure initialized? */
-  int   init_executed;   /* has the initialization routine been run? */
+  int   status;         /* 0 = init not run, 1 = init running, 2 = init finished */
 } pthread_once_t;       /* dynamic package initialization */
 
-#define _PTHREAD_ONCE_INIT  { 1, 0 }  /* is initialized and not run */
+#define _PTHREAD_ONCE_INIT  { 0 }  /* not run */
 #endif /* defined(_POSIX_THREADS) || __POSIX_VISIBLE >= 199506 */
 
 /* POSIX Barrier Types */
 
 #if defined(_POSIX_BARRIERS)
-typedef __uint32_t pthread_barrier_t;        /* POSIX Barrier Object */
 typedef struct {
-  int   is_initialized;  /* is this structure initialized? */
+  _LOCK_T  lock;
+  _COND_T  cond;
+  unsigned reload;
+  unsigned counter;
+  unsigned cycle;
+} pthread_barrier_t;        /* POSIX Barrier Object */
+typedef struct {
 #if defined(_POSIX_THREAD_PROCESS_SHARED)
   int   process_shared;       /* allow this to be shared amongst processes */
 #endif
@@ -218,12 +207,17 @@ typedef __uint32_t pthread_spinlock_t;        /* POSIX Spin Lock Object */
 /* POSIX Reader/Writer Lock Types */
 
 #if defined(_POSIX_READER_WRITER_LOCKS)
-typedef __uint32_t pthread_rwlock_t;         /* POSIX RWLock Object */
+typedef struct {
+  _LOCK_T  lock;
+  _COND_T  cond_r;
+  _COND_T  cond_w;
+  uint32_t cnt_r : 30;
+  uint32_t cnt_w : 2;
+} pthread_rwlock_t;         /* POSIX RWLock Object */
 
-#define _PTHREAD_RWLOCK_INITIALIZER ((pthread_rwlock_t) 0xFFFFFFFF)
+#define _PTHREAD_RWLOCK_INITIALIZER ((pthread_rwlock_t){ __LOCK_INITIALIZER, __COND_INITIALIZER, __COND_INITIALIZER, 0, 0 })
 
 typedef struct {
-  int   is_initialized;       /* is this structure initialized? */
 #if defined(_POSIX_THREAD_PROCESS_SHARED)
   int   process_shared;       /* allow this to be shared amongst processes */
 #endif
diff --git a/newlib/libc/include/sys/_timespec.h b/newlib/libc/include/sys/_timespec.h
index f810b00..ca7e11d 100644
--- a/newlib/libc/include/sys/_timespec.h
+++ b/newlib/libc/include/sys/_timespec.h
@@ -49,4 +49,10 @@ struct timespec {
 	long	tv_nsec;	/* and nanoseconds */
 };
 
+__uint64_t
+timespec2nsec(const struct timespec *__restrict ts);
+
+__uint64_t
+abstimespec2nsec(__clockid_t clock_id, const struct timespec *__restrict ts);
+
 #endif /* !_SYS__TIMESPEC_H_ */
diff --git a/newlib/libc/include/sys/config.h b/newlib/libc/include/sys/config.h
index d746b15..80169d9 100644
--- a/newlib/libc/include/sys/config.h
+++ b/newlib/libc/include/sys/config.h
@@ -4,6 +4,9 @@
 #include <machine/ieeefp.h>  /* floating point macros */
 #include <sys/features.h>	/* POSIX defs */
 
+/* we want the reentrancy structure to be returned by a function */
+#define __DYNAMIC_REENT__
+
 #ifdef __aarch64__
 #define MALLOC_ALIGNMENT 16
 #endif
diff --git a/newlib/libc/include/sys/dirent.h b/newlib/libc/include/sys/dirent.h
index a3fb5c0..b208de4 100644
--- a/newlib/libc/include/sys/dirent.h
+++ b/newlib/libc/include/sys/dirent.h
@@ -1,13 +1,60 @@
 /* <dirent.h> includes <sys/dirent.h>, which is this file.  On a
    system which supports <dirent.h>, this file is overridden by
    dirent.h in the libc/sys/.../sys directory.  On a system which does
-   not support <dirent.h>, we will get this file which uses #error to force
-   an error.  */
+   not support <dirent.h>, we will get this file
+*/
+
+#ifndef _dirent_h_
+#define _dirent_h_
+
+#include <sys/iosupport.h>
+#include <sys/types.h>
+#include <sys/syslimits.h>
+
+#define	DT_UNKNOWN	 0
+#define	DT_FIFO		 1
+#define	DT_CHR		 2
+#define	DT_DIR		 4
+#define	DT_BLK		 6
+#define	DT_REG		 8
+#define	DT_LNK		10
+#define	DT_SOCK		12
+#define	DT_WHT		14
+
+#define _DIRENT_HAVE_D_TYPE
 
 #ifdef __cplusplus
 extern "C" {
 #endif
-#error "<dirent.h> not supported"
+
+struct dirent {
+	ino_t	d_ino;
+	unsigned char  d_type;
+	char	d_name[NAME_MAX+1];
+};
+
+typedef struct {
+	long int        position;
+	DIR_ITER*       dirData;
+	struct dirent   fileData;
+} DIR;
+
+int closedir(DIR *dirp);
+DIR *opendir(const char *dirname);
+struct dirent *readdir(DIR *dirp);
+int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result);
+void rewinddir(DIR *dirp);
+void seekdir(DIR *dirp, long int loc);
+long int telldir(DIR *dirp);
+
+int scandir(const char *dirp, struct dirent ***namelist,
+	int (*filter)(const struct dirent *),
+	int (*compar)(const struct dirent **, const struct dirent **));
+
+int alphasort(const struct dirent **a, const struct dirent **b);
+
 #ifdef __cplusplus
 }
 #endif
+
+#endif // _dirent_h_
diff --git a/newlib/libc/include/sys/features.h b/newlib/libc/include/sys/features.h
index 2188071..93294ad 100644
--- a/newlib/libc/include/sys/features.h
+++ b/newlib/libc/include/sys/features.h
@@ -330,6 +330,16 @@ extern "C" {
 #  define __SSP_FORTIFY_LEVEL 0
 #endif
 
+#ifdef __DEVKITA64__
+#define _POSIX_MONOTONIC_CLOCK		200112L
+#define _POSIX_TIMERS			1
+#define _POSIX_THREADS				1
+#define _POSIX_SEMAPHORES		1
+#define _POSIX_BARRIERS                 200112L
+#define _POSIX_READER_WRITER_LOCKS      200112L
+#define _UNIX98_THREAD_MUTEX_ATTRIBUTES         1
+#endif
+
 /* RTEMS adheres to POSIX -- 1003.1b with some features from annexes.  */
 
 #ifdef __rtems__
diff --git a/newlib/libc/include/sys/iosupport.h b/newlib/libc/include/sys/iosupport.h
new file mode 100644
index 0000000..82d2e35
--- /dev/null
+++ b/newlib/libc/include/sys/iosupport.h
@@ -0,0 +1,126 @@
+//---------------------------------------------------------------------------------
+#ifndef __iosupp_h__
+#define __iosupp_h__
+//---------------------------------------------------------------------------------
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <reent.h>
+#include <sys/stat.h>
+#include <sys/statvfs.h>
+#include <sys/time.h>
+
+enum	{
+	STD_IN,
+	STD_OUT,
+	STD_ERR,
+	STD_MAX = 16
+};
+
+typedef struct {
+	unsigned int device;
+	unsigned int refcount;
+	void *fileStruct;
+} __handle;
+
+/* Directory iterator for mantaining state between dir* calls */
+typedef struct {
+    int device;
+    void *dirStruct;
+} DIR_ITER;
+
+typedef struct {
+	const char *name;
+	size_t structSize;
+	int (*open_r)(struct _reent *r, void *fileStruct, const char *path, int flags, int mode);
+	int (*close_r)(struct _reent *r, void *fd);
+	ssize_t (*write_r)(struct _reent *r, void *fd, const char *ptr, size_t len);
+	ssize_t (*read_r)(struct _reent *r, void *fd, char *ptr, size_t len);
+	off_t (*seek_r)(struct _reent *r, void *fd, off_t pos, int dir);
+	int (*fstat_r)(struct _reent *r, void *fd, struct stat *st);
+	int (*stat_r)(struct _reent *r, const char *file, struct stat *st);
+	int (*link_r)(struct _reent *r, const char *existing, const char  *newLink);
+	int (*unlink_r)(struct _reent *r, const char *name);
+	int (*chdir_r)(struct _reent *r, const char *name);
+	int (*rename_r) (struct _reent *r, const char *oldName, const char *newName);
+	int (*mkdir_r) (struct _reent *r, const char *path, int mode);
+
+	size_t dirStateSize;
+
+	DIR_ITER* (*diropen_r)(struct _reent *r, DIR_ITER *dirState, const char *path);
+	int (*dirreset_r)(struct _reent *r, DIR_ITER *dirState);
+	int (*dirnext_r)(struct _reent *r, DIR_ITER *dirState, char *filename, struct stat *filestat);
+	int (*dirclose_r)(struct _reent *r, DIR_ITER *dirState);
+	int (*statvfs_r)(struct _reent *r, const char *path, struct statvfs *buf);
+	int (*ftruncate_r)(struct _reent *r, void *fd, off_t len);
+	int (*fsync_r)(struct _reent *r, void *fd);
+
+	void *deviceData;
+
+	int (*chmod_r)(struct _reent *r, const char *path, mode_t mode);
+	int (*fchmod_r)(struct _reent *r, void *fd, mode_t mode);
+	int (*rmdir_r)(struct _reent *r, const char *name);
+	int (*lstat_r)(struct _reent *r, const char *file, struct stat *st);
+	int (*utimes_r)(struct _reent *r, const char *filename, const struct timeval times[2]);
+
+} devoptab_t;
+
+extern const devoptab_t *devoptab_list[];
+
+#ifdef _BUILDING_LIBSYSBASE
+#define __SYSCALL(_name) __attribute__((weak)) __syscall_##_name
+#define __has_syscall(_name) (&__syscall_##_name)
+#else
+#define __SYSCALL(_name) __syscall_##_name
+#endif
+
+void __SYSCALL(exit)(int rc);
+struct _reent *__SYSCALL(getreent)(void);
+
+void __SYSCALL(lock_acquire)(_LOCK_T *lock);
+int  __SYSCALL(lock_try_acquire)(_LOCK_T *lock);
+void __SYSCALL(lock_release)(_LOCK_T *lock);
+void __SYSCALL(lock_acquire_recursive)(_LOCK_RECURSIVE_T *lock);
+int  __SYSCALL(lock_try_acquire_recursive)(_LOCK_RECURSIVE_T *lock);
+void __SYSCALL(lock_release_recursive)(_LOCK_RECURSIVE_T *lock);
+int  __SYSCALL(cond_signal)(_COND_T *cond);
+int  __SYSCALL(cond_broadcast)(_COND_T *cond);
+int  __SYSCALL(cond_wait)(_COND_T *cond, _LOCK_T *lock, uint64_t timeout_ns);
+int  __SYSCALL(cond_wait_recursive)(_COND_T *cond, _LOCK_RECURSIVE_T *lock, uint64_t timeout_ns);
+int  __SYSCALL(thread_create)(struct __pthread_t **thread, void* (*func)(void*), void *arg, void *stack_addr, size_t stack_size);
+void*__SYSCALL(thread_join)(struct __pthread_t *thread);
+int  __SYSCALL(thread_detach)(struct __pthread_t *thread);
+void __SYSCALL(thread_exit)(void *value);
+struct __pthread_t *__SYSCALL(thread_self)(void);
+int  __SYSCALL(tls_create)(uint32_t *key, void (*destructor)(void*));
+int  __SYSCALL(tls_set)(uint32_t key, const void *value);
+void*__SYSCALL(tls_get)(uint32_t key);
+int  __SYSCALL(tls_delete)(uint32_t key);
+
+int  __SYSCALL(gettod_r)(struct _reent *ptr, struct timeval *tp, struct timezone *tz);
+int __SYSCALL(clock_gettime)(clockid_t clock_id, struct timespec *tp);
+int __SYSCALL(clock_settime)(clockid_t clock_id, const struct timespec *tp);
+int __SYSCALL(clock_getres)(clockid_t clock_id, struct timespec *res);
+int __SYSCALL(nanosleep)(const struct timespec *req, struct timespec *rem);
+
+#undef __SYSCALL
+
+int AddDevice( const devoptab_t* device);
+int FindDevice(const char* name);
+int RemoveDevice(const char* name);
+void setDefaultDevice( int device );
+const devoptab_t* GetDeviceOpTab (const char *name);
+
+void __release_handle(int fd);
+int  __alloc_handle(int device);
+__handle *__get_handle(int fd);
+
+#ifdef __cplusplus
+}
+#endif
+
+//---------------------------------------------------------------------------------
+#endif // __iosupp_h__
+//---------------------------------------------------------------------------------
diff --git a/newlib/libc/include/sys/lock.h b/newlib/libc/include/sys/lock.h
index 5289049..2c3e64f 100644
--- a/newlib/libc/include/sys/lock.h
+++ b/newlib/libc/include/sys/lock.h
@@ -1,69 +1,105 @@
 #ifndef __SYS_LOCK_H__
 #define __SYS_LOCK_H__
 
-/* dummy lock routines for single-threaded aps */
-
-#include <newlib.h>
 #include <_ansi.h>
+#include <stdint.h>
 
-#if !defined(_RETARGETABLE_LOCKING)
+typedef uint32_t _LOCK_T;
 
-typedef int _LOCK_T;
-typedef int _LOCK_RECURSIVE_T;
+struct __lock_t {
+	_LOCK_T lock;
+	uint32_t thread_tag;
+	uint32_t counter;
+};
 
-#define __LOCK_INIT(class,lock) static int lock = 0;
-#define __LOCK_INIT_RECURSIVE(class,lock) static int lock = 0;
-#define __lock_init(lock) ((void) 0)
-#define __lock_init_recursive(lock) ((void) 0)
-#define __lock_close(lock) ((void) 0)
-#define __lock_close_recursive(lock) ((void) 0)
-#define __lock_acquire(lock) ((void) 0)
-#define __lock_acquire_recursive(lock) ((void) 0)
-#define __lock_try_acquire(lock) ((void) 0)
-#define __lock_try_acquire_recursive(lock) ((void) 0)
-#define __lock_release(lock) ((void) 0)
-#define __lock_release_recursive(lock) ((void) 0)
+typedef struct __lock_t _LOCK_RECURSIVE_T;
 
-#else
+typedef uint32_t _COND_T;
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-struct __lock;
-typedef struct __lock * _LOCK_T;
-#define _LOCK_RECURSIVE_T _LOCK_T
-
-#define __LOCK_INIT(class,lock) extern struct __lock __lock_ ## lock; \
-	class _LOCK_T lock = &__lock_ ## lock
-#define __LOCK_INIT_RECURSIVE(class,lock) __LOCK_INIT(class,lock)
-
-extern void __retarget_lock_init(_LOCK_T *lock);
-#define __lock_init(lock) __retarget_lock_init(&lock)
-extern void __retarget_lock_init_recursive(_LOCK_T *lock);
-#define __lock_init_recursive(lock) __retarget_lock_init_recursive(&lock)
-extern void __retarget_lock_close(_LOCK_T lock);
-#define __lock_close(lock) __retarget_lock_close(lock)
-extern void __retarget_lock_close_recursive(_LOCK_T lock);
-#define __lock_close_recursive(lock) __retarget_lock_close_recursive(lock)
-extern void __retarget_lock_acquire(_LOCK_T lock);
-#define __lock_acquire(lock) __retarget_lock_acquire(lock)
-extern void __retarget_lock_acquire_recursive(_LOCK_T lock);
-#define __lock_acquire_recursive(lock) __retarget_lock_acquire_recursive(lock)
-extern int __retarget_lock_try_acquire(_LOCK_T lock);
-#define __lock_try_acquire(lock) __retarget_lock_try_acquire(lock)
-extern int __retarget_lock_try_acquire_recursive(_LOCK_T lock);
-#define __lock_try_acquire_recursive(lock) \
-  __retarget_lock_try_acquire_recursive(lock)
-extern void __retarget_lock_release(_LOCK_T lock);
-#define __lock_release(lock) __retarget_lock_release(lock)
-extern void __retarget_lock_release_recursive(_LOCK_T lock);
-#define __lock_release_recursive(lock) __retarget_lock_release_recursive(lock)
+extern void __libc_lock_init(_LOCK_T *lock);
+extern void __libc_lock_init_recursive(_LOCK_RECURSIVE_T *lock);
+extern void __libc_lock_close(_LOCK_T *lock);
+extern void __libc_lock_close_recursive(_LOCK_RECURSIVE_T *lock);
+extern void __libc_lock_acquire(_LOCK_T *lock);
+extern void __libc_lock_acquire_recursive(_LOCK_RECURSIVE_T *lock);
+extern void __libc_lock_release(_LOCK_T *lock);
+extern void __libc_lock_release_recursive(_LOCK_RECURSIVE_T *lock);
+
+/* Returns 0 for success and non-zero for failure */
+extern int __libc_lock_try_acquire(_LOCK_T *lock);
+extern int __libc_lock_try_acquire_recursive(_LOCK_RECURSIVE_T *lock);
+
+/* Returns errno */
+extern int __libc_cond_init(_COND_T *cond);
+extern int __libc_cond_signal(_COND_T *cond);
+extern int __libc_cond_broadcast(_COND_T *cond);
+extern int __libc_cond_wait(_COND_T *cond, _LOCK_T *lock, uint64_t timeout_ns);
+extern int __libc_cond_wait_recursive(_COND_T *cond, _LOCK_RECURSIVE_T *lock, uint64_t timeout_ns);
 
 #ifdef __cplusplus
 }
 #endif
 
-#endif /* !defined(_RETARGETABLE_LOCKING) */
+#define __LOCK_INITIALIZER ((_LOCK_T)0)
+#define __LOCK_INITIALIZER_RECURSIVE ((_LOCK_RECURSIVE_T){__LOCK_INITIALIZER,0,0})
+#define __COND_INITIALIZER ((_COND_T)0)
+
+#define __LOCK_INIT(CLASS,NAME) \
+CLASS _LOCK_T NAME = __LOCK_INITIALIZER;
+
+#define __LOCK_INIT_RECURSIVE(CLASS,NAME) \
+CLASS _LOCK_RECURSIVE_T NAME = __LOCK_INITIALIZER_RECURSIVE;
+
+#define __COND_INIT(CLASS,NAME) \
+CLASS _COND_T NAME = __COND_INITIALIZER;
+
+#define __lock_init(NAME) \
+	__libc_lock_init(&(NAME))
+
+#define __lock_init_recursive(NAME) \
+	__libc_lock_init_recursive(&(NAME))
+
+#define __lock_close(NAME) \
+	__libc_lock_close(&(NAME))
+
+#define __lock_close_recursive(NAME) \
+	__libc_lock_close_recursive(&(NAME))
+
+#define __lock_acquire(NAME) \
+	__libc_lock_acquire(&(NAME))
+
+#define __lock_acquire_recursive(NAME) \
+	__libc_lock_acquire_recursive(&(NAME))
+
+#define __lock_try_acquire(NAME) \
+	__libc_lock_try_acquire(&(NAME))
+
+#define __lock_try_acquire_recursive(NAME) \
+	__libc_lock_try_acquire_recursive(&(NAME))
+
+#define __lock_release(NAME) \
+	__libc_lock_release(&(NAME))
+
+#define __lock_release_recursive(NAME) \
+	__libc_lock_release_recursive(&(NAME))
+
+#define __cond_init(NAME) \
+	__libc_cond_init(&(NAME))
+
+#define __cond_signal(NAME) \
+	__libc_cond_signal(&(NAME))
+
+#define __cond_broadcast(NAME) \
+	__libc_cond_broadcast(&(NAME))
+
+#define __cond_wait(NAME, LOCK, TIMEOUT) \
+	__libc_cond_wait(&(NAME), &(LOCK), (TIMEOUT))
+
+#define __cond_wait_recursive(NAME, LOCK, TIMEOUT) \
+	__libc_cond_wait_recursive(&(NAME), &(LOCK), (TIMEOUT))
 
-#endif /* __SYS_LOCK_H__ */
+#endif // __SYS_LOCK_H__
diff --git a/newlib/libc/include/sys/param.h b/newlib/libc/include/sys/param.h
index 9a6f115..fdd6cf9 100644
--- a/newlib/libc/include/sys/param.h
+++ b/newlib/libc/include/sys/param.h
@@ -23,7 +23,7 @@
 # define PATHSIZE (1024)
 #endif
 
-#define MAXPATHLEN PATH_MAX
+#define MAXPATHLEN	PATHSIZE
 
 #define MAX(a,b) ((a) > (b) ? (a) : (b))
 #define MIN(a,b) ((a) < (b) ? (a) : (b))
diff --git a/newlib/libc/include/sys/reent.h b/newlib/libc/include/sys/reent.h
index 74b70e9..d8c5410 100644
--- a/newlib/libc/include/sys/reent.h
+++ b/newlib/libc/include/sys/reent.h
@@ -421,6 +421,8 @@ struct _reent
   __FILE *__sf;			        /* file descriptors */
   struct _misc_reent *_misc;            /* strtok, multibyte states */
   char *_signal_buf;                    /* strsignal */
+
+  void *deviceData;
 };
 
 #ifdef _REENT_GLOBAL_STDIO_STREAMS
@@ -691,6 +693,7 @@ struct _reent
 # ifndef _REENT_GLOBAL_STDIO_STREAMS
   __FILE __sf[3];  		/* first three file descriptors */
 # endif
+  void *deviceData;
 };
 
 #ifdef _REENT_GLOBAL_STDIO_STREAMS
diff --git a/newlib/libc/include/sys/stat.h b/newlib/libc/include/sys/stat.h
index 8769112..5526e59 100644
--- a/newlib/libc/include/sys/stat.h
+++ b/newlib/libc/include/sys/stat.h
@@ -142,8 +142,9 @@ int	mkfifo (const char *__path, mode_t __mode );
 int	stat (const char *__restrict __path, struct stat *__restrict __sbuf );
 mode_t	umask (mode_t __mask );
 
-#if defined (__SPU__) || defined(__rtems__) || defined(__CYGWIN__) && !defined(__INSIDE_CYGWIN__)
 int	lstat (const char *__restrict __path, struct stat *__restrict __buf );
+
+#if defined (__SPU__) || defined(__rtems__) || defined(__CYGWIN__) && !defined(__INSIDE_CYGWIN__)
 int	mknod (const char *__path, mode_t __mode, dev_t __dev );
 #endif
 
diff --git a/newlib/libc/include/sys/statvfs.h b/newlib/libc/include/sys/statvfs.h
new file mode 100644
index 0000000..380329d
--- /dev/null
+++ b/newlib/libc/include/sys/statvfs.h
@@ -0,0 +1,35 @@
+#ifndef _SYS_STATVFS_H
+#define _SYS_STATVFS_H
+
+
+#define ST_RDONLY 0x0001
+#define ST_NOSUID 0x0002
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+
+struct statvfs {
+	unsigned long f_bsize;
+	unsigned long f_frsize;
+	fsblkcnt_t f_blocks;
+	fsblkcnt_t f_bfree;
+	fsblkcnt_t f_bavail;
+	fsfilcnt_t f_files;
+	fsfilcnt_t f_ffree;
+	fsfilcnt_t f_favail;
+	unsigned long f_fsid;
+	unsigned long f_flag;
+	unsigned long f_namemax;
+}; 
+
+int statvfs(const char *path, struct statvfs *buf);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif // _SYS_STATVFS_H
\ No newline at end of file
diff --git a/newlib/libc/include/sys/syslimits.h b/newlib/libc/include/sys/syslimits.h
index ba9dbd6..49c213c 100644
--- a/newlib/libc/include/sys/syslimits.h
+++ b/newlib/libc/include/sys/syslimits.h
@@ -62,4 +62,6 @@
 #define	LINE_MAX		 2048	/* max bytes in an input line */
 #define	RE_DUP_MAX		  255	/* max RE's in interval notation */
 
+#define	PTHREAD_DESTRUCTOR_ITERATIONS	1	/* max attempts to destroy TLS values on thread exit */
+
 #endif
diff --git a/newlib/libc/include/sys/utime.h b/newlib/libc/include/sys/utime.h
index 5e937f1..635a7a6 100644
--- a/newlib/libc/include/sys/utime.h
+++ b/newlib/libc/include/sys/utime.h
@@ -9,12 +9,19 @@
 extern "C" {
 #endif
 
-struct utimbuf 
+struct utimbuf
 {
   time_t actime;
-  time_t modtime; 
+  time_t modtime;
 };
 
+/* Functions */
+
+int utime(
+  const char           *path,
+  const struct utimbuf *times
+);
+
 #ifdef __cplusplus
 };
 #endif
diff --git a/newlib/libc/locale/locale.c b/newlib/libc/locale/locale.c
index 4c343e4..c044934 100644
--- a/newlib/libc/locale/locale.c
+++ b/newlib/libc/locale/locale.c
@@ -92,7 +92,7 @@ beginning with <<"LC_">>.
 
 <<localeconv>> returns a pointer to a structure (also defined in
 `<<locale.h>>') describing the locale-specific conventions currently
-in effect.  
+in effect.
 
 <<_localeconv_r>> and <<_setlocale_r>> are reentrant versions of
 <<localeconv>> and <<setlocale>> respectively.  The extra argument
@@ -166,15 +166,18 @@ No supporting OS subroutines are required.
 #include "../ctype/ctype_.h"
 #include "../stdlib/local.h"
 
+
 #ifdef __CYGWIN__ /* Has to be kept available as exported symbol for
 		     backward compatibility.  Set it in setlocale, but
 		     otherwise ignore it.  Applications compiled after
 		     2010 don't use it anymore. */
+
 int __EXPORT __mb_cur_max = 6;
 #endif
 
 char *_PathLocale = NULL;
 
+
 #ifdef _MB_CAPABLE
 /*
  * Category names for getenv()
@@ -194,7 +197,11 @@ static char *categories[_LC_LAST] = {
  * Default locale per POSIX.  Can be overridden on a per-target base.
  */
 #ifndef DEFAULT_LOCALE
-#define DEFAULT_LOCALE	"C"
+#ifdef __DEFAULT_UTF8__
+#define DEFAULT_LOCALE	 "C.UTF-8"
+#else
+#define DEFAULT_LOCALE	 "C"
+#endif
 #endif
 
 #ifdef _MB_CAPABLE
@@ -207,8 +214,13 @@ char __default_locale[ENCODING_LEN + 1] = DEFAULT_LOCALE;
 const struct __locale_t __C_locale =
 {
   { "C", "C", "C", "C", "C", "C", "C", },
+#if defined ( __DEFAULT_UTF8__ )
+  __utf8_wctomb,
+  __utf8_mbtowc,
+#else
   __ascii_wctomb,
   __ascii_mbtowc,
+#endif
   0,
   DEFAULT_CTYPE_PTR,
   {
@@ -219,9 +231,15 @@ const struct __locale_t __C_locale =
     CHAR_MAX, CHAR_MAX
   },
 #ifndef __HAVE_LOCALE_INFO__
+#ifdef __DEFAULT_UTF8__
+  "\6",
+  "UTF-8",
+  "UTF-8",
+#else
   "\1",
   "ASCII",
   "ASCII",
+#endif
 #else /* __HAVE_LOCALE_INFO__ */
   {
     { NULL, NULL },			/* LC_ALL */
@@ -240,10 +258,11 @@ const struct __locale_t __C_locale =
 };
 #endif /* _MB_CAPABLE */
 
+
 struct __locale_t __global_locale =
 {
   { "C", "C", DEFAULT_LOCALE, "C", "C", "C", "C", },
-#ifdef __CYGWIN__
+#if defined ( __CYGWIN__ ) || defined ( __DEFAULT_UTF8__ )
   __utf8_wctomb,
   __utf8_mbtowc,
 #else
@@ -260,9 +279,15 @@ struct __locale_t __global_locale =
     CHAR_MAX, CHAR_MAX
   },
 #ifndef __HAVE_LOCALE_INFO__
+#ifdef __DEFAULT_UTF8__
+  "\6",
+  "UTF-8",
+  "UTF-8",
+#else
   "\1",
   "ASCII",
   "ASCII",
+#endif
 #else /* __HAVE_LOCALE_INFO__ */
   {
     { NULL, NULL },			/* LC_ALL */
@@ -296,7 +321,7 @@ _setlocale_r (struct _reent *p,
 {
 #ifndef _MB_CAPABLE
   if (locale)
-    { 
+    {
       if (strcmp (locale, "POSIX") && strcmp (locale, "C")
 	  && strcmp (locale, ""))
         return NULL;
@@ -990,6 +1015,7 @@ __locale_ctype_ptr_l (struct __locale_t *locale)
 
 const char *
 __locale_ctype_ptr (void)
+
 {
   return __get_current_locale ()->ctype_ptr;
 }
diff --git a/newlib/libc/locale/setlocale.h b/newlib/libc/locale/setlocale.h
index a0c8084..efabdcf 100644
--- a/newlib/libc/locale/setlocale.h
+++ b/newlib/libc/locale/setlocale.h
@@ -217,11 +217,7 @@ __get_global_locale ()
 _ELIDABLE_INLINE struct __locale_t *
 __get_locale_r (struct _reent *r)
 {
-#ifdef __HAVE_LOCALE_INFO__
   return r->_locale;
-#else
-  return __get_global_locale();
-#endif
 }
 
 /* In POSIX terms the current locale is the locale used by all functions
@@ -231,11 +227,7 @@ __get_locale_r (struct _reent *r)
 _ELIDABLE_INLINE struct __locale_t *
 __get_current_locale (void)
 {
-#ifdef __HAVE_LOCALE_INFO__
   return _REENT->_locale ?: __get_global_locale ();
-#else
-  return __get_global_locale();
-#endif
 }
 
 /* Only access fixed "C" locale using this function.  Fake for !_MB_CAPABLE
diff --git a/newlib/libc/machine/aarch64/Makefile.am b/newlib/libc/machine/aarch64/Makefile.am
index e8b8197..011f69d 100644
--- a/newlib/libc/machine/aarch64/Makefile.am
+++ b/newlib/libc/machine/aarch64/Makefile.am
@@ -9,6 +9,7 @@ AM_CCASFLAGS = $(INCLUDES)
 noinst_LIBRARIES = lib.a
 
 lib_a_SOURCES =
+lib_a_SOURCES += access.c
 lib_a_SOURCES += memchr-stub.c
 lib_a_SOURCES += memchr.S
 lib_a_SOURCES += memcmp-stub.c
diff --git a/newlib/libc/machine/aarch64/Makefile.in b/newlib/libc/machine/aarch64/Makefile.in
index 39b23a1..9695124 100644
--- a/newlib/libc/machine/aarch64/Makefile.in
+++ b/newlib/libc/machine/aarch64/Makefile.in
@@ -69,22 +69,22 @@ LIBRARIES = $(noinst_LIBRARIES)
 ARFLAGS = cru
 lib_a_AR = $(AR) $(ARFLAGS)
 lib_a_LIBADD =
-am_lib_a_OBJECTS = lib_a-memchr-stub.$(OBJEXT) lib_a-memchr.$(OBJEXT) \
-	lib_a-memcmp-stub.$(OBJEXT) lib_a-memcmp.$(OBJEXT) \
-	lib_a-memcpy-stub.$(OBJEXT) lib_a-memcpy.$(OBJEXT) \
-	lib_a-memmove-stub.$(OBJEXT) lib_a-memmove.$(OBJEXT) \
-	lib_a-memset-stub.$(OBJEXT) lib_a-memset.$(OBJEXT) \
-	lib_a-rawmemchr.$(OBJEXT) lib_a-rawmemchr-stub.$(OBJEXT) \
-	lib_a-setjmp.$(OBJEXT) lib_a-stpcpy-stub.$(OBJEXT) \
-	lib_a-stpcpy.$(OBJEXT) lib_a-strchr-stub.$(OBJEXT) \
-	lib_a-strchr.$(OBJEXT) lib_a-strchrnul-stub.$(OBJEXT) \
-	lib_a-strchrnul.$(OBJEXT) lib_a-strcmp-stub.$(OBJEXT) \
-	lib_a-strcmp.$(OBJEXT) lib_a-strcpy-stub.$(OBJEXT) \
-	lib_a-strcpy.$(OBJEXT) lib_a-strlen-stub.$(OBJEXT) \
-	lib_a-strlen.$(OBJEXT) lib_a-strncmp-stub.$(OBJEXT) \
-	lib_a-strncmp.$(OBJEXT) lib_a-strnlen-stub.$(OBJEXT) \
-	lib_a-strnlen.$(OBJEXT) lib_a-strrchr-stub.$(OBJEXT) \
-	lib_a-strrchr.$(OBJEXT)
+am_lib_a_OBJECTS = lib_a-access.$(OBJEXT) lib_a-memchr-stub.$(OBJEXT) \
+	lib_a-memchr.$(OBJEXT) lib_a-memcmp-stub.$(OBJEXT) \
+	lib_a-memcmp.$(OBJEXT) lib_a-memcpy-stub.$(OBJEXT) \
+	lib_a-memcpy.$(OBJEXT) lib_a-memmove-stub.$(OBJEXT) \
+	lib_a-memmove.$(OBJEXT) lib_a-memset-stub.$(OBJEXT) \
+	lib_a-memset.$(OBJEXT) lib_a-rawmemchr.$(OBJEXT) \
+	lib_a-rawmemchr-stub.$(OBJEXT) lib_a-setjmp.$(OBJEXT) \
+	lib_a-stpcpy-stub.$(OBJEXT) lib_a-stpcpy.$(OBJEXT) \
+	lib_a-strchr-stub.$(OBJEXT) lib_a-strchr.$(OBJEXT) \
+	lib_a-strchrnul-stub.$(OBJEXT) lib_a-strchrnul.$(OBJEXT) \
+	lib_a-strcmp-stub.$(OBJEXT) lib_a-strcmp.$(OBJEXT) \
+	lib_a-strcpy-stub.$(OBJEXT) lib_a-strcpy.$(OBJEXT) \
+	lib_a-strlen-stub.$(OBJEXT) lib_a-strlen.$(OBJEXT) \
+	lib_a-strncmp-stub.$(OBJEXT) lib_a-strncmp.$(OBJEXT) \
+	lib_a-strnlen-stub.$(OBJEXT) lib_a-strnlen.$(OBJEXT) \
+	lib_a-strrchr-stub.$(OBJEXT) lib_a-strrchr.$(OBJEXT)
 lib_a_OBJECTS = $(am_lib_a_OBJECTS)
 DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp =
@@ -210,7 +210,7 @@ AUTOMAKE_OPTIONS = cygnus
 INCLUDES = $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS)
 AM_CCASFLAGS = $(INCLUDES)
 noinst_LIBRARIES = lib.a
-lib_a_SOURCES = memchr-stub.c memchr.S memcmp-stub.c memcmp.S \
+lib_a_SOURCES = access.c memchr-stub.c memchr.S memcmp-stub.c memcmp.S \
 	memcpy-stub.c memcpy.S memmove-stub.c memmove.S memset-stub.c \
 	memset.S rawmemchr.S rawmemchr-stub.c setjmp.S stpcpy-stub.c \
 	stpcpy.S strchr-stub.c strchr.S strchrnul-stub.c strchrnul.S \
@@ -381,6 +381,12 @@ lib_a-strrchr.obj: strrchr.S
 .c.obj:
 	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 
+lib_a-access.o: access.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-access.o `test -f 'access.c' || echo '$(srcdir)/'`access.c
+
+lib_a-access.obj: access.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-access.obj `if test -f 'access.c'; then $(CYGPATH_W) 'access.c'; else $(CYGPATH_W) '$(srcdir)/access.c'; fi`
+
 lib_a-memchr-stub.o: memchr-stub.c
 	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-memchr-stub.o `test -f 'memchr-stub.c' || echo '$(srcdir)/'`memchr-stub.c
 
diff --git a/newlib/libc/machine/aarch64/access.c b/newlib/libc/machine/aarch64/access.c
new file mode 100644
index 0000000..980682e
--- /dev/null
+++ b/newlib/libc/machine/aarch64/access.c
@@ -0,0 +1,33 @@
+/* This is file ACCESS.C */
+/*
+ * Copyright (C) 1993 DJ Delorie
+ * All rights reserved.
+ *
+ * Redistribution, modification, and use in source and binary forms is permitted
+ * provided that the above copyright notice and following paragraph are
+ * duplicated in all such forms.
+ *
+ * This file is distributed WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+int access(const char *fn, int flags)
+{
+  struct stat s;
+  if (stat(fn, &s))
+    return -1;
+  if (s.st_mode & S_IFDIR)
+    return 0;
+  if (flags & W_OK)
+  {
+    if (s.st_mode & S_IWRITE)
+      return 0;
+    return -1;
+  }
+  return 0;
+}
+	
diff --git a/newlib/libc/machine/arm/Makefile.am b/newlib/libc/machine/arm/Makefile.am
index 9bd35e7..7311300 100644
--- a/newlib/libc/machine/arm/Makefile.am
+++ b/newlib/libc/machine/arm/Makefile.am
@@ -11,7 +11,9 @@ noinst_LIBRARIES = lib.a
 lib_a_SOURCES = setjmp.S strcmp.S strcpy.c \
 		aeabi_memcpy.c aeabi_memcpy-armv7a.S \
 		aeabi_memmove.c aeabi_memmove-soft.S \
-		aeabi_memset.c aeabi_memset-soft.S aeabi_memclr.c
+		aeabi_memset.c aeabi_memset-soft.S aeabi_memclr.c \
+		sync_synchronize.c
+
 lib_a_SOURCES += memchr-stub.c
 lib_a_SOURCES += memchr.S
 lib_a_SOURCES += memcpy-stub.c
diff --git a/newlib/libc/machine/arm/Makefile.in b/newlib/libc/machine/arm/Makefile.in
index d9dbcd5..43712f8 100644
--- a/newlib/libc/machine/arm/Makefile.in
+++ b/newlib/libc/machine/arm/Makefile.in
@@ -75,10 +75,10 @@ am_lib_a_OBJECTS = lib_a-setjmp.$(OBJEXT) lib_a-strcmp.$(OBJEXT) \
 	lib_a-aeabi_memmove.$(OBJEXT) \
 	lib_a-aeabi_memmove-soft.$(OBJEXT) \
 	lib_a-aeabi_memset.$(OBJEXT) lib_a-aeabi_memset-soft.$(OBJEXT) \
-	lib_a-aeabi_memclr.$(OBJEXT) lib_a-memchr-stub.$(OBJEXT) \
-	lib_a-memchr.$(OBJEXT) lib_a-memcpy-stub.$(OBJEXT) \
-	lib_a-memcpy.$(OBJEXT) lib_a-strlen-stub.$(OBJEXT) \
-	lib_a-strlen.$(OBJEXT)
+	lib_a-aeabi_memclr.$(OBJEXT) lib_a-sync_synchronize.$(OBJEXT) \
+	lib_a-memchr-stub.$(OBJEXT) lib_a-memchr.$(OBJEXT) \
+	lib_a-memcpy-stub.$(OBJEXT) lib_a-memcpy.$(OBJEXT) \
+	lib_a-strlen-stub.$(OBJEXT) lib_a-strlen.$(OBJEXT)
 lib_a_OBJECTS = $(am_lib_a_OBJECTS)
 DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp =
@@ -208,8 +208,8 @@ noinst_LIBRARIES = lib.a
 lib_a_SOURCES = setjmp.S strcmp.S strcpy.c aeabi_memcpy.c \
 	aeabi_memcpy-armv7a.S aeabi_memmove.c aeabi_memmove-soft.S \
 	aeabi_memset.c aeabi_memset-soft.S aeabi_memclr.c \
-	memchr-stub.c memchr.S memcpy-stub.c memcpy.S strlen-stub.c \
-	strlen.S
+	sync_synchronize.c memchr-stub.c memchr.S memcpy-stub.c \
+	memcpy.S strlen-stub.c strlen.S
 lib_a_CCASFLAGS = $(AM_CCASFLAGS)
 lib_a_CFLAGS = $(AM_CFLAGS)
 ACLOCAL_AMFLAGS = -I ../../.. -I ../../../..
@@ -367,6 +367,12 @@ lib_a-aeabi_memclr.o: aeabi_memclr.c
 lib_a-aeabi_memclr.obj: aeabi_memclr.c
 	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-aeabi_memclr.obj `if test -f 'aeabi_memclr.c'; then $(CYGPATH_W) 'aeabi_memclr.c'; else $(CYGPATH_W) '$(srcdir)/aeabi_memclr.c'; fi`
 
+lib_a-sync_synchronize.o: sync_synchronize.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sync_synchronize.o `test -f 'sync_synchronize.c' || echo '$(srcdir)/'`sync_synchronize.c
+
+lib_a-sync_synchronize.obj: sync_synchronize.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sync_synchronize.obj `if test -f 'sync_synchronize.c'; then $(CYGPATH_W) 'sync_synchronize.c'; else $(CYGPATH_W) '$(srcdir)/sync_synchronize.c'; fi`
+
 lib_a-memchr-stub.o: memchr-stub.c
 	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-memchr-stub.o `test -f 'memchr-stub.c' || echo '$(srcdir)/'`memchr-stub.c
 
diff --git a/newlib/libc/machine/arm/sync_synchronize.c b/newlib/libc/machine/arm/sync_synchronize.c
new file mode 100644
index 0000000..3acc9e0
--- /dev/null
+++ b/newlib/libc/machine/arm/sync_synchronize.c
@@ -0,0 +1,10 @@
+#if __ARM_ARCH < 6
+#include <sys/cdefs.h>
+void __attribute__((weak))
+__sync_synchronize (void)
+{
+  __warn_references (__sync_synchronize,
+		     "legacy compatible __sync_synchronize used. Not suitable for multi-threaded applications");
+  return;
+}
+#endif
diff --git a/newlib/libc/machine/arm/sys/stdio.h b/newlib/libc/machine/arm/sys/stdio.h
new file mode 100644
index 0000000..4eb278e
--- /dev/null
+++ b/newlib/libc/machine/arm/sys/stdio.h
@@ -0,0 +1,27 @@
+#ifndef _NEWLIB_STDIO_H
+#define _NEWLIB_STDIO_H
+
+#include <sys/lock.h>
+#include <sys/reent.h>
+
+/* Internal locking macros, used to protect stdio functions.  In the
+   general case, expand to nothing. Use __SSTR flag in FILE _flags to
+   detect if FILE is private to sprintf/sscanf class of functions; if
+   set then do nothing as lock is not initialised. */
+#if !defined(_flockfile)
+#ifndef __SINGLE_THREAD__
+#  define _flockfile(fp) (((fp)->_flags & __SSTR) ? 0 : __flockfile(fp))
+#else
+#  define _flockfile(fp)	(_CAST_VOID 0)
+#endif
+#endif
+
+#if !defined(_funlockfile)
+#ifndef __SINGLE_THREAD__
+#  define _funlockfile(fp) (((fp)->_flags & __SSTR) ? 0 : __funlockfile(fp))
+#else
+#  define _funlockfile(fp)	(_CAST_VOID 0)
+#endif
+#endif
+
+#endif /* _NEWLIB_STDIO_H */
diff --git a/newlib/libc/reent/getreent.c b/newlib/libc/reent/getreent.c
index 5fa98e9..ef8a15e 100644
--- a/newlib/libc/reent/getreent.c
+++ b/newlib/libc/reent/getreent.c
@@ -1,3 +1,4 @@
+#if 0
 /* default reentrant pointer when multithread enabled */
 
 #ifdef GETREENT_PROVIDED
@@ -20,3 +21,4 @@ __getreent (void)
 }
 
 #endif
+#endif
\ No newline at end of file
diff --git a/newlib/libc/reent/gettimeofdayr.c b/newlib/libc/reent/gettimeofdayr.c
index 9b982a9..8c0aaac 100644
--- a/newlib/libc/reent/gettimeofdayr.c
+++ b/newlib/libc/reent/gettimeofdayr.c
@@ -51,7 +51,7 @@ DESCRIPTION
 	Check libc.a to see if its available on yours.
 */
 
-int
+/*int
 _gettimeofday_r (struct _reent *ptr,
      struct timeval *ptimeval,
      void *ptimezone)
@@ -63,5 +63,5 @@ _gettimeofday_r (struct _reent *ptr,
     ptr->_errno = errno;
   return ret;
 }
-
+*/
 #endif /* ! defined (REENTRANT_SYSCALLS_PROVIDED) */
diff --git a/newlib/libc/stdio/fread.c b/newlib/libc/stdio/fread.c
index b358d2b..11c2343 100644
--- a/newlib/libc/stdio/fread.c
+++ b/newlib/libc/stdio/fread.c
@@ -135,7 +135,7 @@ crlf_r (struct _reent * ptr,
     }
 
   return count;
-  
+
 }
 
 #endif
@@ -187,7 +187,6 @@ _fread_r (struct _reent * ptr,
 	  int rc = 0;
 	  /* save fp buffering state */
 	  void *old_base = fp->_bf._base;
-	  void * old_p = fp->_p;
 	  int old_size = fp->_bf._size;
 	  /* allow __refill to use user's buffer */
 	  fp->_bf._base = (unsigned char *) p;
@@ -197,7 +196,7 @@ _fread_r (struct _reent * ptr,
 	  /* restore fp buffering back to original state */
 	  fp->_bf._base = old_base;
 	  fp->_bf._size = old_size;
-	  fp->_p = old_p;
+	  fp->_p = old_base;
 	  resid -= fp->_r;
 	  p += fp->_r;
 	  fp->_r = 0;
@@ -225,7 +224,32 @@ _fread_r (struct _reent * ptr,
 	  /* fp->_r = 0 ... done in __srefill */
 	  p += r;
 	  resid -= r;
-	  if (__srefill_r (ptr, fp))
+
+      int rc = 0;
+
+      if (resid>fp->_bf._size)
+      {
+        /* save fp buffering state */
+        void *old_base = fp->_bf._base;
+        void * old_p = fp->_p;
+        int old_size = fp->_bf._size;
+        /* allow __refill to use user's buffer */
+        fp->_bf._base = (unsigned char *) p;
+        fp->_bf._size = resid;
+        fp->_p = (unsigned char *) p;
+        rc = __srefill_r (ptr, fp);
+        /* restore fp buffering back to original state */
+        fp->_bf._base = old_base;
+        fp->_bf._size = old_size;
+        fp->_p = old_base;
+        resid -= fp->_r;
+        p += fp->_r;
+        fp->_r = 0;
+
+      } else {
+        rc = __srefill_r (ptr, fp);
+      }
+	  if (rc)
 	    {
 	      /* no more input: return partial result */
 #ifdef __SCLE
diff --git a/newlib/libc/stdio/local.h b/newlib/libc/stdio/local.h
index 53694aa..79a8f46 100644
--- a/newlib/libc/stdio/local.h
+++ b/newlib/libc/stdio/local.h
@@ -56,7 +56,7 @@
    the appropriate _newlib_XXX_exit macro. */
 
 #if !defined (__SINGLE_THREAD__) && defined (_POSIX_THREADS) \
-    && !defined (__rtems__)
+    && !defined (__rtems__) && !defined (__DEVKITA64__)
 #define _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
 #endif
 
diff --git a/newlib/libc/stdio/vfprintf.c b/newlib/libc/stdio/vfprintf.c
index c4bf2db..d756df3 100644
--- a/newlib/libc/stdio/vfprintf.c
+++ b/newlib/libc/stdio/vfprintf.c
@@ -112,6 +112,8 @@ Supporting OS subroutines required: <<close>>, <<fstat>>, <<isatty>>,
 <<lseek>>, <<read>>, <<sbrk>>, <<write>>.
 */
 
+#pragma GCC optimize ("Os")
+
 #if defined(LIBC_SCCS) && !defined(lint)
 /*static char *sccsid = "from: @(#)vfprintf.c	5.50 (Berkeley) 12/16/92";*/
 static char *rcsid = "$Id$";
@@ -1438,7 +1440,7 @@ reswitch:	switch (ch) {
 string:
 #endif
 			sign = '\0';
-#ifndef __OPTIMIZE_SIZE__
+//#ifndef __OPTIMIZE_SIZE__
 			/* Behavior is undefined if the user passed a
 			   NULL string when precision is not 0.
 			   However, if we are not optimizing for size,
@@ -1448,7 +1450,7 @@ string:
 				size = ((unsigned) prec > 6U) ? 6 : prec;
 			}
 			else
-#endif /* __OPTIMIZE_SIZE__ */
+//#endif /* __OPTIMIZE_SIZE__ */
 #ifdef _MB_CAPABLE
 			if (ch == 'S' || (flags & LONGINT)) {
 				mbstate_t ps;
diff --git a/newlib/libc/stdio/vfscanf.c b/newlib/libc/stdio/vfscanf.c
index 9c38eeb..fbc8d87 100644
--- a/newlib/libc/stdio/vfscanf.c
+++ b/newlib/libc/stdio/vfscanf.c
@@ -74,6 +74,8 @@ These are GNU extensions.
 Supporting OS subroutines required:
 */
 
+#pragma GCC optimize ("Os")
+
 #include <_ansi.h>
 #include <reent.h>
 #include <newlib.h>
diff --git a/newlib/libc/stdio/vfwprintf.c b/newlib/libc/stdio/vfwprintf.c
index 980b31e..722be90 100644
--- a/newlib/libc/stdio/vfwprintf.c
+++ b/newlib/libc/stdio/vfwprintf.c
@@ -92,6 +92,9 @@ SEEALSO
  *
  * This code is large and complicated...
  */
+
+#pragma GCC optimize ("Os")
+
 #include <newlib.h>
 
 #ifdef INTEGER_ONLY
diff --git a/newlib/libc/stdio/vfwscanf.c b/newlib/libc/stdio/vfwscanf.c
index ffb6cc8..db33d4f 100644
--- a/newlib/libc/stdio/vfwscanf.c
+++ b/newlib/libc/stdio/vfwscanf.c
@@ -74,6 +74,9 @@ PORTABILITY
 C99, POSIX-1.2008
 */
 
+
+#pragma GCC optimize ("Os")
+
 #include <_ansi.h>
 #include <reent.h>
 #include <newlib.h>
diff --git a/newlib/libc/stdlib/Makefile.am b/newlib/libc/stdlib/Makefile.am
index 357e37b..7183b21 100644
--- a/newlib/libc/stdlib/Makefile.am
+++ b/newlib/libc/stdlib/Makefile.am
@@ -110,6 +110,7 @@ MALLOCR=mallocr
 endif
 
 EXTENDED_SOURCES = \
+	threads.c	\
 	arc4random.c	\
 	arc4random_uniform.c \
 	cxa_atexit.c	\
diff --git a/newlib/libc/stdlib/Makefile.in b/newlib/libc/stdlib/Makefile.in
index 699831f..1e6d2e6 100644
--- a/newlib/libc/stdlib/Makefile.in
+++ b/newlib/libc/stdlib/Makefile.in
@@ -119,7 +119,7 @@ am__objects_2 = lib_a-__adjust.$(OBJEXT) lib_a-__atexit.$(OBJEXT) \
 	lib_a-wcstoumax.$(OBJEXT) lib_a-wcstombs.$(OBJEXT) \
 	lib_a-wcstombs_r.$(OBJEXT) lib_a-wctomb.$(OBJEXT) \
 	lib_a-wctomb_r.$(OBJEXT) $(am__objects_1)
-am__objects_3 = lib_a-arc4random.$(OBJEXT) \
+am__objects_3 = lib_a-threads.$(OBJEXT) lib_a-arc4random.$(OBJEXT) \
 	lib_a-arc4random_uniform.$(OBJEXT) lib_a-cxa_atexit.$(OBJEXT) \
 	lib_a-cxa_finalize.$(OBJEXT) lib_a-drand48.$(OBJEXT) \
 	lib_a-ecvtbuf.$(OBJEXT) lib_a-efgcvt.$(OBJEXT) \
@@ -173,7 +173,7 @@ am__objects_9 = __adjust.lo __atexit.lo __call_atexit.lo __exp10.lo \
 	utoa.lo wcstod.lo wcstoimax.lo wcstol.lo wcstoul.lo \
 	wcstoumax.lo wcstombs.lo wcstombs_r.lo wctomb.lo wctomb_r.lo \
 	$(am__objects_8)
-am__objects_10 = arc4random.lo arc4random_uniform.lo cxa_atexit.lo \
+am__objects_10 = threads.lo arc4random.lo arc4random_uniform.lo cxa_atexit.lo \
 	cxa_finalize.lo drand48.lo ecvtbuf.lo efgcvt.lo erand48.lo \
 	jrand48.lo lcong48.lo lrand48.lo mrand48.lo msize.lo mtrim.lo \
 	nrand48.lo rand48.lo seed48.lo srand48.lo strtoll.lo \
@@ -1054,6 +1054,12 @@ lib_a-wcstold.o: wcstold.c
 lib_a-wcstold.obj: wcstold.c
 	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wcstold.obj `if test -f 'wcstold.c'; then $(CYGPATH_W) 'wcstold.c'; else $(CYGPATH_W) '$(srcdir)/wcstold.c'; fi`
 
+lib_a-threads.o: threads.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-threads.o `test -f 'threads.c' || echo '$(srcdir)/'`threads.c
+
+lib_a-threads.obj: threads.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-threads.obj `if test -f 'threads.c'; then $(CYGPATH_W) 'threads.c'; else $(CYGPATH_W) '$(srcdir)/threads.c'; fi`
+
 lib_a-arc4random.o: arc4random.c
 	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-arc4random.o `test -f 'arc4random.c' || echo '$(srcdir)/'`arc4random.c
 
diff --git a/newlib/libc/stdlib/aligned_alloc.c b/newlib/libc/stdlib/aligned_alloc.c
index 88413ce..24029a6 100644
--- a/newlib/libc/stdlib/aligned_alloc.c
+++ b/newlib/libc/stdlib/aligned_alloc.c
@@ -1,5 +1,5 @@
 /*-
- * Copyright (c) 2015 embedded brains GmbH
+ * Copyright (c) 2018 Dave Murphy
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -25,14 +25,15 @@
  */
 
 #include <stdlib.h>
+#include <malloc.h>
+#include <errno.h>
 
 void *
 aligned_alloc(size_t alignment, size_t size)
 {
-	void *p;
-	int error;
+	if ((alignment !=0) && !(alignment & (alignment - 1 )) && !(size & (alignment - 1)))
+		return memalign(alignment,size);
 
-	error = posix_memalign(&p, alignment, size);
-
-	return (error == 0 ? p : NULL);
+	errno = EINVAL;
+	return (void*)NULL;
 }
diff --git a/newlib/libc/stdlib/mbtowc_r.c b/newlib/libc/stdlib/mbtowc_r.c
index 920a7ea..ba5ee76 100644
--- a/newlib/libc/stdlib/mbtowc_r.c
+++ b/newlib/libc/stdlib/mbtowc_r.c
@@ -7,6 +7,7 @@
 #include <errno.h>
 #include "local.h"
 
+
 int
 _mbtowc_r (struct _reent *r,
         wchar_t       *__restrict pwc,
diff --git a/newlib/libc/stdlib/threads.c b/newlib/libc/stdlib/threads.c
new file mode 100755
index 0000000..741111e
--- /dev/null
+++ b/newlib/libc/stdlib/threads.c
@@ -0,0 +1,224 @@
+/*-
+ * Copyright (c) 2019 fincs <fincs@devkitpro.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <time.h>
+#include <threads.h>
+#include <sched.h>
+
+#if defined(PTHREAD_MUTEX_INITIALIZER) && defined(PTHREAD_RECURSIVE_MUTEX_INITIALIZER)
+#define MTX_DIRECT_INIT
+#endif
+
+#if defined(PTHREAD_COND_INITIALIZER)
+#define CND_DIRECT_INIT
+#endif
+
+static inline int err2thrd(int err)
+{
+    switch (err) {
+        case 0:
+            return thrd_success;
+        case EBUSY:
+            return thrd_busy;
+        case ETIMEDOUT:
+            return thrd_timedout;
+        case ENOMEM:
+            return thrd_nomem;
+        default:
+            return thrd_error;
+    }
+}
+
+void call_once(once_flag *flag, void (*func)(void))
+{
+    pthread_once(flag, func);
+}
+
+int cnd_broadcast(cnd_t *cond)
+{
+    int err = pthread_cond_broadcast(cond);
+    return err2thrd(err);
+}
+
+void cnd_destroy(cnd_t *cond)
+{
+#ifndef CND_DIRECT_INIT
+    pthread_cond_destroy(cond);
+#endif
+}
+
+int cnd_init(cnd_t *cond)
+{
+#ifdef CND_DIRECT_INIT
+    *cond = PTHREAD_COND_INITIALIZER;
+    return thrd_success;
+#else
+    int err = pthread_cond_init(cond, NULL);
+    return err2thrd(err);
+#endif
+}
+
+int cnd_signal(cnd_t *cond)
+{
+    int err = pthread_cond_signal(cond);
+    return err2thrd(err);
+}
+
+int cnd_timedwait(cnd_t *__restrict cond, mtx_t *__restrict mtx, const struct timespec *__restrict abs_time)
+{
+    int err = pthread_cond_timedwait(cond, mtx, abs_time);
+    return err2thrd(err);
+}
+
+int cnd_wait(cnd_t *cond, mtx_t *mtx)
+{
+    int err = pthread_cond_wait(cond, mtx);
+    return err2thrd(err);
+}
+
+void mtx_destroy(mtx_t *mtx)
+{
+#ifndef MTX_DIRECT_INIT
+    pthread_mutex_destroy(mtx);
+#endif
+}
+
+int mtx_init(mtx_t *mtx, int type)
+{
+    if (type & mtx_timed)
+        return thrd_error;
+#ifdef MTX_DIRECT_INIT
+    if (type & mtx_recursive)
+        *mtx = PTHREAD_RECURSIVE_MUTEX_INITIALIZER;
+    else
+        *mtx = PTHREAD_MUTEX_INITIALIZER;
+    return thrd_success;
+#else
+    pthread_mutexattr_t attr;
+    pthread_mutexattr_init(&attr);
+    if (type & mtx_plain)
+        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL);
+    if (type & mtx_recursive)
+        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
+    int err = pthread_mutex_init(mtx, &attr);
+    pthread_mutexattr_destroy(&attr);
+    return err2thrd(err);
+#endif
+}
+
+int mtx_lock(mtx_t *mtx)
+{
+    int err = pthread_mutex_lock(mtx);
+    return err2thrd(err);
+}
+
+int mtx_timedlock(mtx_t *__restrict mtx, const struct timespec *__restrict ts)
+{
+    return thrd_error;
+}
+
+int mtx_trylock(mtx_t *mtx)
+{
+    int err = pthread_mutex_trylock(mtx);
+    return err2thrd(err);
+}
+
+int mtx_unlock(mtx_t *mtx)
+{
+    int err = pthread_mutex_unlock(mtx);
+    return err2thrd(err);
+}
+
+int thrd_create(thrd_t *thr, thrd_start_t func, void *arg)
+{
+    int err = pthread_create(thr, NULL, (void*(*)(void*))func, arg);
+    return err2thrd(err);
+}
+
+thrd_t thrd_current(void)
+{
+    return pthread_self();
+}
+
+int thrd_detach(thrd_t thr)
+{
+    int err = pthread_detach(thr);
+    return err2thrd(err);
+}
+
+int thrd_equal(thrd_t thr1, thrd_t thr2)
+{
+    return pthread_equal(thr1, thr2);
+}
+
+void thrd_exit(int res)
+{
+    pthread_exit((void*)(uintptr_t)res);
+}
+
+int thrd_join(thrd_t thr, int *res)
+{
+    void *value = NULL;
+    int err = pthread_join(thr, &value);
+    if (!err && res)
+        *res = (uintptr_t)value;
+    return err2thrd(err);
+}
+
+int thrd_sleep(const struct timespec *duration, struct timespec *remaining)
+{
+    return nanosleep(duration, remaining);
+}
+
+void thrd_yield(void)
+{
+    sched_yield();
+}
+
+int tss_create(tss_t *key, tss_dtor_t dtor)
+{
+    int err = pthread_key_create(key, dtor);
+    return err2thrd(err);
+}
+
+void tss_delete(tss_t key)
+{
+    pthread_key_delete(key);
+}
+
+void * tss_get(tss_t key)
+{
+    return pthread_getspecific(key);
+}
+
+int tss_set(tss_t key, void *val)
+{
+    int err = pthread_setspecific(key, val);
+    return err2thrd(err);
+}
diff --git a/newlib/libc/sys/arm/include/machine/_types.h b/newlib/libc/sys/arm/include/machine/_types.h
new file mode 100644
index 0000000..40092f9
--- /dev/null
+++ b/newlib/libc/sys/arm/include/machine/_types.h
@@ -0,0 +1,19 @@
+#ifndef _MACHINE__TYPES_H
+#define _MACHINE__TYPES_H
+
+#include <machine/_default_types.h>
+
+/* Use 64bit types */
+typedef __int64_t _off_t;
+#define __machine_off_t_defined
+
+typedef __int64_t _fpos_t;
+#define __machine_fpos_t_defined
+
+typedef __uint32_t __ino_t;
+#define __machine_ino_t_defined
+
+typedef __uint32_t __dev_t;
+#define __machine_dev_t_defined
+#endif
+
diff --git a/newlib/libc/sys/arm/sys/lock.h b/newlib/libc/sys/arm/sys/lock.h
new file mode 100644
index 0000000..567fed5
--- /dev/null
+++ b/newlib/libc/sys/arm/sys/lock.h
@@ -0,0 +1,66 @@
+#ifndef __SYS_LOCK_H__
+#define __SYS_LOCK_H__
+
+#include <_ansi.h>
+#include <stdint.h>
+
+typedef int32_t _LOCK_T;
+
+struct __lock_t {
+	_LOCK_T lock;
+	uint32_t thread_tag;
+	uint32_t counter;
+};
+
+typedef struct __lock_t _LOCK_RECURSIVE_T;
+
+extern void __libc_lock_init(_LOCK_T *lock);
+extern void __libc_lock_init_recursive(_LOCK_RECURSIVE_T *lock);
+extern void __libc_lock_close(_LOCK_T *lock);
+extern void __libc_lock_close_recursive(_LOCK_RECURSIVE_T *lock);
+extern void __libc_lock_acquire(_LOCK_T *lock);
+extern void __libc_lock_acquire_recursive(_LOCK_RECURSIVE_T *lock);
+extern void __libc_lock_release(_LOCK_T *lock);
+extern void __libc_lock_release_recursive(_LOCK_RECURSIVE_T *lock);
+
+/* Returns 0 for success and non-zero for failure */
+extern int __libc_lock_try_acquire(_LOCK_T *lock);
+extern int __libc_lock_try_acquire_recursive(_LOCK_RECURSIVE_T *lock);
+
+#define __LOCK_INIT(CLASS,NAME) \
+CLASS _LOCK_T NAME = 1;
+
+#define __LOCK_INIT_RECURSIVE(CLASS,NAME) \
+CLASS _LOCK_RECURSIVE_T NAME = {1,0,0};
+
+#define __lock_init(NAME) \
+	__libc_lock_init(&(NAME))
+
+#define __lock_init_recursive(NAME) \
+	__libc_lock_init_recursive(&(NAME))
+
+#define __lock_close(NAME) \
+	__libc_lock_close(&(NAME))
+
+#define __lock_close_recursive(NAME) \
+	__libc_lock_close_recursive(&(NAME))
+
+#define __lock_acquire(NAME) \
+	__libc_lock_acquire(&(NAME))
+
+#define __lock_acquire_recursive(NAME) \
+	__libc_lock_acquire_recursive(&(NAME))
+
+#define __lock_try_acquire(NAME) \
+	__libc_lock_try_acquire(&(NAME))
+
+#define __lock_try_acquire_recursive(NAME) \
+	__libc_lock_try_acquire_recursive(&(NAME))
+
+#define __lock_release(NAME) \
+	__libc_lock_release(&(NAME))
+
+#define __lock_release_recursive(NAME) \
+	__libc_lock_release_recursive(&(NAME))
+
+#endif // __SYS_LOCK_H__
