diff --git a/config/gthr.m4 b/config/gthr.m4
index 11996247f15..f21b315ce8a 100644
--- a/config/gthr.m4
+++ b/config/gthr.m4
@@ -13,6 +13,7 @@ AC_DEFUN([GCC_AC_THREAD_HEADER],
 case $1 in
     aix)	thread_header=config/rs6000/gthr-aix.h ;;
     dce)	thread_header=config/pa/gthr-dce.h ;;
+    dkp)        thread_header=config/rs6000/gthr-dkp.h ;;
     gcn)	thread_header=config/gcn/gthr-gcn.h ;;
     lynx)	thread_header=config/gthr-lynx.h ;;
     mipssde)	thread_header=config/mips/gthr-mipssde.h ;;
diff --git a/gcc/config/newlib-stdint.h b/gcc/config/newlib-stdint.h
index 98bc77b46b8..4f1690d4f4d 100644
--- a/gcc/config/newlib-stdint.h
+++ b/gcc/config/newlib-stdint.h
@@ -25,7 +25,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 /* newlib uses 32-bit long in certain cases for all non-SPU
    targets.  */
 #ifndef STDINT_LONG32
-#define STDINT_LONG32 (LONG_TYPE_SIZE == 32)
+#define STDINT_LONG32 0
 #endif
 
 #define SIG_ATOMIC_TYPE "int"
diff --git a/gcc/config/rs6000/eabi.h b/gcc/config/rs6000/eabi.h
index 5bfc377e0de..342ed1932b9 100644
--- a/gcc/config/rs6000/eabi.h
+++ b/gcc/config/rs6000/eabi.h
@@ -36,6 +36,8 @@
       builtin_assert ("system=embedded"); \
       builtin_assert ("cpu=powerpc");     \
       builtin_assert ("machine=powerpc"); \
+      builtin_define ("__DEVKITPPC__");   \
+      builtin_define ("__DEVKITPRO__");   \
       TARGET_OS_SYSV_CPP_BUILTINS ();     \
     }                                     \
   while (0)
diff --git a/gcc/config/rs6000/rs6000.h b/gcc/config/rs6000/rs6000.h
index 3503614efbd..b0a1b8e4ad7 100644
--- a/gcc/config/rs6000/rs6000.h
+++ b/gcc/config/rs6000/rs6000.h
@@ -199,6 +199,7 @@ ASM_OPT_ANY
 /* -mcpu=native handling only makes sense with compiler running on
    an PowerPC chip.  If changing this condition, also change
    the condition in driver-rs6000.cc.  */
+#if 0
 #if defined(__powerpc__) || defined(__POWERPC__) || defined(_AIX)
 /* In driver-rs6000.cc.  */
 extern const char *host_detect_local_cpu (int argc, const char **argv);
@@ -210,6 +211,8 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);
 #else
 #define ASM_CPU_NATIVE_SPEC "%(asm_default)"
 #endif
+#endif
+#define ASM_CPU_NATIVE_SPEC "%(asm_default)"
 
 #ifndef CC1_CPU_SPEC
 #ifdef HAVE_LOCAL_CPU_DETECT
diff --git a/gcc/config/rs6000/sysv4.h b/gcc/config/rs6000/sysv4.h
index ae932fc22f0..527b48878b8 100644
--- a/gcc/config/rs6000/sysv4.h
+++ b/gcc/config/rs6000/sysv4.h
@@ -581,7 +581,11 @@ GNU_USER_TARGET_CC1_SPEC
 
 /* Default starting address if specified.  */
 #define LINK_START_SPEC "\
-%{mads         : %(link_start_ads)         ; \
+%{mgcn|mogc    : %(link_start_ogc)         ; \
+  mvgc         : %(link_start_vgc)         ; \
+  mgcbios      : %(link_start_gcb)         ; \
+  mrvl         : %(link_start_rvl)         ; \
+  mads         : %(link_start_ads)         ; \
   myellowknife : %(link_start_yellowknife) ; \
   mmvme        : %(link_start_mvme)        ; \
   msim         : %(link_start_sim)         ; \
@@ -612,7 +616,8 @@ GNU_USER_TARGET_CC1_SPEC
 
 /* Any specific OS flags.  */
 #define LINK_OS_SPEC "\
-%{mads         : %(link_os_ads)         ; \
+%{mgcn|mogc|mvgc|mgcbios|mrvl         : %(link_os_ogc)         ; \
+  mads         : %(link_os_ads)         ; \
   myellowknife : %(link_os_yellowknife) ; \
   mmvme        : %(link_os_mvme)        ; \
   msim         : %(link_os_sim)         ; \
@@ -627,7 +632,10 @@ GNU_USER_TARGET_CC1_SPEC
 /* Override rs6000.h definition.  */
 #undef	CPP_SPEC
 #define	CPP_SPEC "%{posix: -D_POSIX_SOURCE} \
-%{mads         : %(cpp_os_ads)         ; \
+%{mgcn         : %(cpp_os_gcn)         ; \
+  mogc|mvgc|mgcbios         : %(cpp_os_ogc)         ; \
+  mrvl         : %(cpp_os_rvl)         ; \
+  mads         : %(cpp_os_ads)         ; \
   myellowknife : %(cpp_os_yellowknife) ; \
   mmvme        : %(cpp_os_mvme)        ; \
   msim         : %(cpp_os_sim)         ; \
@@ -641,7 +649,10 @@ GNU_USER_TARGET_CC1_SPEC
 
 #undef	STARTFILE_SPEC
 #define	STARTFILE_SPEC "\
-%{mads         : %(startfile_ads)         ; \
+%{mgcn         : %(startfile_gcn)         ; \
+  mogc|mvgc|mgcbios         : %(startfile_ogc)         ; \
+  mrvl         : %(startfile_ogc)         ; \
+  mads         : %(startfile_ads)         ; \
   myellowknife : %(startfile_yellowknife) ; \
   mmvme        : %(startfile_mvme)        ; \
   msim         : %(startfile_sim)         ; \
@@ -655,7 +666,8 @@ GNU_USER_TARGET_CC1_SPEC
 
 #undef	LIB_SPEC
 #define	LIB_SPEC "\
-%{mads         : %(lib_ads)         ; \
+%{mgcn|mogc|mvgc|mgcbios|mrvl        : %(lib_ogc)         ; \
+  mads         : %(lib_ads)         ; \
   myellowknife : %(lib_yellowknife) ; \
   mmvme        : %(lib_mvme)        ; \
   msim         : %(lib_sim)         ; \
@@ -665,11 +677,12 @@ GNU_USER_TARGET_CC1_SPEC
   mcall-openbsd: %(lib_openbsd)     ; \
                : %(lib_default)     }"
 
-#define LIB_DEFAULT_SPEC "-lc"
+#define LIB_DEFAULT_SPEC "--start-group -lsysbase -lc --end-group"
 
 #undef	ENDFILE_SPEC
 #define	ENDFILE_SPEC "\
-%{mads         : %(endfile_ads)         ; \
+%{mgcn|mogc|mvgc|mgcbios|mrvl         : %(endfile_ogc)         ; \
+  mads         : %(endfile_ads)         ; \
   myellowknife : %(endfile_yellowknife) ; \
   mmvme        : %(endfile_mvme)        ; \
   msim         : %(endfile_sim)         ; \
@@ -685,16 +698,27 @@ GNU_USER_TARGET_CC1_SPEC
 
 /* Motorola ADS support.  */
 #define LIB_ADS_SPEC "--start-group -lads -lc --end-group"
+#define LIB_OGC_SPEC "--start-group -lsysbase -lc --end-group"
 
 #define	STARTFILE_ADS_SPEC "ecrti.o%s crt0.o%s crtbegin.o%s"
+#define	STARTFILE_OGC_SPEC "ecrti.o%s crtbegin.o%s crtmain.o%s"
 
 #define	ENDFILE_ADS_SPEC "crtend.o%s ecrtn.o%s"
+#define	ENDFILE_OGC_SPEC "crtend.o%s ecrtn.o%s"
 
 #define LINK_START_ADS_SPEC "-T ads.ld%s"
+#define LINK_START_OGC_SPEC "-T ogc.ld%s"
+#define LINK_START_RVL_SPEC "-T rvl.ld%s"
+#define LINK_START_VGC_SPEC "-T vgcogc.ld%s"
+#define LINK_START_GCB_SPEC "-T gcbogc.ld%s"
 
 #define LINK_OS_ADS_SPEC ""
+#define LINK_OS_OGC_SPEC "--gc-sections"
 
 #define CPP_OS_ADS_SPEC ""
+#define CPP_OS_GCN_SPEC "-D__gamecube__ -ffunction-sections -fdata-sections"
+#define CPP_OS_OGC_SPEC "-D__gamecube__ -DHW_DOL -ffunction-sections -fdata-sections"
+#define CPP_OS_RVL_SPEC "-D__wii__ -DHW_RVL -ffunction-sections -fdata-sections"
 
 /* Motorola Yellowknife support.  */
 #define LIB_YELLOWKNIFE_SPEC "--start-group -lyk -lc --end-group"
@@ -842,6 +866,7 @@ ncrtn.o%s"
 #undef	SUBTARGET_EXTRA_SPECS
 #define	SUBTARGET_EXTRA_SPECS						\
   { "crtsavres_default",	CRTSAVRES_DEFAULT_SPEC },		\
+  { "lib_ogc",			LIB_OGC_SPEC },				\
   { "lib_ads",			LIB_ADS_SPEC },				\
   { "lib_yellowknife",		LIB_YELLOWKNIFE_SPEC },			\
   { "lib_mvme",			LIB_MVME_SPEC },			\
@@ -851,6 +876,7 @@ ncrtn.o%s"
   { "lib_netbsd",		LIB_NETBSD_SPEC },			\
   { "lib_openbsd",		LIB_OPENBSD_SPEC },			\
   { "lib_default",		LIB_DEFAULT_SPEC },			\
+  { "startfile_ogc",		STARTFILE_OGC_SPEC },			\
   { "startfile_ads",		STARTFILE_ADS_SPEC },			\
   { "startfile_yellowknife",	STARTFILE_YELLOWKNIFE_SPEC },		\
   { "startfile_mvme",		STARTFILE_MVME_SPEC },			\
@@ -860,6 +886,7 @@ ncrtn.o%s"
   { "startfile_netbsd",		STARTFILE_NETBSD_SPEC },		\
   { "startfile_openbsd",	STARTFILE_OPENBSD_SPEC },		\
   { "startfile_default",	STARTFILE_DEFAULT_SPEC },		\
+  { "endfile_ogc",		ENDFILE_OGC_SPEC },			\
   { "endfile_ads",		ENDFILE_ADS_SPEC },			\
   { "endfile_yellowknife",	ENDFILE_YELLOWKNIFE_SPEC },		\
   { "endfile_mvme",		ENDFILE_MVME_SPEC },			\
@@ -871,7 +898,11 @@ ncrtn.o%s"
   { "endfile_default",		ENDFILE_DEFAULT_SPEC },			\
   { "link_shlib",		LINK_SHLIB_SPEC },			\
   { "link_start",		LINK_START_SPEC },			\
+  { "link_start_vgc",		LINK_START_VGC_SPEC },			\
+  { "link_start_gcb",		LINK_START_GCB_SPEC },			\
+  { "link_start_rvl",		LINK_START_RVL_SPEC },			\
   { "link_start_ads",		LINK_START_ADS_SPEC },			\
+  { "link_start_ogc",		LINK_START_OGC_SPEC },			\
   { "link_start_yellowknife",	LINK_START_YELLOWKNIFE_SPEC },		\
   { "link_start_mvme",		LINK_START_MVME_SPEC },			\
   { "link_start_sim",		LINK_START_SIM_SPEC },			\
@@ -881,6 +912,7 @@ ncrtn.o%s"
   { "link_start_openbsd",	LINK_START_OPENBSD_SPEC },		\
   { "link_start_default",	LINK_START_DEFAULT_SPEC },		\
   { "link_os",			LINK_OS_SPEC },				\
+  { "link_os_ogc",		LINK_OS_OGC_SPEC },			\
   { "link_os_ads",		LINK_OS_ADS_SPEC },			\
   { "link_os_yellowknife",	LINK_OS_YELLOWKNIFE_SPEC },		\
   { "link_os_mvme",		LINK_OS_MVME_SPEC },			\
@@ -892,6 +924,9 @@ ncrtn.o%s"
   { "link_os_default",		LINK_OS_DEFAULT_SPEC },			\
   { "cc1_secure_plt_default",	CC1_SECURE_PLT_DEFAULT_SPEC },		\
   { "link_secure_plt",		LINK_SECURE_PLT_SPEC },			\
+  { "cpp_os_gcn",		CPP_OS_GCN_SPEC },			\
+  { "cpp_os_ogc",		CPP_OS_OGC_SPEC },			\
+  { "cpp_os_rvl",		CPP_OS_RVL_SPEC },			\
   { "cpp_os_ads",		CPP_OS_ADS_SPEC },			\
   { "cpp_os_yellowknife",	CPP_OS_YELLOWKNIFE_SPEC },		\
   { "cpp_os_mvme",		CPP_OS_MVME_SPEC },			\
diff --git a/gcc/config/rs6000/sysv4.opt b/gcc/config/rs6000/sysv4.opt
index 691e0d3d2e8..2eb60bc56b6 100644
--- a/gcc/config/rs6000/sysv4.opt
+++ b/gcc/config/rs6000/sysv4.opt
@@ -124,6 +124,26 @@ mads
 Target RejectNegative
 Link with libads.a, libc.a and crt0.o.
 
+mgcn
+Target RejectNegative
+Link with libsysbase.a and libc.a, use ogc linker script 
+
+mogc
+Target RejectNegative
+Link with libsysbase.a and libc.a, use ogc linker script 
+
+mgcbios
+Target RejectNegative
+Link with libsysbase.a and libc.a, use gcbogc linker script 
+
+mvgc
+Target RejectNegative
+Link with libsysbase.a and libc.a, use gcbogc linker script 
+
+mrvl
+Target RejectNegative
+Link with libsysbase.a and libc.a, use rvl linker script 
+
 myellowknife
 Target RejectNegative
 Link with libyk.a, libc.a and crt0.o.
diff --git a/gcc/configure b/gcc/configure
index c7b26d1927d..d1e32ef9ec5 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -13011,7 +13011,7 @@ case ${enable_threads} in
     # default
     target_thread_file='single'
     ;;
-  aix | dce | lynx | mipssde | posix | rtems | \
+  aix | dce | dkp | lynx | mipssde | posix | rtems | \
   single | tpf | vxworks | win32 | mcf)
     target_thread_file=${enable_threads}
     ;;
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 09082e8ccae..f5700df9455 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -2020,7 +2020,7 @@ case ${enable_threads} in
     # default
     target_thread_file='single'
     ;;
-  aix | dce | lynx | mipssde | posix | rtems | \
+  aix | dce | dkp | lynx | mipssde | posix | rtems | \
   single | tpf | vxworks | win32 | mcf)
     target_thread_file=${enable_threads}
     ;;
diff --git a/libgcc/config/rs6000/crtrestvr.S b/libgcc/config/rs6000/crtrestvr.S
index cf7f71ae123..7e0892a845f 100644
--- a/libgcc/config/rs6000/crtrestvr.S
+++ b/libgcc/config/rs6000/crtrestvr.S
@@ -24,7 +24,7 @@
 
 /* On PowerPC64 Linux, these functions are provided by the linker.  */
 #ifndef __powerpc64__
-
+#if 0
 #undef __ALTIVEC__
 #define __ALTIVEC__ 1
 	#include "ppc-asm.h"
@@ -86,3 +86,4 @@ FUNC_END(_restvr_20)
 CFI_ENDPROC
 
 #endif
+#endif
diff --git a/libgcc/config/rs6000/crtsavevr.S b/libgcc/config/rs6000/crtsavevr.S
index 19de2128714..d116593062d 100644
--- a/libgcc/config/rs6000/crtsavevr.S
+++ b/libgcc/config/rs6000/crtsavevr.S
@@ -24,7 +24,7 @@
 
 /* On PowerPC64 Linux, these functions are provided by the linker.  */
 #ifndef __powerpc64__
-
+#if 0
 #undef __ALTIVEC__
 #define __ALTIVEC__ 1
 	#include "ppc-asm.h"
@@ -86,3 +86,4 @@ FUNC_END(_savevr_20)
 CFI_ENDPROC
 
 #endif
+#endif
diff --git a/libgcc/config/rs6000/gthr-dkp.c b/libgcc/config/rs6000/gthr-dkp.c
new file mode 100644
index 00000000000..26180aa7f36
--- /dev/null
+++ b/libgcc/config/rs6000/gthr-dkp.c
@@ -0,0 +1,319 @@
+/* Threads compatibility routines for libgcc2 and libobjc.  */
+/* Compile this one with gcc.  */
+/* Copyright (C) 1997-2016 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#define _BUILDING_LIBGCC
+#include "gthr-dkp.h"
+#include <stddef.h>
+
+
+int
+__gthread_active_p (void)
+{
+  if (!__has_gthr_impl(active)) {
+    return 0;
+  }
+
+  return __gthr_impl_active();
+}
+
+int
+__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
+                  void *__args)
+{
+  if (!__has_gthr_impl(create)) {
+    return -1;
+  }
+
+  return __gthr_impl_create(__threadid, __func, __args);
+}
+
+int
+__gthread_join (__gthread_t __threadid, void **__value_ptr)
+{
+  if (!__has_gthr_impl(join)) {
+    return -1;
+  }
+
+  return __gthr_impl_join(__threadid, __value_ptr);
+}
+
+int
+__gthread_detach (__gthread_t __threadid)
+{
+  if (!__has_gthr_impl(detach)) {
+    return -1;
+  }
+
+  return __gthr_impl_detach(__threadid);
+}
+
+int
+__gthread_equal (__gthread_t __t1, __gthread_t __t2)
+{
+  if (!__has_gthr_impl(equal)) {
+    return -1;
+  }
+
+  return __gthr_impl_equal(__t1, __t2);
+}
+
+__gthread_t
+__gthread_self (void)
+{
+  if (!__has_gthr_impl(self)) {
+    __gthread_t result = { 0 };
+    return result;
+  }
+
+  return __gthr_impl_self();
+}
+
+int
+__gthread_yield (void)
+{
+  if (!__has_gthr_impl(yield)) {
+    return -1;
+  }
+
+  return __gthr_impl_yield();
+}
+
+int
+__gthread_once (__gthread_once_t *__once, void (*__func) (void))
+{
+  if (!__has_gthr_impl(once)) {
+    return -1;
+  }
+
+  return __gthr_impl_once(__once, __func);
+}
+
+int
+__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
+{
+  if (!__has_gthr_impl(key_create)) {
+    return -1;
+  }
+
+  return __gthr_impl_key_create(__key, __dtor);
+}
+
+int
+__gthread_key_delete (__gthread_key_t __key)
+{
+  if (!__has_gthr_impl(key_delete)) {
+    return -1;
+  }
+
+  return __gthr_impl_key_delete(__key);
+}
+
+void *
+__gthread_getspecific (__gthread_key_t __key)
+{
+  if (!__has_gthr_impl(getspecific)) {
+    return NULL;
+  }
+
+  return __gthr_impl_getspecific(__key);
+}
+
+int
+__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
+{
+  if (!__has_gthr_impl(setspecific)) {
+    return -1;
+  }
+
+  return __gthr_impl_setspecific(__key, __ptr);
+}
+
+void
+__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
+{
+  if (__has_gthr_impl(mutex_init_function)) {
+    __gthr_impl_mutex_init_function(__mutex);
+  }
+}
+
+int
+__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
+{
+  if (!__has_gthr_impl(mutex_destroy)) {
+    return -1;
+  }
+
+  return __gthr_impl_mutex_destroy(__mutex);
+}
+
+int
+__gthread_mutex_lock (__gthread_mutex_t *__mutex)
+{
+  if (!__has_gthr_impl(mutex_lock)) {
+    return -1;
+  }
+
+  return __gthr_impl_mutex_lock(__mutex);
+}
+
+int
+__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
+{
+  if (!__has_gthr_impl(mutex_trylock)) {
+    return -1;
+  }
+
+  return __gthr_impl_mutex_trylock(__mutex);
+}
+
+int
+__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
+{
+  if (!__has_gthr_impl(mutex_unlock)) {
+    return -1;
+  }
+
+  return __gthr_impl_mutex_unlock(__mutex);
+}
+
+int
+__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)
+{
+  if (!__has_gthr_impl(recursive_mutex_init_function)) {
+    return -1;
+  }
+
+  return __gthr_impl_recursive_mutex_init_function(__mutex);
+}
+
+int
+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
+{
+  if (!__has_gthr_impl(recursive_mutex_lock)) {
+    return -1;
+  }
+
+  return __gthr_impl_recursive_mutex_lock(__mutex);
+}
+
+int
+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
+{
+  if (!__has_gthr_impl(recursive_mutex_trylock)) {
+    return -1;
+  }
+
+  return __gthr_impl_recursive_mutex_trylock(__mutex);
+}
+
+int
+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
+{
+  if (!__has_gthr_impl(recursive_mutex_unlock)) {
+    return -1;
+  }
+
+  return __gthr_impl_recursive_mutex_unlock(__mutex);
+}
+
+int
+__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
+{
+  if (!__has_gthr_impl(recursive_mutex_destroy)) {
+    return -1;
+  }
+
+  return __gthr_impl_recursive_mutex_destroy(__mutex);
+}
+
+void
+__gthread_cond_init_function (__gthread_cond_t *__cond)
+{
+  if (__has_gthr_impl(cond_init_function)) {
+    __gthr_impl_cond_init_function(__cond);
+  }
+}
+
+int
+__gthread_cond_broadcast (__gthread_cond_t *__cond)
+{
+  if (!__has_gthr_impl(cond_broadcast)) {
+    return -1;
+  }
+
+  return __gthr_impl_cond_broadcast(__cond);
+}
+
+int
+__gthread_cond_signal (__gthread_cond_t *__cond)
+{
+  if (!__has_gthr_impl(cond_signal)) {
+    return -1;
+  }
+
+  return __gthr_impl_cond_signal(__cond);
+}
+
+int
+__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
+{
+  if (!__has_gthr_impl(cond_wait)) {
+    return -1;
+  }
+
+  return __gthr_impl_cond_wait(__cond, __mutex);
+}
+
+int
+__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
+                          const __gthread_time_t *__abs_timeout)
+{
+  if (!__has_gthr_impl(cond_timedwait)) {
+    return -1;
+  }
+
+  return __gthr_impl_cond_timedwait(__cond, __mutex, __abs_timeout);
+}
+
+int
+__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
+                               __gthread_recursive_mutex_t *__mutex)
+{
+  if (!__has_gthr_impl(cond_wait_recursive)) {
+    return -1;
+  }
+
+  return __gthr_impl_cond_wait_recursive(__cond, __mutex);
+}
+
+int
+__gthread_cond_destroy (__gthread_cond_t* __cond)
+{
+  if (!__has_gthr_impl(cond_destroy)) {
+    return -1;
+  }
+
+  return __gthr_impl_cond_destroy(__cond);
+}
diff --git a/libgcc/config/rs6000/gthr-dkp.h b/libgcc/config/rs6000/gthr-dkp.h
new file mode 100644
index 00000000000..72ecf82ab83
--- /dev/null
+++ b/libgcc/config/rs6000/gthr-dkp.h
@@ -0,0 +1,187 @@
+/* Threads compatibility routines for libgcc2 and libobjc.  */
+/* Compile this one with gcc.  */
+/* Copyright (C) 1997-2016 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef _GLIBCXX_GCC_GTHR_DKP_H
+#define _GLIBCXX_GCC_GTHR_DKP_H
+
+#define __GTHREADS 1
+#define __GTHREADS_CXX0X 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void *                      __gthread_t;
+typedef struct { int padding[7]; }  __gthread_cond_t;
+typedef struct { int padding; }     __gthread_key_t;
+typedef struct { int padding[11]; } __gthread_mutex_t;
+typedef struct { int padding; }     __gthread_once_t;
+typedef struct { int padding[11]; } __gthread_recursive_mutex_t;
+typedef struct timespec             __gthread_time_t;
+
+#define __GTHREAD_HAS_COND 1
+#define _GTHREAD_USE_MUTEX_TIMEDLOCK 0
+
+#define __GTHREAD_ONCE_INIT { 0 }
+#define __GTHREAD_TIME_INIT { 0, 0 }
+
+#define __GTHREAD_COND_INIT_FUNCTION __gthread_cond_init_function
+#define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function
+#define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function
+
+#ifdef _BUILDING_LIBGCC
+#define __GTHR_IMPL(_name) __attribute__((weak)) __gthr_impl_##_name
+#define __has_gthr_impl(_name) (&__gthr_impl_##_name)
+#else
+#define __GTHR_IMPL(_name) __gthr_impl_##_name
+#endif
+
+int __GTHR_IMPL(active) (void);
+int __GTHR_IMPL(create) (__gthread_t *__threadid, void *(*__func) (void*), void *__args);
+int __GTHR_IMPL(join) (__gthread_t __threadid, void **__value_ptr);
+int __GTHR_IMPL(detach) (__gthread_t __threadid);
+int __GTHR_IMPL(equal) (__gthread_t __t1, __gthread_t __t2);
+__gthread_t __GTHR_IMPL(self) (void);
+int __GTHR_IMPL(yield) (void);
+int __GTHR_IMPL(once) (__gthread_once_t *__once, void (*__func) (void));
+int __GTHR_IMPL(key_create) (__gthread_key_t *__key, void (*__dtor) (void *));
+int __GTHR_IMPL(key_delete) (__gthread_key_t __key);
+void * __GTHR_IMPL(getspecific) (__gthread_key_t __key);
+int __GTHR_IMPL(setspecific) (__gthread_key_t __key, const void *__ptr);
+void __GTHR_IMPL(mutex_init_function) (__gthread_mutex_t *__mutex);
+int __GTHR_IMPL(mutex_destroy) (__gthread_mutex_t *__mutex);
+int __GTHR_IMPL(mutex_lock) (__gthread_mutex_t *__mutex);
+int __GTHR_IMPL(mutex_trylock) (__gthread_mutex_t *__mutex);
+int __GTHR_IMPL(mutex_unlock) (__gthread_mutex_t *__mutex);
+int __GTHR_IMPL(recursive_mutex_init_function) (__gthread_recursive_mutex_t *__mutex);
+int __GTHR_IMPL(recursive_mutex_lock) (__gthread_recursive_mutex_t *__mutex);
+int __GTHR_IMPL(recursive_mutex_trylock) (__gthread_recursive_mutex_t *__mutex);
+int __GTHR_IMPL(recursive_mutex_unlock) (__gthread_recursive_mutex_t *__mutex);
+int __GTHR_IMPL(recursive_mutex_destroy) (__gthread_recursive_mutex_t *__mutex);
+void __GTHR_IMPL(cond_init_function) (__gthread_cond_t *__cond);
+int __GTHR_IMPL(cond_broadcast) (__gthread_cond_t *__cond);
+int __GTHR_IMPL(cond_signal) (__gthread_cond_t *__cond);
+int __GTHR_IMPL(cond_wait) (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex);
+int __GTHR_IMPL(cond_timedwait) (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
+                         const __gthread_time_t *__abs_timeout);
+int __GTHR_IMPL(cond_wait_recursive) (__gthread_cond_t *__cond,
+                              __gthread_recursive_mutex_t *__mutex);
+int __GTHR_IMPL(cond_destroy) (__gthread_cond_t* __cond);
+
+int
+__gthread_active_p (void);
+
+int
+__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
+                  void *__args);
+
+int
+__gthread_join (__gthread_t __threadid, void **__value_ptr);
+
+int
+__gthread_detach (__gthread_t __threadid);
+
+int
+__gthread_equal (__gthread_t __t1, __gthread_t __t2);
+
+__gthread_t
+__gthread_self (void);
+
+int
+__gthread_yield (void);
+
+int
+__gthread_once (__gthread_once_t *__once, void (*__func) (void));
+
+int
+__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *));
+
+int
+__gthread_key_delete (__gthread_key_t __key);
+
+void *
+__gthread_getspecific (__gthread_key_t __key);
+
+int
+__gthread_setspecific (__gthread_key_t __key, const void *__ptr);
+
+void
+__gthread_mutex_init_function (__gthread_mutex_t *__mutex);
+
+int
+__gthread_mutex_destroy (__gthread_mutex_t *__mutex);
+
+int
+__gthread_mutex_lock (__gthread_mutex_t *__mutex);
+
+int
+__gthread_mutex_trylock (__gthread_mutex_t *__mutex);
+
+int
+__gthread_mutex_unlock (__gthread_mutex_t *__mutex);
+
+int
+__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex);
+
+int
+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex);
+
+int
+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex);
+
+int
+__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex);
+
+int
+__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex);
+
+void
+__gthread_cond_init_function (__gthread_cond_t *__cond);
+
+int
+__gthread_cond_broadcast (__gthread_cond_t *__cond);
+
+int
+__gthread_cond_signal (__gthread_cond_t *__cond);
+
+int
+__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex);
+
+int
+__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
+                          const __gthread_time_t *__abs_timeout);
+
+int
+__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
+                               __gthread_recursive_mutex_t *__mutex);
+
+int
+__gthread_cond_destroy (__gthread_cond_t* __cond);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ! _GLIBCXX_GCC_GTHR_DKP_H */
diff --git a/libgcc/config/rs6000/t-ppccomm b/libgcc/config/rs6000/t-ppccomm
index fb812d3801f..7f6669d530f 100644
--- a/libgcc/config/rs6000/t-ppccomm
+++ b/libgcc/config/rs6000/t-ppccomm
@@ -1,4 +1,5 @@
 LIB2ADD += $(srcdir)/config/rs6000/ibm-ldouble.c \
+	   $(srcdir)/config/rs6000/gthr-dkp.c \
 	   $(srcdir)/config/rs6000/tramp.S
 
 # This can't end up in shared libgcc
diff --git a/libgcc/configure b/libgcc/configure
index be5d45f1755..5c5aa253655 100755
--- a/libgcc/configure
+++ b/libgcc/configure
@@ -5690,6 +5690,7 @@ tm_file="${tm_file_}"
 case $target_thread_file in
     aix)	thread_header=config/rs6000/gthr-aix.h ;;
     dce)	thread_header=config/pa/gthr-dce.h ;;
+    dkp)        thread_header=config/rs6000/gthr-dkp.h ;;
     gcn)	thread_header=config/gcn/gthr-gcn.h ;;
     lynx)	thread_header=config/gthr-lynx.h ;;
     mipssde)	thread_header=config/mips/gthr-mipssde.h ;;
diff --git a/libgcc/crtstuff.c b/libgcc/crtstuff.c
index 93ff5b81dc5..20c0fe89a28 100644
--- a/libgcc/crtstuff.c
+++ b/libgcc/crtstuff.c
@@ -326,7 +326,7 @@ register_tm_clones (void)
 
 #ifdef OBJECT_FORMAT_ELF
 
-#if DEFAULT_USE_CXA_ATEXIT
+#if 1 /* DEFAULT_USE_CXA_ATEXIT */
 /* Declare the __dso_handle variable.  It should have a unique value
    in every shared-object; in a main program its value is zero.  The
    object should in any case be protected.  This means the instance
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 68ee94c9e28..1e17f789b89 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -15800,6 +15800,7 @@ $as_echo "$target_thread_file" >&6; }
 case $target_thread_file in
     aix)	thread_header=config/rs6000/gthr-aix.h ;;
     dce)	thread_header=config/pa/gthr-dce.h ;;
+    dkp)        thread_header=config/rs6000/gthr-dkp.h ;;
     gcn)	thread_header=config/gcn/gthr-gcn.h ;;
     lynx)	thread_header=config/gthr-lynx.h ;;
     mipssde)	thread_header=config/mips/gthr-mipssde.h ;;
diff --git a/libstdc++-v3/include/std/fstream b/libstdc++-v3/include/std/fstream
index 3dff4e5e74e..7835a727321 100644
--- a/libstdc++-v3/include/std/fstream
+++ b/libstdc++-v3/include/std/fstream
@@ -48,7 +48,7 @@
 
 // This can be overridden by the target's os_defines.h
 #ifndef _GLIBCXX_BUFSIZ
-# define _GLIBCXX_BUFSIZ BUFSIZ
+# define _GLIBCXX_BUFSIZ (BUFSIZ+1)
 #endif
 
 namespace std _GLIBCXX_VISIBILITY(default)
diff --git a/libstdc++-v3/libsupc++/eh_alloc.cc b/libstdc++-v3/libsupc++/eh_alloc.cc
index 8380052c9f3..100de070f20 100644
--- a/libstdc++-v3/libsupc++/eh_alloc.cc
+++ b/libstdc++-v3/libsupc++/eh_alloc.cc
@@ -143,6 +143,7 @@ namespace
     {
     public:
       pool() noexcept;
+      ~pool();
 
       _GLIBCXX_NODISCARD void *allocate (std::size_t) noexcept;
       void free (void *) noexcept;
@@ -248,6 +249,15 @@ namespace
       first_free_entry->next = NULL;
     }
 
+  pool::~pool()
+    {
+      if (arena)
+        {
+          ::free(arena);
+          arena = 0;
+        }
+    }
+
   void *pool::allocate (std::size_t size) noexcept
     {
       __scoped_lock sentry(emergency_mutex);
diff --git a/libstdc++-v3/src/c++17/fs_ops.cc b/libstdc++-v3/src/c++17/fs_ops.cc
index c94d260632f..74c7a06a90d 100644
--- a/libstdc++-v3/src/c++17/fs_ops.cc
+++ b/libstdc++-v3/src/c++17/fs_ops.cc
@@ -1124,6 +1124,7 @@ fs::permissions(const path& p, perms prms, perm_options opts,
     }
 
   int err = 0;
+#ifndef __DEVKITPPC__
 #if _GLIBCXX_USE_FCHMODAT
   const int flag = (nofollow && is_symlink(st)) ? AT_SYMLINK_NOFOLLOW : 0;
   if (::fchmodat(AT_FDCWD, p.c_str(), static_cast<mode_t>(prms), flag))
@@ -1133,6 +1134,7 @@ fs::permissions(const path& p, perms prms, perm_options opts,
     ec = std::__unsupported();
   else if (posix::chmod(p.c_str(), static_cast<posix::mode_t>(prms)))
     err = errno;
+#endif
 #endif
 
   if (err)
diff --git a/libstdc++-v3/src/filesystem/ops-common.h b/libstdc++-v3/src/filesystem/ops-common.h
index c95511b5c95..f9be4529bb2 100644
--- a/libstdc++-v3/src/filesystem/ops-common.h
+++ b/libstdc++-v3/src/filesystem/ops-common.h
@@ -486,6 +486,7 @@ _GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM
 	return false;
       }
 
+#ifndef __DEVKITPPC__
 #if defined _GLIBCXX_USE_FCHMOD && ! defined _GLIBCXX_FILESYSTEM_IS_WINDOWS
     if (::fchmod(out.fd, from_st->st_mode))
 #elif defined _GLIBCXX_USE_FCHMODAT && ! defined _GLIBCXX_FILESYSTEM_IS_WINDOWS
@@ -497,6 +498,7 @@ _GLIBCXX_BEGIN_NAMESPACE_FILESYSTEM
 	ec.assign(errno, std::generic_category());
 	return false;
       }
+#endif
 
     size_t count = from_st->st_size;
 #if defined _GLIBCXX_USE_SENDFILE && ! defined _GLIBCXX_FILESYSTEM_IS_WINDOWS
diff --git a/libstdc++-v3/src/filesystem/ops.cc b/libstdc++-v3/src/filesystem/ops.cc
index d33c13d7f15..7c343cdc30e 100644
--- a/libstdc++-v3/src/filesystem/ops.cc
+++ b/libstdc++-v3/src/filesystem/ops.cc
@@ -972,6 +972,7 @@ fs::permissions(const path& p, perms prms, error_code& ec) noexcept
     }
 
   int err = 0;
+#ifndef __DEVKITPPC__
 #if _GLIBCXX_USE_FCHMODAT
   const int flag = (nofollow && is_symlink(st)) ? AT_SYMLINK_NOFOLLOW : 0;
   if (::fchmodat(AT_FDCWD, p.c_str(), static_cast<mode_t>(prms), flag))
@@ -981,6 +982,7 @@ fs::permissions(const path& p, perms prms, error_code& ec) noexcept
     ec = std::__unsupported();
   else if (posix::chmod(p.c_str(), static_cast<mode_t>(prms)))
     err = errno;
+#endif
 #endif
 
   if (err)
