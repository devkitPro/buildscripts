diff -Nbaur gcc-4.8.1/gcc/config/rs6000/rs6000.h gcc-4.8.1-ppc/gcc/config/rs6000/rs6000.h
--- gcc-4.8.1/gcc/config/rs6000/rs6000.h	2013-05-07 00:33:49.000000000 +0100
+++ gcc-4.8.1-ppc/gcc/config/rs6000/rs6000.h	2013-09-07 08:56:31.000000000 +0100
@@ -195,6 +195,7 @@
   { "asm_cpu_476",		ASM_CPU_476_SPEC },			\
   SUBTARGET_EXTRA_SPECS
 
+#if 0
 /* -mcpu=native handling only makes sense with compiler running on
    an PowerPC chip.  If changing this condition, also change
    the condition in driver-rs6000.c.  */
@@ -209,6 +210,8 @@
 #else
 #define ASM_CPU_NATIVE_SPEC "%(asm_default)"
 #endif
+#endif 
+#define ASM_CPU_NATIVE_SPEC "%(asm_default)"
 
 #ifndef CC1_CPU_SPEC
 #ifdef HAVE_LOCAL_CPU_DETECT
diff -Nbaur gcc-4.8.1/gcc/config/rs6000/sysv4.h gcc-4.8.1-ppc/gcc/config/rs6000/sysv4.h
--- gcc-4.8.1/gcc/config/rs6000/sysv4.h	2013-01-10 20:38:27.000000000 +0000
+++ gcc-4.8.1-ppc/gcc/config/rs6000/sysv4.h	2013-09-07 08:56:31.000000000 +0100
@@ -578,7 +578,11 @@
 
 /* Default starting address if specified.  */
 #define LINK_START_SPEC "\
-%{mads         : %(link_start_ads)         ; \
+%{mgcn|mogc         : %(link_start_ogc)         ; \
+  mvgc         : %(link_start_vgc)         ; \
+  mgcbios         : %(link_start_gcb)         ; \
+  mrvl         : %(link_start_rvl)         ; \
+  mads         : %(link_start_ads)         ; \
   myellowknife : %(link_start_yellowknife) ; \
   mmvme        : %(link_start_mvme)        ; \
   msim         : %(link_start_sim)         ; \
@@ -615,7 +619,8 @@
 
 /* Any specific OS flags.  */
 #define LINK_OS_SPEC "\
-%{mads         : %(link_os_ads)         ; \
+%{mgcn|mogc|mvgc|mgcbios|mrvl         : %(link_os_ogc)         ; \
+  mads         : %(link_os_ads)         ; \
   myellowknife : %(link_os_yellowknife) ; \
   mmvme        : %(link_os_mvme)        ; \
   msim         : %(link_os_sim)         ; \
@@ -633,7 +638,10 @@
 /* Override rs6000.h definition.  */
 #undef	CPP_SPEC
 #define	CPP_SPEC "%{posix: -D_POSIX_SOURCE} \
-%{mads         : %(cpp_os_ads)         ; \
+%{mgcn         : %(cpp_os_gcn)         ; \
+  mogc|mvgc|mgcbios         : %(cpp_os_ogc)         ; \
+  mrvl         : %(cpp_os_rvl)         ; \
+  mads         : %(cpp_os_ads)         ; \
   myellowknife : %(cpp_os_yellowknife) ; \
   mmvme        : %(cpp_os_mvme)        ; \
   msim         : %(cpp_os_sim)         ; \
@@ -647,7 +655,10 @@
 
 #undef	STARTFILE_SPEC
 #define	STARTFILE_SPEC "\
-%{mads         : %(startfile_ads)         ; \
+%{mgcn         : %(startfile_gcn)         ; \
+  mogc|mvgc|mgcbios         : %(startfile_ogc)         ; \
+  mrvl         : %(startfile_ogc)         ; \
+  mads         : %(startfile_ads)         ; \
   myellowknife : %(startfile_yellowknife) ; \
   mmvme        : %(startfile_mvme)        ; \
   msim         : %(startfile_sim)         ; \
@@ -657,11 +668,12 @@
   mcall-openbsd: %(startfile_openbsd)     ; \
                : %(startfile_default)     }"
 
-#define	STARTFILE_DEFAULT_SPEC "ecrti.o%s crtbegin.o%s"
+#define	STARTFILE_DEFAULT_SPEC "crt0.o%s ecrti.o%s crtbegin.o%s"
 
 #undef	LIB_SPEC
 #define	LIB_SPEC "\
-%{mads         : %(lib_ads)         ; \
+%{mgcn|mogc|mvgc|mgcbios|mrvl        : %(lib_ogc)         ; \
+  mads         : %(lib_ads)         ; \
   myellowknife : %(lib_yellowknife) ; \
   mmvme        : %(lib_mvme)        ; \
   msim         : %(lib_sim)         ; \
@@ -671,11 +683,12 @@
   mcall-openbsd: %(lib_openbsd)     ; \
                : %(lib_default)     }"
 
-#define LIB_DEFAULT_SPEC "-lc"
+#define LIB_DEFAULT_SPEC "--start-group -lsysbase -lc --end-group"
 
 #undef	ENDFILE_SPEC
 #define	ENDFILE_SPEC "\
-%{mads         : %(endfile_ads)         ; \
+%{mgcn|mogc|mvgc|mgcbios|mrvl         : %(endfile_ogc)         ; \
+  mads         : %(endfile_ads)         ; \
   myellowknife : %(endfile_yellowknife) ; \
   mmvme        : %(endfile_mvme)        ; \
   msim         : %(endfile_sim)         ; \
@@ -691,16 +704,27 @@
 
 /* Motorola ADS support.  */
 #define LIB_ADS_SPEC "--start-group -lads -lc --end-group"
+#define LIB_OGC_SPEC "--start-group -lsysbase -lc --end-group"
 
 #define	STARTFILE_ADS_SPEC "ecrti.o%s crt0.o%s crtbegin.o%s"
+#define	STARTFILE_OGC_SPEC "ecrti.o%s crtbegin.o%s crtmain.o%s"
 
 #define	ENDFILE_ADS_SPEC "crtend.o%s ecrtn.o%s"
+#define	ENDFILE_OGC_SPEC "crtend.o%s ecrtn.o%s"
 
 #define LINK_START_ADS_SPEC "-T ads.ld%s"
+#define LINK_START_OGC_SPEC "-T ogc.ld%s"
+#define LINK_START_RVL_SPEC "-T rvl.ld%s"
+#define LINK_START_VGC_SPEC "-T vgcogc.ld%s"
+#define LINK_START_GCB_SPEC "-T gcbogc.ld%s"
 
 #define LINK_OS_ADS_SPEC ""
+#define LINK_OS_OGC_SPEC "--gc-sections"
 
 #define CPP_OS_ADS_SPEC ""
+#define CPP_OS_GCN_SPEC "-D__gamecube__ -ffunction-sections -fdata-sections"
+#define CPP_OS_OGC_SPEC "-D__gamecube__ -DHW_DOL -ffunction-sections -fdata-sections"
+#define CPP_OS_RVL_SPEC "-D__wii__ -DHW_RVL -ffunction-sections -fdata-sections"
 
 /* Motorola Yellowknife support.  */
 #define LIB_YELLOWKNIFE_SPEC "--start-group -lyk -lc --end-group"
@@ -870,6 +894,7 @@
 #undef	SUBTARGET_EXTRA_SPECS
 #define	SUBTARGET_EXTRA_SPECS						\
   { "crtsavres_default",	CRTSAVRES_DEFAULT_SPEC },		\
+  { "lib_ogc",			LIB_OGC_SPEC },				\
   { "lib_ads",			LIB_ADS_SPEC },				\
   { "lib_yellowknife",		LIB_YELLOWKNIFE_SPEC },			\
   { "lib_mvme",			LIB_MVME_SPEC },			\
@@ -879,6 +904,7 @@
   { "lib_netbsd",		LIB_NETBSD_SPEC },			\
   { "lib_openbsd",		LIB_OPENBSD_SPEC },			\
   { "lib_default",		LIB_DEFAULT_SPEC },			\
+  { "startfile_ogc",		STARTFILE_OGC_SPEC },			\
   { "startfile_ads",		STARTFILE_ADS_SPEC },			\
   { "startfile_yellowknife",	STARTFILE_YELLOWKNIFE_SPEC },		\
   { "startfile_mvme",		STARTFILE_MVME_SPEC },			\
@@ -888,6 +914,7 @@
   { "startfile_netbsd",		STARTFILE_NETBSD_SPEC },		\
   { "startfile_openbsd",	STARTFILE_OPENBSD_SPEC },		\
   { "startfile_default",	STARTFILE_DEFAULT_SPEC },		\
+  { "endfile_ogc",		ENDFILE_OGC_SPEC },			\
   { "endfile_ads",		ENDFILE_ADS_SPEC },			\
   { "endfile_yellowknife",	ENDFILE_YELLOWKNIFE_SPEC },		\
   { "endfile_mvme",		ENDFILE_MVME_SPEC },			\
@@ -900,7 +927,11 @@
   { "link_shlib",		LINK_SHLIB_SPEC },			\
   { "link_target",		LINK_TARGET_SPEC },			\
   { "link_start",		LINK_START_SPEC },			\
+  { "link_start_vgc",		LINK_START_VGC_SPEC },			\
+  { "link_start_gcb",		LINK_START_GCB_SPEC },			\
+  { "link_start_rvl",		LINK_START_RVL_SPEC },			\
   { "link_start_ads",		LINK_START_ADS_SPEC },			\
+  { "link_start_ogc",		LINK_START_OGC_SPEC },			\
   { "link_start_yellowknife",	LINK_START_YELLOWKNIFE_SPEC },		\
   { "link_start_mvme",		LINK_START_MVME_SPEC },			\
   { "link_start_sim",		LINK_START_SIM_SPEC },			\
@@ -910,6 +941,7 @@
   { "link_start_openbsd",	LINK_START_OPENBSD_SPEC },		\
   { "link_start_default",	LINK_START_DEFAULT_SPEC },		\
   { "link_os",			LINK_OS_SPEC },				\
+  { "link_os_ogc",		LINK_OS_OGC_SPEC },			\
   { "link_os_ads",		LINK_OS_ADS_SPEC },			\
   { "link_os_yellowknife",	LINK_OS_YELLOWKNIFE_SPEC },		\
   { "link_os_mvme",		LINK_OS_MVME_SPEC },			\
@@ -923,6 +955,9 @@
   { "cc1_endian_little",	CC1_ENDIAN_LITTLE_SPEC },		\
   { "cc1_endian_default",	CC1_ENDIAN_DEFAULT_SPEC },		\
   { "cc1_secure_plt_default",	CC1_SECURE_PLT_DEFAULT_SPEC },		\
+  { "cpp_os_gcn",		CPP_OS_GCN_SPEC },			\
+  { "cpp_os_ogc",		CPP_OS_OGC_SPEC },			\
+  { "cpp_os_rvl",		CPP_OS_RVL_SPEC },			\
   { "cpp_os_ads",		CPP_OS_ADS_SPEC },			\
   { "cpp_os_yellowknife",	CPP_OS_YELLOWKNIFE_SPEC },		\
   { "cpp_os_mvme",		CPP_OS_MVME_SPEC },			\
diff -Nbaur gcc-4.8.1/gcc/config/rs6000/sysv4.opt gcc-4.8.1-ppc/gcc/config/rs6000/sysv4.opt
--- gcc-4.8.1/gcc/config/rs6000/sysv4.opt	2013-01-10 20:38:27.000000000 +0000
+++ gcc-4.8.1-ppc/gcc/config/rs6000/sysv4.opt	2013-09-07 08:56:31.000000000 +0100
@@ -120,6 +120,26 @@
 Target RejectNegative
 Link with libads.a, libc.a and crt0.o
 
+mgcn
+Target RejectNegative
+Link with libsysbase.a and libc.a, use ogc linker script 
+
+mogc
+Target RejectNegative
+Link with libsysbase.a and libc.a, use ogc linker script 
+
+mgcbios
+Target RejectNegative
+Link with libsysbase.a and libc.a, use gcbogc linker script 
+
+mvgc
+Target RejectNegative
+Link with libsysbase.a and libc.a, use gcbogc linker script 
+
+mrvl
+Target RejectNegative
+Link with libsysbase.a and libc.a, use rvl linker script 
+
 myellowknife
 Target RejectNegative
 Link with libyk.a, libc.a and crt0.o
diff -Nbaur gcc-4.8.1/gcc/config.gcc gcc-4.8.1-ppc/gcc/config.gcc
--- gcc-4.8.1/gcc/config.gcc	2013-03-13 09:47:41.000000000 +0000
+++ gcc-4.8.1-ppc/gcc/config.gcc	2013-09-07 08:56:31.000000000 +0100
@@ -2056,7 +2056,7 @@
 	use_gcc_stdint=wrap
 	;;
 powerpc-*-eabi*)
-	tm_file="${tm_file} dbxelf.h elfos.h usegas.h freebsd-spec.h newlib-stdint.h rs6000/sysv4.h rs6000/eabi.h rs6000/e500.h"
+	tm_file="${tm_file} dbxelf.h elfos.h usegas.h freebsd-spec.h newlib-stdint.h rs6000/sysv4.h rs6000/eabi.h rs6000/e500.h rs6000/750cl.h"
 	extra_options="${extra_options} rs6000/sysv4.opt"
 	tmake_file="rs6000/t-fprules rs6000/t-ppcgas rs6000/t-ppccomm"
 	use_gcc_stdint=wrap
diff -Nbaur gcc-4.8.1/libcpp/Makefile.in gcc-4.8.1-ppc/libcpp/Makefile.in
--- gcc-4.8.1/libcpp/Makefile.in	2013-05-31 10:09:26.000000000 +0100
+++ gcc-4.8.1-ppc/libcpp/Makefile.in	2013-09-07 08:56:31.000000000 +0100
@@ -207,8 +207,7 @@
 # Note that we put the dependencies into a .Tpo file, then move them
 # into place if the compile succeeds.  We need this because gcc does
 # not atomically write the dependency output file.
-COMPILE = $(COMPILE.base) -o $@ -MT $@ -MMD -MP -MF $(DEPDIR)/$*.Tpo
-POSTCOMPILE = @mv $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+COMPILE = $(COMPILE.base) -o $@
 else
 COMPILE = source='$<' object='$@' libtool=no DEPDIR=$(DEPDIR) $(DEPMODE) \
 	  $(depcomp) $(COMPILE.base)
diff -Nbaur gcc-4.8.1/libgcc/config/rs6000/crtrestvr.S gcc-4.8.1-ppc/libgcc/config/rs6000/crtrestvr.S
--- gcc-4.8.1/libgcc/config/rs6000/crtrestvr.S	2013-02-04 19:06:20.000000000 +0000
+++ gcc-4.8.1-ppc/libgcc/config/rs6000/crtrestvr.S	2013-09-07 08:56:31.000000000 +0100
@@ -24,7 +24,7 @@
 
 /* On PowerPC64 Linux, these functions are provided by the linker.  */
 #ifndef __powerpc64__
-
+#if 0
 #undef __ALTIVEC__
 #define __ALTIVEC__ 1
 	#include "ppc-asm.h"
@@ -85,3 +85,4 @@
 CFI_ENDPROC
 
 #endif
+#endif
diff -Nbaur gcc-4.8.1/libgcc/config/rs6000/crtsavevr.S gcc-4.8.1-ppc/libgcc/config/rs6000/crtsavevr.S
--- gcc-4.8.1/libgcc/config/rs6000/crtsavevr.S	2013-02-04 19:06:20.000000000 +0000
+++ gcc-4.8.1-ppc/libgcc/config/rs6000/crtsavevr.S	2013-09-07 08:56:31.000000000 +0100
@@ -24,6 +24,7 @@
 
 /* On PowerPC64 Linux, these functions are provided by the linker.  */
 #ifndef __powerpc64__
+#if 0
 
 #undef __ALTIVEC__
 #define __ALTIVEC__ 1
@@ -85,3 +86,4 @@
 CFI_ENDPROC
 
 #endif
+#endif
diff -Nbaur gcc-4.8.1/libgcc/crtstuff.c gcc-4.8.1-ppc/libgcc/crtstuff.c
--- gcc-4.8.1/libgcc/crtstuff.c	2013-02-04 19:06:20.000000000 +0000
+++ gcc-4.8.1-ppc/libgcc/crtstuff.c	2013-09-07 10:24:50.000000000 +0100
@@ -47,7 +47,7 @@
 
 /* Target machine header files require this define. */
 #define IN_LIBGCC2
-
+#define USED_FOR_TARGET
 /* FIXME: Including auto-host is incorrect, but until we have
    identified the set of defines that need to go into auto-target.h,
    this will have to do.  */
diff -Nbaur gcc-4.8.1/zlib/acinclude.m4 gcc-4.8.1-ppc/zlib/acinclude.m4
--- gcc-4.8.1/zlib/acinclude.m4	2005-09-12 18:02:07.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/acinclude.m4	1970-01-01 01:00:00.000000000 +0100
@@ -1,9 +0,0 @@
-sinclude(../config/no-executables.m4)
-sinclude(../libtool.m4)
-dnl The lines below arrange for aclocal not to bring libtool.m4
-dnl AM_PROG_LIBTOOL into aclocal.m4, while still arranging for automake
-dnl to add a definition of LIBTOOL to Makefile.in.
-ifelse(yes,no,[
-AC_DEFUN([AM_PROG_LIBTOOL],)
-AC_SUBST(LIBTOOL)
-])
diff -Nbaur gcc-4.8.1/zlib/aclocal.m4 gcc-4.8.1-ppc/zlib/aclocal.m4
--- gcc-4.8.1/zlib/aclocal.m4	2010-04-02 19:18:06.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/aclocal.m4	1970-01-01 01:00:00.000000000 +0100
@@ -1,979 +0,0 @@
-# generated automatically by aclocal 1.11.1 -*- Autoconf -*-
-
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-m4_ifndef([AC_AUTOCONF_VERSION],
-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
-m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,
-[m4_warning([this file was generated for autoconf 2.64.
-You have another version of autoconf.  It may work, but is not guaranteed to.
-If you have problems, you may need to regenerate the build system entirely.
-To do so, use the procedure documented by the package, typically `autoreconf'.])])
-
-# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# AM_AUTOMAKE_VERSION(VERSION)
-# ----------------------------
-# Automake X.Y traces this macro to ensure aclocal.m4 has been
-# generated from the m4 files accompanying Automake X.Y.
-# (This private macro should not be called outside this file.)
-AC_DEFUN([AM_AUTOMAKE_VERSION],
-[am__api_version='1.11'
-dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
-dnl require some minimum version.  Point them to the right macro.
-m4_if([$1], [1.11.1], [],
-      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
-])
-
-# _AM_AUTOCONF_VERSION(VERSION)
-# -----------------------------
-# aclocal traces this macro to find the Autoconf version.
-# This is a private macro too.  Using m4_define simplifies
-# the logic in aclocal, which can simply ignore this definition.
-m4_define([_AM_AUTOCONF_VERSION], [])
-
-# AM_SET_CURRENT_AUTOMAKE_VERSION
-# -------------------------------
-# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
-# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
-AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-[AM_AUTOMAKE_VERSION([1.11.1])dnl
-m4_ifndef([AC_AUTOCONF_VERSION],
-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
-_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
-
-# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
-
-# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
-# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
-# `$srcdir', `$srcdir/..', or `$srcdir/../..'.
-#
-# Of course, Automake must honor this variable whenever it calls a
-# tool from the auxiliary directory.  The problem is that $srcdir (and
-# therefore $ac_aux_dir as well) can be either absolute or relative,
-# depending on how configure is run.  This is pretty annoying, since
-# it makes $ac_aux_dir quite unusable in subdirectories: in the top
-# source directory, any form will work fine, but in subdirectories a
-# relative path needs to be adjusted first.
-#
-# $ac_aux_dir/missing
-#    fails when called from a subdirectory if $ac_aux_dir is relative
-# $top_srcdir/$ac_aux_dir/missing
-#    fails if $ac_aux_dir is absolute,
-#    fails when called from a subdirectory in a VPATH build with
-#          a relative $ac_aux_dir
-#
-# The reason of the latter failure is that $top_srcdir and $ac_aux_dir
-# are both prefixed by $srcdir.  In an in-source build this is usually
-# harmless because $srcdir is `.', but things will broke when you
-# start a VPATH build or use an absolute $srcdir.
-#
-# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
-# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:
-#   am_aux_dir='\$(top_srcdir)/'`expr "$ac_aux_dir" : "$srcdir//*\(.*\)"`
-# and then we would define $MISSING as
-#   MISSING="\${SHELL} $am_aux_dir/missing"
-# This will work as long as MISSING is not called from configure, because
-# unfortunately $(top_srcdir) has no meaning in configure.
-# However there are other variables, like CC, which are often used in
-# configure, and could therefore not use this "fixed" $ac_aux_dir.
-#
-# Another solution, used here, is to always expand $ac_aux_dir to an
-# absolute PATH.  The drawback is that using absolute paths prevent a
-# configured tree to be moved without reconfiguration.
-
-AC_DEFUN([AM_AUX_DIR_EXPAND],
-[dnl Rely on autoconf to set up CDPATH properly.
-AC_PREREQ([2.50])dnl
-# expand $ac_aux_dir to an absolute path
-am_aux_dir=`cd $ac_aux_dir && pwd`
-])
-
-# AM_CONDITIONAL                                            -*- Autoconf -*-
-
-# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008
-# Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 9
-
-# AM_CONDITIONAL(NAME, SHELL-CONDITION)
-# -------------------------------------
-# Define a conditional.
-AC_DEFUN([AM_CONDITIONAL],
-[AC_PREREQ(2.52)dnl
- ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
-	[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
-AC_SUBST([$1_TRUE])dnl
-AC_SUBST([$1_FALSE])dnl
-_AM_SUBST_NOTMAKE([$1_TRUE])dnl
-_AM_SUBST_NOTMAKE([$1_FALSE])dnl
-m4_define([_AM_COND_VALUE_$1], [$2])dnl
-if $2; then
-  $1_TRUE=
-  $1_FALSE='#'
-else
-  $1_TRUE='#'
-  $1_FALSE=
-fi
-AC_CONFIG_COMMANDS_PRE(
-[if test -z "${$1_TRUE}" && test -z "${$1_FALSE}"; then
-  AC_MSG_ERROR([[conditional "$1" was never defined.
-Usually this means the macro was only invoked conditionally.]])
-fi])])
-
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009
-# Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 10
-
-# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
-# written in clear, in which case automake, when reading aclocal.m4,
-# will think it sees a *use*, and therefore will trigger all it's
-# C support machinery.  Also note that it means that autoscan, seeing
-# CC etc. in the Makefile, will ask for an AC_PROG_CC use...
-
-
-# _AM_DEPENDENCIES(NAME)
-# ----------------------
-# See how the compiler implements dependency checking.
-# NAME is "CC", "CXX", "GCJ", or "OBJC".
-# We try a few techniques and use that to set a single cache variable.
-#
-# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was
-# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular
-# dependency, and given that the user is not expected to run this macro,
-# just rely on AC_PROG_CC.
-AC_DEFUN([_AM_DEPENDENCIES],
-[AC_REQUIRE([AM_SET_DEPDIR])dnl
-AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl
-AC_REQUIRE([AM_MAKE_INCLUDE])dnl
-AC_REQUIRE([AM_DEP_TRACK])dnl
-
-ifelse([$1], CC,   [depcc="$CC"   am_compiler_list=],
-       [$1], CXX,  [depcc="$CXX"  am_compiler_list=],
-       [$1], OBJC, [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
-       [$1], UPC,  [depcc="$UPC"  am_compiler_list=],
-       [$1], GCJ,  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
-                   [depcc="$$1"   am_compiler_list=])
-
-AC_CACHE_CHECK([dependency style of $depcc],
-               [am_cv_$1_dependencies_compiler_type],
-[if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
-  # We make a subdir and do the tests there.  Otherwise we can end up
-  # making bogus files that we don't know about and never remove.  For
-  # instance it was reported that on HP-UX the gcc test will end up
-  # making a dummy file named `D' -- because `-MD' means `put the output
-  # in D'.
-  mkdir conftest.dir
-  # Copy depcomp to subdir because otherwise we won't find it if we're
-  # using a relative directory.
-  cp "$am_depcomp" conftest.dir
-  cd conftest.dir
-  # We will build objects and dependencies in a subdirectory because
-  # it helps to detect inapplicable dependency modes.  For instance
-  # both Tru64's cc and ICC support -MD to output dependencies as a
-  # side effect of compilation, but ICC will put the dependencies in
-  # the current directory while Tru64 will put them in the object
-  # directory.
-  mkdir sub
-
-  am_cv_$1_dependencies_compiler_type=none
-  if test "$am_compiler_list" = ""; then
-     am_compiler_list=`sed -n ['s/^#*\([a-zA-Z0-9]*\))$/\1/p'] < ./depcomp`
-  fi
-  am__universal=false
-  m4_case([$1], [CC],
-    [case " $depcc " in #(
-     *\ -arch\ *\ -arch\ *) am__universal=true ;;
-     esac],
-    [CXX],
-    [case " $depcc " in #(
-     *\ -arch\ *\ -arch\ *) am__universal=true ;;
-     esac])
-
-  for depmode in $am_compiler_list; do
-    # Setup a source with many dependencies, because some compilers
-    # like to wrap large dependency lists on column 80 (with \), and
-    # we should not choose a depcomp mode which is confused by this.
-    #
-    # We need to recreate these files for each test, as the compiler may
-    # overwrite some of them when testing with obscure command lines.
-    # This happens at least with the AIX C compiler.
-    : > sub/conftest.c
-    for i in 1 2 3 4 5 6; do
-      echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
-      # Solaris 8's {/usr,}/bin/sh.
-      touch sub/conftst$i.h
-    done
-    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
-
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
-    # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
-    am__obj=sub/conftest.${OBJEXT-o}
-    am__minus_obj="-o $am__obj"
-    case $depmode in
-    gcc)
-      # This depmode causes a compiler race in universal mode.
-      test "$am__universal" = false || continue
-      ;;
-    nosideeffect)
-      # after this tag, mechanisms are not by side-effect, so they'll
-      # only be used when explicitly requested
-      if test "x$enable_dependency_tracking" = xyes; then
-	continue
-      else
-	break
-      fi
-      ;;
-    msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
-      # not run yet.  These depmodes are late enough in the game, and
-      # so weak that their functioning should not be impacted.
-      am__obj=conftest.${OBJEXT-o}
-      am__minus_obj=
-      ;;
-    none) break ;;
-    esac
-    if depmode=$depmode \
-       source=sub/conftest.c object=$am__obj \
-       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
-       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
-         >/dev/null 2>conftest.err &&
-       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
-       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
-       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
-       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
-      # icc doesn't choke on unknown options, it will just issue warnings
-      # or remarks (even with -Werror).  So we grep stderr for any message
-      # that says an option was ignored or not supported.
-      # When given -MP, icc 7.0 and 7.1 complain thusly:
-      #   icc: Command line warning: ignoring option '-M'; no argument required
-      # The diagnosis changed in icc 8.0:
-      #   icc: Command line remark: option '-MP' not supported
-      if (grep 'ignoring option' conftest.err ||
-          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
-        am_cv_$1_dependencies_compiler_type=$depmode
-        break
-      fi
-    fi
-  done
-
-  cd ..
-  rm -rf conftest.dir
-else
-  am_cv_$1_dependencies_compiler_type=none
-fi
-])
-AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])
-AM_CONDITIONAL([am__fastdep$1], [
-  test "x$enable_dependency_tracking" != xno \
-  && test "$am_cv_$1_dependencies_compiler_type" = gcc3])
-])
-
-
-# AM_SET_DEPDIR
-# -------------
-# Choose a directory name for dependency files.
-# This macro is AC_REQUIREd in _AM_DEPENDENCIES
-AC_DEFUN([AM_SET_DEPDIR],
-[AC_REQUIRE([AM_SET_LEADING_DOT])dnl
-AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
-])
-
-
-# AM_DEP_TRACK
-# ------------
-AC_DEFUN([AM_DEP_TRACK],
-[AC_ARG_ENABLE(dependency-tracking,
-[  --disable-dependency-tracking  speeds up one-time build
-  --enable-dependency-tracking   do not reject slow dependency extractors])
-if test "x$enable_dependency_tracking" != xno; then
-  am_depcomp="$ac_aux_dir/depcomp"
-  AMDEPBACKSLASH='\'
-fi
-AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
-AC_SUBST([AMDEPBACKSLASH])dnl
-_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl
-])
-
-# Generate code to set up dependency tracking.              -*- Autoconf -*-
-
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008
-# Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-#serial 5
-
-# _AM_OUTPUT_DEPENDENCY_COMMANDS
-# ------------------------------
-AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
-[{
-  # Autoconf 2.62 quotes --file arguments for eval, but not when files
-  # are listed without --file.  Let's play safe and only enable the eval
-  # if we detect the quoting.
-  case $CONFIG_FILES in
-  *\'*) eval set x "$CONFIG_FILES" ;;
-  *)   set x $CONFIG_FILES ;;
-  esac
-  shift
-  for mf
-  do
-    # Strip MF so we end up with the name of the file.
-    mf=`echo "$mf" | sed -e 's/:.*$//'`
-    # Check whether this is an Automake generated Makefile or not.
-    # We used to match only the files named `Makefile.in', but
-    # some people rename them; so instead we look at the file content.
-    # Grep'ing the first line is not enough: some people post-process
-    # each Makefile.in and add a new line on top of each file to say so.
-    # Grep'ing the whole file is not good either: AIX grep has a line
-    # limit of 2048, but all sed's we know have understand at least 4000.
-    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
-      dirpart=`AS_DIRNAME("$mf")`
-    else
-      continue
-    fi
-    # Extract the definition of DEPDIR, am__include, and am__quote
-    # from the Makefile without running `make'.
-    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
-    test -z "$DEPDIR" && continue
-    am__include=`sed -n 's/^am__include = //p' < "$mf"`
-    test -z "am__include" && continue
-    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
-    # When using ansi2knr, U may be empty or an underscore; expand it
-    U=`sed -n 's/^U = //p' < "$mf"`
-    # Find all dependency output files, they are included files with
-    # $(DEPDIR) in their names.  We invoke sed twice because it is the
-    # simplest approach to changing $(DEPDIR) to its actual value in the
-    # expansion.
-    for file in `sed -n "
-      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
-	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
-      # Make sure the directory exists.
-      test -f "$dirpart/$file" && continue
-      fdir=`AS_DIRNAME(["$file"])`
-      AS_MKDIR_P([$dirpart/$fdir])
-      # echo "creating $dirpart/$file"
-      echo '# dummy' > "$dirpart/$file"
-    done
-  done
-}
-])# _AM_OUTPUT_DEPENDENCY_COMMANDS
-
-
-# AM_OUTPUT_DEPENDENCY_COMMANDS
-# -----------------------------
-# This macro should only be invoked once -- use via AC_REQUIRE.
-#
-# This code is only required when automatic dependency tracking
-# is enabled.  FIXME.  This creates each `.P' file that we will
-# need in order to bootstrap the dependency handling code.
-AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
-[AC_CONFIG_COMMANDS([depfiles],
-     [test x"$AMDEP_TRUE" != x"" || _AM_OUTPUT_DEPENDENCY_COMMANDS],
-     [AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"])
-])
-
-# Do all the work for Automake.                             -*- Autoconf -*-
-
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 16
-
-# This macro actually does too much.  Some checks are only needed if
-# your package does certain things.  But this isn't really a big deal.
-
-# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])
-# AM_INIT_AUTOMAKE([OPTIONS])
-# -----------------------------------------------
-# The call with PACKAGE and VERSION arguments is the old style
-# call (pre autoconf-2.50), which is being phased out.  PACKAGE
-# and VERSION should now be passed to AC_INIT and removed from
-# the call to AM_INIT_AUTOMAKE.
-# We support both call styles for the transition.  After
-# the next Automake release, Autoconf can make the AC_INIT
-# arguments mandatory, and then we can depend on a new Autoconf
-# release and drop the old call support.
-AC_DEFUN([AM_INIT_AUTOMAKE],
-[AC_PREREQ([2.62])dnl
-dnl Autoconf wants to disallow AM_ names.  We explicitly allow
-dnl the ones we care about.
-m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl
-AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl
-AC_REQUIRE([AC_PROG_INSTALL])dnl
-if test "`cd $srcdir && pwd`" != "`pwd`"; then
-  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
-  # is not polluted with repeated "-I."
-  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl
-  # test to see if srcdir already configured
-  if test -f $srcdir/config.status; then
-    AC_MSG_ERROR([source directory already configured; run "make distclean" there first])
-  fi
-fi
-
-# test whether we have cygpath
-if test -z "$CYGPATH_W"; then
-  if (cygpath --version) >/dev/null 2>/dev/null; then
-    CYGPATH_W='cygpath -w'
-  else
-    CYGPATH_W=echo
-  fi
-fi
-AC_SUBST([CYGPATH_W])
-
-# Define the identity of the package.
-dnl Distinguish between old-style and new-style calls.
-m4_ifval([$2],
-[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
- AC_SUBST([PACKAGE], [$1])dnl
- AC_SUBST([VERSION], [$2])],
-[_AM_SET_OPTIONS([$1])dnl
-dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.
-m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,
-  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl
- AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
- AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl
-
-_AM_IF_OPTION([no-define],,
-[AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE", [Name of package])
- AC_DEFINE_UNQUOTED(VERSION, "$VERSION", [Version number of package])])dnl
-
-# Some tools Automake needs.
-AC_REQUIRE([AM_SANITY_CHECK])dnl
-AC_REQUIRE([AC_ARG_PROGRAM])dnl
-AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})
-AM_MISSING_PROG(AUTOCONF, autoconf)
-AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})
-AM_MISSING_PROG(AUTOHEADER, autoheader)
-AM_MISSING_PROG(MAKEINFO, makeinfo)
-AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
-AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl
-AC_REQUIRE([AM_PROG_MKDIR_P])dnl
-# We need awk for the "check" target.  The system "awk" is bad on
-# some platforms.
-AC_REQUIRE([AC_PROG_AWK])dnl
-AC_REQUIRE([AC_PROG_MAKE_SET])dnl
-AC_REQUIRE([AM_SET_LEADING_DOT])dnl
-_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],
-	      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],
-			     [_AM_PROG_TAR([v7])])])
-_AM_IF_OPTION([no-dependencies],,
-[AC_PROVIDE_IFELSE([AC_PROG_CC],
-		  [_AM_DEPENDENCIES(CC)],
-		  [define([AC_PROG_CC],
-			  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl
-AC_PROVIDE_IFELSE([AC_PROG_CXX],
-		  [_AM_DEPENDENCIES(CXX)],
-		  [define([AC_PROG_CXX],
-			  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl
-AC_PROVIDE_IFELSE([AC_PROG_OBJC],
-		  [_AM_DEPENDENCIES(OBJC)],
-		  [define([AC_PROG_OBJC],
-			  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl
-])
-_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl
-dnl The `parallel-tests' driver may need to know about EXEEXT, so add the
-dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro
-dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.
-AC_CONFIG_COMMANDS_PRE(dnl
-[m4_provide_if([_AM_COMPILER_EXEEXT],
-  [AM_CONDITIONAL([am__EXEEXT], [test -n "$EXEEXT"])])])dnl
-])
-
-dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
-dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further
-dnl mangled by Autoconf and run in a shell conditional statement.
-m4_define([_AC_COMPILER_EXEEXT],
-m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])
-
-
-# When config.status generates a header, we must update the stamp-h file.
-# This file resides in the same directory as the config header
-# that is generated.  The stamp files are numbered to have different names.
-
-# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the
-# loop where config.status creates the headers, so we can generate
-# our stamp files there.
-AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],
-[# Compute $1's index in $config_headers.
-_am_arg=$1
-_am_stamp_count=1
-for _am_header in $config_headers :; do
-  case $_am_header in
-    $_am_arg | $_am_arg:* )
-      break ;;
-    * )
-      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
-  esac
-done
-echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
-
-# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# AM_PROG_INSTALL_SH
-# ------------------
-# Define $install_sh.
-AC_DEFUN([AM_PROG_INSTALL_SH],
-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
-if test x"${install_sh}" != xset; then
-  case $am_aux_dir in
-  *\ * | *\	*)
-    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
-  *)
-    install_sh="\${SHELL} $am_aux_dir/install-sh"
-  esac
-fi
-AC_SUBST(install_sh)])
-
-# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-
-# From Jim Meyering
-
-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008
-# Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 5
-
-# AM_MAINTAINER_MODE([DEFAULT-MODE])
-# ----------------------------------
-# Control maintainer-specific portions of Makefiles.
-# Default is to disable them, unless `enable' is passed literally.
-# For symmetry, `disable' may be passed as well.  Anyway, the user
-# can override the default with the --enable/--disable switch.
-AC_DEFUN([AM_MAINTAINER_MODE],
-[m4_case(m4_default([$1], [disable]),
-       [enable], [m4_define([am_maintainer_other], [disable])],
-       [disable], [m4_define([am_maintainer_other], [enable])],
-       [m4_define([am_maintainer_other], [enable])
-        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])
-AC_MSG_CHECKING([whether to am_maintainer_other maintainer-specific portions of Makefiles])
-  dnl maintainer-mode's default is 'disable' unless 'enable' is passed
-  AC_ARG_ENABLE([maintainer-mode],
-[  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful
-			  (and sometimes confusing) to the casual installer],
-      [USE_MAINTAINER_MODE=$enableval],
-      [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))
-  AC_MSG_RESULT([$USE_MAINTAINER_MODE])
-  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])
-  MAINT=$MAINTAINER_MODE_TRUE
-  AC_SUBST([MAINT])dnl
-]
-)
-
-AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])
-
-# Check to see how 'make' treats includes.	            -*- Autoconf -*-
-
-# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 4
-
-# AM_MAKE_INCLUDE()
-# -----------------
-# Check to see how make treats includes.
-AC_DEFUN([AM_MAKE_INCLUDE],
-[am_make=${MAKE-make}
-cat > confinc << 'END'
-am__doit:
-	@echo this is the am__doit target
-.PHONY: am__doit
-END
-# If we don't find an include directive, just comment out the code.
-AC_MSG_CHECKING([for style of include used by $am_make])
-am__include="#"
-am__quote=
-_am_result=none
-# First try GNU make style include.
-echo "include confinc" > confmf
-# Ignore all kinds of additional output from `make'.
-case `$am_make -s -f confmf 2> /dev/null` in #(
-*the\ am__doit\ target*)
-  am__include=include
-  am__quote=
-  _am_result=GNU
-  ;;
-esac
-# Now try BSD make style include.
-if test "$am__include" = "#"; then
-   echo '.include "confinc"' > confmf
-   case `$am_make -s -f confmf 2> /dev/null` in #(
-   *the\ am__doit\ target*)
-     am__include=.include
-     am__quote="\""
-     _am_result=BSD
-     ;;
-   esac
-fi
-AC_SUBST([am__include])
-AC_SUBST([am__quote])
-AC_MSG_RESULT([$_am_result])
-rm -f confinc confmf
-])
-
-# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
-
-# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008
-# Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 6
-
-# AM_MISSING_PROG(NAME, PROGRAM)
-# ------------------------------
-AC_DEFUN([AM_MISSING_PROG],
-[AC_REQUIRE([AM_MISSING_HAS_RUN])
-$1=${$1-"${am_missing_run}$2"}
-AC_SUBST($1)])
-
-
-# AM_MISSING_HAS_RUN
-# ------------------
-# Define MISSING if not defined so far and test if it supports --run.
-# If it does, set am_missing_run to use it, otherwise, to nothing.
-AC_DEFUN([AM_MISSING_HAS_RUN],
-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
-AC_REQUIRE_AUX_FILE([missing])dnl
-if test x"${MISSING+set}" != xset; then
-  case $am_aux_dir in
-  *\ * | *\	*)
-    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
-  *)
-    MISSING="\${SHELL} $am_aux_dir/missing" ;;
-  esac
-fi
-# Use eval to expand $SHELL
-if eval "$MISSING --run true"; then
-  am_missing_run="$MISSING --run "
-else
-  am_missing_run=
-  AC_MSG_WARN([`missing' script is too old or missing])
-fi
-])
-
-# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# AM_PROG_MKDIR_P
-# ---------------
-# Check for `mkdir -p'.
-AC_DEFUN([AM_PROG_MKDIR_P],
-[AC_PREREQ([2.60])dnl
-AC_REQUIRE([AC_PROG_MKDIR_P])dnl
-dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,
-dnl while keeping a definition of mkdir_p for backward compatibility.
-dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.
-dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of
-dnl Makefile.ins that do not define MKDIR_P, so we do our own
-dnl adjustment using top_builddir (which is defined more often than
-dnl MKDIR_P).
-AC_SUBST([mkdir_p], ["$MKDIR_P"])dnl
-case $mkdir_p in
-  [[\\/$]]* | ?:[[\\/]]*) ;;
-  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
-esac
-])
-
-# Helper functions for option handling.                     -*- Autoconf -*-
-
-# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 4
-
-# _AM_MANGLE_OPTION(NAME)
-# -----------------------
-AC_DEFUN([_AM_MANGLE_OPTION],
-[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])
-
-# _AM_SET_OPTION(NAME)
-# ------------------------------
-# Set option NAME.  Presently that only means defining a flag for this option.
-AC_DEFUN([_AM_SET_OPTION],
-[m4_define(_AM_MANGLE_OPTION([$1]), 1)])
-
-# _AM_SET_OPTIONS(OPTIONS)
-# ----------------------------------
-# OPTIONS is a space-separated list of Automake options.
-AC_DEFUN([_AM_SET_OPTIONS],
-[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])
-
-# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])
-# -------------------------------------------
-# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
-AC_DEFUN([_AM_IF_OPTION],
-[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])
-
-# Check to make sure that the build environment is sane.    -*- Autoconf -*-
-
-# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008
-# Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 5
-
-# AM_SANITY_CHECK
-# ---------------
-AC_DEFUN([AM_SANITY_CHECK],
-[AC_MSG_CHECKING([whether build environment is sane])
-# Just in case
-sleep 1
-echo timestamp > conftest.file
-# Reject unsafe characters in $srcdir or the absolute working directory
-# name.  Accept space and tab only in the latter.
-am_lf='
-'
-case `pwd` in
-  *[[\\\"\#\$\&\'\`$am_lf]]*)
-    AC_MSG_ERROR([unsafe absolute working directory name]);;
-esac
-case $srcdir in
-  *[[\\\"\#\$\&\'\`$am_lf\ \	]]*)
-    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;
-esac
-
-# Do `set' in a subshell so we don't clobber the current shell's
-# arguments.  Must try -L first in case configure is actually a
-# symlink; some systems play weird games with the mod time of symlinks
-# (eg FreeBSD returns the mod time of the symlink's containing
-# directory).
-if (
-   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
-   if test "$[*]" = "X"; then
-      # -L didn't work.
-      set X `ls -t "$srcdir/configure" conftest.file`
-   fi
-   rm -f conftest.file
-   if test "$[*]" != "X $srcdir/configure conftest.file" \
-      && test "$[*]" != "X conftest.file $srcdir/configure"; then
-
-      # If neither matched, then we have a broken ls.  This can happen
-      # if, for instance, CONFIG_SHELL is bash and it inherits a
-      # broken ls alias from the environment.  This has actually
-      # happened.  Such a system could not be considered "sane".
-      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
-alias in your environment])
-   fi
-
-   test "$[2]" = conftest.file
-   )
-then
-   # Ok.
-   :
-else
-   AC_MSG_ERROR([newly created file is older than distributed files!
-Check your system clock])
-fi
-AC_MSG_RESULT(yes)])
-
-# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# AM_PROG_INSTALL_STRIP
-# ---------------------
-# One issue with vendor `install' (even GNU) is that you can't
-# specify the program used to strip binaries.  This is especially
-# annoying in cross-compiling environments, where the build's strip
-# is unlikely to handle the host's binaries.
-# Fortunately install-sh will honor a STRIPPROG variable, so we
-# always use install-sh in `make install-strip', and initialize
-# STRIPPROG with the value of the STRIP variable (set by the user).
-AC_DEFUN([AM_PROG_INSTALL_STRIP],
-[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
-# Installed binaries are usually stripped using `strip' when the user
-# run `make install-strip'.  However `strip' might not be the right
-# tool to use in cross-compilation environments, therefore Automake
-# will honor the `STRIP' environment variable to overrule this program.
-dnl Don't test for $cross_compiling = yes, because it might be `maybe'.
-if test "$cross_compiling" != no; then
-  AC_CHECK_TOOL([STRIP], [strip], :)
-fi
-INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
-AC_SUBST([INSTALL_STRIP_PROGRAM])])
-
-# Copyright (C) 2006, 2008  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 2
-
-# _AM_SUBST_NOTMAKE(VARIABLE)
-# ---------------------------
-# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.
-# This macro is traced by Automake.
-AC_DEFUN([_AM_SUBST_NOTMAKE])
-
-# AM_SUBST_NOTMAKE(VARIABLE)
-# ---------------------------
-# Public sister of _AM_SUBST_NOTMAKE.
-AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])
-
-# Check how to create a tarball.                            -*- Autoconf -*-
-
-# Copyright (C) 2004, 2005  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 2
-
-# _AM_PROG_TAR(FORMAT)
-# --------------------
-# Check how to create a tarball in format FORMAT.
-# FORMAT should be one of `v7', `ustar', or `pax'.
-#
-# Substitute a variable $(am__tar) that is a command
-# writing to stdout a FORMAT-tarball containing the directory
-# $tardir.
-#     tardir=directory && $(am__tar) > result.tar
-#
-# Substitute a variable $(am__untar) that extract such
-# a tarball read from stdin.
-#     $(am__untar) < result.tar
-AC_DEFUN([_AM_PROG_TAR],
-[# Always define AMTAR for backward compatibility.
-AM_MISSING_PROG([AMTAR], [tar])
-m4_if([$1], [v7],
-     [am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'],
-     [m4_case([$1], [ustar],, [pax],,
-              [m4_fatal([Unknown tar format])])
-AC_MSG_CHECKING([how to create a $1 tar archive])
-# Loop over all known methods to create a tar archive until one works.
-_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'
-_am_tools=${am_cv_prog_tar_$1-$_am_tools}
-# Do not fold the above two line into one, because Tru64 sh and
-# Solaris sh will not grok spaces in the rhs of `-'.
-for _am_tool in $_am_tools
-do
-  case $_am_tool in
-  gnutar)
-    for _am_tar in tar gnutar gtar;
-    do
-      AM_RUN_LOG([$_am_tar --version]) && break
-    done
-    am__tar="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$$tardir"'
-    am__tar_="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$tardir"'
-    am__untar="$_am_tar -xf -"
-    ;;
-  plaintar)
-    # Must skip GNU tar: if it does not support --format= it doesn't create
-    # ustar tarball either.
-    (tar --version) >/dev/null 2>&1 && continue
-    am__tar='tar chf - "$$tardir"'
-    am__tar_='tar chf - "$tardir"'
-    am__untar='tar xf -'
-    ;;
-  pax)
-    am__tar='pax -L -x $1 -w "$$tardir"'
-    am__tar_='pax -L -x $1 -w "$tardir"'
-    am__untar='pax -r'
-    ;;
-  cpio)
-    am__tar='find "$$tardir" -print | cpio -o -H $1 -L'
-    am__tar_='find "$tardir" -print | cpio -o -H $1 -L'
-    am__untar='cpio -i -H $1 -d'
-    ;;
-  none)
-    am__tar=false
-    am__tar_=false
-    am__untar=false
-    ;;
-  esac
-
-  # If the value was cached, stop now.  We just wanted to have am__tar
-  # and am__untar set.
-  test -n "${am_cv_prog_tar_$1}" && break
-
-  # tar/untar a dummy directory, and stop if the command works
-  rm -rf conftest.dir
-  mkdir conftest.dir
-  echo GrepMe > conftest.dir/file
-  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
-  rm -rf conftest.dir
-  if test -s conftest.tar; then
-    AM_RUN_LOG([$am__untar <conftest.tar])
-    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
-  fi
-done
-rm -rf conftest.dir
-
-AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
-AC_MSG_RESULT([$am_cv_prog_tar_$1])])
-AC_SUBST([am__tar])
-AC_SUBST([am__untar])
-]) # _AM_PROG_TAR
-
-m4_include([../config/depstand.m4])
-m4_include([../config/lead-dot.m4])
-m4_include([../config/multi.m4])
-m4_include([../config/override.m4])
-m4_include([../ltoptions.m4])
-m4_include([../ltsugar.m4])
-m4_include([../ltversion.m4])
-m4_include([../lt~obsolete.m4])
-m4_include([acinclude.m4])
diff -Nbaur gcc-4.8.1/zlib/adler32.c gcc-4.8.1-ppc/zlib/adler32.c
--- gcc-4.8.1/zlib/adler32.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/adler32.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,179 +0,0 @@
-/* adler32.c -- compute the Adler-32 checksum of a data stream
- * Copyright (C) 1995-2011 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id: adler32.c,v 1.1.1.2 2002/03/11 21:53:23 tromey Exp $ */
-
-#include "zutil.h"
-
-#define local static
-
-local uLong adler32_combine_ OF((uLong adler1, uLong adler2, z_off64_t len2));
-
-#define BASE 65521      /* largest prime smaller than 65536 */
-#define NMAX 5552
-/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
-
-#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}
-#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
-#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
-#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
-#define DO16(buf)   DO8(buf,0); DO8(buf,8);
-
-/* use NO_DIVIDE if your processor does not do division in hardware --
-   try it both ways to see which is faster */
-#ifdef NO_DIVIDE
-/* note that this assumes BASE is 65521, where 65536 % 65521 == 15
-   (thank you to John Reiser for pointing this out) */
-#  define CHOP(a) \
-    do { \
-        unsigned long tmp = a >> 16; \
-        a &= 0xffffUL; \
-        a += (tmp << 4) - tmp; \
-    } while (0)
-#  define MOD28(a) \
-    do { \
-        CHOP(a); \
-        if (a >= BASE) a -= BASE; \
-    } while (0)
-#  define MOD(a) \
-    do { \
-        CHOP(a); \
-        MOD28(a); \
-    } while (0)
-#  define MOD63(a) \
-    do { /* this assumes a is not negative */ \
-        z_off64_t tmp = a >> 32; \
-        a &= 0xffffffffL; \
-        a += (tmp << 8) - (tmp << 5) + tmp; \
-        tmp = a >> 16; \
-        a &= 0xffffL; \
-        a += (tmp << 4) - tmp; \
-        tmp = a >> 16; \
-        a &= 0xffffL; \
-        a += (tmp << 4) - tmp; \
-        if (a >= BASE) a -= BASE; \
-    } while (0)
-#else
-#  define MOD(a) a %= BASE
-#  define MOD28(a) a %= BASE
-#  define MOD63(a) a %= BASE
-#endif
-
-/* ========================================================================= */
-uLong ZEXPORT adler32(adler, buf, len)
-    uLong adler;
-    const Bytef *buf;
-    uInt len;
-{
-    unsigned long sum2;
-    unsigned n;
-
-    /* split Adler-32 into component sums */
-    sum2 = (adler >> 16) & 0xffff;
-    adler &= 0xffff;
-
-    /* in case user likes doing a byte at a time, keep it fast */
-    if (len == 1) {
-        adler += buf[0];
-        if (adler >= BASE)
-            adler -= BASE;
-        sum2 += adler;
-        if (sum2 >= BASE)
-            sum2 -= BASE;
-        return adler | (sum2 << 16);
-    }
-
-    /* initial Adler-32 value (deferred check for len == 1 speed) */
-    if (buf == Z_NULL)
-        return 1L;
-
-    /* in case short lengths are provided, keep it somewhat fast */
-    if (len < 16) {
-        while (len--) {
-            adler += *buf++;
-            sum2 += adler;
-        }
-        if (adler >= BASE)
-            adler -= BASE;
-        MOD28(sum2);            /* only added so many BASE's */
-        return adler | (sum2 << 16);
-    }
-
-    /* do length NMAX blocks -- requires just one modulo operation */
-    while (len >= NMAX) {
-        len -= NMAX;
-        n = NMAX / 16;          /* NMAX is divisible by 16 */
-        do {
-            DO16(buf);          /* 16 sums unrolled */
-            buf += 16;
-        } while (--n);
-        MOD(adler);
-        MOD(sum2);
-    }
-
-    /* do remaining bytes (less than NMAX, still just one modulo) */
-    if (len) {                  /* avoid modulos if none remaining */
-        while (len >= 16) {
-            len -= 16;
-            DO16(buf);
-            buf += 16;
-        }
-        while (len--) {
-            adler += *buf++;
-            sum2 += adler;
-        }
-        MOD(adler);
-        MOD(sum2);
-    }
-
-    /* return recombined sums */
-    return adler | (sum2 << 16);
-}
-
-/* ========================================================================= */
-local uLong adler32_combine_(adler1, adler2, len2)
-    uLong adler1;
-    uLong adler2;
-    z_off64_t len2;
-{
-    unsigned long sum1;
-    unsigned long sum2;
-    unsigned rem;
-
-    /* for negative len, return invalid adler32 as a clue for debugging */
-    if (len2 < 0)
-        return 0xffffffffUL;
-
-    /* the derivation of this formula is left as an exercise for the reader */
-    MOD63(len2);                /* assumes len2 >= 0 */
-    rem = (unsigned)len2;
-    sum1 = adler1 & 0xffff;
-    sum2 = rem * sum1;
-    MOD(sum2);
-    sum1 += (adler2 & 0xffff) + BASE - 1;
-    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;
-    if (sum1 >= BASE) sum1 -= BASE;
-    if (sum1 >= BASE) sum1 -= BASE;
-    if (sum2 >= (BASE << 1)) sum2 -= (BASE << 1);
-    if (sum2 >= BASE) sum2 -= BASE;
-    return sum1 | (sum2 << 16);
-}
-
-/* ========================================================================= */
-uLong ZEXPORT adler32_combine(adler1, adler2, len2)
-    uLong adler1;
-    uLong adler2;
-    z_off_t len2;
-{
-    return adler32_combine_(adler1, adler2, len2);
-}
-
-uLong ZEXPORT adler32_combine64(adler1, adler2, len2)
-    uLong adler1;
-    uLong adler2;
-    z_off64_t len2;
-{
-    return adler32_combine_(adler1, adler2, len2);
-}
diff -Nbaur gcc-4.8.1/zlib/amiga/Makefile.pup gcc-4.8.1-ppc/zlib/amiga/Makefile.pup
--- gcc-4.8.1/zlib/amiga/Makefile.pup	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/amiga/Makefile.pup	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-# Amiga powerUP (TM) Makefile
-# makefile for libpng and SAS C V6.58/7.00 PPC compiler
-# Copyright (C) 1998 by Andreas R. Kleinert
-
-LIBNAME	= libzip.a
-
-CC	= scppc
-CFLAGS	= NOSTKCHK NOSINT OPTIMIZE OPTGO OPTPEEP OPTINLOCAL OPTINL \
-	  OPTLOOP OPTRDEP=8 OPTDEP=8 OPTCOMP=8 NOVER
-AR	= ppc-amigaos-ar cr
-RANLIB	= ppc-amigaos-ranlib
-LD	= ppc-amigaos-ld -r
-LDFLAGS	= -o
-LDLIBS	= LIB:scppc.a LIB:end.o
-RM	= delete quiet
-
-OBJS = adler32.o compress.o crc32.o gzclose.o gzlib.o gzread.o gzwrite.o \
-       uncompr.o deflate.o trees.o zutil.o inflate.o infback.o inftrees.o inffast.o
-
-TEST_OBJS = example.o minigzip.o
-
-all: example minigzip
-
-check: test
-test: all
-	example
-	echo hello world | minigzip | minigzip -d
-
-$(LIBNAME): $(OBJS)
-	$(AR) $@ $(OBJS)
-	-$(RANLIB) $@
-
-example: example.o $(LIBNAME)
-	$(LD) $(LDFLAGS) $@ LIB:c_ppc.o $@.o $(LIBNAME) $(LDLIBS)
-
-minigzip: minigzip.o $(LIBNAME)
-	$(LD) $(LDFLAGS) $@ LIB:c_ppc.o $@.o $(LIBNAME) $(LDLIBS)
-
-mostlyclean: clean
-clean:
-	$(RM) *.o example minigzip $(LIBNAME) foo.gz
-
-zip:
-	zip -ul9 zlib README ChangeLog Makefile Make????.??? Makefile.?? \
-	  descrip.mms *.[ch]
-
-tgz:
-	cd ..; tar cfz zlib/zlib.tgz zlib/README zlib/ChangeLog zlib/Makefile \
-	  zlib/Make????.??? zlib/Makefile.?? zlib/descrip.mms zlib/*.[ch]
-
-# DO NOT DELETE THIS LINE -- make depend depends on it.
-
-adler32.o: zlib.h zconf.h
-compress.o: zlib.h zconf.h
-crc32.o: crc32.h zlib.h zconf.h
-deflate.o: deflate.h zutil.h zlib.h zconf.h
-example.o: zlib.h zconf.h
-gzclose.o: zlib.h zconf.h gzguts.h
-gzlib.o: zlib.h zconf.h gzguts.h
-gzread.o: zlib.h zconf.h gzguts.h
-gzwrite.o: zlib.h zconf.h gzguts.h
-inffast.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-inflate.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-infback.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-inftrees.o: zutil.h zlib.h zconf.h inftrees.h
-minigzip.o: zlib.h zconf.h
-trees.o: deflate.h zutil.h zlib.h zconf.h trees.h
-uncompr.o: zlib.h zconf.h
-zutil.o: zutil.h zlib.h zconf.h
diff -Nbaur gcc-4.8.1/zlib/amiga/Makefile.sas gcc-4.8.1-ppc/zlib/amiga/Makefile.sas
--- gcc-4.8.1/zlib/amiga/Makefile.sas	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/amiga/Makefile.sas	1970-01-01 01:00:00.000000000 +0100
@@ -1,68 +0,0 @@
-# SMakefile for zlib
-# Modified from the standard UNIX Makefile Copyright Jean-loup Gailly
-# Osma Ahvenlampi <Osma.Ahvenlampi@hut.fi>
-# Amiga, SAS/C 6.56 & Smake
-
-CC=sc
-CFLAGS=OPT
-#CFLAGS=OPT CPU=68030
-#CFLAGS=DEBUG=LINE
-LDFLAGS=LIB z.lib
-
-SCOPTIONS=OPTSCHED OPTINLINE OPTALIAS OPTTIME OPTINLOCAL STRMERGE \
-       NOICONS PARMS=BOTH NOSTACKCHECK UTILLIB NOVERSION ERRORREXX \
-       DEF=POSTINC
-
-OBJS = adler32.o compress.o crc32.o gzclose.o gzlib.o gzread.o gzwrite.o \
-       uncompr.o deflate.o trees.o zutil.o inflate.o infback.o inftrees.o inffast.o
-
-TEST_OBJS = example.o minigzip.o
-
-all: SCOPTIONS example minigzip
-
-check: test
-test: all
-	example
-	echo hello world | minigzip | minigzip -d
-
-install: z.lib
-	copy clone zlib.h zconf.h INCLUDE:
-	copy clone z.lib LIB:
-
-z.lib: $(OBJS)
-	oml z.lib r $(OBJS)
-
-example: example.o z.lib
-	$(CC) $(CFLAGS) LINK TO $@ example.o $(LDFLAGS)
-
-minigzip: minigzip.o z.lib
-	$(CC) $(CFLAGS) LINK TO $@ minigzip.o $(LDFLAGS)
-
-mostlyclean: clean
-clean:
-	-delete force quiet example minigzip *.o z.lib foo.gz *.lnk SCOPTIONS
-
-SCOPTIONS: Makefile.sas
-	copy to $@ <from <
-$(SCOPTIONS)
-<
-
-# DO NOT DELETE THIS LINE -- make depend depends on it.
-
-adler32.o: zlib.h zconf.h
-compress.o: zlib.h zconf.h
-crc32.o: crc32.h zlib.h zconf.h
-deflate.o: deflate.h zutil.h zlib.h zconf.h
-example.o: zlib.h zconf.h
-gzclose.o: zlib.h zconf.h gzguts.h
-gzlib.o: zlib.h zconf.h gzguts.h
-gzread.o: zlib.h zconf.h gzguts.h
-gzwrite.o: zlib.h zconf.h gzguts.h
-inffast.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-inflate.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-infback.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-inftrees.o: zutil.h zlib.h zconf.h inftrees.h
-minigzip.o: zlib.h zconf.h
-trees.o: deflate.h zutil.h zlib.h zconf.h trees.h
-uncompr.o: zlib.h zconf.h
-zutil.o: zutil.h zlib.h zconf.h
diff -Nbaur gcc-4.8.1/zlib/as400/bndsrc gcc-4.8.1-ppc/zlib/as400/bndsrc
--- gcc-4.8.1/zlib/as400/bndsrc	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/as400/bndsrc	1970-01-01 01:00:00.000000000 +0100
@@ -1,205 +0,0 @@
-STRPGMEXP PGMLVL(*CURRENT) SIGNATURE('ZLIB')
-
-/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
-/*   Version 1.1.3 entry points.                                    */
-/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
-
-/********************************************************************/
-/*   *MODULE      ADLER32      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("adler32")
-
-/********************************************************************/
-/*   *MODULE      COMPRESS     ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("compress")
-  EXPORT SYMBOL("compress2")
-
-/********************************************************************/
-/*   *MODULE      CRC32        ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("crc32")
-  EXPORT SYMBOL("get_crc_table")
-
-/********************************************************************/
-/*   *MODULE      DEFLATE      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("deflate")
-  EXPORT SYMBOL("deflateEnd")
-  EXPORT SYMBOL("deflateSetDictionary")
-  EXPORT SYMBOL("deflateCopy")
-  EXPORT SYMBOL("deflateReset")
-  EXPORT SYMBOL("deflateParams")
-  EXPORT SYMBOL("deflatePrime")
-  EXPORT SYMBOL("deflateInit_")
-  EXPORT SYMBOL("deflateInit2_")
-
-/********************************************************************/
-/*   *MODULE      GZIO         ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("gzopen")
-  EXPORT SYMBOL("gzdopen")
-  EXPORT SYMBOL("gzsetparams")
-  EXPORT SYMBOL("gzread")
-  EXPORT SYMBOL("gzwrite")
-  EXPORT SYMBOL("gzprintf")
-  EXPORT SYMBOL("gzputs")
-  EXPORT SYMBOL("gzgets")
-  EXPORT SYMBOL("gzputc")
-  EXPORT SYMBOL("gzgetc")
-  EXPORT SYMBOL("gzflush")
-  EXPORT SYMBOL("gzseek")
-  EXPORT SYMBOL("gzrewind")
-  EXPORT SYMBOL("gztell")
-  EXPORT SYMBOL("gzeof")
-  EXPORT SYMBOL("gzclose")
-  EXPORT SYMBOL("gzerror")
-
-/********************************************************************/
-/*   *MODULE      INFLATE      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("inflate")
-  EXPORT SYMBOL("inflateEnd")
-  EXPORT SYMBOL("inflateSetDictionary")
-  EXPORT SYMBOL("inflateSync")
-  EXPORT SYMBOL("inflateReset")
-  EXPORT SYMBOL("inflateInit_")
-  EXPORT SYMBOL("inflateInit2_")
-  EXPORT SYMBOL("inflateSyncPoint")
-
-/********************************************************************/
-/*   *MODULE      UNCOMPR      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("uncompress")
-
-/********************************************************************/
-/*   *MODULE      ZUTIL        ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("zlibVersion")
-  EXPORT SYMBOL("zError")
-
-/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
-/*   Version 1.2.1 additional entry points.                         */
-/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
-
-/********************************************************************/
-/*   *MODULE      COMPRESS     ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("compressBound")
-
-/********************************************************************/
-/*   *MODULE      DEFLATE      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("deflateBound")
-
-/********************************************************************/
-/*   *MODULE      GZIO         ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("gzungetc")
-  EXPORT SYMBOL("gzclearerr")
-
-/********************************************************************/
-/*   *MODULE      INFBACK      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("inflateBack")
-  EXPORT SYMBOL("inflateBackEnd")
-  EXPORT SYMBOL("inflateBackInit_")
-
-/********************************************************************/
-/*   *MODULE      INFLATE      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("inflateCopy")
-
-/********************************************************************/
-/*   *MODULE      ZUTIL        ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("zlibCompileFlags")
-
-/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
-/*   Version 1.2.5 additional entry points.                         */
-/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
-
-/********************************************************************/
-/*   *MODULE      ADLER32      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("adler32_combine")
-  EXPORT SYMBOL("adler32_combine64")
-
-/********************************************************************/
-/*   *MODULE      CRC32        ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("crc32_combine")
-  EXPORT SYMBOL("crc32_combine64")
-
-/********************************************************************/
-/*   *MODULE      GZLIB        ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("gzbuffer")
-  EXPORT SYMBOL("gzoffset")
-  EXPORT SYMBOL("gzoffset64")
-  EXPORT SYMBOL("gzopen64")
-  EXPORT SYMBOL("gzseek64")
-  EXPORT SYMBOL("gztell64")
-
-/********************************************************************/
-/*   *MODULE      GZREAD       ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("gzclose_r")
-
-/********************************************************************/
-/*   *MODULE      GZWRITE      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("gzclose_w")
-
-/********************************************************************/
-/*   *MODULE      INFLATE      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("inflateMark")
-  EXPORT SYMBOL("inflatePrime")
-  EXPORT SYMBOL("inflateReset2")
-  EXPORT SYMBOL("inflateUndermine")
-
-/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
-/*   Version 1.2.6 additional entry points.                         */
-/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
-
-/********************************************************************/
-/*   *MODULE      DEFLATE      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("deflateResetKeep")
-  EXPORT SYMBOL("deflatePending")
-
-/********************************************************************/
-/*   *MODULE      GZWRITE      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("gzgetc_")
-
-/********************************************************************/
-/*   *MODULE      INFLATE      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("inflateResetKeep")
-
-ENDPGMEXP
diff -Nbaur gcc-4.8.1/zlib/as400/compile.clp gcc-4.8.1-ppc/zlib/as400/compile.clp
--- gcc-4.8.1/zlib/as400/compile.clp	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/as400/compile.clp	1970-01-01 01:00:00.000000000 +0100
@@ -1,110 +0,0 @@
-/******************************************************************************/
-/*                                                                            */
-/*  ZLIB                                                                      */
-/*                                                                            */
-/*    Compile sources into modules and link them into a service program.      */
-/*                                                                            */
-/******************************************************************************/
-
-             PGM
-
-/*      Configuration adjustable parameters.                                  */
-
-             DCL        VAR(&SRCLIB) TYPE(*CHAR) LEN(10) +
-                          VALUE('ZLIB')                         /* Source library. */
-             DCL        VAR(&SRCFILE) TYPE(*CHAR) LEN(10) +
-                          VALUE('SOURCES')                      /* Source member file. */
-             DCL        VAR(&CTLFILE) TYPE(*CHAR) LEN(10) +
-                          VALUE('TOOLS')                        /* Control member file. */
-
-             DCL        VAR(&MODLIB) TYPE(*CHAR) LEN(10) +
-                          VALUE('ZLIB')                         /* Module library. */
-
-             DCL        VAR(&SRVLIB) TYPE(*CHAR) LEN(10) +
-                          VALUE('LGPL')                         /* Service program library. */
-
-             DCL        VAR(&CFLAGS) TYPE(*CHAR) +
-                          VALUE('OPTIMIZE(40)')                 /* Compile options. */
-
-             DCL        VAR(&TGTRLS) TYPE(*CHAR) +
-                          VALUE('V5R3M0')                       /* Target release. */
-
-
-/*      Working storage.                                                      */
-
-             DCL        VAR(&CMDLEN) TYPE(*DEC) LEN(15 5) VALUE(300)    /* Command length. */
-             DCL        VAR(&CMD) TYPE(*CHAR) LEN(512)
-             DCL        VAR(&FIXDCMD) TYPE(*CHAR) LEN(512)
-
-
-/*      Compile sources into modules.                                         */
-
-             CHGVAR     VAR(&FIXDCMD) VALUE('CRTCMOD' *BCAT &CFLAGS *BCAT      +
-                        'SYSIFCOPT(*IFS64IO)' *BCAT                            +
-                        'DEFINE(''_LARGEFILE64_SOURCE''' *BCAT                 +
-                        '''_LFS64_LARGEFILE=1'') TGTRLS(' *TCAT &TGTRLS *TCAT  +
-                        ') SRCFILE(' *TCAT &SRCLIB *TCAT '/' *TCAT             +
-                        &SRCFILE *TCAT ') MODULE(' *TCAT &MODLIB *TCAT '/')
-
-
-             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'ADLER32)')
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'COMPRESS)')
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'CRC32)')
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'DEFLATE)')
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'GZCLOSE)')
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'GZLIB)')
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'GZREAD)')
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'GZWRITE)')
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'INFBACK)')
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'INFFAST)')
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'INFLATE)')
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'INFTREES)')
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'TREES)')
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'UNCOMPR)')
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE(&FIXDCMD *TCAT 'ZUTIL)')
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-
-/*      Link modules into a service program.                                  */
-
-             CRTSRVPGM  SRVPGM(&SRVLIB/ZLIB) +
-                          MODULE(&MODLIB/ADLER32     &MODLIB/COMPRESS    +
-                                 &MODLIB/CRC32       &MODLIB/DEFLATE     +
-                                 &MODLIB/GZCLOSE     &MODLIB/GZLIB       +
-                                 &MODLIB/GZREAD      &MODLIB/GZWRITE     +
-                                 &MODLIB/INFBACK     &MODLIB/INFFAST     +
-                                 &MODLIB/INFLATE     &MODLIB/INFTREES    +
-                                 &MODLIB/TREES       &MODLIB/UNCOMPR     +
-                                 &MODLIB/ZUTIL)                          +
-                          SRCFILE(&SRCLIB/&CTLFILE) SRCMBR(BNDSRC)       +
-                          TEXT('ZLIB 1.2.7') TGTRLS(&TGTRLS)
-
-             ENDPGM
diff -Nbaur gcc-4.8.1/zlib/as400/readme.txt gcc-4.8.1-ppc/zlib/as400/readme.txt
--- gcc-4.8.1/zlib/as400/readme.txt	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/as400/readme.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,115 +0,0 @@
-        ZLIB version 1.2.7 for AS400 installation instructions
-
-I) From an AS400 *SAVF file:
-
-1)      Unpacking archive to an AS400 save file
-
-On the AS400:
-
-_       Create the ZLIB AS400 library:
-
-        CRTLIB LIB(ZLIB) TYPE(*PROD) TEXT('ZLIB compression API library')
-
-_       Create a work save file, for example:
-
-                CRTSAVF FILE(ZLIB/ZLIBSAVF)
-
-On a PC connected to the target AS400:
-
-_       Unpack the save file image to a PC file "ZLIBSAVF"
-_       Upload this file into the save file on the AS400, for example
-                using ftp in BINARY mode.
-
-
-2)      Populating the ZLIB AS400 source library
-
-On the AS400:
-
-_       Extract the saved objects into the ZLIB AS400 library using:
-
-RSTOBJ OBJ(*ALL) SAVLIB(ZLIB) DEV(*SAVF) SAVF(ZLIB/ZLIBSAVF) RSTLIB(ZLIB)
-
-
-3)      Customize installation:
-
-_       Edit CL member ZLIB/TOOLS(COMPILE) and change parameters if needed,
-                according to the comments.
-
-_       Compile this member with:
-
-        CRTCLPGM PGM(ZLIB/COMPILE) SRCFILE(ZLIB/TOOLS) SRCMBR(COMPILE)
-
-
-4)      Compile and generate the service program:
-
-_       This can now be done by executing:
-
-        CALL PGM(ZLIB/COMPILE)
-
-
-
-II) From the original source distribution:
-
-1)      On the AS400, create the source library:
-
-        CRTLIB LIB(ZLIB) TYPE(*PROD) TEXT('ZLIB compression API library')
-
-2)      Create the source files:
-
-        CRTSRCPF FILE(ZLIB/SOURCES) RCDLEN(112) TEXT('ZLIB library modules')
-        CRTSRCPF FILE(ZLIB/H)       RCDLEN(112) TEXT('ZLIB library includes')
-        CRTSRCPF FILE(ZLIB/TOOLS)   RCDLEN(112) TEXT('ZLIB library control utilities')
-
-3)      From the machine hosting the distribution files, upload them (with
-                FTP in text mode, for example) according to the following table:
-
-    Original    AS400   AS400    AS400 AS400
-    file        file    member   type  description
-                SOURCES                Original ZLIB C subprogram sources
-    adler32.c           ADLER32  C     ZLIB - Compute the Adler-32 checksum of a dta strm
-    compress.c          COMPRESS C     ZLIB - Compress a memory buffer
-    crc32.c             CRC32    C     ZLIB - Compute the CRC-32 of a data stream
-    deflate.c           DEFLATE  C     ZLIB - Compress data using the deflation algorithm
-    gzclose.c           GZCLOSE  C     ZLIB - Close .gz files
-    gzlib.c             GZLIB    C     ZLIB - Miscellaneous .gz files IO support
-    gzread.c            GZREAD   C     ZLIB - Read .gz files
-    gzwrite.c           GZWRITE  C     ZLIB - Write .gz files
-    infback.c           INFBACK  C     ZLIB - Inflate using a callback interface
-    inffast.c           INFFAST  C     ZLIB - Fast proc. literals & length/distance pairs
-    inflate.c           INFLATE  C     ZLIB - Interface to inflate modules
-    inftrees.c          INFTREES C     ZLIB - Generate Huffman trees for efficient decode
-    trees.c             TREES    C     ZLIB - Output deflated data using Huffman coding
-    uncompr.c           UNCOMPR  C     ZLIB - Decompress a memory buffer
-    zutil.c             ZUTIL    C     ZLIB - Target dependent utility functions
-                H                      Original ZLIB C and ILE/RPG include files
-    crc32.h             CRC32    C     ZLIB - CRC32 tables
-    deflate.h           DEFLATE  C     ZLIB - Internal compression state
-    gzguts.h            GZGUTS   C     ZLIB - Definitions for the gzclose module
-    inffast.h           INFFAST  C     ZLIB - Header to use inffast.c
-    inffixed.h          INFFIXED C     ZLIB - Table for decoding fixed codes
-    inflate.h           INFLATE  C     ZLIB - Internal inflate state definitions
-    inftrees.h          INFTREES C     ZLIB - Header to use inftrees.c
-    trees.h             TREES    C     ZLIB - Created automatically with -DGEN_TREES_H
-    zconf.h             ZCONF    C     ZLIB - Compression library configuration
-    zlib.h              ZLIB     C     ZLIB - Compression library C user interface
-    as400/zlib.inc      ZLIB.INC RPGLE ZLIB - Compression library ILE RPG user interface
-    zutil.h             ZUTIL    C     ZLIB - Internal interface and configuration
-                TOOLS                  Building source software & AS/400 README
-    as400/bndsrc        BNDSRC         Entry point exportation list
-    as400/compile.clp   COMPILE  CLP   Compile sources & generate service program
-    as400/readme.txt    README   TXT   Installation instructions
-
-4)      Continue as in I)3).
-
-
-
-
-Notes:  For AS400 ILE RPG programmers, a /copy member defining the ZLIB
-                API prototypes for ILE RPG can be found in ZLIB/H(ZLIB.INC).
-                Please read comments in this member for more information.
-
-        Remember that most foreign textual data are ASCII coded: this
-                implementation does not handle conversion from/to ASCII, so
-                text data code conversions must be done explicitely.
-
-        Mainly for the reason above, always open zipped files in binary mode.
diff -Nbaur gcc-4.8.1/zlib/as400/zlib.inc gcc-4.8.1-ppc/zlib/as400/zlib.inc
--- gcc-4.8.1/zlib/as400/zlib.inc	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/as400/zlib.inc	1970-01-01 01:00:00.000000000 +0100
@@ -1,445 +0,0 @@
-      *  ZLIB.INC - Interface to the general purpose compression library
-      *
-      *  ILE RPG400 version by Patrick Monnerat, DATASPHERE.
-      *  Version 1.2.7
-      *
-      *
-      *  WARNING:
-      *     Procedures inflateInit(), inflateInit2(), deflateInit(),
-      *         deflateInit2() and inflateBackInit() need to be called with
-      *         two additional arguments:
-      *         the package version string and the stream control structure.
-      *         size. This is needed because RPG lacks some macro feature.
-      *         Call these procedures as:
-      *             inflateInit(...: ZLIB_VERSION: %size(z_stream))
-      *
-      /if not defined(ZLIB_H_)
-      /define ZLIB_H_
-      *
-      **************************************************************************
-      *                               Constants
-      **************************************************************************
-      *
-      *  Versioning information.
-      *
-     D ZLIB_VERSION    C                   '1.2.7'
-     D ZLIB_VERNUM     C                   X'1270'
-     D ZLIB_VER_MAJOR  C                   1
-     D ZLIB_VER_MINOR  C                   2
-     D ZLIB_VER_REVISION...
-     D                 C                   7
-     D ZLIB_VER_SUBREVISION...
-     D                 C                   0
-      *
-      *  Other equates.
-      *
-     D Z_NO_FLUSH      C                   0
-     D Z_PARTIAL_FLUSH...
-     D                 C                   1
-     D Z_SYNC_FLUSH    C                   2
-     D Z_FULL_FLUSH    C                   3
-     D Z_FINISH        C                   4
-     D Z_BLOCK         C                   5
-     D Z_TREES         C                   6
-      *
-     D Z_OK            C                   0
-     D Z_STREAM_END    C                   1
-     D Z_NEED_DICT     C                   2
-     D Z_ERRNO         C                   -1
-     D Z_STREAM_ERROR  C                   -2
-     D Z_DATA_ERROR    C                   -3
-     D Z_MEM_ERROR     C                   -4
-     D Z_BUF_ERROR     C                   -5
-     DZ_VERSION_ERROR  C                   -6
-      *
-     D Z_NO_COMPRESSION...
-     D                 C                   0
-     D Z_BEST_SPEED    C                   1
-     D Z_BEST_COMPRESSION...
-     D                 C                   9
-     D Z_DEFAULT_COMPRESSION...
-     D                 C                   -1
-      *
-     D Z_FILTERED      C                   1
-     D Z_HUFFMAN_ONLY  C                   2
-     D Z_RLE           C                   3
-     D Z_DEFAULT_STRATEGY...
-     D                 C                   0
-      *
-     D Z_BINARY        C                   0
-     D Z_ASCII         C                   1
-     D Z_UNKNOWN       C                   2
-      *
-     D Z_DEFLATED      C                   8
-      *
-     D Z_NULL          C                   0
-      *
-      **************************************************************************
-      *                                 Types
-      **************************************************************************
-      *
-     D z_streamp       S               *                                        Stream struct ptr
-     D gzFile          S               *                                        File pointer
-     D z_off_t         S             10i 0                                      Stream offsets
-     D z_off64_t       S             20i 0                                      Stream offsets
-      *
-      **************************************************************************
-      *                               Structures
-      **************************************************************************
-      *
-      *  The GZIP encode/decode stream support structure.
-      *
-     D z_stream        DS                  align based(z_streamp)
-     D  zs_next_in                     *                                        Next input byte
-     D  zs_avail_in                  10U 0                                      Byte cnt at next_in
-     D  zs_total_in                  10U 0                                      Total bytes read
-     D  zs_next_out                    *                                        Output buffer ptr
-     D  zs_avail_out                 10U 0                                      Room left @ next_out
-     D  zs_total_out                 10U 0                                      Total bytes written
-     D  zs_msg                         *                                        Last errmsg or null
-     D  zs_state                       *                                        Internal state
-     D  zs_zalloc                      *   procptr                              Int. state allocator
-     D  zs_free                        *   procptr                              Int. state dealloc.
-     D  zs_opaque                      *                                        Private alloc. data
-     D  zs_data_type                 10i 0                                      ASC/BIN best guess
-     D  zs_adler                     10u 0                                      Uncompr. adler32 val
-     D                               10U 0                                      Reserved
-     D                               10U 0                                      Ptr. alignment
-      *
-      **************************************************************************
-      *                     Utility function prototypes
-      **************************************************************************
-      *
-     D compress        PR            10I 0 extproc('compress')
-     D  dest                      65535    options(*varsize)                    Destination buffer
-     D  destLen                      10U 0                                      Destination length
-     D  source                    65535    const options(*varsize)              Source buffer
-     D  sourceLen                    10u 0 value                                Source length
-      *
-     D compress2       PR            10I 0 extproc('compress2')
-     D  dest                      65535    options(*varsize)                    Destination buffer
-     D  destLen                      10U 0                                      Destination length
-     D  source                    65535    const options(*varsize)              Source buffer
-     D  sourceLen                    10U 0 value                                Source length
-     D  level                        10I 0 value                                Compression level
-      *
-     D compressBound   PR            10U 0 extproc('compressBound')
-     D  sourceLen                    10U 0 value
-      *
-     D uncompress      PR            10I 0 extproc('uncompress')
-     D  dest                      65535    options(*varsize)                    Destination buffer
-     D  destLen                      10U 0                                      Destination length
-     D  source                    65535    const options(*varsize)              Source buffer
-     D  sourceLen                    10U 0 value                                Source length
-      *
-      /if not defined(LARGE_FILES)
-     D gzopen          PR                  extproc('gzopen')
-     D                                     like(gzFile)
-     D  path                           *   value options(*string)               File pathname
-     D  mode                           *   value options(*string)               Open mode
-      /else
-     D gzopen          PR                  extproc('gzopen64')
-     D                                     like(gzFile)
-     D  path                           *   value options(*string)               File pathname
-     D  mode                           *   value options(*string)               Open mode
-      *
-     D gzopen64        PR                  extproc('gzopen64')
-     D                                     like(gzFile)
-     D  path                           *   value options(*string)               File pathname
-     D  mode                           *   value options(*string)               Open mode
-      /endif
-      *
-     D gzdopen         PR                  extproc('gzdopen')
-     D                                     like(gzFile)
-     D  fd                           10I 0 value                                File descriptor
-     D  mode                           *   value options(*string)               Open mode
-      *
-     D gzbuffer        PR            10I 0 extproc('gzbuffer')
-     D  file                               value like(gzFile)                   File pointer
-     D  size                         10U 0 value
-      *
-     D gzsetparams     PR            10I 0 extproc('gzsetparams')
-     D  file                               value like(gzFile)                   File pointer
-     D  level                        10I 0 value
-     D  strategy                     10I 0 value
-      *
-     D gzread          PR            10I 0 extproc('gzread')
-     D  file                               value like(gzFile)                   File pointer
-     D  buf                       65535    options(*varsize)                    Buffer
-     D  len                          10u 0 value                                Buffer length
-      *
-     D gzwrite         PR            10I 0 extproc('gzwrite')
-     D  file                               value like(gzFile)                   File pointer
-     D  buf                       65535    const options(*varsize)              Buffer
-     D  len                          10u 0 value                                Buffer length
-      *
-     D gzputs          PR            10I 0 extproc('gzputs')
-     D  file                               value like(gzFile)                   File pointer
-     D  s                              *   value options(*string)               String to output
-      *
-     D gzgets          PR              *   extproc('gzgets')
-     D  file                               value like(gzFile)                   File pointer
-     D  buf                       65535    options(*varsize)                    Read buffer
-     D  len                          10i 0 value                                Buffer length
-      *
-     D gzputc          PR            10i 0 extproc('gzputc')
-     D  file                               value like(gzFile)                   File pointer
-     D  c                            10I 0 value                                Character to write
-      *
-     D gzgetc          PR            10i 0 extproc('gzgetc')
-     D  file                               value like(gzFile)                   File pointer
-      *
-     D gzgetc_         PR            10i 0 extproc('gzgetc_')
-     D  file                               value like(gzFile)                   File pointer
-      *
-     D gzungetc        PR            10i 0 extproc('gzungetc')
-     D  c                            10I 0 value                                Character to push
-     D  file                               value like(gzFile)                   File pointer
-      *
-     D gzflush         PR            10i 0 extproc('gzflush')
-     D  file                               value like(gzFile)                   File pointer
-     D  flush                        10I 0 value                                Type of flush
-      *
-      /if not defined(LARGE_FILES)
-     D gzseek          PR                  extproc('gzseek')
-     D                                     like(z_off_t)
-     D  file                               value like(gzFile)                   File pointer
-     D  offset                             value like(z_off_t)                  Offset
-     D  whence                       10i 0 value                                Origin
-      /else
-     D gzseek          PR                  extproc('gzseek64')
-     D                                     like(z_off_t)
-     D  file                               value like(gzFile)                   File pointer
-     D  offset                             value like(z_off_t)                  Offset
-     D  whence                       10i 0 value                                Origin
-      *
-     D gzseek64        PR                  extproc('gzseek64')
-     D                                     like(z_off64_t)
-     D  file                               value like(gzFile)                   File pointer
-     D  offset                             value like(z_off64_t)                Offset
-     D  whence                       10i 0 value                                Origin
-      /endif
-      *
-     D gzrewind        PR            10i 0 extproc('gzrewind')
-     D  file                               value like(gzFile)                   File pointer
-      *
-      /if not defined(LARGE_FILES)
-     D gztell          PR                  extproc('gztell')
-     D                                     like(z_off_t)
-     D  file                               value like(gzFile)                   File pointer
-      /else
-     D gztell          PR                  extproc('gztell64')
-     D                                     like(z_off_t)
-     D  file                               value like(gzFile)                   File pointer
-      *
-     D gztell64        PR                  extproc('gztell64')
-     D                                     like(z_off64_t)
-     D  file                               value like(gzFile)                   File pointer
-      /endif
-      *
-      /if not defined(LARGE_FILES)
-     D gzoffset        PR                  extproc('gzoffset')
-     D                                     like(z_off_t)
-     D  file                               value like(gzFile)                   File pointer
-      /else
-     D gzoffset        PR                  extproc('gzoffset64')
-     D                                     like(z_off_t)
-     D  file                               value like(gzFile)                   File pointer
-      *
-     D gzoffset64      PR                  extproc('gzoffset64')
-     D                                     like(z_off64_t)
-     D  file                               value like(gzFile)                   File pointer
-      /endif
-      *
-     D gzeof           PR            10i 0 extproc('gzeof')
-     D  file                               value like(gzFile)                   File pointer
-      *
-     D gzclose_r       PR            10i 0 extproc('gzclose_r')
-     D  file                               value like(gzFile)                   File pointer
-      *
-     D gzclose_w       PR            10i 0 extproc('gzclose_w')
-     D  file                               value like(gzFile)                   File pointer
-      *
-     D gzclose         PR            10i 0 extproc('gzclose')
-     D  file                               value like(gzFile)                   File pointer
-      *
-     D gzerror         PR              *   extproc('gzerror')                   Error string
-     D  file                               value like(gzFile)                   File pointer
-     D  errnum                       10I 0                                      Error code
-      *
-     D gzclearerr      PR                  extproc('gzclearerr')
-     D  file                               value like(gzFile)                   File pointer
-      *
-      **************************************************************************
-      *                        Basic function prototypes
-      **************************************************************************
-      *
-     D zlibVersion     PR              *   extproc('zlibVersion')               Version string
-      *
-     D deflateInit     PR            10I 0 extproc('deflateInit_')              Init. compression
-     D  strm                               like(z_stream)                       Compression stream
-     D  level                        10I 0 value                                Compression level
-     D  version                        *   value options(*string)               Version string
-     D  stream_size                  10i 0 value                                Stream struct. size
-      *
-     D deflate         PR            10I 0 extproc('deflate')                   Compress data
-     D  strm                               like(z_stream)                       Compression stream
-     D  flush                        10I 0 value                                Flush type required
-      *
-     D deflateEnd      PR            10I 0 extproc('deflateEnd')                Termin. compression
-     D  strm                               like(z_stream)                       Compression stream
-      *
-     D inflateInit     PR            10I 0 extproc('inflateInit_')              Init. expansion
-     D  strm                               like(z_stream)                       Expansion stream
-     D  version                        *   value options(*string)               Version string
-     D  stream_size                  10i 0 value                                Stream struct. size
-      *
-     D inflate         PR            10I 0 extproc('inflate')                   Expand data
-     D  strm                               like(z_stream)                       Expansion stream
-     D  flush                        10I 0 value                                Flush type required
-      *
-     D inflateEnd      PR            10I 0 extproc('inflateEnd')                Termin. expansion
-     D  strm                               like(z_stream)                       Expansion stream
-      *
-      **************************************************************************
-      *                        Advanced function prototypes
-      **************************************************************************
-      *
-     D deflateInit2    PR            10I 0 extproc('deflateInit2_')             Init. compression
-     D  strm                               like(z_stream)                       Compression stream
-     D  level                        10I 0 value                                Compression level
-     D  method                       10I 0 value                                Compression method
-     D  windowBits                   10I 0 value                                log2(window size)
-     D  memLevel                     10I 0 value                                Mem/cmpress tradeoff
-     D  strategy                     10I 0 value                                Compression stategy
-     D  version                        *   value options(*string)               Version string
-     D  stream_size                  10i 0 value                                Stream struct. size
-      *
-     D deflateSetDictionary...
-     D                 PR            10I 0 extproc('deflateSetDictionary')      Init. dictionary
-     D  strm                               like(z_stream)                       Compression stream
-     D  dictionary                65535    const options(*varsize)              Dictionary bytes
-     D  dictLength                   10U 0 value                                Dictionary length
-      *
-     D deflateCopy     PR            10I 0 extproc('deflateCopy')               Compress strm 2 strm
-     D  dest                               like(z_stream)                       Destination stream
-     D  source                             like(z_stream)                       Source stream
-      *
-     D deflateReset    PR            10I 0 extproc('deflateReset')              End and init. stream
-     D  strm                               like(z_stream)                       Compression stream
-      *
-     D deflateParams   PR            10I 0 extproc('deflateParams')             Change level & strat
-     D  strm                               like(z_stream)                       Compression stream
-     D  level                        10I 0 value                                Compression level
-     D  strategy                     10I 0 value                                Compression stategy
-      *
-     D deflateBound    PR            10U 0 extproc('deflateBound')              Change level & strat
-     D  strm                               like(z_stream)                       Compression stream
-     D  sourcelen                    10U 0 value                                Compression level
-      *
-     D deflatePending  PR            10I 0 extproc('deflatePending')            Change level & strat
-     D  strm                               like(z_stream)                       Compression stream
-     D  pending                      10U 0                                      Pending bytes
-     D  bits                         10I 0                                      Pending bits
-      *
-     D deflatePrime    PR            10I 0 extproc('deflatePrime')              Change level & strat
-     D  strm                               like(z_stream)                       Compression stream
-     D  bits                         10I 0 value                                # of bits to insert
-     D  value                        10I 0 value                                Bits to insert
-      *
-     D inflateInit2    PR            10I 0 extproc('inflateInit2_')             Init. expansion
-     D  strm                               like(z_stream)                       Expansion stream
-     D  windowBits                   10I 0 value                                log2(window size)
-     D  version                        *   value options(*string)               Version string
-     D  stream_size                  10i 0 value                                Stream struct. size
-      *
-     D inflateSetDictionary...
-     D                 PR            10I 0 extproc('inflateSetDictionary')      Init. dictionary
-     D  strm                               like(z_stream)                       Expansion stream
-     D  dictionary                65535    const options(*varsize)              Dictionary bytes
-     D  dictLength                   10U 0 value                                Dictionary length
-      *
-     D inflateSync     PR            10I 0 extproc('inflateSync')               Sync. expansion
-     D  strm                               like(z_stream)                       Expansion stream
-      *
-     D inflateCopy     PR            10I 0 extproc('inflateCopy')
-     D  dest                               like(z_stream)                       Destination stream
-     D  source                             like(z_stream)                       Source stream
-      *
-     D inflateReset    PR            10I 0 extproc('inflateReset')              End and init. stream
-     D  strm                               like(z_stream)                       Expansion stream
-      *
-     D inflateReset2   PR            10I 0 extproc('inflateReset2')             End and init. stream
-     D  strm                               like(z_stream)                       Expansion stream
-     D  windowBits                   10I 0 value                                Log2(buffer size)
-      *
-     D inflatePrime    PR            10I 0 extproc('inflatePrime')              Insert bits
-     D  strm                               like(z_stream)                       Expansion stream
-     D  bits                         10I 0 value                                Bit count
-     D  value                        10I 0 value                                Bits to insert
-      *
-     D inflateMark     PR            10I 0 extproc('inflateMark')               Get inflate info
-     D  strm                               like(z_stream)                       Expansion stream
-      *
-     D inflateBackInit...
-     D                 PR            10I 0 extproc('inflateBackInit_')
-     D  strm                               like(z_stream)                       Expansion stream
-     D  windowBits                   10I 0 value                                Log2(buffer size)
-     D  window                    65535    options(*varsize)                    Buffer
-     D  version                        *   value options(*string)               Version string
-     D  stream_size                  10i 0 value                                Stream struct. size
-      *
-     D inflateBack     PR            10I 0 extproc('inflateBack')
-     D  strm                               like(z_stream)                       Expansion stream
-     D  in                             *   value procptr                        Input function
-     D  in_desc                        *   value                                Input descriptor
-     D  out                            *   value procptr                        Output function
-     D  out_desc                       *   value                                Output descriptor
-      *
-     D inflateBackEnd  PR            10I 0 extproc('inflateBackEnd')
-     D  strm                               like(z_stream)                       Expansion stream
-      *
-     D zlibCompileFlags...
-     D                 PR            10U 0 extproc('zlibCompileFlags')
-      *
-      **************************************************************************
-      *                        Checksum function prototypes
-      **************************************************************************
-      *
-     D adler32         PR            10U 0 extproc('adler32')                   New checksum
-     D  adler                        10U 0 value                                Old checksum
-     D  buf                       65535    const options(*varsize)              Bytes to accumulate
-     D  len                          10U 0 value                                Buffer length
-      *
-     D crc32           PR            10U 0 extproc('crc32')                     New checksum
-     D  crc                          10U 0 value                                Old checksum
-     D  buf                       65535    const options(*varsize)              Bytes to accumulate
-     D  len                          10U 0 value                                Buffer length
-      *
-      **************************************************************************
-      *                     Miscellaneous function prototypes
-      **************************************************************************
-      *
-     D zError          PR              *   extproc('zError')                    Error string
-     D  err                          10I 0 value                                Error code
-      *
-     D inflateSyncPoint...
-     D                 PR            10I 0 extproc('inflateSyncPoint')
-     D  strm                               like(z_stream)                       Expansion stream
-      *
-     D get_crc_table   PR              *   extproc('get_crc_table')             Ptr to ulongs
-      *
-     D inflateUndermine...
-     D                 PR            10I 0 extproc('inflateUndermine')
-     D  strm                               like(z_stream)                       Expansion stream
-     D  arg                          10I 0 value                                Error code
-      *
-     D inflateResetKeep...
-     D                 PR            10I 0 extproc('inflateResetKeep')          End and init. stream
-     D  strm                               like(z_stream)                       Expansion stream
-      *
-     D deflateResetKeep...
-     D                 PR            10I 0 extproc('deflateResetKeep')          End and init. stream
-     D  strm                               like(z_stream)                       Expansion stream
-      *
-      /endif
diff -Nbaur gcc-4.8.1/zlib/ChangeLog gcc-4.8.1-ppc/zlib/ChangeLog
--- gcc-4.8.1/zlib/ChangeLog	2013-05-31 10:00:14.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/ChangeLog	1970-01-01 01:00:00.000000000 +0100
@@ -1,1417 +0,0 @@
-2013-05-31  Release Manager
-
-	* GCC 4.8.1 released.
-
-2013-03-22  Release Manager
-
-	* GCC 4.8.0 released.
-
-
-                ChangeLog file for zlib
-
-Changes in 1.2.7 (2 May 2012)
-- Replace use of memmove() with a simple copy for portability
-- Test for existence of strerror
-- Restore gzgetc_ for backward compatibility with 1.2.6
-- Fix build with non-GNU make on Solaris
-- Require gcc 4.0 or later on Mac OS X to use the hidden attribute
-- Include unistd.h for Watcom C
-- Use __WATCOMC__ instead of __WATCOM__
-- Do not use the visibility attribute if NO_VIZ defined
-- Improve the detection of no hidden visibility attribute
-- Avoid using __int64 for gcc or solo compilation
-- Cast to char * in gzprintf to avoid warnings [Zinser]
-- Fix make_vms.com for VAX [Zinser]
-- Don't use library or built-in byte swaps
-- Simplify test and use of gcc hidden attribute
-- Fix bug in gzclose_w() when gzwrite() fails to allocate memory
-- Add "x" (O_EXCL) and "e" (O_CLOEXEC) modes support to gzopen()
-- Fix bug in test/minigzip.c for configure --solo
-- Fix contrib/vstudio project link errors [Mohanathas]
-- Add ability to choose the builder in make_vms.com [Schweda]
-- Add DESTDIR support to mingw32 win32/Makefile.gcc
-- Fix comments in win32/Makefile.gcc for proper usage
-- Allow overriding the default install locations for cmake
-- Generate and install the pkg-config file with cmake
-- Build both a static and a shared version of zlib with cmake
-- Include version symbols for cmake builds
-- If using cmake with MSVC, add the source directory to the includes
-- Remove unneeded EXTRA_CFLAGS from win32/Makefile.gcc [Truta]
-- Move obsolete emx makefile to old [Truta]
-- Allow the use of -Wundef when compiling or using zlib
-- Avoid the use of the -u option with mktemp
-- Improve inflate() documentation on the use of Z_FINISH
-- Recognize clang as gcc
-- Add gzopen_w() in Windows for wide character path names
-- Rename zconf.h in CMakeLists.txt to move it out of the way
-- Add source directory in CMakeLists.txt for building examples
-- Look in build directory for zlib.pc in CMakeLists.txt
-- Remove gzflags from zlibvc.def in vc9 and vc10
-- Fix contrib/minizip compilation in the MinGW environment
-- Update ./configure for Solaris, support --64 [Mooney]
-- Remove -R. from Solaris shared build (possible security issue)
-- Avoid race condition for parallel make (-j) running example
-- Fix type mismatch between get_crc_table() and crc_table
-- Fix parsing of version with "-" in CMakeLists.txt [Snider, Ziegler]
-- Fix the path to zlib.map in CMakeLists.txt
-- Force the native libtool in Mac OS X to avoid GNU libtool [Beebe]
-- Add instructions to win32/Makefile.gcc for shared install [Torri]
-
-Changes in 1.2.6.1 (12 Feb 2012)
-- Avoid the use of the Objective-C reserved name "id"
-- Include io.h in gzguts.h for Microsoft compilers
-- Fix problem with ./configure --prefix and gzgetc macro
-- Include gz_header definition when compiling zlib solo
-- Put gzflags() functionality back in zutil.c
-- Avoid library header include in crc32.c for Z_SOLO
-- Use name in GCC_CLASSIC as C compiler for coverage testing, if set
-- Minor cleanup in contrib/minizip/zip.c [Vollant]
-- Update make_vms.com [Zinser]
-- Remove unnecessary gzgetc_ function
-- Use optimized byte swap operations for Microsoft and GNU [Snyder]
-- Fix minor typo in zlib.h comments [Rzesniowiecki]
-
-Changes in 1.2.6 (29 Jan 2012)
-- Update the Pascal interface in contrib/pascal
-- Fix function numbers for gzgetc_ in zlibvc.def files
-- Fix configure.ac for contrib/minizip [Schiffer]
-- Fix large-entry detection in minizip on 64-bit systems [Schiffer]
-- Have ./configure use the compiler return code for error indication
-- Fix CMakeLists.txt for cross compilation [McClure]
-- Fix contrib/minizip/zip.c for 64-bit architectures [Dalsnes]
-- Fix compilation of contrib/minizip on FreeBSD [Marquez]
-- Correct suggested usages in win32/Makefile.msc [Shachar, Horvath]
-- Include io.h for Turbo C / Borland C on all platforms [Truta]
-- Make version explicit in contrib/minizip/configure.ac [Bosmans]
-- Avoid warning for no encryption in contrib/minizip/zip.c [Vollant]
-- Minor cleanup up contrib/minizip/unzip.c [Vollant]
-- Fix bug when compiling minizip with C++ [Vollant]
-- Protect for long name and extra fields in contrib/minizip [Vollant]
-- Avoid some warnings in contrib/minizip [Vollant]
-- Add -I../.. -L../.. to CFLAGS for minizip and miniunzip
-- Add missing libs to minizip linker command
-- Add support for VPATH builds in contrib/minizip
-- Add an --enable-demos option to contrib/minizip/configure
-- Add the generation of configure.log by ./configure
-- Exit when required parameters not provided to win32/Makefile.gcc
-- Have gzputc return the character written instead of the argument
-- Use the -m option on ldconfig for BSD systems [Tobias]
-- Correct in zlib.map when deflateResetKeep was added
-
-Changes in 1.2.5.3 (15 Jan 2012)
-- Restore gzgetc function for binary compatibility
-- Do not use _lseeki64 under Borland C++ [Truta]
-- Update win32/Makefile.msc to build test/*.c [Truta]
-- Remove old/visualc6 given CMakefile and other alternatives
-- Update AS400 build files and documentation [Monnerat]
-- Update win32/Makefile.gcc to build test/*.c [Truta]
-- Permit stronger flushes after Z_BLOCK flushes
-- Avoid extraneous empty blocks when doing empty flushes
-- Permit Z_NULL arguments to deflatePending
-- Allow deflatePrime() to insert bits in the middle of a stream
-- Remove second empty static block for Z_PARTIAL_FLUSH
-- Write out all of the available bits when using Z_BLOCK
-- Insert the first two strings in the hash table after a flush
-
-Changes in 1.2.5.2 (17 Dec 2011)
-- fix ld error: unable to find version dependency 'ZLIB_1.2.5'
-- use relative symlinks for shared libs
-- Avoid searching past window for Z_RLE strategy
-- Assure that high-water mark initialization is always applied in deflate
-- Add assertions to fill_window() in deflate.c to match comments
-- Update python link in README
-- Correct spelling error in gzread.c
-- Fix bug in gzgets() for a concatenated empty gzip stream
-- Correct error in comment for gz_make()
-- Change gzread() and related to ignore junk after gzip streams
-- Allow gzread() and related to continue after gzclearerr()
-- Allow gzrewind() and gzseek() after a premature end-of-file
-- Simplify gzseek() now that raw after gzip is ignored
-- Change gzgetc() to a macro for speed (~40% speedup in testing)
-- Fix gzclose() to return the actual error last encountered
-- Always add large file support for windows
-- Include zconf.h for windows large file support
-- Include zconf.h.cmakein for windows large file support
-- Update zconf.h.cmakein on make distclean
-- Merge vestigial vsnprintf determination from zutil.h to gzguts.h
-- Clarify how gzopen() appends in zlib.h comments
-- Correct documentation of gzdirect() since junk at end now ignored
-- Add a transparent write mode to gzopen() when 'T' is in the mode
-- Update python link in zlib man page
-- Get inffixed.h and MAKEFIXED result to match
-- Add a ./config --solo option to make zlib subset with no libary use
-- Add undocumented inflateResetKeep() function for CAB file decoding
-- Add --cover option to ./configure for gcc coverage testing
-- Add #define ZLIB_CONST option to use const in the z_stream interface
-- Add comment to gzdopen() in zlib.h to use dup() when using fileno()
-- Note behavior of uncompress() to provide as much data as it can
-- Add files in contrib/minizip to aid in building libminizip
-- Split off AR options in Makefile.in and configure
-- Change ON macro to Z_ARG to avoid application conflicts
-- Facilitate compilation with Borland C++ for pragmas and vsnprintf
-- Include io.h for Turbo C / Borland C++
-- Move example.c and minigzip.c to test/
-- Simplify incomplete code table filling in inflate_table()
-- Remove code from inflate.c and infback.c that is impossible to execute
-- Test the inflate code with full coverage
-- Allow deflateSetDictionary, inflateSetDictionary at any time (in raw)
-- Add deflateResetKeep and fix inflateResetKeep to retain dictionary
-- Fix gzwrite.c to accommodate reduced memory zlib compilation
-- Have inflate() with Z_FINISH avoid the allocation of a window
-- Do not set strm->adler when doing raw inflate
-- Fix gzeof() to behave just like feof() when read is not past end of file
-- Fix bug in gzread.c when end-of-file is reached
-- Avoid use of Z_BUF_ERROR in gz* functions except for premature EOF
-- Document gzread() capability to read concurrently written files
-- Remove hard-coding of resource compiler in CMakeLists.txt [Blammo]
-
-Changes in 1.2.5.1 (10 Sep 2011)
-- Update FAQ entry on shared builds (#13)
-- Avoid symbolic argument to chmod in Makefile.in
-- Fix bug and add consts in contrib/puff [Oberhumer]
-- Update contrib/puff/zeros.raw test file to have all block types
-- Add full coverage test for puff in contrib/puff/Makefile
-- Fix static-only-build install in Makefile.in
-- Fix bug in unzGetCurrentFileInfo() in contrib/minizip [Kuno]
-- Add libz.a dependency to shared in Makefile.in for parallel builds
-- Spell out "number" (instead of "nb") in zlib.h for total_in, total_out
-- Replace $(...) with `...` in configure for non-bash sh [Bowler]
-- Add darwin* to Darwin* and solaris* to SunOS\ 5* in configure [Groffen]
-- Add solaris* to Linux* in configure to allow gcc use [Groffen]
-- Add *bsd* to Linux* case in configure [Bar-Lev]
-- Add inffast.obj to dependencies in win32/Makefile.msc
-- Correct spelling error in deflate.h [Kohler]
-- Change libzdll.a again to libz.dll.a (!) in win32/Makefile.gcc
-- Add test to configure for GNU C looking for gcc in output of $cc -v
-- Add zlib.pc generation to win32/Makefile.gcc [Weigelt]
-- Fix bug in zlib.h for _FILE_OFFSET_BITS set and _LARGEFILE64_SOURCE not
-- Add comment in zlib.h that adler32_combine with len2 < 0 makes no sense
-- Make NO_DIVIDE option in adler32.c much faster (thanks to John Reiser)
-- Make stronger test in zconf.h to include unistd.h for LFS
-- Apply Darwin patches for 64-bit file offsets to contrib/minizip [Slack]
-- Fix zlib.h LFS support when Z_PREFIX used
-- Add updated as400 support (removed from old) [Monnerat]
-- Avoid deflate sensitivity to volatile input data
-- Avoid division in adler32_combine for NO_DIVIDE
-- Clarify the use of Z_FINISH with deflateBound() amount of space
-- Set binary for output file in puff.c
-- Use u4 type for crc_table to avoid conversion warnings
-- Apply casts in zlib.h to avoid conversion warnings
-- Add OF to prototypes for adler32_combine_ and crc32_combine_ [Miller]
-- Improve inflateSync() documentation to note indeterminancy
-- Add deflatePending() function to return the amount of pending output
-- Correct the spelling of "specification" in FAQ [Randers-Pehrson]
-- Add a check in configure for stdarg.h, use for gzprintf()
-- Check that pointers fit in ints when gzprint() compiled old style
-- Add dummy name before $(SHAREDLIBV) in Makefile [Bar-Lev, Bowler]
-- Delete line in configure that adds -L. libz.a to LDFLAGS [Weigelt]
-- Add debug records in assmebler code [Londer]
-- Update RFC references to use http://tools.ietf.org/html/... [Li]
-- Add --archs option, use of libtool to configure for Mac OS X [Borstel]
-
-Changes in 1.2.5 (19 Apr 2010)
-- Disable visibility attribute in win32/Makefile.gcc [Bar-Lev]
-- Default to libdir as sharedlibdir in configure [Nieder]
-- Update copyright dates on modified source files
-- Update trees.c to be able to generate modified trees.h
-- Exit configure for MinGW, suggesting win32/Makefile.gcc
-- Check for NULL path in gz_open [Homurlu]
-
-Changes in 1.2.4.5 (18 Apr 2010)
-- Set sharedlibdir in configure [Torok]
-- Set LDFLAGS in Makefile.in [Bar-Lev]
-- Avoid mkdir objs race condition in Makefile.in [Bowler]
-- Add ZLIB_INTERNAL in front of internal inter-module functions and arrays
-- Define ZLIB_INTERNAL to hide internal functions and arrays for GNU C
-- Don't use hidden attribute when it is a warning generator (e.g. Solaris)
-
-Changes in 1.2.4.4 (18 Apr 2010)
-- Fix CROSS_PREFIX executable testing, CHOST extract, mingw* [Torok]
-- Undefine _LARGEFILE64_SOURCE in zconf.h if it is zero, but not if empty
-- Try to use bash or ksh regardless of functionality of /bin/sh
-- Fix configure incompatibility with NetBSD sh
-- Remove attempt to run under bash or ksh since have better NetBSD fix
-- Fix win32/Makefile.gcc for MinGW [Bar-Lev]
-- Add diagnostic messages when using CROSS_PREFIX in configure
-- Added --sharedlibdir option to configure [Weigelt]
-- Use hidden visibility attribute when available [Frysinger]
-
-Changes in 1.2.4.3 (10 Apr 2010)
-- Only use CROSS_PREFIX in configure for ar and ranlib if they exist
-- Use CROSS_PREFIX for nm [Bar-Lev]
-- Assume _LARGEFILE64_SOURCE defined is equivalent to true
-- Avoid use of undefined symbols in #if with && and ||
-- Make *64 prototypes in gzguts.h consistent with functions
-- Add -shared load option for MinGW in configure [Bowler]
-- Move z_off64_t to public interface, use instead of off64_t
-- Remove ! from shell test in configure (not portable to Solaris)
-- Change +0 macro tests to -0 for possibly increased portability
-
-Changes in 1.2.4.2 (9 Apr 2010)
-- Add consistent carriage returns to readme.txt's in masmx86 and masmx64
-- Really provide prototypes for *64 functions when building without LFS
-- Only define unlink() in minigzip.c if unistd.h not included
-- Update README to point to contrib/vstudio project files
-- Move projects/vc6 to old/ and remove projects/
-- Include stdlib.h in minigzip.c for setmode() definition under WinCE
-- Clean up assembler builds in win32/Makefile.msc [Rowe]
-- Include sys/types.h for Microsoft for off_t definition
-- Fix memory leak on error in gz_open()
-- Symbolize nm as $NM in configure [Weigelt]
-- Use TEST_LDSHARED instead of LDSHARED to link test programs [Weigelt]
-- Add +0 to _FILE_OFFSET_BITS and _LFS64_LARGEFILE in case not defined
-- Fix bug in gzeof() to take into account unused input data
-- Avoid initialization of structures with variables in puff.c
-- Updated win32/README-WIN32.txt [Rowe]
-
-Changes in 1.2.4.1 (28 Mar 2010)
-- Remove the use of [a-z] constructs for sed in configure [gentoo 310225]
-- Remove $(SHAREDLIB) from LIBS in Makefile.in [Creech]
-- Restore "for debugging" comment on sprintf() in gzlib.c
-- Remove fdopen for MVS from gzguts.h
-- Put new README-WIN32.txt in win32 [Rowe]
-- Add check for shell to configure and invoke another shell if needed
-- Fix big fat stinking bug in gzseek() on uncompressed files
-- Remove vestigial F_OPEN64 define in zutil.h
-- Set and check the value of _LARGEFILE_SOURCE and _LARGEFILE64_SOURCE
-- Avoid errors on non-LFS systems when applications define LFS macros
-- Set EXE to ".exe" in configure for MINGW [Kahle]
-- Match crc32() in crc32.c exactly to the prototype in zlib.h [Sherrill]
-- Add prefix for cross-compilation in win32/makefile.gcc [Bar-Lev]
-- Add DLL install in win32/makefile.gcc [Bar-Lev]
-- Allow Linux* or linux* from uname in configure [Bar-Lev]
-- Allow ldconfig to be redefined in configure and Makefile.in [Bar-Lev]
-- Add cross-compilation prefixes to configure [Bar-Lev]
-- Match type exactly in gz_load() invocation in gzread.c
-- Match type exactly of zcalloc() in zutil.c to zlib.h alloc_func
-- Provide prototypes for *64 functions when building zlib without LFS
-- Don't use -lc when linking shared library on MinGW
-- Remove errno.h check in configure and vestigial errno code in zutil.h
-
-Changes in 1.2.4 (14 Mar 2010)
-- Fix VER3 extraction in configure for no fourth subversion
-- Update zlib.3, add docs to Makefile.in to make .pdf out of it
-- Add zlib.3.pdf to distribution
-- Don't set error code in gzerror() if passed pointer is NULL
-- Apply destination directory fixes to CMakeLists.txt [Lowman]
-- Move #cmakedefine's to a new zconf.in.cmakein
-- Restore zconf.h for builds that don't use configure or cmake
-- Add distclean to dummy Makefile for convenience
-- Update and improve INDEX, README, and FAQ
-- Update CMakeLists.txt for the return of zconf.h [Lowman]
-- Update contrib/vstudio/vc9 and vc10 [Vollant]
-- Change libz.dll.a back to libzdll.a in win32/Makefile.gcc
-- Apply license and readme changes to contrib/asm686 [Raiter]
-- Check file name lengths and add -c option in minigzip.c [Li]
-- Update contrib/amd64 and contrib/masmx86/ [Vollant]
-- Avoid use of "eof" parameter in trees.c to not shadow library variable
-- Update make_vms.com for removal of zlibdefs.h [Zinser]
-- Update assembler code and vstudio projects in contrib [Vollant]
-- Remove outdated assembler code contrib/masm686 and contrib/asm586
-- Remove old vc7 and vc8 from contrib/vstudio
-- Update win32/Makefile.msc, add ZLIB_VER_SUBREVISION [Rowe]
-- Fix memory leaks in gzclose_r() and gzclose_w(), file leak in gz_open()
-- Add contrib/gcc_gvmat64 for longest_match and inflate_fast [Vollant]
-- Remove *64 functions from win32/zlib.def (they're not 64-bit yet)
-- Fix bug in void-returning vsprintf() case in gzwrite.c
-- Fix name change from inflate.h in contrib/inflate86/inffas86.c
-- Check if temporary file exists before removing in make_vms.com [Zinser]
-- Fix make install and uninstall for --static option
-- Fix usage of _MSC_VER in gzguts.h and zutil.h [Truta]
-- Update readme.txt in contrib/masmx64 and masmx86 to assemble
-
-Changes in 1.2.3.9 (21 Feb 2010)
-- Expunge gzio.c
-- Move as400 build information to old
-- Fix updates in contrib/minizip and contrib/vstudio
-- Add const to vsnprintf test in configure to avoid warnings [Weigelt]
-- Delete zconf.h (made by configure) [Weigelt]
-- Change zconf.in.h to zconf.h.in per convention [Weigelt]
-- Check for NULL buf in gzgets()
-- Return empty string for gzgets() with len == 1 (like fgets())
-- Fix description of gzgets() in zlib.h for end-of-file, NULL return
-- Update minizip to 1.1 [Vollant]
-- Avoid MSVC loss of data warnings in gzread.c, gzwrite.c
-- Note in zlib.h that gzerror() should be used to distinguish from EOF
-- Remove use of snprintf() from gzlib.c
-- Fix bug in gzseek()
-- Update contrib/vstudio, adding vc9 and vc10 [Kuno, Vollant]
-- Fix zconf.h generation in CMakeLists.txt [Lowman]
-- Improve comments in zconf.h where modified by configure
-
-Changes in 1.2.3.8 (13 Feb 2010)
-- Clean up text files (tabs, trailing whitespace, etc.) [Oberhumer]
-- Use z_off64_t in gz_zero() and gz_skip() to match state->skip
-- Avoid comparison problem when sizeof(int) == sizeof(z_off64_t)
-- Revert to Makefile.in from 1.2.3.6 (live with the clutter)
-- Fix missing error return in gzflush(), add zlib.h note
-- Add *64 functions to zlib.map [Levin]
-- Fix signed/unsigned comparison in gz_comp()
-- Use SFLAGS when testing shared linking in configure
-- Add --64 option to ./configure to use -m64 with gcc
-- Fix ./configure --help to correctly name options
-- Have make fail if a test fails [Levin]
-- Avoid buffer overrun in contrib/masmx64/gvmat64.asm [Simpson]
-- Remove assembler object files from contrib
-
-Changes in 1.2.3.7 (24 Jan 2010)
-- Always gzopen() with O_LARGEFILE if available
-- Fix gzdirect() to work immediately after gzopen() or gzdopen()
-- Make gzdirect() more precise when the state changes while reading
-- Improve zlib.h documentation in many places
-- Catch memory allocation failure in gz_open()
-- Complete close operation if seek forward in gzclose_w() fails
-- Return Z_ERRNO from gzclose_r() if close() fails
-- Return Z_STREAM_ERROR instead of EOF for gzclose() being passed NULL
-- Return zero for gzwrite() errors to match zlib.h description
-- Return -1 on gzputs() error to match zlib.h description
-- Add zconf.in.h to allow recovery from configure modification [Weigelt]
-- Fix static library permissions in Makefile.in [Weigelt]
-- Avoid warnings in configure tests that hide functionality [Weigelt]
-- Add *BSD and DragonFly to Linux case in configure [gentoo 123571]
-- Change libzdll.a to libz.dll.a in win32/Makefile.gcc [gentoo 288212]
-- Avoid access of uninitialized data for first inflateReset2 call [Gomes]
-- Keep object files in subdirectories to reduce the clutter somewhat
-- Remove default Makefile and zlibdefs.h, add dummy Makefile
-- Add new external functions to Z_PREFIX, remove duplicates, z_z_ -> z_
-- Remove zlibdefs.h completely -- modify zconf.h instead
-
-Changes in 1.2.3.6 (17 Jan 2010)
-- Avoid void * arithmetic in gzread.c and gzwrite.c
-- Make compilers happier with const char * for gz_error message
-- Avoid unused parameter warning in inflate.c
-- Avoid signed-unsigned comparison warning in inflate.c
-- Indent #pragma's for traditional C
-- Fix usage of strwinerror() in glib.c, change to gz_strwinerror()
-- Correct email address in configure for system options
-- Update make_vms.com and add make_vms.com to contrib/minizip [Zinser]
-- Update zlib.map [Brown]
-- Fix Makefile.in for Solaris 10 make of example64 and minizip64 [Torok]
-- Apply various fixes to CMakeLists.txt [Lowman]
-- Add checks on len in gzread() and gzwrite()
-- Add error message for no more room for gzungetc()
-- Remove zlib version check in gzwrite()
-- Defer compression of gzprintf() result until need to
-- Use snprintf() in gzdopen() if available
-- Remove USE_MMAP configuration determination (only used by minigzip)
-- Remove examples/pigz.c (available separately)
-- Update examples/gun.c to 1.6
-
-Changes in 1.2.3.5 (8 Jan 2010)
-- Add space after #if in zutil.h for some compilers
-- Fix relatively harmless bug in deflate_fast() [Exarevsky]
-- Fix same problem in deflate_slow()
-- Add $(SHAREDLIBV) to LIBS in Makefile.in [Brown]
-- Add deflate_rle() for faster Z_RLE strategy run-length encoding
-- Add deflate_huff() for faster Z_HUFFMAN_ONLY encoding
-- Change name of "write" variable in inffast.c to avoid library collisions
-- Fix premature EOF from gzread() in gzio.c [Brown]
-- Use zlib header window size if windowBits is 0 in inflateInit2()
-- Remove compressBound() call in deflate.c to avoid linking compress.o
-- Replace use of errno in gz* with functions, support WinCE [Alves]
-- Provide alternative to perror() in minigzip.c for WinCE [Alves]
-- Don't use _vsnprintf on later versions of MSVC [Lowman]
-- Add CMake build script and input file [Lowman]
-- Update contrib/minizip to 1.1 [Svensson, Vollant]
-- Moved nintendods directory from contrib to .
-- Replace gzio.c with a new set of routines with the same functionality
-- Add gzbuffer(), gzoffset(), gzclose_r(), gzclose_w() as part of above
-- Update contrib/minizip to 1.1b
-- Change gzeof() to return 0 on error instead of -1 to agree with zlib.h
-
-Changes in 1.2.3.4 (21 Dec 2009)
-- Use old school .SUFFIXES in Makefile.in for FreeBSD compatibility
-- Update comments in configure and Makefile.in for default --shared
-- Fix test -z's in configure [Marquess]
-- Build examplesh and minigzipsh when not testing
-- Change NULL's to Z_NULL's in deflate.c and in comments in zlib.h
-- Import LDFLAGS from the environment in configure
-- Fix configure to populate SFLAGS with discovered CFLAGS options
-- Adapt make_vms.com to the new Makefile.in [Zinser]
-- Add zlib2ansi script for C++ compilation [Marquess]
-- Add _FILE_OFFSET_BITS=64 test to make test (when applicable)
-- Add AMD64 assembler code for longest match to contrib [Teterin]
-- Include options from $SFLAGS when doing $LDSHARED
-- Simplify 64-bit file support by introducing z_off64_t type
-- Make shared object files in objs directory to work around old Sun cc
-- Use only three-part version number for Darwin shared compiles
-- Add rc option to ar in Makefile.in for when ./configure not run
-- Add -WI,-rpath,. to LDFLAGS for OSF 1 V4*
-- Set LD_LIBRARYN32_PATH for SGI IRIX shared compile
-- Protect against _FILE_OFFSET_BITS being defined when compiling zlib
-- Rename Makefile.in targets allstatic to static and allshared to shared
-- Fix static and shared Makefile.in targets to be independent
-- Correct error return bug in gz_open() by setting state [Brown]
-- Put spaces before ;;'s in configure for better sh compatibility
-- Add pigz.c (parallel implementation of gzip) to examples/
-- Correct constant in crc32.c to UL [Leventhal]
-- Reject negative lengths in crc32_combine()
-- Add inflateReset2() function to work like inflateEnd()/inflateInit2()
-- Include sys/types.h for _LARGEFILE64_SOURCE [Brown]
-- Correct typo in doc/algorithm.txt [Janik]
-- Fix bug in adler32_combine() [Zhu]
-- Catch missing-end-of-block-code error in all inflates and in puff
-    Assures that random input to inflate eventually results in an error
-- Added enough.c (calculation of ENOUGH for inftrees.h) to examples/
-- Update ENOUGH and its usage to reflect discovered bounds
-- Fix gzerror() error report on empty input file [Brown]
-- Add ush casts in trees.c to avoid pedantic runtime errors
-- Fix typo in zlib.h uncompress() description [Reiss]
-- Correct inflate() comments with regard to automatic header detection
-- Remove deprecation comment on Z_PARTIAL_FLUSH (it stays)
-- Put new version of gzlog (2.0) in examples with interruption recovery
-- Add puff compile option to permit invalid distance-too-far streams
-- Add puff TEST command options, ability to read piped input
-- Prototype the *64 functions in zlib.h when _FILE_OFFSET_BITS == 64, but
-  _LARGEFILE64_SOURCE not defined
-- Fix Z_FULL_FLUSH to truly erase the past by resetting s->strstart
-- Fix deflateSetDictionary() to use all 32K for output consistency
-- Remove extraneous #define MIN_LOOKAHEAD in deflate.c (in deflate.h)
-- Clear bytes after deflate lookahead to avoid use of uninitialized data
-- Change a limit in inftrees.c to be more transparent to Coverity Prevent
-- Update win32/zlib.def with exported symbols from zlib.h
-- Correct spelling errors in zlib.h [Willem, Sobrado]
-- Allow Z_BLOCK for deflate() to force a new block
-- Allow negative bits in inflatePrime() to delete existing bit buffer
-- Add Z_TREES flush option to inflate() to return at end of trees
-- Add inflateMark() to return current state information for random access
-- Add Makefile for NintendoDS to contrib [Costa]
-- Add -w in configure compile tests to avoid spurious warnings [Beucler]
-- Fix typos in zlib.h comments for deflateSetDictionary()
-- Fix EOF detection in transparent gzread() [Maier]
-
-Changes in 1.2.3.3 (2 October 2006)
-- Make --shared the default for configure, add a --static option
-- Add compile option to permit invalid distance-too-far streams
-- Add inflateUndermine() function which is required to enable above
-- Remove use of "this" variable name for C++ compatibility [Marquess]
-- Add testing of shared library in make test, if shared library built
-- Use ftello() and fseeko() if available instead of ftell() and fseek()
-- Provide two versions of all functions that use the z_off_t type for
-  binary compatibility -- a normal version and a 64-bit offset version,
-  per the Large File Support Extension when _LARGEFILE64_SOURCE is
-  defined; use the 64-bit versions by default when _FILE_OFFSET_BITS
-  is defined to be 64
-- Add a --uname= option to configure to perhaps help with cross-compiling
-
-Changes in 1.2.3.2 (3 September 2006)
-- Turn off silly Borland warnings [Hay]
-- Use off64_t and define _LARGEFILE64_SOURCE when present
-- Fix missing dependency on inffixed.h in Makefile.in
-- Rig configure --shared to build both shared and static [Teredesai, Truta]
-- Remove zconf.in.h and instead create a new zlibdefs.h file
-- Fix contrib/minizip/unzip.c non-encrypted after encrypted [Vollant]
-- Add treebuild.xml (see http://treebuild.metux.de/) [Weigelt]
-
-Changes in 1.2.3.1 (16 August 2006)
-- Add watcom directory with OpenWatcom make files [Daniel]
-- Remove #undef of FAR in zconf.in.h for MVS [Fedtke]
-- Update make_vms.com [Zinser]
-- Use -fPIC for shared build in configure [Teredesai, Nicholson]
-- Use only major version number for libz.so on IRIX and OSF1 [Reinholdtsen]
-- Use fdopen() (not _fdopen()) for Interix in zutil.h [Bck]
-- Add some FAQ entries about the contrib directory
-- Update the MVS question in the FAQ
-- Avoid extraneous reads after EOF in gzio.c [Brown]
-- Correct spelling of "successfully" in gzio.c [Randers-Pehrson]
-- Add comments to zlib.h about gzerror() usage [Brown]
-- Set extra flags in gzip header in gzopen() like deflate() does
-- Make configure options more compatible with double-dash conventions
-  [Weigelt]
-- Clean up compilation under Solaris SunStudio cc [Rowe, Reinholdtsen]
-- Fix uninstall target in Makefile.in [Truta]
-- Add pkgconfig support [Weigelt]
-- Use $(DESTDIR) macro in Makefile.in [Reinholdtsen, Weigelt]
-- Replace set_data_type() with a more accurate detect_data_type() in
-  trees.c, according to the txtvsbin.txt document [Truta]
-- Swap the order of #include <stdio.h> and #include "zlib.h" in
-  gzio.c, example.c and minigzip.c [Truta]
-- Shut up annoying VS2005 warnings about standard C deprecation [Rowe,
-  Truta] (where?)
-- Fix target "clean" from win32/Makefile.bor [Truta]
-- Create .pdb and .manifest files in win32/makefile.msc [Ziegler, Rowe]
-- Update zlib www home address in win32/DLL_FAQ.txt [Truta]
-- Update contrib/masmx86/inffas32.asm for VS2005 [Vollant, Van Wassenhove]
-- Enable browse info in the "Debug" and "ASM Debug" configurations in
-  the Visual C++ 6 project, and set (non-ASM) "Debug" as default [Truta]
-- Add pkgconfig support [Weigelt]
-- Add ZLIB_VER_MAJOR, ZLIB_VER_MINOR and ZLIB_VER_REVISION in zlib.h,
-  for use in win32/zlib1.rc [Polushin, Rowe, Truta]
-- Add a document that explains the new text detection scheme to
-  doc/txtvsbin.txt [Truta]
-- Add rfc1950.txt, rfc1951.txt and rfc1952.txt to doc/ [Truta]
-- Move algorithm.txt into doc/ [Truta]
-- Synchronize FAQ with website
-- Fix compressBound(), was low for some pathological cases [Fearnley]
-- Take into account wrapper variations in deflateBound()
-- Set examples/zpipe.c input and output to binary mode for Windows
-- Update examples/zlib_how.html with new zpipe.c (also web site)
-- Fix some warnings in examples/gzlog.c and examples/zran.c (it seems
-  that gcc became pickier in 4.0)
-- Add zlib.map for Linux: "All symbols from zlib-1.1.4 remain
-  un-versioned, the patch adds versioning only for symbols introduced in
-  zlib-1.2.0 or later.  It also declares as local those symbols which are
-  not designed to be exported." [Levin]
-- Update Z_PREFIX list in zconf.in.h, add --zprefix option to configure
-- Do not initialize global static by default in trees.c, add a response
-  NO_INIT_GLOBAL_POINTERS to initialize them if needed [Marquess]
-- Don't use strerror() in gzio.c under WinCE [Yakimov]
-- Don't use errno.h in zutil.h under WinCE [Yakimov]
-- Move arguments for AR to its usage to allow replacing ar [Marot]
-- Add HAVE_VISIBILITY_PRAGMA in zconf.in.h for Mozilla [Randers-Pehrson]
-- Improve inflateInit() and inflateInit2() documentation
-- Fix structure size comment in inflate.h
-- Change configure help option from --h* to --help [Santos]
-
-Changes in 1.2.3 (18 July 2005)
-- Apply security vulnerability fixes to contrib/infback9 as well
-- Clean up some text files (carriage returns, trailing space)
-- Update testzlib, vstudio, masmx64, and masmx86 in contrib [Vollant]
-
-Changes in 1.2.2.4 (11 July 2005)
-- Add inflatePrime() function for starting inflation at bit boundary
-- Avoid some Visual C warnings in deflate.c
-- Avoid more silly Visual C warnings in inflate.c and inftrees.c for 64-bit
-  compile
-- Fix some spelling errors in comments [Betts]
-- Correct inflateInit2() error return documentation in zlib.h
-- Add zran.c example of compressed data random access to examples
-  directory, shows use of inflatePrime()
-- Fix cast for assignments to strm->state in inflate.c and infback.c
-- Fix zlibCompileFlags() in zutil.c to use 1L for long shifts [Oberhumer]
-- Move declarations of gf2 functions to right place in crc32.c [Oberhumer]
-- Add cast in trees.c t avoid a warning [Oberhumer]
-- Avoid some warnings in fitblk.c, gun.c, gzjoin.c in examples [Oberhumer]
-- Update make_vms.com [Zinser]
-- Initialize state->write in inflateReset() since copied in inflate_fast()
-- Be more strict on incomplete code sets in inflate_table() and increase
-  ENOUGH and MAXD -- this repairs a possible security vulnerability for
-  invalid inflate input.  Thanks to Tavis Ormandy and Markus Oberhumer for
-  discovering the vulnerability and providing test cases.
-- Add ia64 support to configure for HP-UX [Smith]
-- Add error return to gzread() for format or i/o error [Levin]
-- Use malloc.h for OS/2 [Necasek]
-
-Changes in 1.2.2.3 (27 May 2005)
-- Replace 1U constants in inflate.c and inftrees.c for 64-bit compile
-- Typecast fread() return values in gzio.c [Vollant]
-- Remove trailing space in minigzip.c outmode (VC++ can't deal with it)
-- Fix crc check bug in gzread() after gzungetc() [Heiner]
-- Add the deflateTune() function to adjust internal compression parameters
-- Add a fast gzip decompressor, gun.c, to examples (use of inflateBack)
-- Remove an incorrect assertion in examples/zpipe.c
-- Add C++ wrapper in infback9.h [Donais]
-- Fix bug in inflateCopy() when decoding fixed codes
-- Note in zlib.h how much deflateSetDictionary() actually uses
-- Remove USE_DICT_HEAD in deflate.c (would mess up inflate if used)
-- Add _WIN32_WCE to define WIN32 in zconf.in.h [Spencer]
-- Don't include stderr.h or errno.h for _WIN32_WCE in zutil.h [Spencer]
-- Add gzdirect() function to indicate transparent reads
-- Update contrib/minizip [Vollant]
-- Fix compilation of deflate.c when both ASMV and FASTEST [Oberhumer]
-- Add casts in crc32.c to avoid warnings [Oberhumer]
-- Add contrib/masmx64 [Vollant]
-- Update contrib/asm586, asm686, masmx86, testzlib, vstudio [Vollant]
-
-Changes in 1.2.2.2 (30 December 2004)
-- Replace structure assignments in deflate.c and inflate.c with zmemcpy to
-  avoid implicit memcpy calls (portability for no-library compilation)
-- Increase sprintf() buffer size in gzdopen() to allow for large numbers
-- Add INFLATE_STRICT to check distances against zlib header
-- Improve WinCE errno handling and comments [Chang]
-- Remove comment about no gzip header processing in FAQ
-- Add Z_FIXED strategy option to deflateInit2() to force fixed trees
-- Add updated make_vms.com [Coghlan], update README
-- Create a new "examples" directory, move gzappend.c there, add zpipe.c,
-  fitblk.c, gzlog.[ch], gzjoin.c, and zlib_how.html.
-- Add FAQ entry and comments in deflate.c on uninitialized memory access
-- Add Solaris 9 make options in configure [Gilbert]
-- Allow strerror() usage in gzio.c for STDC
-- Fix DecompressBuf in contrib/delphi/ZLib.pas [ManChesTer]
-- Update contrib/masmx86/inffas32.asm and gvmat32.asm [Vollant]
-- Use z_off_t for adler32_combine() and crc32_combine() lengths
-- Make adler32() much faster for small len
-- Use OS_CODE in deflate() default gzip header
-
-Changes in 1.2.2.1 (31 October 2004)
-- Allow inflateSetDictionary() call for raw inflate
-- Fix inflate header crc check bug for file names and comments
-- Add deflateSetHeader() and gz_header structure for custom gzip headers
-- Add inflateGetheader() to retrieve gzip headers
-- Add crc32_combine() and adler32_combine() functions
-- Add alloc_func, free_func, in_func, out_func to Z_PREFIX list
-- Use zstreamp consistently in zlib.h (inflate_back functions)
-- Remove GUNZIP condition from definition of inflate_mode in inflate.h
-  and in contrib/inflate86/inffast.S [Truta, Anderson]
-- Add support for AMD64 in contrib/inflate86/inffas86.c [Anderson]
-- Update projects/README.projects and projects/visualc6 [Truta]
-- Update win32/DLL_FAQ.txt [Truta]
-- Avoid warning under NO_GZCOMPRESS in gzio.c; fix typo [Truta]
-- Deprecate Z_ASCII; use Z_TEXT instead [Truta]
-- Use a new algorithm for setting strm->data_type in trees.c [Truta]
-- Do not define an exit() prototype in zutil.c unless DEBUG defined
-- Remove prototype of exit() from zutil.c, example.c, minigzip.c [Truta]
-- Add comment in zlib.h for Z_NO_FLUSH parameter to deflate()
-- Fix Darwin build version identification [Peterson]
-
-Changes in 1.2.2 (3 October 2004)
-- Update zlib.h comments on gzip in-memory processing
-- Set adler to 1 in inflateReset() to support Java test suite [Walles]
-- Add contrib/dotzlib [Ravn]
-- Update win32/DLL_FAQ.txt [Truta]
-- Update contrib/minizip [Vollant]
-- Move contrib/visual-basic.txt to old/ [Truta]
-- Fix assembler builds in projects/visualc6/ [Truta]
-
-Changes in 1.2.1.2 (9 September 2004)
-- Update INDEX file
-- Fix trees.c to update strm->data_type (no one ever noticed!)
-- Fix bug in error case in inflate.c, infback.c, and infback9.c [Brown]
-- Add "volatile" to crc table flag declaration (for DYNAMIC_CRC_TABLE)
-- Add limited multitasking protection to DYNAMIC_CRC_TABLE
-- Add NO_vsnprintf for VMS in zutil.h [Mozilla]
-- Don't declare strerror() under VMS [Mozilla]
-- Add comment to DYNAMIC_CRC_TABLE to use get_crc_table() to initialize
-- Update contrib/ada [Anisimkov]
-- Update contrib/minizip [Vollant]
-- Fix configure to not hardcode directories for Darwin [Peterson]
-- Fix gzio.c to not return error on empty files [Brown]
-- Fix indentation; update version in contrib/delphi/ZLib.pas and
-  contrib/pascal/zlibpas.pas [Truta]
-- Update mkasm.bat in contrib/masmx86 [Truta]
-- Update contrib/untgz [Truta]
-- Add projects/README.projects [Truta]
-- Add project for MS Visual C++ 6.0 in projects/visualc6 [Cadieux, Truta]
-- Update win32/DLL_FAQ.txt [Truta]
-- Update list of Z_PREFIX symbols in zconf.h [Randers-Pehrson, Truta]
-- Remove an unnecessary assignment to curr in inftrees.c [Truta]
-- Add OS/2 to exe builds in configure [Poltorak]
-- Remove err dummy parameter in zlib.h [Kientzle]
-
-Changes in 1.2.1.1 (9 January 2004)
-- Update email address in README
-- Several FAQ updates
-- Fix a big fat bug in inftrees.c that prevented decoding valid
-  dynamic blocks with only literals and no distance codes --
-  Thanks to "Hot Emu" for the bug report and sample file
-- Add a note to puff.c on no distance codes case.
-
-Changes in 1.2.1 (17 November 2003)
-- Remove a tab in contrib/gzappend/gzappend.c
-- Update some interfaces in contrib for new zlib functions
-- Update zlib version number in some contrib entries
-- Add Windows CE definition for ptrdiff_t in zutil.h [Mai, Truta]
-- Support shared libraries on Hurd and KFreeBSD [Brown]
-- Fix error in NO_DIVIDE option of adler32.c
-
-Changes in 1.2.0.8 (4 November 2003)
-- Update version in contrib/delphi/ZLib.pas and contrib/pascal/zlibpas.pas
-- Add experimental NO_DIVIDE #define in adler32.c
-    - Possibly faster on some processors (let me know if it is)
-- Correct Z_BLOCK to not return on first inflate call if no wrap
-- Fix strm->data_type on inflate() return to correctly indicate EOB
-- Add deflatePrime() function for appending in the middle of a byte
-- Add contrib/gzappend for an example of appending to a stream
-- Update win32/DLL_FAQ.txt [Truta]
-- Delete Turbo C comment in README [Truta]
-- Improve some indentation in zconf.h [Truta]
-- Fix infinite loop on bad input in configure script [Church]
-- Fix gzeof() for concatenated gzip files [Johnson]
-- Add example to contrib/visual-basic.txt [Michael B.]
-- Add -p to mkdir's in Makefile.in [vda]
-- Fix configure to properly detect presence or lack of printf functions
-- Add AS400 support [Monnerat]
-- Add a little Cygwin support [Wilson]
-
-Changes in 1.2.0.7 (21 September 2003)
-- Correct some debug formats in contrib/infback9
-- Cast a type in a debug statement in trees.c
-- Change search and replace delimiter in configure from % to # [Beebe]
-- Update contrib/untgz to 0.2 with various fixes [Truta]
-- Add build support for Amiga [Nikl]
-- Remove some directories in old that have been updated to 1.2
-- Add dylib building for Mac OS X in configure and Makefile.in
-- Remove old distribution stuff from Makefile
-- Update README to point to DLL_FAQ.txt, and add comment on Mac OS X
-- Update links in README
-
-Changes in 1.2.0.6 (13 September 2003)
-- Minor FAQ updates
-- Update contrib/minizip to 1.00 [Vollant]
-- Remove test of gz functions in example.c when GZ_COMPRESS defined [Truta]
-- Update POSTINC comment for 68060 [Nikl]
-- Add contrib/infback9 with deflate64 decoding (unsupported)
-- For MVS define NO_vsnprintf and undefine FAR [van Burik]
-- Add pragma for fdopen on MVS [van Burik]
-
-Changes in 1.2.0.5 (8 September 2003)
-- Add OF to inflateBackEnd() declaration in zlib.h
-- Remember start when using gzdopen in the middle of a file
-- Use internal off_t counters in gz* functions to properly handle seeks
-- Perform more rigorous check for distance-too-far in inffast.c
-- Add Z_BLOCK flush option to return from inflate at block boundary
-- Set strm->data_type on return from inflate
-    - Indicate bits unused, if at block boundary, and if in last block
-- Replace size_t with ptrdiff_t in crc32.c, and check for correct size
-- Add condition so old NO_DEFLATE define still works for compatibility
-- FAQ update regarding the Windows DLL [Truta]
-- INDEX update: add qnx entry, remove aix entry [Truta]
-- Install zlib.3 into mandir [Wilson]
-- Move contrib/zlib_dll_FAQ.txt to win32/DLL_FAQ.txt; update [Truta]
-- Adapt the zlib interface to the new DLL convention guidelines [Truta]
-- Introduce ZLIB_WINAPI macro to allow the export of functions using
-  the WINAPI calling convention, for Visual Basic [Vollant, Truta]
-- Update msdos and win32 scripts and makefiles [Truta]
-- Export symbols by name, not by ordinal, in win32/zlib.def [Truta]
-- Add contrib/ada [Anisimkov]
-- Move asm files from contrib/vstudio/vc70_32 to contrib/asm386 [Truta]
-- Rename contrib/asm386 to contrib/masmx86 [Truta, Vollant]
-- Add contrib/masm686 [Truta]
-- Fix offsets in contrib/inflate86 and contrib/masmx86/inffas32.asm
-  [Truta, Vollant]
-- Update contrib/delphi; rename to contrib/pascal; add example [Truta]
-- Remove contrib/delphi2; add a new contrib/delphi [Truta]
-- Avoid inclusion of the nonstandard <memory.h> in contrib/iostream,
-  and fix some method prototypes [Truta]
-- Fix the ZCR_SEED2 constant to avoid warnings in contrib/minizip
-  [Truta]
-- Avoid the use of backslash (\) in contrib/minizip [Vollant]
-- Fix file time handling in contrib/untgz; update makefiles [Truta]
-- Update contrib/vstudio/vc70_32 to comply with the new DLL guidelines
-  [Vollant]
-- Remove contrib/vstudio/vc15_16 [Vollant]
-- Rename contrib/vstudio/vc70_32 to contrib/vstudio/vc7 [Truta]
-- Update README.contrib [Truta]
-- Invert the assignment order of match_head and s->prev[...] in
-  INSERT_STRING [Truta]
-- Compare TOO_FAR with 32767 instead of 32768, to avoid 16-bit warnings
-  [Truta]
-- Compare function pointers with 0, not with NULL or Z_NULL [Truta]
-- Fix prototype of syncsearch in inflate.c [Truta]
-- Introduce ASMINF macro to be enabled when using an ASM implementation
-  of inflate_fast [Truta]
-- Change NO_DEFLATE to NO_GZCOMPRESS [Truta]
-- Modify test_gzio in example.c to take a single file name as a
-  parameter [Truta]
-- Exit the example.c program if gzopen fails [Truta]
-- Add type casts around strlen in example.c [Truta]
-- Remove casting to sizeof in minigzip.c; give a proper type
-  to the variable compared with SUFFIX_LEN [Truta]
-- Update definitions of STDC and STDC99 in zconf.h [Truta]
-- Synchronize zconf.h with the new Windows DLL interface [Truta]
-- Use SYS16BIT instead of __32BIT__ to distinguish between
-  16- and 32-bit platforms [Truta]
-- Use far memory allocators in small 16-bit memory models for
-  Turbo C [Truta]
-- Add info about the use of ASMV, ASMINF and ZLIB_WINAPI in
-  zlibCompileFlags [Truta]
-- Cygwin has vsnprintf [Wilson]
-- In Windows16, OS_CODE is 0, as in MSDOS [Truta]
-- In Cygwin, OS_CODE is 3 (Unix), not 11 (Windows32) [Wilson]
-
-Changes in 1.2.0.4 (10 August 2003)
-- Minor FAQ updates
-- Be more strict when checking inflateInit2's windowBits parameter
-- Change NO_GUNZIP compile option to NO_GZIP to cover deflate as well
-- Add gzip wrapper option to deflateInit2 using windowBits
-- Add updated QNX rule in configure and qnx directory [Bonnefoy]
-- Make inflate distance-too-far checks more rigorous
-- Clean up FAR usage in inflate
-- Add casting to sizeof() in gzio.c and minigzip.c
-
-Changes in 1.2.0.3 (19 July 2003)
-- Fix silly error in gzungetc() implementation [Vollant]
-- Update contrib/minizip and contrib/vstudio [Vollant]
-- Fix printf format in example.c
-- Correct cdecl support in zconf.in.h [Anisimkov]
-- Minor FAQ updates
-
-Changes in 1.2.0.2 (13 July 2003)
-- Add ZLIB_VERNUM in zlib.h for numerical preprocessor comparisons
-- Attempt to avoid warnings in crc32.c for pointer-int conversion
-- Add AIX to configure, remove aix directory [Bakker]
-- Add some casts to minigzip.c
-- Improve checking after insecure sprintf() or vsprintf() calls
-- Remove #elif's from crc32.c
-- Change leave label to inf_leave in inflate.c and infback.c to avoid
-  library conflicts
-- Remove inflate gzip decoding by default--only enable gzip decoding by
-  special request for stricter backward compatibility
-- Add zlibCompileFlags() function to return compilation information
-- More typecasting in deflate.c to avoid warnings
-- Remove leading underscore from _Capital #defines [Truta]
-- Fix configure to link shared library when testing
-- Add some Windows CE target adjustments [Mai]
-- Remove #define ZLIB_DLL in zconf.h [Vollant]
-- Add zlib.3 [Rodgers]
-- Update RFC URL in deflate.c and algorithm.txt [Mai]
-- Add zlib_dll_FAQ.txt to contrib [Truta]
-- Add UL to some constants [Truta]
-- Update minizip and vstudio [Vollant]
-- Remove vestigial NEED_DUMMY_RETURN from zconf.in.h
-- Expand use of NO_DUMMY_DECL to avoid all dummy structures
-- Added iostream3 to contrib [Schwardt]
-- Replace rewind() with fseek() for WinCE [Truta]
-- Improve setting of zlib format compression level flags
-    - Report 0 for huffman and rle strategies and for level == 0 or 1
-    - Report 2 only for level == 6
-- Only deal with 64K limit when necessary at compile time [Truta]
-- Allow TOO_FAR check to be turned off at compile time [Truta]
-- Add gzclearerr() function [Souza]
-- Add gzungetc() function
-
-Changes in 1.2.0.1 (17 March 2003)
-- Add Z_RLE strategy for run-length encoding [Truta]
-    - When Z_RLE requested, restrict matches to distance one
-    - Update zlib.h, minigzip.c, gzopen(), gzdopen() for Z_RLE
-- Correct FASTEST compilation to allow level == 0
-- Clean up what gets compiled for FASTEST
-- Incorporate changes to zconf.in.h [Vollant]
-    - Refine detection of Turbo C need for dummy returns
-    - Refine ZLIB_DLL compilation
-    - Include additional header file on VMS for off_t typedef
-- Try to use _vsnprintf where it supplants vsprintf [Vollant]
-- Add some casts in inffast.c
-- Enchance comments in zlib.h on what happens if gzprintf() tries to
-  write more than 4095 bytes before compression
-- Remove unused state from inflateBackEnd()
-- Remove exit(0) from minigzip.c, example.c
-- Get rid of all those darn tabs
-- Add "check" target to Makefile.in that does the same thing as "test"
-- Add "mostlyclean" and "maintainer-clean" targets to Makefile.in
-- Update contrib/inflate86 [Anderson]
-- Update contrib/testzlib, contrib/vstudio, contrib/minizip [Vollant]
-- Add msdos and win32 directories with makefiles [Truta]
-- More additions and improvements to the FAQ
-
-Changes in 1.2.0 (9 March 2003)
-- New and improved inflate code
-    - About 20% faster
-    - Does not allocate 32K window unless and until needed
-    - Automatically detects and decompresses gzip streams
-    - Raw inflate no longer needs an extra dummy byte at end
-    - Added inflateBack functions using a callback interface--even faster
-      than inflate, useful for file utilities (gzip, zip)
-    - Added inflateCopy() function to record state for random access on
-      externally generated deflate streams (e.g. in gzip files)
-    - More readable code (I hope)
-- New and improved crc32()
-    - About 50% faster, thanks to suggestions from Rodney Brown
-- Add deflateBound() and compressBound() functions
-- Fix memory leak in deflateInit2()
-- Permit setting dictionary for raw deflate (for parallel deflate)
-- Fix const declaration for gzwrite()
-- Check for some malloc() failures in gzio.c
-- Fix bug in gzopen() on single-byte file 0x1f
-- Fix bug in gzread() on concatenated file with 0x1f at end of buffer
-  and next buffer doesn't start with 0x8b
-- Fix uncompress() to return Z_DATA_ERROR on truncated input
-- Free memory at end of example.c
-- Remove MAX #define in trees.c (conflicted with some libraries)
-- Fix static const's in deflate.c, gzio.c, and zutil.[ch]
-- Declare malloc() and free() in gzio.c if STDC not defined
-- Use malloc() instead of calloc() in zutil.c if int big enough
-- Define STDC for AIX
-- Add aix/ with approach for compiling shared library on AIX
-- Add HP-UX support for shared libraries in configure
-- Add OpenUNIX support for shared libraries in configure
-- Use $cc instead of gcc to build shared library
-- Make prefix directory if needed when installing
-- Correct Macintosh avoidance of typedef Byte in zconf.h
-- Correct Turbo C memory allocation when under Linux
-- Use libz.a instead of -lz in Makefile (assure use of compiled library)
-- Update configure to check for snprintf or vsnprintf functions and their
-  return value, warn during make if using an insecure function
-- Fix configure problem with compile-time knowledge of HAVE_UNISTD_H that
-  is lost when library is used--resolution is to build new zconf.h
-- Documentation improvements (in zlib.h):
-    - Document raw deflate and inflate
-    - Update RFCs URL
-    - Point out that zlib and gzip formats are different
-    - Note that Z_BUF_ERROR is not fatal
-    - Document string limit for gzprintf() and possible buffer overflow
-    - Note requirement on avail_out when flushing
-    - Note permitted values of flush parameter of inflate()
-- Add some FAQs (and even answers) to the FAQ
-- Add contrib/inflate86/ for x86 faster inflate
-- Add contrib/blast/ for PKWare Data Compression Library decompression
-- Add contrib/puff/ simple inflate for deflate format description
-
-Changes in 1.1.4 (11 March 2002)
-- ZFREE was repeated on same allocation on some error conditions.
-  This creates a security problem described in
-  http://www.zlib.org/advisory-2002-03-11.txt
-- Returned incorrect error (Z_MEM_ERROR) on some invalid data
-- Avoid accesses before window for invalid distances with inflate window
-  less than 32K.
-- force windowBits > 8 to avoid a bug in the encoder for a window size
-  of 256 bytes. (A complete fix will be available in 1.1.5).
-
-Changes in 1.1.3 (9 July 1998)
-- fix "an inflate input buffer bug that shows up on rare but persistent
-  occasions" (Mark)
-- fix gzread and gztell for concatenated .gz files (Didier Le Botlan)
-- fix gzseek(..., SEEK_SET) in write mode
-- fix crc check after a gzeek (Frank Faubert)
-- fix miniunzip when the last entry in a zip file is itself a zip file
-  (J Lillge)
-- add contrib/asm586 and contrib/asm686 (Brian Raiter)
-  See http://www.muppetlabs.com/~breadbox/software/assembly.html
-- add support for Delphi 3 in contrib/delphi (Bob Dellaca)
-- add support for C++Builder 3 and Delphi 3 in contrib/delphi2 (Davide Moretti)
-- do not exit prematurely in untgz if 0 at start of block (Magnus Holmgren)
-- use macro EXTERN instead of extern to support DLL for BeOS (Sander Stoks)
-- added a FAQ file
-
-- Support gzdopen on Mac with Metrowerks (Jason Linhart)
-- Do not redefine Byte on Mac (Brad Pettit & Jason Linhart)
-- define SEEK_END too if SEEK_SET is not defined (Albert Chin-A-Young)
-- avoid some warnings with Borland C (Tom Tanner)
-- fix a problem in contrib/minizip/zip.c for 16-bit MSDOS (Gilles Vollant)
-- emulate utime() for WIN32 in contrib/untgz  (Gilles Vollant)
-- allow several arguments to configure (Tim Mooney, Frodo Looijaard)
-- use libdir and includedir in Makefile.in (Tim Mooney)
-- support shared libraries on OSF1 V4 (Tim Mooney)
-- remove so_locations in "make clean"  (Tim Mooney)
-- fix maketree.c compilation error (Glenn, Mark)
-- Python interface to zlib now in Python 1.5 (Jeremy Hylton)
-- new Makefile.riscos (Rich Walker)
-- initialize static descriptors in trees.c for embedded targets (Nick Smith)
-- use "foo-gz" in example.c for RISCOS and VMS (Nick Smith)
-- add the OS/2 files in Makefile.in too (Andrew Zabolotny)
-- fix fdopen and halloc macros for Microsoft C 6.0 (Tom Lane)
-- fix maketree.c to allow clean compilation of inffixed.h (Mark)
-- fix parameter check in deflateCopy (Gunther Nikl)
-- cleanup trees.c, use compressed_len only in debug mode (Christian Spieler)
-- Many portability patches by Christian Spieler:
-  . zutil.c, zutil.h: added "const" for zmem*
-  . Make_vms.com: fixed some typos
-  . Make_vms.com: msdos/Makefile.*: removed zutil.h from some dependency lists
-  . msdos/Makefile.msc: remove "default rtl link library" info from obj files
-  . msdos/Makefile.*: use model-dependent name for the built zlib library
-  . msdos/Makefile.emx, nt/Makefile.emx, nt/Makefile.gcc:
-     new makefiles, for emx (DOS/OS2), emx&rsxnt and mingw32 (Windows 9x / NT)
-- use define instead of typedef for Bytef also for MSC small/medium (Tom Lane)
-- replace __far with _far for better portability (Christian Spieler, Tom Lane)
-- fix test for errno.h in configure (Tim Newsham)
-
-Changes in 1.1.2 (19 March 98)
-- added contrib/minzip, mini zip and unzip based on zlib (Gilles Vollant)
-  See http://www.winimage.com/zLibDll/unzip.html
-- preinitialize the inflate tables for fixed codes, to make the code
-  completely thread safe (Mark)
-- some simplifications and slight speed-up to the inflate code (Mark)
-- fix gzeof on non-compressed files (Allan Schrum)
-- add -std1 option in configure for OSF1 to fix gzprintf (Martin Mokrejs)
-- use default value of 4K for Z_BUFSIZE for 16-bit MSDOS (Tim Wegner + Glenn)
-- added os2/Makefile.def and os2/zlib.def (Andrew Zabolotny)
-- add shared lib support for UNIX_SV4.2MP (MATSUURA Takanori)
-- do not wrap extern "C" around system includes (Tom Lane)
-- mention zlib binding for TCL in README (Andreas Kupries)
-- added amiga/Makefile.pup for Amiga powerUP SAS/C PPC (Andreas Kleinert)
-- allow "make install prefix=..." even after configure (Glenn Randers-Pehrson)
-- allow "configure --prefix $HOME" (Tim Mooney)
-- remove warnings in example.c and gzio.c (Glenn Randers-Pehrson)
-- move Makefile.sas to amiga/Makefile.sas
-
-Changes in 1.1.1 (27 Feb 98)
-- fix macros _tr_tally_* in deflate.h for debug mode  (Glenn Randers-Pehrson)
-- remove block truncation heuristic which had very marginal effect for zlib
-  (smaller lit_bufsize than in gzip 1.2.4) and degraded a little the
-  compression ratio on some files. This also allows inlining _tr_tally for
-  matches in deflate_slow.
-- added msdos/Makefile.w32 for WIN32 Microsoft Visual C++ (Bob Frazier)
-
-Changes in 1.1.0 (24 Feb 98)
-- do not return STREAM_END prematurely in inflate (John Bowler)
-- revert to the zlib 1.0.8 inflate to avoid the gcc 2.8.0 bug (Jeremy Buhler)
-- compile with -DFASTEST to get compression code optimized for speed only
-- in minigzip, try mmap'ing the input file first (Miguel Albrecht)
-- increase size of I/O buffers in minigzip.c and gzio.c (not a big gain
-  on Sun but significant on HP)
-
-- add a pointer to experimental unzip library in README (Gilles Vollant)
-- initialize variable gcc in configure (Chris Herborth)
-
-Changes in 1.0.9 (17 Feb 1998)
-- added gzputs and gzgets functions
-- do not clear eof flag in gzseek (Mark Diekhans)
-- fix gzseek for files in transparent mode (Mark Diekhans)
-- do not assume that vsprintf returns the number of bytes written (Jens Krinke)
-- replace EXPORT with ZEXPORT to avoid conflict with other programs
-- added compress2 in zconf.h, zlib.def, zlib.dnt
-- new asm code from Gilles Vollant in contrib/asm386
-- simplify the inflate code (Mark):
- . Replace ZALLOC's in huft_build() with single ZALLOC in inflate_blocks_new()
- . ZALLOC the length list in inflate_trees_fixed() instead of using stack
- . ZALLOC the value area for huft_build() instead of using stack
- . Simplify Z_FINISH check in inflate()
-
-- Avoid gcc 2.8.0 comparison bug a little differently than zlib 1.0.8
-- in inftrees.c, avoid cc -O bug on HP (Farshid Elahi)
-- in zconf.h move the ZLIB_DLL stuff earlier to avoid problems with
-  the declaration of FAR (Gilles VOllant)
-- install libz.so* with mode 755 (executable) instead of 644 (Marc Lehmann)
-- read_buf buf parameter of type Bytef* instead of charf*
-- zmemcpy parameters are of type Bytef*, not charf* (Joseph Strout)
-- do not redeclare unlink in minigzip.c for WIN32 (John Bowler)
-- fix check for presence of directories in "make install" (Ian Willis)
-
-Changes in 1.0.8 (27 Jan 1998)
-- fixed offsets in contrib/asm386/gvmat32.asm (Gilles Vollant)
-- fix gzgetc and gzputc for big endian systems (Markus Oberhumer)
-- added compress2() to allow setting the compression level
-- include sys/types.h to get off_t on some systems (Marc Lehmann & QingLong)
-- use constant arrays for the static trees in trees.c instead of computing
-  them at run time (thanks to Ken Raeburn for this suggestion). To create
-  trees.h, compile with GEN_TREES_H and run "make test".
-- check return code of example in "make test" and display result
-- pass minigzip command line options to file_compress
-- simplifying code of inflateSync to avoid gcc 2.8 bug
-
-- support CC="gcc -Wall" in configure -s (QingLong)
-- avoid a flush caused by ftell in gzopen for write mode (Ken Raeburn)
-- fix test for shared library support to avoid compiler warnings
-- zlib.lib -> zlib.dll in msdos/zlib.rc (Gilles Vollant)
-- check for TARGET_OS_MAC in addition to MACOS (Brad Pettit)
-- do not use fdopen for Metrowerks on Mac (Brad Pettit))
-- add checks for gzputc and gzputc in example.c
-- avoid warnings in gzio.c and deflate.c (Andreas Kleinert)
-- use const for the CRC table (Ken Raeburn)
-- fixed "make uninstall" for shared libraries
-- use Tracev instead of Trace in infblock.c
-- in example.c use correct compressed length for test_sync
-- suppress +vnocompatwarnings in configure for HPUX (not always supported)
-
-Changes in 1.0.7 (20 Jan 1998)
-- fix gzseek which was broken in write mode
-- return error for gzseek to negative absolute position
-- fix configure for Linux (Chun-Chung Chen)
-- increase stack space for MSC (Tim Wegner)
-- get_crc_table and inflateSyncPoint are EXPORTed (Gilles Vollant)
-- define EXPORTVA for gzprintf (Gilles Vollant)
-- added man page zlib.3 (Rick Rodgers)
-- for contrib/untgz, fix makedir() and improve Makefile
-
-- check gzseek in write mode in example.c
-- allocate extra buffer for seeks only if gzseek is actually called
-- avoid signed/unsigned comparisons (Tim Wegner, Gilles Vollant)
-- add inflateSyncPoint in zconf.h
-- fix list of exported functions in nt/zlib.dnt and mdsos/zlib.def
-
-Changes in 1.0.6 (19 Jan 1998)
-- add functions gzprintf, gzputc, gzgetc, gztell, gzeof, gzseek, gzrewind and
-  gzsetparams (thanks to Roland Giersig and Kevin Ruland for some of this code)
-- Fix a deflate bug occurring only with compression level 0 (thanks to
-  Andy Buckler for finding this one).
-- In minigzip, pass transparently also the first byte for .Z files.
-- return Z_BUF_ERROR instead of Z_OK if output buffer full in uncompress()
-- check Z_FINISH in inflate (thanks to Marc Schluper)
-- Implement deflateCopy (thanks to Adam Costello)
-- make static libraries by default in configure, add --shared option.
-- move MSDOS or Windows specific files to directory msdos
-- suppress the notion of partial flush to simplify the interface
-  (but the symbol Z_PARTIAL_FLUSH is kept for compatibility with 1.0.4)
-- suppress history buffer provided by application to simplify the interface
-  (this feature was not implemented anyway in 1.0.4)
-- next_in and avail_in must be initialized before calling inflateInit or
-  inflateInit2
-- add EXPORT in all exported functions (for Windows DLL)
-- added Makefile.nt (thanks to Stephen Williams)
-- added the unsupported "contrib" directory:
-   contrib/asm386/ by Gilles Vollant <info@winimage.com>
-        386 asm code replacing longest_match().
-   contrib/iostream/ by Kevin Ruland <kevin@rodin.wustl.edu>
-        A C++ I/O streams interface to the zlib gz* functions
-   contrib/iostream2/  by Tyge Lvset <Tyge.Lovset@cmr.no>
-        Another C++ I/O streams interface
-   contrib/untgz/  by "Pedro A. Aranda Guti\irrez" <paag@tid.es>
-        A very simple tar.gz file extractor using zlib
-   contrib/visual-basic.txt by Carlos Rios <c_rios@sonda.cl>
-        How to use compress(), uncompress() and the gz* functions from VB.
-- pass params -f (filtered data), -h (huffman only), -1 to -9 (compression
-  level) in minigzip (thanks to Tom Lane)
-
-- use const for rommable constants in deflate
-- added test for gzseek and gztell in example.c
-- add undocumented function inflateSyncPoint() (hack for Paul Mackerras)
-- add undocumented function zError to convert error code to string
-  (for Tim Smithers)
-- Allow compilation of gzio with -DNO_DEFLATE to avoid the compression code.
-- Use default memcpy for Symantec MSDOS compiler.
-- Add EXPORT keyword for check_func (needed for Windows DLL)
-- add current directory to LD_LIBRARY_PATH for "make test"
-- create also a link for libz.so.1
-- added support for FUJITSU UXP/DS (thanks to Toshiaki Nomura)
-- use $(SHAREDLIB) instead of libz.so in Makefile.in (for HPUX)
-- added -soname for Linux in configure (Chun-Chung Chen,
-- assign numbers to the exported functions in zlib.def (for Windows DLL)
-- add advice in zlib.h for best usage of deflateSetDictionary
-- work around compiler bug on Atari (cast Z_NULL in call of s->checkfn)
-- allow compilation with ANSI keywords only enabled for TurboC in large model
-- avoid "versionString"[0] (Borland bug)
-- add NEED_DUMMY_RETURN for Borland
-- use variable z_verbose for tracing in debug mode (L. Peter Deutsch).
-- allow compilation with CC
-- defined STDC for OS/2 (David Charlap)
-- limit external names to 8 chars for MVS (Thomas Lund)
-- in minigzip.c, use static buffers only for 16-bit systems
-- fix suffix check for "minigzip -d foo.gz"
-- do not return an error for the 2nd of two consecutive gzflush() (Felix Lee)
-- use _fdopen instead of fdopen for MSC >= 6.0 (Thomas Fanslau)
-- added makelcc.bat for lcc-win32 (Tom St Denis)
-- in Makefile.dj2, use copy and del instead of install and rm (Frank Donahoe)
-- Avoid expanded $Id: ChangeLog,v 1.5 2002/05/08 04:38:00 aoliva Exp $. Use "rcs -kb" or "cvs admin -kb" to avoid Id expansion.
-- check for unistd.h in configure (for off_t)
-- remove useless check parameter in inflate_blocks_free
-- avoid useless assignment of s->check to itself in inflate_blocks_new
-- do not flush twice in gzclose (thanks to Ken Raeburn)
-- rename FOPEN as F_OPEN to avoid clash with /usr/include/sys/file.h
-- use NO_ERRNO_H instead of enumeration of operating systems with errno.h
-- work around buggy fclose on pipes for HP/UX
-- support zlib DLL with BORLAND C++ 5.0 (thanks to Glenn Randers-Pehrson)
-- fix configure if CC is already equal to gcc
-
-Changes in 1.0.5 (3 Jan 98)
-- Fix inflate to terminate gracefully when fed corrupted or invalid data
-- Use const for rommable constants in inflate
-- Eliminate memory leaks on error conditions in inflate
-- Removed some vestigial code in inflate
-- Update web address in README
-
-Changes in 1.0.4 (24 Jul 96)
-- In very rare conditions, deflate(s, Z_FINISH) could fail to produce an EOF
-  bit, so the decompressor could decompress all the correct data but went
-  on to attempt decompressing extra garbage data. This affected minigzip too.
-- zlibVersion and gzerror return const char* (needed for DLL)
-- port to RISCOS (no fdopen, no multiple dots, no unlink, no fileno)
-- use z_error only for DEBUG (avoid problem with DLLs)
-
-Changes in 1.0.3 (2 Jul 96)
-- use z_streamp instead of z_stream *, which is now a far pointer in MSDOS
-  small and medium models; this makes the library incompatible with previous
-  versions for these models. (No effect in large model or on other systems.)
-- return OK instead of BUF_ERROR if previous deflate call returned with
-  avail_out as zero but there is nothing to do
-- added memcmp for non STDC compilers
-- define NO_DUMMY_DECL for more Mac compilers (.h files merged incorrectly)
-- define __32BIT__ if __386__ or i386 is defined (pb. with Watcom and SCO)
-- better check for 16-bit mode MSC (avoids problem with Symantec)
-
-Changes in 1.0.2 (23 May 96)
-- added Windows DLL support
-- added a function zlibVersion (for the DLL support)
-- fixed declarations using Bytef in infutil.c (pb with MSDOS medium model)
-- Bytef is define's instead of typedef'd only for Borland C
-- avoid reading uninitialized memory in example.c
-- mention in README that the zlib format is now RFC1950
-- updated Makefile.dj2
-- added algorithm.doc
-
-Changes in 1.0.1 (20 May 96) [1.0 skipped to avoid confusion]
-- fix array overlay in deflate.c which sometimes caused bad compressed data
-- fix inflate bug with empty stored block
-- fix MSDOS medium model which was broken in 0.99
-- fix deflateParams() which could generated bad compressed data.
-- Bytef is define'd instead of typedef'ed (work around Borland bug)
-- added an INDEX file
-- new makefiles for DJGPP (Makefile.dj2), 32-bit Borland (Makefile.b32),
-  Watcom (Makefile.wat), Amiga SAS/C (Makefile.sas)
-- speed up adler32 for modern machines without auto-increment
-- added -ansi for IRIX in configure
-- static_init_done in trees.c is an int
-- define unlink as delete for VMS
-- fix configure for QNX
-- add configure branch for SCO and HPUX
-- avoid many warnings (unused variables, dead assignments, etc...)
-- no fdopen for BeOS
-- fix the Watcom fix for 32 bit mode (define FAR as empty)
-- removed redefinition of Byte for MKWERKS
-- work around an MWKERKS bug (incorrect merge of all .h files)
-
-Changes in 0.99 (27 Jan 96)
-- allow preset dictionary shared between compressor and decompressor
-- allow compression level 0 (no compression)
-- add deflateParams in zlib.h: allow dynamic change of compression level
-  and compression strategy.
-- test large buffers and deflateParams in example.c
-- add optional "configure" to build zlib as a shared library
-- suppress Makefile.qnx, use configure instead
-- fixed deflate for 64-bit systems (detected on Cray)
-- fixed inflate_blocks for 64-bit systems (detected on Alpha)
-- declare Z_DEFLATED in zlib.h (possible parameter for deflateInit2)
-- always return Z_BUF_ERROR when deflate() has nothing to do
-- deflateInit and inflateInit are now macros to allow version checking
-- prefix all global functions and types with z_ with -DZ_PREFIX
-- make falloc completely reentrant (inftrees.c)
-- fixed very unlikely race condition in ct_static_init
-- free in reverse order of allocation to help memory manager
-- use zlib-1.0/* instead of zlib/* inside the tar.gz
-- make zlib warning-free with "gcc -O3 -Wall -Wwrite-strings -Wpointer-arith
-  -Wconversion -Wstrict-prototypes -Wmissing-prototypes"
-- allow gzread on concatenated .gz files
-- deflateEnd now returns Z_DATA_ERROR if it was premature
-- deflate is finally (?) fully deterministic (no matches beyond end of input)
-- Document Z_SYNC_FLUSH
-- add uninstall in Makefile
-- Check for __cpluplus in zlib.h
-- Better test in ct_align for partial flush
-- avoid harmless warnings for Borland C++
-- initialize hash_head in deflate.c
-- avoid warning on fdopen (gzio.c) for HP cc -Aa
-- include stdlib.h for STDC compilers
-- include errno.h for Cray
-- ignore error if ranlib doesn't exist
-- call ranlib twice for NeXTSTEP
-- use exec_prefix instead of prefix for libz.a
-- renamed ct_* as _tr_* to avoid conflict with applications
-- clear z->msg in inflateInit2 before any error return
-- initialize opaque in example.c, gzio.c, deflate.c and inflate.c
-- fixed typo in zconf.h (_GNUC__ => __GNUC__)
-- check for WIN32 in zconf.h and zutil.c (avoid farmalloc in 32-bit mode)
-- fix typo in Make_vms.com (f$trnlnm -> f$getsyi)
-- in fcalloc, normalize pointer if size > 65520 bytes
-- don't use special fcalloc for 32 bit Borland C++
-- use STDC instead of __GO32__ to avoid redeclaring exit, calloc, etc...
-- use Z_BINARY instead of BINARY
-- document that gzclose after gzdopen will close the file
-- allow "a" as mode in gzopen.
-- fix error checking in gzread
-- allow skipping .gz extra-field on pipes
-- added reference to Perl interface in README
-- put the crc table in FAR data (I dislike more and more the medium model :)
-- added get_crc_table
-- added a dimension to all arrays (Borland C can't count).
-- workaround Borland C bug in declaration of inflate_codes_new & inflate_fast
-- guard against multiple inclusion of *.h (for precompiled header on Mac)
-- Watcom C pretends to be Microsoft C small model even in 32 bit mode.
-- don't use unsized arrays to avoid silly warnings by Visual C++:
-     warning C4746: 'inflate_mask' : unsized array treated as  '__far'
-     (what's wrong with far data in far model?).
-- define enum out of inflate_blocks_state to allow compilation with C++
-
-Changes in 0.95 (16 Aug 95)
-- fix MSDOS small and medium model (now easier to adapt to any compiler)
-- inlined send_bits
-- fix the final (:-) bug for deflate with flush (output was correct but
-  not completely flushed in rare occasions).
-- default window size is same for compression and decompression
-  (it's now sufficient to set MAX_WBITS in zconf.h).
-- voidp -> voidpf and voidnp -> voidp (for consistency with other
-  typedefs and because voidnp was not near in large model).
-
-Changes in 0.94 (13 Aug 95)
-- support MSDOS medium model
-- fix deflate with flush (could sometimes generate bad output)
-- fix deflateReset (zlib header was incorrectly suppressed)
-- added support for VMS
-- allow a compression level in gzopen()
-- gzflush now calls fflush
-- For deflate with flush, flush even if no more input is provided.
-- rename libgz.a as libz.a
-- avoid complex expression in infcodes.c triggering Turbo C bug
-- work around a problem with gcc on Alpha (in INSERT_STRING)
-- don't use inline functions (problem with some gcc versions)
-- allow renaming of Byte, uInt, etc... with #define.
-- avoid warning about (unused) pointer before start of array in deflate.c
-- avoid various warnings in gzio.c, example.c, infblock.c, adler32.c, zutil.c
-- avoid reserved word 'new' in trees.c
-
-Changes in 0.93 (25 June 95)
-- temporarily disable inline functions
-- make deflate deterministic
-- give enough lookahead for PARTIAL_FLUSH
-- Set binary mode for stdin/stdout in minigzip.c for OS/2
-- don't even use signed char in inflate (not portable enough)
-- fix inflate memory leak for segmented architectures
-
-Changes in 0.92 (3 May 95)
-- don't assume that char is signed (problem on SGI)
-- Clear bit buffer when starting a stored block
-- no memcpy on Pyramid
-- suppressed inftest.c
-- optimized fill_window, put longest_match inline for gcc
-- optimized inflate on stored blocks.
-- untabify all sources to simplify patches
-
-Changes in 0.91 (2 May 95)
-- Default MEM_LEVEL is 8 (not 9 for Unix) as documented in zlib.h
-- Document the memory requirements in zconf.h
-- added "make install"
-- fix sync search logic in inflateSync
-- deflate(Z_FULL_FLUSH) now works even if output buffer too short
-- after inflateSync, don't scare people with just "lo world"
-- added support for DJGPP
-
-Changes in 0.9 (1 May 95)
-- don't assume that zalloc clears the allocated memory (the TurboC bug
-  was Mark's bug after all :)
-- let again gzread copy uncompressed data unchanged (was working in 0.71)
-- deflate(Z_FULL_FLUSH), inflateReset and inflateSync are now fully implemented
-- added a test of inflateSync in example.c
-- moved MAX_WBITS to zconf.h because users might want to change that.
-- document explicitly that zalloc(64K) on MSDOS must return a normalized
-  pointer (zero offset)
-- added Makefiles for Microsoft C, Turbo C, Borland C++
-- faster crc32()
-
-Changes in 0.8 (29 April 95)
-- added fast inflate (inffast.c)
-- deflate(Z_FINISH) now returns Z_STREAM_END when done. Warning: this
-  is incompatible with previous versions of zlib which returned Z_OK.
-- work around a TurboC compiler bug (bad code for b << 0, see infutil.h)
-  (actually that was not a compiler bug, see 0.81 above)
-- gzread no longer reads one extra byte in certain cases
-- In gzio destroy(), don't reference a freed structure
-- avoid many warnings for MSDOS
-- avoid the ERROR symbol which is used by MS Windows
-
-Changes in 0.71 (14 April 95)
-- Fixed more MSDOS compilation problems :( There is still a bug with
-  TurboC large model.
-
-Changes in 0.7 (14 April 95)
-- Added full inflate support.
-- Simplified the crc32() interface. The pre- and post-conditioning
-  (one's complement) is now done inside crc32(). WARNING: this is
-  incompatible with previous versions; see zlib.h for the new usage.
-
-Changes in 0.61 (12 April 95)
-- workaround for a bug in TurboC. example and minigzip now work on MSDOS.
-
-Changes in 0.6 (11 April 95)
-- added minigzip.c
-- added gzdopen to reopen a file descriptor as gzFile
-- added transparent reading of non-gziped files in gzread.
-- fixed bug in gzread (don't read crc as data)
-- fixed bug in destroy (gzio.c) (don't return Z_STREAM_END for gzclose).
-- don't allocate big arrays in the stack (for MSDOS)
-- fix some MSDOS compilation problems
-
-Changes in 0.5:
-- do real compression in deflate.c. Z_PARTIAL_FLUSH is supported but
-  not yet Z_FULL_FLUSH.
-- support decompression but only in a single step (forced Z_FINISH)
-- added opaque object for zalloc and zfree.
-- added deflateReset and inflateReset
-- added a variable zlib_version for consistency checking.
-- renamed the 'filter' parameter of deflateInit2 as 'strategy'.
-  Added Z_FILTERED and Z_HUFFMAN_ONLY constants.
-
-Changes in 0.4:
-- avoid "zip" everywhere, use zlib instead of ziplib.
-- suppress Z_BLOCK_FLUSH, interpret Z_PARTIAL_FLUSH as block flush
-  if compression method == 8.
-- added adler32 and crc32
-- renamed deflateOptions as deflateInit2, call one or the other but not both
-- added the method parameter for deflateInit2.
-- added inflateInit2
-- simplied considerably deflateInit and inflateInit by not supporting
-  user-provided history buffer. This is supported only in deflateInit2
-  and inflateInit2.
-
-Changes in 0.3:
-- prefix all macro names with Z_
-- use Z_FINISH instead of deflateEnd to finish compression.
-- added Z_HUFFMAN_ONLY
-- added gzerror()
diff -Nbaur gcc-4.8.1/zlib/ChangeLog.gcj gcc-4.8.1-ppc/zlib/ChangeLog.gcj
--- gcc-4.8.1/zlib/ChangeLog.gcj	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/ChangeLog.gcj	1970-01-01 01:00:00.000000000 +0100
@@ -1,342 +0,0 @@
-2012-11-16  Matthias Klose  <doko@ubuntu.com>
-
-	* Imported zlib 1.2.7; merged local changes.
-
-2012-09-14  David Edelsohn  <dje.gcc@gmail.com>
-
-	* configure: Regenerated.
-
-2012-05-16  H.J. Lu  <hongjiu.lu@intel.com>
-
-	* configure: Regenerated.
-
-2012-03-02  Matthias Klose  <doko@ubuntu.com>
-
-	* Imported zlib 1.2.5; merged local changes.
-
-2011-11-21  Andreas Tobler  <andreast@fgznet.ch>
-
-        * configure: Regenerate.
-
-2011-02-13  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* configure: Regenerate.
-
-2010-04-02  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* Makefile.in: Regenerate.
-	* aclocal.m4: Regenerate.
-
-2009-12-05  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* Makefile.in: Regenerate.
-	* configure: Regenerate.
-
-2009-08-24  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* configure.ac (AC_PREREQ): Bump to 2.64.
-
-2009-08-22  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* Makefile.am (install-html, install-pdf, html): Remove.
-	* Makefile.in: Regenerate.
-
-	* Makefile.in: Regenerate.
-	* aclocal.m4: Regenerate.
-	* configure: Regenerate.
-
-2009-07-30  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* configure.ac (_AC_ARG_VAR_PRECIOUS): Use m4_rename_force.
-
-2009-03-01  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* configure: Regenerate.
-
-2008-12-18  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* configure: Regenerate.
-
-2008-09-26  Peter O'Gorman  <pogma@thewrittenword.com>
-            Steve Ellcey  <sje@cup.hp.com>
-
-	* configure: Regenerate for new libtool.
-	* Makefile.in: Ditto.
-
-2008-06-17  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* Makefile.in: Regenerate.
-	* configure: Regenerate.
-
-2008-03-16  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* aclocal.m4: Regenerate.
-	* configure: Likewise.
-	* Makefile.in: Likewise.
-
-2008-01-24  David Edelsohn  <edelsohn@gnu.org>
-
-	* configure: Regenerate.
-
-2007-07-05  H.J. Lu  <hongjiu.lu@intel.com>
-
-	* aclocal.m4: Regenerated.
-
-2007-05-23  Steve Ellcey  <sje@cup.hp.com>
-
-	* Makefile.in: Regenerate.
-	* configure: Regenerate.
-	* aclocal.m4: Regenerate.
-
-2007-04-14  Steve Ellcey  <sje@cup.hp.com>
-
-	* Makefile.am: Add -I .. to ACLOCAL_AMFLAGS.
-	* Makefile.in: Regenerate.
-
-2007-03-01  Brooks Moses  <brooks.moses@codesourcery.com>
-
-	* Makefile.am: Add dummy install-pdf target.
-	* Makefile.in: Regenerate
-
-2007-01-16  Jack Howarth  <howarth@bromo.med.uc.edu>
-
-	* Makefile.am: Add ACLOCAL_AMFLAGS to use multi.m4.
-	* aclocal.m4: Regenerate.
-	* configure: Regenerate.
-	* Makefile.in: Regenerate.
-
-2006-06-13  Carlos O'Donell  <carlos@codesourcery.com>
-
-	* Makefile.am: Add html and install-html stubs.
-	* Makefile.in: Regenerate.
-	* aclocal.m4: Regenerate.
-
-2005-06-14  Tom Tromey  <tromey@redhat.com>
-
-	* Imported zlib 1.2.3; merged local changes.
-
-2005-06-14  Tom Tromey  <tromey@redhat.com>
-
-	PR libgcj/19877:
-	* configure, aclocal.m4, Makefile.in: Rebuilt.
-
-2005-06-06  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
-
-	* zconf.h (NO_vsnprintf): Define on Tru64 UNIX V4.0.
-
-2005-05-09  Mike Stump  <mrs@apple.com>
-	
-	* configure: Regenerate.
-
-2005-04-12  Mike Stump  <mrs@apple.com>
-
-	* configure: Regenerate.
-
-2004-11-24  Kelley Cook  <kcook@gcc.gnu.org>
-
-	* configure: Regenerate for libtool change.
-
-2004-11-24  Kelley Cook  <kcook@gcc.gnu.org>
-
-	* Makefile.in, aclocal.m4: Regenerate with automake 1.9.3.
-
-2004-11-22  Eric Botcazou  <ebotcazou@libertysurf.fr>
-
-	* zconf.h: Define NO_vsnprintf on Solaris 2.5.1.
-
-2004-10-11  Tom Tromey  <tromey@redhat.com>
-
-	PR libgcj/14856:
-	* Imported zlib 1.2.1; merged local changes.
-
-2005-06-15  Paolo Bonzini  <bonzini@gnu.org>
-
-	* Makefile.am: Remove useless multilib rules.
-	* configure.ac: Rewrite multilib support to use
-	features of recent automakes.
-	* aclocal.m4: Regenerate with Automake 1.8.5.
-	* Makefile.in: Regenerate with Automake 1.8.5.
-	* configure: Regenerate.
-
-2004-04-12  Kelley Cook  <kcook@gcc.gnu.org>
-
-	* Makefile.am: Add in libz_a_CFLAGS as recommended by automake doc.
-	* Makefile.in: Regenerate with automake 1.7.9.
-	* aclocal.m4: Likewise.
-	* configure: Regenerate.
-
-2004-04-10  Kelley Cook  <kcook@gcc.gnu.org>
-
-	* configure.in: Rename file to ...
-	* configure.ac: ...this.
-	* Makefile.in: Regenerate.
-
-2004-04-09  Nathanael Nerode  <neroden@gcc.gnu.org>
-
-	* configure.in: Update to autoconf 2.59; clean up slightly.
-	* acinclude.m4: Update to autoconf 2.59.
-	* aclocal.m4: Regenerate. 
-	* Makefile.in: Regenerate.
-	* configure: Regenerate.
-
-2004-01-14  Kelley Cook  <kcook@gcc.gnu.org>
-
-	* configure.in: Add in AC_PREREQ(2.13)
-
-2003-09-09  Alan Modra  <amodra@bigpond.net.au>
-
-	* configure: Regenerate.
-
-2003-07-11  Nathanael Nerode  <neroden@gcc.gnu.org>
-
-	PR bootstrap/7126
-	* configure.in: Correct zlib version number.
-	* configure: Regenerate.
-
-2003-07-11  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>
-
-	* README: Note that zlib is not part of GCC.
-
-2003-03-12  Andreas Schwab  <schwab@suse.de>
-
-	* configure.in:  Avoid trailing /. in toolexeclibdir.
-	* configure: Rebuilt.
-
-2003-02-20  Alexandre Oliva  <aoliva@redhat.com>
-
-	* configure.in: Propagate ORIGINAL_LD_FOR_MULTILIBS to
-	config.status.
-	* configure: Rebuilt.
-
-2003-02-19  Alexandre Oliva  <aoliva@redhat.com>
-
-	* configure.in (multiosdir): Set to nothing if compiler is not GCC
-	or if it doesn't support -print-multi-os-directory.
-	* configure: Rebuilt.
-
-2002-09-22  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
-
-	* Makefile.am (all-multi): Fix multilib parallel build.
-
-2002-05-16  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
-
-	* configure.in: Allow for PWDCMD to override hardcoded pwd.
-	* configure: Regenerate.
-
-	* ChangeLog: Move entries to ChangeLog.gcj.
-
-2002-05-08  Alexandre Oliva  <aoliva@redhat.com>
-
-	* configure.in (ORIGINAL_LD_FOR_MULTILIBS): Preserve LD at
-	script entry, and set LD to it when configuring multilibs.
-	* configure: Rebuilt.
-
-2002-03-17  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>
-
-	* Makefile.am: Make target library a convenience library.
-	* Makefile.in: Rebuilt.
-
-2002-03-11  Tom Tromey  <tromey@redhat.com>
-
-	* ChangeLog.gcj: Imported 1.1.4, while preserving local changes.
-
-2001-07-03  Tom Tromey  <tromey@redhat.com>
-
-	Fix for PR bootstrap/3281:
-	* configure, Makefile.in: Rebuilt.
-	* configure.in: Set mkinstalldirs, for in-tree build.
-
-2001-06-09  Alexandre Oliva  <aoliva@redhat.com>, Stephen L Moshier  <moshier@mediaone.net>
-
-	* configure.in (AC_EXEEXT): Work around in case it expands to
-	nothing, as in autoconf 2.50.
-	* configure: Rebuilt.
-
-2001-05-13  Alexandre Oliva  <aoliva@redhat.com>
-
-	* acinclude.m4: Use ../libtool.m4.
-	* configure.in: Use ${zlib_basedir}/.. for AC_CONFIG_AUX_DIR.
-	* acinclude.m4, configure, Makefile.in: Rebuilt.
-
-2000-10-24  Chris Demetriou  <cgd@sibyte.com>
-
-	* configure.in: Invoke AC_PROG_CPP unconditionally before
-	conditional feature tests.
-
-2000-10-10  Alexandre Oliva  <aoliva@redhat.com>
-
-	* configure.in (zlib_basedir): Cope with empty with_target_subdir
-	* configure: Rebuilt.
-
-2000-09-06  Alexandre Oliva  <aoliva@redhat.com>
-
-	* configure.in (multilib): Enable by default only for target.
-	* configure: Rebuilt.
-
-Sun Sep  3 12:37:12 2000  Anthony Green  <green@redhat.com>
-
-	* configure.in: Add TARGET_LIBRARY conditional.
-	* configure: Rebuilt.
-	* Makefile.am: If we're building a build host library, call the
-	library libz.a and don't use libtool.
-	* Makefile.in: Rebuilt.
-
-1999-10-04  Tom Tromey  <tromey@cygnus.com>
-
-	* configure: Rebuilt.
-	* configure.in: Call AC_EXEEXT after LIB_AC_PROG_CC, but don't
-	actually let AC_EXEEXT run.
-
-1999-09-28  Tom Tromey  <tromey@cygnus.com>
-
-	* aclocal.m4, configure: Rebuilt.
-	* acinclude.m4 (LIB_AC_PROG_CC): Provide appropriate AC_PROG_ symbol.
-
-Mon Aug  9 18:33:38 1999  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
-
-	* Makefile.in: Rebuilt.
-	* Makefile.am (toolexeclibdir): Add $(MULTISUBDIR) even for native
-	builds.
-
-	* configure: Rebuilt.
-	* configure.in: Properly align --help output, fix capitalization.
-
-1999-08-02  Tom Tromey  <tromey@cygnus.com>
-
-	* aclocal.m4, configure: Rebuilt for new libtool.
-
-1999-07-19  Alexandre Oliva  <oliva@dcc.unicamp.br>
-
-	* Makefile.am (*-recursive, *-am, *-multi): Automake does not
-	generate *-recursive for this Makefile, use *-am instead.
-	* Makefile.in: Rebuilt.
-
-1999-06-21  Tom Tromey  <tromey@cygnus.com>
-
-	* Makefile.in: Rebuilt.
-	* Makefile.am (libzgcj_la_LDFLAGS): Use -version-info, not
-	-release.
-
-	* Makefile.in: Rebuilt.
-	* Makefile.am (toolexeclibdir): Define as libdir when
-	appropriate.
-	* configure: Rebuilt.
-	* configure.in (USE_LIBDIR): New conditional.
-
-1999-05-10  Tom Tromey  <tromey@cygnus.com>
-
-	* configure, Makefile.in: Rebuilt.
-	* Makefile.am (EXTRA_LTLIBRARIES): New macro.
-	(toolexeclib_LTLIBRARIES): Use @target_all@.
-	* configure.in: Recognize --with-system-zlib.  Subst target_all.
-
-1999-05-04  Tom Tromey  <tromey@cygnus.com>
-
-	* Makefile.in: Replace with automake-generated file.
-	* Makefile.am: New file.
-	* configure: Replaced with autoconf-generated script.
-	* aclocal.m4: New file.
-	* acinclude.m4: New file.
-	* configure.in: New file.
-	* Makefile: Removed.
-
diff -Nbaur gcc-4.8.1/zlib/CMakeLists.txt gcc-4.8.1-ppc/zlib/CMakeLists.txt
--- gcc-4.8.1/zlib/CMakeLists.txt	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,211 +0,0 @@
-cmake_minimum_required(VERSION 2.4.4)
-set(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)
-
-project(zlib C)
-
-set(VERSION "1.2.7")
-
-set(INSTALL_BIN_DIR "${CMAKE_INSTALL_PREFIX}/bin" CACHE PATH "Installation directory for executables")
-set(INSTALL_LIB_DIR "${CMAKE_INSTALL_PREFIX}/lib" CACHE PATH "Installation directory for libraries")
-set(INSTALL_INC_DIR "${CMAKE_INSTALL_PREFIX}/include" CACHE PATH "Installation directory for headers")
-set(INSTALL_MAN_DIR "${CMAKE_INSTALL_PREFIX}/share/man" CACHE PATH "Installation directory for manual pages")
-set(INSTALL_PKGCONFIG_DIR "${CMAKE_INSTALL_PREFIX}/share/pkgconfig" CACHE PATH "Installation directory for pkgconfig (.pc) files")
-
-include(CheckTypeSize)
-include(CheckFunctionExists)
-include(CheckIncludeFile)
-include(CheckCSourceCompiles)
-enable_testing()
-
-check_include_file(sys/types.h HAVE_SYS_TYPES_H)
-check_include_file(stdint.h    HAVE_STDINT_H)
-check_include_file(stddef.h    HAVE_STDDEF_H)
-
-#
-# Check to see if we have large file support
-#
-set(CMAKE_REQUIRED_DEFINITIONS -D_LARGEFILE64_SOURCE=1)
-# We add these other definitions here because CheckTypeSize.cmake
-# in CMake 2.4.x does not automatically do so and we want
-# compatibility with CMake 2.4.x.
-if(HAVE_SYS_TYPES_H)
-    list(APPEND CMAKE_REQUIRED_DEFINITIONS -DHAVE_SYS_TYPES_H)
-endif()
-if(HAVE_STDINT_H)
-    list(APPEND CMAKE_REQUIRED_DEFINITIONS -DHAVE_STDINT_H)
-endif()
-if(HAVE_STDDEF_H)
-    list(APPEND CMAKE_REQUIRED_DEFINITIONS -DHAVE_STDDEF_H)
-endif()
-check_type_size(off64_t OFF64_T)
-if(HAVE_OFF64_T)
-   add_definitions(-D_LARGEFILE64_SOURCE=1)
-endif()
-set(CMAKE_REQUIRED_DEFINITIONS) # clear variable
-
-#
-# Check for fseeko
-#
-check_function_exists(fseeko HAVE_FSEEKO)
-if(NOT HAVE_FSEEKO)
-    add_definitions(-DNO_FSEEKO)
-endif()
-
-#
-# Check for unistd.h
-#
-check_include_file(unistd.h Z_HAVE_UNISTD_H)
-
-if(MSVC)
-    set(CMAKE_DEBUG_POSTFIX "d")
-    add_definitions(-D_CRT_SECURE_NO_DEPRECATE)
-    add_definitions(-D_CRT_NONSTDC_NO_DEPRECATE)
-    include_directories(${CMAKE_CURRENT_SOURCE_DIR})
-endif()
-
-if(NOT CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_CURRENT_BINARY_DIR)
-    # If we're doing an out of source build and the user has a zconf.h
-    # in their source tree...
-    if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/zconf.h)
-        message(STATUS "Renaming")
-        message(STATUS "    ${CMAKE_CURRENT_SOURCE_DIR}/zconf.h")
-        message(STATUS "to 'zconf.h.included' because this file is included with zlib")
-        message(STATUS "but CMake generates it automatically in the build directory.")
-        file(RENAME ${CMAKE_CURRENT_SOURCE_DIR}/zconf.h ${CMAKE_CURRENT_SOURCE_DIR}/zconf.h.included)
-  endif()
-endif()
-
-set(ZLIB_PC ${CMAKE_CURRENT_BINARY_DIR}/zlib.pc)
-configure_file( ${CMAKE_CURRENT_SOURCE_DIR}/zlib.pc.cmakein
-		${ZLIB_PC} @ONLY)
-configure_file(	${CMAKE_CURRENT_SOURCE_DIR}/zconf.h.cmakein
-		${CMAKE_CURRENT_BINARY_DIR}/zconf.h @ONLY)
-include_directories(${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_SOURCE_DIR})
-
-
-#============================================================================
-# zlib
-#============================================================================
-
-set(ZLIB_PUBLIC_HDRS
-    ${CMAKE_CURRENT_BINARY_DIR}/zconf.h
-    zlib.h
-)
-set(ZLIB_PRIVATE_HDRS
-    crc32.h
-    deflate.h
-    gzguts.h
-    inffast.h
-    inffixed.h
-    inflate.h
-    inftrees.h
-    trees.h
-    zutil.h
-)
-set(ZLIB_SRCS
-    adler32.c
-    compress.c
-    crc32.c
-    deflate.c
-    gzclose.c
-    gzlib.c
-    gzread.c
-    gzwrite.c
-    inflate.c
-    infback.c
-    inftrees.c
-    inffast.c
-    trees.c
-    uncompr.c
-    zutil.c
-)
-
-if(NOT MINGW)
-    set(ZLIB_SRCS ${ZLIB_SRCS}
-        win32/zlib1.rc # If present will override custom build rule below.
-    )
-endif()
-
-# parse the full version number from zlib.h and include in ZLIB_FULL_VERSION
-file(READ ${CMAKE_CURRENT_SOURCE_DIR}/zlib.h _zlib_h_contents)
-string(REGEX REPLACE ".*#define[ \t]+ZLIB_VERSION[ \t]+\"([-0-9A-Za-z.]+)\".*"
-    "\\1" ZLIB_FULL_VERSION ${_zlib_h_contents})
-
-if(MINGW)
-    # This gets us DLL resource information when compiling on MinGW.
-    if(NOT CMAKE_RC_COMPILER)
-        SET(CMAKE_RC_COMPILER windres.exe)
-    endif()
-
-    add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/zlib1rc.obj
-                       COMMAND ${CMAKE_RC_COMPILER}
-                            -D GCC_WINDRES
-                            -I ${CMAKE_CURRENT_SOURCE_DIR}
-                            -I ${CMAKE_CURRENT_BINARY_DIR}
-                            -o ${CMAKE_CURRENT_BINARY_DIR}/zlib1rc.obj
-                            -i ${CMAKE_CURRENT_SOURCE_DIR}/win32/zlib1.rc)
-    set(ZLIB_SRCS ${ZLIB_SRCS} ${CMAKE_CURRENT_BINARY_DIR}/zlib1rc.obj)
-endif(MINGW)
-
-add_library(zlib SHARED ${ZLIB_SRCS} ${ZLIB_PUBLIC_HDRS} ${ZLIB_PRIVATE_HDRS})
-add_library(zlibstatic STATIC ${ZLIB_SRCS} ${ZLIB_PUBLIC_HDRS} ${ZLIB_PRIVATE_HDRS})
-set_target_properties(zlib PROPERTIES DEFINE_SYMBOL ZLIB_DLL)
-set_target_properties(zlib PROPERTIES SOVERSION 1)
-
-if(NOT CYGWIN)
-    # This property causes shared libraries on Linux to have the full version
-    # encoded into their final filename.  We disable this on Cygwin because
-    # it causes cygz-${ZLIB_FULL_VERSION}.dll to be created when cygz.dll
-    # seems to be the default.
-    #
-    # This has no effect with MSVC, on that platform the version info for
-    # the DLL comes from the resource file win32/zlib1.rc
-    set_target_properties(zlib PROPERTIES VERSION ${ZLIB_FULL_VERSION})
-endif()
-
-if(UNIX)
-    # On unix-like platforms the library is almost always called libz
-   set_target_properties(zlib zlibstatic PROPERTIES OUTPUT_NAME z)
-   set_target_properties(zlib PROPERTIES LINK_FLAGS "-Wl,--version-script,${CMAKE_CURRENT_SOURCE_DIR}/zlib.map")
-elseif(BUILD_SHARED_LIBS AND WIN32)
-    # Creates zlib1.dll when building shared library version
-    set_target_properties(zlib PROPERTIES SUFFIX "1.dll")
-endif()
-
-if(NOT SKIP_INSTALL_LIBRARIES AND NOT SKIP_INSTALL_ALL )
-    install(TARGETS zlib zlibstatic
-        RUNTIME DESTINATION "${INSTALL_BIN_DIR}"
-        ARCHIVE DESTINATION "${INSTALL_LIB_DIR}"
-        LIBRARY DESTINATION "${INSTALL_LIB_DIR}" )
-endif()
-if(NOT SKIP_INSTALL_HEADERS AND NOT SKIP_INSTALL_ALL )
-    install(FILES ${ZLIB_PUBLIC_HDRS} DESTINATION "${INSTALL_INC_DIR}")
-endif()
-if(NOT SKIP_INSTALL_FILES AND NOT SKIP_INSTALL_ALL )
-    install(FILES zlib.3 DESTINATION "${INSTALL_MAN_DIR}/man3")
-endif()
-if(NOT SKIP_INSTALL_FILES AND NOT SKIP_INSTALL_ALL )
-    install(FILES ${ZLIB_PC} DESTINATION "${INSTALL_PKGCONFIG_DIR}")
-endif()
-
-#============================================================================
-# Example binaries
-#============================================================================
-
-add_executable(example test/example.c)
-target_link_libraries(example zlib)
-add_test(example example)
-
-add_executable(minigzip test/minigzip.c)
-target_link_libraries(minigzip zlib)
-
-if(HAVE_OFF64_T)
-    add_executable(example64 test/example.c)
-    target_link_libraries(example64 zlib)
-    set_target_properties(example64 PROPERTIES COMPILE_FLAGS "-D_FILE_OFFSET_BITS=64")
-    add_test(example64 example64)
-
-    add_executable(minigzip64 test/minigzip.c)
-    target_link_libraries(minigzip64 zlib)
-    set_target_properties(minigzip64 PROPERTIES COMPILE_FLAGS "-D_FILE_OFFSET_BITS=64")
-endif()
diff -Nbaur gcc-4.8.1/zlib/compress.c gcc-4.8.1-ppc/zlib/compress.c
--- gcc-4.8.1/zlib/compress.c	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/compress.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,80 +0,0 @@
-/* compress.c -- compress a memory buffer
- * Copyright (C) 1995-2005 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id: compress.c,v 1.1.1.2 2002/03/11 21:53:23 tromey Exp $ */
-
-#define ZLIB_INTERNAL
-#include "zlib.h"
-
-/* ===========================================================================
-     Compresses the source buffer into the destination buffer. The level
-   parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer. Upon entry, destLen is the total size of the
-   destination buffer, which must be at least 0.1% larger than sourceLen plus
-   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
-
-     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
-   Z_STREAM_ERROR if the level parameter is invalid.
-*/
-int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-    int level;
-{
-    z_stream stream;
-    int err;
-
-    stream.next_in = (Bytef*)source;
-    stream.avail_in = (uInt)sourceLen;
-#ifdef MAXSEG_64K
-    /* Check for source > 64K on 16-bit machine: */
-    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
-#endif
-    stream.next_out = dest;
-    stream.avail_out = (uInt)*destLen;
-    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
-
-    stream.zalloc = (alloc_func)0;
-    stream.zfree = (free_func)0;
-    stream.opaque = (voidpf)0;
-
-    err = deflateInit(&stream, level);
-    if (err != Z_OK) return err;
-
-    err = deflate(&stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        deflateEnd(&stream);
-        return err == Z_OK ? Z_BUF_ERROR : err;
-    }
-    *destLen = stream.total_out;
-
-    err = deflateEnd(&stream);
-    return err;
-}
-
-/* ===========================================================================
- */
-int ZEXPORT compress (dest, destLen, source, sourceLen)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-{
-    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
-}
-
-/* ===========================================================================
-     If the default memLevel or windowBits for deflateInit() is changed, then
-   this function needs to be updated.
- */
-uLong ZEXPORT compressBound (sourceLen)
-    uLong sourceLen;
-{
-    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
-           (sourceLen >> 25) + 13;
-}
diff -Nbaur gcc-4.8.1/zlib/configure gcc-4.8.1-ppc/zlib/configure
--- gcc-4.8.1/zlib/configure	2012-09-15 00:43:33.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/configure	1970-01-01 01:00:00.000000000 +0100
@@ -1,13406 +0,0 @@
-#! /bin/sh
-# Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.64.
-#
-# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
-# Foundation, Inc.
-#
-# This configure script is free software; the Free Software Foundation
-# gives unlimited permission to copy, distribute and modify it.
-## -------------------- ##
-## M4sh Initialization. ##
-## -------------------- ##
-
-# Be more Bourne compatible
-DUALCASE=1; export DUALCASE # for MKS sh
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
-  emulate sh
-  NULLCMD=:
-  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in #(
-  *posix*) :
-    set -o posix ;; #(
-  *) :
-     ;;
-esac
-fi
-
-
-as_nl='
-'
-export as_nl
-# Printing a long string crashes Solaris 7 /usr/bin/printf.
-as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
-# Prefer a ksh shell builtin over an external printf program on Solaris,
-# but without wasting forks for bash or zsh.
-if test -z "$BASH_VERSION$ZSH_VERSION" \
-    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='print -r --'
-  as_echo_n='print -rn --'
-elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='printf %s\n'
-  as_echo_n='printf %s'
-else
-  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
-    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
-    as_echo_n='/usr/ucb/echo -n'
-  else
-    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
-    as_echo_n_body='eval
-      arg=$1;
-      case $arg in #(
-      *"$as_nl"*)
-	expr "X$arg" : "X\\(.*\\)$as_nl";
-	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
-      esac;
-      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
-    '
-    export as_echo_n_body
-    as_echo_n='sh -c $as_echo_n_body as_echo'
-  fi
-  export as_echo_body
-  as_echo='sh -c $as_echo_body as_echo'
-fi
-
-# The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
-  PATH_SEPARATOR=:
-  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
-    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
-      PATH_SEPARATOR=';'
-  }
-fi
-
-
-# IFS
-# We need space, tab and new line, in precisely that order.  Quoting is
-# there to prevent editors from complaining about space-tab.
-# (If _AS_PATH_WALK were called with IFS unset, it would disable word
-# splitting by setting IFS to empty value.)
-IFS=" ""	$as_nl"
-
-# Find who we are.  Look in the path if we contain no directory separator.
-case $0 in #((
-  *[\\/]* ) as_myself=$0 ;;
-  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-  done
-IFS=$as_save_IFS
-
-     ;;
-esac
-# We did not find ourselves, most probably we were run as `sh COMMAND'
-# in which case we are not to be found in the path.
-if test "x$as_myself" = x; then
-  as_myself=$0
-fi
-if test ! -f "$as_myself"; then
-  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
-  exit 1
-fi
-
-# Unset variables that we do not need and which cause bugs (e.g. in
-# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
-# suppresses any "Segmentation fault" message there.  '((' could
-# trigger a bug in pdksh 5.2.14.
-for as_var in BASH_ENV ENV MAIL MAILPATH
-do eval test x\${$as_var+set} = xset \
-  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
-done
-PS1='$ '
-PS2='> '
-PS4='+ '
-
-# NLS nuisances.
-LC_ALL=C
-export LC_ALL
-LANGUAGE=C
-export LANGUAGE
-
-# CDPATH.
-(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
-
-if test "x$CONFIG_SHELL" = x; then
-  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
-  emulate sh
-  NULLCMD=:
-  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '\${1+\"\$@\"}'='\"\$@\"'
-  setopt NO_GLOB_SUBST
-else
-  case \`(set -o) 2>/dev/null\` in #(
-  *posix*) :
-    set -o posix ;; #(
-  *) :
-     ;;
-esac
-fi
-"
-  as_required="as_fn_return () { (exit \$1); }
-as_fn_success () { as_fn_return 0; }
-as_fn_failure () { as_fn_return 1; }
-as_fn_ret_success () { return 0; }
-as_fn_ret_failure () { return 1; }
-
-exitcode=0
-as_fn_success || { exitcode=1; echo as_fn_success failed.; }
-as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
-as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
-as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
-if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
-
-else
-  exitcode=1; echo positional parameters were not saved.
-fi
-test x\$exitcode = x0 || exit 1"
-  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
-  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
-  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
-  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
-
-  test -n \"\${ZSH_VERSION+set}\${BASH_VERSION+set}\" || (
-    ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-    ECHO=\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO
-    ECHO=\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO
-    PATH=/empty FPATH=/empty; export PATH FPATH
-    test \"X\`printf %s \$ECHO\`\" = \"X\$ECHO\" \\
-      || test \"X\`print -r -- \$ECHO\`\" = \"X\$ECHO\" ) || exit 1
-test \$(( 1 + 1 )) = 2 || exit 1"
-  if (eval "$as_required") 2>/dev/null; then :
-  as_have_required=yes
-else
-  as_have_required=no
-fi
-  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :
-
-else
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-as_found=false
-for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  as_found=:
-  case $as_dir in #(
-	 /*)
-	   for as_base in sh bash ksh sh5; do
-	     # Try only shells that exist, to save several forks.
-	     as_shell=$as_dir/$as_base
-	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
-		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
-  CONFIG_SHELL=$as_shell as_have_required=yes
-		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
-  break 2
-fi
-fi
-	   done;;
-       esac
-  as_found=false
-done
-$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
-	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
-  CONFIG_SHELL=$SHELL as_have_required=yes
-fi; }
-IFS=$as_save_IFS
-
-
-      if test "x$CONFIG_SHELL" != x; then :
-  # We cannot yet assume a decent shell, so we have to provide a
-	# neutralization value for shells without unset; and this also
-	# works around shells that cannot unset nonexistent variables.
-	BASH_ENV=/dev/null
-	ENV=/dev/null
-	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
-	export CONFIG_SHELL
-	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
-fi
-
-    if test x$as_have_required = xno; then :
-  $as_echo "$0: This script requires a shell more modern than all"
-  $as_echo "$0: the shells that I found on your system."
-  if test x${ZSH_VERSION+set} = xset ; then
-    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
-    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
-  else
-    $as_echo "$0: Please tell bug-autoconf@gnu.org about your system,
-$0: including any error possibly output before this
-$0: message. Then install a modern shell, or manually run
-$0: the script under such a shell if you do have one."
-  fi
-  exit 1
-fi
-fi
-fi
-SHELL=${CONFIG_SHELL-/bin/sh}
-export SHELL
-# Unset more variables known to interfere with behavior of common tools.
-CLICOLOR_FORCE= GREP_OPTIONS=
-unset CLICOLOR_FORCE GREP_OPTIONS
-
-## --------------------- ##
-## M4sh Shell Functions. ##
-## --------------------- ##
-# as_fn_unset VAR
-# ---------------
-# Portably unset VAR.
-as_fn_unset ()
-{
-  { eval $1=; unset $1;}
-}
-as_unset=as_fn_unset
-
-# as_fn_set_status STATUS
-# -----------------------
-# Set $? to STATUS, without forking.
-as_fn_set_status ()
-{
-  return $1
-} # as_fn_set_status
-
-# as_fn_exit STATUS
-# -----------------
-# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
-as_fn_exit ()
-{
-  set +e
-  as_fn_set_status $1
-  exit $1
-} # as_fn_exit
-
-# as_fn_mkdir_p
-# -------------
-# Create "$as_dir" as a directory, including parents if necessary.
-as_fn_mkdir_p ()
-{
-
-  case $as_dir in #(
-  -*) as_dir=./$as_dir;;
-  esac
-  test -d "$as_dir" || eval $as_mkdir_p || {
-    as_dirs=
-    while :; do
-      case $as_dir in #(
-      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
-      *) as_qdir=$as_dir;;
-      esac
-      as_dirs="'$as_qdir' $as_dirs"
-      as_dir=`$as_dirname -- "$as_dir" ||
-$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_dir" : 'X\(//\)[^/]' \| \
-	 X"$as_dir" : 'X\(//\)$' \| \
-	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_dir" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      test -d "$as_dir" && break
-    done
-    test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
-
-
-} # as_fn_mkdir_p
-# as_fn_append VAR VALUE
-# ----------------------
-# Append the text in VALUE to the end of the definition contained in VAR. Take
-# advantage of any shell optimizations that allow amortized linear growth over
-# repeated appends, instead of the typical quadratic growth present in naive
-# implementations.
-if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
-  eval 'as_fn_append ()
-  {
-    eval $1+=\$2
-  }'
-else
-  as_fn_append ()
-  {
-    eval $1=\$$1\$2
-  }
-fi # as_fn_append
-
-# as_fn_arith ARG...
-# ------------------
-# Perform arithmetic evaluation on the ARGs, and store the result in the
-# global $as_val. Take advantage of shells that can avoid forks. The arguments
-# must be portable across $(()) and expr.
-if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
-  eval 'as_fn_arith ()
-  {
-    as_val=$(( $* ))
-  }'
-else
-  as_fn_arith ()
-  {
-    as_val=`expr "$@" || test $? -eq 1`
-  }
-fi # as_fn_arith
-
-
-# as_fn_error ERROR [LINENO LOG_FD]
-# ---------------------------------
-# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
-# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with status $?, using 1 if that was 0.
-as_fn_error ()
-{
-  as_status=$?; test $as_status -eq 0 && as_status=1
-  if test "$3"; then
-    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
-  fi
-  $as_echo "$as_me: error: $1" >&2
-  as_fn_exit $as_status
-} # as_fn_error
-
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
-  as_basename=basename
-else
-  as_basename=false
-fi
-
-if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
-  as_dirname=dirname
-else
-  as_dirname=false
-fi
-
-as_me=`$as_basename -- "$0" ||
-$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
-	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X/"$0" |
-    sed '/^.*\/\([^/][^/]*\)\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
-
-  as_lineno_1=$LINENO as_lineno_1a=$LINENO
-  as_lineno_2=$LINENO as_lineno_2a=$LINENO
-  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
-  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
-  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
-  sed -n '
-    p
-    /[$]LINENO/=
-  ' <$as_myself |
-    sed '
-      s/[$]LINENO.*/&-/
-      t lineno
-      b
-      :lineno
-      N
-      :loop
-      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
-      t loop
-      s/-\n.*//
-    ' >$as_me.lineno &&
-  chmod +x "$as_me.lineno" ||
-    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
-
-  # Don't try to exec as it changes $[0], causing all sort of problems
-  # (the dirname of $[0] is not the place where we might find the
-  # original and so on.  Autoconf is especially sensitive to this).
-  . "./$as_me.lineno"
-  # Exit status is that of the last command.
-  exit
-}
-
-ECHO_C= ECHO_N= ECHO_T=
-case `echo -n x` in #(((((
--n*)
-  case `echo 'xy\c'` in
-  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
-  xy)  ECHO_C='\c';;
-  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
-       ECHO_T='	';;
-  esac;;
-*)
-  ECHO_N='-n';;
-esac
-
-rm -f conf$$ conf$$.exe conf$$.file
-if test -d conf$$.dir; then
-  rm -f conf$$.dir/conf$$.file
-else
-  rm -f conf$$.dir
-  mkdir conf$$.dir 2>/dev/null
-fi
-if (echo >conf$$.file) 2>/dev/null; then
-  if ln -s conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s='ln -s'
-    # ... but there are two gotchas:
-    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
-    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
-    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
-  elif ln conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s=ln
-  else
-    as_ln_s='cp -p'
-  fi
-else
-  as_ln_s='cp -p'
-fi
-rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
-rmdir conf$$.dir 2>/dev/null
-
-if mkdir -p . 2>/dev/null; then
-  as_mkdir_p='mkdir -p "$as_dir"'
-else
-  test -d ./-p && rmdir ./-p
-  as_mkdir_p=false
-fi
-
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
-
-# Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
-
-# Sed expression to map a string onto a valid variable name.
-as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
-
-SHELL=${CONFIG_SHELL-/bin/sh}
-
-
-exec 7<&0 </dev/null 6>&1
-
-# Name of the host.
-# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
-# so uname gets run too.
-ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
-
-#
-# Initializations.
-#
-ac_default_prefix=/usr/local
-ac_clean_files=
-ac_config_libobj_dir=.
-LIBOBJS=
-cross_compiling=no
-subdirs=
-MFLAGS=
-MAKEFLAGS=
-
-# Identity of this package.
-PACKAGE_NAME=
-PACKAGE_TARNAME=
-PACKAGE_VERSION=
-PACKAGE_STRING=
-PACKAGE_BUGREPORT=
-PACKAGE_URL=
-
-ac_unique_file="zlib.h"
-# Factoring default headers for most tests.
-ac_includes_default="\
-#include <stdio.h>
-#ifdef HAVE_SYS_TYPES_H
-# include <sys/types.h>
-#endif
-#ifdef HAVE_SYS_STAT_H
-# include <sys/stat.h>
-#endif
-#ifdef STDC_HEADERS
-# include <stdlib.h>
-# include <stddef.h>
-#else
-# ifdef HAVE_STDLIB_H
-#  include <stdlib.h>
-# endif
-#endif
-#ifdef HAVE_STRING_H
-# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
-#  include <memory.h>
-# endif
-# include <string.h>
-#endif
-#ifdef HAVE_STRINGS_H
-# include <strings.h>
-#endif
-#ifdef HAVE_INTTYPES_H
-# include <inttypes.h>
-#endif
-#ifdef HAVE_STDINT_H
-# include <stdint.h>
-#endif
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif"
-
-ac_subst_vars='am__EXEEXT_FALSE
-am__EXEEXT_TRUE
-LTLIBOBJS
-LIBOBJS
-TARGET_LIBRARY_FALSE
-TARGET_LIBRARY_TRUE
-toolexeclibdir
-toolexecdir
-target_all
-CPP
-OTOOL64
-OTOOL
-LIPO
-NMEDIT
-DSYMUTIL
-RANLIB
-AR
-OBJDUMP
-LN_S
-NM
-ac_ct_DUMPBIN
-DUMPBIN
-LD
-FGREP
-EGREP
-GREP
-SED
-LIBTOOL
-am__fastdepCC_FALSE
-am__fastdepCC_TRUE
-CCDEPMODE
-AMDEPBACKSLASH
-AMDEP_FALSE
-AMDEP_TRUE
-am__quote
-am__include
-DEPDIR
-OBJEXT
-EXEEXT
-ac_ct_CC
-CPPFLAGS
-LDFLAGS
-CFLAGS
-CC
-COMPPATH
-MAINT
-MAINTAINER_MODE_FALSE
-MAINTAINER_MODE_TRUE
-am__untar
-am__tar
-AMTAR
-am__leading_dot
-SET_MAKE
-AWK
-mkdir_p
-MKDIR_P
-INSTALL_STRIP_PROGRAM
-STRIP
-install_sh
-MAKEINFO
-AUTOHEADER
-AUTOMAKE
-AUTOCONF
-ACLOCAL
-VERSION
-PACKAGE
-CYGPATH_W
-am__isrc
-INSTALL_DATA
-INSTALL_SCRIPT
-INSTALL_PROGRAM
-mkinstalldirs
-target_os
-target_vendor
-target_cpu
-target
-host_os
-host_vendor
-host_cpu
-host
-build_os
-build_vendor
-build_cpu
-build
-multi_basedir
-target_alias
-host_alias
-build_alias
-LIBS
-ECHO_T
-ECHO_N
-ECHO_C
-DEFS
-mandir
-localedir
-libdir
-psdir
-pdfdir
-dvidir
-htmldir
-infodir
-docdir
-oldincludedir
-includedir
-localstatedir
-sharedstatedir
-sysconfdir
-datadir
-datarootdir
-libexecdir
-sbindir
-bindir
-program_transform_name
-prefix
-exec_prefix
-PACKAGE_URL
-PACKAGE_BUGREPORT
-PACKAGE_STRING
-PACKAGE_VERSION
-PACKAGE_TARNAME
-PACKAGE_NAME
-PATH_SEPARATOR
-SHELL'
-ac_subst_files=''
-ac_user_opts='
-enable_option_checking
-enable_multilib
-enable_maintainer_mode
-with_target_subdir
-with_cross_host
-with_system_zlib
-enable_dependency_tracking
-enable_shared
-enable_static
-with_pic
-enable_fast_install
-with_gnu_ld
-enable_libtool_lock
-'
-      ac_precious_vars='build_alias
-host_alias
-target_alias
-CPP
-CPPFLAGS'
-
-
-# Initialize some variables set by options.
-ac_init_help=
-ac_init_version=false
-ac_unrecognized_opts=
-ac_unrecognized_sep=
-# The variables have the same names as the options, with
-# dashes changed to underlines.
-cache_file=/dev/null
-exec_prefix=NONE
-no_create=
-no_recursion=
-prefix=NONE
-program_prefix=NONE
-program_suffix=NONE
-program_transform_name=s,x,x,
-silent=
-site=
-srcdir=
-verbose=
-x_includes=NONE
-x_libraries=NONE
-
-# Installation directory options.
-# These are left unexpanded so users can "make install exec_prefix=/foo"
-# and all the variables that are supposed to be based on exec_prefix
-# by default will actually change.
-# Use braces instead of parens because sh, perl, etc. also accept them.
-# (The list follows the same order as the GNU Coding Standards.)
-bindir='${exec_prefix}/bin'
-sbindir='${exec_prefix}/sbin'
-libexecdir='${exec_prefix}/libexec'
-datarootdir='${prefix}/share'
-datadir='${datarootdir}'
-sysconfdir='${prefix}/etc'
-sharedstatedir='${prefix}/com'
-localstatedir='${prefix}/var'
-includedir='${prefix}/include'
-oldincludedir='/usr/include'
-docdir='${datarootdir}/doc/${PACKAGE}'
-infodir='${datarootdir}/info'
-htmldir='${docdir}'
-dvidir='${docdir}'
-pdfdir='${docdir}'
-psdir='${docdir}'
-libdir='${exec_prefix}/lib'
-localedir='${datarootdir}/locale'
-mandir='${datarootdir}/man'
-
-ac_prev=
-ac_dashdash=
-for ac_option
-do
-  # If the previous option needs an argument, assign it.
-  if test -n "$ac_prev"; then
-    eval $ac_prev=\$ac_option
-    ac_prev=
-    continue
-  fi
-
-  case $ac_option in
-  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
-  *)	ac_optarg=yes ;;
-  esac
-
-  # Accept the important Cygnus configure options, so we can diagnose typos.
-
-  case $ac_dashdash$ac_option in
-  --)
-    ac_dashdash=yes ;;
-
-  -bindir | --bindir | --bindi | --bind | --bin | --bi)
-    ac_prev=bindir ;;
-  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
-    bindir=$ac_optarg ;;
-
-  -build | --build | --buil | --bui | --bu)
-    ac_prev=build_alias ;;
-  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
-    build_alias=$ac_optarg ;;
-
-  -cache-file | --cache-file | --cache-fil | --cache-fi \
-  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
-    ac_prev=cache_file ;;
-  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
-  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
-    cache_file=$ac_optarg ;;
-
-  --config-cache | -C)
-    cache_file=config.cache ;;
-
-  -datadir | --datadir | --datadi | --datad)
-    ac_prev=datadir ;;
-  -datadir=* | --datadir=* | --datadi=* | --datad=*)
-    datadir=$ac_optarg ;;
-
-  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
-  | --dataroo | --dataro | --datar)
-    ac_prev=datarootdir ;;
-  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
-  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
-    datarootdir=$ac_optarg ;;
-
-  -disable-* | --disable-*)
-    ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid feature name: $ac_useropt"
-    ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
-    case $ac_user_opts in
-      *"
-"enable_$ac_useropt"
-"*) ;;
-      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig"
-	 ac_unrecognized_sep=', ';;
-    esac
-    eval enable_$ac_useropt=no ;;
-
-  -docdir | --docdir | --docdi | --doc | --do)
-    ac_prev=docdir ;;
-  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
-    docdir=$ac_optarg ;;
-
-  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
-    ac_prev=dvidir ;;
-  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
-    dvidir=$ac_optarg ;;
-
-  -enable-* | --enable-*)
-    ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid feature name: $ac_useropt"
-    ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
-    case $ac_user_opts in
-      *"
-"enable_$ac_useropt"
-"*) ;;
-      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig"
-	 ac_unrecognized_sep=', ';;
-    esac
-    eval enable_$ac_useropt=\$ac_optarg ;;
-
-  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
-  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
-  | --exec | --exe | --ex)
-    ac_prev=exec_prefix ;;
-  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
-  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
-  | --exec=* | --exe=* | --ex=*)
-    exec_prefix=$ac_optarg ;;
-
-  -gas | --gas | --ga | --g)
-    # Obsolete; use --with-gas.
-    with_gas=yes ;;
-
-  -help | --help | --hel | --he | -h)
-    ac_init_help=long ;;
-  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
-    ac_init_help=recursive ;;
-  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
-    ac_init_help=short ;;
-
-  -host | --host | --hos | --ho)
-    ac_prev=host_alias ;;
-  -host=* | --host=* | --hos=* | --ho=*)
-    host_alias=$ac_optarg ;;
-
-  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
-    ac_prev=htmldir ;;
-  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
-  | --ht=*)
-    htmldir=$ac_optarg ;;
-
-  -includedir | --includedir | --includedi | --included | --include \
-  | --includ | --inclu | --incl | --inc)
-    ac_prev=includedir ;;
-  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
-  | --includ=* | --inclu=* | --incl=* | --inc=*)
-    includedir=$ac_optarg ;;
-
-  -infodir | --infodir | --infodi | --infod | --info | --inf)
-    ac_prev=infodir ;;
-  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
-    infodir=$ac_optarg ;;
-
-  -libdir | --libdir | --libdi | --libd)
-    ac_prev=libdir ;;
-  -libdir=* | --libdir=* | --libdi=* | --libd=*)
-    libdir=$ac_optarg ;;
-
-  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
-  | --libexe | --libex | --libe)
-    ac_prev=libexecdir ;;
-  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
-  | --libexe=* | --libex=* | --libe=*)
-    libexecdir=$ac_optarg ;;
-
-  -localedir | --localedir | --localedi | --localed | --locale)
-    ac_prev=localedir ;;
-  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
-    localedir=$ac_optarg ;;
-
-  -localstatedir | --localstatedir | --localstatedi | --localstated \
-  | --localstate | --localstat | --localsta | --localst | --locals)
-    ac_prev=localstatedir ;;
-  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
-  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
-    localstatedir=$ac_optarg ;;
-
-  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
-    ac_prev=mandir ;;
-  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
-    mandir=$ac_optarg ;;
-
-  -nfp | --nfp | --nf)
-    # Obsolete; use --without-fp.
-    with_fp=no ;;
-
-  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
-  | --no-cr | --no-c | -n)
-    no_create=yes ;;
-
-  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
-  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
-    no_recursion=yes ;;
-
-  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
-  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
-  | --oldin | --oldi | --old | --ol | --o)
-    ac_prev=oldincludedir ;;
-  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
-  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
-  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
-    oldincludedir=$ac_optarg ;;
-
-  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
-    ac_prev=prefix ;;
-  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
-    prefix=$ac_optarg ;;
-
-  -program-prefix | --program-prefix | --program-prefi | --program-pref \
-  | --program-pre | --program-pr | --program-p)
-    ac_prev=program_prefix ;;
-  -program-prefix=* | --program-prefix=* | --program-prefi=* \
-  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
-    program_prefix=$ac_optarg ;;
-
-  -program-suffix | --program-suffix | --program-suffi | --program-suff \
-  | --program-suf | --program-su | --program-s)
-    ac_prev=program_suffix ;;
-  -program-suffix=* | --program-suffix=* | --program-suffi=* \
-  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
-    program_suffix=$ac_optarg ;;
-
-  -program-transform-name | --program-transform-name \
-  | --program-transform-nam | --program-transform-na \
-  | --program-transform-n | --program-transform- \
-  | --program-transform | --program-transfor \
-  | --program-transfo | --program-transf \
-  | --program-trans | --program-tran \
-  | --progr-tra | --program-tr | --program-t)
-    ac_prev=program_transform_name ;;
-  -program-transform-name=* | --program-transform-name=* \
-  | --program-transform-nam=* | --program-transform-na=* \
-  | --program-transform-n=* | --program-transform-=* \
-  | --program-transform=* | --program-transfor=* \
-  | --program-transfo=* | --program-transf=* \
-  | --program-trans=* | --program-tran=* \
-  | --progr-tra=* | --program-tr=* | --program-t=*)
-    program_transform_name=$ac_optarg ;;
-
-  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
-    ac_prev=pdfdir ;;
-  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
-    pdfdir=$ac_optarg ;;
-
-  -psdir | --psdir | --psdi | --psd | --ps)
-    ac_prev=psdir ;;
-  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
-    psdir=$ac_optarg ;;
-
-  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-  | -silent | --silent | --silen | --sile | --sil)
-    silent=yes ;;
-
-  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
-    ac_prev=sbindir ;;
-  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
-  | --sbi=* | --sb=*)
-    sbindir=$ac_optarg ;;
-
-  -sharedstatedir | --sharedstatedir | --sharedstatedi \
-  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
-  | --sharedst | --shareds | --shared | --share | --shar \
-  | --sha | --sh)
-    ac_prev=sharedstatedir ;;
-  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
-  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
-  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
-  | --sha=* | --sh=*)
-    sharedstatedir=$ac_optarg ;;
-
-  -site | --site | --sit)
-    ac_prev=site ;;
-  -site=* | --site=* | --sit=*)
-    site=$ac_optarg ;;
-
-  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
-    ac_prev=srcdir ;;
-  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
-    srcdir=$ac_optarg ;;
-
-  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
-  | --syscon | --sysco | --sysc | --sys | --sy)
-    ac_prev=sysconfdir ;;
-  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
-  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
-    sysconfdir=$ac_optarg ;;
-
-  -target | --target | --targe | --targ | --tar | --ta | --t)
-    ac_prev=target_alias ;;
-  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
-    target_alias=$ac_optarg ;;
-
-  -v | -verbose | --verbose | --verbos | --verbo | --verb)
-    verbose=yes ;;
-
-  -version | --version | --versio | --versi | --vers | -V)
-    ac_init_version=: ;;
-
-  -with-* | --with-*)
-    ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid package name: $ac_useropt"
-    ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
-    case $ac_user_opts in
-      *"
-"with_$ac_useropt"
-"*) ;;
-      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig"
-	 ac_unrecognized_sep=', ';;
-    esac
-    eval with_$ac_useropt=\$ac_optarg ;;
-
-  -without-* | --without-*)
-    ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid package name: $ac_useropt"
-    ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
-    case $ac_user_opts in
-      *"
-"with_$ac_useropt"
-"*) ;;
-      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig"
-	 ac_unrecognized_sep=', ';;
-    esac
-    eval with_$ac_useropt=no ;;
-
-  --x)
-    # Obsolete; use --with-x.
-    with_x=yes ;;
-
-  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
-  | --x-incl | --x-inc | --x-in | --x-i)
-    ac_prev=x_includes ;;
-  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
-  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
-    x_includes=$ac_optarg ;;
-
-  -x-libraries | --x-libraries | --x-librarie | --x-librari \
-  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
-    ac_prev=x_libraries ;;
-  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
-  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
-    x_libraries=$ac_optarg ;;
-
-  -*) as_fn_error "unrecognized option: \`$ac_option'
-Try \`$0 --help' for more information."
-    ;;
-
-  *=*)
-    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
-    # Reject names that are not valid shell variable names.
-    case $ac_envvar in #(
-      '' | [0-9]* | *[!_$as_cr_alnum]* )
-      as_fn_error "invalid variable name: \`$ac_envvar'" ;;
-    esac
-    eval $ac_envvar=\$ac_optarg
-    export $ac_envvar ;;
-
-  *)
-    # FIXME: should be removed in autoconf 3.0.
-    $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
-    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
-      $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
-    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
-    ;;
-
-  esac
-done
-
-if test -n "$ac_prev"; then
-  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
-  as_fn_error "missing argument to $ac_option"
-fi
-
-if test -n "$ac_unrecognized_opts"; then
-  case $enable_option_checking in
-    no) ;;
-    fatal) as_fn_error "unrecognized options: $ac_unrecognized_opts" ;;
-    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
-  esac
-fi
-
-# Check all directory arguments for consistency.
-for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
-		datadir sysconfdir sharedstatedir localstatedir includedir \
-		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
-		libdir localedir mandir
-do
-  eval ac_val=\$$ac_var
-  # Remove trailing slashes.
-  case $ac_val in
-    */ )
-      ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
-      eval $ac_var=\$ac_val;;
-  esac
-  # Be sure to have absolute directory names.
-  case $ac_val in
-    [\\/$]* | ?:[\\/]* )  continue;;
-    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
-  esac
-  as_fn_error "expected an absolute directory name for --$ac_var: $ac_val"
-done
-
-# There might be people who depend on the old broken behavior: `$host'
-# used to hold the argument of --host etc.
-# FIXME: To remove some day.
-build=$build_alias
-host=$host_alias
-target=$target_alias
-
-# FIXME: To remove some day.
-if test "x$host_alias" != x; then
-  if test "x$build_alias" = x; then
-    cross_compiling=maybe
-    $as_echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
-    If a cross compiler is detected then cross compile mode will be used." >&2
-  elif test "x$build_alias" != "x$host_alias"; then
-    cross_compiling=yes
-  fi
-fi
-
-ac_tool_prefix=
-test -n "$host_alias" && ac_tool_prefix=$host_alias-
-
-test "$silent" = yes && exec 6>/dev/null
-
-
-ac_pwd=`pwd` && test -n "$ac_pwd" &&
-ac_ls_di=`ls -di .` &&
-ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
-  as_fn_error "working directory cannot be determined"
-test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
-  as_fn_error "pwd does not report name of working directory"
-
-
-# Find the source files, if location was not specified.
-if test -z "$srcdir"; then
-  ac_srcdir_defaulted=yes
-  # Try the directory containing this script, then the parent directory.
-  ac_confdir=`$as_dirname -- "$as_myself" ||
-$as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_myself" : 'X\(//\)[^/]' \| \
-	 X"$as_myself" : 'X\(//\)$' \| \
-	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_myself" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-  srcdir=$ac_confdir
-  if test ! -r "$srcdir/$ac_unique_file"; then
-    srcdir=..
-  fi
-else
-  ac_srcdir_defaulted=no
-fi
-if test ! -r "$srcdir/$ac_unique_file"; then
-  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
-  as_fn_error "cannot find sources ($ac_unique_file) in $srcdir"
-fi
-ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
-ac_abs_confdir=`(
-	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error "$ac_msg"
-	pwd)`
-# When building in place, set srcdir=.
-if test "$ac_abs_confdir" = "$ac_pwd"; then
-  srcdir=.
-fi
-# Remove unnecessary trailing slashes from srcdir.
-# Double slashes in file names in object file debugging info
-# mess up M-x gdb in Emacs.
-case $srcdir in
-*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
-esac
-for ac_var in $ac_precious_vars; do
-  eval ac_env_${ac_var}_set=\${${ac_var}+set}
-  eval ac_env_${ac_var}_value=\$${ac_var}
-  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
-  eval ac_cv_env_${ac_var}_value=\$${ac_var}
-done
-
-#
-# Report the --help message.
-#
-if test "$ac_init_help" = "long"; then
-  # Omit some internal or obsolete options to make the list less imposing.
-  # This message is too long to be a string in the A/UX 3.1 sh.
-  cat <<_ACEOF
-\`configure' configures this package to adapt to many kinds of systems.
-
-Usage: $0 [OPTION]... [VAR=VALUE]...
-
-To assign environment variables (e.g., CC, CFLAGS...), specify them as
-VAR=VALUE.  See below for descriptions of some of the useful variables.
-
-Defaults for the options are specified in brackets.
-
-Configuration:
-  -h, --help              display this help and exit
-      --help=short        display options specific to this package
-      --help=recursive    display the short help of all the included packages
-  -V, --version           display version information and exit
-  -q, --quiet, --silent   do not print \`checking...' messages
-      --cache-file=FILE   cache test results in FILE [disabled]
-  -C, --config-cache      alias for \`--cache-file=config.cache'
-  -n, --no-create         do not create output files
-      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
-
-Installation directories:
-  --prefix=PREFIX         install architecture-independent files in PREFIX
-                          [$ac_default_prefix]
-  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
-                          [PREFIX]
-
-By default, \`make install' will install all the files in
-\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
-an installation prefix other than \`$ac_default_prefix' using \`--prefix',
-for instance \`--prefix=\$HOME'.
-
-For better control, use the options below.
-
-Fine tuning of the installation directories:
-  --bindir=DIR            user executables [EPREFIX/bin]
-  --sbindir=DIR           system admin executables [EPREFIX/sbin]
-  --libexecdir=DIR        program executables [EPREFIX/libexec]
-  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
-  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
-  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
-  --libdir=DIR            object code libraries [EPREFIX/lib]
-  --includedir=DIR        C header files [PREFIX/include]
-  --oldincludedir=DIR     C header files for non-gcc [/usr/include]
-  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]
-  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]
-  --infodir=DIR           info documentation [DATAROOTDIR/info]
-  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
-  --mandir=DIR            man documentation [DATAROOTDIR/man]
-  --docdir=DIR            documentation root [DATAROOTDIR/doc/PACKAGE]
-  --htmldir=DIR           html documentation [DOCDIR]
-  --dvidir=DIR            dvi documentation [DOCDIR]
-  --pdfdir=DIR            pdf documentation [DOCDIR]
-  --psdir=DIR             ps documentation [DOCDIR]
-_ACEOF
-
-  cat <<\_ACEOF
-
-Program names:
-  --program-prefix=PREFIX            prepend PREFIX to installed program names
-  --program-suffix=SUFFIX            append SUFFIX to installed program names
-  --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
-
-System types:
-  --build=BUILD     configure for building on BUILD [guessed]
-  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
-  --target=TARGET   configure for building compilers for TARGET [HOST]
-_ACEOF
-fi
-
-if test -n "$ac_init_help"; then
-
-  cat <<\_ACEOF
-
-Optional Features:
-  --disable-option-checking  ignore unrecognized --enable/--with options
-  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
-  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
-  --enable-multilib       build many library versions (default)
-  --enable-maintainer-mode  enable make rules and dependencies not useful
-			  (and sometimes confusing) to the casual installer
-  --disable-dependency-tracking  speeds up one-time build
-  --enable-dependency-tracking   do not reject slow dependency extractors
-  --enable-shared[=PKGS]  build shared libraries [default=yes]
-  --enable-static[=PKGS]  build static libraries [default=yes]
-  --enable-fast-install[=PKGS]
-                          optimize for fast installation [default=yes]
-  --disable-libtool-lock  avoid locking (might break parallel builds)
-
-Optional Packages:
-  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
-  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
-  --with-target-subdir=SUBDIR
-                          configuring in a subdirectory
-  --with-cross-host=HOST  configuring with a cross compiler
-  --with-system-zlib      use installed libz
-  --with-pic              try to use only PIC/non-PIC objects [default=use
-                          both]
-  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]
-
-Some influential environment variables:
-  CC          C compiler command
-  CFLAGS      C compiler flags
-  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
-              nonstandard directory <lib dir>
-  LIBS        libraries to pass to the linker, e.g. -l<library>
-  CPPFLAGS    C/C++/Objective C preprocessor flags, e.g. -I<include dir> if
-              you have headers in a nonstandard directory <include dir>
-  CPP         C preprocessor
-
-Use these variables to override the choices made by `configure' or to help
-it to find libraries and programs with nonstandard names/locations.
-
-Report bugs to the package provider.
-_ACEOF
-ac_status=$?
-fi
-
-if test "$ac_init_help" = "recursive"; then
-  # If there are subdirs, report their specific --help.
-  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
-    test -d "$ac_dir" ||
-      { cd "$srcdir" && ac_pwd=`pwd` && srcdir=. && test -d "$ac_dir"; } ||
-      continue
-    ac_builddir=.
-
-case "$ac_dir" in
-.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
-*)
-  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
-  # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
-  case $ac_top_builddir_sub in
-  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
-  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
-  esac ;;
-esac
-ac_abs_top_builddir=$ac_pwd
-ac_abs_builddir=$ac_pwd$ac_dir_suffix
-# for backward compatibility:
-ac_top_builddir=$ac_top_build_prefix
-
-case $srcdir in
-  .)  # We are building in place.
-    ac_srcdir=.
-    ac_top_srcdir=$ac_top_builddir_sub
-    ac_abs_top_srcdir=$ac_pwd ;;
-  [\\/]* | ?:[\\/]* )  # Absolute name.
-    ac_srcdir=$srcdir$ac_dir_suffix;
-    ac_top_srcdir=$srcdir
-    ac_abs_top_srcdir=$srcdir ;;
-  *) # Relative name.
-    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
-    ac_top_srcdir=$ac_top_build_prefix$srcdir
-    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
-esac
-ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
-
-    cd "$ac_dir" || { ac_status=$?; continue; }
-    # Check for guested configure.
-    if test -f "$ac_srcdir/configure.gnu"; then
-      echo &&
-      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
-    elif test -f "$ac_srcdir/configure"; then
-      echo &&
-      $SHELL "$ac_srcdir/configure" --help=recursive
-    else
-      $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
-    fi || ac_status=$?
-    cd "$ac_pwd" || { ac_status=$?; break; }
-  done
-fi
-
-test -n "$ac_init_help" && exit $ac_status
-if $ac_init_version; then
-  cat <<\_ACEOF
-configure
-generated by GNU Autoconf 2.64
-
-Copyright (C) 2009 Free Software Foundation, Inc.
-This configure script is free software; the Free Software Foundation
-gives unlimited permission to copy, distribute and modify it.
-_ACEOF
-  exit
-fi
-
-## ------------------------ ##
-## Autoconf initialization. ##
-## ------------------------ ##
-
-# ac_fn_c_try_compile LINENO
-# --------------------------
-# Try to compile conftest.$ac_ext, and return whether this succeeded.
-ac_fn_c_try_compile ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext
-  if { { ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compile") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_retval=1
-fi
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-  return $ac_retval
-
-} # ac_fn_c_try_compile
-
-# ac_fn_c_try_link LINENO
-# -----------------------
-# Try to link conftest.$ac_ext, and return whether this succeeded.
-ac_fn_c_try_link ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext conftest$ac_exeext
-  if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_retval=1
-fi
-  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
-  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
-  # interfere with the next link command; also delete a directory that is
-  # left behind by Apple's compiler.  We do this before executing the actions.
-  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-  return $ac_retval
-
-} # ac_fn_c_try_link
-
-# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
-# -------------------------------------------------------
-# Tests whether HEADER exists and can be compiled using the include files in
-# INCLUDES, setting the cache variable VAR accordingly.
-ac_fn_c_check_header_compile ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-#include <$2>
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  eval "$3=yes"
-else
-  eval "$3=no"
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-
-} # ac_fn_c_check_header_compile
-
-# ac_fn_c_try_cpp LINENO
-# ----------------------
-# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
-ac_fn_c_try_cpp ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { { ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-    ac_retval=1
-fi
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-  return $ac_retval
-
-} # ac_fn_c_try_cpp
-
-# ac_fn_c_try_run LINENO
-# ----------------------
-# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
-# that executables *can* be run.
-ac_fn_c_try_run ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
-  { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-       $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-       ac_retval=$ac_status
-fi
-  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-  return $ac_retval
-
-} # ac_fn_c_try_run
-
-# ac_fn_c_check_func LINENO FUNC VAR
-# ----------------------------------
-# Tests whether FUNC exists, setting the cache variable VAR accordingly
-ac_fn_c_check_func ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-/* Define $2 to an innocuous variant, in case <limits.h> declares $2.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $2 innocuous_$2
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $2 (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $2
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $2 ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$2 || defined __stub___$2
-choke me
-#endif
-
-int
-main ()
-{
-return $2 ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  eval "$3=yes"
-else
-  eval "$3=no"
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-
-} # ac_fn_c_check_func
-
-# ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES
-# -------------------------------------------------------
-# Tests whether HEADER exists, giving a warning if it cannot be compiled using
-# the include files in INCLUDES and setting the cache variable VAR
-# accordingly.
-ac_fn_c_check_header_mongrel ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
-  $as_echo_n "(cached) " >&6
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 usability" >&5
-$as_echo_n "checking $2 usability... " >&6; }
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-#include <$2>
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_header_compiler=yes
-else
-  ac_header_compiler=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 presence" >&5
-$as_echo_n "checking $2 presence... " >&6; }
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <$2>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  ac_header_preproc=yes
-else
-  ac_header_preproc=no
-fi
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in #((
-  yes:no: )
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $2: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $2:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $2: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
-    ;;
-esac
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
-  $as_echo_n "(cached) " >&6
-else
-  eval "$3=\$ac_header_compiler"
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-fi
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-
-} # ac_fn_c_check_header_mongrel
-cat >config.log <<_ACEOF
-This file contains any messages produced by compilers while
-running configure, to aid debugging if configure makes a mistake.
-
-It was created by $as_me, which was
-generated by GNU Autoconf 2.64.  Invocation command line was
-
-  $ $0 $@
-
-_ACEOF
-exec 5>>config.log
-{
-cat <<_ASUNAME
-## --------- ##
-## Platform. ##
-## --------- ##
-
-hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
-uname -m = `(uname -m) 2>/dev/null || echo unknown`
-uname -r = `(uname -r) 2>/dev/null || echo unknown`
-uname -s = `(uname -s) 2>/dev/null || echo unknown`
-uname -v = `(uname -v) 2>/dev/null || echo unknown`
-
-/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
-/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
-
-/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
-/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
-/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
-/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
-/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
-/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
-/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
-
-_ASUNAME
-
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    $as_echo "PATH: $as_dir"
-  done
-IFS=$as_save_IFS
-
-} >&5
-
-cat >&5 <<_ACEOF
-
-
-## ----------- ##
-## Core tests. ##
-## ----------- ##
-
-_ACEOF
-
-
-# Keep a trace of the command line.
-# Strip out --no-create and --no-recursion so they do not pile up.
-# Strip out --silent because we don't want to record it for future runs.
-# Also quote any args containing shell meta-characters.
-# Make two passes to allow for proper duplicate-argument suppression.
-ac_configure_args=
-ac_configure_args0=
-ac_configure_args1=
-ac_must_keep_next=false
-for ac_pass in 1 2
-do
-  for ac_arg
-  do
-    case $ac_arg in
-    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
-    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-    | -silent | --silent | --silen | --sile | --sil)
-      continue ;;
-    *\'*)
-      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
-    esac
-    case $ac_pass in
-    1) as_fn_append ac_configure_args0 " '$ac_arg'" ;;
-    2)
-      as_fn_append ac_configure_args1 " '$ac_arg'"
-      if test $ac_must_keep_next = true; then
-	ac_must_keep_next=false # Got value, back to normal.
-      else
-	case $ac_arg in
-	  *=* | --config-cache | -C | -disable-* | --disable-* \
-	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
-	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
-	  | -with-* | --with-* | -without-* | --without-* | --x)
-	    case "$ac_configure_args0 " in
-	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
-	    esac
-	    ;;
-	  -* ) ac_must_keep_next=true ;;
-	esac
-      fi
-      as_fn_append ac_configure_args " '$ac_arg'"
-      ;;
-    esac
-  done
-done
-{ ac_configure_args0=; unset ac_configure_args0;}
-{ ac_configure_args1=; unset ac_configure_args1;}
-
-# When interrupted or exit'd, cleanup temporary files, and complete
-# config.log.  We remove comments because anyway the quotes in there
-# would cause problems or look ugly.
-# WARNING: Use '\'' to represent an apostrophe within the trap.
-# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
-trap 'exit_status=$?
-  # Save into config.log some information that might help in debugging.
-  {
-    echo
-
-    cat <<\_ASBOX
-## ---------------- ##
-## Cache variables. ##
-## ---------------- ##
-_ASBOX
-    echo
-    # The following way of writing the cache mishandles newlines in values,
-(
-  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
-    eval ac_val=\$$ac_var
-    case $ac_val in #(
-    *${as_nl}*)
-      case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
-$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
-      esac
-      case $ac_var in #(
-      _ | IFS | as_nl) ;; #(
-      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
-      *) { eval $ac_var=; unset $ac_var;} ;;
-      esac ;;
-    esac
-  done
-  (set) 2>&1 |
-    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
-    *${as_nl}ac_space=\ *)
-      sed -n \
-	"s/'\''/'\''\\\\'\'''\''/g;
-	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
-      ;; #(
-    *)
-      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
-      ;;
-    esac |
-    sort
-)
-    echo
-
-    cat <<\_ASBOX
-## ----------------- ##
-## Output variables. ##
-## ----------------- ##
-_ASBOX
-    echo
-    for ac_var in $ac_subst_vars
-    do
-      eval ac_val=\$$ac_var
-      case $ac_val in
-      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
-      esac
-      $as_echo "$ac_var='\''$ac_val'\''"
-    done | sort
-    echo
-
-    if test -n "$ac_subst_files"; then
-      cat <<\_ASBOX
-## ------------------- ##
-## File substitutions. ##
-## ------------------- ##
-_ASBOX
-      echo
-      for ac_var in $ac_subst_files
-      do
-	eval ac_val=\$$ac_var
-	case $ac_val in
-	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
-	esac
-	$as_echo "$ac_var='\''$ac_val'\''"
-      done | sort
-      echo
-    fi
-
-    if test -s confdefs.h; then
-      cat <<\_ASBOX
-## ----------- ##
-## confdefs.h. ##
-## ----------- ##
-_ASBOX
-      echo
-      cat confdefs.h
-      echo
-    fi
-    test "$ac_signal" != 0 &&
-      $as_echo "$as_me: caught signal $ac_signal"
-    $as_echo "$as_me: exit $exit_status"
-  } >&5
-  rm -f core *.core core.conftest.* &&
-    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
-    exit $exit_status
-' 0
-for ac_signal in 1 2 13 15; do
-  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal
-done
-ac_signal=0
-
-# confdefs.h avoids OS command line length limits that DEFS can exceed.
-rm -f -r conftest* confdefs.h
-
-$as_echo "/* confdefs.h */" > confdefs.h
-
-# Predefined preprocessor variables.
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_NAME "$PACKAGE_NAME"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_VERSION "$PACKAGE_VERSION"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_STRING "$PACKAGE_STRING"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_URL "$PACKAGE_URL"
-_ACEOF
-
-
-# Let the site file select an alternate cache file if it wants to.
-# Prefer an explicitly selected file to automatically selected ones.
-ac_site_file1=NONE
-ac_site_file2=NONE
-if test -n "$CONFIG_SITE"; then
-  ac_site_file1=$CONFIG_SITE
-elif test "x$prefix" != xNONE; then
-  ac_site_file1=$prefix/share/config.site
-  ac_site_file2=$prefix/etc/config.site
-else
-  ac_site_file1=$ac_default_prefix/share/config.site
-  ac_site_file2=$ac_default_prefix/etc/config.site
-fi
-for ac_site_file in "$ac_site_file1" "$ac_site_file2"
-do
-  test "x$ac_site_file" = xNONE && continue
-  if test -r "$ac_site_file"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
-$as_echo "$as_me: loading site script $ac_site_file" >&6;}
-    sed 's/^/| /' "$ac_site_file" >&5
-    . "$ac_site_file"
-  fi
-done
-
-if test -r "$cache_file"; then
-  # Some versions of bash will fail to source /dev/null (special
-  # files actually), so we avoid doing that.
-  if test -f "$cache_file"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
-$as_echo "$as_me: loading cache $cache_file" >&6;}
-    case $cache_file in
-      [\\/]* | ?:[\\/]* ) . "$cache_file";;
-      *)                      . "./$cache_file";;
-    esac
-  fi
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
-$as_echo "$as_me: creating cache $cache_file" >&6;}
-  >$cache_file
-fi
-
-# Check that the precious variables saved in the cache have kept the same
-# value.
-ac_cache_corrupted=false
-for ac_var in $ac_precious_vars; do
-  eval ac_old_set=\$ac_cv_env_${ac_var}_set
-  eval ac_new_set=\$ac_env_${ac_var}_set
-  eval ac_old_val=\$ac_cv_env_${ac_var}_value
-  eval ac_new_val=\$ac_env_${ac_var}_value
-  case $ac_old_set,$ac_new_set in
-    set,)
-      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
-$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
-      ac_cache_corrupted=: ;;
-    ,set)
-      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
-$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
-      ac_cache_corrupted=: ;;
-    ,);;
-    *)
-      if test "x$ac_old_val" != "x$ac_new_val"; then
-	# differences in whitespace do not lead to failure.
-	ac_old_val_w=`echo x $ac_old_val`
-	ac_new_val_w=`echo x $ac_new_val`
-	if test "$ac_old_val_w" != "$ac_new_val_w"; then
-	  { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
-$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
-	  ac_cache_corrupted=:
-	else
-	  { $as_echo "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
-$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
-	  eval $ac_var=\$ac_old_val
-	fi
-	{ $as_echo "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
-$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
-	{ $as_echo "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
-$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
-      fi;;
-  esac
-  # Pass precious variables to config.status.
-  if test "$ac_new_set" = set; then
-    case $ac_new_val in
-    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
-    *) ac_arg=$ac_var=$ac_new_val ;;
-    esac
-    case " $ac_configure_args " in
-      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
-      *) as_fn_append ac_configure_args " '$ac_arg'" ;;
-    esac
-  fi
-done
-if $ac_cache_corrupted; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-  { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
-$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
-  as_fn_error "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
-fi
-## -------------------- ##
-## Main body of script. ##
-## -------------------- ##
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-
-
-
-
-
-# Default to --enable-multilib
-# Check whether --enable-multilib was given.
-if test "${enable_multilib+set}" = set; then :
-  enableval=$enable_multilib; case "$enableval" in
-  yes) multilib=yes ;;
-  no)  multilib=no ;;
-  *)   as_fn_error "bad value $enableval for multilib option" "$LINENO" 5 ;;
- esac
-else
-  multilib=yes
-fi
-
-
-# We may get other options which we leave undocumented:
-# --with-target-subdir, --with-multisrctop, --with-multisubdir
-# See config-ml.in if you want the gory details.
-
-if test "$srcdir" = "."; then
-  if test "$with_target_subdir" != "."; then
-    multi_basedir="$srcdir/$with_multisrctop../.."
-  else
-    multi_basedir="$srcdir/$with_multisrctop.."
-  fi
-else
-  multi_basedir="$srcdir/.."
-fi
-
-
-# Even if the default multilib is not a cross compilation,
-# it may be that some of the other multilibs are.
-if test $cross_compiling = no && test $multilib = yes \
-   && test "x${with_multisubdir}" != x ; then
-   cross_compiling=maybe
-fi
-
-ac_config_commands="$ac_config_commands default-1"
-
-
-ac_aux_dir=
-for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
-  for ac_t in install-sh install.sh shtool; do
-    if test -f "$ac_dir/$ac_t"; then
-      ac_aux_dir=$ac_dir
-      ac_install_sh="$ac_aux_dir/$ac_t -c"
-      break 2
-    fi
-  done
-done
-if test -z "$ac_aux_dir"; then
-  as_fn_error "cannot find install-sh, install.sh, or shtool in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" "$LINENO" 5
-fi
-
-# These three variables are undocumented and unsupported,
-# and are intended to be withdrawn in a future Autoconf release.
-# They can cause serious problems if a builder's source tree is in a directory
-# whose full name contains unusual characters.
-ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
-ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
-ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
-
-
-# Make sure we can run config.sub.
-$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
-  as_fn_error "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
-$as_echo_n "checking build system type... " >&6; }
-if test "${ac_cv_build+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_build_alias=$build_alias
-test "x$ac_build_alias" = x &&
-  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
-test "x$ac_build_alias" = x &&
-  as_fn_error "cannot guess build type; you must specify one" "$LINENO" 5
-ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
-  as_fn_error "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
-$as_echo "$ac_cv_build" >&6; }
-case $ac_cv_build in
-*-*-*) ;;
-*) as_fn_error "invalid value of canonical build" "$LINENO" 5;;
-esac
-build=$ac_cv_build
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_build
-shift
-build_cpu=$1
-build_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-build_os=$*
-IFS=$ac_save_IFS
-case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
-$as_echo_n "checking host system type... " >&6; }
-if test "${ac_cv_host+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test "x$host_alias" = x; then
-  ac_cv_host=$ac_cv_build
-else
-  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
-    as_fn_error "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
-$as_echo "$ac_cv_host" >&6; }
-case $ac_cv_host in
-*-*-*) ;;
-*) as_fn_error "invalid value of canonical host" "$LINENO" 5;;
-esac
-host=$ac_cv_host
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_host
-shift
-host_cpu=$1
-host_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-host_os=$*
-IFS=$ac_save_IFS
-case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking target system type" >&5
-$as_echo_n "checking target system type... " >&6; }
-if test "${ac_cv_target+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test "x$target_alias" = x; then
-  ac_cv_target=$ac_cv_host
-else
-  ac_cv_target=`$SHELL "$ac_aux_dir/config.sub" $target_alias` ||
-    as_fn_error "$SHELL $ac_aux_dir/config.sub $target_alias failed" "$LINENO" 5
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_target" >&5
-$as_echo "$ac_cv_target" >&6; }
-case $ac_cv_target in
-*-*-*) ;;
-*) as_fn_error "invalid value of canonical target" "$LINENO" 5;;
-esac
-target=$ac_cv_target
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_target
-shift
-target_cpu=$1
-target_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-target_os=$*
-IFS=$ac_save_IFS
-case $target_os in *\ *) target_os=`echo "$target_os" | sed 's/ /-/g'`;; esac
-
-
-# The aliases save the names the user supplied, while $host etc.
-# will get canonicalized.
-test -n "$target_alias" &&
-  test "$program_prefix$program_suffix$program_transform_name" = \
-    NONENONEs,x,x, &&
-  program_prefix=${target_alias}-
-
-
-# This works around an automake problem.
-mkinstalldirs="`cd $ac_aux_dir && ${PWDCMD-pwd}`/mkinstalldirs"
-
-
-am__api_version='1.11'
-
-# Find a good install program.  We prefer a C program (faster),
-# so one script is as good as another.  But avoid the broken or
-# incompatible versions:
-# SysV /etc/install, /usr/sbin/install
-# SunOS /usr/etc/install
-# IRIX /sbin/install
-# AIX /bin/install
-# AmigaOS /C/install, which installs bootblocks on floppy discs
-# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
-# AFS /usr/afsws/bin/install, which mishandles nonexistent args
-# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
-# OS/2's system install, which has a completely different semantic
-# ./install, which can be erroneously created by make from ./install.sh.
-# Reject install programs that cannot install multiple files.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a BSD-compatible install" >&5
-$as_echo_n "checking for a BSD-compatible install... " >&6; }
-if test -z "$INSTALL"; then
-if test "${ac_cv_path_install+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    # Account for people who put trailing slashes in PATH elements.
-case $as_dir/ in #((
-  ./ | .// | /[cC]/* | \
-  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
-  ?:[\\/]os2[\\/]install[\\/]* | ?:[\\/]OS2[\\/]INSTALL[\\/]* | \
-  /usr/ucb/* ) ;;
-  *)
-    # OSF1 and SCO ODT 3.0 have their own names for install.
-    # Don't use installbsd from OSF since it installs stuff as root
-    # by default.
-    for ac_prog in ginstall scoinst install; do
-      for ac_exec_ext in '' $ac_executable_extensions; do
-	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
-	  if test $ac_prog = install &&
-	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
-	    # AIX install.  It has an incompatible calling convention.
-	    :
-	  elif test $ac_prog = install &&
-	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
-	    # program-specific install script used by HP pwplus--don't use.
-	    :
-	  else
-	    rm -rf conftest.one conftest.two conftest.dir
-	    echo one > conftest.one
-	    echo two > conftest.two
-	    mkdir conftest.dir
-	    if "$as_dir/$ac_prog$ac_exec_ext" -c conftest.one conftest.two "`pwd`/conftest.dir" &&
-	      test -s conftest.one && test -s conftest.two &&
-	      test -s conftest.dir/conftest.one &&
-	      test -s conftest.dir/conftest.two
-	    then
-	      ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
-	      break 3
-	    fi
-	  fi
-	fi
-      done
-    done
-    ;;
-esac
-
-  done
-IFS=$as_save_IFS
-
-rm -rf conftest.one conftest.two conftest.dir
-
-fi
-  if test "${ac_cv_path_install+set}" = set; then
-    INSTALL=$ac_cv_path_install
-  else
-    # As a last resort, use the slow shell script.  Don't cache a
-    # value for INSTALL within a source directory, because that will
-    # break other packages using the cache if that directory is
-    # removed, or if the value is a relative name.
-    INSTALL=$ac_install_sh
-  fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $INSTALL" >&5
-$as_echo "$INSTALL" >&6; }
-
-# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
-# It thinks the first close brace ends the variable substitution.
-test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
-
-test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
-
-test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether build environment is sane" >&5
-$as_echo_n "checking whether build environment is sane... " >&6; }
-# Just in case
-sleep 1
-echo timestamp > conftest.file
-# Reject unsafe characters in $srcdir or the absolute working directory
-# name.  Accept space and tab only in the latter.
-am_lf='
-'
-case `pwd` in
-  *[\\\"\#\$\&\'\`$am_lf]*)
-    as_fn_error "unsafe absolute working directory name" "$LINENO" 5;;
-esac
-case $srcdir in
-  *[\\\"\#\$\&\'\`$am_lf\ \	]*)
-    as_fn_error "unsafe srcdir value: \`$srcdir'" "$LINENO" 5;;
-esac
-
-# Do `set' in a subshell so we don't clobber the current shell's
-# arguments.  Must try -L first in case configure is actually a
-# symlink; some systems play weird games with the mod time of symlinks
-# (eg FreeBSD returns the mod time of the symlink's containing
-# directory).
-if (
-   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
-   if test "$*" = "X"; then
-      # -L didn't work.
-      set X `ls -t "$srcdir/configure" conftest.file`
-   fi
-   rm -f conftest.file
-   if test "$*" != "X $srcdir/configure conftest.file" \
-      && test "$*" != "X conftest.file $srcdir/configure"; then
-
-      # If neither matched, then we have a broken ls.  This can happen
-      # if, for instance, CONFIG_SHELL is bash and it inherits a
-      # broken ls alias from the environment.  This has actually
-      # happened.  Such a system could not be considered "sane".
-      as_fn_error "ls -t appears to fail.  Make sure there is not a broken
-alias in your environment" "$LINENO" 5
-   fi
-
-   test "$2" = conftest.file
-   )
-then
-   # Ok.
-   :
-else
-   as_fn_error "newly created file is older than distributed files!
-Check your system clock" "$LINENO" 5
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-test "$program_prefix" != NONE &&
-  program_transform_name="s&^&$program_prefix&;$program_transform_name"
-# Use a double $ so make ignores it.
-test "$program_suffix" != NONE &&
-  program_transform_name="s&\$&$program_suffix&;$program_transform_name"
-# Double any \ or $.
-# By default was `s,x,x', remove it if useless.
-ac_script='s/[\\$]/&&/g;s/;s,x,x,$//'
-program_transform_name=`$as_echo "$program_transform_name" | sed "$ac_script"`
-
-# expand $ac_aux_dir to an absolute path
-am_aux_dir=`cd $ac_aux_dir && pwd`
-
-if test x"${MISSING+set}" != xset; then
-  case $am_aux_dir in
-  *\ * | *\	*)
-    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
-  *)
-    MISSING="\${SHELL} $am_aux_dir/missing" ;;
-  esac
-fi
-# Use eval to expand $SHELL
-if eval "$MISSING --run true"; then
-  am_missing_run="$MISSING --run "
-else
-  am_missing_run=
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`missing' script is too old or missing" >&5
-$as_echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
-fi
-
-if test x"${install_sh}" != xset; then
-  case $am_aux_dir in
-  *\ * | *\	*)
-    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
-  *)
-    install_sh="\${SHELL} $am_aux_dir/install-sh"
-  esac
-fi
-
-# Installed binaries are usually stripped using `strip' when the user
-# run `make install-strip'.  However `strip' might not be the right
-# tool to use in cross-compilation environments, therefore Automake
-# will honor the `STRIP' environment variable to overrule this program.
-if test "$cross_compiling" != no; then
-  if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
-set dummy ${ac_tool_prefix}strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_STRIP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$STRIP"; then
-  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-STRIP=$ac_cv_prog_STRIP
-if test -n "$STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
-$as_echo "$STRIP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_STRIP"; then
-  ac_ct_STRIP=$STRIP
-  # Extract the first word of "strip", so it can be a program name with args.
-set dummy strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_STRIP"; then
-  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_STRIP="strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
-if test -n "$ac_ct_STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
-$as_echo "$ac_ct_STRIP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_STRIP" = x; then
-    STRIP=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    STRIP=$ac_ct_STRIP
-  fi
-else
-  STRIP="$ac_cv_prog_STRIP"
-fi
-
-fi
-INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a thread-safe mkdir -p" >&5
-$as_echo_n "checking for a thread-safe mkdir -p... " >&6; }
-if test -z "$MKDIR_P"; then
-  if test "${ac_cv_path_mkdir+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/opt/sfw/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in mkdir gmkdir; do
-	 for ac_exec_ext in '' $ac_executable_extensions; do
-	   { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; } || continue
-	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
-	     'mkdir (GNU coreutils) '* | \
-	     'mkdir (coreutils) '* | \
-	     'mkdir (fileutils) '4.1*)
-	       ac_cv_path_mkdir=$as_dir/$ac_prog$ac_exec_ext
-	       break 3;;
-	   esac
-	 done
-       done
-  done
-IFS=$as_save_IFS
-
-fi
-
-  if test "${ac_cv_path_mkdir+set}" = set; then
-    MKDIR_P="$ac_cv_path_mkdir -p"
-  else
-    # As a last resort, use the slow shell script.  Don't cache a
-    # value for MKDIR_P within a source directory, because that will
-    # break other packages using the cache if that directory is
-    # removed, or if the value is a relative name.
-    test -d ./--version && rmdir ./--version
-    MKDIR_P="$ac_install_sh -d"
-  fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $MKDIR_P" >&5
-$as_echo "$MKDIR_P" >&6; }
-
-mkdir_p="$MKDIR_P"
-case $mkdir_p in
-  [\\/$]* | ?:[\\/]*) ;;
-  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
-esac
-
-for ac_prog in gawk mawk nawk awk
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_AWK+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$AWK"; then
-  ac_cv_prog_AWK="$AWK" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_AWK="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-AWK=$ac_cv_prog_AWK
-if test -n "$AWK"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AWK" >&5
-$as_echo "$AWK" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$AWK" && break
-done
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} sets \$(MAKE)" >&5
-$as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
-set x ${MAKE-make}
-ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
-if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.make <<\_ACEOF
-SHELL = /bin/sh
-all:
-	@echo '@@@%%%=$(MAKE)=@@@%%%'
-_ACEOF
-# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
-case `${MAKE-make} -f conftest.make 2>/dev/null` in
-  *@@@%%%=?*=@@@%%%*)
-    eval ac_cv_prog_make_${ac_make}_set=yes;;
-  *)
-    eval ac_cv_prog_make_${ac_make}_set=no;;
-esac
-rm -f conftest.make
-fi
-if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-  SET_MAKE=
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-  SET_MAKE="MAKE=${MAKE-make}"
-fi
-
-rm -rf .tst 2>/dev/null
-mkdir .tst 2>/dev/null
-if test -d .tst; then
-  am__leading_dot=.
-else
-  am__leading_dot=_
-fi
-rmdir .tst 2>/dev/null
-
-if test "`cd $srcdir && pwd`" != "`pwd`"; then
-  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
-  # is not polluted with repeated "-I."
-  am__isrc=' -I$(srcdir)'
-  # test to see if srcdir already configured
-  if test -f $srcdir/config.status; then
-    as_fn_error "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
-  fi
-fi
-
-# test whether we have cygpath
-if test -z "$CYGPATH_W"; then
-  if (cygpath --version) >/dev/null 2>/dev/null; then
-    CYGPATH_W='cygpath -w'
-  else
-    CYGPATH_W=echo
-  fi
-fi
-
-
-# Define the identity of the package.
- PACKAGE=zlib
- VERSION=1.1.4
-
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE "$PACKAGE"
-_ACEOF
-
-
-cat >>confdefs.h <<_ACEOF
-#define VERSION "$VERSION"
-_ACEOF
-
-# Some tools Automake needs.
-
-ACLOCAL=${ACLOCAL-"${am_missing_run}aclocal-${am__api_version}"}
-
-
-AUTOCONF=${AUTOCONF-"${am_missing_run}autoconf"}
-
-
-AUTOMAKE=${AUTOMAKE-"${am_missing_run}automake-${am__api_version}"}
-
-
-AUTOHEADER=${AUTOHEADER-"${am_missing_run}autoheader"}
-
-
-MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
-
-# We need awk for the "check" target.  The system "awk" is bad on
-# some platforms.
-# Always define AMTAR for backward compatibility.
-
-AMTAR=${AMTAR-"${am_missing_run}tar"}
-
-am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to enable maintainer-specific portions of Makefiles" >&5
-$as_echo_n "checking whether to enable maintainer-specific portions of Makefiles... " >&6; }
-    # Check whether --enable-maintainer-mode was given.
-if test "${enable_maintainer_mode+set}" = set; then :
-  enableval=$enable_maintainer_mode; USE_MAINTAINER_MODE=$enableval
-else
-  USE_MAINTAINER_MODE=no
-fi
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $USE_MAINTAINER_MODE" >&5
-$as_echo "$USE_MAINTAINER_MODE" >&6; }
-   if test $USE_MAINTAINER_MODE = yes; then
-  MAINTAINER_MODE_TRUE=
-  MAINTAINER_MODE_FALSE='#'
-else
-  MAINTAINER_MODE_TRUE='#'
-  MAINTAINER_MODE_FALSE=
-fi
-
-  MAINT=$MAINTAINER_MODE_TRUE
-
-
-
-
-# Check whether --with-target-subdir was given.
-if test "${with_target_subdir+set}" = set; then :
-  withval=$with_target_subdir;
-fi
-
-
-if test -z "$with_target_subdir" || test "$with_target_subdir" = "."; then
-   COMPPATH=.
-else
-   COMPPATH=..
-fi
-
-
-
-# Check whether --with-cross-host was given.
-if test "${with_cross_host+set}" = set; then :
-  withval=$with_cross_host;
-fi
-
-
-# Check whether --enable-multilib was given.
-if test "${enable_multilib+set}" = set; then :
-  enableval=$enable_multilib; case "${enableval}" in
-  yes) multilib=yes ;;
-  no)  multilib=no ;;
-  *)   as_fn_error "bad value ${enableval} for multilib option" "$LINENO" 5 ;;
- esac
-else
-  test -z "$with_target_subdir" && multilib=no || multilib=yes
-fi
-
-
-# Check whether --with-system-zlib was given.
-if test "${with_system_zlib+set}" = set; then :
-  withval=$with_system_zlib;
-fi
-
-
-# Make sure we don't test executables when making cross-tools.
-
-
-# The same as in boehm-gc and libstdc++. Have to borrow it from there.
-# We must force CC to /not/ be precious variables; otherwise
-# the wrong, non-multilib-adjusted value will be used in multilibs.
-# As a side effect, we have to subst CFLAGS ourselves.
-
-
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
-set dummy ${ac_tool_prefix}gcc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CC="${ac_tool_prefix}gcc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_CC"; then
-  ac_ct_CC=$CC
-  # Extract the first word of "gcc", so it can be a program name with args.
-set dummy gcc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_CC"; then
-  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_CC="gcc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_CC=$ac_cv_prog_ac_ct_CC
-if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
-$as_echo "$ac_ct_CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_CC" = x; then
-    CC=""
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    CC=$ac_ct_CC
-  fi
-else
-  CC="$ac_cv_prog_CC"
-fi
-
-if test -z "$CC"; then
-          if test -n "$ac_tool_prefix"; then
-    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
-set dummy ${ac_tool_prefix}cc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CC="${ac_tool_prefix}cc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  fi
-fi
-if test -z "$CC"; then
-  # Extract the first word of "cc", so it can be a program name with args.
-set dummy cc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-  ac_prog_rejected=no
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
-       ac_prog_rejected=yes
-       continue
-     fi
-    ac_cv_prog_CC="cc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-if test $ac_prog_rejected = yes; then
-  # We found a bogon in the path, so make sure we never use it.
-  set dummy $ac_cv_prog_CC
-  shift
-  if test $# != 0; then
-    # We chose a different compiler from the bogus one.
-    # However, it has the same basename, so the bogon will be chosen
-    # first if we set CC to just the basename; use the full file name.
-    shift
-    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
-  fi
-fi
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$CC"; then
-  if test -n "$ac_tool_prefix"; then
-  for ac_prog in cl.exe
-  do
-    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
-set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-    test -n "$CC" && break
-  done
-fi
-if test -z "$CC"; then
-  ac_ct_CC=$CC
-  for ac_prog in cl.exe
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_CC"; then
-  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_CC="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_CC=$ac_cv_prog_ac_ct_CC
-if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
-$as_echo "$ac_ct_CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$ac_ct_CC" && break
-done
-
-  if test "x$ac_ct_CC" = x; then
-    CC=""
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    CC=$ac_ct_CC
-  fi
-fi
-
-fi
-
-
-test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "no acceptable C compiler found in \$PATH
-See \`config.log' for more details." "$LINENO" 5; }
-
-# Provide some information about the compiler.
-$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
-set X $ac_compile
-ac_compiler=$2
-for ac_option in --version -v -V -qversion; do
-  { { ac_try="$ac_compiler $ac_option >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    sed '10a\
-... rest of stderr output deleted ...
-         10q' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    rm -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-done
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-# FIXME: Cleanup?
-if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
-  gcc_no_link=no
-else
-  gcc_no_link=yes
-fi
-if test x$gcc_no_link = xyes; then
-  # Setting cross_compile will disable run tests; it will
-  # also disable AC_CHECK_FILE but that's generally
-  # correct if we can't link.
-  cross_compiling=yes
-  EXEEXT=
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-ac_clean_files_save=$ac_clean_files
-ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out conftest.out"
-# Try to create an executable without -o first, disregard a.out.
-# It will help us diagnose broken compilers, and finding out an intuition
-# of exeext.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name" >&5
-$as_echo_n "checking for C compiler default output file name... " >&6; }
-ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
-
-# The possible output files:
-ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
-
-ac_rmfiles=
-for ac_file in $ac_files
-do
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
-    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
-  esac
-done
-rm -f $ac_rmfiles
-
-if { { ac_try="$ac_link_default"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link_default") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
-  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
-# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
-# in a Makefile.  We should not override ac_cv_exeext if it was cached,
-# so that the user can short-circuit this test for compilers unknown to
-# Autoconf.
-for ac_file in $ac_files ''
-do
-  test -f "$ac_file" || continue
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
-	;;
-    [ab].out )
-	# We found the default executable, but exeext='' is most
-	# certainly right.
-	break;;
-    *.* )
-	if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
-	then :; else
-	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-	fi
-	# We set ac_cv_exeext here because the later test for it is not
-	# safe: cross compilers may not add the suffix if given an `-o'
-	# argument, so we may need to know it at that point already.
-	# Even if this section looks crufty: it has the advantage of
-	# actually working.
-	break;;
-    * )
-	break;;
-  esac
-done
-test "$ac_cv_exeext" = no && ac_cv_exeext=
-
-else
-  ac_file=''
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_file" >&5
-$as_echo "$ac_file" >&6; }
-if test -z "$ac_file"; then :
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ as_fn_set_status 77
-as_fn_error "C compiler cannot create executables
-See \`config.log' for more details." "$LINENO" 5; }; }
-fi
-ac_exeext=$ac_cv_exeext
-
-# Check that the compiler produces executables we can run.  If not, either
-# the compiler is broken, or we cross compile.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler works" >&5
-$as_echo_n "checking whether the C compiler works... " >&6; }
-# If not cross compiling, check that we can run a simple program.
-if test "$cross_compiling" != yes; then
-  if { ac_try='./$ac_file'
-  { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; }; then
-    cross_compiling=no
-  else
-    if test "$cross_compiling" = maybe; then
-	cross_compiling=yes
-    else
-	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot run C compiled programs.
-If you meant to cross compile, use \`--host'.
-See \`config.log' for more details." "$LINENO" 5; }
-    fi
-  fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-
-rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out conftest.out
-ac_clean_files=$ac_clean_files_save
-# Check that the compiler produces executables we can run.  If not, either
-# the compiler is broken, or we cross compile.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling" >&5
-$as_echo_n "checking whether we are cross compiling... " >&6; }
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $cross_compiling" >&5
-$as_echo "$cross_compiling" >&6; }
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
-$as_echo_n "checking for suffix of executables... " >&6; }
-if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
-  # If both `conftest.exe' and `conftest' are `present' (well, observable)
-# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
-# work properly (i.e., refer to `conftest.exe'), while it won't with
-# `rm'.
-for ac_file in conftest.exe conftest conftest.*; do
-  test -f "$ac_file" || continue
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
-    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-	  break;;
-    * ) break;;
-  esac
-done
-else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot compute suffix of executables: cannot compile and link
-See \`config.log' for more details." "$LINENO" 5; }
-fi
-rm -f conftest$ac_cv_exeext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
-$as_echo "$ac_cv_exeext" >&6; }
-
-rm -f conftest.$ac_ext
-EXEEXT=$ac_cv_exeext
-ac_exeext=$EXEEXT
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
-$as_echo_n "checking for suffix of object files... " >&6; }
-if test "${ac_cv_objext+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.o conftest.obj
-if { { ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compile") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
-  for ac_file in conftest.o conftest.obj conftest.*; do
-  test -f "$ac_file" || continue;
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
-    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
-       break;;
-  esac
-done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot compute suffix of object files: cannot compile
-See \`config.log' for more details." "$LINENO" 5; }
-fi
-rm -f conftest.$ac_cv_objext conftest.$ac_ext
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
-$as_echo "$ac_cv_objext" >&6; }
-OBJEXT=$ac_cv_objext
-ac_objext=$OBJEXT
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
-$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
-if test "${ac_cv_c_compiler_gnu+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-#ifndef __GNUC__
-       choke me
-#endif
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_compiler_gnu=yes
-else
-  ac_compiler_gnu=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-ac_cv_c_compiler_gnu=$ac_compiler_gnu
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
-$as_echo "$ac_cv_c_compiler_gnu" >&6; }
-if test $ac_compiler_gnu = yes; then
-  GCC=yes
-else
-  GCC=
-fi
-ac_test_CFLAGS=${CFLAGS+set}
-ac_save_CFLAGS=$CFLAGS
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
-$as_echo_n "checking whether $CC accepts -g... " >&6; }
-if test "${ac_cv_prog_cc_g+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_save_c_werror_flag=$ac_c_werror_flag
-   ac_c_werror_flag=yes
-   ac_cv_prog_cc_g=no
-   CFLAGS="-g"
-   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_prog_cc_g=yes
-else
-  CFLAGS=""
-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-else
-  ac_c_werror_flag=$ac_save_c_werror_flag
-	 CFLAGS="-g"
-	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_prog_cc_g=yes
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-   ac_c_werror_flag=$ac_save_c_werror_flag
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
-$as_echo "$ac_cv_prog_cc_g" >&6; }
-if test "$ac_test_CFLAGS" = set; then
-  CFLAGS=$ac_save_CFLAGS
-elif test $ac_cv_prog_cc_g = yes; then
-  if test "$GCC" = yes; then
-    CFLAGS="-g -O2"
-  else
-    CFLAGS="-g"
-  fi
-else
-  if test "$GCC" = yes; then
-    CFLAGS="-O2"
-  else
-    CFLAGS=
-  fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
-$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
-if test "${ac_cv_prog_cc_c89+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_prog_cc_c89=no
-ac_save_CC=$CC
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdarg.h>
-#include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
-struct buf { int x; };
-FILE * (*rcsopen) (struct buf *, struct stat *, int);
-static char *e (p, i)
-     char **p;
-     int i;
-{
-  return p[i];
-}
-static char *f (char * (*g) (char **, int), char **p, ...)
-{
-  char *s;
-  va_list v;
-  va_start (v,p);
-  s = g (p, va_arg (v,int));
-  va_end (v);
-  return s;
-}
-
-/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
-   function prototypes and stuff, but not '\xHH' hex character constants.
-   These don't provoke an error unfortunately, instead are silently treated
-   as 'x'.  The following induces an error, until -std is added to get
-   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
-   array size at least.  It's necessary to write '\x00'==0 to get something
-   that's true only with -std.  */
-int osf4_cc_array ['\x00' == 0 ? 1 : -1];
-
-/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
-   inside strings and character constants.  */
-#define FOO(x) 'x'
-int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
-
-int test (int i, double x);
-struct s1 {int (*f) (int a);};
-struct s2 {int (*f) (double a);};
-int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
-int argc;
-char **argv;
-int
-main ()
-{
-return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
-  ;
-  return 0;
-}
-_ACEOF
-for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
-	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
-do
-  CC="$ac_save_CC $ac_arg"
-  if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_prog_cc_c89=$ac_arg
-fi
-rm -f core conftest.err conftest.$ac_objext
-  test "x$ac_cv_prog_cc_c89" != "xno" && break
-done
-rm -f conftest.$ac_ext
-CC=$ac_save_CC
-
-fi
-# AC_CACHE_VAL
-case "x$ac_cv_prog_cc_c89" in
-  x)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
-$as_echo "none needed" >&6; } ;;
-  xno)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
-$as_echo "unsupported" >&6; } ;;
-  *)
-    CC="$CC $ac_cv_prog_cc_c89"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
-$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
-esac
-if test "x$ac_cv_prog_cc_c89" != xno; then :
-
-fi
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-DEPDIR="${am__leading_dot}deps"
-
-ac_config_commands="$ac_config_commands depfiles"
-
-
-am_make=${MAKE-make}
-cat > confinc << 'END'
-am__doit:
-	@echo this is the am__doit target
-.PHONY: am__doit
-END
-# If we don't find an include directive, just comment out the code.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for style of include used by $am_make" >&5
-$as_echo_n "checking for style of include used by $am_make... " >&6; }
-am__include="#"
-am__quote=
-_am_result=none
-# First try GNU make style include.
-echo "include confinc" > confmf
-# Ignore all kinds of additional output from `make'.
-case `$am_make -s -f confmf 2> /dev/null` in #(
-*the\ am__doit\ target*)
-  am__include=include
-  am__quote=
-  _am_result=GNU
-  ;;
-esac
-# Now try BSD make style include.
-if test "$am__include" = "#"; then
-   echo '.include "confinc"' > confmf
-   case `$am_make -s -f confmf 2> /dev/null` in #(
-   *the\ am__doit\ target*)
-     am__include=.include
-     am__quote="\""
-     _am_result=BSD
-     ;;
-   esac
-fi
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $_am_result" >&5
-$as_echo "$_am_result" >&6; }
-rm -f confinc confmf
-
-# Check whether --enable-dependency-tracking was given.
-if test "${enable_dependency_tracking+set}" = set; then :
-  enableval=$enable_dependency_tracking;
-fi
-
-if test "x$enable_dependency_tracking" != xno; then
-  am_depcomp="$ac_aux_dir/depcomp"
-  AMDEPBACKSLASH='\'
-fi
- if test "x$enable_dependency_tracking" != xno; then
-  AMDEP_TRUE=
-  AMDEP_FALSE='#'
-else
-  AMDEP_TRUE='#'
-  AMDEP_FALSE=
-fi
-
-
-
-depcc="$CC"   am_compiler_list=
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
-$as_echo_n "checking dependency style of $depcc... " >&6; }
-if test "${am_cv_CC_dependencies_compiler_type+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
-  # We make a subdir and do the tests there.  Otherwise we can end up
-  # making bogus files that we don't know about and never remove.  For
-  # instance it was reported that on HP-UX the gcc test will end up
-  # making a dummy file named `D' -- because `-MD' means `put the output
-  # in D'.
-  mkdir conftest.dir
-  # Copy depcomp to subdir because otherwise we won't find it if we're
-  # using a relative directory.
-  cp "$am_depcomp" conftest.dir
-  cd conftest.dir
-  # We will build objects and dependencies in a subdirectory because
-  # it helps to detect inapplicable dependency modes.  For instance
-  # both Tru64's cc and ICC support -MD to output dependencies as a
-  # side effect of compilation, but ICC will put the dependencies in
-  # the current directory while Tru64 will put them in the object
-  # directory.
-  mkdir sub
-
-  am_cv_CC_dependencies_compiler_type=none
-  if test "$am_compiler_list" = ""; then
-     am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
-  fi
-  am__universal=false
-  case " $depcc " in #(
-     *\ -arch\ *\ -arch\ *) am__universal=true ;;
-     esac
-
-  for depmode in $am_compiler_list; do
-    # Setup a source with many dependencies, because some compilers
-    # like to wrap large dependency lists on column 80 (with \), and
-    # we should not choose a depcomp mode which is confused by this.
-    #
-    # We need to recreate these files for each test, as the compiler may
-    # overwrite some of them when testing with obscure command lines.
-    # This happens at least with the AIX C compiler.
-    : > sub/conftest.c
-    for i in 1 2 3 4 5 6; do
-      echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
-      # Solaris 8's {/usr,}/bin/sh.
-      touch sub/conftst$i.h
-    done
-    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
-
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
-    # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
-    am__obj=sub/conftest.${OBJEXT-o}
-    am__minus_obj="-o $am__obj"
-    case $depmode in
-    gcc)
-      # This depmode causes a compiler race in universal mode.
-      test "$am__universal" = false || continue
-      ;;
-    nosideeffect)
-      # after this tag, mechanisms are not by side-effect, so they'll
-      # only be used when explicitly requested
-      if test "x$enable_dependency_tracking" = xyes; then
-	continue
-      else
-	break
-      fi
-      ;;
-    msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
-      # not run yet.  These depmodes are late enough in the game, and
-      # so weak that their functioning should not be impacted.
-      am__obj=conftest.${OBJEXT-o}
-      am__minus_obj=
-      ;;
-    none) break ;;
-    esac
-    if depmode=$depmode \
-       source=sub/conftest.c object=$am__obj \
-       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
-       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
-         >/dev/null 2>conftest.err &&
-       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
-       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
-       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
-       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
-      # icc doesn't choke on unknown options, it will just issue warnings
-      # or remarks (even with -Werror).  So we grep stderr for any message
-      # that says an option was ignored or not supported.
-      # When given -MP, icc 7.0 and 7.1 complain thusly:
-      #   icc: Command line warning: ignoring option '-M'; no argument required
-      # The diagnosis changed in icc 8.0:
-      #   icc: Command line remark: option '-MP' not supported
-      if (grep 'ignoring option' conftest.err ||
-          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
-        am_cv_CC_dependencies_compiler_type=$depmode
-        break
-      fi
-    fi
-  done
-
-  cd ..
-  rm -rf conftest.dir
-else
-  am_cv_CC_dependencies_compiler_type=none
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_CC_dependencies_compiler_type" >&5
-$as_echo "$am_cv_CC_dependencies_compiler_type" >&6; }
-CCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type
-
- if
-  test "x$enable_dependency_tracking" != xno \
-  && test "$am_cv_CC_dependencies_compiler_type" = gcc3; then
-  am__fastdepCC_TRUE=
-  am__fastdepCC_FALSE='#'
-else
-  am__fastdepCC_TRUE='#'
-  am__fastdepCC_FALSE=
-fi
-
-
-
-
-
-
-case `pwd` in
-  *\ * | *\	*)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&5
-$as_echo "$as_me: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&2;} ;;
-esac
-
-
-
-macro_version='2.2.7a'
-macro_revision='1.3134'
-
-
-
-
-
-
-
-
-
-
-
-
-
-ltmain="$ac_aux_dir/ltmain.sh"
-
-# Backslashify metacharacters that are still active within
-# double-quoted strings.
-sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
-
-# Same as above, but do not quote variable references.
-double_quote_subst='s/\(["`\\]\)/\\\1/g'
-
-# Sed substitution to delay expansion of an escaped shell variable in a
-# double_quote_subst'ed string.
-delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
-
-# Sed substitution to delay expansion of an escaped single quote.
-delay_single_quote_subst='s/'\''/'\'\\\\\\\'\''/g'
-
-# Sed substitution to avoid accidental globbing in evaled expressions
-no_glob_subst='s/\*/\\\*/g'
-
-ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO
-ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to print strings" >&5
-$as_echo_n "checking how to print strings... " >&6; }
-# Test print first, because it will be a builtin if present.
-if test "X`print -r -- -n 2>/dev/null`" = X-n && \
-   test "X`print -r -- $ECHO 2>/dev/null`" = "X$ECHO"; then
-  ECHO='print -r --'
-elif test "X`printf %s $ECHO 2>/dev/null`" = "X$ECHO"; then
-  ECHO='printf %s\n'
-else
-  # Use this function as a fallback that always works.
-  func_fallback_echo ()
-  {
-    eval 'cat <<_LTECHO_EOF
-$1
-_LTECHO_EOF'
-  }
-  ECHO='func_fallback_echo'
-fi
-
-# func_echo_all arg...
-# Invoke $ECHO with all args, space-separated.
-func_echo_all ()
-{
-    $ECHO ""
-}
-
-case "$ECHO" in
-  printf*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: printf" >&5
-$as_echo "printf" >&6; } ;;
-  print*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: print -r" >&5
-$as_echo "print -r" >&6; } ;;
-  *) { $as_echo "$as_me:${as_lineno-$LINENO}: result: cat" >&5
-$as_echo "cat" >&6; } ;;
-esac
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a sed that does not truncate output" >&5
-$as_echo_n "checking for a sed that does not truncate output... " >&6; }
-if test "${ac_cv_path_SED+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-            ac_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/
-     for ac_i in 1 2 3 4 5 6 7; do
-       ac_script="$ac_script$as_nl$ac_script"
-     done
-     echo "$ac_script" 2>/dev/null | sed 99q >conftest.sed
-     { ac_script=; unset ac_script;}
-     if test -z "$SED"; then
-  ac_path_SED_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in sed gsed; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_SED="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_SED" && $as_test_x "$ac_path_SED"; } || continue
-# Check for GNU ac_path_SED and select it if it is found.
-  # Check for GNU $ac_path_SED
-case `"$ac_path_SED" --version 2>&1` in
-*GNU*)
-  ac_cv_path_SED="$ac_path_SED" ac_path_SED_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo '' >> "conftest.nl"
-    "$ac_path_SED" -f conftest.sed < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_SED_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_SED="$ac_path_SED"
-      ac_path_SED_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_SED_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_SED"; then
-    as_fn_error "no acceptable sed could be found in \$PATH" "$LINENO" 5
-  fi
-else
-  ac_cv_path_SED=$SED
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_SED" >&5
-$as_echo "$ac_cv_path_SED" >&6; }
- SED="$ac_cv_path_SED"
-  rm -f conftest.sed
-
-test -z "$SED" && SED=sed
-Xsed="$SED -e 1s/^X//"
-
-
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
-$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
-if test "${ac_cv_path_GREP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -z "$GREP"; then
-  ac_path_GREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in grep ggrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
-# Check for GNU ac_path_GREP and select it if it is found.
-  # Check for GNU $ac_path_GREP
-case `"$ac_path_GREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'GREP' >> "conftest.nl"
-    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_GREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_GREP="$ac_path_GREP"
-      ac_path_GREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_GREP_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_GREP"; then
-    as_fn_error "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
-  fi
-else
-  ac_cv_path_GREP=$GREP
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
-$as_echo "$ac_cv_path_GREP" >&6; }
- GREP="$ac_cv_path_GREP"
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
-$as_echo_n "checking for egrep... " >&6; }
-if test "${ac_cv_path_EGREP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
-   then ac_cv_path_EGREP="$GREP -E"
-   else
-     if test -z "$EGREP"; then
-  ac_path_EGREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in egrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
-# Check for GNU ac_path_EGREP and select it if it is found.
-  # Check for GNU $ac_path_EGREP
-case `"$ac_path_EGREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'EGREP' >> "conftest.nl"
-    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_EGREP="$ac_path_EGREP"
-      ac_path_EGREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_EGREP_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_EGREP"; then
-    as_fn_error "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
-  fi
-else
-  ac_cv_path_EGREP=$EGREP
-fi
-
-   fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
-$as_echo "$ac_cv_path_EGREP" >&6; }
- EGREP="$ac_cv_path_EGREP"
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for fgrep" >&5
-$as_echo_n "checking for fgrep... " >&6; }
-if test "${ac_cv_path_FGREP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if echo 'ab*c' | $GREP -F 'ab*c' >/dev/null 2>&1
-   then ac_cv_path_FGREP="$GREP -F"
-   else
-     if test -z "$FGREP"; then
-  ac_path_FGREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in fgrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_FGREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_FGREP" && $as_test_x "$ac_path_FGREP"; } || continue
-# Check for GNU ac_path_FGREP and select it if it is found.
-  # Check for GNU $ac_path_FGREP
-case `"$ac_path_FGREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_FGREP="$ac_path_FGREP" ac_path_FGREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'FGREP' >> "conftest.nl"
-    "$ac_path_FGREP" FGREP < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_FGREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_FGREP="$ac_path_FGREP"
-      ac_path_FGREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_FGREP_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_FGREP"; then
-    as_fn_error "no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
-  fi
-else
-  ac_cv_path_FGREP=$FGREP
-fi
-
-   fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_FGREP" >&5
-$as_echo "$ac_cv_path_FGREP" >&6; }
- FGREP="$ac_cv_path_FGREP"
-
-
-test -z "$GREP" && GREP=grep
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-# Check whether --with-gnu-ld was given.
-if test "${with_gnu_ld+set}" = set; then :
-  withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
-else
-  with_gnu_ld=no
-fi
-
-ac_prog=ld
-if test "$GCC" = yes; then
-  # Check if gcc -print-prog-name=ld gives a path.
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
-$as_echo_n "checking for ld used by $CC... " >&6; }
-  case $host in
-  *-*-mingw*)
-    # gcc leaves a trailing carriage return which upsets mingw
-    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
-  *)
-    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
-  esac
-  case $ac_prog in
-    # Accept absolute paths.
-    [\\/]* | ?:[\\/]*)
-      re_direlt='/[^/][^/]*/\.\./'
-      # Canonicalize the pathname of ld
-      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
-      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
-	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
-      done
-      test -z "$LD" && LD="$ac_prog"
-      ;;
-  "")
-    # If it fails, then pretend we aren't using GCC.
-    ac_prog=ld
-    ;;
-  *)
-    # If it is relative, then search for the first ld in PATH.
-    with_gnu_ld=unknown
-    ;;
-  esac
-elif test "$with_gnu_ld" = yes; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU ld" >&5
-$as_echo_n "checking for GNU ld... " >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for non-GNU ld" >&5
-$as_echo_n "checking for non-GNU ld... " >&6; }
-fi
-if test "${lt_cv_path_LD+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -z "$LD"; then
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-  for ac_dir in $PATH; do
-    IFS="$lt_save_ifs"
-    test -z "$ac_dir" && ac_dir=.
-    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
-      lt_cv_path_LD="$ac_dir/$ac_prog"
-      # Check to see if the program is GNU ld.  I'd rather use --version,
-      # but apparently some variants of GNU ld only accept -v.
-      # Break only if it was the GNU/non-GNU ld that we prefer.
-      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
-      *GNU* | *'with BFD'*)
-	test "$with_gnu_ld" != no && break
-	;;
-      *)
-	test "$with_gnu_ld" != yes && break
-	;;
-      esac
-    fi
-  done
-  IFS="$lt_save_ifs"
-else
-  lt_cv_path_LD="$LD" # Let the user override the test with a path.
-fi
-fi
-
-LD="$lt_cv_path_LD"
-if test -n "$LD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
-$as_echo "$LD" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-test -z "$LD" && as_fn_error "no acceptable ld found in \$PATH" "$LINENO" 5
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if the linker ($LD) is GNU ld" >&5
-$as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
-if test "${lt_cv_prog_gnu_ld+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  # I'd rather use --version here, but apparently some GNU lds only accept -v.
-case `$LD -v 2>&1 </dev/null` in
-*GNU* | *'with BFD'*)
-  lt_cv_prog_gnu_ld=yes
-  ;;
-*)
-  lt_cv_prog_gnu_ld=no
-  ;;
-esac
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_gnu_ld" >&5
-$as_echo "$lt_cv_prog_gnu_ld" >&6; }
-with_gnu_ld=$lt_cv_prog_gnu_ld
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for BSD- or MS-compatible name lister (nm)" >&5
-$as_echo_n "checking for BSD- or MS-compatible name lister (nm)... " >&6; }
-if test "${lt_cv_path_NM+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$NM"; then
-  # Let the user override the test.
-  lt_cv_path_NM="$NM"
-else
-  lt_nm_to_check="${ac_tool_prefix}nm"
-  if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
-    lt_nm_to_check="$lt_nm_to_check nm"
-  fi
-  for lt_tmp_nm in $lt_nm_to_check; do
-    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do
-      IFS="$lt_save_ifs"
-      test -z "$ac_dir" && ac_dir=.
-      tmp_nm="$ac_dir/$lt_tmp_nm"
-      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
-	# Check to see if the nm accepts a BSD-compat flag.
-	# Adding the `sed 1q' prevents false positives on HP-UX, which says:
-	#   nm: unknown option "B" ignored
-	# Tru64's nm complains that /dev/null is an invalid object file
-	case `"$tmp_nm" -B /dev/null 2>&1 | sed '1q'` in
-	*/dev/null* | *'Invalid file or object type'*)
-	  lt_cv_path_NM="$tmp_nm -B"
-	  break
-	  ;;
-	*)
-	  case `"$tmp_nm" -p /dev/null 2>&1 | sed '1q'` in
-	  */dev/null*)
-	    lt_cv_path_NM="$tmp_nm -p"
-	    break
-	    ;;
-	  *)
-	    lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
-	    continue # so that we can try to find one that supports BSD flags
-	    ;;
-	  esac
-	  ;;
-	esac
-      fi
-    done
-    IFS="$lt_save_ifs"
-  done
-  : ${lt_cv_path_NM=no}
-fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_path_NM" >&5
-$as_echo "$lt_cv_path_NM" >&6; }
-if test "$lt_cv_path_NM" != "no"; then
-  NM="$lt_cv_path_NM"
-else
-  # Didn't find any BSD compatible name lister, look for dumpbin.
-  if test -n "$DUMPBIN"; then :
-    # Let the user override the test.
-  else
-    if test -n "$ac_tool_prefix"; then
-  for ac_prog in dumpbin "link -dump"
-  do
-    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
-set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_DUMPBIN+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$DUMPBIN"; then
-  ac_cv_prog_DUMPBIN="$DUMPBIN" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_DUMPBIN="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-DUMPBIN=$ac_cv_prog_DUMPBIN
-if test -n "$DUMPBIN"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DUMPBIN" >&5
-$as_echo "$DUMPBIN" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-    test -n "$DUMPBIN" && break
-  done
-fi
-if test -z "$DUMPBIN"; then
-  ac_ct_DUMPBIN=$DUMPBIN
-  for ac_prog in dumpbin "link -dump"
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_DUMPBIN+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_DUMPBIN"; then
-  ac_cv_prog_ac_ct_DUMPBIN="$ac_ct_DUMPBIN" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_DUMPBIN="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_DUMPBIN=$ac_cv_prog_ac_ct_DUMPBIN
-if test -n "$ac_ct_DUMPBIN"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DUMPBIN" >&5
-$as_echo "$ac_ct_DUMPBIN" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$ac_ct_DUMPBIN" && break
-done
-
-  if test "x$ac_ct_DUMPBIN" = x; then
-    DUMPBIN=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    DUMPBIN=$ac_ct_DUMPBIN
-  fi
-fi
-
-    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in
-    *COFF*)
-      DUMPBIN="$DUMPBIN -symbols"
-      ;;
-    *)
-      DUMPBIN=:
-      ;;
-    esac
-  fi
-
-  if test "$DUMPBIN" != ":"; then
-    NM="$DUMPBIN"
-  fi
-fi
-test -z "$NM" && NM=nm
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the name lister ($NM) interface" >&5
-$as_echo_n "checking the name lister ($NM) interface... " >&6; }
-if test "${lt_cv_nm_interface+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_nm_interface="BSD nm"
-  echo "int some_variable = 0;" > conftest.$ac_ext
-  (eval echo "\"\$as_me:$LINENO: $ac_compile\"" >&5)
-  (eval "$ac_compile" 2>conftest.err)
-  cat conftest.err >&5
-  (eval echo "\"\$as_me:$LINENO: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
-  (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
-  cat conftest.err >&5
-  (eval echo "\"\$as_me:$LINENO: output\"" >&5)
-  cat conftest.out >&5
-  if $GREP 'External.*some_variable' conftest.out > /dev/null; then
-    lt_cv_nm_interface="MS dumpbin"
-  fi
-  rm -f conftest*
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_nm_interface" >&5
-$as_echo "$lt_cv_nm_interface" >&6; }
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ln -s works" >&5
-$as_echo_n "checking whether ln -s works... " >&6; }
-LN_S=$as_ln_s
-if test "$LN_S" = "ln -s"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no, using $LN_S" >&5
-$as_echo "no, using $LN_S" >&6; }
-fi
-
-# find the maximum length of command line arguments
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the maximum length of command line arguments" >&5
-$as_echo_n "checking the maximum length of command line arguments... " >&6; }
-if test "${lt_cv_sys_max_cmd_len+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-    i=0
-  teststring="ABCD"
-
-  case $build_os in
-  msdosdjgpp*)
-    # On DJGPP, this test can blow up pretty badly due to problems in libc
-    # (any single argument exceeding 2000 bytes causes a buffer overrun
-    # during glob expansion).  Even if it were fixed, the result of this
-    # check would be larger than it should be.
-    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
-    ;;
-
-  gnu*)
-    # Under GNU Hurd, this test is not required because there is
-    # no limit to the length of command line arguments.
-    # Libtool will interpret -1 as no limit whatsoever
-    lt_cv_sys_max_cmd_len=-1;
-    ;;
-
-  cygwin* | mingw* | cegcc*)
-    # On Win9x/ME, this test blows up -- it succeeds, but takes
-    # about 5 minutes as the teststring grows exponentially.
-    # Worse, since 9x/ME are not pre-emptively multitasking,
-    # you end up with a "frozen" computer, even though with patience
-    # the test eventually succeeds (with a max line length of 256k).
-    # Instead, let's just punt: use the minimum linelength reported by
-    # all of the supported platforms: 8192 (on NT/2K/XP).
-    lt_cv_sys_max_cmd_len=8192;
-    ;;
-
-  mint*)
-    # On MiNT this can take a long time and run out of memory.
-    lt_cv_sys_max_cmd_len=8192;
-    ;;
-
-  amigaos*)
-    # On AmigaOS with pdksh, this test takes hours, literally.
-    # So we just punt and use a minimum line length of 8192.
-    lt_cv_sys_max_cmd_len=8192;
-    ;;
-
-  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
-    # This has been around since 386BSD, at least.  Likely further.
-    if test -x /sbin/sysctl; then
-      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
-    elif test -x /usr/sbin/sysctl; then
-      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
-    else
-      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
-    fi
-    # And add a safety zone
-    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
-    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
-    ;;
-
-  interix*)
-    # We know the value 262144 and hardcode it with a safety zone (like BSD)
-    lt_cv_sys_max_cmd_len=196608
-    ;;
-
-  osf*)
-    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure
-    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
-    # nice to cause kernel panics so lets avoid the loop below.
-    # First set a reasonable default.
-    lt_cv_sys_max_cmd_len=16384
-    #
-    if test -x /sbin/sysconfig; then
-      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
-        *1*) lt_cv_sys_max_cmd_len=-1 ;;
-      esac
-    fi
-    ;;
-  sco3.2v5*)
-    lt_cv_sys_max_cmd_len=102400
-    ;;
-  sysv5* | sco5v6* | sysv4.2uw2*)
-    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
-    if test -n "$kargmax"; then
-      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[	 ]//'`
-    else
-      lt_cv_sys_max_cmd_len=32768
-    fi
-    ;;
-  *)
-    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
-    if test -n "$lt_cv_sys_max_cmd_len"; then
-      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
-      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
-    else
-      # Make teststring a little bigger before we do anything with it.
-      # a 1K string should be a reasonable start.
-      for i in 1 2 3 4 5 6 7 8 ; do
-        teststring=$teststring$teststring
-      done
-      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
-      # If test is not a shell built-in, we'll probably end up computing a
-      # maximum length that is only half of the actual maximum length, but
-      # we can't tell.
-      while { test "X"`func_fallback_echo "$teststring$teststring" 2>/dev/null` \
-	         = "X$teststring$teststring"; } >/dev/null 2>&1 &&
-	      test $i != 17 # 1/2 MB should be enough
-      do
-        i=`expr $i + 1`
-        teststring=$teststring$teststring
-      done
-      # Only check the string length outside the loop.
-      lt_cv_sys_max_cmd_len=`expr "X$teststring" : ".*" 2>&1`
-      teststring=
-      # Add a significant safety factor because C++ compilers can tack on
-      # massive amounts of additional arguments before passing them to the
-      # linker.  It appears as though 1/2 is a usable value.
-      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
-    fi
-    ;;
-  esac
-
-fi
-
-if test -n $lt_cv_sys_max_cmd_len ; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_sys_max_cmd_len" >&5
-$as_echo "$lt_cv_sys_max_cmd_len" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: none" >&5
-$as_echo "none" >&6; }
-fi
-max_cmd_len=$lt_cv_sys_max_cmd_len
-
-
-
-
-
-
-: ${CP="cp -f"}
-: ${MV="mv -f"}
-: ${RM="rm -f"}
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands some XSI constructs" >&5
-$as_echo_n "checking whether the shell understands some XSI constructs... " >&6; }
-# Try some XSI features
-xsi_shell=no
-( _lt_dummy="a/b/c"
-  test "${_lt_dummy##*/},${_lt_dummy%/*},"${_lt_dummy%"$_lt_dummy"}, \
-      = c,a/b,, \
-    && eval 'test $(( 1 + 1 )) -eq 2 \
-    && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
-  && xsi_shell=yes
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $xsi_shell" >&5
-$as_echo "$xsi_shell" >&6; }
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands \"+=\"" >&5
-$as_echo_n "checking whether the shell understands \"+=\"... " >&6; }
-lt_shell_append=no
-( foo=bar; set foo baz; eval "$1+=\$2" && test "$foo" = barbaz ) \
-    >/dev/null 2>&1 \
-  && lt_shell_append=yes
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_shell_append" >&5
-$as_echo "$lt_shell_append" >&6; }
-
-
-if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
-  lt_unset=unset
-else
-  lt_unset=false
-fi
-
-
-
-
-
-# test EBCDIC or ASCII
-case `echo X|tr X '\101'` in
- A) # ASCII based system
-    # \n is not interpreted correctly by Solaris 8 /usr/ucb/tr
-  lt_SP2NL='tr \040 \012'
-  lt_NL2SP='tr \015\012 \040\040'
-  ;;
- *) # EBCDIC based system
-  lt_SP2NL='tr \100 \n'
-  lt_NL2SP='tr \r\n \100\100'
-  ;;
-esac
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $LD option to reload object files" >&5
-$as_echo_n "checking for $LD option to reload object files... " >&6; }
-if test "${lt_cv_ld_reload_flag+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_ld_reload_flag='-r'
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_reload_flag" >&5
-$as_echo "$lt_cv_ld_reload_flag" >&6; }
-reload_flag=$lt_cv_ld_reload_flag
-case $reload_flag in
-"" | " "*) ;;
-*) reload_flag=" $reload_flag" ;;
-esac
-reload_cmds='$LD$reload_flag -o $output$reload_objs'
-case $host_os in
-  darwin*)
-    if test "$GCC" = yes; then
-      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
-    else
-      reload_cmds='$LD$reload_flag -o $output$reload_objs'
-    fi
-    ;;
-esac
-
-
-
-
-
-
-
-
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}objdump", so it can be a program name with args.
-set dummy ${ac_tool_prefix}objdump; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_OBJDUMP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$OBJDUMP"; then
-  ac_cv_prog_OBJDUMP="$OBJDUMP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_OBJDUMP="${ac_tool_prefix}objdump"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-OBJDUMP=$ac_cv_prog_OBJDUMP
-if test -n "$OBJDUMP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OBJDUMP" >&5
-$as_echo "$OBJDUMP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_OBJDUMP"; then
-  ac_ct_OBJDUMP=$OBJDUMP
-  # Extract the first word of "objdump", so it can be a program name with args.
-set dummy objdump; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_OBJDUMP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_OBJDUMP"; then
-  ac_cv_prog_ac_ct_OBJDUMP="$ac_ct_OBJDUMP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_OBJDUMP="objdump"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_OBJDUMP=$ac_cv_prog_ac_ct_OBJDUMP
-if test -n "$ac_ct_OBJDUMP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OBJDUMP" >&5
-$as_echo "$ac_ct_OBJDUMP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_OBJDUMP" = x; then
-    OBJDUMP="false"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    OBJDUMP=$ac_ct_OBJDUMP
-  fi
-else
-  OBJDUMP="$ac_cv_prog_OBJDUMP"
-fi
-
-test -z "$OBJDUMP" && OBJDUMP=objdump
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to recognize dependent libraries" >&5
-$as_echo_n "checking how to recognize dependent libraries... " >&6; }
-if test "${lt_cv_deplibs_check_method+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_file_magic_cmd='$MAGIC_CMD'
-lt_cv_file_magic_test_file=
-lt_cv_deplibs_check_method='unknown'
-# Need to set the preceding variable on all platforms that support
-# interlibrary dependencies.
-# 'none' -- dependencies not supported.
-# `unknown' -- same as none, but documents that we really don't know.
-# 'pass_all' -- all dependencies passed with no checks.
-# 'test_compile' -- check by making test program.
-# 'file_magic [[regex]]' -- check by looking for files in library path
-# which responds to the $file_magic_cmd with a given extended regex.
-# If you have `file' or equivalent on your system and you're not sure
-# whether `pass_all' will *always* work, you probably want this one.
-
-case $host_os in
-aix[4-9]*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-beos*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-bsdi[45]*)
-  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib)'
-  lt_cv_file_magic_cmd='/usr/bin/file -L'
-  lt_cv_file_magic_test_file=/shlib/libc.so
-  ;;
-
-cygwin*)
-  # func_win32_libid is a shell function defined in ltmain.sh
-  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
-  lt_cv_file_magic_cmd='func_win32_libid'
-  ;;
-
-mingw* | pw32*)
-  # Base MSYS/MinGW do not provide the 'file' command needed by
-  # func_win32_libid shell function, so use a weaker test based on 'objdump',
-  # unless we find 'file', for example because we are cross-compiling.
-  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.
-  if ( test "$lt_cv_nm_interface" = "BSD nm" && file / ) >/dev/null 2>&1; then
-    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
-    lt_cv_file_magic_cmd='func_win32_libid'
-  else
-    lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'
-    lt_cv_file_magic_cmd='$OBJDUMP -f'
-  fi
-  ;;
-
-cegcc*)
-  # use the weaker test based on 'objdump'. See mingw*.
-  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'
-  lt_cv_file_magic_cmd='$OBJDUMP -f'
-  ;;
-
-darwin* | rhapsody*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-freebsd* | dragonfly*)
-  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
-    case $host_cpu in
-    i*86 )
-      # Not sure whether the presence of OpenBSD here was a mistake.
-      # Let's accept both of them until this is cleared up.
-      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[3-9]86 (compact )?demand paged shared library'
-      lt_cv_file_magic_cmd=/usr/bin/file
-      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
-      ;;
-    esac
-  else
-    lt_cv_deplibs_check_method=pass_all
-  fi
-  ;;
-
-gnu*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-haiku*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-hpux10.20* | hpux11*)
-  lt_cv_file_magic_cmd=/usr/bin/file
-  case $host_cpu in
-  ia64*)
-    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF-[0-9][0-9]) shared object file - IA64'
-    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so
-    ;;
-  hppa*64*)
-    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\.[0-9]'
-    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl
-    ;;
-  *)
-    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|PA-RISC[0-9]\.[0-9]) shared library'
-    lt_cv_file_magic_test_file=/usr/lib/libc.sl
-    ;;
-  esac
-  ;;
-
-interix[3-9]*)
-  # PIC code is broken on Interix 3.x, that's why |\.a not |_pic\.a here
-  lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|\.a)$'
-  ;;
-
-irix5* | irix6* | nonstopux*)
-  case $LD in
-  *-32|*"-32 ") libmagic=32-bit;;
-  *-n32|*"-n32 ") libmagic=N32;;
-  *-64|*"-64 ") libmagic=64-bit;;
-  *) libmagic=never-match;;
-  esac
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-# This must be Linux ELF.
-linux* | k*bsd*-gnu | kopensolaris*-gnu)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-netbsd*)
-  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
-    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
-  else
-    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|_pic\.a)$'
-  fi
-  ;;
-
-newos6*)
-  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (executable|dynamic lib)'
-  lt_cv_file_magic_cmd=/usr/bin/file
-  lt_cv_file_magic_test_file=/usr/lib/libnls.so
-  ;;
-
-*nto* | *qnx*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-openbsd*)
-  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|\.so|_pic\.a)$'
-  else
-    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
-  fi
-  ;;
-
-osf3* | osf4* | osf5*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-rdos*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-solaris*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-sysv4 | sysv4.3*)
-  case $host_vendor in
-  motorola)
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib) M[0-9][0-9]* Version [0-9]'
-    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`
-    ;;
-  ncr)
-    lt_cv_deplibs_check_method=pass_all
-    ;;
-  sequent)
-    lt_cv_file_magic_cmd='/bin/file'
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )'
-    ;;
-  sni)
-    lt_cv_file_magic_cmd='/bin/file'
-    lt_cv_deplibs_check_method="file_magic ELF [0-9][0-9]*-bit [LM]SB dynamic lib"
-    lt_cv_file_magic_test_file=/lib/libc.so
-    ;;
-  siemens)
-    lt_cv_deplibs_check_method=pass_all
-    ;;
-  pc)
-    lt_cv_deplibs_check_method=pass_all
-    ;;
-  esac
-  ;;
-
-tpf*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-esac
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_deplibs_check_method" >&5
-$as_echo "$lt_cv_deplibs_check_method" >&6; }
-file_magic_cmd=$lt_cv_file_magic_cmd
-deplibs_check_method=$lt_cv_deplibs_check_method
-test -z "$deplibs_check_method" && deplibs_check_method=unknown
-
-
-
-
-
-
-
-
-
-
-
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
-set dummy ${ac_tool_prefix}ar; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_AR+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$AR"; then
-  ac_cv_prog_AR="$AR" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_AR="${ac_tool_prefix}ar"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-AR=$ac_cv_prog_AR
-if test -n "$AR"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
-$as_echo "$AR" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_AR"; then
-  ac_ct_AR=$AR
-  # Extract the first word of "ar", so it can be a program name with args.
-set dummy ar; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_AR+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_AR"; then
-  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_AR="ar"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_AR=$ac_cv_prog_ac_ct_AR
-if test -n "$ac_ct_AR"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
-$as_echo "$ac_ct_AR" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_AR" = x; then
-    AR="false"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    AR=$ac_ct_AR
-  fi
-else
-  AR="$ac_cv_prog_AR"
-fi
-
-test -z "$AR" && AR=ar
-test -z "$AR_FLAGS" && AR_FLAGS=cru
-
-
-
-
-
-
-
-
-
-
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
-set dummy ${ac_tool_prefix}strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_STRIP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$STRIP"; then
-  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-STRIP=$ac_cv_prog_STRIP
-if test -n "$STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
-$as_echo "$STRIP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_STRIP"; then
-  ac_ct_STRIP=$STRIP
-  # Extract the first word of "strip", so it can be a program name with args.
-set dummy strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_STRIP"; then
-  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_STRIP="strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
-if test -n "$ac_ct_STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
-$as_echo "$ac_ct_STRIP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_STRIP" = x; then
-    STRIP=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    STRIP=$ac_ct_STRIP
-  fi
-else
-  STRIP="$ac_cv_prog_STRIP"
-fi
-
-test -z "$STRIP" && STRIP=:
-
-
-
-
-
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
-set dummy ${ac_tool_prefix}ranlib; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_RANLIB+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$RANLIB"; then
-  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-RANLIB=$ac_cv_prog_RANLIB
-if test -n "$RANLIB"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
-$as_echo "$RANLIB" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_RANLIB"; then
-  ac_ct_RANLIB=$RANLIB
-  # Extract the first word of "ranlib", so it can be a program name with args.
-set dummy ranlib; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_RANLIB"; then
-  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_RANLIB="ranlib"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
-if test -n "$ac_ct_RANLIB"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
-$as_echo "$ac_ct_RANLIB" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_RANLIB" = x; then
-    RANLIB=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    RANLIB=$ac_ct_RANLIB
-  fi
-else
-  RANLIB="$ac_cv_prog_RANLIB"
-fi
-
-test -z "$RANLIB" && RANLIB=:
-
-
-
-
-
-
-# Determine commands to create old-style static archives.
-old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'
-old_postinstall_cmds='chmod 644 $oldlib'
-old_postuninstall_cmds=
-
-if test -n "$RANLIB"; then
-  case $host_os in
-  openbsd*)
-    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$oldlib"
-    ;;
-  *)
-    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB \$oldlib"
-    ;;
-  esac
-  old_archive_cmds="$old_archive_cmds~\$RANLIB \$oldlib"
-fi
-
-case $host_os in
-  darwin*)
-    lock_old_archive_extraction=yes ;;
-  *)
-    lock_old_archive_extraction=no ;;
-esac
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-# If no C compiler was specified, use CC.
-LTCC=${LTCC-"$CC"}
-
-# If no C compiler flags were specified, use CFLAGS.
-LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
-
-# Allow CC to be a program name with arguments.
-compiler=$CC
-
-
-# Check for command to grab the raw symbol name followed by C symbol from nm.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking command to parse $NM output from $compiler object" >&5
-$as_echo_n "checking command to parse $NM output from $compiler object... " >&6; }
-if test "${lt_cv_sys_global_symbol_pipe+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-
-# These are sane defaults that work on at least a few old systems.
-# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
-
-# Character class describing NM global symbol codes.
-symcode='[BCDEGRST]'
-
-# Regexp to match symbols that can be accessed directly from C.
-sympat='\([_A-Za-z][_A-Za-z0-9]*\)'
-
-# Define system-specific variables.
-case $host_os in
-aix*)
-  symcode='[BCDT]'
-  ;;
-cygwin* | mingw* | pw32* | cegcc*)
-  symcode='[ABCDGISTW]'
-  ;;
-hpux*)
-  if test "$host_cpu" = ia64; then
-    symcode='[ABCDEGRST]'
-  fi
-  ;;
-irix* | nonstopux*)
-  symcode='[BCDEGRST]'
-  ;;
-osf*)
-  symcode='[BCDEGQRST]'
-  ;;
-solaris*)
-  symcode='[BDRT]'
-  ;;
-sco3.2v5*)
-  symcode='[DT]'
-  ;;
-sysv4.2uw2*)
-  symcode='[DT]'
-  ;;
-sysv5* | sco5v6* | unixware* | OpenUNIX*)
-  symcode='[ABDT]'
-  ;;
-sysv4)
-  symcode='[DFNSTU]'
-  ;;
-esac
-
-# If we're using GNU nm, then use its standard symbol codes.
-case `$NM -V 2>&1` in
-*GNU* | *'with BFD'*)
-  symcode='[ABCDGIRSTW]' ;;
-esac
-
-# Transform an extracted symbol line into a proper C declaration.
-# Some systems (esp. on ia64) link data and code symbols differently,
-# so use this general approach.
-lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
-
-# Transform an extracted symbol line into symbol name and symbol address
-lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"\2\", (void *) \&\2},/p'"
-lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \(lib[^ ]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
-
-# Handle CRLF in mingw tool chain
-opt_cr=
-case $build_os in
-mingw*)
-  opt_cr=`$ECHO 'x\{0,1\}' | tr x '\015'` # option cr in regexp
-  ;;
-esac
-
-# Try without a prefix underscore, then with it.
-for ac_symprfx in "" "_"; do
-
-  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.
-  symxfrm="\\1 $ac_symprfx\\2 \\2"
-
-  # Write the raw and C identifiers.
-  if test "$lt_cv_nm_interface" = "MS dumpbin"; then
-    # Fake it for dumpbin and say T for any non-static function
-    # and D for any global variable.
-    # Also find C++ and __fastcall symbols from MSVC++,
-    # which start with @ or ?.
-    lt_cv_sys_global_symbol_pipe="$AWK '"\
-"     {last_section=section; section=\$ 3};"\
-"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};"\
-"     \$ 0!~/External *\|/{next};"\
-"     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
-"     {if(hide[section]) next};"\
-"     {f=0}; \$ 0~/\(\).*\|/{f=1}; {printf f ? \"T \" : \"D \"};"\
-"     {split(\$ 0, a, /\||\r/); split(a[2], s)};"\
-"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
-"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
-"     ' prfx=^$ac_symprfx"
-  else
-    lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[	 ]\($symcode$symcode*\)[	 ][	 ]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
-  fi
-
-  # Check to see that the pipe works correctly.
-  pipe_works=no
-
-  rm -f conftest*
-  cat > conftest.$ac_ext <<_LT_EOF
-#ifdef __cplusplus
-extern "C" {
-#endif
-char nm_test_var;
-void nm_test_func(void);
-void nm_test_func(void){}
-#ifdef __cplusplus
-}
-#endif
-int main(){nm_test_var='a';nm_test_func();return(0);}
-_LT_EOF
-
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    # Now try to grab the symbols.
-    nlist=conftest.nm
-    if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist\""; } >&5
-  (eval $NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s "$nlist"; then
-      # Try sorting and uniquifying the output.
-      if sort "$nlist" | uniq > "$nlist"T; then
-	mv -f "$nlist"T "$nlist"
-      else
-	rm -f "$nlist"T
-      fi
-
-      # Make sure that we snagged all the symbols we need.
-      if $GREP ' nm_test_var$' "$nlist" >/dev/null; then
-	if $GREP ' nm_test_func$' "$nlist" >/dev/null; then
-	  cat <<_LT_EOF > conftest.$ac_ext
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-_LT_EOF
-	  # Now generate the symbol file.
-	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | $GREP -v main >> conftest.$ac_ext'
-
-	  cat <<_LT_EOF >> conftest.$ac_ext
-
-/* The mapping between symbol names and symbols.  */
-const struct {
-  const char *name;
-  void       *address;
-}
-lt__PROGRAM__LTX_preloaded_symbols[] =
-{
-  { "@PROGRAM@", (void *) 0 },
-_LT_EOF
-	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
-	  cat <<\_LT_EOF >> conftest.$ac_ext
-  {0, (void *) 0}
-};
-
-/* This works around a problem in FreeBSD linker */
-#ifdef FREEBSD_WORKAROUND
-static const void *lt_preloaded_setup() {
-  return lt__PROGRAM__LTX_preloaded_symbols;
-}
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-_LT_EOF
-	  # Now try linking the two files.
-	  mv conftest.$ac_objext conftstm.$ac_objext
-	  lt_save_LIBS="$LIBS"
-	  lt_save_CFLAGS="$CFLAGS"
-	  LIBS="conftstm.$ac_objext"
-	  CFLAGS="$CFLAGS$lt_prog_compiler_no_builtin_flag"
-	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s conftest${ac_exeext}; then
-	    pipe_works=yes
-	  fi
-	  LIBS="$lt_save_LIBS"
-	  CFLAGS="$lt_save_CFLAGS"
-	else
-	  echo "cannot find nm_test_func in $nlist" >&5
-	fi
-      else
-	echo "cannot find nm_test_var in $nlist" >&5
-      fi
-    else
-      echo "cannot run $lt_cv_sys_global_symbol_pipe" >&5
-    fi
-  else
-    echo "$progname: failed program was:" >&5
-    cat conftest.$ac_ext >&5
-  fi
-  rm -rf conftest* conftst*
-
-  # Do not use the global_symbol_pipe unless it works.
-  if test "$pipe_works" = yes; then
-    break
-  else
-    lt_cv_sys_global_symbol_pipe=
-  fi
-done
-
-fi
-
-if test -z "$lt_cv_sys_global_symbol_pipe"; then
-  lt_cv_sys_global_symbol_to_cdecl=
-fi
-if test -z "$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: failed" >&5
-$as_echo "failed" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: ok" >&5
-$as_echo "ok" >&6; }
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-# Check whether --enable-libtool-lock was given.
-if test "${enable_libtool_lock+set}" = set; then :
-  enableval=$enable_libtool_lock;
-fi
-
-test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
-
-# Some flags need to be propagated to the compiler or linker for good
-# libtool support.
-case $host in
-ia64-*-hpux*)
-  # Find out which ABI we are using.
-  echo 'int i;' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    case `/usr/bin/file conftest.$ac_objext` in
-      *ELF-32*)
-	HPUX_IA64_MODE="32"
-	;;
-      *ELF-64*)
-	HPUX_IA64_MODE="64"
-	;;
-    esac
-  fi
-  rm -rf conftest*
-  ;;
-*-*-irix6*)
-  # Find out which ABI we are using.
-  echo '#line '$LINENO' "configure"' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    if test "$lt_cv_prog_gnu_ld" = yes; then
-      case `/usr/bin/file conftest.$ac_objext` in
-	*32-bit*)
-	  LD="${LD-ld} -melf32bsmip"
-	  ;;
-	*N32*)
-	  LD="${LD-ld} -melf32bmipn32"
-	  ;;
-	*64-bit*)
-	  LD="${LD-ld} -melf64bmip"
-	;;
-      esac
-    else
-      case `/usr/bin/file conftest.$ac_objext` in
-	*32-bit*)
-	  LD="${LD-ld} -32"
-	  ;;
-	*N32*)
-	  LD="${LD-ld} -n32"
-	  ;;
-	*64-bit*)
-	  LD="${LD-ld} -64"
-	  ;;
-      esac
-    fi
-  fi
-  rm -rf conftest*
-  ;;
-
-x86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \
-s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
-  # Find out which ABI we are using.
-  echo 'int i;' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    case `/usr/bin/file conftest.o` in
-      *32-bit*)
-	case $host in
-	  x86_64-*kfreebsd*-gnu)
-	    LD="${LD-ld} -m elf_i386_fbsd"
-	    ;;
-	  x86_64-*linux*)
-	    case `/usr/bin/file conftest.o` in
-	      *x86-64*)
-		LD="${LD-ld} -m elf32_x86_64"
-		;;
-	      *)
-		LD="${LD-ld} -m elf_i386"
-		;;
-	    esac
-	    ;;
-	  ppc64-*linux*|powerpc64-*linux*)
-	    LD="${LD-ld} -m elf32ppclinux"
-	    ;;
-	  s390x-*linux*)
-	    LD="${LD-ld} -m elf_s390"
-	    ;;
-	  sparc64-*linux*)
-	    LD="${LD-ld} -m elf32_sparc"
-	    ;;
-	esac
-	;;
-      *64-bit*)
-	case $host in
-	  x86_64-*kfreebsd*-gnu)
-	    LD="${LD-ld} -m elf_x86_64_fbsd"
-	    ;;
-	  x86_64-*linux*)
-	    LD="${LD-ld} -m elf_x86_64"
-	    ;;
-	  ppc*-*linux*|powerpc*-*linux*)
-	    LD="${LD-ld} -m elf64ppc"
-	    ;;
-	  s390*-*linux*|s390*-*tpf*)
-	    LD="${LD-ld} -m elf64_s390"
-	    ;;
-	  sparc*-*linux*)
-	    LD="${LD-ld} -m elf64_sparc"
-	    ;;
-	esac
-	;;
-    esac
-  fi
-  rm -rf conftest*
-  ;;
-
-*-*-sco3.2v5*)
-  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
-  SAVE_CFLAGS="$CFLAGS"
-  CFLAGS="$CFLAGS -belf"
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler needs -belf" >&5
-$as_echo_n "checking whether the C compiler needs -belf... " >&6; }
-if test "${lt_cv_cc_needs_belf+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-     if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  lt_cv_cc_needs_belf=yes
-else
-  lt_cv_cc_needs_belf=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-     ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_cc_needs_belf" >&5
-$as_echo "$lt_cv_cc_needs_belf" >&6; }
-  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
-    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
-    CFLAGS="$SAVE_CFLAGS"
-  fi
-  ;;
-sparc*-*solaris*)
-  # Find out which ABI we are using.
-  echo 'int i;' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    case `/usr/bin/file conftest.o` in
-    *64-bit*)
-      case $lt_cv_prog_gnu_ld in
-      yes*) LD="${LD-ld} -m elf64_sparc" ;;
-      *)
-	if ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then
-	  LD="${LD-ld} -64"
-	fi
-	;;
-      esac
-      ;;
-    esac
-  fi
-  rm -rf conftest*
-  ;;
-esac
-
-need_locks="$enable_libtool_lock"
-
-
-  case $host_os in
-    rhapsody* | darwin*)
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}dsymutil", so it can be a program name with args.
-set dummy ${ac_tool_prefix}dsymutil; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_DSYMUTIL+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$DSYMUTIL"; then
-  ac_cv_prog_DSYMUTIL="$DSYMUTIL" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_DSYMUTIL="${ac_tool_prefix}dsymutil"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-DSYMUTIL=$ac_cv_prog_DSYMUTIL
-if test -n "$DSYMUTIL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DSYMUTIL" >&5
-$as_echo "$DSYMUTIL" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_DSYMUTIL"; then
-  ac_ct_DSYMUTIL=$DSYMUTIL
-  # Extract the first word of "dsymutil", so it can be a program name with args.
-set dummy dsymutil; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_DSYMUTIL+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_DSYMUTIL"; then
-  ac_cv_prog_ac_ct_DSYMUTIL="$ac_ct_DSYMUTIL" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_DSYMUTIL="dsymutil"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_DSYMUTIL=$ac_cv_prog_ac_ct_DSYMUTIL
-if test -n "$ac_ct_DSYMUTIL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DSYMUTIL" >&5
-$as_echo "$ac_ct_DSYMUTIL" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_DSYMUTIL" = x; then
-    DSYMUTIL=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    DSYMUTIL=$ac_ct_DSYMUTIL
-  fi
-else
-  DSYMUTIL="$ac_cv_prog_DSYMUTIL"
-fi
-
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}nmedit", so it can be a program name with args.
-set dummy ${ac_tool_prefix}nmedit; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_NMEDIT+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$NMEDIT"; then
-  ac_cv_prog_NMEDIT="$NMEDIT" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_NMEDIT="${ac_tool_prefix}nmedit"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-NMEDIT=$ac_cv_prog_NMEDIT
-if test -n "$NMEDIT"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $NMEDIT" >&5
-$as_echo "$NMEDIT" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_NMEDIT"; then
-  ac_ct_NMEDIT=$NMEDIT
-  # Extract the first word of "nmedit", so it can be a program name with args.
-set dummy nmedit; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_NMEDIT+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_NMEDIT"; then
-  ac_cv_prog_ac_ct_NMEDIT="$ac_ct_NMEDIT" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_NMEDIT="nmedit"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_NMEDIT=$ac_cv_prog_ac_ct_NMEDIT
-if test -n "$ac_ct_NMEDIT"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_NMEDIT" >&5
-$as_echo "$ac_ct_NMEDIT" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_NMEDIT" = x; then
-    NMEDIT=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    NMEDIT=$ac_ct_NMEDIT
-  fi
-else
-  NMEDIT="$ac_cv_prog_NMEDIT"
-fi
-
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}lipo", so it can be a program name with args.
-set dummy ${ac_tool_prefix}lipo; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_LIPO+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$LIPO"; then
-  ac_cv_prog_LIPO="$LIPO" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_LIPO="${ac_tool_prefix}lipo"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-LIPO=$ac_cv_prog_LIPO
-if test -n "$LIPO"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LIPO" >&5
-$as_echo "$LIPO" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_LIPO"; then
-  ac_ct_LIPO=$LIPO
-  # Extract the first word of "lipo", so it can be a program name with args.
-set dummy lipo; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_LIPO+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_LIPO"; then
-  ac_cv_prog_ac_ct_LIPO="$ac_ct_LIPO" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_LIPO="lipo"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_LIPO=$ac_cv_prog_ac_ct_LIPO
-if test -n "$ac_ct_LIPO"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_LIPO" >&5
-$as_echo "$ac_ct_LIPO" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_LIPO" = x; then
-    LIPO=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    LIPO=$ac_ct_LIPO
-  fi
-else
-  LIPO="$ac_cv_prog_LIPO"
-fi
-
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}otool", so it can be a program name with args.
-set dummy ${ac_tool_prefix}otool; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_OTOOL+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$OTOOL"; then
-  ac_cv_prog_OTOOL="$OTOOL" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_OTOOL="${ac_tool_prefix}otool"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-OTOOL=$ac_cv_prog_OTOOL
-if test -n "$OTOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL" >&5
-$as_echo "$OTOOL" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_OTOOL"; then
-  ac_ct_OTOOL=$OTOOL
-  # Extract the first word of "otool", so it can be a program name with args.
-set dummy otool; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_OTOOL+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_OTOOL"; then
-  ac_cv_prog_ac_ct_OTOOL="$ac_ct_OTOOL" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_OTOOL="otool"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_OTOOL=$ac_cv_prog_ac_ct_OTOOL
-if test -n "$ac_ct_OTOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL" >&5
-$as_echo "$ac_ct_OTOOL" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_OTOOL" = x; then
-    OTOOL=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    OTOOL=$ac_ct_OTOOL
-  fi
-else
-  OTOOL="$ac_cv_prog_OTOOL"
-fi
-
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}otool64", so it can be a program name with args.
-set dummy ${ac_tool_prefix}otool64; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_OTOOL64+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$OTOOL64"; then
-  ac_cv_prog_OTOOL64="$OTOOL64" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_OTOOL64="${ac_tool_prefix}otool64"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-OTOOL64=$ac_cv_prog_OTOOL64
-if test -n "$OTOOL64"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL64" >&5
-$as_echo "$OTOOL64" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_OTOOL64"; then
-  ac_ct_OTOOL64=$OTOOL64
-  # Extract the first word of "otool64", so it can be a program name with args.
-set dummy otool64; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_OTOOL64+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_OTOOL64"; then
-  ac_cv_prog_ac_ct_OTOOL64="$ac_ct_OTOOL64" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_OTOOL64="otool64"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_OTOOL64=$ac_cv_prog_ac_ct_OTOOL64
-if test -n "$ac_ct_OTOOL64"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL64" >&5
-$as_echo "$ac_ct_OTOOL64" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_OTOOL64" = x; then
-    OTOOL64=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    OTOOL64=$ac_ct_OTOOL64
-  fi
-else
-  OTOOL64="$ac_cv_prog_OTOOL64"
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -single_module linker flag" >&5
-$as_echo_n "checking for -single_module linker flag... " >&6; }
-if test "${lt_cv_apple_cc_single_mod+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_apple_cc_single_mod=no
-      if test -z "${LT_MULTI_MODULE}"; then
-	# By default we will add the -single_module flag. You can override
-	# by either setting the environment variable LT_MULTI_MODULE
-	# non-empty at configure time, or by adding -multi_module to the
-	# link flags.
-	rm -rf libconftest.dylib*
-	echo "int foo(void){return 1;}" > conftest.c
-	echo "$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
--dynamiclib -Wl,-single_module conftest.c" >&5
-	$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
-	  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err
-        _lt_result=$?
-	if test -f libconftest.dylib && test ! -s conftest.err && test $_lt_result = 0; then
-	  lt_cv_apple_cc_single_mod=yes
-	else
-	  cat conftest.err >&5
-	fi
-	rm -rf libconftest.dylib*
-	rm -f conftest.*
-      fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_apple_cc_single_mod" >&5
-$as_echo "$lt_cv_apple_cc_single_mod" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -exported_symbols_list linker flag" >&5
-$as_echo_n "checking for -exported_symbols_list linker flag... " >&6; }
-if test "${lt_cv_ld_exported_symbols_list+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_ld_exported_symbols_list=no
-      save_LDFLAGS=$LDFLAGS
-      echo "_main" > conftest.sym
-      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
-      if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  lt_cv_ld_exported_symbols_list=yes
-else
-  lt_cv_ld_exported_symbols_list=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-	LDFLAGS="$save_LDFLAGS"
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_exported_symbols_list" >&5
-$as_echo "$lt_cv_ld_exported_symbols_list" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -force_load linker flag" >&5
-$as_echo_n "checking for -force_load linker flag... " >&6; }
-if test "${lt_cv_ld_force_load+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_ld_force_load=no
-      cat > conftest.c << _LT_EOF
-int forced_loaded() { return 2;}
-_LT_EOF
-      echo "$LTCC $LTCFLAGS -c -o conftest.o conftest.c" >&5
-      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&5
-      echo "$AR cru libconftest.a conftest.o" >&5
-      $AR cru libconftest.a conftest.o 2>&5
-      cat > conftest.c << _LT_EOF
-int main() { return 0;}
-_LT_EOF
-      echo "$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a" >&5
-      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err
-      _lt_result=$?
-      if test -f conftest && test ! -s conftest.err && test $_lt_result = 0 && $GREP forced_load conftest 2>&1 >/dev/null; then
-	lt_cv_ld_force_load=yes
-      else
-	cat conftest.err >&5
-      fi
-        rm -f conftest.err libconftest.a conftest conftest.c
-        rm -rf conftest.dSYM
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_force_load" >&5
-$as_echo "$lt_cv_ld_force_load" >&6; }
-    case $host_os in
-    rhapsody* | darwin1.[012])
-      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
-    darwin1.*)
-      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
-    darwin*) # darwin 5.x on
-      # if running on 10.5 or later, the deployment target defaults
-      # to the OS version, if on x86, and 10.4, the deployment
-      # target defaults to 10.4. Don't you love it?
-      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
-	10.0,*86*-darwin8*|10.0,*-darwin[91]*)
-	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
-	10.[012]*)
-	  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
-	10.*)
-	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
-      esac
-    ;;
-  esac
-    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
-      _lt_dar_single_mod='$single_module'
-    fi
-    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
-      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
-    else
-      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
-    fi
-    if test "$DSYMUTIL" != ":" && test "$lt_cv_ld_force_load" = "no"; then
-      _lt_dsymutil='~$DSYMUTIL $lib || :'
-    else
-      _lt_dsymutil=
-    fi
-    ;;
-  esac
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
-$as_echo_n "checking how to run the C preprocessor... " >&6; }
-# On Suns, sometimes $CPP names a directory.
-if test -n "$CPP" && test -d "$CPP"; then
-  CPP=
-fi
-if test -z "$CPP"; then
-  if test "${ac_cv_prog_CPP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-      # Double quotes because CPP needs to be expanded
-    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
-    do
-      ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-  break
-fi
-
-    done
-    ac_cv_prog_CPP=$CPP
-
-fi
-  CPP=$ac_cv_prog_CPP
-else
-  ac_cv_prog_CPP=$CPP
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
-$as_echo "$CPP" >&6; }
-ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-
-else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details." "$LINENO" 5; }
-fi
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
-$as_echo_n "checking for ANSI C header files... " >&6; }
-if test "${ac_cv_header_stdc+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <float.h>
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_header_stdc=yes
-else
-  ac_cv_header_stdc=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-if test $ac_cv_header_stdc = yes; then
-  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <string.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "memchr" >/dev/null 2>&1; then :
-
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
-
-fi
-
-if test $ac_cv_header_stdc = yes; then
-  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdlib.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "free" >/dev/null 2>&1; then :
-
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
-
-fi
-
-if test $ac_cv_header_stdc = yes; then
-  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
-  if test "$cross_compiling" = yes; then :
-  :
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ctype.h>
-#include <stdlib.h>
-#if ((' ' & 0x0FF) == 0x020)
-# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
-# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
-#else
-# define ISLOWER(c) \
-		   (('a' <= (c) && (c) <= 'i') \
-		     || ('j' <= (c) && (c) <= 'r') \
-		     || ('s' <= (c) && (c) <= 'z'))
-# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
-#endif
-
-#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
-int
-main ()
-{
-  int i;
-  for (i = 0; i < 256; i++)
-    if (XOR (islower (i), ISLOWER (i))
-	|| toupper (i) != TOUPPER (i))
-      return 2;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
-
-else
-  ac_cv_header_stdc=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-fi
-
-fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
-$as_echo "$ac_cv_header_stdc" >&6; }
-if test $ac_cv_header_stdc = yes; then
-
-$as_echo "#define STDC_HEADERS 1" >>confdefs.h
-
-fi
-
-# On IRIX 5.3, sys/types and inttypes.h are conflicting.
-for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
-		  inttypes.h stdint.h unistd.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
-"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-for ac_header in dlfcn.h
-do :
-  ac_fn_c_check_header_compile "$LINENO" "dlfcn.h" "ac_cv_header_dlfcn_h" "$ac_includes_default
-"
-if test "x$ac_cv_header_dlfcn_h" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_DLFCN_H 1
-_ACEOF
-
-fi
-
-done
-
-
-
-
-
-# Set options
-
-
-
-        enable_dlopen=no
-
-
-  enable_win32_dll=no
-
-
-            # Check whether --enable-shared was given.
-if test "${enable_shared+set}" = set; then :
-  enableval=$enable_shared; p=${PACKAGE-default}
-    case $enableval in
-    yes) enable_shared=yes ;;
-    no) enable_shared=no ;;
-    *)
-      enable_shared=no
-      # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
-      for pkg in $enableval; do
-	IFS="$lt_save_ifs"
-	if test "X$pkg" = "X$p"; then
-	  enable_shared=yes
-	fi
-      done
-      IFS="$lt_save_ifs"
-      ;;
-    esac
-else
-  enable_shared=yes
-fi
-
-
-
-
-
-
-
-
-
-  # Check whether --enable-static was given.
-if test "${enable_static+set}" = set; then :
-  enableval=$enable_static; p=${PACKAGE-default}
-    case $enableval in
-    yes) enable_static=yes ;;
-    no) enable_static=no ;;
-    *)
-     enable_static=no
-      # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
-      for pkg in $enableval; do
-	IFS="$lt_save_ifs"
-	if test "X$pkg" = "X$p"; then
-	  enable_static=yes
-	fi
-      done
-      IFS="$lt_save_ifs"
-      ;;
-    esac
-else
-  enable_static=yes
-fi
-
-
-
-
-
-
-
-
-
-
-# Check whether --with-pic was given.
-if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
-else
-  pic_mode=default
-fi
-
-
-test -z "$pic_mode" && pic_mode=default
-
-
-
-
-
-
-
-  # Check whether --enable-fast-install was given.
-if test "${enable_fast_install+set}" = set; then :
-  enableval=$enable_fast_install; p=${PACKAGE-default}
-    case $enableval in
-    yes) enable_fast_install=yes ;;
-    no) enable_fast_install=no ;;
-    *)
-      enable_fast_install=no
-      # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
-      for pkg in $enableval; do
-	IFS="$lt_save_ifs"
-	if test "X$pkg" = "X$p"; then
-	  enable_fast_install=yes
-	fi
-      done
-      IFS="$lt_save_ifs"
-      ;;
-    esac
-else
-  enable_fast_install=yes
-fi
-
-
-
-
-
-
-
-
-
-
-
-# This can be used to rebuild libtool when needed
-LIBTOOL_DEPS="$ltmain"
-
-# Always use our own libtool.
-LIBTOOL='$(SHELL) $(top_builddir)/libtool'
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-test -z "$LN_S" && LN_S="ln -s"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-if test -n "${ZSH_VERSION+set}" ; then
-   setopt NO_GLOB_SUBST
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for objdir" >&5
-$as_echo_n "checking for objdir... " >&6; }
-if test "${lt_cv_objdir+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  rm -f .libs 2>/dev/null
-mkdir .libs 2>/dev/null
-if test -d .libs; then
-  lt_cv_objdir=.libs
-else
-  # MS-DOS does not allow filenames that begin with a dot.
-  lt_cv_objdir=_libs
-fi
-rmdir .libs 2>/dev/null
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_objdir" >&5
-$as_echo "$lt_cv_objdir" >&6; }
-objdir=$lt_cv_objdir
-
-
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define LT_OBJDIR "$lt_cv_objdir/"
-_ACEOF
-
-
-
-
-case $host_os in
-aix3*)
-  # AIX sometimes has problems with the GCC collect2 program.  For some
-  # reason, if we set the COLLECT_NAMES environment variable, the problems
-  # vanish in a puff of smoke.
-  if test "X${COLLECT_NAMES+set}" != Xset; then
-    COLLECT_NAMES=
-    export COLLECT_NAMES
-  fi
-  ;;
-esac
-
-# Global variables:
-ofile=libtool
-can_build_shared=yes
-
-# All known linkers require a `.a' archive for static linking (except MSVC,
-# which needs '.lib').
-libext=a
-
-with_gnu_ld="$lt_cv_prog_gnu_ld"
-
-old_CC="$CC"
-old_CFLAGS="$CFLAGS"
-
-# Set sane defaults for various variables
-test -z "$CC" && CC=cc
-test -z "$LTCC" && LTCC=$CC
-test -z "$LTCFLAGS" && LTCFLAGS=$CFLAGS
-test -z "$LD" && LD=ld
-test -z "$ac_objext" && ac_objext=o
-
-for cc_temp in $compiler""; do
-  case $cc_temp in
-    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
-    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
-    \-*) ;;
-    *) break;;
-  esac
-done
-cc_basename=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
-
-
-# Only perform the check for file, if the check method requires it
-test -z "$MAGIC_CMD" && MAGIC_CMD=file
-case $deplibs_check_method in
-file_magic*)
-  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${ac_tool_prefix}file" >&5
-$as_echo_n "checking for ${ac_tool_prefix}file... " >&6; }
-if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $MAGIC_CMD in
-[\\/*] |  ?:[\\/]*)
-  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
-  ;;
-*)
-  lt_save_MAGIC_CMD="$MAGIC_CMD"
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
-  for ac_dir in $ac_dummy; do
-    IFS="$lt_save_ifs"
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/${ac_tool_prefix}file; then
-      lt_cv_path_MAGIC_CMD="$ac_dir/${ac_tool_prefix}file"
-      if test -n "$file_magic_test_file"; then
-	case $deplibs_check_method in
-	"file_magic "*)
-	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
-	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
-	    $EGREP "$file_magic_regex" > /dev/null; then
-	    :
-	  else
-	    cat <<_LT_EOF 1>&2
-
-*** Warning: the command libtool uses to detect shared libraries,
-*** $file_magic_cmd, produces output that libtool cannot recognize.
-*** The result is that libtool may fail to recognize shared libraries
-*** as such.  This will affect the creation of libtool libraries that
-*** depend on shared libraries, but programs linked with such libtool
-*** libraries will work regardless of this problem.  Nevertheless, you
-*** may want to report the problem to your system manager and/or to
-*** bug-libtool@gnu.org
-
-_LT_EOF
-	  fi ;;
-	esac
-      fi
-      break
-    fi
-  done
-  IFS="$lt_save_ifs"
-  MAGIC_CMD="$lt_save_MAGIC_CMD"
-  ;;
-esac
-fi
-
-MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-if test -n "$MAGIC_CMD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
-$as_echo "$MAGIC_CMD" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-
-
-
-if test -z "$lt_cv_path_MAGIC_CMD"; then
-  if test -n "$ac_tool_prefix"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for file" >&5
-$as_echo_n "checking for file... " >&6; }
-if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $MAGIC_CMD in
-[\\/*] |  ?:[\\/]*)
-  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
-  ;;
-*)
-  lt_save_MAGIC_CMD="$MAGIC_CMD"
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
-  for ac_dir in $ac_dummy; do
-    IFS="$lt_save_ifs"
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/file; then
-      lt_cv_path_MAGIC_CMD="$ac_dir/file"
-      if test -n "$file_magic_test_file"; then
-	case $deplibs_check_method in
-	"file_magic "*)
-	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
-	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
-	    $EGREP "$file_magic_regex" > /dev/null; then
-	    :
-	  else
-	    cat <<_LT_EOF 1>&2
-
-*** Warning: the command libtool uses to detect shared libraries,
-*** $file_magic_cmd, produces output that libtool cannot recognize.
-*** The result is that libtool may fail to recognize shared libraries
-*** as such.  This will affect the creation of libtool libraries that
-*** depend on shared libraries, but programs linked with such libtool
-*** libraries will work regardless of this problem.  Nevertheless, you
-*** may want to report the problem to your system manager and/or to
-*** bug-libtool@gnu.org
-
-_LT_EOF
-	  fi ;;
-	esac
-      fi
-      break
-    fi
-  done
-  IFS="$lt_save_ifs"
-  MAGIC_CMD="$lt_save_MAGIC_CMD"
-  ;;
-esac
-fi
-
-MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-if test -n "$MAGIC_CMD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
-$as_echo "$MAGIC_CMD" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  else
-    MAGIC_CMD=:
-  fi
-fi
-
-  fi
-  ;;
-esac
-
-# Use C for the default configuration in the libtool script
-
-lt_save_CC="$CC"
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-# Source file extension for C test sources.
-ac_ext=c
-
-# Object file extension for compiled C test sources.
-objext=o
-objext=$objext
-
-# Code to be used in simple compile tests
-lt_simple_compile_test_code="int some_variable = 0;"
-
-# Code to be used in simple link tests
-lt_simple_link_test_code='int main(){return(0);}'
-
-
-
-
-
-
-
-# If no C compiler was specified, use CC.
-LTCC=${LTCC-"$CC"}
-
-# If no C compiler flags were specified, use CFLAGS.
-LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
-
-# Allow CC to be a program name with arguments.
-compiler=$CC
-
-# Save the default compiler, since it gets overwritten when the other
-# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.
-compiler_DEFAULT=$CC
-
-# save warnings/boilerplate of simple test code
-ac_outfile=conftest.$ac_objext
-echo "$lt_simple_compile_test_code" >conftest.$ac_ext
-eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
-_lt_compiler_boilerplate=`cat conftest.err`
-$RM conftest*
-
-ac_outfile=conftest.$ac_objext
-echo "$lt_simple_link_test_code" >conftest.$ac_ext
-eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
-_lt_linker_boilerplate=`cat conftest.err`
-$RM -r conftest*
-
-
-## CAVEAT EMPTOR:
-## There is no encapsulation within the following macros, do not change
-## the running order or otherwise move them around unless you know exactly
-## what you are doing...
-if test -n "$compiler"; then
-
-lt_prog_compiler_no_builtin_flag=
-
-if test "$GCC" = yes; then
-  case $cc_basename in
-  nvcc*)
-    lt_prog_compiler_no_builtin_flag=' -Xcompiler -fno-builtin' ;;
-  *)
-    lt_prog_compiler_no_builtin_flag=' -fno-builtin' ;;
-  esac
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
-$as_echo_n "checking if $compiler supports -fno-rtti -fno-exceptions... " >&6; }
-if test "${lt_cv_prog_compiler_rtti_exceptions+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_rtti_exceptions=no
-   ac_outfile=conftest.$ac_objext
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-   lt_compiler_flag="-fno-rtti -fno-exceptions"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   # The option is referenced via a variable to avoid confusing sed.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>conftest.err)
-   ac_status=$?
-   cat conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s "$ac_outfile"; then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings other than the usual output.
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
-     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_rtti_exceptions=yes
-     fi
-   fi
-   $RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_rtti_exceptions" >&5
-$as_echo "$lt_cv_prog_compiler_rtti_exceptions" >&6; }
-
-if test x"$lt_cv_prog_compiler_rtti_exceptions" = xyes; then
-    lt_prog_compiler_no_builtin_flag="$lt_prog_compiler_no_builtin_flag -fno-rtti -fno-exceptions"
-else
-    :
-fi
-
-fi
-
-
-
-
-
-
-  lt_prog_compiler_wl=
-lt_prog_compiler_pic=
-lt_prog_compiler_static=
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $compiler option to produce PIC" >&5
-$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
-
-  if test "$GCC" = yes; then
-    lt_prog_compiler_wl='-Wl,'
-    lt_prog_compiler_static='-static'
-
-    case $host_os in
-      aix*)
-      # All AIX code is PIC.
-      if test "$host_cpu" = ia64; then
-	# AIX 5 now supports IA64 processor
-	lt_prog_compiler_static='-Bstatic'
-      fi
-      lt_prog_compiler_pic='-fPIC'
-      ;;
-
-    amigaos*)
-      case $host_cpu in
-      powerpc)
-            # see comment about AmigaOS4 .so support
-            lt_prog_compiler_pic='-fPIC'
-        ;;
-      m68k)
-            # FIXME: we need at least 68020 code to build shared libraries, but
-            # adding the `-m68020' flag to GCC prevents building anything better,
-            # like `-m68040'.
-            lt_prog_compiler_pic='-m68020 -resident32 -malways-restore-a4'
-        ;;
-      esac
-      ;;
-
-    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
-      # PIC is the default for these OSes.
-      ;;
-
-    mingw* | cygwin* | pw32* | os2* | cegcc*)
-      # This hack is so that the source file can tell whether it is being
-      # built for inclusion in a dll (and should export symbols for example).
-      # Although the cygwin gcc ignores -fPIC, still need this for old-style
-      # (--disable-auto-import) libraries
-      lt_prog_compiler_pic='-DDLL_EXPORT'
-      ;;
-
-    darwin* | rhapsody*)
-      # PIC is the default on this platform
-      # Common symbols not allowed in MH_DYLIB files
-      lt_prog_compiler_pic='-fno-common'
-      ;;
-
-    haiku*)
-      # PIC is the default for Haiku.
-      # The "-static" flag exists, but is broken.
-      lt_prog_compiler_static=
-      ;;
-
-    hpux*)
-      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
-      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
-      # sets the default TLS model and affects inlining.
-      case $host_cpu in
-      hppa*64*)
-	# +Z the default
-	;;
-      *)
-	lt_prog_compiler_pic='-fPIC'
-	;;
-      esac
-      ;;
-
-    interix[3-9]*)
-      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
-      # Instead, we relocate shared libraries at runtime.
-      ;;
-
-    msdosdjgpp*)
-      # Just because we use GCC doesn't mean we suddenly get shared libraries
-      # on systems that don't support them.
-      lt_prog_compiler_can_build_shared=no
-      enable_shared=no
-      ;;
-
-    *nto* | *qnx*)
-      # QNX uses GNU C++, but need to define -shared option too, otherwise
-      # it will coredump.
-      lt_prog_compiler_pic='-fPIC -shared'
-      ;;
-
-    sysv4*MP*)
-      if test -d /usr/nec; then
-	lt_prog_compiler_pic=-Kconform_pic
-      fi
-      ;;
-
-    *)
-      lt_prog_compiler_pic='-fPIC'
-      ;;
-    esac
-
-    case $cc_basename in
-    nvcc*) # Cuda Compiler Driver 2.2
-      lt_prog_compiler_wl='-Xlinker '
-      lt_prog_compiler_pic='-Xcompiler -fPIC'
-      ;;
-    esac
-  else
-    # PORTME Check for flag to pass linker flags through the system compiler.
-    case $host_os in
-    aix*)
-      lt_prog_compiler_wl='-Wl,'
-      if test "$host_cpu" = ia64; then
-	# AIX 5 now supports IA64 processor
-	lt_prog_compiler_static='-Bstatic'
-      else
-	lt_prog_compiler_static='-bnso -bI:/lib/syscalls.exp'
-      fi
-      ;;
-
-    mingw* | cygwin* | pw32* | os2* | cegcc*)
-      # This hack is so that the source file can tell whether it is being
-      # built for inclusion in a dll (and should export symbols for example).
-      lt_prog_compiler_pic='-DDLL_EXPORT'
-      ;;
-
-    hpux9* | hpux10* | hpux11*)
-      lt_prog_compiler_wl='-Wl,'
-      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
-      # not for PA HP-UX.
-      case $host_cpu in
-      hppa*64*|ia64*)
-	# +Z the default
-	;;
-      *)
-	lt_prog_compiler_pic='+Z'
-	;;
-      esac
-      # Is there a better lt_prog_compiler_static that works with the bundled CC?
-      lt_prog_compiler_static='${wl}-a ${wl}archive'
-      ;;
-
-    irix5* | irix6* | nonstopux*)
-      lt_prog_compiler_wl='-Wl,'
-      # PIC (with -KPIC) is the default.
-      lt_prog_compiler_static='-non_shared'
-      ;;
-
-    linux* | k*bsd*-gnu | kopensolaris*-gnu)
-      case $cc_basename in
-      # old Intel for x86_64 which still supported -KPIC.
-      ecc*)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-KPIC'
-	lt_prog_compiler_static='-static'
-        ;;
-      # icc used to be incompatible with GCC.
-      # ICC 10 doesn't accept -KPIC any more.
-      icc* | ifort*)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-fPIC'
-	lt_prog_compiler_static='-static'
-        ;;
-      # Lahey Fortran 8.1.
-      lf95*)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='--shared'
-	lt_prog_compiler_static='--static'
-	;;
-      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)
-        # Portland Group compilers (*not* the Pentium gcc compiler,
-	# which looks to be a dead project)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-fpic'
-	lt_prog_compiler_static='-Bstatic'
-        ;;
-      ccc*)
-        lt_prog_compiler_wl='-Wl,'
-        # All Alpha code is PIC.
-        lt_prog_compiler_static='-non_shared'
-        ;;
-      xl* | bgxl* | bgf* | mpixl*)
-	# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-qpic'
-	lt_prog_compiler_static='-qstaticlink'
-	;;
-      *)
-	case `$CC -V 2>&1 | sed 5q` in
-	*Sun\ F* | *Sun*Fortran*)
-	  # Sun Fortran 8.3 passes all unrecognized flags to the linker
-	  lt_prog_compiler_pic='-KPIC'
-	  lt_prog_compiler_static='-Bstatic'
-	  lt_prog_compiler_wl=''
-	  ;;
-	*Sun\ C*)
-	  # Sun C 5.9
-	  lt_prog_compiler_pic='-KPIC'
-	  lt_prog_compiler_static='-Bstatic'
-	  lt_prog_compiler_wl='-Wl,'
-	  ;;
-	esac
-	;;
-      esac
-      ;;
-
-    newsos6)
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
-
-    *nto* | *qnx*)
-      # QNX uses GNU C++, but need to define -shared option too, otherwise
-      # it will coredump.
-      lt_prog_compiler_pic='-fPIC -shared'
-      ;;
-
-    osf3* | osf4* | osf5*)
-      lt_prog_compiler_wl='-Wl,'
-      # All OSF/1 code is PIC.
-      lt_prog_compiler_static='-non_shared'
-      ;;
-
-    rdos*)
-      lt_prog_compiler_static='-non_shared'
-      ;;
-
-    solaris*)
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      case $cc_basename in
-      f77* | f90* | f95*)
-	lt_prog_compiler_wl='-Qoption ld ';;
-      *)
-	lt_prog_compiler_wl='-Wl,';;
-      esac
-      ;;
-
-    sunos4*)
-      lt_prog_compiler_wl='-Qoption ld '
-      lt_prog_compiler_pic='-PIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
-
-    sysv4 | sysv4.2uw2* | sysv4.3*)
-      lt_prog_compiler_wl='-Wl,'
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
-
-    sysv4*MP*)
-      if test -d /usr/nec ;then
-	lt_prog_compiler_pic='-Kconform_pic'
-	lt_prog_compiler_static='-Bstatic'
-      fi
-      ;;
-
-    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
-      lt_prog_compiler_wl='-Wl,'
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
-
-    unicos*)
-      lt_prog_compiler_wl='-Wl,'
-      lt_prog_compiler_can_build_shared=no
-      ;;
-
-    uts4*)
-      lt_prog_compiler_pic='-pic'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
-
-    *)
-      lt_prog_compiler_can_build_shared=no
-      ;;
-    esac
-  fi
-
-case $host_os in
-  # For platforms which do not support PIC, -DPIC is meaningless:
-  *djgpp*)
-    lt_prog_compiler_pic=
-    ;;
-  *)
-    lt_prog_compiler_pic="$lt_prog_compiler_pic -DPIC"
-    ;;
-esac
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic" >&5
-$as_echo "$lt_prog_compiler_pic" >&6; }
-
-
-
-
-
-
-#
-# Check to make sure the PIC flag actually works.
-#
-if test -n "$lt_prog_compiler_pic"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler PIC flag $lt_prog_compiler_pic works" >&5
-$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic works... " >&6; }
-if test "${lt_cv_prog_compiler_pic_works+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_pic_works=no
-   ac_outfile=conftest.$ac_objext
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-   lt_compiler_flag="$lt_prog_compiler_pic -DPIC"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   # The option is referenced via a variable to avoid confusing sed.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>conftest.err)
-   ac_status=$?
-   cat conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s "$ac_outfile"; then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings other than the usual output.
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
-     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_pic_works=yes
-     fi
-   fi
-   $RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic_works" >&5
-$as_echo "$lt_cv_prog_compiler_pic_works" >&6; }
-
-if test x"$lt_cv_prog_compiler_pic_works" = xyes; then
-    case $lt_prog_compiler_pic in
-     "" | " "*) ;;
-     *) lt_prog_compiler_pic=" $lt_prog_compiler_pic" ;;
-     esac
-else
-    lt_prog_compiler_pic=
-     lt_prog_compiler_can_build_shared=no
-fi
-
-fi
-
-
-
-
-
-
-#
-# Check to make sure the static flag actually works.
-#
-wl=$lt_prog_compiler_wl eval lt_tmp_static_flag=\"$lt_prog_compiler_static\"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler static flag $lt_tmp_static_flag works" >&5
-$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
-if test "${lt_cv_prog_compiler_static_works+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_static_works=no
-   save_LDFLAGS="$LDFLAGS"
-   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
-   echo "$lt_simple_link_test_code" > conftest.$ac_ext
-   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
-     # The linker can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     if test -s conftest.err; then
-       # Append any errors to the config.log.
-       cat conftest.err 1>&5
-       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
-       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-       if diff conftest.exp conftest.er2 >/dev/null; then
-         lt_cv_prog_compiler_static_works=yes
-       fi
-     else
-       lt_cv_prog_compiler_static_works=yes
-     fi
-   fi
-   $RM -r conftest*
-   LDFLAGS="$save_LDFLAGS"
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_static_works" >&5
-$as_echo "$lt_cv_prog_compiler_static_works" >&6; }
-
-if test x"$lt_cv_prog_compiler_static_works" = xyes; then
-    :
-else
-    lt_prog_compiler_static=
-fi
-
-
-
-
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
-$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
-if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_c_o=no
-   $RM -r conftest 2>/dev/null
-   mkdir conftest
-   cd conftest
-   mkdir out
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-
-   lt_compiler_flag="-o out/conftest2.$ac_objext"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>out/conftest.err)
-   ac_status=$?
-   cat out/conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s out/conftest2.$ac_objext
-   then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
-     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
-     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_c_o=yes
-     fi
-   fi
-   chmod u+w . 2>&5
-   $RM conftest*
-   # SGI C++ compiler will create directory out/ii_files/ for
-   # template instantiation
-   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
-   $RM out/* && rmdir out
-   cd ..
-   $RM -r conftest
-   $RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
-$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
-
-
-
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
-$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
-if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_c_o=no
-   $RM -r conftest 2>/dev/null
-   mkdir conftest
-   cd conftest
-   mkdir out
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-
-   lt_compiler_flag="-o out/conftest2.$ac_objext"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>out/conftest.err)
-   ac_status=$?
-   cat out/conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s out/conftest2.$ac_objext
-   then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
-     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
-     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_c_o=yes
-     fi
-   fi
-   chmod u+w . 2>&5
-   $RM conftest*
-   # SGI C++ compiler will create directory out/ii_files/ for
-   # template instantiation
-   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
-   $RM out/* && rmdir out
-   cd ..
-   $RM -r conftest
-   $RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
-$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
-
-
-
-
-hard_links="nottested"
-if test "$lt_cv_prog_compiler_c_o" = no && test "$need_locks" != no; then
-  # do not overwrite the value of need_locks provided by the user
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
-$as_echo_n "checking if we can lock with hard links... " >&6; }
-  hard_links=yes
-  $RM conftest*
-  ln conftest.a conftest.b 2>/dev/null && hard_links=no
-  touch conftest.a
-  ln conftest.a conftest.b 2>&5 || hard_links=no
-  ln conftest.a conftest.b 2>/dev/null && hard_links=no
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
-$as_echo "$hard_links" >&6; }
-  if test "$hard_links" = no; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
-$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
-    need_locks=warn
-  fi
-else
-  need_locks=no
-fi
-
-
-
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
-$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
-
-  runpath_var=
-  allow_undefined_flag=
-  always_export_symbols=no
-  archive_cmds=
-  archive_expsym_cmds=
-  compiler_needs_object=no
-  enable_shared_with_static_runtimes=no
-  export_dynamic_flag_spec=
-  export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
-  hardcode_automatic=no
-  hardcode_direct=no
-  hardcode_direct_absolute=no
-  hardcode_libdir_flag_spec=
-  hardcode_libdir_flag_spec_ld=
-  hardcode_libdir_separator=
-  hardcode_minus_L=no
-  hardcode_shlibpath_var=unsupported
-  inherit_rpath=no
-  link_all_deplibs=unknown
-  module_cmds=
-  module_expsym_cmds=
-  old_archive_from_new_cmds=
-  old_archive_from_expsyms_cmds=
-  thread_safe_flag_spec=
-  whole_archive_flag_spec=
-  # include_expsyms should be a list of space-separated symbols to be *always*
-  # included in the symbol list
-  include_expsyms=
-  # exclude_expsyms can be an extended regexp of symbols to exclude
-  # it will be wrapped by ` (' and `)$', so one must not match beginning or
-  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
-  # as well as any symbol that contains `d'.
-  exclude_expsyms='_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*'
-  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
-  # platforms (ab)use it in PIC code, but their linkers get confused if
-  # the symbol is explicitly referenced.  Since portable code cannot
-  # rely on this symbol name, it's probably fine to never include it in
-  # preloaded symbol tables.
-  # Exclude shared library initialization/finalization symbols.
-  extract_expsyms_cmds=
-
-  case $host_os in
-  cygwin* | mingw* | pw32* | cegcc*)
-    # FIXME: the MSVC++ port hasn't been tested in a loooong time
-    # When not using gcc, we currently assume that we are using
-    # Microsoft Visual C++.
-    if test "$GCC" != yes; then
-      with_gnu_ld=no
-    fi
-    ;;
-  interix*)
-    # we just hope/assume this is gcc and not c89 (= MSVC++)
-    with_gnu_ld=yes
-    ;;
-  openbsd*)
-    with_gnu_ld=no
-    ;;
-  esac
-
-  ld_shlibs=yes
-
-  # On some targets, GNU ld is compatible enough with the native linker
-  # that we're better off using the native interface for both.
-  lt_use_gnu_ld_interface=no
-  if test "$with_gnu_ld" = yes; then
-    case $host_os in
-      aix*)
-	# The AIX port of GNU ld has always aspired to compatibility
-	# with the native linker.  However, as the warning in the GNU ld
-	# block says, versions before 2.19.5* couldn't really create working
-	# shared libraries, regardless of the interface used.
-	case `$LD -v 2>&1` in
-	  *\ \(GNU\ Binutils\)\ 2.19.5*) ;;
-	  *\ \(GNU\ Binutils\)\ 2.[2-9]*) ;;
-	  *\ \(GNU\ Binutils\)\ [3-9]*) ;;
-	  *)
-	    lt_use_gnu_ld_interface=yes
-	    ;;
-	esac
-	;;
-      *)
-	lt_use_gnu_ld_interface=yes
-	;;
-    esac
-  fi
-
-  if test "$lt_use_gnu_ld_interface" = yes; then
-    # If archive_cmds runs LD, not CC, wlarc should be empty
-    wlarc='${wl}'
-
-    # Set some defaults for GNU ld with shared library support. These
-    # are reset later if shared libraries are not supported. Putting them
-    # here allows them to be overridden if necessary.
-    runpath_var=LD_RUN_PATH
-    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-    export_dynamic_flag_spec='${wl}--export-dynamic'
-    # ancient GNU ld didn't support --whole-archive et. al.
-    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then
-      whole_archive_flag_spec="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
-    else
-      whole_archive_flag_spec=
-    fi
-    supports_anon_versioning=no
-    case `$LD -v 2>&1` in
-      *GNU\ gold*) supports_anon_versioning=yes ;;
-      *\ [01].* | *\ 2.[0-9].* | *\ 2.10.*) ;; # catch versions < 2.11
-      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
-      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
-      *\ 2.11.*) ;; # other 2.11 versions
-      *) supports_anon_versioning=yes ;;
-    esac
-
-    # See if GNU ld supports shared libraries.
-    case $host_os in
-    aix[3-9]*)
-      # On AIX/PPC, the GNU linker is very broken
-      if test "$host_cpu" != ia64; then
-	ld_shlibs=no
-	cat <<_LT_EOF 1>&2
-
-*** Warning: the GNU linker, at least up to release 2.19, is reported
-*** to be unable to reliably create shared libraries on AIX.
-*** Therefore, libtool is disabling shared libraries support.  If you
-*** really care for shared libraries, you may want to install binutils
-*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.
-*** You will then need to restart the configuration process.
-
-_LT_EOF
-      fi
-      ;;
-
-    amigaos*)
-      case $host_cpu in
-      powerpc)
-            # see comment about AmigaOS4 .so support
-            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-            archive_expsym_cmds=''
-        ;;
-      m68k)
-            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
-            hardcode_libdir_flag_spec='-L$libdir'
-            hardcode_minus_L=yes
-        ;;
-      esac
-      ;;
-
-    beos*)
-      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	allow_undefined_flag=unsupported
-	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
-	# support --undefined.  This deserves some investigation.  FIXME
-	archive_cmds='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
-
-    cygwin* | mingw* | pw32* | cegcc*)
-      # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
-      # as there is no search path for DLLs.
-      hardcode_libdir_flag_spec='-L$libdir'
-      export_dynamic_flag_spec='${wl}--export-all-symbols'
-      allow_undefined_flag=unsupported
-      always_export_symbols=no
-      enable_shared_with_static_runtimes=yes
-      export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1 DATA/'\'' | $SED -e '\''/^[AITW][ ]/s/.*[ ]//'\'' | sort | uniq > $export_symbols'
-
-      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
-        archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
-	# If the export-symbols file already is a .def file (1st line
-	# is EXPORTS), use it as is; otherwise, prepend...
-	archive_expsym_cmds='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
-	  cp $export_symbols $output_objdir/$soname.def;
-	else
-	  echo EXPORTS > $output_objdir/$soname.def;
-	  cat $export_symbols >> $output_objdir/$soname.def;
-	fi~
-	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
-
-    haiku*)
-      archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-      link_all_deplibs=yes
-      ;;
-
-    interix[3-9]*)
-      hardcode_direct=no
-      hardcode_shlibpath_var=no
-      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-      export_dynamic_flag_spec='${wl}-E'
-      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
-      # Instead, shared libraries are loaded at an image base (0x10000000 by
-      # default) and relocated if they conflict, which is a slow very memory
-      # consuming and fragmenting process.  To avoid this, we pick a random,
-      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
-      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
-      archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
-      archive_expsym_cmds='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
-      ;;
-
-    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
-      tmp_diet=no
-      if test "$host_os" = linux-dietlibc; then
-	case $cc_basename in
-	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
-	esac
-      fi
-      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \
-	 && test "$tmp_diet" = no
-      then
-	tmp_addflag=
-	tmp_sharedflag='-shared'
-	case $cc_basename,$host_cpu in
-        pgcc*)				# Portland Group C compiler
-	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
-	  tmp_addflag=' $pic_flag'
-	  ;;
-	pgf77* | pgf90* | pgf95* | pgfortran*)
-					# Portland Group f77 and f90 compilers
-	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
-	  tmp_addflag=' $pic_flag -Mnomain' ;;
-	ecc*,ia64* | icc*,ia64*)	# Intel C compiler on ia64
-	  tmp_addflag=' -i_dynamic' ;;
-	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
-	  tmp_addflag=' -i_dynamic -nofor_main' ;;
-	ifc* | ifort*)			# Intel Fortran compiler
-	  tmp_addflag=' -nofor_main' ;;
-	lf95*)				# Lahey Fortran 8.1
-	  whole_archive_flag_spec=
-	  tmp_sharedflag='--shared' ;;
-	xl[cC]* | bgxl[cC]* | mpixl[cC]*) # IBM XL C 8.0 on PPC (deal with xlf below)
-	  tmp_sharedflag='-qmkshrobj'
-	  tmp_addflag= ;;
-	nvcc*)	# Cuda Compiler Driver 2.2
-	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
-	  compiler_needs_object=yes
-	  ;;
-	esac
-	case `$CC -V 2>&1 | sed 5q` in
-	*Sun\ C*)			# Sun C 5.9
-	  whole_archive_flag_spec='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
-	  compiler_needs_object=yes
-	  tmp_sharedflag='-G' ;;
-	*Sun\ F*)			# Sun Fortran 8.3
-	  tmp_sharedflag='-G' ;;
-	esac
-	archive_cmds='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-
-        if test "x$supports_anon_versioning" = xyes; then
-          archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
-	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
-	    echo "local: *; };" >> $output_objdir/$libname.ver~
-	    $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
-        fi
-
-	case $cc_basename in
-	xlf* | bgf* | bgxlf* | mpixlf*)
-	  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself
-	  whole_archive_flag_spec='--whole-archive$convenience --no-whole-archive'
-	  hardcode_libdir_flag_spec=
-	  hardcode_libdir_flag_spec_ld='-rpath $libdir'
-	  archive_cmds='$LD -shared $libobjs $deplibs $compiler_flags -soname $soname -o $lib'
-	  if test "x$supports_anon_versioning" = xyes; then
-	    archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
-	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
-	      echo "local: *; };" >> $output_objdir/$libname.ver~
-	      $LD -shared $libobjs $deplibs $compiler_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
-	  fi
-	  ;;
-	esac
-      else
-        ld_shlibs=no
-      fi
-      ;;
-
-    netbsd*)
-      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-	archive_cmds='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
-	wlarc=
-      else
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-      fi
-      ;;
-
-    solaris*)
-      if $LD -v 2>&1 | $GREP 'BFD 2\.8' > /dev/null; then
-	ld_shlibs=no
-	cat <<_LT_EOF 1>&2
-
-*** Warning: The releases 2.8.* of the GNU linker cannot reliably
-*** create shared libraries on Solaris systems.  Therefore, libtool
-*** is disabling shared libraries support.  We urge you to upgrade GNU
-*** binutils to release 2.9.1 or newer.  Another option is to modify
-*** your PATH or compiler configuration so that the native linker is
-*** used, and then restart.
-
-_LT_EOF
-      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
-
-    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
-      case `$LD -v 2>&1` in
-        *\ [01].* | *\ 2.[0-9].* | *\ 2.1[0-5].*)
-	ld_shlibs=no
-	cat <<_LT_EOF 1>&2
-
-*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
-*** reliably create shared libraries on SCO systems.  Therefore, libtool
-*** is disabling shared libraries support.  We urge you to upgrade GNU
-*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
-*** your PATH or compiler configuration so that the native linker is
-*** used, and then restart.
-
-_LT_EOF
-	;;
-	*)
-	  # For security reasons, it is highly recommended that you always
-	  # use absolute paths for naming shared libraries, and exclude the
-	  # DT_RUNPATH tag from executables and libraries.  But doing so
-	  # requires that you compile everything twice, which is a pain.
-	  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-	    archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	    archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-	  else
-	    ld_shlibs=no
-	  fi
-	;;
-      esac
-      ;;
-
-    sunos4*)
-      archive_cmds='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
-      wlarc=
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
-
-    *)
-      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
-    esac
-
-    if test "$ld_shlibs" = no; then
-      runpath_var=
-      hardcode_libdir_flag_spec=
-      export_dynamic_flag_spec=
-      whole_archive_flag_spec=
-    fi
-  else
-    # PORTME fill in a description of your system's linker (not GNU ld)
-    case $host_os in
-    aix3*)
-      allow_undefined_flag=unsupported
-      always_export_symbols=yes
-      archive_expsym_cmds='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
-      # Note: this linker hardcodes the directories in LIBPATH if there
-      # are no directories specified by -L.
-      hardcode_minus_L=yes
-      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
-	# Neither direct hardcoding nor static linking is supported with a
-	# broken collect2.
-	hardcode_direct=unsupported
-      fi
-      ;;
-
-    aix[4-9]*)
-      if test "$host_cpu" = ia64; then
-	# On IA64, the linker does run time linking by default, so we don't
-	# have to do anything special.
-	aix_use_runtimelinking=no
-	exp_sym_flag='-Bexport'
-	no_entry_flag=""
-      else
-	# If we're using GNU nm, then we don't want the "-C" option.
-	# -C means demangle to AIX nm, but means don't demangle with GNU nm
-	# Also, AIX nm treats weak defined symbols like other global
-	# defined symbols, whereas GNU nm marks them as "W".
-	if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
-	  export_symbols_cmds='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
-	else
-	  export_symbols_cmds='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
-	fi
-	aix_use_runtimelinking=no
-
-	# Test if we are trying to use run time linking or normal
-	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
-	# need to do runtime linking.
-	case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)
-	  for ld_flag in $LDFLAGS; do
-	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
-	    aix_use_runtimelinking=yes
-	    break
-	  fi
-	  done
-	  ;;
-	esac
-
-	exp_sym_flag='-bexport'
-	no_entry_flag='-bnoentry'
-      fi
-
-      # When large executables or shared objects are built, AIX ld can
-      # have problems creating the table of contents.  If linking a library
-      # or program results in "error TOC overflow" add -mminimal-toc to
-      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
-      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
-
-      archive_cmds=''
-      hardcode_direct=yes
-      hardcode_direct_absolute=yes
-      hardcode_libdir_separator=':'
-      link_all_deplibs=yes
-      file_list_spec='${wl}-f,'
-
-      if test "$GCC" = yes; then
-	case $host_os in aix4.[012]|aix4.[012].*)
-	# We only want to do this on AIX 4.2 and lower, the check
-	# below for broken collect2 doesn't work under 4.3+
-	  collect2name=`${CC} -print-prog-name=collect2`
-	  if test -f "$collect2name" &&
-	   strings "$collect2name" | $GREP resolve_lib_name >/dev/null
-	  then
-	  # We have reworked collect2
-	  :
-	  else
-	  # We have old collect2
-	  hardcode_direct=unsupported
-	  # It fails to find uninstalled libraries when the uninstalled
-	  # path is not listed in the libpath.  Setting hardcode_minus_L
-	  # to unsupported forces relinking
-	  hardcode_minus_L=yes
-	  hardcode_libdir_flag_spec='-L$libdir'
-	  hardcode_libdir_separator=
-	  fi
-	  ;;
-	esac
-	shared_flag='-shared'
-	if test "$aix_use_runtimelinking" = yes; then
-	  shared_flag="$shared_flag "'${wl}-G'
-	fi
-      else
-	# not using gcc
-	if test "$host_cpu" = ia64; then
-	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
-	# chokes on -Wl,-G. The following line is correct:
-	  shared_flag='-G'
-	else
-	  if test "$aix_use_runtimelinking" = yes; then
-	    shared_flag='${wl}-G'
-	  else
-	    shared_flag='${wl}-bM:SRE'
-	  fi
-	fi
-      fi
-
-      export_dynamic_flag_spec='${wl}-bexpall'
-      # It seems that -bexpall does not export symbols beginning with
-      # underscore (_), so it is better to generate a list of symbols to export.
-      always_export_symbols=yes
-      if test "$aix_use_runtimelinking" = yes; then
-	# Warning - without using the other runtime loading flags (-brtl),
-	# -berok will link without error, but may produce a broken library.
-	allow_undefined_flag='-berok'
-        # Determine the default libpath from the value encoded in an
-        # empty executable.
-        if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-
-lt_aix_libpath_sed='
-    /Import File Strings/,/^$/ {
-	/^0/ {
-	    s/^0  *\(.*\)$/\1/
-	    p
-	}
-    }'
-aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-# Check for a 64-bit object if we didn't find anything.
-if test -z "$aix_libpath"; then
-  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
-
-        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
-        archive_expsym_cmds='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
-      else
-	if test "$host_cpu" = ia64; then
-	  hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
-	  allow_undefined_flag="-z nodefs"
-	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
-	else
-	 # Determine the default libpath from the value encoded in an
-	 # empty executable.
-	 if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-
-lt_aix_libpath_sed='
-    /Import File Strings/,/^$/ {
-	/^0/ {
-	    s/^0  *\(.*\)$/\1/
-	    p
-	}
-    }'
-aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-# Check for a 64-bit object if we didn't find anything.
-if test -z "$aix_libpath"; then
-  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
-
-	 hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
-	  # Warning - without using the other run time loading flags,
-	  # -berok will link without error, but may produce a broken library.
-	  no_undefined_flag=' ${wl}-bernotok'
-	  allow_undefined_flag=' ${wl}-berok'
-	  if test "$with_gnu_ld" = yes; then
-	    # We only use this code for GNU lds that support --whole-archive.
-	    whole_archive_flag_spec='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
-	  else
-	    # Exported symbols can be pulled into shared objects from archives
-	    whole_archive_flag_spec='$convenience'
-	  fi
-	  archive_cmds_need_lc=yes
-	  # This is similar to how AIX traditionally builds its shared libraries.
-	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
-	fi
-      fi
-      ;;
-
-    amigaos*)
-      case $host_cpu in
-      powerpc)
-            # see comment about AmigaOS4 .so support
-            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-            archive_expsym_cmds=''
-        ;;
-      m68k)
-            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
-            hardcode_libdir_flag_spec='-L$libdir'
-            hardcode_minus_L=yes
-        ;;
-      esac
-      ;;
-
-    bsdi[45]*)
-      export_dynamic_flag_spec=-rdynamic
-      ;;
-
-    cygwin* | mingw* | pw32* | cegcc*)
-      # When not using gcc, we currently assume that we are using
-      # Microsoft Visual C++.
-      # hardcode_libdir_flag_spec is actually meaningless, as there is
-      # no search path for DLLs.
-      hardcode_libdir_flag_spec=' '
-      allow_undefined_flag=unsupported
-      # Tell ltmain to make .lib files, not .a files.
-      libext=lib
-      # Tell ltmain to make .dll files, not .so files.
-      shrext_cmds=".dll"
-      # FIXME: Setting linknames here is a bad hack.
-      archive_cmds='$CC -o $lib $libobjs $compiler_flags `func_echo_all "$deplibs" | $SED '\''s/ -lc$//'\''` -link -dll~linknames='
-      # The linker will automatically build a .lib file if we build a DLL.
-      old_archive_from_new_cmds='true'
-      # FIXME: Should let the user specify the lib program.
-      old_archive_cmds='lib -OUT:$oldlib$oldobjs$old_deplibs'
-      fix_srcfile_path='`cygpath -w "$srcfile"`'
-      enable_shared_with_static_runtimes=yes
-      ;;
-
-    darwin* | rhapsody*)
-
-
-  archive_cmds_need_lc=no
-  hardcode_direct=no
-  hardcode_automatic=yes
-  hardcode_shlibpath_var=unsupported
-  if test "$lt_cv_ld_force_load" = "yes"; then
-    whole_archive_flag_spec='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience ${wl}-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
-  else
-    whole_archive_flag_spec=''
-  fi
-  link_all_deplibs=yes
-  allow_undefined_flag="$_lt_dar_allow_undefined"
-  case $cc_basename in
-     ifort*) _lt_dar_can_shared=yes ;;
-     *) _lt_dar_can_shared=$GCC ;;
-  esac
-  if test "$_lt_dar_can_shared" = "yes"; then
-    output_verbose_link_cmd=func_echo_all
-    archive_cmds="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
-    module_cmds="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
-    archive_expsym_cmds="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
-    module_expsym_cmds="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
-
-  else
-  ld_shlibs=no
-  fi
-
-      ;;
-
-    dgux*)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_shlibpath_var=no
-      ;;
-
-    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
-    # support.  Future versions do this automatically, but an explicit c++rt0.o
-    # does not break anything, and helps significantly (at the cost of a little
-    # extra space).
-    freebsd2.2*)
-      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
-
-    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2.*)
-      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_direct=yes
-      hardcode_minus_L=yes
-      hardcode_shlibpath_var=no
-      ;;
-
-    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
-    freebsd* | dragonfly*)
-      archive_cmds='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
-
-    hpux9*)
-      if test "$GCC" = yes; then
-	archive_cmds='$RM $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
-      else
-	archive_cmds='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
-      fi
-      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-      hardcode_libdir_separator=:
-      hardcode_direct=yes
-
-      # hardcode_minus_L: Not really in the search PATH,
-      # but as the default location of the library.
-      hardcode_minus_L=yes
-      export_dynamic_flag_spec='${wl}-E'
-      ;;
-
-    hpux10*)
-      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
-	archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
-      fi
-      if test "$with_gnu_ld" = no; then
-	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-	hardcode_libdir_flag_spec_ld='+b $libdir'
-	hardcode_libdir_separator=:
-	hardcode_direct=yes
-	hardcode_direct_absolute=yes
-	export_dynamic_flag_spec='${wl}-E'
-	# hardcode_minus_L: Not really in the search PATH,
-	# but as the default location of the library.
-	hardcode_minus_L=yes
-      fi
-      ;;
-
-    hpux11*)
-      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
-	case $host_cpu in
-	hppa*64*)
-	  archive_cmds='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	ia64*)
-	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	*)
-	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	esac
-      else
-	case $host_cpu in
-	hppa*64*)
-	  archive_cmds='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	ia64*)
-	  archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	*)
-
-	  # Older versions of the 11.00 compiler do not understand -b yet
-	  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)
-	  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $CC understands -b" >&5
-$as_echo_n "checking if $CC understands -b... " >&6; }
-if test "${lt_cv_prog_compiler__b+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler__b=no
-   save_LDFLAGS="$LDFLAGS"
-   LDFLAGS="$LDFLAGS -b"
-   echo "$lt_simple_link_test_code" > conftest.$ac_ext
-   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
-     # The linker can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     if test -s conftest.err; then
-       # Append any errors to the config.log.
-       cat conftest.err 1>&5
-       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
-       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-       if diff conftest.exp conftest.er2 >/dev/null; then
-         lt_cv_prog_compiler__b=yes
-       fi
-     else
-       lt_cv_prog_compiler__b=yes
-     fi
-   fi
-   $RM -r conftest*
-   LDFLAGS="$save_LDFLAGS"
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler__b" >&5
-$as_echo "$lt_cv_prog_compiler__b" >&6; }
-
-if test x"$lt_cv_prog_compiler__b" = xyes; then
-    archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
-else
-    archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
-fi
-
-	  ;;
-	esac
-      fi
-      if test "$with_gnu_ld" = no; then
-	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-	hardcode_libdir_separator=:
-
-	case $host_cpu in
-	hppa*64*|ia64*)
-	  hardcode_direct=no
-	  hardcode_shlibpath_var=no
-	  ;;
-	*)
-	  hardcode_direct=yes
-	  hardcode_direct_absolute=yes
-	  export_dynamic_flag_spec='${wl}-E'
-
-	  # hardcode_minus_L: Not really in the search PATH,
-	  # but as the default location of the library.
-	  hardcode_minus_L=yes
-	  ;;
-	esac
-      fi
-      ;;
-
-    irix5* | irix6* | nonstopux*)
-      if test "$GCC" = yes; then
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-	# Try to use the -exported_symbol ld option, if it does not
-	# work, assume that -exports_file does not work either and
-	# implicitly export all symbols.
-        save_LDFLAGS="$LDFLAGS"
-        LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
-        if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int foo(void) {}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
-
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-        LDFLAGS="$save_LDFLAGS"
-      else
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
-      fi
-      archive_cmds_need_lc='no'
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      inherit_rpath=yes
-      link_all_deplibs=yes
-      ;;
-
-    netbsd*)
-      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-	archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
-      else
-	archive_cmds='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
-      fi
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
-
-    newsos6)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_direct=yes
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      hardcode_shlibpath_var=no
-      ;;
-
-    *nto* | *qnx*)
-      ;;
-
-    openbsd*)
-      if test -f /usr/libexec/ld.so; then
-	hardcode_direct=yes
-	hardcode_shlibpath_var=no
-	hardcode_direct_absolute=yes
-	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-	  archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
-	  archive_expsym_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
-	  hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-	  export_dynamic_flag_spec='${wl}-E'
-	else
-	  case $host_os in
-	   openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
-	     archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
-	     hardcode_libdir_flag_spec='-R$libdir'
-	     ;;
-	   *)
-	     archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
-	     hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-	     ;;
-	  esac
-	fi
-      else
-	ld_shlibs=no
-      fi
-      ;;
-
-    os2*)
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_minus_L=yes
-      allow_undefined_flag=unsupported
-      archive_cmds='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
-      old_archive_from_new_cmds='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
-      ;;
-
-    osf3*)
-      if test "$GCC" = yes; then
-	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-      else
-	allow_undefined_flag=' -expect_unresolved \*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-      fi
-      archive_cmds_need_lc='no'
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      ;;
-
-    osf4* | osf5*)	# as osf3* with the addition of -msym flag
-      if test "$GCC" = yes; then
-	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-	hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      else
-	allow_undefined_flag=' -expect_unresolved \*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-	archive_expsym_cmds='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
-	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
-
-	# Both c and cxx compiler support -rpath directly
-	hardcode_libdir_flag_spec='-rpath $libdir'
-      fi
-      archive_cmds_need_lc='no'
-      hardcode_libdir_separator=:
-      ;;
-
-    solaris*)
-      no_undefined_flag=' -z defs'
-      if test "$GCC" = yes; then
-	wlarc='${wl}'
-	archive_cmds='$CC -shared ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $CC -shared ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
-      else
-	case `$CC -V 2>&1` in
-	*"Compilers 5.0"*)
-	  wlarc=''
-	  archive_cmds='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
-	  ;;
-	*)
-	  wlarc='${wl}'
-	  archive_cmds='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'
-	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
-	  ;;
-	esac
-      fi
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_shlibpath_var=no
-      case $host_os in
-      solaris2.[0-5] | solaris2.[0-5].*) ;;
-      *)
-	# The compiler driver will combine and reorder linker options,
-	# but understands `-z linker_flag'.  GCC discards it without `$wl',
-	# but is careful enough not to reorder.
-	# Supported since Solaris 2.6 (maybe 2.5.1?)
-	if test "$GCC" = yes; then
-	  whole_archive_flag_spec='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
-	else
-	  whole_archive_flag_spec='-z allextract$convenience -z defaultextract'
-	fi
-	;;
-      esac
-      link_all_deplibs=yes
-      ;;
-
-    sunos4*)
-      if test "x$host_vendor" = xsequent; then
-	# Use $CC to link under sequent, because it throws in some extra .o
-	# files that make .init and .fini sections work.
-	archive_cmds='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
-      fi
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_direct=yes
-      hardcode_minus_L=yes
-      hardcode_shlibpath_var=no
-      ;;
-
-    sysv4)
-      case $host_vendor in
-	sni)
-	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	  hardcode_direct=yes # is this really true???
-	;;
-	siemens)
-	  ## LD is ld it makes a PLAMLIB
-	  ## CC just makes a GrossModule.
-	  archive_cmds='$LD -G -o $lib $libobjs $deplibs $linker_flags'
-	  reload_cmds='$CC -r -o $output$reload_objs'
-	  hardcode_direct=no
-        ;;
-	motorola)
-	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	  hardcode_direct=no #Motorola manual says yes, but my tests say they lie
-	;;
-      esac
-      runpath_var='LD_RUN_PATH'
-      hardcode_shlibpath_var=no
-      ;;
-
-    sysv4.3*)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_shlibpath_var=no
-      export_dynamic_flag_spec='-Bexport'
-      ;;
-
-    sysv4*MP*)
-      if test -d /usr/nec; then
-	archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	hardcode_shlibpath_var=no
-	runpath_var=LD_RUN_PATH
-	hardcode_runpath_var=yes
-	ld_shlibs=yes
-      fi
-      ;;
-
-    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
-      no_undefined_flag='${wl}-z,text'
-      archive_cmds_need_lc=no
-      hardcode_shlibpath_var=no
-      runpath_var='LD_RUN_PATH'
-
-      if test "$GCC" = yes; then
-	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      fi
-      ;;
-
-    sysv5* | sco3.2v5* | sco5v6*)
-      # Note: We can NOT use -z defs as we might desire, because we do not
-      # link with -lc, and that would cause any symbols used from libc to
-      # always be unresolved, which means just about no library would
-      # ever link correctly.  If we're not using GNU ld we use -z text
-      # though, which does catch some bad symbols but isn't as heavy-handed
-      # as -z defs.
-      no_undefined_flag='${wl}-z,text'
-      allow_undefined_flag='${wl}-z,nodefs'
-      archive_cmds_need_lc=no
-      hardcode_shlibpath_var=no
-      hardcode_libdir_flag_spec='${wl}-R,$libdir'
-      hardcode_libdir_separator=':'
-      link_all_deplibs=yes
-      export_dynamic_flag_spec='${wl}-Bexport'
-      runpath_var='LD_RUN_PATH'
-
-      if test "$GCC" = yes; then
-	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      fi
-      ;;
-
-    uts4*)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_shlibpath_var=no
-      ;;
-
-    *)
-      ld_shlibs=no
-      ;;
-    esac
-
-    if test x$host_vendor = xsni; then
-      case $host in
-      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
-	export_dynamic_flag_spec='${wl}-Blargedynsym'
-	;;
-      esac
-    fi
-  fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs" >&5
-$as_echo "$ld_shlibs" >&6; }
-test "$ld_shlibs" = no && can_build_shared=no
-
-with_gnu_ld=$with_gnu_ld
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-#
-# Do we need to explicitly link libc?
-#
-case "x$archive_cmds_need_lc" in
-x|xyes)
-  # Assume -lc should be added
-  archive_cmds_need_lc=yes
-
-  if test "$enable_shared" = yes && test "$GCC" = yes; then
-    case $archive_cmds in
-    *'~'*)
-      # FIXME: we may have to deal with multi-command sequences.
-      ;;
-    '$CC '*)
-      # Test whether the compiler implicitly links with -lc since on some
-      # systems, -lgcc has to come before -lc. If gcc already passes -lc
-      # to ld, don't add -lc before -lgcc.
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -lc should be explicitly linked in" >&5
-$as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
-if test "${lt_cv_archive_cmds_need_lc+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  $RM conftest*
-	echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-
-	if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } 2>conftest.err; then
-	  soname=conftest
-	  lib=conftest
-	  libobjs=conftest.$ac_objext
-	  deplibs=
-	  wl=$lt_prog_compiler_wl
-	  pic_flag=$lt_prog_compiler_pic
-	  compiler_flags=-v
-	  linker_flags=-v
-	  verstring=
-	  output_objdir=.
-	  libname=conftest
-	  lt_save_allow_undefined_flag=$allow_undefined_flag
-	  allow_undefined_flag=
-	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1\""; } >&5
-  (eval $archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-	  then
-	    lt_cv_archive_cmds_need_lc=no
-	  else
-	    lt_cv_archive_cmds_need_lc=yes
-	  fi
-	  allow_undefined_flag=$lt_save_allow_undefined_flag
-	else
-	  cat conftest.err 1>&5
-	fi
-	$RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_archive_cmds_need_lc" >&5
-$as_echo "$lt_cv_archive_cmds_need_lc" >&6; }
-      archive_cmds_need_lc=$lt_cv_archive_cmds_need_lc
-      ;;
-    esac
-  fi
-  ;;
-esac
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
-$as_echo_n "checking dynamic linker characteristics... " >&6; }
-
-if test "$GCC" = yes; then
-  case $host_os in
-    darwin*) lt_awk_arg="/^libraries:/,/LR/" ;;
-    *) lt_awk_arg="/^libraries:/" ;;
-  esac
-  case $host_os in
-    mingw* | cegcc*) lt_sed_strip_eq="s,=\([A-Za-z]:\),\1,g" ;;
-    *) lt_sed_strip_eq="s,=/,/,g" ;;
-  esac
-  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e "s/^libraries://" -e $lt_sed_strip_eq`
-  case $lt_search_path_spec in
-  *\;*)
-    # if the path contains ";" then we assume it to be the separator
-    # otherwise default to the standard path separator (i.e. ":") - it is
-    # assumed that no part of a normal pathname contains ";" but that should
-    # okay in the real world where ";" in dirpaths is itself problematic.
-    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED 's/;/ /g'`
-    ;;
-  *)
-    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED "s/$PATH_SEPARATOR/ /g"`
-    ;;
-  esac
-  # Ok, now we have the path, separated by spaces, we can step through it
-  # and add multilib dir if necessary.
-  lt_tmp_lt_search_path_spec=
-  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
-  for lt_sys_path in $lt_search_path_spec; do
-    if test -d "$lt_sys_path/$lt_multi_os_dir"; then
-      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir"
-    else
-      test -d "$lt_sys_path" && \
-	lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path"
-    fi
-  done
-  lt_search_path_spec=`$ECHO "$lt_tmp_lt_search_path_spec" | awk '
-BEGIN {RS=" "; FS="/|\n";} {
-  lt_foo="";
-  lt_count=0;
-  for (lt_i = NF; lt_i > 0; lt_i--) {
-    if ($lt_i != "" && $lt_i != ".") {
-      if ($lt_i == "..") {
-        lt_count++;
-      } else {
-        if (lt_count == 0) {
-          lt_foo="/" $lt_i lt_foo;
-        } else {
-          lt_count--;
-        }
-      }
-    }
-  }
-  if (lt_foo != "") { lt_freq[lt_foo]++; }
-  if (lt_freq[lt_foo] == 1) { print lt_foo; }
-}'`
-  # AWK program above erroneously prepends '/' to C:/dos/paths
-  # for these hosts.
-  case $host_os in
-    mingw* | cegcc*) lt_search_path_spec=`$ECHO "$lt_search_path_spec" |\
-      $SED 's,/\([A-Za-z]:\),\1,g'` ;;
-  esac
-  sys_lib_search_path_spec=`$ECHO "$lt_search_path_spec" | $lt_NL2SP`
-else
-  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
-fi
-library_names_spec=
-libname_spec='lib$name'
-soname_spec=
-shrext_cmds=".so"
-postinstall_cmds=
-postuninstall_cmds=
-finish_cmds=
-finish_eval=
-shlibpath_var=
-shlibpath_overrides_runpath=unknown
-version_type=none
-dynamic_linker="$host_os ld.so"
-sys_lib_dlsearch_path_spec="/lib /usr/lib"
-need_lib_prefix=unknown
-hardcode_into_libs=no
-
-# when you set need_version to no, make sure it does not cause -set_version
-# flags to be left without arguments
-need_version=unknown
-
-case $host_os in
-aix3*)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
-  shlibpath_var=LIBPATH
-
-  # AIX 3 has no versioning support, so we append a major version to the name.
-  soname_spec='${libname}${release}${shared_ext}$major'
-  ;;
-
-aix[4-9]*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  hardcode_into_libs=yes
-  if test "$host_cpu" = ia64; then
-    # AIX 5 supports IA64
-    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
-    shlibpath_var=LD_LIBRARY_PATH
-  else
-    # With GCC up to 2.95.x, collect2 would create an import file
-    # for dependence libraries.  The import file would start with
-    # the line `#! .'.  This would cause the generated library to
-    # depend on `.', always an invalid library.  This was fixed in
-    # development snapshots of GCC prior to 3.0.
-    case $host_os in
-      aix4 | aix4.[01] | aix4.[01].*)
-      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
-	   echo ' yes '
-	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
-	:
-      else
-	can_build_shared=no
-      fi
-      ;;
-    esac
-    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
-    # soname into executable. Probably we can add versioning support to
-    # collect2, so additional links can be useful in future.
-    if test "$aix_use_runtimelinking" = yes; then
-      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
-      # instead of lib<name>.a to let people know that these are not
-      # typical AIX shared libraries.
-      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    else
-      # We preserve .a as extension for shared libraries through AIX4.2
-      # and later when we are not doing run time linking.
-      library_names_spec='${libname}${release}.a $libname.a'
-      soname_spec='${libname}${release}${shared_ext}$major'
-    fi
-    shlibpath_var=LIBPATH
-  fi
-  ;;
-
-amigaos*)
-  case $host_cpu in
-  powerpc)
-    # Since July 2007 AmigaOS4 officially supports .so libraries.
-    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    ;;
-  m68k)
-    library_names_spec='$libname.ixlibrary $libname.a'
-    # Create ${libname}_ixlibrary.a entries in /sys/libs.
-    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
-    ;;
-  esac
-  ;;
-
-beos*)
-  library_names_spec='${libname}${shared_ext}'
-  dynamic_linker="$host_os ld.so"
-  shlibpath_var=LIBRARY_PATH
-  ;;
-
-bsdi[45]*)
-  version_type=linux
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
-  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
-  # the default ld.so.conf also contains /usr/contrib/lib and
-  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
-  # libtool to hard-code these into programs
-  ;;
-
-cygwin* | mingw* | pw32* | cegcc*)
-  version_type=windows
-  shrext_cmds=".dll"
-  need_version=no
-  need_lib_prefix=no
-
-  case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
-    library_names_spec='$libname.dll.a'
-    # DLL is installed to $(libdir)/../bin by postinstall_cmds
-    postinstall_cmds='base_file=`basename \${file}`~
-      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
-      dldir=$destdir/`dirname \$dlpath`~
-      test -d \$dldir || mkdir -p \$dldir~
-      $install_prog $dir/$dlname \$dldir/$dlname~
-      chmod a+x \$dldir/$dlname~
-      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
-        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
-      fi'
-    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
-      dlpath=$dir/\$dldll~
-       $RM \$dlpath'
-    shlibpath_overrides_runpath=yes
-
-    case $host_os in
-    cygwin*)
-      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
-      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-
-      sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
-      ;;
-    mingw* | cegcc*)
-      # MinGW DLLs use traditional 'lib' prefix
-      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-      ;;
-    pw32*)
-      # pw32 DLLs use 'pw' prefix rather than 'lib'
-      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-      ;;
-    esac
-    ;;
-
-  *)
-    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
-    ;;
-  esac
-  dynamic_linker='Win32 ld.exe'
-  # FIXME: first we should search . and the directory the executable is in
-  shlibpath_var=PATH
-  ;;
-
-darwin* | rhapsody*)
-  dynamic_linker="$host_os dyld"
-  version_type=darwin
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
-  soname_spec='${libname}${release}${major}$shared_ext'
-  shlibpath_overrides_runpath=yes
-  shlibpath_var=DYLD_LIBRARY_PATH
-  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
-
-  sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/local/lib"
-  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
-  ;;
-
-dgux*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  ;;
-
-freebsd* | dragonfly*)
-  # DragonFly does not have aout.  When/if they implement a new
-  # versioning mechanism, adjust this.
-  if test -x /usr/bin/objformat; then
-    objformat=`/usr/bin/objformat`
-  else
-    case $host_os in
-    freebsd[23].*) objformat=aout ;;
-    *) objformat=elf ;;
-    esac
-  fi
-  version_type=freebsd-$objformat
-  case $version_type in
-    freebsd-elf*)
-      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
-      need_version=no
-      need_lib_prefix=no
-      ;;
-    freebsd-*)
-      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
-      need_version=yes
-      ;;
-  esac
-  shlibpath_var=LD_LIBRARY_PATH
-  case $host_os in
-  freebsd2.*)
-    shlibpath_overrides_runpath=yes
-    ;;
-  freebsd3.[01]* | freebsdelf3.[01]*)
-    shlibpath_overrides_runpath=yes
-    hardcode_into_libs=yes
-    ;;
-  freebsd3.[2-9]* | freebsdelf3.[2-9]* | \
-  freebsd4.[0-5] | freebsdelf4.[0-5] | freebsd4.1.1 | freebsdelf4.1.1)
-    shlibpath_overrides_runpath=no
-    hardcode_into_libs=yes
-    ;;
-  *) # from 4.6 on, and DragonFly
-    shlibpath_overrides_runpath=yes
-    hardcode_into_libs=yes
-    ;;
-  esac
-  ;;
-
-gnu*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  hardcode_into_libs=yes
-  ;;
-
-haiku*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  dynamic_linker="$host_os runtime_loader"
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/beos/system/lib'
-  hardcode_into_libs=yes
-  ;;
-
-hpux9* | hpux10* | hpux11*)
-  # Give a soname corresponding to the major version so that dld.sl refuses to
-  # link against other versions.
-  version_type=sunos
-  need_lib_prefix=no
-  need_version=no
-  case $host_cpu in
-  ia64*)
-    shrext_cmds='.so'
-    hardcode_into_libs=yes
-    dynamic_linker="$host_os dld.so"
-    shlibpath_var=LD_LIBRARY_PATH
-    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    if test "X$HPUX_IA64_MODE" = X32; then
-      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
-    else
-      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
-    fi
-    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
-    ;;
-  hppa*64*)
-    shrext_cmds='.sl'
-    hardcode_into_libs=yes
-    dynamic_linker="$host_os dld.sl"
-    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
-    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
-    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
-    ;;
-  *)
-    shrext_cmds='.sl'
-    dynamic_linker="$host_os dld.sl"
-    shlibpath_var=SHLIB_PATH
-    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    ;;
-  esac
-  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...
-  postinstall_cmds='chmod 555 $lib'
-  # or fails outright, so override atomically:
-  install_override_mode=555
-  ;;
-
-interix[3-9]*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  ;;
-
-irix5* | irix6* | nonstopux*)
-  case $host_os in
-    nonstopux*) version_type=nonstopux ;;
-    *)
-	if test "$lt_cv_prog_gnu_ld" = yes; then
-		version_type=linux
-	else
-		version_type=irix
-	fi ;;
-  esac
-  need_lib_prefix=no
-  need_version=no
-  soname_spec='${libname}${release}${shared_ext}$major'
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
-  case $host_os in
-  irix5* | nonstopux*)
-    libsuff= shlibsuff=
-    ;;
-  *)
-    case $LD in # libtool.m4 will add one of these switches to LD
-    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
-      libsuff= shlibsuff= libmagic=32-bit;;
-    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
-      libsuff=32 shlibsuff=N32 libmagic=N32;;
-    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
-      libsuff=64 shlibsuff=64 libmagic=64-bit;;
-    *) libsuff= shlibsuff= libmagic=never-match;;
-    esac
-    ;;
-  esac
-  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
-  shlibpath_overrides_runpath=no
-  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
-  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
-  hardcode_into_libs=yes
-  ;;
-
-# No shared lib support for Linux oldld, aout, or coff.
-linux*oldld* | linux*aout* | linux*coff*)
-  dynamic_linker=no
-  ;;
-
-# This must be Linux ELF.
-linux* | k*bsd*-gnu | kopensolaris*-gnu)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-
-  # Some binutils ld are patched to set DT_RUNPATH
-  if test "${lt_cv_shlibpath_overrides_runpath+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_shlibpath_overrides_runpath=no
-    save_LDFLAGS=$LDFLAGS
-    save_libdir=$libdir
-    eval "libdir=/foo; wl=\"$lt_prog_compiler_wl\"; \
-	 LDFLAGS=\"\$LDFLAGS $hardcode_libdir_flag_spec\""
-    if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  if  ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null; then :
-  lt_cv_shlibpath_overrides_runpath=yes
-fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-    LDFLAGS=$save_LDFLAGS
-    libdir=$save_libdir
-
-fi
-
-  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath
-
-  # This implies no fast_install, which is unacceptable.
-  # Some rework will be needed to allow for fast_install
-  # before this can be enabled.
-  hardcode_into_libs=yes
-
-  # Append ld.so.conf contents to the search path
-  if test -f /etc/ld.so.conf; then
-    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
-    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
-  fi
-
-  # We used to test for /lib/ld.so.1 and disable shared libraries on
-  # powerpc, because MkLinux only supported shared libraries with the
-  # GNU dynamic linker.  Since this was broken with cross compilers,
-  # most powerpc-linux boxes support dynamic linking these days and
-  # people can always --disable-shared, the test was removed, and we
-  # assume the GNU/Linux dynamic linker is in use.
-  dynamic_linker='GNU/Linux ld.so'
-  ;;
-
-netbsd*)
-  version_type=sunos
-  need_lib_prefix=no
-  need_version=no
-  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
-    dynamic_linker='NetBSD (a.out) ld.so'
-  else
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    dynamic_linker='NetBSD ld.elf_so'
-  fi
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  hardcode_into_libs=yes
-  ;;
-
-newsos6)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  ;;
-
-*nto* | *qnx*)
-  version_type=qnx
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  dynamic_linker='ldqnx.so'
-  ;;
-
-openbsd*)
-  version_type=sunos
-  sys_lib_dlsearch_path_spec="/usr/lib"
-  need_lib_prefix=no
-  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
-  case $host_os in
-    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
-    *)				need_version=no  ;;
-  esac
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-    case $host_os in
-      openbsd2.[89] | openbsd2.[89].*)
-	shlibpath_overrides_runpath=no
-	;;
-      *)
-	shlibpath_overrides_runpath=yes
-	;;
-      esac
-  else
-    shlibpath_overrides_runpath=yes
-  fi
-  ;;
-
-os2*)
-  libname_spec='$name'
-  shrext_cmds=".dll"
-  need_lib_prefix=no
-  library_names_spec='$libname${shared_ext} $libname.a'
-  dynamic_linker='OS/2 ld.exe'
-  shlibpath_var=LIBPATH
-  ;;
-
-osf3* | osf4* | osf5*)
-  version_type=osf
-  need_lib_prefix=no
-  need_version=no
-  soname_spec='${libname}${release}${shared_ext}$major'
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
-  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
-  ;;
-
-rdos*)
-  dynamic_linker=no
-  ;;
-
-solaris*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  hardcode_into_libs=yes
-  # ldd complains unless libraries are executable
-  postinstall_cmds='chmod +x $lib'
-  ;;
-
-sunos4*)
-  version_type=sunos
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  if test "$with_gnu_ld" = yes; then
-    need_lib_prefix=no
-  fi
-  need_version=yes
-  ;;
-
-sysv4 | sysv4.3*)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  case $host_vendor in
-    sni)
-      shlibpath_overrides_runpath=no
-      need_lib_prefix=no
-      runpath_var=LD_RUN_PATH
-      ;;
-    siemens)
-      need_lib_prefix=no
-      ;;
-    motorola)
-      need_lib_prefix=no
-      need_version=no
-      shlibpath_overrides_runpath=no
-      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
-      ;;
-  esac
-  ;;
-
-sysv4*MP*)
-  if test -d /usr/nec ;then
-    version_type=linux
-    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
-    soname_spec='$libname${shared_ext}.$major'
-    shlibpath_var=LD_LIBRARY_PATH
-  fi
-  ;;
-
-sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
-  version_type=freebsd-elf
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  hardcode_into_libs=yes
-  if test "$with_gnu_ld" = yes; then
-    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
-  else
-    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
-    case $host_os in
-      sco3.2v5*)
-        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
-	;;
-    esac
-  fi
-  sys_lib_dlsearch_path_spec='/usr/lib'
-  ;;
-
-tpf*)
-  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  ;;
-
-uts4*)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  ;;
-
-*)
-  dynamic_linker=no
-  ;;
-esac
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $dynamic_linker" >&5
-$as_echo "$dynamic_linker" >&6; }
-test "$dynamic_linker" = no && can_build_shared=no
-
-variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
-if test "$GCC" = yes; then
-  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
-fi
-
-if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
-  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
-fi
-if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
-  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking how to hardcode library paths into programs" >&5
-$as_echo_n "checking how to hardcode library paths into programs... " >&6; }
-hardcode_action=
-if test -n "$hardcode_libdir_flag_spec" ||
-   test -n "$runpath_var" ||
-   test "X$hardcode_automatic" = "Xyes" ; then
-
-  # We can hardcode non-existent directories.
-  if test "$hardcode_direct" != no &&
-     # If the only mechanism to avoid hardcoding is shlibpath_var, we
-     # have to relink, otherwise we might link with an installed library
-     # when we should be linking with a yet-to-be-installed one
-     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, )" != no &&
-     test "$hardcode_minus_L" != no; then
-    # Linking always hardcodes the temporary library directory.
-    hardcode_action=relink
-  else
-    # We can link without hardcoding, and we can hardcode nonexisting dirs.
-    hardcode_action=immediate
-  fi
-else
-  # We cannot hardcode anything, or else we can only hardcode existing
-  # directories.
-  hardcode_action=unsupported
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action" >&5
-$as_echo "$hardcode_action" >&6; }
-
-if test "$hardcode_action" = relink ||
-   test "$inherit_rpath" = yes; then
-  # Fast installation is not supported
-  enable_fast_install=no
-elif test "$shlibpath_overrides_runpath" = yes ||
-     test "$enable_shared" = no; then
-  # Fast installation is not necessary
-  enable_fast_install=needless
-fi
-
-
-
-
-
-
-  if test "x$enable_dlopen" != xyes; then
-  enable_dlopen=unknown
-  enable_dlopen_self=unknown
-  enable_dlopen_self_static=unknown
-else
-  lt_cv_dlopen=no
-  lt_cv_dlopen_libs=
-
-  case $host_os in
-  beos*)
-    lt_cv_dlopen="load_add_on"
-    lt_cv_dlopen_libs=
-    lt_cv_dlopen_self=yes
-    ;;
-
-  mingw* | pw32* | cegcc*)
-    lt_cv_dlopen="LoadLibrary"
-    lt_cv_dlopen_libs=
-    ;;
-
-  cygwin*)
-    lt_cv_dlopen="dlopen"
-    lt_cv_dlopen_libs=
-    ;;
-
-  darwin*)
-  # if libdl is installed we need to link against it
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
-$as_echo_n "checking for dlopen in -ldl... " >&6; }
-if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldl  $LIBS"
-if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dlopen ();
-int
-main ()
-{
-return dlopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dl_dlopen=yes
-else
-  ac_cv_lib_dl_dlopen=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
-$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
-if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
-else
-
-    lt_cv_dlopen="dyld"
-    lt_cv_dlopen_libs=
-    lt_cv_dlopen_self=yes
-
-fi
-
-    ;;
-
-  *)
-    ac_fn_c_check_func "$LINENO" "shl_load" "ac_cv_func_shl_load"
-if test "x$ac_cv_func_shl_load" = x""yes; then :
-  lt_cv_dlopen="shl_load"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shl_load in -ldld" >&5
-$as_echo_n "checking for shl_load in -ldld... " >&6; }
-if test "${ac_cv_lib_dld_shl_load+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldld  $LIBS"
-if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char shl_load ();
-int
-main ()
-{
-return shl_load ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dld_shl_load=yes
-else
-  ac_cv_lib_dld_shl_load=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_shl_load" >&5
-$as_echo "$ac_cv_lib_dld_shl_load" >&6; }
-if test "x$ac_cv_lib_dld_shl_load" = x""yes; then :
-  lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"
-else
-  ac_fn_c_check_func "$LINENO" "dlopen" "ac_cv_func_dlopen"
-if test "x$ac_cv_func_dlopen" = x""yes; then :
-  lt_cv_dlopen="dlopen"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
-$as_echo_n "checking for dlopen in -ldl... " >&6; }
-if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldl  $LIBS"
-if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dlopen ();
-int
-main ()
-{
-return dlopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dl_dlopen=yes
-else
-  ac_cv_lib_dl_dlopen=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
-$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
-if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -lsvld" >&5
-$as_echo_n "checking for dlopen in -lsvld... " >&6; }
-if test "${ac_cv_lib_svld_dlopen+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lsvld  $LIBS"
-if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dlopen ();
-int
-main ()
-{
-return dlopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_svld_dlopen=yes
-else
-  ac_cv_lib_svld_dlopen=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_svld_dlopen" >&5
-$as_echo "$ac_cv_lib_svld_dlopen" >&6; }
-if test "x$ac_cv_lib_svld_dlopen" = x""yes; then :
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dld_link in -ldld" >&5
-$as_echo_n "checking for dld_link in -ldld... " >&6; }
-if test "${ac_cv_lib_dld_dld_link+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldld  $LIBS"
-if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dld_link ();
-int
-main ()
-{
-return dld_link ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dld_dld_link=yes
-else
-  ac_cv_lib_dld_dld_link=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_dld_link" >&5
-$as_echo "$ac_cv_lib_dld_dld_link" >&6; }
-if test "x$ac_cv_lib_dld_dld_link" = x""yes; then :
-  lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"
-fi
-
-
-fi
-
-
-fi
-
-
-fi
-
-
-fi
-
-
-fi
-
-    ;;
-  esac
-
-  if test "x$lt_cv_dlopen" != xno; then
-    enable_dlopen=yes
-  else
-    enable_dlopen=no
-  fi
-
-  case $lt_cv_dlopen in
-  dlopen)
-    save_CPPFLAGS="$CPPFLAGS"
-    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
-
-    save_LDFLAGS="$LDFLAGS"
-    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
-
-    save_LIBS="$LIBS"
-    LIBS="$lt_cv_dlopen_libs $LIBS"
-
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a program can dlopen itself" >&5
-$as_echo_n "checking whether a program can dlopen itself... " >&6; }
-if test "${lt_cv_dlopen_self+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  	  if test "$cross_compiling" = yes; then :
-  lt_cv_dlopen_self=cross
-else
-  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
-  lt_status=$lt_dlunknown
-  cat > conftest.$ac_ext <<_LT_EOF
-#line 10397 "configure"
-#include "confdefs.h"
-
-#if HAVE_DLFCN_H
-#include <dlfcn.h>
-#endif
-
-#include <stdio.h>
-
-#ifdef RTLD_GLOBAL
-#  define LT_DLGLOBAL		RTLD_GLOBAL
-#else
-#  ifdef DL_GLOBAL
-#    define LT_DLGLOBAL		DL_GLOBAL
-#  else
-#    define LT_DLGLOBAL		0
-#  endif
-#endif
-
-/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
-   find out it does not work in some platform. */
-#ifndef LT_DLLAZY_OR_NOW
-#  ifdef RTLD_LAZY
-#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
-#  else
-#    ifdef DL_LAZY
-#      define LT_DLLAZY_OR_NOW		DL_LAZY
-#    else
-#      ifdef RTLD_NOW
-#        define LT_DLLAZY_OR_NOW	RTLD_NOW
-#      else
-#        ifdef DL_NOW
-#          define LT_DLLAZY_OR_NOW	DL_NOW
-#        else
-#          define LT_DLLAZY_OR_NOW	0
-#        endif
-#      endif
-#    endif
-#  endif
-#endif
-
-/* When -fvisbility=hidden is used, assume the code has been annotated
-   correspondingly for the symbols needed.  */
-#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
-void fnord () __attribute__((visibility("default")));
-#endif
-
-void fnord () { int i=42; }
-int main ()
-{
-  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
-  int status = $lt_dlunknown;
-
-  if (self)
-    {
-      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
-      else
-        {
-	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
-          else puts (dlerror ());
-	}
-      /* dlclose (self); */
-    }
-  else
-    puts (dlerror ());
-
-  return status;
-}
-_LT_EOF
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
-    (./conftest; exit; ) >&5 2>/dev/null
-    lt_status=$?
-    case x$lt_status in
-      x$lt_dlno_uscore) lt_cv_dlopen_self=yes ;;
-      x$lt_dlneed_uscore) lt_cv_dlopen_self=yes ;;
-      x$lt_dlunknown|x*) lt_cv_dlopen_self=no ;;
-    esac
-  else :
-    # compilation failed
-    lt_cv_dlopen_self=no
-  fi
-fi
-rm -fr conftest*
-
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self" >&5
-$as_echo "$lt_cv_dlopen_self" >&6; }
-
-    if test "x$lt_cv_dlopen_self" = xyes; then
-      wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a statically linked program can dlopen itself" >&5
-$as_echo_n "checking whether a statically linked program can dlopen itself... " >&6; }
-if test "${lt_cv_dlopen_self_static+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  	  if test "$cross_compiling" = yes; then :
-  lt_cv_dlopen_self_static=cross
-else
-  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
-  lt_status=$lt_dlunknown
-  cat > conftest.$ac_ext <<_LT_EOF
-#line 10503 "configure"
-#include "confdefs.h"
-
-#if HAVE_DLFCN_H
-#include <dlfcn.h>
-#endif
-
-#include <stdio.h>
-
-#ifdef RTLD_GLOBAL
-#  define LT_DLGLOBAL		RTLD_GLOBAL
-#else
-#  ifdef DL_GLOBAL
-#    define LT_DLGLOBAL		DL_GLOBAL
-#  else
-#    define LT_DLGLOBAL		0
-#  endif
-#endif
-
-/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
-   find out it does not work in some platform. */
-#ifndef LT_DLLAZY_OR_NOW
-#  ifdef RTLD_LAZY
-#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
-#  else
-#    ifdef DL_LAZY
-#      define LT_DLLAZY_OR_NOW		DL_LAZY
-#    else
-#      ifdef RTLD_NOW
-#        define LT_DLLAZY_OR_NOW	RTLD_NOW
-#      else
-#        ifdef DL_NOW
-#          define LT_DLLAZY_OR_NOW	DL_NOW
-#        else
-#          define LT_DLLAZY_OR_NOW	0
-#        endif
-#      endif
-#    endif
-#  endif
-#endif
-
-/* When -fvisbility=hidden is used, assume the code has been annotated
-   correspondingly for the symbols needed.  */
-#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
-void fnord () __attribute__((visibility("default")));
-#endif
-
-void fnord () { int i=42; }
-int main ()
-{
-  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
-  int status = $lt_dlunknown;
-
-  if (self)
-    {
-      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
-      else
-        {
-	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
-          else puts (dlerror ());
-	}
-      /* dlclose (self); */
-    }
-  else
-    puts (dlerror ());
-
-  return status;
-}
-_LT_EOF
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
-    (./conftest; exit; ) >&5 2>/dev/null
-    lt_status=$?
-    case x$lt_status in
-      x$lt_dlno_uscore) lt_cv_dlopen_self_static=yes ;;
-      x$lt_dlneed_uscore) lt_cv_dlopen_self_static=yes ;;
-      x$lt_dlunknown|x*) lt_cv_dlopen_self_static=no ;;
-    esac
-  else :
-    # compilation failed
-    lt_cv_dlopen_self_static=no
-  fi
-fi
-rm -fr conftest*
-
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self_static" >&5
-$as_echo "$lt_cv_dlopen_self_static" >&6; }
-    fi
-
-    CPPFLAGS="$save_CPPFLAGS"
-    LDFLAGS="$save_LDFLAGS"
-    LIBS="$save_LIBS"
-    ;;
-  esac
-
-  case $lt_cv_dlopen_self in
-  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
-  *) enable_dlopen_self=unknown ;;
-  esac
-
-  case $lt_cv_dlopen_self_static in
-  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
-  *) enable_dlopen_self_static=unknown ;;
-  esac
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-striplib=
-old_striplib=
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether stripping libraries is possible" >&5
-$as_echo_n "checking whether stripping libraries is possible... " >&6; }
-if test -n "$STRIP" && $STRIP -V 2>&1 | $GREP "GNU strip" >/dev/null; then
-  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
-  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-else
-# FIXME - insert some real tests, host_os isn't really good enough
-  case $host_os in
-  darwin*)
-    if test -n "$STRIP" ; then
-      striplib="$STRIP -x"
-      old_striplib="$STRIP -S"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-    else
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-    fi
-    ;;
-  *)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-    ;;
-  esac
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-  # Report which library types will actually be built
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if libtool supports shared libraries" >&5
-$as_echo_n "checking if libtool supports shared libraries... " >&6; }
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $can_build_shared" >&5
-$as_echo "$can_build_shared" >&6; }
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build shared libraries" >&5
-$as_echo_n "checking whether to build shared libraries... " >&6; }
-  test "$can_build_shared" = "no" && enable_shared=no
-
-  # On AIX, shared libraries and static libraries use the same namespace, and
-  # are all built from PIC.
-  case $host_os in
-  aix3*)
-    test "$enable_shared" = yes && enable_static=no
-    if test -n "$RANLIB"; then
-      archive_cmds="$archive_cmds~\$RANLIB \$lib"
-      postinstall_cmds='$RANLIB $lib'
-    fi
-    ;;
-
-  aix[4-9]*)
-    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
-      test "$enable_shared" = yes && enable_static=no
-    fi
-    ;;
-  esac
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_shared" >&5
-$as_echo "$enable_shared" >&6; }
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build static libraries" >&5
-$as_echo_n "checking whether to build static libraries... " >&6; }
-  # Make sure either enable_shared or enable_static is yes.
-  test "$enable_shared" = yes || enable_static=yes
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_static" >&5
-$as_echo "$enable_static" >&6; }
-
-
-
-
-fi
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-CC="$lt_save_CC"
-
-
-
-
-
-
-
-
-
-
-
-
-
-        ac_config_commands="$ac_config_commands libtool"
-
-
-
-
-# Only expand once:
-
-
-
-# Find CPP now so that any conditional tests below won't do it and
-# thereby make the resulting definitions conditional.
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
-$as_echo_n "checking how to run the C preprocessor... " >&6; }
-# On Suns, sometimes $CPP names a directory.
-if test -n "$CPP" && test -d "$CPP"; then
-  CPP=
-fi
-if test -z "$CPP"; then
-  if test "${ac_cv_prog_CPP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-      # Double quotes because CPP needs to be expanded
-    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
-    do
-      ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-  break
-fi
-
-    done
-    ac_cv_prog_CPP=$CPP
-
-fi
-  CPP=$ac_cv_prog_CPP
-else
-  ac_cv_prog_CPP=$CPP
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
-$as_echo "$CPP" >&6; }
-ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-
-else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details." "$LINENO" 5; }
-fi
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-if test -n "$with_cross_host"; then
-   # We are being configured with a cross compiler.  AC_REPLACE_FUNCS
-   # may not work correctly, because the compiler may not be able to
-   # link executables.
-
-   # We assume newlib.  This lets us hard-code the functions we know
-   # we'll have.
-   $as_echo "#define HAVE_MEMCPY 1" >>confdefs.h
-
-   $as_echo "#define HAVE_STRERROR 1" >>confdefs.h
-
-
-   # We ignore --with-system-zlib in this case.
-   target_all=libzgcj.la
-else
-   if test x$gcc_no_link = xyes; then
-  if test "x${ac_cv_func_mmap_fixed_mapped+set}" != xset; then
-    ac_cv_func_mmap_fixed_mapped=no
-  fi
-fi
-if test "x${ac_cv_func_mmap_fixed_mapped}" != xno; then
-  for ac_header in stdlib.h unistd.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-for ac_func in getpagesize
-do :
-  ac_fn_c_check_func "$LINENO" "getpagesize" "ac_cv_func_getpagesize"
-if test "x$ac_cv_func_getpagesize" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_GETPAGESIZE 1
-_ACEOF
-
-fi
-done
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for working mmap" >&5
-$as_echo_n "checking for working mmap... " >&6; }
-if test "${ac_cv_func_mmap_fixed_mapped+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then :
-  ac_cv_func_mmap_fixed_mapped=no
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$ac_includes_default
-/* malloc might have been renamed as rpl_malloc. */
-#undef malloc
-
-/* Thanks to Mike Haertel and Jim Avera for this test.
-   Here is a matrix of mmap possibilities:
-	mmap private not fixed
-	mmap private fixed at somewhere currently unmapped
-	mmap private fixed at somewhere already mapped
-	mmap shared not fixed
-	mmap shared fixed at somewhere currently unmapped
-	mmap shared fixed at somewhere already mapped
-   For private mappings, we should verify that changes cannot be read()
-   back from the file, nor mmap's back from the file at a different
-   address.  (There have been systems where private was not correctly
-   implemented like the infamous i386 svr4.0, and systems where the
-   VM page cache was not coherent with the file system buffer cache
-   like early versions of FreeBSD and possibly contemporary NetBSD.)
-   For shared mappings, we should conversely verify that changes get
-   propagated back to all the places they're supposed to be.
-
-   Grep wants private fixed already mapped.
-   The main things grep needs to know about mmap are:
-   * does it exist and is it safe to write into the mmap'd area
-   * how to use it (BSD variants)  */
-
-#include <fcntl.h>
-#include <sys/mman.h>
-
-#if !defined STDC_HEADERS && !defined HAVE_STDLIB_H
-char *malloc ();
-#endif
-
-/* This mess was copied from the GNU getpagesize.h.  */
-#ifndef HAVE_GETPAGESIZE
-/* Assume that all systems that can run configure have sys/param.h.  */
-# ifndef HAVE_SYS_PARAM_H
-#  define HAVE_SYS_PARAM_H 1
-# endif
-
-# ifdef _SC_PAGESIZE
-#  define getpagesize() sysconf(_SC_PAGESIZE)
-# else /* no _SC_PAGESIZE */
-#  ifdef HAVE_SYS_PARAM_H
-#   include <sys/param.h>
-#   ifdef EXEC_PAGESIZE
-#    define getpagesize() EXEC_PAGESIZE
-#   else /* no EXEC_PAGESIZE */
-#    ifdef NBPG
-#     define getpagesize() NBPG * CLSIZE
-#     ifndef CLSIZE
-#      define CLSIZE 1
-#     endif /* no CLSIZE */
-#    else /* no NBPG */
-#     ifdef NBPC
-#      define getpagesize() NBPC
-#     else /* no NBPC */
-#      ifdef PAGESIZE
-#       define getpagesize() PAGESIZE
-#      endif /* PAGESIZE */
-#     endif /* no NBPC */
-#    endif /* no NBPG */
-#   endif /* no EXEC_PAGESIZE */
-#  else /* no HAVE_SYS_PARAM_H */
-#   define getpagesize() 8192	/* punt totally */
-#  endif /* no HAVE_SYS_PARAM_H */
-# endif /* no _SC_PAGESIZE */
-
-#endif /* no HAVE_GETPAGESIZE */
-
-int
-main ()
-{
-  char *data, *data2, *data3;
-  int i, pagesize;
-  int fd;
-
-  pagesize = getpagesize ();
-
-  /* First, make a file with some known garbage in it. */
-  data = (char *) malloc (pagesize);
-  if (!data)
-    return 1;
-  for (i = 0; i < pagesize; ++i)
-    *(data + i) = rand ();
-  umask (0);
-  fd = creat ("conftest.mmap", 0600);
-  if (fd < 0)
-    return 1;
-  if (write (fd, data, pagesize) != pagesize)
-    return 1;
-  close (fd);
-
-  /* Next, try to mmap the file at a fixed address which already has
-     something else allocated at it.  If we can, also make sure that
-     we see the same garbage.  */
-  fd = open ("conftest.mmap", O_RDWR);
-  if (fd < 0)
-    return 1;
-  data2 = (char *) malloc (2 * pagesize);
-  if (!data2)
-    return 1;
-  data2 += (pagesize - ((long int) data2 & (pagesize - 1))) & (pagesize - 1);
-  if (data2 != mmap (data2, pagesize, PROT_READ | PROT_WRITE,
-		     MAP_PRIVATE | MAP_FIXED, fd, 0L))
-    return 1;
-  for (i = 0; i < pagesize; ++i)
-    if (*(data + i) != *(data2 + i))
-      return 1;
-
-  /* Finally, make sure that changes to the mapped area do not
-     percolate back to the file as seen by read().  (This is a bug on
-     some variants of i386 svr4.0.)  */
-  for (i = 0; i < pagesize; ++i)
-    *(data2 + i) = *(data2 + i) + 1;
-  data3 = (char *) malloc (pagesize);
-  if (!data3)
-    return 1;
-  if (read (fd, data3, pagesize) != pagesize)
-    return 1;
-  for (i = 0; i < pagesize; ++i)
-    if (*(data + i) != *(data3 + i))
-      return 1;
-  close (fd);
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
-  ac_cv_func_mmap_fixed_mapped=yes
-else
-  ac_cv_func_mmap_fixed_mapped=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_func_mmap_fixed_mapped" >&5
-$as_echo "$ac_cv_func_mmap_fixed_mapped" >&6; }
-if test $ac_cv_func_mmap_fixed_mapped = yes; then
-
-$as_echo "#define HAVE_MMAP 1" >>confdefs.h
-
-fi
-rm -f conftest.mmap
-
-fi
-   for ac_func in memcpy strerror
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-done
-
-
-   if test "$with_system_zlib" = yes; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for deflate in -lz" >&5
-$as_echo_n "checking for deflate in -lz... " >&6; }
-if test "${ac_cv_lib_z_deflate+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lz  $LIBS"
-if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char deflate ();
-int
-main ()
-{
-return deflate ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_z_deflate=yes
-else
-  ac_cv_lib_z_deflate=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_z_deflate" >&5
-$as_echo "$ac_cv_lib_z_deflate" >&6; }
-if test "x$ac_cv_lib_z_deflate" = x""yes; then :
-  target_all=
-else
-  target_all=libzgcj.la
-fi
-
-   else
-      target_all=libzgcj.la
-   fi
-fi
-
-
-
-for ac_header in unistd.h
-do :
-  ac_fn_c_check_header_mongrel "$LINENO" "unistd.h" "ac_cv_header_unistd_h" "$ac_includes_default"
-if test "x$ac_cv_header_unistd_h" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_UNISTD_H 1
-_ACEOF
-
-fi
-
-done
-
-
-if test -n "$with_cross_host" &&
-   test x"$with_cross_host" != x"no"; then
-  toolexecdir='$(exec_prefix)/$(target_alias)'
-  toolexeclibdir='$(toolexecdir)/lib'
-else
-  toolexecdir='$(libdir)/gcc-lib/$(target_alias)'
-  toolexeclibdir='$(libdir)'
-fi
-if test "$GCC" = yes && $CC -print-multi-os-directory > /dev/null 2>&1; then
-  multiosdir=/`$CC -print-multi-os-directory`
-  case $multiosdir in
-    /.) multiosdir= ;; # Avoid trailing /.
-  esac
-else
-  multiosdir=
-fi
-toolexeclibdir=${toolexeclibdir}${multiosdir}
-
-
-
- if test -n "$with_target_subdir"; then
-  TARGET_LIBRARY_TRUE=
-  TARGET_LIBRARY_FALSE='#'
-else
-  TARGET_LIBRARY_TRUE='#'
-  TARGET_LIBRARY_FALSE=
-fi
-
-
-if test "${multilib}" = "yes"; then
-  multilib_arg="--enable-multilib"
-else
-  multilib_arg=
-fi
-
-ac_config_files="$ac_config_files Makefile"
-
-cat >confcache <<\_ACEOF
-# This file is a shell script that caches the results of configure
-# tests run on this system so they can be shared between configure
-# scripts and configure runs, see configure's option --config-cache.
-# It is not useful on other systems.  If it contains results you don't
-# want to keep, you may remove or edit it.
-#
-# config.status only pays attention to the cache file if you give it
-# the --recheck option to rerun configure.
-#
-# `ac_cv_env_foo' variables (set or unset) will be overridden when
-# loading this file, other *unset* `ac_cv_foo' will be assigned the
-# following values.
-
-_ACEOF
-
-# The following way of writing the cache mishandles newlines in values,
-# but we know of no workaround that is simple, portable, and efficient.
-# So, we kill variables containing newlines.
-# Ultrix sh set writes to stderr and can't be redirected directly,
-# and sets the high bit in the cache file unless we assign to the vars.
-(
-  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
-    eval ac_val=\$$ac_var
-    case $ac_val in #(
-    *${as_nl}*)
-      case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
-$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
-      esac
-      case $ac_var in #(
-      _ | IFS | as_nl) ;; #(
-      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
-      *) { eval $ac_var=; unset $ac_var;} ;;
-      esac ;;
-    esac
-  done
-
-  (set) 2>&1 |
-    case $as_nl`(ac_space=' '; set) 2>&1` in #(
-    *${as_nl}ac_space=\ *)
-      # `set' does not quote correctly, so add quotes: double-quote
-      # substitution turns \\\\ into \\, and sed turns \\ into \.
-      sed -n \
-	"s/'/'\\\\''/g;
-	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
-      ;; #(
-    *)
-      # `set' quotes correctly as required by POSIX, so do not add quotes.
-      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
-      ;;
-    esac |
-    sort
-) |
-  sed '
-     /^ac_cv_env_/b end
-     t clear
-     :clear
-     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
-     t end
-     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
-     :end' >>confcache
-if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
-  if test -w "$cache_file"; then
-    test "x$cache_file" != "x/dev/null" &&
-      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
-$as_echo "$as_me: updating cache $cache_file" >&6;}
-    cat confcache >$cache_file
-  else
-    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
-$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
-  fi
-fi
-rm -f confcache
-
-test "x$prefix" = xNONE && prefix=$ac_default_prefix
-# Let make expand exec_prefix.
-test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
-
-# Transform confdefs.h into DEFS.
-# Protect against shell expansion while executing Makefile rules.
-# Protect against Makefile macro expansion.
-#
-# If the first sed substitution is executed (which looks for macros that
-# take arguments), then branch to the quote section.  Otherwise,
-# look for a macro that doesn't take arguments.
-ac_script='
-:mline
-/\\$/{
- N
- s,\\\n,,
- b mline
-}
-t clear
-:clear
-s/^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*([^)]*)\)[	 ]*\(.*\)/-D\1=\2/g
-t quote
-s/^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\)/-D\1=\2/g
-t quote
-b any
-:quote
-s/[	 `~#$^&*(){}\\|;'\''"<>?]/\\&/g
-s/\[/\\&/g
-s/\]/\\&/g
-s/\$/$$/g
-H
-:any
-${
-	g
-	s/^\n//
-	s/\n/ /g
-	p
-}
-'
-DEFS=`sed -n "$ac_script" confdefs.h`
-
-
-ac_libobjs=
-ac_ltlibobjs=
-for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
-  # 1. Remove the extension, and $U if already installed.
-  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
-  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
-  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
-  #    will be set to the directory where LIBOBJS objects are built.
-  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
-  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
-done
-LIBOBJS=$ac_libobjs
-
-LTLIBOBJS=$ac_ltlibobjs
-
-
- if test -n "$EXEEXT"; then
-  am__EXEEXT_TRUE=
-  am__EXEEXT_FALSE='#'
-else
-  am__EXEEXT_TRUE='#'
-  am__EXEEXT_FALSE=
-fi
-
-if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
-  as_fn_error "conditional \"MAINTAINER_MODE\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
-fi
-if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
-  as_fn_error "conditional \"AMDEP\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
-fi
-if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
-  as_fn_error "conditional \"am__fastdepCC\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
-fi
-if test -z "${TARGET_LIBRARY_TRUE}" && test -z "${TARGET_LIBRARY_FALSE}"; then
-  as_fn_error "conditional \"TARGET_LIBRARY\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
-fi
-
-: ${CONFIG_STATUS=./config.status}
-ac_write_fail=0
-ac_clean_files_save=$ac_clean_files
-ac_clean_files="$ac_clean_files $CONFIG_STATUS"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
-$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
-as_write_fail=0
-cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
-#! $SHELL
-# Generated by $as_me.
-# Run this file to recreate the current configuration.
-# Compiler output produced by configure, useful for debugging
-# configure, is in config.log if it exists.
-
-debug=false
-ac_cs_recheck=false
-ac_cs_silent=false
-
-SHELL=\${CONFIG_SHELL-$SHELL}
-export SHELL
-_ASEOF
-cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
-## -------------------- ##
-## M4sh Initialization. ##
-## -------------------- ##
-
-# Be more Bourne compatible
-DUALCASE=1; export DUALCASE # for MKS sh
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
-  emulate sh
-  NULLCMD=:
-  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in #(
-  *posix*) :
-    set -o posix ;; #(
-  *) :
-     ;;
-esac
-fi
-
-
-as_nl='
-'
-export as_nl
-# Printing a long string crashes Solaris 7 /usr/bin/printf.
-as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
-# Prefer a ksh shell builtin over an external printf program on Solaris,
-# but without wasting forks for bash or zsh.
-if test -z "$BASH_VERSION$ZSH_VERSION" \
-    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='print -r --'
-  as_echo_n='print -rn --'
-elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='printf %s\n'
-  as_echo_n='printf %s'
-else
-  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
-    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
-    as_echo_n='/usr/ucb/echo -n'
-  else
-    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
-    as_echo_n_body='eval
-      arg=$1;
-      case $arg in #(
-      *"$as_nl"*)
-	expr "X$arg" : "X\\(.*\\)$as_nl";
-	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
-      esac;
-      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
-    '
-    export as_echo_n_body
-    as_echo_n='sh -c $as_echo_n_body as_echo'
-  fi
-  export as_echo_body
-  as_echo='sh -c $as_echo_body as_echo'
-fi
-
-# The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
-  PATH_SEPARATOR=:
-  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
-    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
-      PATH_SEPARATOR=';'
-  }
-fi
-
-
-# IFS
-# We need space, tab and new line, in precisely that order.  Quoting is
-# there to prevent editors from complaining about space-tab.
-# (If _AS_PATH_WALK were called with IFS unset, it would disable word
-# splitting by setting IFS to empty value.)
-IFS=" ""	$as_nl"
-
-# Find who we are.  Look in the path if we contain no directory separator.
-case $0 in #((
-  *[\\/]* ) as_myself=$0 ;;
-  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-  done
-IFS=$as_save_IFS
-
-     ;;
-esac
-# We did not find ourselves, most probably we were run as `sh COMMAND'
-# in which case we are not to be found in the path.
-if test "x$as_myself" = x; then
-  as_myself=$0
-fi
-if test ! -f "$as_myself"; then
-  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
-  exit 1
-fi
-
-# Unset variables that we do not need and which cause bugs (e.g. in
-# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
-# suppresses any "Segmentation fault" message there.  '((' could
-# trigger a bug in pdksh 5.2.14.
-for as_var in BASH_ENV ENV MAIL MAILPATH
-do eval test x\${$as_var+set} = xset \
-  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
-done
-PS1='$ '
-PS2='> '
-PS4='+ '
-
-# NLS nuisances.
-LC_ALL=C
-export LC_ALL
-LANGUAGE=C
-export LANGUAGE
-
-# CDPATH.
-(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
-
-
-# as_fn_error ERROR [LINENO LOG_FD]
-# ---------------------------------
-# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
-# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with status $?, using 1 if that was 0.
-as_fn_error ()
-{
-  as_status=$?; test $as_status -eq 0 && as_status=1
-  if test "$3"; then
-    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
-  fi
-  $as_echo "$as_me: error: $1" >&2
-  as_fn_exit $as_status
-} # as_fn_error
-
-
-# as_fn_set_status STATUS
-# -----------------------
-# Set $? to STATUS, without forking.
-as_fn_set_status ()
-{
-  return $1
-} # as_fn_set_status
-
-# as_fn_exit STATUS
-# -----------------
-# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
-as_fn_exit ()
-{
-  set +e
-  as_fn_set_status $1
-  exit $1
-} # as_fn_exit
-
-# as_fn_unset VAR
-# ---------------
-# Portably unset VAR.
-as_fn_unset ()
-{
-  { eval $1=; unset $1;}
-}
-as_unset=as_fn_unset
-# as_fn_append VAR VALUE
-# ----------------------
-# Append the text in VALUE to the end of the definition contained in VAR. Take
-# advantage of any shell optimizations that allow amortized linear growth over
-# repeated appends, instead of the typical quadratic growth present in naive
-# implementations.
-if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
-  eval 'as_fn_append ()
-  {
-    eval $1+=\$2
-  }'
-else
-  as_fn_append ()
-  {
-    eval $1=\$$1\$2
-  }
-fi # as_fn_append
-
-# as_fn_arith ARG...
-# ------------------
-# Perform arithmetic evaluation on the ARGs, and store the result in the
-# global $as_val. Take advantage of shells that can avoid forks. The arguments
-# must be portable across $(()) and expr.
-if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
-  eval 'as_fn_arith ()
-  {
-    as_val=$(( $* ))
-  }'
-else
-  as_fn_arith ()
-  {
-    as_val=`expr "$@" || test $? -eq 1`
-  }
-fi # as_fn_arith
-
-
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
-  as_basename=basename
-else
-  as_basename=false
-fi
-
-if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
-  as_dirname=dirname
-else
-  as_dirname=false
-fi
-
-as_me=`$as_basename -- "$0" ||
-$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
-	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X/"$0" |
-    sed '/^.*\/\([^/][^/]*\)\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
-ECHO_C= ECHO_N= ECHO_T=
-case `echo -n x` in #(((((
--n*)
-  case `echo 'xy\c'` in
-  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
-  xy)  ECHO_C='\c';;
-  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
-       ECHO_T='	';;
-  esac;;
-*)
-  ECHO_N='-n';;
-esac
-
-rm -f conf$$ conf$$.exe conf$$.file
-if test -d conf$$.dir; then
-  rm -f conf$$.dir/conf$$.file
-else
-  rm -f conf$$.dir
-  mkdir conf$$.dir 2>/dev/null
-fi
-if (echo >conf$$.file) 2>/dev/null; then
-  if ln -s conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s='ln -s'
-    # ... but there are two gotchas:
-    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
-    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
-    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
-  elif ln conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s=ln
-  else
-    as_ln_s='cp -p'
-  fi
-else
-  as_ln_s='cp -p'
-fi
-rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
-rmdir conf$$.dir 2>/dev/null
-
-
-# as_fn_mkdir_p
-# -------------
-# Create "$as_dir" as a directory, including parents if necessary.
-as_fn_mkdir_p ()
-{
-
-  case $as_dir in #(
-  -*) as_dir=./$as_dir;;
-  esac
-  test -d "$as_dir" || eval $as_mkdir_p || {
-    as_dirs=
-    while :; do
-      case $as_dir in #(
-      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
-      *) as_qdir=$as_dir;;
-      esac
-      as_dirs="'$as_qdir' $as_dirs"
-      as_dir=`$as_dirname -- "$as_dir" ||
-$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_dir" : 'X\(//\)[^/]' \| \
-	 X"$as_dir" : 'X\(//\)$' \| \
-	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_dir" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      test -d "$as_dir" && break
-    done
-    test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
-
-
-} # as_fn_mkdir_p
-if mkdir -p . 2>/dev/null; then
-  as_mkdir_p='mkdir -p "$as_dir"'
-else
-  test -d ./-p && rmdir ./-p
-  as_mkdir_p=false
-fi
-
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
-
-# Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
-
-# Sed expression to map a string onto a valid variable name.
-as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
-
-
-exec 6>&1
-## ----------------------------------- ##
-## Main body of $CONFIG_STATUS script. ##
-## ----------------------------------- ##
-_ASEOF
-test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-# Save the log message, to keep $0 and so on meaningful, and to
-# report actual input values of CONFIG_FILES etc. instead of their
-# values after options handling.
-ac_log="
-This file was extended by $as_me, which was
-generated by GNU Autoconf 2.64.  Invocation command line was
-
-  CONFIG_FILES    = $CONFIG_FILES
-  CONFIG_HEADERS  = $CONFIG_HEADERS
-  CONFIG_LINKS    = $CONFIG_LINKS
-  CONFIG_COMMANDS = $CONFIG_COMMANDS
-  $ $0 $@
-
-on `(hostname || uname -n) 2>/dev/null | sed 1q`
-"
-
-_ACEOF
-
-case $ac_config_files in *"
-"*) set x $ac_config_files; shift; ac_config_files=$*;;
-esac
-
-
-
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-# Files that config.status was made for.
-config_files="$ac_config_files"
-config_commands="$ac_config_commands"
-
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-ac_cs_usage="\
-\`$as_me' instantiates files and other configuration actions
-from templates according to the current configuration.  Unless the files
-and actions are specified as TAGs, all are instantiated by default.
-
-Usage: $0 [OPTION]... [TAG]...
-
-  -h, --help       print this help, then exit
-  -V, --version    print version number and configuration settings, then exit
-  -q, --quiet, --silent
-                   do not print progress messages
-  -d, --debug      don't remove temporary files
-      --recheck    update $as_me by reconfiguring in the same conditions
-      --file=FILE[:TEMPLATE]
-                   instantiate the configuration file FILE
-
-Configuration files:
-$config_files
-
-Configuration commands:
-$config_commands
-
-Report bugs to the package provider."
-
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-ac_cs_version="\\
-config.status
-configured by $0, generated by GNU Autoconf 2.64,
-  with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
-
-Copyright (C) 2009 Free Software Foundation, Inc.
-This config.status script is free software; the Free Software Foundation
-gives unlimited permission to copy, distribute and modify it."
-
-ac_pwd='$ac_pwd'
-srcdir='$srcdir'
-INSTALL='$INSTALL'
-MKDIR_P='$MKDIR_P'
-AWK='$AWK'
-test -n "\$AWK" || AWK=awk
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-# The default lists apply if the user does not specify any file.
-ac_need_defaults=:
-while test $# != 0
-do
-  case $1 in
-  --*=*)
-    ac_option=`expr "X$1" : 'X\([^=]*\)='`
-    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
-    ac_shift=:
-    ;;
-  *)
-    ac_option=$1
-    ac_optarg=$2
-    ac_shift=shift
-    ;;
-  esac
-
-  case $ac_option in
-  # Handling of the options.
-  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
-    ac_cs_recheck=: ;;
-  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
-    $as_echo "$ac_cs_version"; exit ;;
-  --debug | --debu | --deb | --de | --d | -d )
-    debug=: ;;
-  --file | --fil | --fi | --f )
-    $ac_shift
-    case $ac_optarg in
-    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
-    esac
-    as_fn_append CONFIG_FILES " '$ac_optarg'"
-    ac_need_defaults=false;;
-  --he | --h |  --help | --hel | -h )
-    $as_echo "$ac_cs_usage"; exit ;;
-  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-  | -silent | --silent | --silen | --sile | --sil | --si | --s)
-    ac_cs_silent=: ;;
-
-  # This is an error.
-  -*) as_fn_error "unrecognized option: \`$1'
-Try \`$0 --help' for more information." ;;
-
-  *) as_fn_append ac_config_targets " $1"
-     ac_need_defaults=false ;;
-
-  esac
-  shift
-done
-
-ac_configure_extra_args=
-
-if $ac_cs_silent; then
-  exec 6>/dev/null
-  ac_configure_extra_args="$ac_configure_extra_args --silent"
-fi
-
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-if \$ac_cs_recheck; then
-  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
-  shift
-  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
-  CONFIG_SHELL='$SHELL'
-  export CONFIG_SHELL
-  exec "\$@"
-fi
-
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-exec 5>>config.log
-{
-  echo
-  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
-## Running $as_me. ##
-_ASBOX
-  $as_echo "$ac_log"
-} >&5
-
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-#
-# INIT-COMMANDS
-#
-
-srcdir="$srcdir"
-host="$host"
-target="$target"
-with_multisubdir="$with_multisubdir"
-with_multisrctop="$with_multisrctop"
-with_target_subdir="$with_target_subdir"
-ac_configure_args="${multilib_arg} ${ac_configure_args}"
-multi_basedir="$multi_basedir"
-CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
-CC="$CC"
-CXX="$CXX"
-GFORTRAN="$GFORTRAN"
-GCJ="$GCJ"
-AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
-
-
-# The HP-UX ksh and POSIX shell print the target directory to stdout
-# if CDPATH is set.
-(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
-
-sed_quote_subst='$sed_quote_subst'
-double_quote_subst='$double_quote_subst'
-delay_variable_subst='$delay_variable_subst'
-macro_version='`$ECHO "$macro_version" | $SED "$delay_single_quote_subst"`'
-macro_revision='`$ECHO "$macro_revision" | $SED "$delay_single_quote_subst"`'
-enable_shared='`$ECHO "$enable_shared" | $SED "$delay_single_quote_subst"`'
-enable_static='`$ECHO "$enable_static" | $SED "$delay_single_quote_subst"`'
-pic_mode='`$ECHO "$pic_mode" | $SED "$delay_single_quote_subst"`'
-enable_fast_install='`$ECHO "$enable_fast_install" | $SED "$delay_single_quote_subst"`'
-SHELL='`$ECHO "$SHELL" | $SED "$delay_single_quote_subst"`'
-ECHO='`$ECHO "$ECHO" | $SED "$delay_single_quote_subst"`'
-host_alias='`$ECHO "$host_alias" | $SED "$delay_single_quote_subst"`'
-host='`$ECHO "$host" | $SED "$delay_single_quote_subst"`'
-host_os='`$ECHO "$host_os" | $SED "$delay_single_quote_subst"`'
-build_alias='`$ECHO "$build_alias" | $SED "$delay_single_quote_subst"`'
-build='`$ECHO "$build" | $SED "$delay_single_quote_subst"`'
-build_os='`$ECHO "$build_os" | $SED "$delay_single_quote_subst"`'
-SED='`$ECHO "$SED" | $SED "$delay_single_quote_subst"`'
-Xsed='`$ECHO "$Xsed" | $SED "$delay_single_quote_subst"`'
-GREP='`$ECHO "$GREP" | $SED "$delay_single_quote_subst"`'
-EGREP='`$ECHO "$EGREP" | $SED "$delay_single_quote_subst"`'
-FGREP='`$ECHO "$FGREP" | $SED "$delay_single_quote_subst"`'
-LD='`$ECHO "$LD" | $SED "$delay_single_quote_subst"`'
-NM='`$ECHO "$NM" | $SED "$delay_single_quote_subst"`'
-LN_S='`$ECHO "$LN_S" | $SED "$delay_single_quote_subst"`'
-max_cmd_len='`$ECHO "$max_cmd_len" | $SED "$delay_single_quote_subst"`'
-ac_objext='`$ECHO "$ac_objext" | $SED "$delay_single_quote_subst"`'
-exeext='`$ECHO "$exeext" | $SED "$delay_single_quote_subst"`'
-lt_unset='`$ECHO "$lt_unset" | $SED "$delay_single_quote_subst"`'
-lt_SP2NL='`$ECHO "$lt_SP2NL" | $SED "$delay_single_quote_subst"`'
-lt_NL2SP='`$ECHO "$lt_NL2SP" | $SED "$delay_single_quote_subst"`'
-reload_flag='`$ECHO "$reload_flag" | $SED "$delay_single_quote_subst"`'
-reload_cmds='`$ECHO "$reload_cmds" | $SED "$delay_single_quote_subst"`'
-OBJDUMP='`$ECHO "$OBJDUMP" | $SED "$delay_single_quote_subst"`'
-deplibs_check_method='`$ECHO "$deplibs_check_method" | $SED "$delay_single_quote_subst"`'
-file_magic_cmd='`$ECHO "$file_magic_cmd" | $SED "$delay_single_quote_subst"`'
-AR='`$ECHO "$AR" | $SED "$delay_single_quote_subst"`'
-AR_FLAGS='`$ECHO "$AR_FLAGS" | $SED "$delay_single_quote_subst"`'
-STRIP='`$ECHO "$STRIP" | $SED "$delay_single_quote_subst"`'
-RANLIB='`$ECHO "$RANLIB" | $SED "$delay_single_quote_subst"`'
-old_postinstall_cmds='`$ECHO "$old_postinstall_cmds" | $SED "$delay_single_quote_subst"`'
-old_postuninstall_cmds='`$ECHO "$old_postuninstall_cmds" | $SED "$delay_single_quote_subst"`'
-old_archive_cmds='`$ECHO "$old_archive_cmds" | $SED "$delay_single_quote_subst"`'
-lock_old_archive_extraction='`$ECHO "$lock_old_archive_extraction" | $SED "$delay_single_quote_subst"`'
-CC='`$ECHO "$CC" | $SED "$delay_single_quote_subst"`'
-CFLAGS='`$ECHO "$CFLAGS" | $SED "$delay_single_quote_subst"`'
-compiler='`$ECHO "$compiler" | $SED "$delay_single_quote_subst"`'
-GCC='`$ECHO "$GCC" | $SED "$delay_single_quote_subst"`'
-lt_cv_sys_global_symbol_pipe='`$ECHO "$lt_cv_sys_global_symbol_pipe" | $SED "$delay_single_quote_subst"`'
-lt_cv_sys_global_symbol_to_cdecl='`$ECHO "$lt_cv_sys_global_symbol_to_cdecl" | $SED "$delay_single_quote_subst"`'
-lt_cv_sys_global_symbol_to_c_name_address='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address" | $SED "$delay_single_quote_subst"`'
-lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address_lib_prefix" | $SED "$delay_single_quote_subst"`'
-objdir='`$ECHO "$objdir" | $SED "$delay_single_quote_subst"`'
-MAGIC_CMD='`$ECHO "$MAGIC_CMD" | $SED "$delay_single_quote_subst"`'
-lt_prog_compiler_no_builtin_flag='`$ECHO "$lt_prog_compiler_no_builtin_flag" | $SED "$delay_single_quote_subst"`'
-lt_prog_compiler_wl='`$ECHO "$lt_prog_compiler_wl" | $SED "$delay_single_quote_subst"`'
-lt_prog_compiler_pic='`$ECHO "$lt_prog_compiler_pic" | $SED "$delay_single_quote_subst"`'
-lt_prog_compiler_static='`$ECHO "$lt_prog_compiler_static" | $SED "$delay_single_quote_subst"`'
-lt_cv_prog_compiler_c_o='`$ECHO "$lt_cv_prog_compiler_c_o" | $SED "$delay_single_quote_subst"`'
-need_locks='`$ECHO "$need_locks" | $SED "$delay_single_quote_subst"`'
-DSYMUTIL='`$ECHO "$DSYMUTIL" | $SED "$delay_single_quote_subst"`'
-NMEDIT='`$ECHO "$NMEDIT" | $SED "$delay_single_quote_subst"`'
-LIPO='`$ECHO "$LIPO" | $SED "$delay_single_quote_subst"`'
-OTOOL='`$ECHO "$OTOOL" | $SED "$delay_single_quote_subst"`'
-OTOOL64='`$ECHO "$OTOOL64" | $SED "$delay_single_quote_subst"`'
-libext='`$ECHO "$libext" | $SED "$delay_single_quote_subst"`'
-shrext_cmds='`$ECHO "$shrext_cmds" | $SED "$delay_single_quote_subst"`'
-extract_expsyms_cmds='`$ECHO "$extract_expsyms_cmds" | $SED "$delay_single_quote_subst"`'
-archive_cmds_need_lc='`$ECHO "$archive_cmds_need_lc" | $SED "$delay_single_quote_subst"`'
-enable_shared_with_static_runtimes='`$ECHO "$enable_shared_with_static_runtimes" | $SED "$delay_single_quote_subst"`'
-export_dynamic_flag_spec='`$ECHO "$export_dynamic_flag_spec" | $SED "$delay_single_quote_subst"`'
-whole_archive_flag_spec='`$ECHO "$whole_archive_flag_spec" | $SED "$delay_single_quote_subst"`'
-compiler_needs_object='`$ECHO "$compiler_needs_object" | $SED "$delay_single_quote_subst"`'
-old_archive_from_new_cmds='`$ECHO "$old_archive_from_new_cmds" | $SED "$delay_single_quote_subst"`'
-old_archive_from_expsyms_cmds='`$ECHO "$old_archive_from_expsyms_cmds" | $SED "$delay_single_quote_subst"`'
-archive_cmds='`$ECHO "$archive_cmds" | $SED "$delay_single_quote_subst"`'
-archive_expsym_cmds='`$ECHO "$archive_expsym_cmds" | $SED "$delay_single_quote_subst"`'
-module_cmds='`$ECHO "$module_cmds" | $SED "$delay_single_quote_subst"`'
-module_expsym_cmds='`$ECHO "$module_expsym_cmds" | $SED "$delay_single_quote_subst"`'
-with_gnu_ld='`$ECHO "$with_gnu_ld" | $SED "$delay_single_quote_subst"`'
-allow_undefined_flag='`$ECHO "$allow_undefined_flag" | $SED "$delay_single_quote_subst"`'
-no_undefined_flag='`$ECHO "$no_undefined_flag" | $SED "$delay_single_quote_subst"`'
-hardcode_libdir_flag_spec='`$ECHO "$hardcode_libdir_flag_spec" | $SED "$delay_single_quote_subst"`'
-hardcode_libdir_flag_spec_ld='`$ECHO "$hardcode_libdir_flag_spec_ld" | $SED "$delay_single_quote_subst"`'
-hardcode_libdir_separator='`$ECHO "$hardcode_libdir_separator" | $SED "$delay_single_quote_subst"`'
-hardcode_direct='`$ECHO "$hardcode_direct" | $SED "$delay_single_quote_subst"`'
-hardcode_direct_absolute='`$ECHO "$hardcode_direct_absolute" | $SED "$delay_single_quote_subst"`'
-hardcode_minus_L='`$ECHO "$hardcode_minus_L" | $SED "$delay_single_quote_subst"`'
-hardcode_shlibpath_var='`$ECHO "$hardcode_shlibpath_var" | $SED "$delay_single_quote_subst"`'
-hardcode_automatic='`$ECHO "$hardcode_automatic" | $SED "$delay_single_quote_subst"`'
-inherit_rpath='`$ECHO "$inherit_rpath" | $SED "$delay_single_quote_subst"`'
-link_all_deplibs='`$ECHO "$link_all_deplibs" | $SED "$delay_single_quote_subst"`'
-fix_srcfile_path='`$ECHO "$fix_srcfile_path" | $SED "$delay_single_quote_subst"`'
-always_export_symbols='`$ECHO "$always_export_symbols" | $SED "$delay_single_quote_subst"`'
-export_symbols_cmds='`$ECHO "$export_symbols_cmds" | $SED "$delay_single_quote_subst"`'
-exclude_expsyms='`$ECHO "$exclude_expsyms" | $SED "$delay_single_quote_subst"`'
-include_expsyms='`$ECHO "$include_expsyms" | $SED "$delay_single_quote_subst"`'
-prelink_cmds='`$ECHO "$prelink_cmds" | $SED "$delay_single_quote_subst"`'
-file_list_spec='`$ECHO "$file_list_spec" | $SED "$delay_single_quote_subst"`'
-variables_saved_for_relink='`$ECHO "$variables_saved_for_relink" | $SED "$delay_single_quote_subst"`'
-need_lib_prefix='`$ECHO "$need_lib_prefix" | $SED "$delay_single_quote_subst"`'
-need_version='`$ECHO "$need_version" | $SED "$delay_single_quote_subst"`'
-version_type='`$ECHO "$version_type" | $SED "$delay_single_quote_subst"`'
-runpath_var='`$ECHO "$runpath_var" | $SED "$delay_single_quote_subst"`'
-shlibpath_var='`$ECHO "$shlibpath_var" | $SED "$delay_single_quote_subst"`'
-shlibpath_overrides_runpath='`$ECHO "$shlibpath_overrides_runpath" | $SED "$delay_single_quote_subst"`'
-libname_spec='`$ECHO "$libname_spec" | $SED "$delay_single_quote_subst"`'
-library_names_spec='`$ECHO "$library_names_spec" | $SED "$delay_single_quote_subst"`'
-soname_spec='`$ECHO "$soname_spec" | $SED "$delay_single_quote_subst"`'
-install_override_mode='`$ECHO "$install_override_mode" | $SED "$delay_single_quote_subst"`'
-postinstall_cmds='`$ECHO "$postinstall_cmds" | $SED "$delay_single_quote_subst"`'
-postuninstall_cmds='`$ECHO "$postuninstall_cmds" | $SED "$delay_single_quote_subst"`'
-finish_cmds='`$ECHO "$finish_cmds" | $SED "$delay_single_quote_subst"`'
-finish_eval='`$ECHO "$finish_eval" | $SED "$delay_single_quote_subst"`'
-hardcode_into_libs='`$ECHO "$hardcode_into_libs" | $SED "$delay_single_quote_subst"`'
-sys_lib_search_path_spec='`$ECHO "$sys_lib_search_path_spec" | $SED "$delay_single_quote_subst"`'
-sys_lib_dlsearch_path_spec='`$ECHO "$sys_lib_dlsearch_path_spec" | $SED "$delay_single_quote_subst"`'
-hardcode_action='`$ECHO "$hardcode_action" | $SED "$delay_single_quote_subst"`'
-enable_dlopen='`$ECHO "$enable_dlopen" | $SED "$delay_single_quote_subst"`'
-enable_dlopen_self='`$ECHO "$enable_dlopen_self" | $SED "$delay_single_quote_subst"`'
-enable_dlopen_self_static='`$ECHO "$enable_dlopen_self_static" | $SED "$delay_single_quote_subst"`'
-old_striplib='`$ECHO "$old_striplib" | $SED "$delay_single_quote_subst"`'
-striplib='`$ECHO "$striplib" | $SED "$delay_single_quote_subst"`'
-
-LTCC='$LTCC'
-LTCFLAGS='$LTCFLAGS'
-compiler='$compiler_DEFAULT'
-
-# A function that is used when there is no print builtin or printf.
-func_fallback_echo ()
-{
-  eval 'cat <<_LTECHO_EOF
-\$1
-_LTECHO_EOF'
-}
-
-# Quote evaled strings.
-for var in SHELL \
-ECHO \
-SED \
-GREP \
-EGREP \
-FGREP \
-LD \
-NM \
-LN_S \
-lt_SP2NL \
-lt_NL2SP \
-reload_flag \
-OBJDUMP \
-deplibs_check_method \
-file_magic_cmd \
-AR \
-AR_FLAGS \
-STRIP \
-RANLIB \
-CC \
-CFLAGS \
-compiler \
-lt_cv_sys_global_symbol_pipe \
-lt_cv_sys_global_symbol_to_cdecl \
-lt_cv_sys_global_symbol_to_c_name_address \
-lt_cv_sys_global_symbol_to_c_name_address_lib_prefix \
-lt_prog_compiler_no_builtin_flag \
-lt_prog_compiler_wl \
-lt_prog_compiler_pic \
-lt_prog_compiler_static \
-lt_cv_prog_compiler_c_o \
-need_locks \
-DSYMUTIL \
-NMEDIT \
-LIPO \
-OTOOL \
-OTOOL64 \
-shrext_cmds \
-export_dynamic_flag_spec \
-whole_archive_flag_spec \
-compiler_needs_object \
-with_gnu_ld \
-allow_undefined_flag \
-no_undefined_flag \
-hardcode_libdir_flag_spec \
-hardcode_libdir_flag_spec_ld \
-hardcode_libdir_separator \
-fix_srcfile_path \
-exclude_expsyms \
-include_expsyms \
-file_list_spec \
-variables_saved_for_relink \
-libname_spec \
-library_names_spec \
-soname_spec \
-install_override_mode \
-finish_eval \
-old_striplib \
-striplib; do
-    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
-    *[\\\\\\\`\\"\\\$]*)
-      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED \\"\\\$sed_quote_subst\\"\\\`\\\\\\""
-      ;;
-    *)
-      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
-      ;;
-    esac
-done
-
-# Double-quote double-evaled strings.
-for var in reload_cmds \
-old_postinstall_cmds \
-old_postuninstall_cmds \
-old_archive_cmds \
-extract_expsyms_cmds \
-old_archive_from_new_cmds \
-old_archive_from_expsyms_cmds \
-archive_cmds \
-archive_expsym_cmds \
-module_cmds \
-module_expsym_cmds \
-export_symbols_cmds \
-prelink_cmds \
-postinstall_cmds \
-postuninstall_cmds \
-finish_cmds \
-sys_lib_search_path_spec \
-sys_lib_dlsearch_path_spec; do
-    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
-    *[\\\\\\\`\\"\\\$]*)
-      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\""
-      ;;
-    *)
-      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
-      ;;
-    esac
-done
-
-ac_aux_dir='$ac_aux_dir'
-xsi_shell='$xsi_shell'
-lt_shell_append='$lt_shell_append'
-
-# See if we are running on zsh, and set the options which allow our
-# commands through without removal of \ escapes INIT.
-if test -n "\${ZSH_VERSION+set}" ; then
-   setopt NO_GLOB_SUBST
-fi
-
-
-    PACKAGE='$PACKAGE'
-    VERSION='$VERSION'
-    TIMESTAMP='$TIMESTAMP'
-    RM='$RM'
-    ofile='$ofile'
-
-
-
-
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-
-# Handling of arguments.
-for ac_config_target in $ac_config_targets
-do
-  case $ac_config_target in
-    "default-1") CONFIG_COMMANDS="$CONFIG_COMMANDS default-1" ;;
-    "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
-    "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
-    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
-
-  *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
-  esac
-done
-
-
-# If the user did not use the arguments to specify the items to instantiate,
-# then the envvar interface is used.  Set only those that are not.
-# We use the long form for the default assignment because of an extremely
-# bizarre bug on SunOS 4.1.3.
-if $ac_need_defaults; then
-  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
-  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
-fi
-
-# Have a temporary directory for convenience.  Make it in the build tree
-# simply because there is no reason against having it here, and in addition,
-# creating and moving files from /tmp can sometimes cause problems.
-# Hook for its removal unless debugging.
-# Note that there is a small window in which the directory will not be cleaned:
-# after its creation but before its name has been assigned to `$tmp'.
-$debug ||
-{
-  tmp=
-  trap 'exit_status=$?
-  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
-' 0
-  trap 'as_fn_exit 1' 1 2 13 15
-}
-# Create a (secure) tmp directory for tmp files.
-
-{
-  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
-  test -n "$tmp" && test -d "$tmp"
-}  ||
-{
-  tmp=./conf$$-$RANDOM
-  (umask 077 && mkdir "$tmp")
-} || as_fn_error "cannot create a temporary directory in ." "$LINENO" 5
-
-# Set up the scripts for CONFIG_FILES section.
-# No need to generate them if there are no CONFIG_FILES.
-# This happens for instance with `./config.status config.h'.
-if test -n "$CONFIG_FILES"; then
-
-
-ac_cr=`echo X | tr X '\015'`
-# On cygwin, bash can eat \r inside `` if the user requested igncr.
-# But we know of no other shell where ac_cr would be empty at this
-# point, so we can use a bashism as a fallback.
-if test "x$ac_cr" = x; then
-  eval ac_cr=\$\'\\r\'
-fi
-ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
-if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
-  ac_cs_awk_cr='\r'
-else
-  ac_cs_awk_cr=$ac_cr
-fi
-
-echo 'BEGIN {' >"$tmp/subs1.awk" &&
-_ACEOF
-
-
-{
-  echo "cat >conf$$subs.awk <<_ACEOF" &&
-  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
-  echo "_ACEOF"
-} >conf$$subs.sh ||
-  as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
-ac_delim_num=`echo "$ac_subst_vars" | grep -c '$'`
-ac_delim='%!_!# '
-for ac_last_try in false false false false false :; do
-  . ./conf$$subs.sh ||
-    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
-
-  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
-  if test $ac_delim_n = $ac_delim_num; then
-    break
-  elif $ac_last_try; then
-    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
-  else
-    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
-  fi
-done
-rm -f conf$$subs.sh
-
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-cat >>"\$tmp/subs1.awk" <<\\_ACAWK &&
-_ACEOF
-sed -n '
-h
-s/^/S["/; s/!.*/"]=/
-p
-g
-s/^[^!]*!//
-:repl
-t repl
-s/'"$ac_delim"'$//
-t delim
-:nl
-h
-s/\(.\{148\}\).*/\1/
-t more1
-s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
-p
-n
-b repl
-:more1
-s/["\\]/\\&/g; s/^/"/; s/$/"\\/
-p
-g
-s/.\{148\}//
-t nl
-:delim
-h
-s/\(.\{148\}\).*/\1/
-t more2
-s/["\\]/\\&/g; s/^/"/; s/$/"/
-p
-b
-:more2
-s/["\\]/\\&/g; s/^/"/; s/$/"\\/
-p
-g
-s/.\{148\}//
-t delim
-' <conf$$subs.awk | sed '
-/^[^""]/{
-  N
-  s/\n//
-}
-' >>$CONFIG_STATUS || ac_write_fail=1
-rm -f conf$$subs.awk
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-_ACAWK
-cat >>"\$tmp/subs1.awk" <<_ACAWK &&
-  for (key in S) S_is_set[key] = 1
-  FS = ""
-
-}
-{
-  line = $ 0
-  nfields = split(line, field, "@")
-  substed = 0
-  len = length(field[1])
-  for (i = 2; i < nfields; i++) {
-    key = field[i]
-    keylen = length(key)
-    if (S_is_set[key]) {
-      value = S[key]
-      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
-      len += length(value) + length(field[++i])
-      substed = 1
-    } else
-      len += 1 + keylen
-  }
-
-  print line
-}
-
-_ACAWK
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
-  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
-else
-  cat
-fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
-  || as_fn_error "could not setup config files machinery" "$LINENO" 5
-_ACEOF
-
-# VPATH may cause trouble with some makes, so we remove $(srcdir),
-# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
-# trailing colons and then remove the whole line if VPATH becomes empty
-# (actually we leave an empty line to preserve line numbers).
-if test "x$srcdir" = x.; then
-  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
-s/:*\$(srcdir):*/:/
-s/:*\${srcdir}:*/:/
-s/:*@srcdir@:*/:/
-s/^\([^=]*=[	 ]*\):*/\1/
-s/:*$//
-s/^[^=]*=[	 ]*$//
-}'
-fi
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-fi # test -n "$CONFIG_FILES"
-
-
-eval set X "  :F $CONFIG_FILES      :C $CONFIG_COMMANDS"
-shift
-for ac_tag
-do
-  case $ac_tag in
-  :[FHLC]) ac_mode=$ac_tag; continue;;
-  esac
-  case $ac_mode$ac_tag in
-  :[FHL]*:*);;
-  :L* | :C*:*) as_fn_error "invalid tag \`$ac_tag'" "$LINENO" 5;;
-  :[FH]-) ac_tag=-:-;;
-  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
-  esac
-  ac_save_IFS=$IFS
-  IFS=:
-  set x $ac_tag
-  IFS=$ac_save_IFS
-  shift
-  ac_file=$1
-  shift
-
-  case $ac_mode in
-  :L) ac_source=$1;;
-  :[FH])
-    ac_file_inputs=
-    for ac_f
-    do
-      case $ac_f in
-      -) ac_f="$tmp/stdin";;
-      *) # Look for the file first in the build tree, then in the source tree
-	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
-	 # because $ac_f cannot contain `:'.
-	 test -f "$ac_f" ||
-	   case $ac_f in
-	   [\\/$]*) false;;
-	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
-	   esac ||
-	   as_fn_error "cannot find input file: \`$ac_f'" "$LINENO" 5;;
-      esac
-      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
-      as_fn_append ac_file_inputs " '$ac_f'"
-    done
-
-    # Let's still pretend it is `configure' which instantiates (i.e., don't
-    # use $as_me), people would be surprised to read:
-    #    /* config.h.  Generated by config.status.  */
-    configure_input='Generated from '`
-	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
-	`' by configure.'
-    if test x"$ac_file" != x-; then
-      configure_input="$ac_file.  $configure_input"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
-$as_echo "$as_me: creating $ac_file" >&6;}
-    fi
-    # Neutralize special characters interpreted by sed in replacement strings.
-    case $configure_input in #(
-    *\&* | *\|* | *\\* )
-       ac_sed_conf_input=`$as_echo "$configure_input" |
-       sed 's/[\\\\&|]/\\\\&/g'`;; #(
-    *) ac_sed_conf_input=$configure_input;;
-    esac
-
-    case $ac_tag in
-    *:-:* | *:-) cat >"$tmp/stdin" \
-      || as_fn_error "could not create $ac_file" "$LINENO" 5 ;;
-    esac
-    ;;
-  esac
-
-  ac_dir=`$as_dirname -- "$ac_file" ||
-$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$ac_file" : 'X\(//\)[^/]' \| \
-	 X"$ac_file" : 'X\(//\)$' \| \
-	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$ac_file" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-  as_dir="$ac_dir"; as_fn_mkdir_p
-  ac_builddir=.
-
-case "$ac_dir" in
-.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
-*)
-  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
-  # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
-  case $ac_top_builddir_sub in
-  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
-  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
-  esac ;;
-esac
-ac_abs_top_builddir=$ac_pwd
-ac_abs_builddir=$ac_pwd$ac_dir_suffix
-# for backward compatibility:
-ac_top_builddir=$ac_top_build_prefix
-
-case $srcdir in
-  .)  # We are building in place.
-    ac_srcdir=.
-    ac_top_srcdir=$ac_top_builddir_sub
-    ac_abs_top_srcdir=$ac_pwd ;;
-  [\\/]* | ?:[\\/]* )  # Absolute name.
-    ac_srcdir=$srcdir$ac_dir_suffix;
-    ac_top_srcdir=$srcdir
-    ac_abs_top_srcdir=$srcdir ;;
-  *) # Relative name.
-    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
-    ac_top_srcdir=$ac_top_build_prefix$srcdir
-    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
-esac
-ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
-
-
-  case $ac_mode in
-  :F)
-  #
-  # CONFIG_FILE
-  #
-
-  case $INSTALL in
-  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
-  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
-  esac
-  ac_MKDIR_P=$MKDIR_P
-  case $MKDIR_P in
-  [\\/$]* | ?:[\\/]* ) ;;
-  */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
-  esac
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-# If the template does not know about datarootdir, expand it.
-# FIXME: This hack should be removed a few years after 2.60.
-ac_datarootdir_hack=; ac_datarootdir_seen=
-ac_sed_dataroot='
-/datarootdir/ {
-  p
-  q
-}
-/@datadir@/p
-/@docdir@/p
-/@infodir@/p
-/@localedir@/p
-/@mandir@/p'
-case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
-*datarootdir*) ac_datarootdir_seen=yes;;
-*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
-$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-  ac_datarootdir_hack='
-  s&@datadir@&$datadir&g
-  s&@docdir@&$docdir&g
-  s&@infodir@&$infodir&g
-  s&@localedir@&$localedir&g
-  s&@mandir@&$mandir&g
-  s&\\\${datarootdir}&$datarootdir&g' ;;
-esac
-_ACEOF
-
-# Neutralize VPATH when `$srcdir' = `.'.
-# Shell code in configure.ac might set extrasub.
-# FIXME: do we really want to maintain this feature?
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-ac_sed_extra="$ac_vpsub
-$extrasub
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-:t
-/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
-s|@configure_input@|$ac_sed_conf_input|;t t
-s&@top_builddir@&$ac_top_builddir_sub&;t t
-s&@top_build_prefix@&$ac_top_build_prefix&;t t
-s&@srcdir@&$ac_srcdir&;t t
-s&@abs_srcdir@&$ac_abs_srcdir&;t t
-s&@top_srcdir@&$ac_top_srcdir&;t t
-s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
-s&@builddir@&$ac_builddir&;t t
-s&@abs_builddir@&$ac_abs_builddir&;t t
-s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
-s&@INSTALL@&$ac_INSTALL&;t t
-s&@MKDIR_P@&$ac_MKDIR_P&;t t
-$ac_datarootdir_hack
-"
-eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
-  || as_fn_error "could not create $ac_file" "$LINENO" 5
-
-test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
-  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
-  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&5
-$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&2;}
-
-  rm -f "$tmp/stdin"
-  case $ac_file in
-  -) cat "$tmp/out" && rm -f "$tmp/out";;
-  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
-  esac \
-  || as_fn_error "could not create $ac_file" "$LINENO" 5
- ;;
-
-
-  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
-$as_echo "$as_me: executing $ac_file commands" >&6;}
- ;;
-  esac
-
-
-  case $ac_file$ac_mode in
-    "default-1":C)
-# Only add multilib support code if we just rebuilt the top-level
-# Makefile.
-case " $CONFIG_FILES " in
- *" Makefile "*)
-   ac_file=Makefile . ${multi_basedir}/config-ml.in
-   ;;
-esac ;;
-    "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
-  # Autoconf 2.62 quotes --file arguments for eval, but not when files
-  # are listed without --file.  Let's play safe and only enable the eval
-  # if we detect the quoting.
-  case $CONFIG_FILES in
-  *\'*) eval set x "$CONFIG_FILES" ;;
-  *)   set x $CONFIG_FILES ;;
-  esac
-  shift
-  for mf
-  do
-    # Strip MF so we end up with the name of the file.
-    mf=`echo "$mf" | sed -e 's/:.*$//'`
-    # Check whether this is an Automake generated Makefile or not.
-    # We used to match only the files named `Makefile.in', but
-    # some people rename them; so instead we look at the file content.
-    # Grep'ing the first line is not enough: some people post-process
-    # each Makefile.in and add a new line on top of each file to say so.
-    # Grep'ing the whole file is not good either: AIX grep has a line
-    # limit of 2048, but all sed's we know have understand at least 4000.
-    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
-      dirpart=`$as_dirname -- "$mf" ||
-$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$mf" : 'X\(//\)[^/]' \| \
-	 X"$mf" : 'X\(//\)$' \| \
-	 X"$mf" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$mf" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-    else
-      continue
-    fi
-    # Extract the definition of DEPDIR, am__include, and am__quote
-    # from the Makefile without running `make'.
-    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
-    test -z "$DEPDIR" && continue
-    am__include=`sed -n 's/^am__include = //p' < "$mf"`
-    test -z "am__include" && continue
-    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
-    # When using ansi2knr, U may be empty or an underscore; expand it
-    U=`sed -n 's/^U = //p' < "$mf"`
-    # Find all dependency output files, they are included files with
-    # $(DEPDIR) in their names.  We invoke sed twice because it is the
-    # simplest approach to changing $(DEPDIR) to its actual value in the
-    # expansion.
-    for file in `sed -n "
-      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
-	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
-      # Make sure the directory exists.
-      test -f "$dirpart/$file" && continue
-      fdir=`$as_dirname -- "$file" ||
-$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$file" : 'X\(//\)[^/]' \| \
-	 X"$file" : 'X\(//\)$' \| \
-	 X"$file" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$file" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      as_dir=$dirpart/$fdir; as_fn_mkdir_p
-      # echo "creating $dirpart/$file"
-      echo '# dummy' > "$dirpart/$file"
-    done
-  done
-}
- ;;
-    "libtool":C)
-
-    # See if we are running on zsh, and set the options which allow our
-    # commands through without removal of \ escapes.
-    if test -n "${ZSH_VERSION+set}" ; then
-      setopt NO_GLOB_SUBST
-    fi
-
-    cfgfile="${ofile}T"
-    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
-    $RM "$cfgfile"
-
-    cat <<_LT_EOF >> "$cfgfile"
-#! $SHELL
-
-# `$ECHO "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
-# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION
-# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
-# NOTE: Changes made to this file will be lost: look at ltmain.sh.
-#
-#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
-#                 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
-#   Written by Gordon Matzigkeit, 1996
-#
-#   This file is part of GNU Libtool.
-#
-# GNU Libtool is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# As a special exception to the GNU General Public License,
-# if you distribute this file as part of a program or library that
-# is built using GNU Libtool, you may include this file under the
-# same distribution terms that you use for the rest of that program.
-#
-# GNU Libtool is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with GNU Libtool; see the file COPYING.  If not, a copy
-# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
-# obtained by writing to the Free Software Foundation, Inc.,
-# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-
-
-# The names of the tagged configurations supported by this script.
-available_tags=""
-
-# ### BEGIN LIBTOOL CONFIG
-
-# Which release of libtool.m4 was used?
-macro_version=$macro_version
-macro_revision=$macro_revision
-
-# Whether or not to build shared libraries.
-build_libtool_libs=$enable_shared
-
-# Whether or not to build static libraries.
-build_old_libs=$enable_static
-
-# What type of objects to build.
-pic_mode=$pic_mode
-
-# Whether or not to optimize for fast installation.
-fast_install=$enable_fast_install
-
-# Shell to use when invoking shell scripts.
-SHELL=$lt_SHELL
-
-# An echo program that protects backslashes.
-ECHO=$lt_ECHO
-
-# The host system.
-host_alias=$host_alias
-host=$host
-host_os=$host_os
-
-# The build system.
-build_alias=$build_alias
-build=$build
-build_os=$build_os
-
-# A sed program that does not truncate output.
-SED=$lt_SED
-
-# Sed that helps us avoid accidentally triggering echo(1) options like -n.
-Xsed="\$SED -e 1s/^X//"
-
-# A grep program that handles long lines.
-GREP=$lt_GREP
-
-# An ERE matcher.
-EGREP=$lt_EGREP
-
-# A literal string matcher.
-FGREP=$lt_FGREP
-
-# A BSD- or MS-compatible name lister.
-NM=$lt_NM
-
-# Whether we need soft or hard links.
-LN_S=$lt_LN_S
-
-# What is the maximum length of a command?
-max_cmd_len=$max_cmd_len
-
-# Object file suffix (normally "o").
-objext=$ac_objext
-
-# Executable file suffix (normally "").
-exeext=$exeext
-
-# whether the shell understands "unset".
-lt_unset=$lt_unset
-
-# turn spaces into newlines.
-SP2NL=$lt_lt_SP2NL
-
-# turn newlines into spaces.
-NL2SP=$lt_lt_NL2SP
-
-# An object symbol dumper.
-OBJDUMP=$lt_OBJDUMP
-
-# Method to check whether dependent libraries are shared objects.
-deplibs_check_method=$lt_deplibs_check_method
-
-# Command to use when deplibs_check_method == "file_magic".
-file_magic_cmd=$lt_file_magic_cmd
-
-# The archiver.
-AR=$lt_AR
-AR_FLAGS=$lt_AR_FLAGS
-
-# A symbol stripping program.
-STRIP=$lt_STRIP
-
-# Commands used to install an old-style archive.
-RANLIB=$lt_RANLIB
-old_postinstall_cmds=$lt_old_postinstall_cmds
-old_postuninstall_cmds=$lt_old_postuninstall_cmds
-
-# Whether to use a lock for old archive extraction.
-lock_old_archive_extraction=$lock_old_archive_extraction
-
-# A C compiler.
-LTCC=$lt_CC
-
-# LTCC compiler flags.
-LTCFLAGS=$lt_CFLAGS
-
-# Take the output of nm and produce a listing of raw symbols and C names.
-global_symbol_pipe=$lt_lt_cv_sys_global_symbol_pipe
-
-# Transform the output of nm in a proper C declaration.
-global_symbol_to_cdecl=$lt_lt_cv_sys_global_symbol_to_cdecl
-
-# Transform the output of nm in a C name address pair.
-global_symbol_to_c_name_address=$lt_lt_cv_sys_global_symbol_to_c_name_address
-
-# Transform the output of nm in a C name address pair when lib prefix is needed.
-global_symbol_to_c_name_address_lib_prefix=$lt_lt_cv_sys_global_symbol_to_c_name_address_lib_prefix
-
-# The name of the directory that contains temporary libtool files.
-objdir=$objdir
-
-# Used to examine libraries when file_magic_cmd begins with "file".
-MAGIC_CMD=$MAGIC_CMD
-
-# Must we lock files when doing compilation?
-need_locks=$lt_need_locks
-
-# Tool to manipulate archived DWARF debug symbol files on Mac OS X.
-DSYMUTIL=$lt_DSYMUTIL
-
-# Tool to change global to local symbols on Mac OS X.
-NMEDIT=$lt_NMEDIT
-
-# Tool to manipulate fat objects and archives on Mac OS X.
-LIPO=$lt_LIPO
-
-# ldd/readelf like tool for Mach-O binaries on Mac OS X.
-OTOOL=$lt_OTOOL
-
-# ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4.
-OTOOL64=$lt_OTOOL64
-
-# Old archive suffix (normally "a").
-libext=$libext
-
-# Shared library suffix (normally ".so").
-shrext_cmds=$lt_shrext_cmds
-
-# The commands to extract the exported symbol list from a shared archive.
-extract_expsyms_cmds=$lt_extract_expsyms_cmds
-
-# Variables whose values should be saved in libtool wrapper scripts and
-# restored at link time.
-variables_saved_for_relink=$lt_variables_saved_for_relink
-
-# Do we need the "lib" prefix for modules?
-need_lib_prefix=$need_lib_prefix
-
-# Do we need a version for libraries?
-need_version=$need_version
-
-# Library versioning type.
-version_type=$version_type
-
-# Shared library runtime path variable.
-runpath_var=$runpath_var
-
-# Shared library path variable.
-shlibpath_var=$shlibpath_var
-
-# Is shlibpath searched before the hard-coded library search path?
-shlibpath_overrides_runpath=$shlibpath_overrides_runpath
-
-# Format of library name prefix.
-libname_spec=$lt_libname_spec
-
-# List of archive names.  First name is the real one, the rest are links.
-# The last name is the one that the linker finds with -lNAME
-library_names_spec=$lt_library_names_spec
-
-# The coded name of the library, if different from the real name.
-soname_spec=$lt_soname_spec
-
-# Permission mode override for installation of shared libraries.
-install_override_mode=$lt_install_override_mode
-
-# Command to use after installation of a shared archive.
-postinstall_cmds=$lt_postinstall_cmds
-
-# Command to use after uninstallation of a shared archive.
-postuninstall_cmds=$lt_postuninstall_cmds
-
-# Commands used to finish a libtool library installation in a directory.
-finish_cmds=$lt_finish_cmds
-
-# As "finish_cmds", except a single script fragment to be evaled but
-# not shown.
-finish_eval=$lt_finish_eval
-
-# Whether we should hardcode library paths into libraries.
-hardcode_into_libs=$hardcode_into_libs
-
-# Compile-time system search path for libraries.
-sys_lib_search_path_spec=$lt_sys_lib_search_path_spec
-
-# Run-time system search path for libraries.
-sys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec
-
-# Whether dlopen is supported.
-dlopen_support=$enable_dlopen
-
-# Whether dlopen of programs is supported.
-dlopen_self=$enable_dlopen_self
-
-# Whether dlopen of statically linked programs is supported.
-dlopen_self_static=$enable_dlopen_self_static
-
-# Commands to strip libraries.
-old_striplib=$lt_old_striplib
-striplib=$lt_striplib
-
-
-# The linker used to build libraries.
-LD=$lt_LD
-
-# How to create reloadable object files.
-reload_flag=$lt_reload_flag
-reload_cmds=$lt_reload_cmds
-
-# Commands used to build an old-style archive.
-old_archive_cmds=$lt_old_archive_cmds
-
-# A language specific compiler.
-CC=$lt_compiler
-
-# Is the compiler the GNU compiler?
-with_gcc=$GCC
-
-# Compiler flag to turn off builtin functions.
-no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag
-
-# How to pass a linker flag through the compiler.
-wl=$lt_lt_prog_compiler_wl
-
-# Additional compiler flags for building library objects.
-pic_flag=$lt_lt_prog_compiler_pic
-
-# Compiler flag to prevent dynamic linking.
-link_static_flag=$lt_lt_prog_compiler_static
-
-# Does compiler simultaneously support -c and -o options?
-compiler_c_o=$lt_lt_cv_prog_compiler_c_o
-
-# Whether or not to add -lc for building shared libraries.
-build_libtool_need_lc=$archive_cmds_need_lc
-
-# Whether or not to disallow shared libs when runtime libs are static.
-allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes
-
-# Compiler flag to allow reflexive dlopens.
-export_dynamic_flag_spec=$lt_export_dynamic_flag_spec
-
-# Compiler flag to generate shared objects directly from archives.
-whole_archive_flag_spec=$lt_whole_archive_flag_spec
-
-# Whether the compiler copes with passing no objects directly.
-compiler_needs_object=$lt_compiler_needs_object
-
-# Create an old-style archive from a shared archive.
-old_archive_from_new_cmds=$lt_old_archive_from_new_cmds
-
-# Create a temporary old-style archive to link instead of a shared archive.
-old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds
-
-# Commands used to build a shared archive.
-archive_cmds=$lt_archive_cmds
-archive_expsym_cmds=$lt_archive_expsym_cmds
-
-# Commands used to build a loadable module if different from building
-# a shared archive.
-module_cmds=$lt_module_cmds
-module_expsym_cmds=$lt_module_expsym_cmds
-
-# Whether we are building with GNU ld or not.
-with_gnu_ld=$lt_with_gnu_ld
-
-# Flag that allows shared libraries with undefined symbols to be built.
-allow_undefined_flag=$lt_allow_undefined_flag
-
-# Flag that enforces no undefined symbols.
-no_undefined_flag=$lt_no_undefined_flag
-
-# Flag to hardcode \$libdir into a binary during linking.
-# This must work even if \$libdir does not exist
-hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec
-
-# If ld is used when linking, flag to hardcode \$libdir into a binary
-# during linking.  This must work even if \$libdir does not exist.
-hardcode_libdir_flag_spec_ld=$lt_hardcode_libdir_flag_spec_ld
-
-# Whether we need a single "-rpath" flag with a separated argument.
-hardcode_libdir_separator=$lt_hardcode_libdir_separator
-
-# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
-# DIR into the resulting binary.
-hardcode_direct=$hardcode_direct
-
-# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
-# DIR into the resulting binary and the resulting library dependency is
-# "absolute",i.e impossible to change by setting \${shlibpath_var} if the
-# library is relocated.
-hardcode_direct_absolute=$hardcode_direct_absolute
-
-# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
-# into the resulting binary.
-hardcode_minus_L=$hardcode_minus_L
-
-# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
-# into the resulting binary.
-hardcode_shlibpath_var=$hardcode_shlibpath_var
-
-# Set to "yes" if building a shared library automatically hardcodes DIR
-# into the library and all subsequent libraries and executables linked
-# against it.
-hardcode_automatic=$hardcode_automatic
-
-# Set to yes if linker adds runtime paths of dependent libraries
-# to runtime path list.
-inherit_rpath=$inherit_rpath
-
-# Whether libtool must link a program against all its dependency libraries.
-link_all_deplibs=$link_all_deplibs
-
-# Fix the shell variable \$srcfile for the compiler.
-fix_srcfile_path=$lt_fix_srcfile_path
-
-# Set to "yes" if exported symbols are required.
-always_export_symbols=$always_export_symbols
-
-# The commands to list exported symbols.
-export_symbols_cmds=$lt_export_symbols_cmds
-
-# Symbols that should not be listed in the preloaded symbols.
-exclude_expsyms=$lt_exclude_expsyms
-
-# Symbols that must always be exported.
-include_expsyms=$lt_include_expsyms
-
-# Commands necessary for linking programs (against libraries) with templates.
-prelink_cmds=$lt_prelink_cmds
-
-# Specify filename containing input files.
-file_list_spec=$lt_file_list_spec
-
-# How to hardcode a shared library path into an executable.
-hardcode_action=$hardcode_action
-
-# ### END LIBTOOL CONFIG
-
-_LT_EOF
-
-  case $host_os in
-  aix3*)
-    cat <<\_LT_EOF >> "$cfgfile"
-# AIX sometimes has problems with the GCC collect2 program.  For some
-# reason, if we set the COLLECT_NAMES environment variable, the problems
-# vanish in a puff of smoke.
-if test "X${COLLECT_NAMES+set}" != Xset; then
-  COLLECT_NAMES=
-  export COLLECT_NAMES
-fi
-_LT_EOF
-    ;;
-  esac
-
-
-ltmain="$ac_aux_dir/ltmain.sh"
-
-
-  # We use sed instead of cat because bash on DJGPP gets confused if
-  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
-  # text mode, it properly converts lines to CR/LF.  This bash problem
-  # is reportedly fixed, but why not run on old versions too?
-  sed '/^# Generated shell functions inserted here/q' "$ltmain" >> "$cfgfile" \
-    || (rm -f "$cfgfile"; exit 1)
-
-  case $xsi_shell in
-  yes)
-    cat << \_LT_EOF >> "$cfgfile"
-
-# func_dirname file append nondir_replacement
-# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
-# otherwise set result to NONDIR_REPLACEMENT.
-func_dirname ()
-{
-  case ${1} in
-    */*) func_dirname_result="${1%/*}${2}" ;;
-    *  ) func_dirname_result="${3}" ;;
-  esac
-}
-
-# func_basename file
-func_basename ()
-{
-  func_basename_result="${1##*/}"
-}
-
-# func_dirname_and_basename file append nondir_replacement
-# perform func_basename and func_dirname in a single function
-# call:
-#   dirname:  Compute the dirname of FILE.  If nonempty,
-#             add APPEND to the result, otherwise set result
-#             to NONDIR_REPLACEMENT.
-#             value returned in "$func_dirname_result"
-#   basename: Compute filename of FILE.
-#             value retuned in "$func_basename_result"
-# Implementation must be kept synchronized with func_dirname
-# and func_basename. For efficiency, we do not delegate to
-# those functions but instead duplicate the functionality here.
-func_dirname_and_basename ()
-{
-  case ${1} in
-    */*) func_dirname_result="${1%/*}${2}" ;;
-    *  ) func_dirname_result="${3}" ;;
-  esac
-  func_basename_result="${1##*/}"
-}
-
-# func_stripname prefix suffix name
-# strip PREFIX and SUFFIX off of NAME.
-# PREFIX and SUFFIX must not contain globbing or regex special
-# characters, hashes, percent signs, but SUFFIX may contain a leading
-# dot (in which case that matches only a dot).
-func_stripname ()
-{
-  # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are
-  # positional parameters, so assign one to ordinary parameter first.
-  func_stripname_result=${3}
-  func_stripname_result=${func_stripname_result#"${1}"}
-  func_stripname_result=${func_stripname_result%"${2}"}
-}
-
-# func_opt_split
-func_opt_split ()
-{
-  func_opt_split_opt=${1%%=*}
-  func_opt_split_arg=${1#*=}
-}
-
-# func_lo2o object
-func_lo2o ()
-{
-  case ${1} in
-    *.lo) func_lo2o_result=${1%.lo}.${objext} ;;
-    *)    func_lo2o_result=${1} ;;
-  esac
-}
-
-# func_xform libobj-or-source
-func_xform ()
-{
-  func_xform_result=${1%.*}.lo
-}
-
-# func_arith arithmetic-term...
-func_arith ()
-{
-  func_arith_result=$(( $* ))
-}
-
-# func_len string
-# STRING may not start with a hyphen.
-func_len ()
-{
-  func_len_result=${#1}
-}
-
-_LT_EOF
-    ;;
-  *) # Bourne compatible functions.
-    cat << \_LT_EOF >> "$cfgfile"
-
-# func_dirname file append nondir_replacement
-# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
-# otherwise set result to NONDIR_REPLACEMENT.
-func_dirname ()
-{
-  # Extract subdirectory from the argument.
-  func_dirname_result=`$ECHO "${1}" | $SED "$dirname"`
-  if test "X$func_dirname_result" = "X${1}"; then
-    func_dirname_result="${3}"
-  else
-    func_dirname_result="$func_dirname_result${2}"
-  fi
-}
-
-# func_basename file
-func_basename ()
-{
-  func_basename_result=`$ECHO "${1}" | $SED "$basename"`
-}
-
-
-# func_stripname prefix suffix name
-# strip PREFIX and SUFFIX off of NAME.
-# PREFIX and SUFFIX must not contain globbing or regex special
-# characters, hashes, percent signs, but SUFFIX may contain a leading
-# dot (in which case that matches only a dot).
-# func_strip_suffix prefix name
-func_stripname ()
-{
-  case ${2} in
-    .*) func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%\\\\${2}\$%%"`;;
-    *)  func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%${2}\$%%"`;;
-  esac
-}
-
-# sed scripts:
-my_sed_long_opt='1s/^\(-[^=]*\)=.*/\1/;q'
-my_sed_long_arg='1s/^-[^=]*=//'
-
-# func_opt_split
-func_opt_split ()
-{
-  func_opt_split_opt=`$ECHO "${1}" | $SED "$my_sed_long_opt"`
-  func_opt_split_arg=`$ECHO "${1}" | $SED "$my_sed_long_arg"`
-}
-
-# func_lo2o object
-func_lo2o ()
-{
-  func_lo2o_result=`$ECHO "${1}" | $SED "$lo2o"`
-}
-
-# func_xform libobj-or-source
-func_xform ()
-{
-  func_xform_result=`$ECHO "${1}" | $SED 's/\.[^.]*$/.lo/'`
-}
-
-# func_arith arithmetic-term...
-func_arith ()
-{
-  func_arith_result=`expr "$@"`
-}
-
-# func_len string
-# STRING may not start with a hyphen.
-func_len ()
-{
-  func_len_result=`expr "$1" : ".*" 2>/dev/null || echo $max_cmd_len`
-}
-
-_LT_EOF
-esac
-
-case $lt_shell_append in
-  yes)
-    cat << \_LT_EOF >> "$cfgfile"
-
-# func_append var value
-# Append VALUE to the end of shell variable VAR.
-func_append ()
-{
-  eval "$1+=\$2"
-}
-_LT_EOF
-    ;;
-  *)
-    cat << \_LT_EOF >> "$cfgfile"
-
-# func_append var value
-# Append VALUE to the end of shell variable VAR.
-func_append ()
-{
-  eval "$1=\$$1\$2"
-}
-
-_LT_EOF
-    ;;
-  esac
-
-
-  sed -n '/^# Generated shell functions inserted here/,$p' "$ltmain" >> "$cfgfile" \
-    || (rm -f "$cfgfile"; exit 1)
-
-  mv -f "$cfgfile" "$ofile" ||
-    (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
-  chmod +x "$ofile"
-
- ;;
-
-  esac
-done # for ac_tag
-
-
-as_fn_exit 0
-_ACEOF
-ac_clean_files=$ac_clean_files_save
-
-test $ac_write_fail = 0 ||
-  as_fn_error "write failure creating $CONFIG_STATUS" "$LINENO" 5
-
-
-# configure is writing to config.log, and then calls config.status.
-# config.status does its own redirection, appending to config.log.
-# Unfortunately, on DOS this fails, as config.log is still kept open
-# by configure, so config.status won't be able to write to it; its
-# output is simply discarded.  So we exec the FD to /dev/null,
-# effectively closing config.log, so it can be properly (re)opened and
-# appended to by config.status.  When coming back to configure, we
-# need to make the FD available again.
-if test "$no_create" != yes; then
-  ac_cs_success=:
-  ac_config_status_args=
-  test "$silent" = yes &&
-    ac_config_status_args="$ac_config_status_args --quiet"
-  exec 5>/dev/null
-  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
-  exec 5>>config.log
-  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
-  # would make configure fail if this is the last instruction.
-  $ac_cs_success || as_fn_exit $?
-fi
-if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
-$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
-fi
-
diff -Nbaur gcc-4.8.1/zlib/configure.ac gcc-4.8.1-ppc/zlib/configure.ac
--- gcc-4.8.1/zlib/configure.ac	2009-08-24 20:08:51.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/configure.ac	1970-01-01 01:00:00.000000000 +0100
@@ -1,123 +0,0 @@
-dnl Process this with autoconf to create configure
-
-AC_PREREQ(2.64)
-AC_INIT
-AC_CONFIG_SRCDIR([zlib.h])
-
-AM_ENABLE_MULTILIB(, ..)
-
-AC_CANONICAL_SYSTEM
-
-# This works around an automake problem.
-mkinstalldirs="`cd $ac_aux_dir && ${PWDCMD-pwd}`/mkinstalldirs"
-AC_SUBST(mkinstalldirs)
-
-AM_INIT_AUTOMAKE(zlib, 1.1.4)
-
-AM_MAINTAINER_MODE
-
-dnl We use these options to decide which functions to include.
-AC_ARG_WITH(target-subdir,
-[  --with-target-subdir=SUBDIR
-                          configuring in a subdirectory])
-
-if test -z "$with_target_subdir" || test "$with_target_subdir" = "."; then
-   COMPPATH=.
-else
-   COMPPATH=..
-fi
-AC_SUBST(COMPPATH)
-
-AC_ARG_WITH(cross-host,
-[  --with-cross-host=HOST  configuring with a cross compiler])
-
-dnl Default to --enable-multilib
-AC_ARG_ENABLE(multilib,
-[  --enable-multilib       build many library versions (default)],
-[case "${enableval}" in
-  yes) multilib=yes ;;
-  no)  multilib=no ;;
-  *)   AC_MSG_ERROR(bad value ${enableval} for multilib option) ;;
- esac], [test -z "$with_target_subdir" && multilib=no || multilib=yes])dnl
-
-AC_ARG_WITH(system-zlib,
-[  --with-system-zlib      use installed libz])
-
-# Make sure we don't test executables when making cross-tools.
-GCC_NO_EXECUTABLES
-
-# The same as in boehm-gc and libstdc++. Have to borrow it from there.
-# We must force CC to /not/ be precious variables; otherwise
-# the wrong, non-multilib-adjusted value will be used in multilibs.
-# As a side effect, we have to subst CFLAGS ourselves.
-
-m4_rename([_AC_ARG_VAR_PRECIOUS],[real_PRECIOUS])
-m4_define([_AC_ARG_VAR_PRECIOUS],[])
-AC_PROG_CC
-m4_rename_force([real_PRECIOUS],[_AC_ARG_VAR_PRECIOUS])
-
-AC_SUBST(CFLAGS)
-
-AC_PROG_LIBTOOL
-
-# Find CPP now so that any conditional tests below won't do it and
-# thereby make the resulting definitions conditional.
-AC_PROG_CPP
-
-if test -n "$with_cross_host"; then
-   # We are being configured with a cross compiler.  AC_REPLACE_FUNCS
-   # may not work correctly, because the compiler may not be able to
-   # link executables.
-
-   # We assume newlib.  This lets us hard-code the functions we know
-   # we'll have.
-   AC_DEFINE(HAVE_MEMCPY)
-   AC_DEFINE(HAVE_STRERROR)
-
-   # We ignore --with-system-zlib in this case.
-   target_all=libzgcj.la
-else
-   AC_FUNC_MMAP
-   AC_CHECK_FUNCS(memcpy strerror)
-
-   if test "$with_system_zlib" = yes; then
-      AC_CHECK_LIB(z, deflate, target_all=, target_all=libzgcj.la)
-   else
-      target_all=libzgcj.la
-   fi
-fi
-
-AC_SUBST(target_all)
-
-AC_CHECK_HEADERS(unistd.h)
-
-if test -n "$with_cross_host" &&
-   test x"$with_cross_host" != x"no"; then
-  toolexecdir='$(exec_prefix)/$(target_alias)'
-  toolexeclibdir='$(toolexecdir)/lib'
-else
-  toolexecdir='$(libdir)/gcc-lib/$(target_alias)'
-  toolexeclibdir='$(libdir)'
-fi
-if test "$GCC" = yes && $CC -print-multi-os-directory > /dev/null 2>&1; then
-  multiosdir=/`$CC -print-multi-os-directory`
-  case $multiosdir in
-    /.) multiosdir= ;; # Avoid trailing /.
-  esac
-else
-  multiosdir=
-fi
-toolexeclibdir=${toolexeclibdir}${multiosdir}
-AC_SUBST(toolexecdir)
-AC_SUBST(toolexeclibdir)
-
-AM_CONDITIONAL(TARGET_LIBRARY, test -n "$with_target_subdir")
-
-if test "${multilib}" = "yes"; then
-  multilib_arg="--enable-multilib"
-else
-  multilib_arg=
-fi
-
-AC_CONFIG_FILES([Makefile])
-AC_OUTPUT
diff -Nbaur gcc-4.8.1/zlib/contrib/ada/buffer_demo.adb gcc-4.8.1-ppc/zlib/contrib/ada/buffer_demo.adb
--- gcc-4.8.1/zlib/contrib/ada/buffer_demo.adb	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/ada/buffer_demo.adb	1970-01-01 01:00:00.000000000 +0100
@@ -1,106 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2004 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
---
---  $Id: buffer_demo.adb,v 1.3 2004/09/06 06:55:35 vagul Exp $
-
---  This demo program provided by Dr Steve Sangwine <sjs@essex.ac.uk>
---
---  Demonstration of a problem with Zlib-Ada (already fixed) when a buffer
---  of exactly the correct size is used for decompressed data, and the last
---  few bytes passed in to Zlib are checksum bytes.
-
---  This program compresses a string of text, and then decompresses the
---  compressed text into a buffer of the same size as the original text.
-
-with Ada.Streams; use Ada.Streams;
-with Ada.Text_IO;
-
-with ZLib; use ZLib;
-
-procedure Buffer_Demo is
-   EOL  : Character renames ASCII.LF;
-   Text : constant String
-     := "Four score and seven years ago our fathers brought forth," & EOL &
-        "upon this continent, a new nation, conceived in liberty," & EOL &
-        "and dedicated to the proposition that `all men are created equal'.";
-
-   Source : Stream_Element_Array (1 .. Text'Length);
-   for Source'Address use Text'Address;
-
-begin
-   Ada.Text_IO.Put (Text);
-   Ada.Text_IO.New_Line;
-   Ada.Text_IO.Put_Line
-     ("Uncompressed size : " & Positive'Image (Text'Length) & " bytes");
-
-   declare
-      Compressed_Data : Stream_Element_Array (1 .. Text'Length);
-      L               : Stream_Element_Offset;
-   begin
-      Compress : declare
-         Compressor : Filter_Type;
-         I : Stream_Element_Offset;
-      begin
-         Deflate_Init (Compressor);
-
-         --  Compress the whole of T at once.
-
-         Translate (Compressor, Source, I, Compressed_Data, L, Finish);
-         pragma Assert (I = Source'Last);
-
-         Close (Compressor);
-
-         Ada.Text_IO.Put_Line
-           ("Compressed size :   "
-            & Stream_Element_Offset'Image (L) & " bytes");
-      end Compress;
-
-      --  Now we decompress the data, passing short blocks of data to Zlib
-      --  (because this demonstrates the problem - the last block passed will
-      --  contain checksum information and there will be no output, only a
-      --  check inside Zlib that the checksum is correct).
-
-      Decompress : declare
-         Decompressor : Filter_Type;
-
-         Uncompressed_Data : Stream_Element_Array (1 .. Text'Length);
-
-         Block_Size : constant := 4;
-         --  This makes sure that the last block contains
-         --  only Adler checksum data.
-
-         P : Stream_Element_Offset := Compressed_Data'First - 1;
-         O : Stream_Element_Offset;
-      begin
-         Inflate_Init (Decompressor);
-
-         loop
-            Translate
-              (Decompressor,
-               Compressed_Data
-                 (P + 1 .. Stream_Element_Offset'Min (P + Block_Size, L)),
-               P,
-               Uncompressed_Data
-                 (Total_Out (Decompressor) + 1 .. Uncompressed_Data'Last),
-               O,
-               No_Flush);
-
-               Ada.Text_IO.Put_Line
-                 ("Total in : " & Count'Image (Total_In (Decompressor)) &
-                  ", out : " & Count'Image (Total_Out (Decompressor)));
-
-               exit when P = L;
-         end loop;
-
-         Ada.Text_IO.New_Line;
-         Ada.Text_IO.Put_Line
-           ("Decompressed text matches original text : "
-             & Boolean'Image (Uncompressed_Data = Source));
-      end Decompress;
-   end;
-end Buffer_Demo;
diff -Nbaur gcc-4.8.1/zlib/contrib/ada/mtest.adb gcc-4.8.1-ppc/zlib/contrib/ada/mtest.adb
--- gcc-4.8.1/zlib/contrib/ada/mtest.adb	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/ada/mtest.adb	1970-01-01 01:00:00.000000000 +0100
@@ -1,156 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
---  Continuous test for ZLib multithreading. If the test would fail
---  we should provide thread safe allocation routines for the Z_Stream.
---
---  $Id: mtest.adb,v 1.4 2004/07/23 07:49:54 vagul Exp $
-
-with ZLib;
-with Ada.Streams;
-with Ada.Numerics.Discrete_Random;
-with Ada.Text_IO;
-with Ada.Exceptions;
-with Ada.Task_Identification;
-
-procedure MTest is
-   use Ada.Streams;
-   use ZLib;
-
-   Stop : Boolean := False;
-
-   pragma Atomic (Stop);
-
-   subtype Visible_Symbols is Stream_Element range 16#20# .. 16#7E#;
-
-   package Random_Elements is
-      new Ada.Numerics.Discrete_Random (Visible_Symbols);
-
-   task type Test_Task;
-
-   task body Test_Task is
-      Buffer : Stream_Element_Array (1 .. 100_000);
-      Gen : Random_Elements.Generator;
-
-      Buffer_First  : Stream_Element_Offset;
-      Compare_First : Stream_Element_Offset;
-
-      Deflate : Filter_Type;
-      Inflate : Filter_Type;
-
-      procedure Further (Item : in Stream_Element_Array);
-
-      procedure Read_Buffer
-        (Item : out Ada.Streams.Stream_Element_Array;
-         Last : out Ada.Streams.Stream_Element_Offset);
-
-      -------------
-      -- Further --
-      -------------
-
-      procedure Further (Item : in Stream_Element_Array) is
-
-         procedure Compare (Item : in Stream_Element_Array);
-
-         -------------
-         -- Compare --
-         -------------
-
-         procedure Compare (Item : in Stream_Element_Array) is
-            Next_First : Stream_Element_Offset := Compare_First + Item'Length;
-         begin
-            if Buffer (Compare_First .. Next_First - 1) /= Item then
-               raise Program_Error;
-            end if;
-
-            Compare_First := Next_First;
-         end Compare;
-
-         procedure Compare_Write is new ZLib.Write (Write => Compare);
-      begin
-         Compare_Write (Inflate, Item, No_Flush);
-      end Further;
-
-      -----------------
-      -- Read_Buffer --
-      -----------------
-
-      procedure Read_Buffer
-        (Item : out Ada.Streams.Stream_Element_Array;
-         Last : out Ada.Streams.Stream_Element_Offset)
-      is
-         Buff_Diff   : Stream_Element_Offset := Buffer'Last - Buffer_First;
-         Next_First : Stream_Element_Offset;
-      begin
-         if Item'Length <= Buff_Diff then
-            Last := Item'Last;
-
-            Next_First := Buffer_First + Item'Length;
-
-            Item := Buffer (Buffer_First .. Next_First - 1);
-
-            Buffer_First := Next_First;
-         else
-            Last := Item'First + Buff_Diff;
-            Item (Item'First .. Last) := Buffer (Buffer_First .. Buffer'Last);
-            Buffer_First := Buffer'Last + 1;
-         end if;
-      end Read_Buffer;
-
-      procedure Translate is new Generic_Translate
-                                   (Data_In  => Read_Buffer,
-                                    Data_Out => Further);
-
-   begin
-      Random_Elements.Reset (Gen);
-
-      Buffer := (others => 20);
-
-      Main : loop
-         for J in Buffer'Range loop
-            Buffer (J) := Random_Elements.Random (Gen);
-
-            Deflate_Init (Deflate);
-            Inflate_Init (Inflate);
-
-            Buffer_First  := Buffer'First;
-            Compare_First := Buffer'First;
-
-            Translate (Deflate);
-
-            if Compare_First /= Buffer'Last + 1 then
-               raise Program_Error;
-            end if;
-
-            Ada.Text_IO.Put_Line
-              (Ada.Task_Identification.Image
-                 (Ada.Task_Identification.Current_Task)
-               & Stream_Element_Offset'Image (J)
-               & ZLib.Count'Image (Total_Out (Deflate)));
-
-            Close (Deflate);
-            Close (Inflate);
-
-            exit Main when Stop;
-         end loop;
-      end loop Main;
-   exception
-      when E : others =>
-         Ada.Text_IO.Put_Line (Ada.Exceptions.Exception_Information (E));
-         Stop := True;
-   end Test_Task;
-
-   Test : array (1 .. 4) of Test_Task;
-
-   pragma Unreferenced (Test);
-
-   Dummy : Character;
-
-begin
-   Ada.Text_IO.Get_Immediate (Dummy);
-   Stop := True;
-end MTest;
diff -Nbaur gcc-4.8.1/zlib/contrib/ada/read.adb gcc-4.8.1-ppc/zlib/contrib/ada/read.adb
--- gcc-4.8.1/zlib/contrib/ada/read.adb	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/ada/read.adb	1970-01-01 01:00:00.000000000 +0100
@@ -1,156 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: read.adb,v 1.8 2004/05/31 10:53:40 vagul Exp $
-
---  Test/demo program for the generic read interface.
-
-with Ada.Numerics.Discrete_Random;
-with Ada.Streams;
-with Ada.Text_IO;
-
-with ZLib;
-
-procedure Read is
-
-   use Ada.Streams;
-
-   ------------------------------------
-   --  Test configuration parameters --
-   ------------------------------------
-
-   File_Size   : Stream_Element_Offset := 100_000;
-
-   Continuous  : constant Boolean          := False;
-   --  If this constant is True, the test would be repeated again and again,
-   --  with increment File_Size for every iteration.
-
-   Header      : constant ZLib.Header_Type := ZLib.Default;
-   --  Do not use Header other than Default in ZLib versions 1.1.4 and older.
-
-   Init_Random : constant := 8;
-   --  We are using the same random sequence, in case of we catch bug,
-   --  so we would be able to reproduce it.
-
-   -- End --
-
-   Pack_Size : Stream_Element_Offset;
-   Offset    : Stream_Element_Offset;
-
-   Filter     : ZLib.Filter_Type;
-
-   subtype Visible_Symbols
-      is Stream_Element range 16#20# .. 16#7E#;
-
-   package Random_Elements is new
-      Ada.Numerics.Discrete_Random (Visible_Symbols);
-
-   Gen : Random_Elements.Generator;
-   Period  : constant Stream_Element_Offset := 200;
-   --  Period constant variable for random generator not to be very random.
-   --  Bigger period, harder random.
-
-   Read_Buffer : Stream_Element_Array (1 .. 2048);
-   Read_First  : Stream_Element_Offset;
-   Read_Last   : Stream_Element_Offset;
-
-   procedure Reset;
-
-   procedure Read
-     (Item : out Stream_Element_Array;
-      Last : out Stream_Element_Offset);
-   --  this procedure is for generic instantiation of
-   --  ZLib.Read
-   --  reading data from the File_In.
-
-   procedure Read is new ZLib.Read
-                           (Read,
-                            Read_Buffer,
-                            Rest_First => Read_First,
-                            Rest_Last  => Read_Last);
-
-   ----------
-   -- Read --
-   ----------
-
-   procedure Read
-     (Item : out Stream_Element_Array;
-      Last : out Stream_Element_Offset) is
-   begin
-      Last := Stream_Element_Offset'Min
-               (Item'Last,
-                Item'First + File_Size - Offset);
-
-      for J in Item'First .. Last loop
-         if J < Item'First + Period then
-            Item (J) := Random_Elements.Random (Gen);
-         else
-            Item (J) := Item (J - Period);
-         end if;
-
-         Offset   := Offset + 1;
-      end loop;
-   end Read;
-
-   -----------
-   -- Reset --
-   -----------
-
-   procedure Reset is
-   begin
-      Random_Elements.Reset (Gen, Init_Random);
-      Pack_Size := 0;
-      Offset := 1;
-      Read_First := Read_Buffer'Last + 1;
-      Read_Last  := Read_Buffer'Last;
-   end Reset;
-
-begin
-   Ada.Text_IO.Put_Line ("ZLib " & ZLib.Version);
-
-   loop
-      for Level in ZLib.Compression_Level'Range loop
-
-         Ada.Text_IO.Put ("Level ="
-            & ZLib.Compression_Level'Image (Level));
-
-         --  Deflate using generic instantiation.
-
-         ZLib.Deflate_Init
-               (Filter,
-                Level,
-                Header => Header);
-
-         Reset;
-
-         Ada.Text_IO.Put
-           (Stream_Element_Offset'Image (File_Size) & " ->");
-
-         loop
-            declare
-               Buffer : Stream_Element_Array (1 .. 1024);
-               Last   : Stream_Element_Offset;
-            begin
-               Read (Filter, Buffer, Last);
-
-               Pack_Size := Pack_Size + Last - Buffer'First + 1;
-
-               exit when Last < Buffer'Last;
-            end;
-         end loop;
-
-         Ada.Text_IO.Put_Line (Stream_Element_Offset'Image (Pack_Size));
-
-         ZLib.Close (Filter);
-      end loop;
-
-      exit when not Continuous;
-
-      File_Size := File_Size + 1;
-   end loop;
-end Read;
diff -Nbaur gcc-4.8.1/zlib/contrib/ada/readme.txt gcc-4.8.1-ppc/zlib/contrib/ada/readme.txt
--- gcc-4.8.1/zlib/contrib/ada/readme.txt	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/ada/readme.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,65 +0,0 @@
-                        ZLib for Ada thick binding (ZLib.Ada)
-                        Release 1.3
-
-ZLib.Ada is a thick binding interface to the popular ZLib data
-compression library, available at http://www.gzip.org/zlib/.
-It provides Ada-style access to the ZLib C library.
-
-
-        Here are the main changes since ZLib.Ada 1.2:
-
-- Attension: ZLib.Read generic routine have a initialization requirement
-  for Read_Last parameter now. It is a bit incompartible with previous version,
-  but extends functionality, we could use new parameters Allow_Read_Some and
-  Flush now.
-
-- Added Is_Open routines to ZLib and ZLib.Streams packages.
-
-- Add pragma Assert to check Stream_Element is 8 bit.
-
-- Fix extraction to buffer with exact known decompressed size. Error reported by
-  Steve Sangwine.
-
-- Fix definition of ULong (changed to unsigned_long), fix regression on 64 bits
-  computers. Patch provided by Pascal Obry.
-
-- Add Status_Error exception definition.
-
-- Add pragma Assertion that Ada.Streams.Stream_Element size is 8 bit.
-
-
-        How to build ZLib.Ada under GNAT
-
-You should have the ZLib library already build on your computer, before
-building ZLib.Ada. Make the directory of ZLib.Ada sources current and
-issue the command:
-
-  gnatmake test -largs -L<directory where libz.a is> -lz
-
-Or use the GNAT project file build for GNAT 3.15 or later:
-
-  gnatmake -Pzlib.gpr -L<directory where libz.a is>
-
-
-        How to build ZLib.Ada under Aonix ObjectAda for Win32 7.2.2
-
-1. Make a project with all *.ads and *.adb files from the distribution.
-2. Build the libz.a library from the ZLib C sources.
-3. Rename libz.a to z.lib.
-4. Add the library z.lib to the project.
-5. Add the libc.lib library from the ObjectAda distribution to the project.
-6. Build the executable using test.adb as a main procedure.
-
-
-        How to use ZLib.Ada
-
-The source files test.adb and read.adb are small demo programs that show
-the main functionality of ZLib.Ada.
-
-The routines from the package specifications are commented.
-
-
-Homepage: http://zlib-ada.sourceforge.net/
-Author: Dmitriy Anisimkov <anisimkov@yahoo.com>
-
-Contributors: Pascal Obry <pascal@obry.org>, Steve Sangwine <sjs@essex.ac.uk>
diff -Nbaur gcc-4.8.1/zlib/contrib/ada/test.adb gcc-4.8.1-ppc/zlib/contrib/ada/test.adb
--- gcc-4.8.1/zlib/contrib/ada/test.adb	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/ada/test.adb	1970-01-01 01:00:00.000000000 +0100
@@ -1,463 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: test.adb,v 1.17 2003/08/12 12:13:30 vagul Exp $
-
---  The program has a few aims.
---  1. Test ZLib.Ada95 thick binding functionality.
---  2. Show the example of use main functionality of the ZLib.Ada95 binding.
---  3. Build this program automatically compile all ZLib.Ada95 packages under
---     GNAT Ada95 compiler.
-
-with ZLib.Streams;
-with Ada.Streams.Stream_IO;
-with Ada.Numerics.Discrete_Random;
-
-with Ada.Text_IO;
-
-with Ada.Calendar;
-
-procedure Test is
-
-   use Ada.Streams;
-   use Stream_IO;
-
-   ------------------------------------
-   --  Test configuration parameters --
-   ------------------------------------
-
-   File_Size   : Count   := 100_000;
-   Continuous  : constant Boolean := False;
-
-   Header      : constant ZLib.Header_Type := ZLib.Default;
-                                              --  ZLib.None;
-                                              --  ZLib.Auto;
-                                              --  ZLib.GZip;
-   --  Do not use Header other then Default in ZLib versions 1.1.4
-   --  and older.
-
-   Strategy    : constant ZLib.Strategy_Type := ZLib.Default_Strategy;
-   Init_Random : constant := 10;
-
-   -- End --
-
-   In_File_Name  : constant String := "testzlib.in";
-   --  Name of the input file
-
-   Z_File_Name   : constant String := "testzlib.zlb";
-   --  Name of the compressed file.
-
-   Out_File_Name : constant String := "testzlib.out";
-   --  Name of the decompressed file.
-
-   File_In   : File_Type;
-   File_Out  : File_Type;
-   File_Back : File_Type;
-   File_Z    : ZLib.Streams.Stream_Type;
-
-   Filter : ZLib.Filter_Type;
-
-   Time_Stamp : Ada.Calendar.Time;
-
-   procedure Generate_File;
-   --  Generate file of spetsified size with some random data.
-   --  The random data is repeatable, for the good compression.
-
-   procedure Compare_Streams
-     (Left, Right : in out Root_Stream_Type'Class);
-   --  The procedure compearing data in 2 streams.
-   --  It is for compare data before and after compression/decompression.
-
-   procedure Compare_Files (Left, Right : String);
-   --  Compare files. Based on the Compare_Streams.
-
-   procedure Copy_Streams
-     (Source, Target : in out Root_Stream_Type'Class;
-      Buffer_Size    : in     Stream_Element_Offset := 1024);
-   --  Copying data from one stream to another. It is for test stream
-   --  interface of the library.
-
-   procedure Data_In
-     (Item : out Stream_Element_Array;
-      Last : out Stream_Element_Offset);
-   --  this procedure is for generic instantiation of
-   --  ZLib.Generic_Translate.
-   --  reading data from the File_In.
-
-   procedure Data_Out (Item : in Stream_Element_Array);
-   --  this procedure is for generic instantiation of
-   --  ZLib.Generic_Translate.
-   --  writing data to the File_Out.
-
-   procedure Stamp;
-   --  Store the timestamp to the local variable.
-
-   procedure Print_Statistic (Msg : String; Data_Size : ZLib.Count);
-   --  Print the time statistic with the message.
-
-   procedure Translate is new ZLib.Generic_Translate
-                                (Data_In  => Data_In,
-                                 Data_Out => Data_Out);
-   --  This procedure is moving data from File_In to File_Out
-   --  with compression or decompression, depend on initialization of
-   --  Filter parameter.
-
-   -------------------
-   -- Compare_Files --
-   -------------------
-
-   procedure Compare_Files (Left, Right : String) is
-      Left_File, Right_File : File_Type;
-   begin
-      Open (Left_File, In_File, Left);
-      Open (Right_File, In_File, Right);
-      Compare_Streams (Stream (Left_File).all, Stream (Right_File).all);
-      Close (Left_File);
-      Close (Right_File);
-   end Compare_Files;
-
-   ---------------------
-   -- Compare_Streams --
-   ---------------------
-
-   procedure Compare_Streams
-     (Left, Right : in out Ada.Streams.Root_Stream_Type'Class)
-   is
-      Left_Buffer, Right_Buffer : Stream_Element_Array (0 .. 16#FFF#);
-      Left_Last, Right_Last : Stream_Element_Offset;
-   begin
-      loop
-         Read (Left, Left_Buffer, Left_Last);
-         Read (Right, Right_Buffer, Right_Last);
-
-         if Left_Last /= Right_Last then
-            Ada.Text_IO.Put_Line ("Compare error :"
-              & Stream_Element_Offset'Image (Left_Last)
-              & " /= "
-              & Stream_Element_Offset'Image (Right_Last));
-
-            raise Constraint_Error;
-
-         elsif Left_Buffer (0 .. Left_Last)
-               /= Right_Buffer (0 .. Right_Last)
-         then
-            Ada.Text_IO.Put_Line ("ERROR: IN and OUT files is not equal.");
-            raise Constraint_Error;
-
-         end if;
-
-         exit when Left_Last < Left_Buffer'Last;
-      end loop;
-   end Compare_Streams;
-
-   ------------------
-   -- Copy_Streams --
-   ------------------
-
-   procedure Copy_Streams
-     (Source, Target : in out Ada.Streams.Root_Stream_Type'Class;
-      Buffer_Size    : in     Stream_Element_Offset := 1024)
-   is
-      Buffer : Stream_Element_Array (1 .. Buffer_Size);
-      Last   : Stream_Element_Offset;
-   begin
-      loop
-         Read  (Source, Buffer, Last);
-         Write (Target, Buffer (1 .. Last));
-
-         exit when Last < Buffer'Last;
-      end loop;
-   end Copy_Streams;
-
-   -------------
-   -- Data_In --
-   -------------
-
-   procedure Data_In
-     (Item : out Stream_Element_Array;
-      Last : out Stream_Element_Offset) is
-   begin
-      Read (File_In, Item, Last);
-   end Data_In;
-
-   --------------
-   -- Data_Out --
-   --------------
-
-   procedure Data_Out (Item : in Stream_Element_Array) is
-   begin
-      Write (File_Out, Item);
-   end Data_Out;
-
-   -------------------
-   -- Generate_File --
-   -------------------
-
-   procedure Generate_File is
-      subtype Visible_Symbols is Stream_Element range 16#20# .. 16#7E#;
-
-      package Random_Elements is
-         new Ada.Numerics.Discrete_Random (Visible_Symbols);
-
-      Gen    : Random_Elements.Generator;
-      Buffer : Stream_Element_Array := (1 .. 77 => 16#20#) & 10;
-
-      Buffer_Count : constant Count := File_Size / Buffer'Length;
-      --  Number of same buffers in the packet.
-
-      Density : constant Count := 30; --  from 0 to Buffer'Length - 2;
-
-      procedure Fill_Buffer (J, D : in Count);
-      --  Change the part of the buffer.
-
-      -----------------
-      -- Fill_Buffer --
-      -----------------
-
-      procedure Fill_Buffer (J, D : in Count) is
-      begin
-         for K in 0 .. D loop
-            Buffer
-              (Stream_Element_Offset ((J + K) mod (Buffer'Length - 1) + 1))
-             := Random_Elements.Random (Gen);
-
-         end loop;
-      end Fill_Buffer;
-
-   begin
-      Random_Elements.Reset (Gen, Init_Random);
-
-      Create (File_In, Out_File, In_File_Name);
-
-      Fill_Buffer (1, Buffer'Length - 2);
-
-      for J in 1 .. Buffer_Count loop
-         Write (File_In, Buffer);
-
-         Fill_Buffer (J, Density);
-      end loop;
-
-      --  fill remain size.
-
-      Write
-        (File_In,
-         Buffer
-           (1 .. Stream_Element_Offset
-                   (File_Size - Buffer'Length * Buffer_Count)));
-
-      Flush (File_In);
-      Close (File_In);
-   end Generate_File;
-
-   ---------------------
-   -- Print_Statistic --
-   ---------------------
-
-   procedure Print_Statistic (Msg : String; Data_Size : ZLib.Count) is
-      use Ada.Calendar;
-      use Ada.Text_IO;
-
-      package Count_IO is new Integer_IO (ZLib.Count);
-
-      Curr_Dur : Duration := Clock - Time_Stamp;
-   begin
-      Put (Msg);
-
-      Set_Col (20);
-      Ada.Text_IO.Put ("size =");
-
-      Count_IO.Put
-        (Data_Size,
-         Width => Stream_IO.Count'Image (File_Size)'Length);
-
-      Put_Line (" duration =" & Duration'Image (Curr_Dur));
-   end Print_Statistic;
-
-   -----------
-   -- Stamp --
-   -----------
-
-   procedure Stamp is
-   begin
-      Time_Stamp := Ada.Calendar.Clock;
-   end Stamp;
-
-begin
-   Ada.Text_IO.Put_Line ("ZLib " & ZLib.Version);
-
-   loop
-      Generate_File;
-
-      for Level in ZLib.Compression_Level'Range loop
-
-         Ada.Text_IO.Put_Line ("Level ="
-            & ZLib.Compression_Level'Image (Level));
-
-         --  Test generic interface.
-         Open   (File_In, In_File, In_File_Name);
-         Create (File_Out, Out_File, Z_File_Name);
-
-         Stamp;
-
-         --  Deflate using generic instantiation.
-
-         ZLib.Deflate_Init
-               (Filter   => Filter,
-                Level    => Level,
-                Strategy => Strategy,
-                Header   => Header);
-
-         Translate (Filter);
-         Print_Statistic ("Generic compress", ZLib.Total_Out (Filter));
-         ZLib.Close (Filter);
-
-         Close (File_In);
-         Close (File_Out);
-
-         Open   (File_In, In_File, Z_File_Name);
-         Create (File_Out, Out_File, Out_File_Name);
-
-         Stamp;
-
-         --  Inflate using generic instantiation.
-
-         ZLib.Inflate_Init (Filter, Header => Header);
-
-         Translate (Filter);
-         Print_Statistic ("Generic decompress", ZLib.Total_Out (Filter));
-
-         ZLib.Close (Filter);
-
-         Close (File_In);
-         Close (File_Out);
-
-         Compare_Files (In_File_Name, Out_File_Name);
-
-         --  Test stream interface.
-
-         --  Compress to the back stream.
-
-         Open   (File_In, In_File, In_File_Name);
-         Create (File_Back, Out_File, Z_File_Name);
-
-         Stamp;
-
-         ZLib.Streams.Create
-           (Stream          => File_Z,
-            Mode            => ZLib.Streams.Out_Stream,
-            Back            => ZLib.Streams.Stream_Access
-                                 (Stream (File_Back)),
-            Back_Compressed => True,
-            Level           => Level,
-            Strategy        => Strategy,
-            Header          => Header);
-
-         Copy_Streams
-           (Source => Stream (File_In).all,
-            Target => File_Z);
-
-         --  Flushing internal buffers to the back stream.
-
-         ZLib.Streams.Flush (File_Z, ZLib.Finish);
-
-         Print_Statistic ("Write compress",
-                          ZLib.Streams.Write_Total_Out (File_Z));
-
-         ZLib.Streams.Close (File_Z);
-
-         Close (File_In);
-         Close (File_Back);
-
-         --  Compare reading from original file and from
-         --  decompression stream.
-
-         Open (File_In,   In_File, In_File_Name);
-         Open (File_Back, In_File, Z_File_Name);
-
-         ZLib.Streams.Create
-           (Stream          => File_Z,
-            Mode            => ZLib.Streams.In_Stream,
-            Back            => ZLib.Streams.Stream_Access
-                                 (Stream (File_Back)),
-            Back_Compressed => True,
-            Header          => Header);
-
-         Stamp;
-         Compare_Streams (Stream (File_In).all, File_Z);
-
-         Print_Statistic ("Read decompress",
-                          ZLib.Streams.Read_Total_Out (File_Z));
-
-         ZLib.Streams.Close (File_Z);
-         Close (File_In);
-         Close (File_Back);
-
-         --  Compress by reading from compression stream.
-
-         Open (File_Back, In_File, In_File_Name);
-         Create (File_Out, Out_File, Z_File_Name);
-
-         ZLib.Streams.Create
-           (Stream          => File_Z,
-            Mode            => ZLib.Streams.In_Stream,
-            Back            => ZLib.Streams.Stream_Access
-                                 (Stream (File_Back)),
-            Back_Compressed => False,
-            Level           => Level,
-            Strategy        => Strategy,
-            Header          => Header);
-
-         Stamp;
-         Copy_Streams
-           (Source => File_Z,
-            Target => Stream (File_Out).all);
-
-         Print_Statistic ("Read compress",
-                          ZLib.Streams.Read_Total_Out (File_Z));
-
-         ZLib.Streams.Close (File_Z);
-
-         Close (File_Out);
-         Close (File_Back);
-
-         --  Decompress to decompression stream.
-
-         Open   (File_In,   In_File, Z_File_Name);
-         Create (File_Back, Out_File, Out_File_Name);
-
-         ZLib.Streams.Create
-           (Stream          => File_Z,
-            Mode            => ZLib.Streams.Out_Stream,
-            Back            => ZLib.Streams.Stream_Access
-                                 (Stream (File_Back)),
-            Back_Compressed => False,
-            Header          => Header);
-
-         Stamp;
-
-         Copy_Streams
-           (Source => Stream (File_In).all,
-            Target => File_Z);
-
-         Print_Statistic ("Write decompress",
-                          ZLib.Streams.Write_Total_Out (File_Z));
-
-         ZLib.Streams.Close (File_Z);
-         Close (File_In);
-         Close (File_Back);
-
-         Compare_Files (In_File_Name, Out_File_Name);
-      end loop;
-
-      Ada.Text_IO.Put_Line (Count'Image (File_Size) & " Ok.");
-
-      exit when not Continuous;
-
-      File_Size := File_Size + 1;
-   end loop;
-end Test;
diff -Nbaur gcc-4.8.1/zlib/contrib/ada/zlib.adb gcc-4.8.1-ppc/zlib/contrib/ada/zlib.adb
--- gcc-4.8.1/zlib/contrib/ada/zlib.adb	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/ada/zlib.adb	1970-01-01 01:00:00.000000000 +0100
@@ -1,701 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2004 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: zlib.adb,v 1.31 2004/09/06 06:53:19 vagul Exp $
-
-with Ada.Exceptions;
-with Ada.Unchecked_Conversion;
-with Ada.Unchecked_Deallocation;
-
-with Interfaces.C.Strings;
-
-with ZLib.Thin;
-
-package body ZLib is
-
-   use type Thin.Int;
-
-   type Z_Stream is new Thin.Z_Stream;
-
-   type Return_Code_Enum is
-      (OK,
-       STREAM_END,
-       NEED_DICT,
-       ERRNO,
-       STREAM_ERROR,
-       DATA_ERROR,
-       MEM_ERROR,
-       BUF_ERROR,
-       VERSION_ERROR);
-
-   type Flate_Step_Function is access
-     function (Strm : in Thin.Z_Streamp; Flush : in Thin.Int) return Thin.Int;
-   pragma Convention (C, Flate_Step_Function);
-
-   type Flate_End_Function is access
-      function (Ctrm : in Thin.Z_Streamp) return Thin.Int;
-   pragma Convention (C, Flate_End_Function);
-
-   type Flate_Type is record
-      Step : Flate_Step_Function;
-      Done : Flate_End_Function;
-   end record;
-
-   subtype Footer_Array is Stream_Element_Array (1 .. 8);
-
-   Simple_GZip_Header : constant Stream_Element_Array (1 .. 10)
-     := (16#1f#, 16#8b#,                 --  Magic header
-         16#08#,                         --  Z_DEFLATED
-         16#00#,                         --  Flags
-         16#00#, 16#00#, 16#00#, 16#00#, --  Time
-         16#00#,                         --  XFlags
-         16#03#                          --  OS code
-        );
-   --  The simplest gzip header is not for informational, but just for
-   --  gzip format compatibility.
-   --  Note that some code below is using assumption
-   --  Simple_GZip_Header'Last > Footer_Array'Last, so do not make
-   --  Simple_GZip_Header'Last <= Footer_Array'Last.
-
-   Return_Code : constant array (Thin.Int range <>) of Return_Code_Enum
-     := (0 => OK,
-         1 => STREAM_END,
-         2 => NEED_DICT,
-        -1 => ERRNO,
-        -2 => STREAM_ERROR,
-        -3 => DATA_ERROR,
-        -4 => MEM_ERROR,
-        -5 => BUF_ERROR,
-        -6 => VERSION_ERROR);
-
-   Flate : constant array (Boolean) of Flate_Type
-     := (True  => (Step => Thin.Deflate'Access,
-                   Done => Thin.DeflateEnd'Access),
-         False => (Step => Thin.Inflate'Access,
-                   Done => Thin.InflateEnd'Access));
-
-   Flush_Finish : constant array (Boolean) of Flush_Mode
-     := (True => Finish, False => No_Flush);
-
-   procedure Raise_Error (Stream : in Z_Stream);
-   pragma Inline (Raise_Error);
-
-   procedure Raise_Error (Message : in String);
-   pragma Inline (Raise_Error);
-
-   procedure Check_Error (Stream : in Z_Stream; Code : in Thin.Int);
-
-   procedure Free is new Ada.Unchecked_Deallocation
-      (Z_Stream, Z_Stream_Access);
-
-   function To_Thin_Access is new Ada.Unchecked_Conversion
-     (Z_Stream_Access, Thin.Z_Streamp);
-
-   procedure Translate_GZip
-     (Filter    : in out Filter_Type;
-      In_Data   : in     Ada.Streams.Stream_Element_Array;
-      In_Last   :    out Ada.Streams.Stream_Element_Offset;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode);
-   --  Separate translate routine for make gzip header.
-
-   procedure Translate_Auto
-     (Filter    : in out Filter_Type;
-      In_Data   : in     Ada.Streams.Stream_Element_Array;
-      In_Last   :    out Ada.Streams.Stream_Element_Offset;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode);
-   --  translate routine without additional headers.
-
-   -----------------
-   -- Check_Error --
-   -----------------
-
-   procedure Check_Error (Stream : in Z_Stream; Code : in Thin.Int) is
-      use type Thin.Int;
-   begin
-      if Code /= Thin.Z_OK then
-         Raise_Error
-            (Return_Code_Enum'Image (Return_Code (Code))
-              & ": " & Last_Error_Message (Stream));
-      end if;
-   end Check_Error;
-
-   -----------
-   -- Close --
-   -----------
-
-   procedure Close
-     (Filter       : in out Filter_Type;
-      Ignore_Error : in     Boolean := False)
-   is
-      Code : Thin.Int;
-   begin
-      if not Ignore_Error and then not Is_Open (Filter) then
-         raise Status_Error;
-      end if;
-
-      Code := Flate (Filter.Compression).Done (To_Thin_Access (Filter.Strm));
-
-      if Ignore_Error or else Code = Thin.Z_OK then
-         Free (Filter.Strm);
-      else
-         declare
-            Error_Message : constant String
-              := Last_Error_Message (Filter.Strm.all);
-         begin
-            Free (Filter.Strm);
-            Ada.Exceptions.Raise_Exception
-               (ZLib_Error'Identity,
-                Return_Code_Enum'Image (Return_Code (Code))
-                  & ": " & Error_Message);
-         end;
-      end if;
-   end Close;
-
-   -----------
-   -- CRC32 --
-   -----------
-
-   function CRC32
-     (CRC  : in Unsigned_32;
-      Data : in Ada.Streams.Stream_Element_Array)
-      return Unsigned_32
-   is
-      use Thin;
-   begin
-      return Unsigned_32 (crc32 (ULong (CRC),
-                                 Data'Address,
-                                 Data'Length));
-   end CRC32;
-
-   procedure CRC32
-     (CRC  : in out Unsigned_32;
-      Data : in     Ada.Streams.Stream_Element_Array) is
-   begin
-      CRC := CRC32 (CRC, Data);
-   end CRC32;
-
-   ------------------
-   -- Deflate_Init --
-   ------------------
-
-   procedure Deflate_Init
-     (Filter       : in out Filter_Type;
-      Level        : in     Compression_Level  := Default_Compression;
-      Strategy     : in     Strategy_Type      := Default_Strategy;
-      Method       : in     Compression_Method := Deflated;
-      Window_Bits  : in     Window_Bits_Type   := Default_Window_Bits;
-      Memory_Level : in     Memory_Level_Type  := Default_Memory_Level;
-      Header       : in     Header_Type        := Default)
-   is
-      use type Thin.Int;
-      Win_Bits : Thin.Int := Thin.Int (Window_Bits);
-   begin
-      if Is_Open (Filter) then
-         raise Status_Error;
-      end if;
-
-      --  We allow ZLib to make header only in case of default header type.
-      --  Otherwise we would either do header by ourselfs, or do not do
-      --  header at all.
-
-      if Header = None or else Header = GZip then
-         Win_Bits := -Win_Bits;
-      end if;
-
-      --  For the GZip CRC calculation and make headers.
-
-      if Header = GZip then
-         Filter.CRC    := 0;
-         Filter.Offset := Simple_GZip_Header'First;
-      else
-         Filter.Offset := Simple_GZip_Header'Last + 1;
-      end if;
-
-      Filter.Strm        := new Z_Stream;
-      Filter.Compression := True;
-      Filter.Stream_End  := False;
-      Filter.Header      := Header;
-
-      if Thin.Deflate_Init
-           (To_Thin_Access (Filter.Strm),
-            Level      => Thin.Int (Level),
-            method     => Thin.Int (Method),
-            windowBits => Win_Bits,
-            memLevel   => Thin.Int (Memory_Level),
-            strategy   => Thin.Int (Strategy)) /= Thin.Z_OK
-      then
-         Raise_Error (Filter.Strm.all);
-      end if;
-   end Deflate_Init;
-
-   -----------
-   -- Flush --
-   -----------
-
-   procedure Flush
-     (Filter    : in out Filter_Type;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode)
-   is
-      No_Data : Stream_Element_Array := (1 .. 0 => 0);
-      Last    : Stream_Element_Offset;
-   begin
-      Translate (Filter, No_Data, Last, Out_Data, Out_Last, Flush);
-   end Flush;
-
-   -----------------------
-   -- Generic_Translate --
-   -----------------------
-
-   procedure Generic_Translate
-     (Filter          : in out ZLib.Filter_Type;
-      In_Buffer_Size  : in     Integer := Default_Buffer_Size;
-      Out_Buffer_Size : in     Integer := Default_Buffer_Size)
-   is
-      In_Buffer  : Stream_Element_Array
-                     (1 .. Stream_Element_Offset (In_Buffer_Size));
-      Out_Buffer : Stream_Element_Array
-                     (1 .. Stream_Element_Offset (Out_Buffer_Size));
-      Last       : Stream_Element_Offset;
-      In_Last    : Stream_Element_Offset;
-      In_First   : Stream_Element_Offset;
-      Out_Last   : Stream_Element_Offset;
-   begin
-      Main : loop
-         Data_In (In_Buffer, Last);
-
-         In_First := In_Buffer'First;
-
-         loop
-            Translate
-              (Filter   => Filter,
-               In_Data  => In_Buffer (In_First .. Last),
-               In_Last  => In_Last,
-               Out_Data => Out_Buffer,
-               Out_Last => Out_Last,
-               Flush    => Flush_Finish (Last < In_Buffer'First));
-
-            if Out_Buffer'First <= Out_Last then
-               Data_Out (Out_Buffer (Out_Buffer'First .. Out_Last));
-            end if;
-
-            exit Main when Stream_End (Filter);
-
-            --  The end of in buffer.
-
-            exit when In_Last = Last;
-
-            In_First := In_Last + 1;
-         end loop;
-      end loop Main;
-
-   end Generic_Translate;
-
-   ------------------
-   -- Inflate_Init --
-   ------------------
-
-   procedure Inflate_Init
-     (Filter      : in out Filter_Type;
-      Window_Bits : in     Window_Bits_Type := Default_Window_Bits;
-      Header      : in     Header_Type      := Default)
-   is
-      use type Thin.Int;
-      Win_Bits : Thin.Int := Thin.Int (Window_Bits);
-
-      procedure Check_Version;
-      --  Check the latest header types compatibility.
-
-      procedure Check_Version is
-      begin
-         if Version <= "1.1.4" then
-            Raise_Error
-              ("Inflate header type " & Header_Type'Image (Header)
-               & " incompatible with ZLib version " & Version);
-         end if;
-      end Check_Version;
-
-   begin
-      if Is_Open (Filter) then
-         raise Status_Error;
-      end if;
-
-      case Header is
-         when None =>
-            Check_Version;
-
-            --  Inflate data without headers determined
-            --  by negative Win_Bits.
-
-            Win_Bits := -Win_Bits;
-         when GZip =>
-            Check_Version;
-
-            --  Inflate gzip data defined by flag 16.
-
-            Win_Bits := Win_Bits + 16;
-         when Auto =>
-            Check_Version;
-
-            --  Inflate with automatic detection
-            --  of gzip or native header defined by flag 32.
-
-            Win_Bits := Win_Bits + 32;
-         when Default => null;
-      end case;
-
-      Filter.Strm        := new Z_Stream;
-      Filter.Compression := False;
-      Filter.Stream_End  := False;
-      Filter.Header      := Header;
-
-      if Thin.Inflate_Init
-         (To_Thin_Access (Filter.Strm), Win_Bits) /= Thin.Z_OK
-      then
-         Raise_Error (Filter.Strm.all);
-      end if;
-   end Inflate_Init;
-
-   -------------
-   -- Is_Open --
-   -------------
-
-   function Is_Open (Filter : in Filter_Type) return Boolean is
-   begin
-      return Filter.Strm /= null;
-   end Is_Open;
-
-   -----------------
-   -- Raise_Error --
-   -----------------
-
-   procedure Raise_Error (Message : in String) is
-   begin
-      Ada.Exceptions.Raise_Exception (ZLib_Error'Identity, Message);
-   end Raise_Error;
-
-   procedure Raise_Error (Stream : in Z_Stream) is
-   begin
-      Raise_Error (Last_Error_Message (Stream));
-   end Raise_Error;
-
-   ----------
-   -- Read --
-   ----------
-
-   procedure Read
-     (Filter : in out Filter_Type;
-      Item   :    out Ada.Streams.Stream_Element_Array;
-      Last   :    out Ada.Streams.Stream_Element_Offset;
-      Flush  : in     Flush_Mode := No_Flush)
-   is
-      In_Last    : Stream_Element_Offset;
-      Item_First : Ada.Streams.Stream_Element_Offset := Item'First;
-      V_Flush    : Flush_Mode := Flush;
-
-   begin
-      pragma Assert (Rest_First in Buffer'First .. Buffer'Last + 1);
-      pragma Assert (Rest_Last in Buffer'First - 1 .. Buffer'Last);
-
-      loop
-         if Rest_Last = Buffer'First - 1 then
-            V_Flush := Finish;
-
-         elsif Rest_First > Rest_Last then
-            Read (Buffer, Rest_Last);
-            Rest_First := Buffer'First;
-
-            if Rest_Last < Buffer'First then
-               V_Flush := Finish;
-            end if;
-         end if;
-
-         Translate
-           (Filter   => Filter,
-            In_Data  => Buffer (Rest_First .. Rest_Last),
-            In_Last  => In_Last,
-            Out_Data => Item (Item_First .. Item'Last),
-            Out_Last => Last,
-            Flush    => V_Flush);
-
-         Rest_First := In_Last + 1;
-
-         exit when Stream_End (Filter)
-           or else Last = Item'Last
-           or else (Last >= Item'First and then Allow_Read_Some);
-
-         Item_First := Last + 1;
-      end loop;
-   end Read;
-
-   ----------------
-   -- Stream_End --
-   ----------------
-
-   function Stream_End (Filter : in Filter_Type) return Boolean is
-   begin
-      if Filter.Header = GZip and Filter.Compression then
-         return Filter.Stream_End
-            and then Filter.Offset = Footer_Array'Last + 1;
-      else
-         return Filter.Stream_End;
-      end if;
-   end Stream_End;
-
-   --------------
-   -- Total_In --
-   --------------
-
-   function Total_In (Filter : in Filter_Type) return Count is
-   begin
-      return Count (Thin.Total_In (To_Thin_Access (Filter.Strm).all));
-   end Total_In;
-
-   ---------------
-   -- Total_Out --
-   ---------------
-
-   function Total_Out (Filter : in Filter_Type) return Count is
-   begin
-      return Count (Thin.Total_Out (To_Thin_Access (Filter.Strm).all));
-   end Total_Out;
-
-   ---------------
-   -- Translate --
-   ---------------
-
-   procedure Translate
-     (Filter    : in out Filter_Type;
-      In_Data   : in     Ada.Streams.Stream_Element_Array;
-      In_Last   :    out Ada.Streams.Stream_Element_Offset;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode) is
-   begin
-      if Filter.Header = GZip and then Filter.Compression then
-         Translate_GZip
-           (Filter   => Filter,
-            In_Data  => In_Data,
-            In_Last  => In_Last,
-            Out_Data => Out_Data,
-            Out_Last => Out_Last,
-            Flush    => Flush);
-      else
-         Translate_Auto
-           (Filter   => Filter,
-            In_Data  => In_Data,
-            In_Last  => In_Last,
-            Out_Data => Out_Data,
-            Out_Last => Out_Last,
-            Flush    => Flush);
-      end if;
-   end Translate;
-
-   --------------------
-   -- Translate_Auto --
-   --------------------
-
-   procedure Translate_Auto
-     (Filter    : in out Filter_Type;
-      In_Data   : in     Ada.Streams.Stream_Element_Array;
-      In_Last   :    out Ada.Streams.Stream_Element_Offset;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode)
-   is
-      use type Thin.Int;
-      Code : Thin.Int;
-
-   begin
-      if not Is_Open (Filter) then
-         raise Status_Error;
-      end if;
-
-      if Out_Data'Length = 0 and then In_Data'Length = 0 then
-         raise Constraint_Error;
-      end if;
-
-      Set_Out (Filter.Strm.all, Out_Data'Address, Out_Data'Length);
-      Set_In  (Filter.Strm.all, In_Data'Address, In_Data'Length);
-
-      Code := Flate (Filter.Compression).Step
-        (To_Thin_Access (Filter.Strm),
-         Thin.Int (Flush));
-
-      if Code = Thin.Z_STREAM_END then
-         Filter.Stream_End := True;
-      else
-         Check_Error (Filter.Strm.all, Code);
-      end if;
-
-      In_Last  := In_Data'Last
-         - Stream_Element_Offset (Avail_In (Filter.Strm.all));
-      Out_Last := Out_Data'Last
-         - Stream_Element_Offset (Avail_Out (Filter.Strm.all));
-   end Translate_Auto;
-
-   --------------------
-   -- Translate_GZip --
-   --------------------
-
-   procedure Translate_GZip
-     (Filter    : in out Filter_Type;
-      In_Data   : in     Ada.Streams.Stream_Element_Array;
-      In_Last   :    out Ada.Streams.Stream_Element_Offset;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode)
-   is
-      Out_First : Stream_Element_Offset;
-
-      procedure Add_Data (Data : in Stream_Element_Array);
-      --  Add data to stream from the Filter.Offset till necessary,
-      --  used for add gzip headr/footer.
-
-      procedure Put_32
-        (Item : in out Stream_Element_Array;
-         Data : in     Unsigned_32);
-      pragma Inline (Put_32);
-
-      --------------
-      -- Add_Data --
-      --------------
-
-      procedure Add_Data (Data : in Stream_Element_Array) is
-         Data_First : Stream_Element_Offset renames Filter.Offset;
-         Data_Last  : Stream_Element_Offset;
-         Data_Len   : Stream_Element_Offset; --  -1
-         Out_Len    : Stream_Element_Offset; --  -1
-      begin
-         Out_First := Out_Last + 1;
-
-         if Data_First > Data'Last then
-            return;
-         end if;
-
-         Data_Len  := Data'Last     - Data_First;
-         Out_Len   := Out_Data'Last - Out_First;
-
-         if Data_Len <= Out_Len then
-            Out_Last  := Out_First  + Data_Len;
-            Data_Last := Data'Last;
-         else
-            Out_Last  := Out_Data'Last;
-            Data_Last := Data_First + Out_Len;
-         end if;
-
-         Out_Data (Out_First .. Out_Last) := Data (Data_First .. Data_Last);
-
-         Data_First := Data_Last + 1;
-         Out_First  := Out_Last + 1;
-      end Add_Data;
-
-      ------------
-      -- Put_32 --
-      ------------
-
-      procedure Put_32
-        (Item : in out Stream_Element_Array;
-         Data : in     Unsigned_32)
-      is
-         D : Unsigned_32 := Data;
-      begin
-         for J in Item'First .. Item'First + 3 loop
-            Item (J) := Stream_Element (D and 16#FF#);
-            D := Shift_Right (D, 8);
-         end loop;
-      end Put_32;
-
-   begin
-      Out_Last := Out_Data'First - 1;
-
-      if not Filter.Stream_End then
-         Add_Data (Simple_GZip_Header);
-
-         Translate_Auto
-           (Filter   => Filter,
-            In_Data  => In_Data,
-            In_Last  => In_Last,
-            Out_Data => Out_Data (Out_First .. Out_Data'Last),
-            Out_Last => Out_Last,
-            Flush    => Flush);
-
-         CRC32 (Filter.CRC, In_Data (In_Data'First .. In_Last));
-      end if;
-
-      if Filter.Stream_End and then Out_Last <= Out_Data'Last then
-         --  This detection method would work only when
-         --  Simple_GZip_Header'Last > Footer_Array'Last
-
-         if Filter.Offset = Simple_GZip_Header'Last + 1 then
-            Filter.Offset := Footer_Array'First;
-         end if;
-
-         declare
-            Footer : Footer_Array;
-         begin
-            Put_32 (Footer, Filter.CRC);
-            Put_32 (Footer (Footer'First + 4 .. Footer'Last),
-                    Unsigned_32 (Total_In (Filter)));
-            Add_Data (Footer);
-         end;
-      end if;
-   end Translate_GZip;
-
-   -------------
-   -- Version --
-   -------------
-
-   function Version return String is
-   begin
-      return Interfaces.C.Strings.Value (Thin.zlibVersion);
-   end Version;
-
-   -----------
-   -- Write --
-   -----------
-
-   procedure Write
-     (Filter : in out Filter_Type;
-      Item   : in     Ada.Streams.Stream_Element_Array;
-      Flush  : in     Flush_Mode := No_Flush)
-   is
-      Buffer   : Stream_Element_Array (1 .. Buffer_Size);
-      In_Last  : Stream_Element_Offset;
-      Out_Last : Stream_Element_Offset;
-      In_First : Stream_Element_Offset := Item'First;
-   begin
-      if Item'Length = 0 and Flush = No_Flush then
-         return;
-      end if;
-
-      loop
-         Translate
-           (Filter   => Filter,
-            In_Data  => Item (In_First .. Item'Last),
-            In_Last  => In_Last,
-            Out_Data => Buffer,
-            Out_Last => Out_Last,
-            Flush    => Flush);
-
-         if Out_Last >= Buffer'First then
-            Write (Buffer (1 .. Out_Last));
-         end if;
-
-         exit when In_Last = Item'Last or Stream_End (Filter);
-
-         In_First := In_Last + 1;
-      end loop;
-   end Write;
-
-end ZLib;
diff -Nbaur gcc-4.8.1/zlib/contrib/ada/zlib.ads gcc-4.8.1-ppc/zlib/contrib/ada/zlib.ads
--- gcc-4.8.1/zlib/contrib/ada/zlib.ads	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/ada/zlib.ads	1970-01-01 01:00:00.000000000 +0100
@@ -1,328 +0,0 @@
-------------------------------------------------------------------------------
---                      ZLib for Ada thick binding.                         --
---                                                                          --
---              Copyright (C) 2002-2004 Dmitriy Anisimkov                   --
---                                                                          --
---  This library is free software; you can redistribute it and/or modify    --
---  it under the terms of the GNU General Public License as published by    --
---  the Free Software Foundation; either version 2 of the License, or (at   --
---  your option) any later version.                                         --
---                                                                          --
---  This library is distributed in the hope that it will be useful, but     --
---  WITHOUT ANY WARRANTY; without even the implied warranty of              --
---  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       --
---  General Public License for more details.                                --
---                                                                          --
---  You should have received a copy of the GNU General Public License       --
---  along with this library; if not, write to the Free Software Foundation, --
---  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.          --
---                                                                          --
---  As a special exception, if other files instantiate generics from this   --
---  unit, or you link this unit with other files to produce an executable,  --
---  this  unit  does not  by itself cause  the resulting executable to be   --
---  covered by the GNU General Public License. This exception does not      --
---  however invalidate any other reasons why the executable file  might be  --
---  covered by the  GNU Public License.                                     --
-------------------------------------------------------------------------------
-
---  $Id: zlib.ads,v 1.26 2004/09/06 06:53:19 vagul Exp $
-
-with Ada.Streams;
-
-with Interfaces;
-
-package ZLib is
-
-   ZLib_Error   : exception;
-   Status_Error : exception;
-
-   type Compression_Level is new Integer range -1 .. 9;
-
-   type Flush_Mode is private;
-
-   type Compression_Method is private;
-
-   type Window_Bits_Type is new Integer range 8 .. 15;
-
-   type Memory_Level_Type is new Integer range 1 .. 9;
-
-   type Unsigned_32 is new Interfaces.Unsigned_32;
-
-   type Strategy_Type is private;
-
-   type Header_Type is (None, Auto, Default, GZip);
-   --  Header type usage have a some limitation for inflate.
-   --  See comment for Inflate_Init.
-
-   subtype Count is Ada.Streams.Stream_Element_Count;
-
-   Default_Memory_Level : constant Memory_Level_Type := 8;
-   Default_Window_Bits  : constant Window_Bits_Type  := 15;
-
-   ----------------------------------
-   -- Compression method constants --
-   ----------------------------------
-
-   Deflated : constant Compression_Method;
-   --  Only one method allowed in this ZLib version
-
-   ---------------------------------
-   -- Compression level constants --
-   ---------------------------------
-
-   No_Compression      : constant Compression_Level := 0;
-   Best_Speed          : constant Compression_Level := 1;
-   Best_Compression    : constant Compression_Level := 9;
-   Default_Compression : constant Compression_Level := -1;
-
-   --------------------------
-   -- Flush mode constants --
-   --------------------------
-
-   No_Flush      : constant Flush_Mode;
-   --  Regular way for compression, no flush
-
-   Partial_Flush : constant Flush_Mode;
-   --  Will be removed, use Z_SYNC_FLUSH instead
-
-   Sync_Flush    : constant Flush_Mode;
-   --  All pending output is flushed to the output buffer and the output
-   --  is aligned on a byte boundary, so that the decompressor can get all
-   --  input data available so far. (In particular avail_in is zero after the
-   --  call if enough output space has been provided  before the call.)
-   --  Flushing may degrade compression for some compression algorithms and so
-   --  it should be used only when necessary.
-
-   Block_Flush   : constant Flush_Mode;
-   --  Z_BLOCK requests that inflate() stop
-   --  if and when it get to the next deflate block boundary. When decoding the
-   --  zlib or gzip format, this will cause inflate() to return immediately
-   --  after the header and before the first block. When doing a raw inflate,
-   --  inflate() will go ahead and process the first block, and will return
-   --  when it gets to the end of that block, or when it runs out of data.
-
-   Full_Flush    : constant Flush_Mode;
-   --  All output is flushed as with SYNC_FLUSH, and the compression state
-   --  is reset so that decompression can restart from this point if previous
-   --  compressed data has been damaged or if random access is desired. Using
-   --  Full_Flush too often can seriously degrade the compression.
-
-   Finish        : constant Flush_Mode;
-   --  Just for tell the compressor that input data is complete.
-
-   ------------------------------------
-   -- Compression strategy constants --
-   ------------------------------------
-
-   --  RLE stategy could be used only in version 1.2.0 and later.
-
-   Filtered         : constant Strategy_Type;
-   Huffman_Only     : constant Strategy_Type;
-   RLE              : constant Strategy_Type;
-   Default_Strategy : constant Strategy_Type;
-
-   Default_Buffer_Size : constant := 4096;
-
-   type Filter_Type is tagged limited private;
-   --  The filter is for compression and for decompression.
-   --  The usage of the type is depend of its initialization.
-
-   function Version return String;
-   pragma Inline (Version);
-   --  Return string representation of the ZLib version.
-
-   procedure Deflate_Init
-     (Filter       : in out Filter_Type;
-      Level        : in     Compression_Level  := Default_Compression;
-      Strategy     : in     Strategy_Type      := Default_Strategy;
-      Method       : in     Compression_Method := Deflated;
-      Window_Bits  : in     Window_Bits_Type   := Default_Window_Bits;
-      Memory_Level : in     Memory_Level_Type  := Default_Memory_Level;
-      Header       : in     Header_Type        := Default);
-   --  Compressor initialization.
-   --  When Header parameter is Auto or Default, then default zlib header
-   --  would be provided for compressed data.
-   --  When Header is GZip, then gzip header would be set instead of
-   --  default header.
-   --  When Header is None, no header would be set for compressed data.
-
-   procedure Inflate_Init
-     (Filter      : in out Filter_Type;
-      Window_Bits : in     Window_Bits_Type := Default_Window_Bits;
-      Header      : in     Header_Type      := Default);
-   --  Decompressor initialization.
-   --  Default header type mean that ZLib default header is expecting in the
-   --  input compressed stream.
-   --  Header type None mean that no header is expecting in the input stream.
-   --  GZip header type mean that GZip header is expecting in the
-   --  input compressed stream.
-   --  Auto header type mean that header type (GZip or Native) would be
-   --  detected automatically in the input stream.
-   --  Note that header types parameter values None, GZip and Auto are
-   --  supported for inflate routine only in ZLib versions 1.2.0.2 and later.
-   --  Deflate_Init is supporting all header types.
-
-   function Is_Open (Filter : in Filter_Type) return Boolean;
-   pragma Inline (Is_Open);
-   --  Is the filter opened for compression or decompression.
-
-   procedure Close
-     (Filter       : in out Filter_Type;
-      Ignore_Error : in     Boolean := False);
-   --  Closing the compression or decompressor.
-   --  If stream is closing before the complete and Ignore_Error is False,
-   --  The exception would be raised.
-
-   generic
-      with procedure Data_In
-        (Item : out Ada.Streams.Stream_Element_Array;
-         Last : out Ada.Streams.Stream_Element_Offset);
-      with procedure Data_Out
-        (Item : in Ada.Streams.Stream_Element_Array);
-   procedure Generic_Translate
-     (Filter          : in out Filter_Type;
-      In_Buffer_Size  : in     Integer := Default_Buffer_Size;
-      Out_Buffer_Size : in     Integer := Default_Buffer_Size);
-   --  Compress/decompress data fetch from Data_In routine and pass the result
-   --  to the Data_Out routine. User should provide Data_In and Data_Out
-   --  for compression/decompression data flow.
-   --  Compression or decompression depend on Filter initialization.
-
-   function Total_In (Filter : in Filter_Type) return Count;
-   pragma Inline (Total_In);
-   --  Returns total number of input bytes read so far
-
-   function Total_Out (Filter : in Filter_Type) return Count;
-   pragma Inline (Total_Out);
-   --  Returns total number of bytes output so far
-
-   function CRC32
-     (CRC    : in Unsigned_32;
-      Data   : in Ada.Streams.Stream_Element_Array)
-      return Unsigned_32;
-   pragma Inline (CRC32);
-   --  Compute CRC32, it could be necessary for make gzip format
-
-   procedure CRC32
-     (CRC  : in out Unsigned_32;
-      Data : in     Ada.Streams.Stream_Element_Array);
-   pragma Inline (CRC32);
-   --  Compute CRC32, it could be necessary for make gzip format
-
-   -------------------------------------------------
-   --  Below is more complex low level routines.  --
-   -------------------------------------------------
-
-   procedure Translate
-     (Filter    : in out Filter_Type;
-      In_Data   : in     Ada.Streams.Stream_Element_Array;
-      In_Last   :    out Ada.Streams.Stream_Element_Offset;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode);
-   --  Compress/decompress the In_Data buffer and place the result into
-   --  Out_Data. In_Last is the index of last element from In_Data accepted by
-   --  the Filter. Out_Last is the last element of the received data from
-   --  Filter. To tell the filter that incoming data are complete put the
-   --  Flush parameter to Finish.
-
-   function Stream_End (Filter : in Filter_Type) return Boolean;
-   pragma Inline (Stream_End);
-   --  Return the true when the stream is complete.
-
-   procedure Flush
-     (Filter    : in out Filter_Type;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode);
-   pragma Inline (Flush);
-   --  Flushing the data from the compressor.
-
-   generic
-      with procedure Write
-        (Item : in Ada.Streams.Stream_Element_Array);
-      --  User should provide this routine for accept
-      --  compressed/decompressed data.
-
-      Buffer_Size : in Ada.Streams.Stream_Element_Offset
-         := Default_Buffer_Size;
-      --  Buffer size for Write user routine.
-
-   procedure Write
-     (Filter  : in out Filter_Type;
-      Item    : in     Ada.Streams.Stream_Element_Array;
-      Flush   : in     Flush_Mode := No_Flush);
-   --  Compress/Decompress data from Item to the generic parameter procedure
-   --  Write. Output buffer size could be set in Buffer_Size generic parameter.
-
-   generic
-      with procedure Read
-        (Item : out Ada.Streams.Stream_Element_Array;
-         Last : out Ada.Streams.Stream_Element_Offset);
-      --  User should provide data for compression/decompression
-      --  thru this routine.
-
-      Buffer : in out Ada.Streams.Stream_Element_Array;
-      --  Buffer for keep remaining data from the previous
-      --  back read.
-
-      Rest_First, Rest_Last : in out Ada.Streams.Stream_Element_Offset;
-      --  Rest_First have to be initialized to Buffer'Last + 1
-      --  Rest_Last have to be initialized to Buffer'Last
-      --  before usage.
-
-      Allow_Read_Some : in Boolean := False;
-      --  Is it allowed to return Last < Item'Last before end of data.
-
-   procedure Read
-     (Filter : in out Filter_Type;
-      Item   :    out Ada.Streams.Stream_Element_Array;
-      Last   :    out Ada.Streams.Stream_Element_Offset;
-      Flush  : in     Flush_Mode := No_Flush);
-   --  Compress/Decompress data from generic parameter procedure Read to the
-   --  Item. User should provide Buffer and initialized Rest_First, Rest_Last
-   --  indicators. If Allow_Read_Some is True, Read routines could return
-   --  Last < Item'Last only at end of stream.
-
-private
-
-   use Ada.Streams;
-
-   pragma Assert (Ada.Streams.Stream_Element'Size    =    8);
-   pragma Assert (Ada.Streams.Stream_Element'Modulus = 2**8);
-
-   type Flush_Mode is new Integer range 0 .. 5;
-
-   type Compression_Method is new Integer range 8 .. 8;
-
-   type Strategy_Type is new Integer range 0 .. 3;
-
-   No_Flush      : constant Flush_Mode := 0;
-   Partial_Flush : constant Flush_Mode := 1;
-   Sync_Flush    : constant Flush_Mode := 2;
-   Full_Flush    : constant Flush_Mode := 3;
-   Finish        : constant Flush_Mode := 4;
-   Block_Flush   : constant Flush_Mode := 5;
-
-   Filtered         : constant Strategy_Type := 1;
-   Huffman_Only     : constant Strategy_Type := 2;
-   RLE              : constant Strategy_Type := 3;
-   Default_Strategy : constant Strategy_Type := 0;
-
-   Deflated : constant Compression_Method := 8;
-
-   type Z_Stream;
-
-   type Z_Stream_Access is access all Z_Stream;
-
-   type Filter_Type is tagged limited record
-      Strm        : Z_Stream_Access;
-      Compression : Boolean;
-      Stream_End  : Boolean;
-      Header      : Header_Type;
-      CRC         : Unsigned_32;
-      Offset      : Stream_Element_Offset;
-      --  Offset for gzip header/footer output.
-   end record;
-
-end ZLib;
diff -Nbaur gcc-4.8.1/zlib/contrib/ada/zlib.gpr gcc-4.8.1-ppc/zlib/contrib/ada/zlib.gpr
--- gcc-4.8.1/zlib/contrib/ada/zlib.gpr	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/ada/zlib.gpr	1970-01-01 01:00:00.000000000 +0100
@@ -1,20 +0,0 @@
-project Zlib is
-
-   for Languages use ("Ada");
-   for Source_Dirs use (".");
-   for Object_Dir use ".";
-   for Main use ("test.adb", "mtest.adb", "read.adb", "buffer_demo");
-
-   package Compiler is
-      for Default_Switches ("ada") use ("-gnatwcfilopru", "-gnatVcdfimorst", "-gnatyabcefhiklmnoprst");
-   end Compiler;
-
-   package Linker is
-      for Default_Switches ("ada") use ("-lz");
-   end Linker;
-
-   package Builder is
-      for Default_Switches ("ada") use ("-s", "-gnatQ");
-   end Builder;
-
-end Zlib;
diff -Nbaur gcc-4.8.1/zlib/contrib/ada/zlib-streams.adb gcc-4.8.1-ppc/zlib/contrib/ada/zlib-streams.adb
--- gcc-4.8.1/zlib/contrib/ada/zlib-streams.adb	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/ada/zlib-streams.adb	1970-01-01 01:00:00.000000000 +0100
@@ -1,225 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: zlib-streams.adb,v 1.10 2004/05/31 10:53:40 vagul Exp $
-
-with Ada.Unchecked_Deallocation;
-
-package body ZLib.Streams is
-
-   -----------
-   -- Close --
-   -----------
-
-   procedure Close (Stream : in out Stream_Type) is
-      procedure Free is new Ada.Unchecked_Deallocation
-         (Stream_Element_Array, Buffer_Access);
-   begin
-      if Stream.Mode = Out_Stream or Stream.Mode = Duplex then
-         --  We should flush the data written by the writer.
-
-         Flush (Stream, Finish);
-
-         Close (Stream.Writer);
-      end if;
-
-      if Stream.Mode = In_Stream or Stream.Mode = Duplex then
-         Close (Stream.Reader);
-         Free (Stream.Buffer);
-      end if;
-   end Close;
-
-   ------------
-   -- Create --
-   ------------
-
-   procedure Create
-     (Stream            :    out Stream_Type;
-      Mode              : in     Stream_Mode;
-      Back              : in     Stream_Access;
-      Back_Compressed   : in     Boolean;
-      Level             : in     Compression_Level := Default_Compression;
-      Strategy          : in     Strategy_Type     := Default_Strategy;
-      Header            : in     Header_Type       := Default;
-      Read_Buffer_Size  : in     Ada.Streams.Stream_Element_Offset
-                                    := Default_Buffer_Size;
-      Write_Buffer_Size : in     Ada.Streams.Stream_Element_Offset
-                                    := Default_Buffer_Size)
-   is
-
-      subtype Buffer_Subtype is Stream_Element_Array (1 .. Read_Buffer_Size);
-
-      procedure Init_Filter
-         (Filter   : in out Filter_Type;
-          Compress : in     Boolean);
-
-      -----------------
-      -- Init_Filter --
-      -----------------
-
-      procedure Init_Filter
-         (Filter   : in out Filter_Type;
-          Compress : in     Boolean) is
-      begin
-         if Compress then
-            Deflate_Init
-              (Filter, Level, Strategy, Header => Header);
-         else
-            Inflate_Init (Filter, Header => Header);
-         end if;
-      end Init_Filter;
-
-   begin
-      Stream.Back := Back;
-      Stream.Mode := Mode;
-
-      if Mode = Out_Stream or Mode = Duplex then
-         Init_Filter (Stream.Writer, Back_Compressed);
-         Stream.Buffer_Size := Write_Buffer_Size;
-      else
-         Stream.Buffer_Size := 0;
-      end if;
-
-      if Mode = In_Stream or Mode = Duplex then
-         Init_Filter (Stream.Reader, not Back_Compressed);
-
-         Stream.Buffer     := new Buffer_Subtype;
-         Stream.Rest_First := Stream.Buffer'Last + 1;
-         Stream.Rest_Last  := Stream.Buffer'Last;
-      end if;
-   end Create;
-
-   -----------
-   -- Flush --
-   -----------
-
-   procedure Flush
-     (Stream : in out Stream_Type;
-      Mode   : in     Flush_Mode := Sync_Flush)
-   is
-      Buffer : Stream_Element_Array (1 .. Stream.Buffer_Size);
-      Last   : Stream_Element_Offset;
-   begin
-      loop
-         Flush (Stream.Writer, Buffer, Last, Mode);
-
-         Ada.Streams.Write (Stream.Back.all, Buffer (1 .. Last));
-
-         exit when Last < Buffer'Last;
-      end loop;
-   end Flush;
-
-   -------------
-   -- Is_Open --
-   -------------
-
-   function Is_Open (Stream : Stream_Type) return Boolean is
-   begin
-      return Is_Open (Stream.Reader) or else Is_Open (Stream.Writer);
-   end Is_Open;
-
-   ----------
-   -- Read --
-   ----------
-
-   procedure Read
-     (Stream : in out Stream_Type;
-      Item   :    out Stream_Element_Array;
-      Last   :    out Stream_Element_Offset)
-   is
-
-      procedure Read
-        (Item : out Stream_Element_Array;
-         Last : out Stream_Element_Offset);
-
-      ----------
-      -- Read --
-      ----------
-
-      procedure Read
-        (Item : out Stream_Element_Array;
-         Last : out Stream_Element_Offset) is
-      begin
-         Ada.Streams.Read (Stream.Back.all, Item, Last);
-      end Read;
-
-      procedure Read is new ZLib.Read
-         (Read       => Read,
-          Buffer     => Stream.Buffer.all,
-          Rest_First => Stream.Rest_First,
-          Rest_Last  => Stream.Rest_Last);
-
-   begin
-      Read (Stream.Reader, Item, Last);
-   end Read;
-
-   -------------------
-   -- Read_Total_In --
-   -------------------
-
-   function Read_Total_In (Stream : in Stream_Type) return Count is
-   begin
-      return Total_In (Stream.Reader);
-   end Read_Total_In;
-
-   --------------------
-   -- Read_Total_Out --
-   --------------------
-
-   function Read_Total_Out (Stream : in Stream_Type) return Count is
-   begin
-      return Total_Out (Stream.Reader);
-   end Read_Total_Out;
-
-   -----------
-   -- Write --
-   -----------
-
-   procedure Write
-     (Stream : in out Stream_Type;
-      Item   : in     Stream_Element_Array)
-   is
-
-      procedure Write (Item : in Stream_Element_Array);
-
-      -----------
-      -- Write --
-      -----------
-
-      procedure Write (Item : in Stream_Element_Array) is
-      begin
-         Ada.Streams.Write (Stream.Back.all, Item);
-      end Write;
-
-      procedure Write is new ZLib.Write
-         (Write       => Write,
-          Buffer_Size => Stream.Buffer_Size);
-
-   begin
-      Write (Stream.Writer, Item, No_Flush);
-   end Write;
-
-   --------------------
-   -- Write_Total_In --
-   --------------------
-
-   function Write_Total_In (Stream : in Stream_Type) return Count is
-   begin
-      return Total_In (Stream.Writer);
-   end Write_Total_In;
-
-   ---------------------
-   -- Write_Total_Out --
-   ---------------------
-
-   function Write_Total_Out (Stream : in Stream_Type) return Count is
-   begin
-      return Total_Out (Stream.Writer);
-   end Write_Total_Out;
-
-end ZLib.Streams;
diff -Nbaur gcc-4.8.1/zlib/contrib/ada/zlib-streams.ads gcc-4.8.1-ppc/zlib/contrib/ada/zlib-streams.ads
--- gcc-4.8.1/zlib/contrib/ada/zlib-streams.ads	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/ada/zlib-streams.ads	1970-01-01 01:00:00.000000000 +0100
@@ -1,114 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: zlib-streams.ads,v 1.12 2004/05/31 10:53:40 vagul Exp $
-
-package ZLib.Streams is
-
-   type Stream_Mode is (In_Stream, Out_Stream, Duplex);
-
-   type Stream_Access is access all Ada.Streams.Root_Stream_Type'Class;
-
-   type Stream_Type is
-      new Ada.Streams.Root_Stream_Type with private;
-
-   procedure Read
-     (Stream : in out Stream_Type;
-      Item   :    out Ada.Streams.Stream_Element_Array;
-      Last   :    out Ada.Streams.Stream_Element_Offset);
-
-   procedure Write
-     (Stream : in out Stream_Type;
-      Item   : in     Ada.Streams.Stream_Element_Array);
-
-   procedure Flush
-     (Stream : in out Stream_Type;
-      Mode   : in     Flush_Mode := Sync_Flush);
-   --  Flush the written data to the back stream,
-   --  all data placed to the compressor is flushing to the Back stream.
-   --  Should not be used untill necessary, becouse it is decreasing
-   --  compression.
-
-   function Read_Total_In (Stream : in Stream_Type) return Count;
-   pragma Inline (Read_Total_In);
-   --  Return total number of bytes read from back stream so far.
-
-   function Read_Total_Out (Stream : in Stream_Type) return Count;
-   pragma Inline (Read_Total_Out);
-   --  Return total number of bytes read so far.
-
-   function Write_Total_In (Stream : in Stream_Type) return Count;
-   pragma Inline (Write_Total_In);
-   --  Return total number of bytes written so far.
-
-   function Write_Total_Out (Stream : in Stream_Type) return Count;
-   pragma Inline (Write_Total_Out);
-   --  Return total number of bytes written to the back stream.
-
-   procedure Create
-     (Stream            :    out Stream_Type;
-      Mode              : in     Stream_Mode;
-      Back              : in     Stream_Access;
-      Back_Compressed   : in     Boolean;
-      Level             : in     Compression_Level := Default_Compression;
-      Strategy          : in     Strategy_Type     := Default_Strategy;
-      Header            : in     Header_Type       := Default;
-      Read_Buffer_Size  : in     Ada.Streams.Stream_Element_Offset
-                                    := Default_Buffer_Size;
-      Write_Buffer_Size : in     Ada.Streams.Stream_Element_Offset
-                                    := Default_Buffer_Size);
-   --  Create the Comression/Decompression stream.
-   --  If mode is In_Stream then Write operation is disabled.
-   --  If mode is Out_Stream then Read operation is disabled.
-
-   --  If Back_Compressed is true then
-   --  Data written to the Stream is compressing to the Back stream
-   --  and data read from the Stream is decompressed data from the Back stream.
-
-   --  If Back_Compressed is false then
-   --  Data written to the Stream is decompressing to the Back stream
-   --  and data read from the Stream is compressed data from the Back stream.
-
-   --  !!! When the Need_Header is False ZLib-Ada is using undocumented
-   --  ZLib 1.1.4 functionality to do not create/wait for ZLib headers.
-
-   function Is_Open (Stream : Stream_Type) return Boolean;
-
-   procedure Close (Stream : in out Stream_Type);
-
-private
-
-   use Ada.Streams;
-
-   type Buffer_Access is access all Stream_Element_Array;
-
-   type Stream_Type
-     is new Root_Stream_Type with
-   record
-      Mode       : Stream_Mode;
-
-      Buffer     : Buffer_Access;
-      Rest_First : Stream_Element_Offset;
-      Rest_Last  : Stream_Element_Offset;
-      --  Buffer for Read operation.
-      --  We need to have this buffer in the record
-      --  becouse not all read data from back stream
-      --  could be processed during the read operation.
-
-      Buffer_Size : Stream_Element_Offset;
-      --  Buffer size for write operation.
-      --  We do not need to have this buffer
-      --  in the record becouse all data could be
-      --  processed in the write operation.
-
-      Back       : Stream_Access;
-      Reader     : Filter_Type;
-      Writer     : Filter_Type;
-   end record;
-
-end ZLib.Streams;
diff -Nbaur gcc-4.8.1/zlib/contrib/ada/zlib-thin.adb gcc-4.8.1-ppc/zlib/contrib/ada/zlib-thin.adb
--- gcc-4.8.1/zlib/contrib/ada/zlib-thin.adb	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/ada/zlib-thin.adb	1970-01-01 01:00:00.000000000 +0100
@@ -1,141 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: zlib-thin.adb,v 1.8 2003/12/14 18:27:31 vagul Exp $
-
-package body ZLib.Thin is
-
-   ZLIB_VERSION  : constant Chars_Ptr := zlibVersion;
-
-   Z_Stream_Size : constant Int := Z_Stream'Size / System.Storage_Unit;
-
-   --------------
-   -- Avail_In --
-   --------------
-
-   function Avail_In (Strm : in Z_Stream) return UInt is
-   begin
-      return Strm.Avail_In;
-   end Avail_In;
-
-   ---------------
-   -- Avail_Out --
-   ---------------
-
-   function Avail_Out (Strm : in Z_Stream) return UInt is
-   begin
-      return Strm.Avail_Out;
-   end Avail_Out;
-
-   ------------------
-   -- Deflate_Init --
-   ------------------
-
-   function Deflate_Init
-     (strm       : Z_Streamp;
-      level      : Int;
-      method     : Int;
-      windowBits : Int;
-      memLevel   : Int;
-      strategy   : Int)
-      return       Int is
-   begin
-      return deflateInit2
-               (strm,
-                level,
-                method,
-                windowBits,
-                memLevel,
-                strategy,
-                ZLIB_VERSION,
-                Z_Stream_Size);
-   end Deflate_Init;
-
-   ------------------
-   -- Inflate_Init --
-   ------------------
-
-   function Inflate_Init (strm : Z_Streamp; windowBits : Int) return Int is
-   begin
-      return inflateInit2 (strm, windowBits, ZLIB_VERSION, Z_Stream_Size);
-   end Inflate_Init;
-
-   ------------------------
-   -- Last_Error_Message --
-   ------------------------
-
-   function Last_Error_Message (Strm : in Z_Stream) return String is
-      use Interfaces.C.Strings;
-   begin
-      if Strm.msg = Null_Ptr then
-         return "";
-      else
-         return Value (Strm.msg);
-      end if;
-   end Last_Error_Message;
-
-   ------------
-   -- Set_In --
-   ------------
-
-   procedure Set_In
-     (Strm   : in out Z_Stream;
-      Buffer : in     Voidp;
-      Size   : in     UInt) is
-   begin
-      Strm.Next_In  := Buffer;
-      Strm.Avail_In := Size;
-   end Set_In;
-
-   ------------------
-   -- Set_Mem_Func --
-   ------------------
-
-   procedure Set_Mem_Func
-     (Strm   : in out Z_Stream;
-      Opaque : in     Voidp;
-      Alloc  : in     alloc_func;
-      Free   : in     free_func) is
-   begin
-      Strm.opaque := Opaque;
-      Strm.zalloc := Alloc;
-      Strm.zfree  := Free;
-   end Set_Mem_Func;
-
-   -------------
-   -- Set_Out --
-   -------------
-
-   procedure Set_Out
-     (Strm   : in out Z_Stream;
-      Buffer : in     Voidp;
-      Size   : in     UInt) is
-   begin
-      Strm.Next_Out  := Buffer;
-      Strm.Avail_Out := Size;
-   end Set_Out;
-
-   --------------
-   -- Total_In --
-   --------------
-
-   function Total_In (Strm : in Z_Stream) return ULong is
-   begin
-      return Strm.Total_In;
-   end Total_In;
-
-   ---------------
-   -- Total_Out --
-   ---------------
-
-   function Total_Out (Strm : in Z_Stream) return ULong is
-   begin
-      return Strm.Total_Out;
-   end Total_Out;
-
-end ZLib.Thin;
diff -Nbaur gcc-4.8.1/zlib/contrib/ada/zlib-thin.ads gcc-4.8.1-ppc/zlib/contrib/ada/zlib-thin.ads
--- gcc-4.8.1/zlib/contrib/ada/zlib-thin.ads	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/ada/zlib-thin.ads	1970-01-01 01:00:00.000000000 +0100
@@ -1,450 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: zlib-thin.ads,v 1.11 2004/07/23 06:33:11 vagul Exp $
-
-with Interfaces.C.Strings;
-
-with System;
-
-private package ZLib.Thin is
-
-   --  From zconf.h
-
-   MAX_MEM_LEVEL : constant := 9;         --  zconf.h:105
-                                          --  zconf.h:105
-   MAX_WBITS : constant := 15;      --  zconf.h:115
-                                    --  32K LZ77 window
-                                    --  zconf.h:115
-   SEEK_SET : constant := 8#0000#;  --  zconf.h:244
-                                    --  Seek from beginning of file.
-                                    --  zconf.h:244
-   SEEK_CUR : constant := 1;        --  zconf.h:245
-                                    --  Seek from current position.
-                                    --  zconf.h:245
-   SEEK_END : constant := 2;        --  zconf.h:246
-                                    --  Set file pointer to EOF plus "offset"
-                                    --  zconf.h:246
-
-   type Byte is new Interfaces.C.unsigned_char; --  8 bits
-                                                --  zconf.h:214
-   type UInt is new Interfaces.C.unsigned;      --  16 bits or more
-                                                --  zconf.h:216
-   type Int is new Interfaces.C.int;
-
-   type ULong is new Interfaces.C.unsigned_long;     --  32 bits or more
-                                                     --  zconf.h:217
-   subtype Chars_Ptr is Interfaces.C.Strings.chars_ptr;
-
-   type ULong_Access is access ULong;
-   type Int_Access is access Int;
-
-   subtype Voidp is System.Address;            --  zconf.h:232
-
-   subtype Byte_Access is Voidp;
-
-   Nul : constant Voidp := System.Null_Address;
-   --  end from zconf
-
-   Z_NO_FLUSH : constant := 8#0000#;   --  zlib.h:125
-                                       --  zlib.h:125
-   Z_PARTIAL_FLUSH : constant := 1;       --  zlib.h:126
-                                          --  will be removed, use
-                                          --  Z_SYNC_FLUSH instead
-                                          --  zlib.h:126
-   Z_SYNC_FLUSH : constant := 2;       --  zlib.h:127
-                                       --  zlib.h:127
-   Z_FULL_FLUSH : constant := 3;       --  zlib.h:128
-                                       --  zlib.h:128
-   Z_FINISH : constant := 4;        --  zlib.h:129
-                                    --  zlib.h:129
-   Z_OK : constant := 8#0000#;   --  zlib.h:132
-                                 --  zlib.h:132
-   Z_STREAM_END : constant := 1;       --  zlib.h:133
-                                       --  zlib.h:133
-   Z_NEED_DICT : constant := 2;        --  zlib.h:134
-                                       --  zlib.h:134
-   Z_ERRNO : constant := -1;        --  zlib.h:135
-                                    --  zlib.h:135
-   Z_STREAM_ERROR : constant := -2;       --  zlib.h:136
-                                          --  zlib.h:136
-   Z_DATA_ERROR : constant := -3;      --  zlib.h:137
-                                       --  zlib.h:137
-   Z_MEM_ERROR : constant := -4;       --  zlib.h:138
-                                       --  zlib.h:138
-   Z_BUF_ERROR : constant := -5;       --  zlib.h:139
-                                       --  zlib.h:139
-   Z_VERSION_ERROR : constant := -6;      --  zlib.h:140
-                                          --  zlib.h:140
-   Z_NO_COMPRESSION : constant := 8#0000#;   --  zlib.h:145
-                                             --  zlib.h:145
-   Z_BEST_SPEED : constant := 1;       --  zlib.h:146
-                                       --  zlib.h:146
-   Z_BEST_COMPRESSION : constant := 9;       --  zlib.h:147
-                                             --  zlib.h:147
-   Z_DEFAULT_COMPRESSION : constant := -1;      --  zlib.h:148
-                                                --  zlib.h:148
-   Z_FILTERED : constant := 1;      --  zlib.h:151
-                                    --  zlib.h:151
-   Z_HUFFMAN_ONLY : constant := 2;        --  zlib.h:152
-                                          --  zlib.h:152
-   Z_DEFAULT_STRATEGY : constant := 8#0000#; --  zlib.h:153
-                                             --  zlib.h:153
-   Z_BINARY : constant := 8#0000#;  --  zlib.h:156
-                                    --  zlib.h:156
-   Z_ASCII : constant := 1;      --  zlib.h:157
-                                 --  zlib.h:157
-   Z_UNKNOWN : constant := 2;       --  zlib.h:158
-                                    --  zlib.h:158
-   Z_DEFLATED : constant := 8;      --  zlib.h:161
-                                    --  zlib.h:161
-   Z_NULL : constant := 8#0000#; --  zlib.h:164
-                                 --  for initializing zalloc, zfree, opaque
-                                 --  zlib.h:164
-   type gzFile is new Voidp;                  --  zlib.h:646
-
-   type Z_Stream is private;
-
-   type Z_Streamp is access all Z_Stream;     --  zlib.h:89
-
-   type alloc_func is access function
-     (Opaque : Voidp;
-      Items  : UInt;
-      Size   : UInt)
-      return Voidp; --  zlib.h:63
-
-   type free_func is access procedure (opaque : Voidp; address : Voidp);
-
-   function zlibVersion return Chars_Ptr;
-
-   function Deflate (strm : Z_Streamp; flush : Int) return Int;
-
-   function DeflateEnd (strm : Z_Streamp) return Int;
-
-   function Inflate (strm : Z_Streamp; flush : Int) return Int;
-
-   function InflateEnd (strm : Z_Streamp) return Int;
-
-   function deflateSetDictionary
-     (strm       : Z_Streamp;
-      dictionary : Byte_Access;
-      dictLength : UInt)
-      return       Int;
-
-   function deflateCopy (dest : Z_Streamp; source : Z_Streamp) return Int;
-   --  zlib.h:478
-
-   function deflateReset (strm : Z_Streamp) return Int; -- zlib.h:495
-
-   function deflateParams
-     (strm     : Z_Streamp;
-      level    : Int;
-      strategy : Int)
-      return     Int;       -- zlib.h:506
-
-   function inflateSetDictionary
-     (strm       : Z_Streamp;
-      dictionary : Byte_Access;
-      dictLength : UInt)
-      return       Int; --  zlib.h:548
-
-   function inflateSync (strm : Z_Streamp) return Int;  --  zlib.h:565
-
-   function inflateReset (strm : Z_Streamp) return Int; --  zlib.h:580
-
-   function compress
-     (dest      : Byte_Access;
-      destLen   : ULong_Access;
-      source    : Byte_Access;
-      sourceLen : ULong)
-      return      Int;           -- zlib.h:601
-
-   function compress2
-     (dest      : Byte_Access;
-      destLen   : ULong_Access;
-      source    : Byte_Access;
-      sourceLen : ULong;
-      level     : Int)
-      return      Int;          -- zlib.h:615
-
-   function uncompress
-     (dest      : Byte_Access;
-      destLen   : ULong_Access;
-      source    : Byte_Access;
-      sourceLen : ULong)
-      return      Int;
-
-   function gzopen (path : Chars_Ptr; mode : Chars_Ptr) return gzFile;
-
-   function gzdopen (fd : Int; mode : Chars_Ptr) return gzFile;
-
-   function gzsetparams
-     (file     : gzFile;
-      level    : Int;
-      strategy : Int)
-      return     Int;
-
-   function gzread
-     (file : gzFile;
-      buf  : Voidp;
-      len  : UInt)
-      return Int;
-
-   function gzwrite
-     (file : in gzFile;
-      buf  : in Voidp;
-      len  : in UInt)
-      return Int;
-
-   function gzprintf (file : in gzFile; format : in Chars_Ptr) return Int;
-
-   function gzputs (file : in gzFile; s : in Chars_Ptr) return Int;
-
-   function gzgets
-     (file : gzFile;
-      buf  : Chars_Ptr;
-      len  : Int)
-      return Chars_Ptr;
-
-   function gzputc (file : gzFile; char : Int) return Int;
-
-   function gzgetc (file : gzFile) return Int;
-
-   function gzflush (file : gzFile; flush : Int) return Int;
-
-   function gzseek
-     (file   : gzFile;
-      offset : Int;
-      whence : Int)
-      return   Int;
-
-   function gzrewind (file : gzFile) return Int;
-
-   function gztell (file : gzFile) return Int;
-
-   function gzeof (file : gzFile) return Int;
-
-   function gzclose (file : gzFile) return Int;
-
-   function gzerror (file : gzFile; errnum : Int_Access) return Chars_Ptr;
-
-   function adler32
-     (adler : ULong;
-      buf   : Byte_Access;
-      len   : UInt)
-      return  ULong;
-
-   function crc32
-     (crc  : ULong;
-      buf  : Byte_Access;
-      len  : UInt)
-      return ULong;
-
-   function deflateInit
-     (strm        : Z_Streamp;
-      level       : Int;
-      version     : Chars_Ptr;
-      stream_size : Int)
-      return        Int;
-
-   function deflateInit2
-     (strm        : Z_Streamp;
-      level       : Int;
-      method      : Int;
-      windowBits  : Int;
-      memLevel    : Int;
-      strategy    : Int;
-      version     : Chars_Ptr;
-      stream_size : Int)
-      return        Int;
-
-   function Deflate_Init
-     (strm       : Z_Streamp;
-      level      : Int;
-      method     : Int;
-      windowBits : Int;
-      memLevel   : Int;
-      strategy   : Int)
-      return       Int;
-   pragma Inline (Deflate_Init);
-
-   function inflateInit
-     (strm        : Z_Streamp;
-      version     : Chars_Ptr;
-      stream_size : Int)
-      return        Int;
-
-   function inflateInit2
-     (strm        : in Z_Streamp;
-      windowBits  : in Int;
-      version     : in Chars_Ptr;
-      stream_size : in Int)
-      return      Int;
-
-   function inflateBackInit
-     (strm        : in Z_Streamp;
-      windowBits  : in Int;
-      window      : in Byte_Access;
-      version     : in Chars_Ptr;
-      stream_size : in Int)
-      return      Int;
-   --  Size of window have to be 2**windowBits.
-
-   function Inflate_Init (strm : Z_Streamp; windowBits : Int) return Int;
-   pragma Inline (Inflate_Init);
-
-   function zError (err : Int) return Chars_Ptr;
-
-   function inflateSyncPoint (z : Z_Streamp) return Int;
-
-   function get_crc_table return ULong_Access;
-
-   --  Interface to the available fields of the z_stream structure.
-   --  The application must update next_in and avail_in when avail_in has
-   --  dropped to zero. It must update next_out and avail_out when avail_out
-   --  has dropped to zero. The application must initialize zalloc, zfree and
-   --  opaque before calling the init function.
-
-   procedure Set_In
-     (Strm   : in out Z_Stream;
-      Buffer : in Voidp;
-      Size   : in UInt);
-   pragma Inline (Set_In);
-
-   procedure Set_Out
-     (Strm   : in out Z_Stream;
-      Buffer : in Voidp;
-      Size   : in UInt);
-   pragma Inline (Set_Out);
-
-   procedure Set_Mem_Func
-     (Strm   : in out Z_Stream;
-      Opaque : in Voidp;
-      Alloc  : in alloc_func;
-      Free   : in free_func);
-   pragma Inline (Set_Mem_Func);
-
-   function Last_Error_Message (Strm : in Z_Stream) return String;
-   pragma Inline (Last_Error_Message);
-
-   function Avail_Out (Strm : in Z_Stream) return UInt;
-   pragma Inline (Avail_Out);
-
-   function Avail_In (Strm : in Z_Stream) return UInt;
-   pragma Inline (Avail_In);
-
-   function Total_In (Strm : in Z_Stream) return ULong;
-   pragma Inline (Total_In);
-
-   function Total_Out (Strm : in Z_Stream) return ULong;
-   pragma Inline (Total_Out);
-
-   function inflateCopy
-     (dest   : in Z_Streamp;
-      Source : in Z_Streamp)
-      return Int;
-
-   function compressBound (Source_Len : in ULong) return ULong;
-
-   function deflateBound
-     (Strm       : in Z_Streamp;
-      Source_Len : in ULong)
-      return     ULong;
-
-   function gzungetc (C : in Int; File : in  gzFile) return Int;
-
-   function zlibCompileFlags return ULong;
-
-private
-
-   type Z_Stream is record            -- zlib.h:68
-      Next_In   : Voidp      := Nul;  -- next input byte
-      Avail_In  : UInt       := 0;    -- number of bytes available at next_in
-      Total_In  : ULong      := 0;    -- total nb of input bytes read so far
-      Next_Out  : Voidp      := Nul;  -- next output byte should be put there
-      Avail_Out : UInt       := 0;    -- remaining free space at next_out
-      Total_Out : ULong      := 0;    -- total nb of bytes output so far
-      msg       : Chars_Ptr;          -- last error message, NULL if no error
-      state     : Voidp;              -- not visible by applications
-      zalloc    : alloc_func := null; -- used to allocate the internal state
-      zfree     : free_func  := null; -- used to free the internal state
-      opaque    : Voidp;              -- private data object passed to
-                                      --  zalloc and zfree
-      data_type : Int;                -- best guess about the data type:
-                                      --  ascii or binary
-      adler     : ULong;              -- adler32 value of the uncompressed
-                                      --  data
-      reserved  : ULong;              -- reserved for future use
-   end record;
-
-   pragma Convention (C, Z_Stream);
-
-   pragma Import (C, zlibVersion, "zlibVersion");
-   pragma Import (C, Deflate, "deflate");
-   pragma Import (C, DeflateEnd, "deflateEnd");
-   pragma Import (C, Inflate, "inflate");
-   pragma Import (C, InflateEnd, "inflateEnd");
-   pragma Import (C, deflateSetDictionary, "deflateSetDictionary");
-   pragma Import (C, deflateCopy, "deflateCopy");
-   pragma Import (C, deflateReset, "deflateReset");
-   pragma Import (C, deflateParams, "deflateParams");
-   pragma Import (C, inflateSetDictionary, "inflateSetDictionary");
-   pragma Import (C, inflateSync, "inflateSync");
-   pragma Import (C, inflateReset, "inflateReset");
-   pragma Import (C, compress, "compress");
-   pragma Import (C, compress2, "compress2");
-   pragma Import (C, uncompress, "uncompress");
-   pragma Import (C, gzopen, "gzopen");
-   pragma Import (C, gzdopen, "gzdopen");
-   pragma Import (C, gzsetparams, "gzsetparams");
-   pragma Import (C, gzread, "gzread");
-   pragma Import (C, gzwrite, "gzwrite");
-   pragma Import (C, gzprintf, "gzprintf");
-   pragma Import (C, gzputs, "gzputs");
-   pragma Import (C, gzgets, "gzgets");
-   pragma Import (C, gzputc, "gzputc");
-   pragma Import (C, gzgetc, "gzgetc");
-   pragma Import (C, gzflush, "gzflush");
-   pragma Import (C, gzseek, "gzseek");
-   pragma Import (C, gzrewind, "gzrewind");
-   pragma Import (C, gztell, "gztell");
-   pragma Import (C, gzeof, "gzeof");
-   pragma Import (C, gzclose, "gzclose");
-   pragma Import (C, gzerror, "gzerror");
-   pragma Import (C, adler32, "adler32");
-   pragma Import (C, crc32, "crc32");
-   pragma Import (C, deflateInit, "deflateInit_");
-   pragma Import (C, inflateInit, "inflateInit_");
-   pragma Import (C, deflateInit2, "deflateInit2_");
-   pragma Import (C, inflateInit2, "inflateInit2_");
-   pragma Import (C, zError, "zError");
-   pragma Import (C, inflateSyncPoint, "inflateSyncPoint");
-   pragma Import (C, get_crc_table, "get_crc_table");
-
-   --  since zlib 1.2.0:
-
-   pragma Import (C, inflateCopy, "inflateCopy");
-   pragma Import (C, compressBound, "compressBound");
-   pragma Import (C, deflateBound, "deflateBound");
-   pragma Import (C, gzungetc, "gzungetc");
-   pragma Import (C, zlibCompileFlags, "zlibCompileFlags");
-
-   pragma Import (C, inflateBackInit, "inflateBackInit_");
-
-   --  I stopped binding the inflateBack routines, becouse realize that
-   --  it does not support zlib and gzip headers for now, and have no
-   --  symmetric deflateBack routines.
-   --  ZLib-Ada is symmetric regarding deflate/inflate data transformation
-   --  and has a similar generic callback interface for the
-   --  deflate/inflate transformation based on the regular Deflate/Inflate
-   --  routines.
-
-   --  pragma Import (C, inflateBack, "inflateBack");
-   --  pragma Import (C, inflateBackEnd, "inflateBackEnd");
-
-end ZLib.Thin;
diff -Nbaur gcc-4.8.1/zlib/contrib/amd64/amd64-match.S gcc-4.8.1-ppc/zlib/contrib/amd64/amd64-match.S
--- gcc-4.8.1/zlib/contrib/amd64/amd64-match.S	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/amd64/amd64-match.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,452 +0,0 @@
-/*
- * match.S -- optimized version of longest_match()
- * based on the similar work by Gilles Vollant, and Brian Raiter, written 1998
- *
- * This is free software; you can redistribute it and/or modify it
- * under the terms of the BSD License. Use by owners of Che Guevarra
- * parafernalia is prohibited, where possible, and highly discouraged
- * elsewhere.
- */
-
-#ifndef NO_UNDERLINE
-#	define	match_init	_match_init
-#	define	longest_match	_longest_match
-#endif
-
-#define	scanend		ebx
-#define	scanendw	bx
-#define	chainlenwmask	edx /* high word: current chain len low word: s->wmask */
-#define	curmatch	rsi
-#define	curmatchd	esi
-#define	windowbestlen	r8
-#define	scanalign	r9
-#define	scanalignd	r9d
-#define	window		r10
-#define	bestlen		r11
-#define	bestlend	r11d
-#define	scanstart	r12d
-#define	scanstartw	r12w
-#define scan		r13
-#define nicematch	r14d
-#define	limit		r15
-#define	limitd		r15d
-#define prev		rcx
-
-/*
- * The 258 is a "magic number, not a parameter -- changing it
- * breaks the hell loose
- */
-#define	MAX_MATCH	(258)
-#define	MIN_MATCH	(3)
-#define	MIN_LOOKAHEAD	(MAX_MATCH + MIN_MATCH + 1)
-#define	MAX_MATCH_8	((MAX_MATCH + 7) & ~7)
-
-/* stack frame offsets */
-#define	LocalVarsSize	(112)
-#define _chainlenwmask	( 8-LocalVarsSize)(%rsp)
-#define _windowbestlen	(16-LocalVarsSize)(%rsp)
-#define save_r14        (24-LocalVarsSize)(%rsp)
-#define save_rsi        (32-LocalVarsSize)(%rsp)
-#define save_rbx        (40-LocalVarsSize)(%rsp)
-#define save_r12        (56-LocalVarsSize)(%rsp)
-#define save_r13        (64-LocalVarsSize)(%rsp)
-#define save_r15        (80-LocalVarsSize)(%rsp)
-
-
-.globl	match_init, longest_match
-
-/*
- * On AMD64 the first argument of a function (in our case -- the pointer to
- * deflate_state structure) is passed in %rdi, hence our offsets below are
- * all off of that.
- */
-
-/* you can check the structure offset by running
-
-#include <stdlib.h>
-#include <stdio.h>
-#include "deflate.h"
-
-void print_depl()
-{
-deflate_state ds;
-deflate_state *s=&ds;
-printf("size pointer=%u\n",(int)sizeof(void*));
-
-printf("#define dsWSize         (%3u)(%%rdi)\n",(int)(((char*)&(s->w_size))-((char*)s)));
-printf("#define dsWMask         (%3u)(%%rdi)\n",(int)(((char*)&(s->w_mask))-((char*)s)));
-printf("#define dsWindow        (%3u)(%%rdi)\n",(int)(((char*)&(s->window))-((char*)s)));
-printf("#define dsPrev          (%3u)(%%rdi)\n",(int)(((char*)&(s->prev))-((char*)s)));
-printf("#define dsMatchLen      (%3u)(%%rdi)\n",(int)(((char*)&(s->match_length))-((char*)s)));
-printf("#define dsPrevMatch     (%3u)(%%rdi)\n",(int)(((char*)&(s->prev_match))-((char*)s)));
-printf("#define dsStrStart      (%3u)(%%rdi)\n",(int)(((char*)&(s->strstart))-((char*)s)));
-printf("#define dsMatchStart    (%3u)(%%rdi)\n",(int)(((char*)&(s->match_start))-((char*)s)));
-printf("#define dsLookahead     (%3u)(%%rdi)\n",(int)(((char*)&(s->lookahead))-((char*)s)));
-printf("#define dsPrevLen       (%3u)(%%rdi)\n",(int)(((char*)&(s->prev_length))-((char*)s)));
-printf("#define dsMaxChainLen   (%3u)(%%rdi)\n",(int)(((char*)&(s->max_chain_length))-((char*)s)));
-printf("#define dsGoodMatch     (%3u)(%%rdi)\n",(int)(((char*)&(s->good_match))-((char*)s)));
-printf("#define dsNiceMatch     (%3u)(%%rdi)\n",(int)(((char*)&(s->nice_match))-((char*)s)));
-}
-
-*/
-
-
-/*
-  to compile for XCode 3.2 on MacOSX x86_64
-  - run "gcc -g -c -DXCODE_MAC_X64_STRUCTURE amd64-match.S"
- */
-
-
-#ifndef CURRENT_LINX_XCODE_MAC_X64_STRUCTURE
-#define dsWSize		( 68)(%rdi)
-#define dsWMask		( 76)(%rdi)
-#define dsWindow	( 80)(%rdi)
-#define dsPrev		( 96)(%rdi)
-#define dsMatchLen	(144)(%rdi)
-#define dsPrevMatch	(148)(%rdi)
-#define dsStrStart	(156)(%rdi)
-#define dsMatchStart	(160)(%rdi)
-#define dsLookahead	(164)(%rdi)
-#define dsPrevLen	(168)(%rdi)
-#define dsMaxChainLen	(172)(%rdi)
-#define dsGoodMatch	(188)(%rdi)
-#define dsNiceMatch	(192)(%rdi)
-
-#else 
-
-#ifndef STRUCT_OFFSET
-#	define STRUCT_OFFSET	(0)
-#endif
-
-
-#define dsWSize		( 56 + STRUCT_OFFSET)(%rdi)
-#define dsWMask		( 64 + STRUCT_OFFSET)(%rdi)
-#define dsWindow	( 72 + STRUCT_OFFSET)(%rdi)
-#define dsPrev		( 88 + STRUCT_OFFSET)(%rdi)
-#define dsMatchLen	(136 + STRUCT_OFFSET)(%rdi)
-#define dsPrevMatch	(140 + STRUCT_OFFSET)(%rdi)
-#define dsStrStart	(148 + STRUCT_OFFSET)(%rdi)
-#define dsMatchStart	(152 + STRUCT_OFFSET)(%rdi)
-#define dsLookahead	(156 + STRUCT_OFFSET)(%rdi)
-#define dsPrevLen	(160 + STRUCT_OFFSET)(%rdi)
-#define dsMaxChainLen	(164 + STRUCT_OFFSET)(%rdi)
-#define dsGoodMatch	(180 + STRUCT_OFFSET)(%rdi)
-#define dsNiceMatch	(184 + STRUCT_OFFSET)(%rdi)
-
-#endif
-
-
-
-
-.text
-
-/* uInt longest_match(deflate_state *deflatestate, IPos curmatch) */
-
-longest_match:
-/*
- * Retrieve the function arguments. %curmatch will hold cur_match
- * throughout the entire function (passed via rsi on amd64).
- * rdi will hold the pointer to the deflate_state (first arg on amd64)
- */
-		mov     %rsi, save_rsi
-		mov     %rbx, save_rbx
-		mov	%r12, save_r12
-		mov     %r13, save_r13
-		mov     %r14, save_r14
-		mov     %r15, save_r15
-
-/* uInt wmask = s->w_mask;						*/
-/* unsigned chain_length = s->max_chain_length;				*/
-/* if (s->prev_length >= s->good_match) {				*/
-/*     chain_length >>= 2;						*/
-/* }									*/
-
-		movl	dsPrevLen, %eax
-		movl	dsGoodMatch, %ebx
-		cmpl	%ebx, %eax
-		movl	dsWMask, %eax
-		movl	dsMaxChainLen, %chainlenwmask
-		jl	LastMatchGood
-		shrl	$2, %chainlenwmask
-LastMatchGood:
-
-/* chainlen is decremented once beforehand so that the function can	*/
-/* use the sign flag instead of the zero flag for the exit test.	*/
-/* It is then shifted into the high word, to make room for the wmask	*/
-/* value, which it will always accompany.				*/
-
-		decl	%chainlenwmask
-		shll	$16, %chainlenwmask
-		orl	%eax, %chainlenwmask
-
-/* if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;	*/
-
-		movl	dsNiceMatch, %eax
-		movl	dsLookahead, %ebx
-		cmpl	%eax, %ebx
-		jl	LookaheadLess
-		movl	%eax, %ebx
-LookaheadLess:	movl	%ebx, %nicematch
-
-/* register Bytef *scan = s->window + s->strstart;			*/
-
-		mov	dsWindow, %window
-		movl	dsStrStart, %limitd
-		lea	(%limit, %window), %scan
-
-/* Determine how many bytes the scan ptr is off from being		*/
-/* dword-aligned.							*/
-
-		mov	%scan, %scanalign
-		negl	%scanalignd
-		andl	$3, %scanalignd
-
-/* IPos limit = s->strstart > (IPos)MAX_DIST(s) ?			*/
-/*     s->strstart - (IPos)MAX_DIST(s) : NIL;				*/
-
-		movl	dsWSize, %eax
-		subl	$MIN_LOOKAHEAD, %eax
-		xorl	%ecx, %ecx
-		subl	%eax, %limitd
-		cmovng	%ecx, %limitd
-
-/* int best_len = s->prev_length;					*/
-
-		movl	dsPrevLen, %bestlend
-
-/* Store the sum of s->window + best_len in %windowbestlen locally, and in memory.	*/
-
-		lea	(%window, %bestlen), %windowbestlen
-		mov	%windowbestlen, _windowbestlen
-
-/* register ush scan_start = *(ushf*)scan;				*/
-/* register ush scan_end   = *(ushf*)(scan+best_len-1);			*/
-/* Posf *prev = s->prev;						*/
-
-		movzwl	(%scan), %scanstart
-		movzwl	-1(%scan, %bestlen), %scanend
-		mov	dsPrev, %prev
-
-/* Jump into the main loop.						*/
-
-		movl	%chainlenwmask, _chainlenwmask
-		jmp	LoopEntry
-
-.balign 16
-
-/* do {
- *     match = s->window + cur_match;
- *     if (*(ushf*)(match+best_len-1) != scan_end ||
- *         *(ushf*)match != scan_start) continue;
- *     [...]
- * } while ((cur_match = prev[cur_match & wmask]) > limit
- *          && --chain_length != 0);
- *
- * Here is the inner loop of the function. The function will spend the
- * majority of its time in this loop, and majority of that time will
- * be spent in the first ten instructions.
- */
-LookupLoop:
-		andl	%chainlenwmask, %curmatchd
-		movzwl	(%prev, %curmatch, 2), %curmatchd
-		cmpl	%limitd, %curmatchd
-		jbe	LeaveNow
-		subl	$0x00010000, %chainlenwmask
-		js	LeaveNow
-LoopEntry:	cmpw	-1(%windowbestlen, %curmatch), %scanendw
-		jne	LookupLoop
-		cmpw	%scanstartw, (%window, %curmatch)
-		jne	LookupLoop
-
-/* Store the current value of chainlen.					*/
-		movl	%chainlenwmask, _chainlenwmask
-
-/* %scan is the string under scrutiny, and %prev to the string we	*/
-/* are hoping to match it up with. In actuality, %esi and %edi are	*/
-/* both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and %edx is	*/
-/* initialized to -(MAX_MATCH_8 - scanalign).				*/
-
-		mov	$(-MAX_MATCH_8), %rdx
-		lea	(%curmatch, %window), %windowbestlen
-		lea	MAX_MATCH_8(%windowbestlen, %scanalign), %windowbestlen
-		lea	MAX_MATCH_8(%scan, %scanalign), %prev
-
-/* the prefetching below makes very little difference... */
-		prefetcht1	(%windowbestlen, %rdx)
-		prefetcht1	(%prev, %rdx)
-
-/*
- * Test the strings for equality, 8 bytes at a time. At the end,
- * adjust %rdx so that it is offset to the exact byte that mismatched.
- *
- * It should be confessed that this loop usually does not represent
- * much of the total running time. Replacing it with a more
- * straightforward "rep cmpsb" would not drastically degrade
- * performance -- unrolling it, for example, makes no difference.
- */
-
-#undef USE_SSE	/* works, but is 6-7% slower, than non-SSE... */
-
-LoopCmps:
-#ifdef USE_SSE
-		/* Preload the SSE registers */
-		movdqu	  (%windowbestlen, %rdx), %xmm1
-		movdqu	  (%prev, %rdx), %xmm2
-		pcmpeqb	%xmm2, %xmm1
-		movdqu	16(%windowbestlen, %rdx), %xmm3
-		movdqu	16(%prev, %rdx), %xmm4
-		pcmpeqb	%xmm4, %xmm3
-		movdqu	32(%windowbestlen, %rdx), %xmm5
-		movdqu	32(%prev, %rdx), %xmm6
-		pcmpeqb	%xmm6, %xmm5
-		movdqu	48(%windowbestlen, %rdx), %xmm7
-		movdqu	48(%prev, %rdx), %xmm8
-		pcmpeqb	%xmm8, %xmm7
-
-		/* Check the comparisions' results */
-		pmovmskb %xmm1, %rax
-		notw	%ax
-		bsfw	%ax, %ax
-		jnz	LeaveLoopCmps
-		
-		/* this is the only iteration of the loop with a possibility of having
-		   incremented rdx by 0x108 (each loop iteration add 16*4 = 0x40 
-		   and (0x40*4)+8=0x108 */
-		add	$8, %rdx
-		jz LenMaximum
-		add	$8, %rdx
-
-		
-		pmovmskb %xmm3, %rax
-		notw	%ax
-		bsfw	%ax, %ax
-		jnz	LeaveLoopCmps
-		
-		
-		add	$16, %rdx
-
-
-		pmovmskb %xmm5, %rax
-		notw	%ax
-		bsfw	%ax, %ax
-		jnz	LeaveLoopCmps
-		
-		add	$16, %rdx
-
-
-		pmovmskb %xmm7, %rax
-		notw	%ax
-		bsfw	%ax, %ax
-		jnz	LeaveLoopCmps
-		
-		add	$16, %rdx
-		
-		jmp	LoopCmps
-LeaveLoopCmps:	add	%rax, %rdx
-#else
-		mov	(%windowbestlen, %rdx), %rax
-		xor	(%prev, %rdx), %rax
-		jnz	LeaveLoopCmps
-		
-		mov	8(%windowbestlen, %rdx), %rax
-		xor	8(%prev, %rdx), %rax
-		jnz	LeaveLoopCmps8
-
-		mov	16(%windowbestlen, %rdx), %rax
-		xor	16(%prev, %rdx), %rax
-		jnz	LeaveLoopCmps16
-				
-		add	$24, %rdx
-		jnz	LoopCmps
-		jmp	LenMaximum
-#	if 0
-/*
- * This three-liner is tantalizingly simple, but bsf is a slow instruction,
- * and the complicated alternative down below is quite a bit faster. Sad...
- */
-
-LeaveLoopCmps:	bsf	%rax, %rax /* find the first non-zero bit */
-		shrl	$3, %eax /* divide by 8 to get the byte */
-		add	%rax, %rdx
-#	else
-LeaveLoopCmps16:
-		add	$8, %rdx
-LeaveLoopCmps8:
-		add	$8, %rdx
-LeaveLoopCmps:	testl   $0xFFFFFFFF, %eax /* Check the first 4 bytes */
-		jnz     Check16
-		add     $4, %rdx
-		shr     $32, %rax
-Check16:        testw   $0xFFFF, %ax
-		jnz     LenLower
-		add	$2, %rdx
-		shrl	$16, %eax
-LenLower:	subb	$1, %al
-		adc	$0, %rdx
-#	endif
-#endif
-
-/* Calculate the length of the match. If it is longer than MAX_MATCH,	*/
-/* then automatically accept it as the best possible match and leave.	*/
-
-		lea	(%prev, %rdx), %rax
-		sub	%scan, %rax
-		cmpl	$MAX_MATCH, %eax
-		jge	LenMaximum
-
-/* If the length of the match is not longer than the best match we	*/
-/* have so far, then forget it and return to the lookup loop.		*/
-
-		cmpl	%bestlend, %eax
-		jg	LongerMatch
-		mov	_windowbestlen, %windowbestlen
-		mov	dsPrev, %prev
-		movl	_chainlenwmask, %edx
-		jmp	LookupLoop
-
-/*         s->match_start = cur_match;					*/
-/*         best_len = len;						*/
-/*         if (len >= nice_match) break;				*/
-/*         scan_end = *(ushf*)(scan+best_len-1);			*/
-
-LongerMatch:
-		movl	%eax, %bestlend
-		movl	%curmatchd, dsMatchStart
-		cmpl	%nicematch, %eax
-		jge	LeaveNow
-
-		lea	(%window, %bestlen), %windowbestlen
-		mov	%windowbestlen, _windowbestlen
-
-		movzwl	-1(%scan, %rax), %scanend
-		mov	dsPrev, %prev
-		movl	_chainlenwmask, %chainlenwmask
-		jmp	LookupLoop
-
-/* Accept the current string, with the maximum possible length.		*/
-
-LenMaximum:
-		movl	$MAX_MATCH, %bestlend
-		movl	%curmatchd, dsMatchStart
-
-/* if ((uInt)best_len <= s->lookahead) return (uInt)best_len;		*/
-/* return s->lookahead;							*/
-
-LeaveNow:
-		movl	dsLookahead, %eax
-		cmpl	%eax, %bestlend
-		cmovngl	%bestlend, %eax
-LookaheadRet:
-
-/* Restore the registers and return from whence we came.			*/
-
-	mov	save_rsi, %rsi
-	mov	save_rbx, %rbx
-	mov	save_r12, %r12
-	mov	save_r13, %r13
-	mov	save_r14, %r14
-	mov	save_r15, %r15
-
-	ret
-
-match_init:	ret
diff -Nbaur gcc-4.8.1/zlib/contrib/asm686/match.S gcc-4.8.1-ppc/zlib/contrib/asm686/match.S
--- gcc-4.8.1/zlib/contrib/asm686/match.S	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/asm686/match.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,357 +0,0 @@
-/* match.S -- x86 assembly version of the zlib longest_match() function.
- * Optimized for the Intel 686 chips (PPro and later).
- *
- * Copyright (C) 1998, 2007 Brian Raiter <breadbox@muppetlabs.com>
- *
- * This software is provided 'as-is', without any express or implied
- * warranty.  In no event will the author be held liable for any damages
- * arising from the use of this software.
- *
- * Permission is granted to anyone to use this software for any purpose,
- * including commercial applications, and to alter it and redistribute it
- * freely, subject to the following restrictions:
- *
- * 1. The origin of this software must not be misrepresented; you must not
- *    claim that you wrote the original software. If you use this software
- *    in a product, an acknowledgment in the product documentation would be
- *    appreciated but is not required.
- * 2. Altered source versions must be plainly marked as such, and must not be
- *    misrepresented as being the original software.
- * 3. This notice may not be removed or altered from any source distribution.
- */
-
-#ifndef NO_UNDERLINE
-#define	match_init	_match_init
-#define	longest_match	_longest_match
-#endif
-
-#define	MAX_MATCH	(258)
-#define	MIN_MATCH	(3)
-#define	MIN_LOOKAHEAD	(MAX_MATCH + MIN_MATCH + 1)
-#define	MAX_MATCH_8	((MAX_MATCH + 7) & ~7)
-
-/* stack frame offsets */
-
-#define	chainlenwmask		0	/* high word: current chain len	*/
-					/* low word: s->wmask		*/
-#define	window			4	/* local copy of s->window	*/
-#define	windowbestlen		8	/* s->window + bestlen		*/
-#define	scanstart		16	/* first two bytes of string	*/
-#define	scanend			12	/* last two bytes of string	*/
-#define	scanalign		20	/* dword-misalignment of string	*/
-#define	nicematch		24	/* a good enough match size	*/
-#define	bestlen			28	/* size of best match so far	*/
-#define	scan			32	/* ptr to string wanting match	*/
-
-#define	LocalVarsSize		(36)
-/*	saved ebx		36 */
-/*	saved edi		40 */
-/*	saved esi		44 */
-/*	saved ebp		48 */
-/*	return address		52 */
-#define	deflatestate		56	/* the function arguments	*/
-#define	curmatch		60
-
-/* All the +zlib1222add offsets are due to the addition of fields
- *  in zlib in the deflate_state structure since the asm code was first written
- * (if you compile with zlib 1.0.4 or older, use "zlib1222add equ (-4)").
- * (if you compile with zlib between 1.0.5 and 1.2.2.1, use "zlib1222add equ 0").
- * if you compile with zlib 1.2.2.2 or later , use "zlib1222add equ 8").
- */
-
-#define zlib1222add		(8)
-
-#define	dsWSize			(36+zlib1222add)
-#define	dsWMask			(44+zlib1222add)
-#define	dsWindow		(48+zlib1222add)
-#define	dsPrev			(56+zlib1222add)
-#define	dsMatchLen		(88+zlib1222add)
-#define	dsPrevMatch		(92+zlib1222add)
-#define	dsStrStart		(100+zlib1222add)
-#define	dsMatchStart		(104+zlib1222add)
-#define	dsLookahead		(108+zlib1222add)
-#define	dsPrevLen		(112+zlib1222add)
-#define	dsMaxChainLen		(116+zlib1222add)
-#define	dsGoodMatch		(132+zlib1222add)
-#define	dsNiceMatch		(136+zlib1222add)
-
-
-.file "match.S"
-
-.globl	match_init, longest_match
-
-.text
-
-/* uInt longest_match(deflate_state *deflatestate, IPos curmatch) */
-.cfi_sections	.debug_frame
-
-longest_match:
-
-.cfi_startproc
-/* Save registers that the compiler may be using, and adjust %esp to	*/
-/* make room for our stack frame.					*/
-
-		pushl	%ebp
-		.cfi_def_cfa_offset 8
-		.cfi_offset ebp, -8
-		pushl	%edi
-		.cfi_def_cfa_offset 12
-		pushl	%esi
-		.cfi_def_cfa_offset 16
-		pushl	%ebx
-		.cfi_def_cfa_offset 20
-		subl	$LocalVarsSize, %esp
-		.cfi_def_cfa_offset LocalVarsSize+20
-
-/* Retrieve the function arguments. %ecx will hold cur_match		*/
-/* throughout the entire function. %edx will hold the pointer to the	*/
-/* deflate_state structure during the function's setup (before		*/
-/* entering the main loop).						*/
-
-		movl	deflatestate(%esp), %edx
-		movl	curmatch(%esp), %ecx
-
-/* uInt wmask = s->w_mask;						*/
-/* unsigned chain_length = s->max_chain_length;				*/
-/* if (s->prev_length >= s->good_match) {				*/
-/*     chain_length >>= 2;						*/
-/* }									*/
- 
-		movl	dsPrevLen(%edx), %eax
-		movl	dsGoodMatch(%edx), %ebx
-		cmpl	%ebx, %eax
-		movl	dsWMask(%edx), %eax
-		movl	dsMaxChainLen(%edx), %ebx
-		jl	LastMatchGood
-		shrl	$2, %ebx
-LastMatchGood:
-
-/* chainlen is decremented once beforehand so that the function can	*/
-/* use the sign flag instead of the zero flag for the exit test.	*/
-/* It is then shifted into the high word, to make room for the wmask	*/
-/* value, which it will always accompany.				*/
-
-		decl	%ebx
-		shll	$16, %ebx
-		orl	%eax, %ebx
-		movl	%ebx, chainlenwmask(%esp)
-
-/* if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;	*/
-
-		movl	dsNiceMatch(%edx), %eax
-		movl	dsLookahead(%edx), %ebx
-		cmpl	%eax, %ebx
-		jl	LookaheadLess
-		movl	%eax, %ebx
-LookaheadLess:	movl	%ebx, nicematch(%esp)
-
-/* register Bytef *scan = s->window + s->strstart;			*/
-
-		movl	dsWindow(%edx), %esi
-		movl	%esi, window(%esp)
-		movl	dsStrStart(%edx), %ebp
-		lea	(%esi,%ebp), %edi
-		movl	%edi, scan(%esp)
-
-/* Determine how many bytes the scan ptr is off from being		*/
-/* dword-aligned.							*/
-
-		movl	%edi, %eax
-		negl	%eax
-		andl	$3, %eax
-		movl	%eax, scanalign(%esp)
-
-/* IPos limit = s->strstart > (IPos)MAX_DIST(s) ?			*/
-/*     s->strstart - (IPos)MAX_DIST(s) : NIL;				*/
-
-		movl	dsWSize(%edx), %eax
-		subl	$MIN_LOOKAHEAD, %eax
-		subl	%eax, %ebp
-		jg	LimitPositive
-		xorl	%ebp, %ebp
-LimitPositive:
-
-/* int best_len = s->prev_length;					*/
-
-		movl	dsPrevLen(%edx), %eax
-		movl	%eax, bestlen(%esp)
-
-/* Store the sum of s->window + best_len in %esi locally, and in %esi.	*/
-
-		addl	%eax, %esi
-		movl	%esi, windowbestlen(%esp)
-
-/* register ush scan_start = *(ushf*)scan;				*/
-/* register ush scan_end   = *(ushf*)(scan+best_len-1);			*/
-/* Posf *prev = s->prev;						*/
-
-		movzwl	(%edi), %ebx
-		movl	%ebx, scanstart(%esp)
-		movzwl	-1(%edi,%eax), %ebx
-		movl	%ebx, scanend(%esp)
-		movl	dsPrev(%edx), %edi
-
-/* Jump into the main loop.						*/
-
-		movl	chainlenwmask(%esp), %edx
-		jmp	LoopEntry
-
-.balign 16
-
-/* do {
- *     match = s->window + cur_match;
- *     if (*(ushf*)(match+best_len-1) != scan_end ||
- *         *(ushf*)match != scan_start) continue;
- *     [...]
- * } while ((cur_match = prev[cur_match & wmask]) > limit
- *          && --chain_length != 0);
- *
- * Here is the inner loop of the function. The function will spend the
- * majority of its time in this loop, and majority of that time will
- * be spent in the first ten instructions.
- *
- * Within this loop:
- * %ebx = scanend
- * %ecx = curmatch
- * %edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)
- * %esi = windowbestlen - i.e., (window + bestlen)
- * %edi = prev
- * %ebp = limit
- */
-LookupLoop:
-		andl	%edx, %ecx
-		movzwl	(%edi,%ecx,2), %ecx
-		cmpl	%ebp, %ecx
-		jbe	LeaveNow
-		subl	$0x00010000, %edx
-		js	LeaveNow
-LoopEntry:	movzwl	-1(%esi,%ecx), %eax
-		cmpl	%ebx, %eax
-		jnz	LookupLoop
-		movl	window(%esp), %eax
-		movzwl	(%eax,%ecx), %eax
-		cmpl	scanstart(%esp), %eax
-		jnz	LookupLoop
-
-/* Store the current value of chainlen.					*/
-
-		movl	%edx, chainlenwmask(%esp)
-
-/* Point %edi to the string under scrutiny, and %esi to the string we	*/
-/* are hoping to match it up with. In actuality, %esi and %edi are	*/
-/* both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and %edx is	*/
-/* initialized to -(MAX_MATCH_8 - scanalign).				*/
-
-		movl	window(%esp), %esi
-		movl	scan(%esp), %edi
-		addl	%ecx, %esi
-		movl	scanalign(%esp), %eax
-		movl	$(-MAX_MATCH_8), %edx
-		lea	MAX_MATCH_8(%edi,%eax), %edi
-		lea	MAX_MATCH_8(%esi,%eax), %esi
-
-/* Test the strings for equality, 8 bytes at a time. At the end,
- * adjust %edx so that it is offset to the exact byte that mismatched.
- *
- * We already know at this point that the first three bytes of the
- * strings match each other, and they can be safely passed over before
- * starting the compare loop. So what this code does is skip over 0-3
- * bytes, as much as necessary in order to dword-align the %edi
- * pointer. (%esi will still be misaligned three times out of four.)
- *
- * It should be confessed that this loop usually does not represent
- * much of the total running time. Replacing it with a more
- * straightforward "rep cmpsb" would not drastically degrade
- * performance.
- */
-LoopCmps:
-		movl	(%esi,%edx), %eax
-		xorl	(%edi,%edx), %eax
-		jnz	LeaveLoopCmps
-		movl	4(%esi,%edx), %eax
-		xorl	4(%edi,%edx), %eax
-		jnz	LeaveLoopCmps4
-		addl	$8, %edx
-		jnz	LoopCmps
-		jmp	LenMaximum
-LeaveLoopCmps4:	addl	$4, %edx
-LeaveLoopCmps:	testl	$0x0000FFFF, %eax
-		jnz	LenLower
-		addl	$2, %edx
-		shrl	$16, %eax
-LenLower:	subb	$1, %al
-		adcl	$0, %edx
-
-/* Calculate the length of the match. If it is longer than MAX_MATCH,	*/
-/* then automatically accept it as the best possible match and leave.	*/
-
-		lea	(%edi,%edx), %eax
-		movl	scan(%esp), %edi
-		subl	%edi, %eax
-		cmpl	$MAX_MATCH, %eax
-		jge	LenMaximum
-
-/* If the length of the match is not longer than the best match we	*/
-/* have so far, then forget it and return to the lookup loop.		*/
-
-		movl	deflatestate(%esp), %edx
-		movl	bestlen(%esp), %ebx
-		cmpl	%ebx, %eax
-		jg	LongerMatch
-		movl	windowbestlen(%esp), %esi
-		movl	dsPrev(%edx), %edi
-		movl	scanend(%esp), %ebx
-		movl	chainlenwmask(%esp), %edx
-		jmp	LookupLoop
-
-/*         s->match_start = cur_match;					*/
-/*         best_len = len;						*/
-/*         if (len >= nice_match) break;				*/
-/*         scan_end = *(ushf*)(scan+best_len-1);			*/
-
-LongerMatch:	movl	nicematch(%esp), %ebx
-		movl	%eax, bestlen(%esp)
-		movl	%ecx, dsMatchStart(%edx)
-		cmpl	%ebx, %eax
-		jge	LeaveNow
-		movl	window(%esp), %esi
-		addl	%eax, %esi
-		movl	%esi, windowbestlen(%esp)
-		movzwl	-1(%edi,%eax), %ebx
-		movl	dsPrev(%edx), %edi
-		movl	%ebx, scanend(%esp)
-		movl	chainlenwmask(%esp), %edx
-		jmp	LookupLoop
-
-/* Accept the current string, with the maximum possible length.		*/
-
-LenMaximum:	movl	deflatestate(%esp), %edx
-		movl	$MAX_MATCH, bestlen(%esp)
-		movl	%ecx, dsMatchStart(%edx)
-
-/* if ((uInt)best_len <= s->lookahead) return (uInt)best_len;		*/
-/* return s->lookahead;							*/
-
-LeaveNow:
-		movl	deflatestate(%esp), %edx
-		movl	bestlen(%esp), %ebx
-		movl	dsLookahead(%edx), %eax
-		cmpl	%eax, %ebx
-		jg	LookaheadRet
-		movl	%ebx, %eax
-LookaheadRet:
-
-/* Restore the stack and return from whence we came.			*/
-
-		addl	$LocalVarsSize, %esp
-		.cfi_def_cfa_offset 20
-		popl	%ebx
-		.cfi_def_cfa_offset 16
-		popl	%esi
-		.cfi_def_cfa_offset 12
-		popl	%edi
-		.cfi_def_cfa_offset 8
-		popl	%ebp
-		.cfi_def_cfa_offset 4
-.cfi_endproc
-match_init:	ret
diff -Nbaur gcc-4.8.1/zlib/contrib/asm686/README.686 gcc-4.8.1-ppc/zlib/contrib/asm686/README.686
--- gcc-4.8.1/zlib/contrib/asm686/README.686	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/asm686/README.686	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-This is a patched version of zlib, modified to use
-Pentium-Pro-optimized assembly code in the deflation algorithm. The
-files changed/added by this patch are:
-
-README.686
-match.S
-
-The speedup that this patch provides varies, depending on whether the
-compiler used to build the original version of zlib falls afoul of the
-PPro's speed traps. My own tests show a speedup of around 10-20% at
-the default compression level, and 20-30% using -9, against a version
-compiled using gcc 2.7.2.3. Your mileage may vary.
-
-Note that this code has been tailored for the PPro/PII in particular,
-and will not perform particuarly well on a Pentium.
-
-If you are using an assembler other than GNU as, you will have to
-translate match.S to use your assembler's syntax. (Have fun.)
-
-Brian Raiter
-breadbox@muppetlabs.com
-April, 1998
-
-
-Added for zlib 1.1.3:
-
-The patches come from
-http://www.muppetlabs.com/~breadbox/software/assembly.html
-
-To compile zlib with this asm file, copy match.S to the zlib directory
-then do:
-
-CFLAGS="-O3 -DASMV" ./configure
-make OBJA=match.o
-
-
-Update:
-
-I've been ignoring these assembly routines for years, believing that
-gcc's generated code had caught up with it sometime around gcc 2.95
-and the major rearchitecting of the Pentium 4. However, I recently
-learned that, despite what I believed, this code still has some life
-in it. On the Pentium 4 and AMD64 chips, it continues to run about 8%
-faster than the code produced by gcc 4.1.
-
-In acknowledgement of its continuing usefulness, I've altered the
-license to match that of the rest of zlib. Share and Enjoy!
-
-Brian Raiter
-breadbox@muppetlabs.com
-April, 2007
diff -Nbaur gcc-4.8.1/zlib/contrib/blast/blast.c gcc-4.8.1-ppc/zlib/contrib/blast/blast.c
--- gcc-4.8.1/zlib/contrib/blast/blast.c	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/blast/blast.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,444 +0,0 @@
-/* blast.c
- * Copyright (C) 2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in blast.h
- * version 1.1, 16 Feb 2003
- *
- * blast.c decompresses data compressed by the PKWare Compression Library.
- * This function provides functionality similar to the explode() function of
- * the PKWare library, hence the name "blast".
- *
- * This decompressor is based on the excellent format description provided by
- * Ben Rudiak-Gould in comp.compression on August 13, 2001.  Interestingly, the
- * example Ben provided in the post is incorrect.  The distance 110001 should
- * instead be 111000.  When corrected, the example byte stream becomes:
- *
- *    00 04 82 24 25 8f 80 7f
- *
- * which decompresses to "AIAIAIAIAIAIA" (without the quotes).
- */
-
-/*
- * Change history:
- *
- * 1.0  12 Feb 2003     - First version
- * 1.1  16 Feb 2003     - Fixed distance check for > 4 GB uncompressed data
- */
-
-#include <setjmp.h>             /* for setjmp(), longjmp(), and jmp_buf */
-#include "blast.h"              /* prototype for blast() */
-
-#define local static            /* for local function definitions */
-#define MAXBITS 13              /* maximum code length */
-#define MAXWIN 4096             /* maximum window size */
-
-/* input and output state */
-struct state {
-    /* input state */
-    blast_in infun;             /* input function provided by user */
-    void *inhow;                /* opaque information passed to infun() */
-    unsigned char *in;          /* next input location */
-    unsigned left;              /* available input at in */
-    int bitbuf;                 /* bit buffer */
-    int bitcnt;                 /* number of bits in bit buffer */
-
-    /* input limit error return state for bits() and decode() */
-    jmp_buf env;
-
-    /* output state */
-    blast_out outfun;           /* output function provided by user */
-    void *outhow;               /* opaque information passed to outfun() */
-    unsigned next;              /* index of next write location in out[] */
-    int first;                  /* true to check distances (for first 4K) */
-    unsigned char out[MAXWIN];  /* output buffer and sliding window */
-};
-
-/*
- * Return need bits from the input stream.  This always leaves less than
- * eight bits in the buffer.  bits() works properly for need == 0.
- *
- * Format notes:
- *
- * - Bits are stored in bytes from the least significant bit to the most
- *   significant bit.  Therefore bits are dropped from the bottom of the bit
- *   buffer, using shift right, and new bytes are appended to the top of the
- *   bit buffer, using shift left.
- */
-local int bits(struct state *s, int need)
-{
-    int val;            /* bit accumulator */
-
-    /* load at least need bits into val */
-    val = s->bitbuf;
-    while (s->bitcnt < need) {
-        if (s->left == 0) {
-            s->left = s->infun(s->inhow, &(s->in));
-            if (s->left == 0) longjmp(s->env, 1);       /* out of input */
-        }
-        val |= (int)(*(s->in)++) << s->bitcnt;          /* load eight bits */
-        s->left--;
-        s->bitcnt += 8;
-    }
-
-    /* drop need bits and update buffer, always zero to seven bits left */
-    s->bitbuf = val >> need;
-    s->bitcnt -= need;
-
-    /* return need bits, zeroing the bits above that */
-    return val & ((1 << need) - 1);
-}
-
-/*
- * Huffman code decoding tables.  count[1..MAXBITS] is the number of symbols of
- * each length, which for a canonical code are stepped through in order.
- * symbol[] are the symbol values in canonical order, where the number of
- * entries is the sum of the counts in count[].  The decoding process can be
- * seen in the function decode() below.
- */
-struct huffman {
-    short *count;       /* number of symbols of each length */
-    short *symbol;      /* canonically ordered symbols */
-};
-
-/*
- * Decode a code from the stream s using huffman table h.  Return the symbol or
- * a negative value if there is an error.  If all of the lengths are zero, i.e.
- * an empty code, or if the code is incomplete and an invalid code is received,
- * then -9 is returned after reading MAXBITS bits.
- *
- * Format notes:
- *
- * - The codes as stored in the compressed data are bit-reversed relative to
- *   a simple integer ordering of codes of the same lengths.  Hence below the
- *   bits are pulled from the compressed data one at a time and used to
- *   build the code value reversed from what is in the stream in order to
- *   permit simple integer comparisons for decoding.
- *
- * - The first code for the shortest length is all ones.  Subsequent codes of
- *   the same length are simply integer decrements of the previous code.  When
- *   moving up a length, a one bit is appended to the code.  For a complete
- *   code, the last code of the longest length will be all zeros.  To support
- *   this ordering, the bits pulled during decoding are inverted to apply the
- *   more "natural" ordering starting with all zeros and incrementing.
- */
-local int decode(struct state *s, struct huffman *h)
-{
-    int len;            /* current number of bits in code */
-    int code;           /* len bits being decoded */
-    int first;          /* first code of length len */
-    int count;          /* number of codes of length len */
-    int index;          /* index of first code of length len in symbol table */
-    int bitbuf;         /* bits from stream */
-    int left;           /* bits left in next or left to process */
-    short *next;        /* next number of codes */
-
-    bitbuf = s->bitbuf;
-    left = s->bitcnt;
-    code = first = index = 0;
-    len = 1;
-    next = h->count + 1;
-    while (1) {
-        while (left--) {
-            code |= (bitbuf & 1) ^ 1;   /* invert code */
-            bitbuf >>= 1;
-            count = *next++;
-            if (code < first + count) { /* if length len, return symbol */
-                s->bitbuf = bitbuf;
-                s->bitcnt = (s->bitcnt - len) & 7;
-                return h->symbol[index + (code - first)];
-            }
-            index += count;             /* else update for next length */
-            first += count;
-            first <<= 1;
-            code <<= 1;
-            len++;
-        }
-        left = (MAXBITS+1) - len;
-        if (left == 0) break;
-        if (s->left == 0) {
-            s->left = s->infun(s->inhow, &(s->in));
-            if (s->left == 0) longjmp(s->env, 1);       /* out of input */
-        }
-        bitbuf = *(s->in)++;
-        s->left--;
-        if (left > 8) left = 8;
-    }
-    return -9;                          /* ran out of codes */
-}
-
-/*
- * Given a list of repeated code lengths rep[0..n-1], where each byte is a
- * count (high four bits + 1) and a code length (low four bits), generate the
- * list of code lengths.  This compaction reduces the size of the object code.
- * Then given the list of code lengths length[0..n-1] representing a canonical
- * Huffman code for n symbols, construct the tables required to decode those
- * codes.  Those tables are the number of codes of each length, and the symbols
- * sorted by length, retaining their original order within each length.  The
- * return value is zero for a complete code set, negative for an over-
- * subscribed code set, and positive for an incomplete code set.  The tables
- * can be used if the return value is zero or positive, but they cannot be used
- * if the return value is negative.  If the return value is zero, it is not
- * possible for decode() using that table to return an error--any stream of
- * enough bits will resolve to a symbol.  If the return value is positive, then
- * it is possible for decode() using that table to return an error for received
- * codes past the end of the incomplete lengths.
- */
-local int construct(struct huffman *h, const unsigned char *rep, int n)
-{
-    int symbol;         /* current symbol when stepping through length[] */
-    int len;            /* current length when stepping through h->count[] */
-    int left;           /* number of possible codes left of current length */
-    short offs[MAXBITS+1];      /* offsets in symbol table for each length */
-    short length[256];  /* code lengths */
-
-    /* convert compact repeat counts into symbol bit length list */
-    symbol = 0;
-    do {
-        len = *rep++;
-        left = (len >> 4) + 1;
-        len &= 15;
-        do {
-            length[symbol++] = len;
-        } while (--left);
-    } while (--n);
-    n = symbol;
-
-    /* count number of codes of each length */
-    for (len = 0; len <= MAXBITS; len++)
-        h->count[len] = 0;
-    for (symbol = 0; symbol < n; symbol++)
-        (h->count[length[symbol]])++;   /* assumes lengths are within bounds */
-    if (h->count[0] == n)               /* no codes! */
-        return 0;                       /* complete, but decode() will fail */
-
-    /* check for an over-subscribed or incomplete set of lengths */
-    left = 1;                           /* one possible code of zero length */
-    for (len = 1; len <= MAXBITS; len++) {
-        left <<= 1;                     /* one more bit, double codes left */
-        left -= h->count[len];          /* deduct count from possible codes */
-        if (left < 0) return left;      /* over-subscribed--return negative */
-    }                                   /* left > 0 means incomplete */
-
-    /* generate offsets into symbol table for each length for sorting */
-    offs[1] = 0;
-    for (len = 1; len < MAXBITS; len++)
-        offs[len + 1] = offs[len] + h->count[len];
-
-    /*
-     * put symbols in table sorted by length, by symbol order within each
-     * length
-     */
-    for (symbol = 0; symbol < n; symbol++)
-        if (length[symbol] != 0)
-            h->symbol[offs[length[symbol]]++] = symbol;
-
-    /* return zero for complete set, positive for incomplete set */
-    return left;
-}
-
-/*
- * Decode PKWare Compression Library stream.
- *
- * Format notes:
- *
- * - First byte is 0 if literals are uncoded or 1 if they are coded.  Second
- *   byte is 4, 5, or 6 for the number of extra bits in the distance code.
- *   This is the base-2 logarithm of the dictionary size minus six.
- *
- * - Compressed data is a combination of literals and length/distance pairs
- *   terminated by an end code.  Literals are either Huffman coded or
- *   uncoded bytes.  A length/distance pair is a coded length followed by a
- *   coded distance to represent a string that occurs earlier in the
- *   uncompressed data that occurs again at the current location.
- *
- * - A bit preceding a literal or length/distance pair indicates which comes
- *   next, 0 for literals, 1 for length/distance.
- *
- * - If literals are uncoded, then the next eight bits are the literal, in the
- *   normal bit order in th stream, i.e. no bit-reversal is needed. Similarly,
- *   no bit reversal is needed for either the length extra bits or the distance
- *   extra bits.
- *
- * - Literal bytes are simply written to the output.  A length/distance pair is
- *   an instruction to copy previously uncompressed bytes to the output.  The
- *   copy is from distance bytes back in the output stream, copying for length
- *   bytes.
- *
- * - Distances pointing before the beginning of the output data are not
- *   permitted.
- *
- * - Overlapped copies, where the length is greater than the distance, are
- *   allowed and common.  For example, a distance of one and a length of 518
- *   simply copies the last byte 518 times.  A distance of four and a length of
- *   twelve copies the last four bytes three times.  A simple forward copy
- *   ignoring whether the length is greater than the distance or not implements
- *   this correctly.
- */
-local int decomp(struct state *s)
-{
-    int lit;            /* true if literals are coded */
-    int dict;           /* log2(dictionary size) - 6 */
-    int symbol;         /* decoded symbol, extra bits for distance */
-    int len;            /* length for copy */
-    int dist;           /* distance for copy */
-    int copy;           /* copy counter */
-    unsigned char *from, *to;   /* copy pointers */
-    static int virgin = 1;                              /* build tables once */
-    static short litcnt[MAXBITS+1], litsym[256];        /* litcode memory */
-    static short lencnt[MAXBITS+1], lensym[16];         /* lencode memory */
-    static short distcnt[MAXBITS+1], distsym[64];       /* distcode memory */
-    static struct huffman litcode = {litcnt, litsym};   /* length code */
-    static struct huffman lencode = {lencnt, lensym};   /* length code */
-    static struct huffman distcode = {distcnt, distsym};/* distance code */
-        /* bit lengths of literal codes */
-    static const unsigned char litlen[] = {
-        11, 124, 8, 7, 28, 7, 188, 13, 76, 4, 10, 8, 12, 10, 12, 10, 8, 23, 8,
-        9, 7, 6, 7, 8, 7, 6, 55, 8, 23, 24, 12, 11, 7, 9, 11, 12, 6, 7, 22, 5,
-        7, 24, 6, 11, 9, 6, 7, 22, 7, 11, 38, 7, 9, 8, 25, 11, 8, 11, 9, 12,
-        8, 12, 5, 38, 5, 38, 5, 11, 7, 5, 6, 21, 6, 10, 53, 8, 7, 24, 10, 27,
-        44, 253, 253, 253, 252, 252, 252, 13, 12, 45, 12, 45, 12, 61, 12, 45,
-        44, 173};
-        /* bit lengths of length codes 0..15 */
-    static const unsigned char lenlen[] = {2, 35, 36, 53, 38, 23};
-        /* bit lengths of distance codes 0..63 */
-    static const unsigned char distlen[] = {2, 20, 53, 230, 247, 151, 248};
-    static const short base[16] = {     /* base for length codes */
-        3, 2, 4, 5, 6, 7, 8, 9, 10, 12, 16, 24, 40, 72, 136, 264};
-    static const char extra[16] = {     /* extra bits for length codes */
-        0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8};
-
-    /* set up decoding tables (once--might not be thread-safe) */
-    if (virgin) {
-        construct(&litcode, litlen, sizeof(litlen));
-        construct(&lencode, lenlen, sizeof(lenlen));
-        construct(&distcode, distlen, sizeof(distlen));
-        virgin = 0;
-    }
-
-    /* read header */
-    lit = bits(s, 8);
-    if (lit > 1) return -1;
-    dict = bits(s, 8);
-    if (dict < 4 || dict > 6) return -2;
-
-    /* decode literals and length/distance pairs */
-    do {
-        if (bits(s, 1)) {
-            /* get length */
-            symbol = decode(s, &lencode);
-            len = base[symbol] + bits(s, extra[symbol]);
-            if (len == 519) break;              /* end code */
-
-            /* get distance */
-            symbol = len == 2 ? 2 : dict;
-            dist = decode(s, &distcode) << symbol;
-            dist += bits(s, symbol);
-            dist++;
-            if (s->first && dist > s->next)
-                return -3;              /* distance too far back */
-
-            /* copy length bytes from distance bytes back */
-            do {
-                to = s->out + s->next;
-                from = to - dist;
-                copy = MAXWIN;
-                if (s->next < dist) {
-                    from += copy;
-                    copy = dist;
-                }
-                copy -= s->next;
-                if (copy > len) copy = len;
-                len -= copy;
-                s->next += copy;
-                do {
-                    *to++ = *from++;
-                } while (--copy);
-                if (s->next == MAXWIN) {
-                    if (s->outfun(s->outhow, s->out, s->next)) return 1;
-                    s->next = 0;
-                    s->first = 0;
-                }
-            } while (len != 0);
-        }
-        else {
-            /* get literal and write it */
-            symbol = lit ? decode(s, &litcode) : bits(s, 8);
-            s->out[s->next++] = symbol;
-            if (s->next == MAXWIN) {
-                if (s->outfun(s->outhow, s->out, s->next)) return 1;
-                s->next = 0;
-                s->first = 0;
-            }
-        }
-    } while (1);
-    return 0;
-}
-
-/* See comments in blast.h */
-int blast(blast_in infun, void *inhow, blast_out outfun, void *outhow)
-{
-    struct state s;             /* input/output state */
-    int err;                    /* return value */
-
-    /* initialize input state */
-    s.infun = infun;
-    s.inhow = inhow;
-    s.left = 0;
-    s.bitbuf = 0;
-    s.bitcnt = 0;
-
-    /* initialize output state */
-    s.outfun = outfun;
-    s.outhow = outhow;
-    s.next = 0;
-    s.first = 1;
-
-    /* return if bits() or decode() tries to read past available input */
-    if (setjmp(s.env) != 0)             /* if came back here via longjmp(), */
-        err = 2;                        /*  then skip decomp(), return error */
-    else
-        err = decomp(&s);               /* decompress */
-
-    /* write any leftover output and update the error code if needed */
-    if (err != 1 && s.next && s.outfun(s.outhow, s.out, s.next) && err == 0)
-        err = 1;
-    return err;
-}
-
-#ifdef TEST
-/* Example of how to use blast() */
-#include <stdio.h>
-#include <stdlib.h>
-
-#define CHUNK 16384
-
-local unsigned inf(void *how, unsigned char **buf)
-{
-    static unsigned char hold[CHUNK];
-
-    *buf = hold;
-    return fread(hold, 1, CHUNK, (FILE *)how);
-}
-
-local int outf(void *how, unsigned char *buf, unsigned len)
-{
-    return fwrite(buf, 1, len, (FILE *)how) != len;
-}
-
-/* Decompress a PKWare Compression Library stream from stdin to stdout */
-int main(void)
-{
-    int ret, n;
-
-    /* decompress to stdout */
-    ret = blast(inf, stdin, outf, stdout);
-    if (ret != 0) fprintf(stderr, "blast error: %d\n", ret);
-
-    /* see if there are any leftover bytes */
-    n = 0;
-    while (getchar() != EOF) n++;
-    if (n) fprintf(stderr, "blast warning: %d unused bytes of input\n", n);
-
-    /* return blast() error code */
-    return ret;
-}
-#endif
diff -Nbaur gcc-4.8.1/zlib/contrib/blast/blast.h gcc-4.8.1-ppc/zlib/contrib/blast/blast.h
--- gcc-4.8.1/zlib/contrib/blast/blast.h	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/blast/blast.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,71 +0,0 @@
-/* blast.h -- interface for blast.c
-  Copyright (C) 2003 Mark Adler
-  version 1.1, 16 Feb 2003
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Mark Adler    madler@alumni.caltech.edu
- */
-
-
-/*
- * blast() decompresses the PKWare Data Compression Library (DCL) compressed
- * format.  It provides the same functionality as the explode() function in
- * that library.  (Note: PKWare overused the "implode" verb, and the format
- * used by their library implode() function is completely different and
- * incompatible with the implode compression method supported by PKZIP.)
- */
-
-
-typedef unsigned (*blast_in)(void *how, unsigned char **buf);
-typedef int (*blast_out)(void *how, unsigned char *buf, unsigned len);
-/* Definitions for input/output functions passed to blast().  See below for
- * what the provided functions need to do.
- */
-
-
-int blast(blast_in infun, void *inhow, blast_out outfun, void *outhow);
-/* Decompress input to output using the provided infun() and outfun() calls.
- * On success, the return value of blast() is zero.  If there is an error in
- * the source data, i.e. it is not in the proper format, then a negative value
- * is returned.  If there is not enough input available or there is not enough
- * output space, then a positive error is returned.
- *
- * The input function is invoked: len = infun(how, &buf), where buf is set by
- * infun() to point to the input buffer, and infun() returns the number of
- * available bytes there.  If infun() returns zero, then blast() returns with
- * an input error.  (blast() only asks for input if it needs it.)  inhow is for
- * use by the application to pass an input descriptor to infun(), if desired.
- *
- * The output function is invoked: err = outfun(how, buf, len), where the bytes
- * to be written are buf[0..len-1].  If err is not zero, then blast() returns
- * with an output error.  outfun() is always called with len <= 4096.  outhow
- * is for use by the application to pass an output descriptor to outfun(), if
- * desired.
- *
- * The return codes are:
- *
- *   2:  ran out of input before completing decompression
- *   1:  output error before completing decompression
- *   0:  successful decompression
- *  -1:  literal flag not zero or one
- *  -2:  dictionary size not in 4..6
- *  -3:  distance is too far back
- *
- * At the bottom of blast.c is an example program that uses blast() that can be
- * compiled to produce a command-line decompression filter by defining TEST.
- */
diff -Nbaur gcc-4.8.1/zlib/contrib/blast/Makefile gcc-4.8.1-ppc/zlib/contrib/blast/Makefile
--- gcc-4.8.1/zlib/contrib/blast/Makefile	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/blast/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-blast: blast.c blast.h
-	cc -DTEST -o blast blast.c
-
-test: blast
-	blast < test.pk | cmp - test.txt
-
-clean:
-	rm -f blast blast.o
diff -Nbaur gcc-4.8.1/zlib/contrib/blast/README gcc-4.8.1-ppc/zlib/contrib/blast/README
--- gcc-4.8.1/zlib/contrib/blast/README	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/blast/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-Read blast.h for purpose and usage.
-
-Mark Adler
-madler@alumni.caltech.edu
diff -Nbaur gcc-4.8.1/zlib/contrib/blast/test.pk gcc-4.8.1-ppc/zlib/contrib/blast/test.pk
--- gcc-4.8.1/zlib/contrib/blast/test.pk	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/blast/test.pk	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
- $%
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/blast/test.txt gcc-4.8.1-ppc/zlib/contrib/blast/test.txt
--- gcc-4.8.1/zlib/contrib/blast/test.txt	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/blast/test.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-AIAIAIAIAIAIA
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/delphi/readme.txt gcc-4.8.1-ppc/zlib/contrib/delphi/readme.txt
--- gcc-4.8.1/zlib/contrib/delphi/readme.txt	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/delphi/readme.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-
-Overview
-========
-
-This directory contains an update to the ZLib interface unit,
-distributed by Borland as a Delphi supplemental component.
-
-The original ZLib unit is Copyright (c) 1997,99 Borland Corp.,
-and is based on zlib version 1.0.4.  There are a series of bugs
-and security problems associated with that old zlib version, and
-we recommend the users to update their ZLib unit.
-
-
-Summary of modifications
-========================
-
-- Improved makefile, adapted to zlib version 1.2.1.
-
-- Some field types from TZStreamRec are changed from Integer to
-  Longint, for consistency with the zlib.h header, and for 64-bit
-  readiness.
-
-- The zlib_version constant is updated.
-
-- The new Z_RLE strategy has its corresponding symbolic constant.
-
-- The allocation and deallocation functions and function types
-  (TAlloc, TFree, zlibAllocMem and zlibFreeMem) are now cdecl,
-  and _malloc and _free are added as C RTL stubs.  As a result,
-  the original C sources of zlib can be compiled out of the box,
-  and linked to the ZLib unit.
-
-
-Suggestions for improvements
-============================
-
-Currently, the ZLib unit provides only a limited wrapper around
-the zlib library, and much of the original zlib functionality is
-missing.  Handling compressed file formats like ZIP/GZIP or PNG
-cannot be implemented without having this functionality.
-Applications that handle these formats are either using their own,
-duplicated code, or not using the ZLib unit at all.
-
-Here are a few suggestions:
-
-- Checksum class wrappers around adler32() and crc32(), similar
-  to the Java classes that implement the java.util.zip.Checksum
-  interface.
-
-- The ability to read and write raw deflate streams, without the
-  zlib stream header and trailer.  Raw deflate streams are used
-  in the ZIP file format.
-
-- The ability to read and write gzip streams, used in the GZIP
-  file format, and normally produced by the gzip program.
-
-- The ability to select a different compression strategy, useful
-  to PNG and MNG image compression, and to multimedia compression
-  in general.  Besides the compression level
-
-    TCompressionLevel = (clNone, clFastest, clDefault, clMax);
-
-  which, in fact, could have used the 'z' prefix and avoided
-  TColor-like symbols
-
-    TCompressionLevel = (zcNone, zcFastest, zcDefault, zcMax);
-
-  there could be a compression strategy
-
-    TCompressionStrategy = (zsDefault, zsFiltered, zsHuffmanOnly, zsRle);
-
-- ZIP and GZIP stream handling via TStreams.
-
-
---
-Cosmin Truta <cosmint@cs.ubbcluj.ro>
diff -Nbaur gcc-4.8.1/zlib/contrib/delphi/ZLibConst.pas gcc-4.8.1-ppc/zlib/contrib/delphi/ZLibConst.pas
--- gcc-4.8.1/zlib/contrib/delphi/ZLibConst.pas	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/delphi/ZLibConst.pas	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
-unit ZLibConst;
-
-interface
-
-resourcestring
-  sTargetBufferTooSmall = 'ZLib error: target buffer may be too small';
-  sInvalidStreamOp = 'Invalid stream operation';
-
-implementation
-
-end.
diff -Nbaur gcc-4.8.1/zlib/contrib/delphi/zlibd32.mak gcc-4.8.1-ppc/zlib/contrib/delphi/zlibd32.mak
--- gcc-4.8.1/zlib/contrib/delphi/zlibd32.mak	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/delphi/zlibd32.mak	1970-01-01 01:00:00.000000000 +0100
@@ -1,99 +0,0 @@
-# Makefile for zlib
-# For use with Delphi and C++ Builder under Win32
-# Updated for zlib 1.2.x by Cosmin Truta
-
-# ------------ Borland C++ ------------
-
-# This project uses the Delphi (fastcall/register) calling convention:
-LOC = -DZEXPORT=__fastcall -DZEXPORTVA=__cdecl
-
-CC = bcc32
-LD = bcc32
-AR = tlib
-# do not use "-pr" in CFLAGS
-CFLAGS = -a -d -k- -O2 $(LOC)
-LDFLAGS =
-
-
-# variables
-ZLIB_LIB = zlib.lib
-
-OBJ1 = adler32.obj compress.obj crc32.obj deflate.obj gzclose.obj gzlib.obj gzread.obj
-OBJ2 = gzwrite.obj infback.obj inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj
-OBJP1 = +adler32.obj+compress.obj+crc32.obj+deflate.obj+gzclose.obj+gzlib.obj+gzread.obj
-OBJP2 = +gzwrite.obj+infback.obj+inffast.obj+inflate.obj+inftrees.obj+trees.obj+uncompr.obj+zutil.obj
-
-
-# targets
-all: $(ZLIB_LIB) example.exe minigzip.exe
-
-.c.obj:
-	$(CC) -c $(CFLAGS) $*.c
-
-adler32.obj: adler32.c zlib.h zconf.h
-
-compress.obj: compress.c zlib.h zconf.h
-
-crc32.obj: crc32.c zlib.h zconf.h crc32.h
-
-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h
-
-gzclose.obj: gzclose.c zlib.h zconf.h gzguts.h
-
-gzlib.obj: gzlib.c zlib.h zconf.h gzguts.h
-
-gzread.obj: gzread.c zlib.h zconf.h gzguts.h
-
-gzwrite.obj: gzwrite.c zlib.h zconf.h gzguts.h
-
-infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h
-
-inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h
-
-trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h
-
-uncompr.obj: uncompr.c zlib.h zconf.h
-
-zutil.obj: zutil.c zutil.h zlib.h zconf.h
-
-example.obj: test/example.c zlib.h zconf.h
-
-minigzip.obj: test/minigzip.c zlib.h zconf.h
-
-
-# For the sake of the old Borland make,
-# the command line is cut to fit in the MS-DOS 128 byte limit:
-$(ZLIB_LIB): $(OBJ1) $(OBJ2)
-	-del $(ZLIB_LIB)
-	$(AR) $(ZLIB_LIB) $(OBJP1)
-	$(AR) $(ZLIB_LIB) $(OBJP2)
-
-
-# testing
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d
-
-example.exe: example.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) example.obj $(ZLIB_LIB)
-
-minigzip.exe: minigzip.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) minigzip.obj $(ZLIB_LIB)
-
-
-# cleanup
-clean:
-	-del *.obj
-	-del *.exe
-	-del *.lib
-	-del *.tds
-	-del zlib.bak
-	-del foo.gz
-
diff -Nbaur gcc-4.8.1/zlib/contrib/delphi/ZLib.pas gcc-4.8.1-ppc/zlib/contrib/delphi/ZLib.pas
--- gcc-4.8.1/zlib/contrib/delphi/ZLib.pas	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/delphi/ZLib.pas	1970-01-01 01:00:00.000000000 +0100
@@ -1,557 +0,0 @@
-{*******************************************************}
-{                                                       }
-{       Borland Delphi Supplemental Components          }
-{       ZLIB Data Compression Interface Unit            }
-{                                                       }
-{       Copyright (c) 1997,99 Borland Corporation       }
-{                                                       }
-{*******************************************************}
-
-{ Updated for zlib 1.2.x by Cosmin Truta <cosmint@cs.ubbcluj.ro> }
-
-unit ZLib;
-
-interface
-
-uses SysUtils, Classes;
-
-type
-  TAlloc = function (AppData: Pointer; Items, Size: Integer): Pointer; cdecl;
-  TFree = procedure (AppData, Block: Pointer); cdecl;
-
-  // Internal structure.  Ignore.
-  TZStreamRec = packed record
-    next_in: PChar;       // next input byte
-    avail_in: Integer;    // number of bytes available at next_in
-    total_in: Longint;    // total nb of input bytes read so far
-
-    next_out: PChar;      // next output byte should be put here
-    avail_out: Integer;   // remaining free space at next_out
-    total_out: Longint;   // total nb of bytes output so far
-
-    msg: PChar;           // last error message, NULL if no error
-    internal: Pointer;    // not visible by applications
-
-    zalloc: TAlloc;       // used to allocate the internal state
-    zfree: TFree;         // used to free the internal state
-    AppData: Pointer;     // private data object passed to zalloc and zfree
-
-    data_type: Integer;   // best guess about the data type: ascii or binary
-    adler: Longint;       // adler32 value of the uncompressed data
-    reserved: Longint;    // reserved for future use
-  end;
-
-  // Abstract ancestor class
-  TCustomZlibStream = class(TStream)
-  private
-    FStrm: TStream;
-    FStrmPos: Integer;
-    FOnProgress: TNotifyEvent;
-    FZRec: TZStreamRec;
-    FBuffer: array [Word] of Char;
-  protected
-    procedure Progress(Sender: TObject); dynamic;
-    property OnProgress: TNotifyEvent read FOnProgress write FOnProgress;
-    constructor Create(Strm: TStream);
-  end;
-
-{ TCompressionStream compresses data on the fly as data is written to it, and
-  stores the compressed data to another stream.
-
-  TCompressionStream is write-only and strictly sequential. Reading from the
-  stream will raise an exception. Using Seek to move the stream pointer
-  will raise an exception.
-
-  Output data is cached internally, written to the output stream only when
-  the internal output buffer is full.  All pending output data is flushed
-  when the stream is destroyed.
-
-  The Position property returns the number of uncompressed bytes of
-  data that have been written to the stream so far.
-
-  CompressionRate returns the on-the-fly percentage by which the original
-  data has been compressed:  (1 - (CompressedBytes / UncompressedBytes)) * 100
-  If raw data size = 100 and compressed data size = 25, the CompressionRate
-  is 75%
-
-  The OnProgress event is called each time the output buffer is filled and
-  written to the output stream.  This is useful for updating a progress
-  indicator when you are writing a large chunk of data to the compression
-  stream in a single call.}
-
-
-  TCompressionLevel = (clNone, clFastest, clDefault, clMax);
-
-  TCompressionStream = class(TCustomZlibStream)
-  private
-    function GetCompressionRate: Single;
-  public
-    constructor Create(CompressionLevel: TCompressionLevel; Dest: TStream);
-    destructor Destroy; override;
-    function Read(var Buffer; Count: Longint): Longint; override;
-    function Write(const Buffer; Count: Longint): Longint; override;
-    function Seek(Offset: Longint; Origin: Word): Longint; override;
-    property CompressionRate: Single read GetCompressionRate;
-    property OnProgress;
-  end;
-
-{ TDecompressionStream decompresses data on the fly as data is read from it.
-
-  Compressed data comes from a separate source stream.  TDecompressionStream
-  is read-only and unidirectional; you can seek forward in the stream, but not
-  backwards.  The special case of setting the stream position to zero is
-  allowed.  Seeking forward decompresses data until the requested position in
-  the uncompressed data has been reached.  Seeking backwards, seeking relative
-  to the end of the stream, requesting the size of the stream, and writing to
-  the stream will raise an exception.
-
-  The Position property returns the number of bytes of uncompressed data that
-  have been read from the stream so far.
-
-  The OnProgress event is called each time the internal input buffer of
-  compressed data is exhausted and the next block is read from the input stream.
-  This is useful for updating a progress indicator when you are reading a
-  large chunk of data from the decompression stream in a single call.}
-
-  TDecompressionStream = class(TCustomZlibStream)
-  public
-    constructor Create(Source: TStream);
-    destructor Destroy; override;
-    function Read(var Buffer; Count: Longint): Longint; override;
-    function Write(const Buffer; Count: Longint): Longint; override;
-    function Seek(Offset: Longint; Origin: Word): Longint; override;
-    property OnProgress;
-  end;
-
-
-
-{ CompressBuf compresses data, buffer to buffer, in one call.
-   In: InBuf = ptr to compressed data
-       InBytes = number of bytes in InBuf
-  Out: OutBuf = ptr to newly allocated buffer containing decompressed data
-       OutBytes = number of bytes in OutBuf   }
-procedure CompressBuf(const InBuf: Pointer; InBytes: Integer;
-                      out OutBuf: Pointer; out OutBytes: Integer);
-
-
-{ DecompressBuf decompresses data, buffer to buffer, in one call.
-   In: InBuf = ptr to compressed data
-       InBytes = number of bytes in InBuf
-       OutEstimate = zero, or est. size of the decompressed data
-  Out: OutBuf = ptr to newly allocated buffer containing decompressed data
-       OutBytes = number of bytes in OutBuf   }
-procedure DecompressBuf(const InBuf: Pointer; InBytes: Integer;
- OutEstimate: Integer; out OutBuf: Pointer; out OutBytes: Integer);
-
-{ DecompressToUserBuf decompresses data, buffer to buffer, in one call.
-   In: InBuf = ptr to compressed data
-       InBytes = number of bytes in InBuf
-  Out: OutBuf = ptr to user-allocated buffer to contain decompressed data
-       BufSize = number of bytes in OutBuf   }
-procedure DecompressToUserBuf(const InBuf: Pointer; InBytes: Integer;
-  const OutBuf: Pointer; BufSize: Integer);
-
-const
-  zlib_version = '1.2.7';
-
-type
-  EZlibError = class(Exception);
-  ECompressionError = class(EZlibError);
-  EDecompressionError = class(EZlibError);
-
-implementation
-
-uses ZLibConst;
-
-const
-  Z_NO_FLUSH      = 0;
-  Z_PARTIAL_FLUSH = 1;
-  Z_SYNC_FLUSH    = 2;
-  Z_FULL_FLUSH    = 3;
-  Z_FINISH        = 4;
-
-  Z_OK            = 0;
-  Z_STREAM_END    = 1;
-  Z_NEED_DICT     = 2;
-  Z_ERRNO         = (-1);
-  Z_STREAM_ERROR  = (-2);
-  Z_DATA_ERROR    = (-3);
-  Z_MEM_ERROR     = (-4);
-  Z_BUF_ERROR     = (-5);
-  Z_VERSION_ERROR = (-6);
-
-  Z_NO_COMPRESSION       =   0;
-  Z_BEST_SPEED           =   1;
-  Z_BEST_COMPRESSION     =   9;
-  Z_DEFAULT_COMPRESSION  = (-1);
-
-  Z_FILTERED            = 1;
-  Z_HUFFMAN_ONLY        = 2;
-  Z_RLE                 = 3;
-  Z_DEFAULT_STRATEGY    = 0;
-
-  Z_BINARY   = 0;
-  Z_ASCII    = 1;
-  Z_UNKNOWN  = 2;
-
-  Z_DEFLATED = 8;
-
-
-{$L adler32.obj}
-{$L compress.obj}
-{$L crc32.obj}
-{$L deflate.obj}
-{$L infback.obj}
-{$L inffast.obj}
-{$L inflate.obj}
-{$L inftrees.obj}
-{$L trees.obj}
-{$L uncompr.obj}
-{$L zutil.obj}
-
-procedure adler32; external;
-procedure compressBound; external;
-procedure crc32; external;
-procedure deflateInit2_; external;
-procedure deflateParams; external;
-
-function _malloc(Size: Integer): Pointer; cdecl;
-begin
-  Result := AllocMem(Size);
-end;
-
-procedure _free(Block: Pointer); cdecl;
-begin
-  FreeMem(Block);
-end;
-
-procedure _memset(P: Pointer; B: Byte; count: Integer); cdecl;
-begin
-  FillChar(P^, count, B);
-end;
-
-procedure _memcpy(dest, source: Pointer; count: Integer); cdecl;
-begin
-  Move(source^, dest^, count);
-end;
-
-
-
-// deflate compresses data
-function deflateInit_(var strm: TZStreamRec; level: Integer; version: PChar;
-  recsize: Integer): Integer; external;
-function deflate(var strm: TZStreamRec; flush: Integer): Integer; external;
-function deflateEnd(var strm: TZStreamRec): Integer; external;
-
-// inflate decompresses data
-function inflateInit_(var strm: TZStreamRec; version: PChar;
-  recsize: Integer): Integer; external;
-function inflate(var strm: TZStreamRec; flush: Integer): Integer; external;
-function inflateEnd(var strm: TZStreamRec): Integer; external;
-function inflateReset(var strm: TZStreamRec): Integer; external;
-
-
-function zlibAllocMem(AppData: Pointer; Items, Size: Integer): Pointer; cdecl;
-begin
-//  GetMem(Result, Items*Size);
-  Result := AllocMem(Items * Size);
-end;
-
-procedure zlibFreeMem(AppData, Block: Pointer); cdecl;
-begin
-  FreeMem(Block);
-end;
-
-{function zlibCheck(code: Integer): Integer;
-begin
-  Result := code;
-  if code < 0 then
-    raise EZlibError.Create('error');    //!!
-end;}
-
-function CCheck(code: Integer): Integer;
-begin
-  Result := code;
-  if code < 0 then
-    raise ECompressionError.Create('error'); //!!
-end;
-
-function DCheck(code: Integer): Integer;
-begin
-  Result := code;
-  if code < 0 then
-    raise EDecompressionError.Create('error');  //!!
-end;
-
-procedure CompressBuf(const InBuf: Pointer; InBytes: Integer;
-                      out OutBuf: Pointer; out OutBytes: Integer);
-var
-  strm: TZStreamRec;
-  P: Pointer;
-begin
-  FillChar(strm, sizeof(strm), 0);
-  strm.zalloc := zlibAllocMem;
-  strm.zfree := zlibFreeMem;
-  OutBytes := ((InBytes + (InBytes div 10) + 12) + 255) and not 255;
-  GetMem(OutBuf, OutBytes);
-  try
-    strm.next_in := InBuf;
-    strm.avail_in := InBytes;
-    strm.next_out := OutBuf;
-    strm.avail_out := OutBytes;
-    CCheck(deflateInit_(strm, Z_BEST_COMPRESSION, zlib_version, sizeof(strm)));
-    try
-      while CCheck(deflate(strm, Z_FINISH)) <> Z_STREAM_END do
-      begin
-        P := OutBuf;
-        Inc(OutBytes, 256);
-        ReallocMem(OutBuf, OutBytes);
-        strm.next_out := PChar(Integer(OutBuf) + (Integer(strm.next_out) - Integer(P)));
-        strm.avail_out := 256;
-      end;
-    finally
-      CCheck(deflateEnd(strm));
-    end;
-    ReallocMem(OutBuf, strm.total_out);
-    OutBytes := strm.total_out;
-  except
-    FreeMem(OutBuf);
-    raise
-  end;
-end;
-
-
-procedure DecompressBuf(const InBuf: Pointer; InBytes: Integer;
-  OutEstimate: Integer; out OutBuf: Pointer; out OutBytes: Integer);
-var
-  strm: TZStreamRec;
-  P: Pointer;
-  BufInc: Integer;
-begin
-  FillChar(strm, sizeof(strm), 0);
-  strm.zalloc := zlibAllocMem;
-  strm.zfree := zlibFreeMem;
-  BufInc := (InBytes + 255) and not 255;
-  if OutEstimate = 0 then
-    OutBytes := BufInc
-  else
-    OutBytes := OutEstimate;
-  GetMem(OutBuf, OutBytes);
-  try
-    strm.next_in := InBuf;
-    strm.avail_in := InBytes;
-    strm.next_out := OutBuf;
-    strm.avail_out := OutBytes;
-    DCheck(inflateInit_(strm, zlib_version, sizeof(strm)));
-    try
-      while DCheck(inflate(strm, Z_NO_FLUSH)) <> Z_STREAM_END do
-      begin
-        P := OutBuf;
-        Inc(OutBytes, BufInc);
-        ReallocMem(OutBuf, OutBytes);
-        strm.next_out := PChar(Integer(OutBuf) + (Integer(strm.next_out) - Integer(P)));
-        strm.avail_out := BufInc;
-      end;
-    finally
-      DCheck(inflateEnd(strm));
-    end;
-    ReallocMem(OutBuf, strm.total_out);
-    OutBytes := strm.total_out;
-  except
-    FreeMem(OutBuf);
-    raise
-  end;
-end;
-
-procedure DecompressToUserBuf(const InBuf: Pointer; InBytes: Integer;
-  const OutBuf: Pointer; BufSize: Integer);
-var
-  strm: TZStreamRec;
-begin
-  FillChar(strm, sizeof(strm), 0);
-  strm.zalloc := zlibAllocMem;
-  strm.zfree := zlibFreeMem;
-  strm.next_in := InBuf;
-  strm.avail_in := InBytes;
-  strm.next_out := OutBuf;
-  strm.avail_out := BufSize;
-  DCheck(inflateInit_(strm, zlib_version, sizeof(strm)));
-  try
-    if DCheck(inflate(strm, Z_FINISH)) <> Z_STREAM_END then
-      raise EZlibError.CreateRes(@sTargetBufferTooSmall);
-  finally
-    DCheck(inflateEnd(strm));
-  end;
-end;
-
-// TCustomZlibStream
-
-constructor TCustomZLibStream.Create(Strm: TStream);
-begin
-  inherited Create;
-  FStrm := Strm;
-  FStrmPos := Strm.Position;
-  FZRec.zalloc := zlibAllocMem;
-  FZRec.zfree := zlibFreeMem;
-end;
-
-procedure TCustomZLibStream.Progress(Sender: TObject);
-begin
-  if Assigned(FOnProgress) then FOnProgress(Sender);
-end;
-
-
-// TCompressionStream
-
-constructor TCompressionStream.Create(CompressionLevel: TCompressionLevel;
-  Dest: TStream);
-const
-  Levels: array [TCompressionLevel] of ShortInt =
-    (Z_NO_COMPRESSION, Z_BEST_SPEED, Z_DEFAULT_COMPRESSION, Z_BEST_COMPRESSION);
-begin
-  inherited Create(Dest);
-  FZRec.next_out := FBuffer;
-  FZRec.avail_out := sizeof(FBuffer);
-  CCheck(deflateInit_(FZRec, Levels[CompressionLevel], zlib_version, sizeof(FZRec)));
-end;
-
-destructor TCompressionStream.Destroy;
-begin
-  FZRec.next_in := nil;
-  FZRec.avail_in := 0;
-  try
-    if FStrm.Position <> FStrmPos then FStrm.Position := FStrmPos;
-    while (CCheck(deflate(FZRec, Z_FINISH)) <> Z_STREAM_END)
-      and (FZRec.avail_out = 0) do
-    begin
-      FStrm.WriteBuffer(FBuffer, sizeof(FBuffer));
-      FZRec.next_out := FBuffer;
-      FZRec.avail_out := sizeof(FBuffer);
-    end;
-    if FZRec.avail_out < sizeof(FBuffer) then
-      FStrm.WriteBuffer(FBuffer, sizeof(FBuffer) - FZRec.avail_out);
-  finally
-    deflateEnd(FZRec);
-  end;
-  inherited Destroy;
-end;
-
-function TCompressionStream.Read(var Buffer; Count: Longint): Longint;
-begin
-  raise ECompressionError.CreateRes(@sInvalidStreamOp);
-end;
-
-function TCompressionStream.Write(const Buffer; Count: Longint): Longint;
-begin
-  FZRec.next_in := @Buffer;
-  FZRec.avail_in := Count;
-  if FStrm.Position <> FStrmPos then FStrm.Position := FStrmPos;
-  while (FZRec.avail_in > 0) do
-  begin
-    CCheck(deflate(FZRec, 0));
-    if FZRec.avail_out = 0 then
-    begin
-      FStrm.WriteBuffer(FBuffer, sizeof(FBuffer));
-      FZRec.next_out := FBuffer;
-      FZRec.avail_out := sizeof(FBuffer);
-      FStrmPos := FStrm.Position;
-      Progress(Self);
-    end;
-  end;
-  Result := Count;
-end;
-
-function TCompressionStream.Seek(Offset: Longint; Origin: Word): Longint;
-begin
-  if (Offset = 0) and (Origin = soFromCurrent) then
-    Result := FZRec.total_in
-  else
-    raise ECompressionError.CreateRes(@sInvalidStreamOp);
-end;
-
-function TCompressionStream.GetCompressionRate: Single;
-begin
-  if FZRec.total_in = 0 then
-    Result := 0
-  else
-    Result := (1.0 - (FZRec.total_out / FZRec.total_in)) * 100.0;
-end;
-
-
-// TDecompressionStream
-
-constructor TDecompressionStream.Create(Source: TStream);
-begin
-  inherited Create(Source);
-  FZRec.next_in := FBuffer;
-  FZRec.avail_in := 0;
-  DCheck(inflateInit_(FZRec, zlib_version, sizeof(FZRec)));
-end;
-
-destructor TDecompressionStream.Destroy;
-begin
-  FStrm.Seek(-FZRec.avail_in, 1);
-  inflateEnd(FZRec);
-  inherited Destroy;
-end;
-
-function TDecompressionStream.Read(var Buffer; Count: Longint): Longint;
-begin
-  FZRec.next_out := @Buffer;
-  FZRec.avail_out := Count;
-  if FStrm.Position <> FStrmPos then FStrm.Position := FStrmPos;
-  while (FZRec.avail_out > 0) do
-  begin
-    if FZRec.avail_in = 0 then
-    begin
-      FZRec.avail_in := FStrm.Read(FBuffer, sizeof(FBuffer));
-      if FZRec.avail_in = 0 then
-      begin
-        Result := Count - FZRec.avail_out;
-        Exit;
-      end;
-      FZRec.next_in := FBuffer;
-      FStrmPos := FStrm.Position;
-      Progress(Self);
-    end;
-    CCheck(inflate(FZRec, 0));
-  end;
-  Result := Count;
-end;
-
-function TDecompressionStream.Write(const Buffer; Count: Longint): Longint;
-begin
-  raise EDecompressionError.CreateRes(@sInvalidStreamOp);
-end;
-
-function TDecompressionStream.Seek(Offset: Longint; Origin: Word): Longint;
-var
-  I: Integer;
-  Buf: array [0..4095] of Char;
-begin
-  if (Offset = 0) and (Origin = soFromBeginning) then
-  begin
-    DCheck(inflateReset(FZRec));
-    FZRec.next_in := FBuffer;
-    FZRec.avail_in := 0;
-    FStrm.Position := 0;
-    FStrmPos := 0;
-  end
-  else if ( (Offset >= 0) and (Origin = soFromCurrent)) or
-          ( ((Offset - FZRec.total_out) > 0) and (Origin = soFromBeginning)) then
-  begin
-    if Origin = soFromBeginning then Dec(Offset, FZRec.total_out);
-    if Offset > 0 then
-    begin
-      for I := 1 to Offset div sizeof(Buf) do
-        ReadBuffer(Buf, sizeof(Buf));
-      ReadBuffer(Buf, Offset mod sizeof(Buf));
-    end;
-  end
-  else
-    raise EDecompressionError.CreateRes(@sInvalidStreamOp);
-  Result := FZRec.total_out;
-end;
-
-
-end.
diff -Nbaur gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/AssemblyInfo.cs gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/AssemblyInfo.cs
--- gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/AssemblyInfo.cs	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/AssemblyInfo.cs	1970-01-01 01:00:00.000000000 +0100
@@ -1,58 +0,0 @@
-using System.Reflection;
-using System.Runtime.CompilerServices;
-
-//
-// General Information about an assembly is controlled through the following
-// set of attributes. Change these attribute values to modify the information
-// associated with an assembly.
-//
-[assembly: AssemblyTitle("DotZLib")]
-[assembly: AssemblyDescription(".Net bindings for ZLib compression dll 1.2.x")]
-[assembly: AssemblyConfiguration("")]
-[assembly: AssemblyCompany("Henrik Ravn")]
-[assembly: AssemblyProduct("")]
-[assembly: AssemblyCopyright("(c) 2004 by Henrik Ravn")]
-[assembly: AssemblyTrademark("")]
-[assembly: AssemblyCulture("")]
-
-//
-// Version information for an assembly consists of the following four values:
-//
-//      Major Version
-//      Minor Version
-//      Build Number
-//      Revision
-//
-// You can specify all the values or you can default the Revision and Build Numbers
-// by using the '*' as shown below:
-
-[assembly: AssemblyVersion("1.0.*")]
-
-//
-// In order to sign your assembly you must specify a key to use. Refer to the
-// Microsoft .NET Framework documentation for more information on assembly signing.
-//
-// Use the attributes below to control which key is used for signing.
-//
-// Notes:
-//   (*) If no key is specified, the assembly is not signed.
-//   (*) KeyName refers to a key that has been installed in the Crypto Service
-//       Provider (CSP) on your machine. KeyFile refers to a file which contains
-//       a key.
-//   (*) If the KeyFile and the KeyName values are both specified, the
-//       following processing occurs:
-//       (1) If the KeyName can be found in the CSP, that key is used.
-//       (2) If the KeyName does not exist and the KeyFile does exist, the key
-//           in the KeyFile is installed into the CSP and used.
-//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
-//       When specifying the KeyFile, the location of the KeyFile should be
-//       relative to the project output directory which is
-//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
-//       located in the project directory, you would specify the AssemblyKeyFile
-//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
-//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
-//       documentation for more information on this.
-//
-[assembly: AssemblyDelaySign(false)]
-[assembly: AssemblyKeyFile("")]
-[assembly: AssemblyKeyName("")]
diff -Nbaur gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/ChecksumImpl.cs gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/ChecksumImpl.cs
--- gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/ChecksumImpl.cs	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/ChecksumImpl.cs	1970-01-01 01:00:00.000000000 +0100
@@ -1,202 +0,0 @@
-//
-//  Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.Runtime.InteropServices;
-using System.Text;
-
-
-namespace DotZLib
-{
-    #region ChecksumGeneratorBase
-    /// <summary>
-    /// Implements the common functionality needed for all <see cref="ChecksumGenerator"/>s
-    /// </summary>
-    /// <example></example>
-    public abstract class ChecksumGeneratorBase : ChecksumGenerator
-    {
-        /// <summary>
-        /// The value of the current checksum
-        /// </summary>
-        protected uint _current;
-
-        /// <summary>
-        /// Initializes a new instance of the checksum generator base - the current checksum is
-        /// set to zero
-        /// </summary>
-        public ChecksumGeneratorBase()
-        {
-            _current = 0;
-        }
-
-        /// <summary>
-        /// Initializes a new instance of the checksum generator basewith a specified value
-        /// </summary>
-        /// <param name="initialValue">The value to set the current checksum to</param>
-        public ChecksumGeneratorBase(uint initialValue)
-        {
-            _current = initialValue;
-        }
-
-        /// <summary>
-        /// Resets the current checksum to zero
-        /// </summary>
-        public void Reset() { _current = 0; }
-
-        /// <summary>
-        /// Gets the current checksum value
-        /// </summary>
-        public uint Value { get { return _current; } }
-
-        /// <summary>
-        /// Updates the current checksum with part of an array of bytes
-        /// </summary>
-        /// <param name="data">The data to update the checksum with</param>
-        /// <param name="offset">Where in <c>data</c> to start updating</param>
-        /// <param name="count">The number of bytes from <c>data</c> to use</param>
-        /// <exception cref="ArgumentException">The sum of offset and count is larger than the length of <c>data</c></exception>
-        /// <exception cref="NullReferenceException"><c>data</c> is a null reference</exception>
-        /// <exception cref="ArgumentOutOfRangeException">Offset or count is negative.</exception>
-        /// <remarks>All the other <c>Update</c> methods are implmeneted in terms of this one.
-        /// This is therefore the only method a derived class has to implement</remarks>
-        public abstract void Update(byte[] data, int offset, int count);
-
-        /// <summary>
-        /// Updates the current checksum with an array of bytes.
-        /// </summary>
-        /// <param name="data">The data to update the checksum with</param>
-        public void Update(byte[] data)
-        {
-            Update(data, 0, data.Length);
-        }
-
-        /// <summary>
-        /// Updates the current checksum with the data from a string
-        /// </summary>
-        /// <param name="data">The string to update the checksum with</param>
-        /// <remarks>The characters in the string are converted by the UTF-8 encoding</remarks>
-        public void Update(string data)
-        {
-			Update(Encoding.UTF8.GetBytes(data));
-        }
-
-        /// <summary>
-        /// Updates the current checksum with the data from a string, using a specific encoding
-        /// </summary>
-        /// <param name="data">The string to update the checksum with</param>
-        /// <param name="encoding">The encoding to use</param>
-        public void Update(string data, Encoding encoding)
-        {
-            Update(encoding.GetBytes(data));
-        }
-
-    }
-    #endregion
-
-    #region CRC32
-    /// <summary>
-    /// Implements a CRC32 checksum generator
-    /// </summary>
-    public sealed class CRC32Checksum : ChecksumGeneratorBase
-    {
-        #region DLL imports
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern uint crc32(uint crc, int data, uint length);
-
-        #endregion
-
-        /// <summary>
-        /// Initializes a new instance of the CRC32 checksum generator
-        /// </summary>
-        public CRC32Checksum() : base() {}
-
-        /// <summary>
-        /// Initializes a new instance of the CRC32 checksum generator with a specified value
-        /// </summary>
-        /// <param name="initialValue">The value to set the current checksum to</param>
-        public CRC32Checksum(uint initialValue) : base(initialValue) {}
-
-        /// <summary>
-        /// Updates the current checksum with part of an array of bytes
-        /// </summary>
-        /// <param name="data">The data to update the checksum with</param>
-        /// <param name="offset">Where in <c>data</c> to start updating</param>
-        /// <param name="count">The number of bytes from <c>data</c> to use</param>
-        /// <exception cref="ArgumentException">The sum of offset and count is larger than the length of <c>data</c></exception>
-        /// <exception cref="NullReferenceException"><c>data</c> is a null reference</exception>
-        /// <exception cref="ArgumentOutOfRangeException">Offset or count is negative.</exception>
-        public override void Update(byte[] data, int offset, int count)
-        {
-            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();
-            if ((offset+count) > data.Length) throw new ArgumentException();
-            GCHandle hData = GCHandle.Alloc(data, GCHandleType.Pinned);
-            try
-            {
-                _current = crc32(_current, hData.AddrOfPinnedObject().ToInt32()+offset, (uint)count);
-            }
-            finally
-            {
-                hData.Free();
-            }
-        }
-
-    }
-    #endregion
-
-    #region Adler
-    /// <summary>
-    /// Implements a checksum generator that computes the Adler checksum on data
-    /// </summary>
-    public sealed class AdlerChecksum : ChecksumGeneratorBase
-    {
-        #region DLL imports
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern uint adler32(uint adler, int data, uint length);
-
-        #endregion
-
-        /// <summary>
-        /// Initializes a new instance of the Adler checksum generator
-        /// </summary>
-        public AdlerChecksum() : base() {}
-
-        /// <summary>
-        /// Initializes a new instance of the Adler checksum generator with a specified value
-        /// </summary>
-        /// <param name="initialValue">The value to set the current checksum to</param>
-        public AdlerChecksum(uint initialValue) : base(initialValue) {}
-
-        /// <summary>
-        /// Updates the current checksum with part of an array of bytes
-        /// </summary>
-        /// <param name="data">The data to update the checksum with</param>
-        /// <param name="offset">Where in <c>data</c> to start updating</param>
-        /// <param name="count">The number of bytes from <c>data</c> to use</param>
-        /// <exception cref="ArgumentException">The sum of offset and count is larger than the length of <c>data</c></exception>
-        /// <exception cref="NullReferenceException"><c>data</c> is a null reference</exception>
-        /// <exception cref="ArgumentOutOfRangeException">Offset or count is negative.</exception>
-        public override void Update(byte[] data, int offset, int count)
-        {
-            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();
-            if ((offset+count) > data.Length) throw new ArgumentException();
-            GCHandle hData = GCHandle.Alloc(data, GCHandleType.Pinned);
-            try
-            {
-                _current = adler32(_current, hData.AddrOfPinnedObject().ToInt32()+offset, (uint)count);
-            }
-            finally
-            {
-                hData.Free();
-            }
-        }
-
-    }
-    #endregion
-
-}
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/CircularBuffer.cs gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/CircularBuffer.cs
--- gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/CircularBuffer.cs	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/CircularBuffer.cs	1970-01-01 01:00:00.000000000 +0100
@@ -1,83 +0,0 @@
-//
-//  Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.Diagnostics;
-
-namespace DotZLib
-{
-
-	/// <summary>
-	/// This class implements a circular buffer
-	/// </summary>
-	internal class CircularBuffer
-	{
-        #region Private data
-        private int _capacity;
-        private int _head;
-        private int _tail;
-        private int _size;
-        private byte[] _buffer;
-        #endregion
-
-        public CircularBuffer(int capacity)
-        {
-            Debug.Assert( capacity > 0 );
-            _buffer = new byte[capacity];
-            _capacity = capacity;
-            _head = 0;
-            _tail = 0;
-            _size = 0;
-        }
-
-        public int Size { get { return _size; } }
-
-        public int Put(byte[] source, int offset, int count)
-        {
-            Debug.Assert( count > 0 );
-            int trueCount = Math.Min(count, _capacity - Size);
-            for (int i = 0; i < trueCount; ++i)
-                _buffer[(_tail+i) % _capacity] = source[offset+i];
-            _tail += trueCount;
-            _tail %= _capacity;
-            _size += trueCount;
-            return trueCount;
-        }
-
-        public bool Put(byte b)
-        {
-            if (Size == _capacity) // no room
-                return false;
-            _buffer[_tail++] = b;
-            _tail %= _capacity;
-            ++_size;
-            return true;
-        }
-
-        public int Get(byte[] destination, int offset, int count)
-        {
-            int trueCount = Math.Min(count,Size);
-            for (int i = 0; i < trueCount; ++i)
-                destination[offset + i] = _buffer[(_head+i) % _capacity];
-            _head += trueCount;
-            _head %= _capacity;
-            _size -= trueCount;
-            return trueCount;
-        }
-
-        public int Get()
-        {
-            if (Size == 0)
-                return -1;
-
-            int result = (int)_buffer[_head++ % _capacity];
-            --_size;
-            return result;
-        }
-
-    }
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/CodecBase.cs gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/CodecBase.cs
--- gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/CodecBase.cs	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/CodecBase.cs	1970-01-01 01:00:00.000000000 +0100
@@ -1,198 +0,0 @@
-//
-//  Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.Runtime.InteropServices;
-
-namespace DotZLib
-{
-	/// <summary>
-	/// Implements the common functionality needed for all <see cref="Codec"/>s
-	/// </summary>
-	public abstract class CodecBase : Codec, IDisposable
-	{
-
-        #region Data members
-
-        /// <summary>
-        /// Instance of the internal zlib buffer structure that is
-        /// passed to all functions in the zlib dll
-        /// </summary>
-        internal ZStream _ztream = new ZStream();
-
-        /// <summary>
-        /// True if the object instance has been disposed, false otherwise
-        /// </summary>
-        protected bool _isDisposed = false;
-
-        /// <summary>
-        /// The size of the internal buffers
-        /// </summary>
-        protected const int kBufferSize = 16384;
-
-        private byte[] _outBuffer = new byte[kBufferSize];
-        private byte[] _inBuffer = new byte[kBufferSize];
-
-        private GCHandle _hInput;
-        private GCHandle _hOutput;
-
-        private uint _checksum = 0;
-
-        #endregion
-
-        /// <summary>
-        /// Initializes a new instance of the <c>CodeBase</c> class.
-        /// </summary>
-		public CodecBase()
-		{
-            try
-            {
-                _hInput = GCHandle.Alloc(_inBuffer, GCHandleType.Pinned);
-                _hOutput = GCHandle.Alloc(_outBuffer, GCHandleType.Pinned);
-            }
-            catch (Exception)
-            {
-                CleanUp(false);
-                throw;
-            }
-        }
-
-
-        #region Codec Members
-
-        /// <summary>
-        /// Occurs when more processed data are available.
-        /// </summary>
-        public event DataAvailableHandler DataAvailable;
-
-        /// <summary>
-        /// Fires the <see cref="DataAvailable"/> event
-        /// </summary>
-        protected void OnDataAvailable()
-        {
-            if (_ztream.total_out > 0)
-            {
-                if (DataAvailable != null)
-                    DataAvailable( _outBuffer, 0, (int)_ztream.total_out);
-                resetOutput();
-            }
-        }
-
-        /// <summary>
-        /// Adds more data to the codec to be processed.
-        /// </summary>
-        /// <param name="data">Byte array containing the data to be added to the codec</param>
-        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
-        public void Add(byte[] data)
-        {
-            Add(data,0,data.Length);
-        }
-
-        /// <summary>
-        /// Adds more data to the codec to be processed.
-        /// </summary>
-        /// <param name="data">Byte array containing the data to be added to the codec</param>
-        /// <param name="offset">The index of the first byte to add from <c>data</c></param>
-        /// <param name="count">The number of bytes to add</param>
-        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
-        /// <remarks>This must be implemented by a derived class</remarks>
-        public abstract void Add(byte[] data, int offset, int count);
-
-        /// <summary>
-        /// Finishes up any pending data that needs to be processed and handled.
-        /// </summary>
-        /// <remarks>This must be implemented by a derived class</remarks>
-        public abstract void Finish();
-
-        /// <summary>
-        /// Gets the checksum of the data that has been added so far
-        /// </summary>
-        public uint Checksum { get { return _checksum; } }
-
-        #endregion
-
-        #region Destructor & IDisposable stuff
-
-        /// <summary>
-        /// Destroys this instance
-        /// </summary>
-        ~CodecBase()
-        {
-            CleanUp(false);
-        }
-
-        /// <summary>
-        /// Releases any unmanaged resources and calls the <see cref="CleanUp()"/> method of the derived class
-        /// </summary>
-        public void Dispose()
-        {
-            CleanUp(true);
-        }
-
-        /// <summary>
-        /// Performs any codec specific cleanup
-        /// </summary>
-        /// <remarks>This must be implemented by a derived class</remarks>
-        protected abstract void CleanUp();
-
-        // performs the release of the handles and calls the dereived CleanUp()
-        private void CleanUp(bool isDisposing)
-        {
-            if (!_isDisposed)
-            {
-                CleanUp();
-                if (_hInput.IsAllocated)
-                    _hInput.Free();
-                if (_hOutput.IsAllocated)
-                    _hOutput.Free();
-
-                _isDisposed = true;
-            }
-        }
-
-
-        #endregion
-
-        #region Helper methods
-
-        /// <summary>
-        /// Copies a number of bytes to the internal codec buffer - ready for proccesing
-        /// </summary>
-        /// <param name="data">The byte array that contains the data to copy</param>
-        /// <param name="startIndex">The index of the first byte to copy</param>
-        /// <param name="count">The number of bytes to copy from <c>data</c></param>
-        protected void copyInput(byte[] data, int startIndex, int count)
-        {
-            Array.Copy(data, startIndex, _inBuffer,0, count);
-            _ztream.next_in = _hInput.AddrOfPinnedObject();
-            _ztream.total_in = 0;
-            _ztream.avail_in = (uint)count;
-
-        }
-
-        /// <summary>
-        /// Resets the internal output buffers to a known state - ready for processing
-        /// </summary>
-        protected void resetOutput()
-        {
-            _ztream.total_out = 0;
-            _ztream.avail_out = kBufferSize;
-            _ztream.next_out = _hOutput.AddrOfPinnedObject();
-        }
-
-        /// <summary>
-        /// Updates the running checksum property
-        /// </summary>
-        /// <param name="newSum">The new checksum value</param>
-        protected void setChecksum(uint newSum)
-        {
-            _checksum = newSum;
-        }
-        #endregion
-
-    }
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/Deflater.cs gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/Deflater.cs
--- gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/Deflater.cs	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/Deflater.cs	1970-01-01 01:00:00.000000000 +0100
@@ -1,106 +0,0 @@
-//
-//  Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.Diagnostics;
-using System.Runtime.InteropServices;
-
-namespace DotZLib
-{
-
-    /// <summary>
-    /// Implements a data compressor, using the deflate algorithm in the ZLib dll
-    /// </summary>
-	public sealed class Deflater : CodecBase
-	{
-        #region Dll imports
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl, CharSet=CharSet.Ansi)]
-        private static extern int deflateInit_(ref ZStream sz, int level, string vs, int size);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int deflate(ref ZStream sz, int flush);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int deflateReset(ref ZStream sz);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int deflateEnd(ref ZStream sz);
-        #endregion
-
-        /// <summary>
-        /// Constructs an new instance of the <c>Deflater</c>
-        /// </summary>
-        /// <param name="level">The compression level to use for this <c>Deflater</c></param>
-		public Deflater(CompressLevel level) : base()
-		{
-            int retval = deflateInit_(ref _ztream, (int)level, Info.Version, Marshal.SizeOf(_ztream));
-            if (retval != 0)
-                throw new ZLibException(retval, "Could not initialize deflater");
-
-            resetOutput();
-		}
-
-        /// <summary>
-        /// Adds more data to the codec to be processed.
-        /// </summary>
-        /// <param name="data">Byte array containing the data to be added to the codec</param>
-        /// <param name="offset">The index of the first byte to add from <c>data</c></param>
-        /// <param name="count">The number of bytes to add</param>
-        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
-        public override void Add(byte[] data, int offset, int count)
-        {
-            if (data == null) throw new ArgumentNullException();
-            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();
-            if ((offset+count) > data.Length) throw new ArgumentException();
-
-            int total = count;
-            int inputIndex = offset;
-            int err = 0;
-
-            while (err >= 0 && inputIndex < total)
-            {
-                copyInput(data, inputIndex, Math.Min(total - inputIndex, kBufferSize));
-                while (err >= 0 && _ztream.avail_in > 0)
-                {
-                    err = deflate(ref _ztream, (int)FlushTypes.None);
-                    if (err == 0)
-                        while (_ztream.avail_out == 0)
-                        {
-                            OnDataAvailable();
-                            err = deflate(ref _ztream, (int)FlushTypes.None);
-                        }
-                    inputIndex += (int)_ztream.total_in;
-                }
-            }
-            setChecksum( _ztream.adler );
-        }
-
-
-        /// <summary>
-        /// Finishes up any pending data that needs to be processed and handled.
-        /// </summary>
-        public override void Finish()
-        {
-            int err;
-            do
-            {
-                err = deflate(ref _ztream, (int)FlushTypes.Finish);
-                OnDataAvailable();
-            }
-            while (err == 0);
-            setChecksum( _ztream.adler );
-            deflateReset(ref _ztream);
-            resetOutput();
-        }
-
-        /// <summary>
-        /// Closes the internal zlib deflate stream
-        /// </summary>
-        protected override void CleanUp() { deflateEnd(ref _ztream); }
-
-    }
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/DotZLib.cs gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/DotZLib.cs
--- gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/DotZLib.cs	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/DotZLib.cs	1970-01-01 01:00:00.000000000 +0100
@@ -1,288 +0,0 @@
-//
-//  Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.IO;
-using System.Runtime.InteropServices;
-using System.Text;
-
-
-namespace DotZLib
-{
-
-    #region Internal types
-
-    /// <summary>
-    /// Defines constants for the various flush types used with zlib
-    /// </summary>
-    internal enum FlushTypes
-    {
-        None,  Partial,  Sync,  Full,  Finish,  Block
-    }
-
-    #region ZStream structure
-    // internal mapping of the zlib zstream structure for marshalling
-    [StructLayoutAttribute(LayoutKind.Sequential, Pack=4, Size=0, CharSet=CharSet.Ansi)]
-    internal struct ZStream
-    {
-        public IntPtr next_in;
-        public uint avail_in;
-        public uint total_in;
-
-        public IntPtr next_out;
-        public uint avail_out;
-        public uint total_out;
-
-        [MarshalAs(UnmanagedType.LPStr)]
-        string msg;
-        uint state;
-
-        uint zalloc;
-        uint zfree;
-        uint opaque;
-
-        int data_type;
-        public uint adler;
-        uint reserved;
-    }
-
-    #endregion
-
-    #endregion
-
-    #region Public enums
-    /// <summary>
-    /// Defines constants for the available compression levels in zlib
-    /// </summary>
-    public enum CompressLevel : int
-    {
-        /// <summary>
-        /// The default compression level with a reasonable compromise between compression and speed
-        /// </summary>
-        Default = -1,
-        /// <summary>
-        /// No compression at all. The data are passed straight through.
-        /// </summary>
-        None = 0,
-        /// <summary>
-        /// The maximum compression rate available.
-        /// </summary>
-        Best = 9,
-        /// <summary>
-        /// The fastest available compression level.
-        /// </summary>
-        Fastest = 1
-    }
-    #endregion
-
-    #region Exception classes
-    /// <summary>
-    /// The exception that is thrown when an error occurs on the zlib dll
-    /// </summary>
-    public class ZLibException : ApplicationException
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="ZLibException"/> class with a specified
-        /// error message and error code
-        /// </summary>
-        /// <param name="errorCode">The zlib error code that caused the exception</param>
-        /// <param name="msg">A message that (hopefully) describes the error</param>
-        public ZLibException(int errorCode, string msg) : base(String.Format("ZLib error {0} {1}", errorCode, msg))
-        {
-        }
-
-        /// <summary>
-        /// Initializes a new instance of the <see cref="ZLibException"/> class with a specified
-        /// error code
-        /// </summary>
-        /// <param name="errorCode">The zlib error code that caused the exception</param>
-        public ZLibException(int errorCode) : base(String.Format("ZLib error {0}", errorCode))
-        {
-        }
-    }
-    #endregion
-
-    #region Interfaces
-
-    /// <summary>
-    /// Declares methods and properties that enables a running checksum to be calculated
-    /// </summary>
-    public interface ChecksumGenerator
-    {
-        /// <summary>
-        /// Gets the current value of the checksum
-        /// </summary>
-        uint Value { get; }
-
-        /// <summary>
-        /// Clears the current checksum to 0
-        /// </summary>
-        void Reset();
-
-        /// <summary>
-        /// Updates the current checksum with an array of bytes
-        /// </summary>
-        /// <param name="data">The data to update the checksum with</param>
-        void Update(byte[] data);
-
-        /// <summary>
-        /// Updates the current checksum with part of an array of bytes
-        /// </summary>
-        /// <param name="data">The data to update the checksum with</param>
-        /// <param name="offset">Where in <c>data</c> to start updating</param>
-        /// <param name="count">The number of bytes from <c>data</c> to use</param>
-        /// <exception cref="ArgumentException">The sum of offset and count is larger than the length of <c>data</c></exception>
-        /// <exception cref="ArgumentNullException"><c>data</c> is a null reference</exception>
-        /// <exception cref="ArgumentOutOfRangeException">Offset or count is negative.</exception>
-        void Update(byte[] data, int offset, int count);
-
-        /// <summary>
-        /// Updates the current checksum with the data from a string
-        /// </summary>
-        /// <param name="data">The string to update the checksum with</param>
-        /// <remarks>The characters in the string are converted by the UTF-8 encoding</remarks>
-        void Update(string data);
-
-        /// <summary>
-        /// Updates the current checksum with the data from a string, using a specific encoding
-        /// </summary>
-        /// <param name="data">The string to update the checksum with</param>
-        /// <param name="encoding">The encoding to use</param>
-        void Update(string data, Encoding encoding);
-    }
-
-
-    /// <summary>
-    /// Represents the method that will be called from a codec when new data
-    /// are available.
-    /// </summary>
-    /// <paramref name="data">The byte array containing the processed data</paramref>
-    /// <paramref name="startIndex">The index of the first processed byte in <c>data</c></paramref>
-    /// <paramref name="count">The number of processed bytes available</paramref>
-    /// <remarks>On return from this method, the data may be overwritten, so grab it while you can.
-    /// You cannot assume that startIndex will be zero.
-    /// </remarks>
-    public delegate void DataAvailableHandler(byte[] data, int startIndex, int count);
-
-    /// <summary>
-    /// Declares methods and events for implementing compressors/decompressors
-    /// </summary>
-    public interface Codec
-    {
-        /// <summary>
-        /// Occurs when more processed data are available.
-        /// </summary>
-        event DataAvailableHandler DataAvailable;
-
-        /// <summary>
-        /// Adds more data to the codec to be processed.
-        /// </summary>
-        /// <param name="data">Byte array containing the data to be added to the codec</param>
-        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
-        void Add(byte[] data);
-
-        /// <summary>
-        /// Adds more data to the codec to be processed.
-        /// </summary>
-        /// <param name="data">Byte array containing the data to be added to the codec</param>
-        /// <param name="offset">The index of the first byte to add from <c>data</c></param>
-        /// <param name="count">The number of bytes to add</param>
-        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
-        void Add(byte[] data, int offset, int count);
-
-        /// <summary>
-        /// Finishes up any pending data that needs to be processed and handled.
-        /// </summary>
-        void Finish();
-
-        /// <summary>
-        /// Gets the checksum of the data that has been added so far
-        /// </summary>
-        uint Checksum { get; }
-
-
-    }
-
-    #endregion
-
-    #region Classes
-    /// <summary>
-    /// Encapsulates general information about the ZLib library
-    /// </summary>
-    public class Info
-    {
-        #region DLL imports
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern uint zlibCompileFlags();
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern string zlibVersion();
-        #endregion
-
-        #region Private stuff
-        private uint _flags;
-
-        // helper function that unpacks a bitsize mask
-        private static int bitSize(uint bits)
-        {
-            switch (bits)
-            {
-                case 0: return 16;
-                case 1: return 32;
-                case 2: return 64;
-            }
-            return -1;
-        }
-        #endregion
-
-        /// <summary>
-        /// Constructs an instance of the <c>Info</c> class.
-        /// </summary>
-        public Info()
-        {
-            _flags = zlibCompileFlags();
-        }
-
-        /// <summary>
-        /// True if the library is compiled with debug info
-        /// </summary>
-        public bool HasDebugInfo { get { return 0 != (_flags & 0x100); } }
-
-        /// <summary>
-        /// True if the library is compiled with assembly optimizations
-        /// </summary>
-        public bool UsesAssemblyCode { get { return 0 != (_flags & 0x200); } }
-
-        /// <summary>
-        /// Gets the size of the unsigned int that was compiled into Zlib
-        /// </summary>
-        public int SizeOfUInt { get { return bitSize(_flags & 3); } }
-
-        /// <summary>
-        /// Gets the size of the unsigned long that was compiled into Zlib
-        /// </summary>
-        public int SizeOfULong { get { return bitSize((_flags >> 2) & 3); } }
-
-        /// <summary>
-        /// Gets the size of the pointers that were compiled into Zlib
-        /// </summary>
-        public int SizeOfPointer { get { return bitSize((_flags >> 4) & 3); } }
-
-        /// <summary>
-        /// Gets the size of the z_off_t type that was compiled into Zlib
-        /// </summary>
-        public int SizeOfOffset { get { return bitSize((_flags >> 6) & 3); } }
-
-        /// <summary>
-        /// Gets the version of ZLib as a string, e.g. "1.2.1"
-        /// </summary>
-        public static string Version { get { return zlibVersion(); } }
-    }
-
-    #endregion
-
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/DotZLib.csproj gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/DotZLib.csproj
--- gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/DotZLib.csproj	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/DotZLib.csproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,141 +0,0 @@
-<VisualStudioProject>
-    <CSHARP
-        ProjectType = "Local"
-        ProductVersion = "7.10.3077"
-        SchemaVersion = "2.0"
-        ProjectGuid = "{BB1EE0B1-1808-46CB-B786-949D91117FC5}"
-    >
-        <Build>
-            <Settings
-                ApplicationIcon = ""
-                AssemblyKeyContainerName = ""
-                AssemblyName = "DotZLib"
-                AssemblyOriginatorKeyFile = ""
-                DefaultClientScript = "JScript"
-                DefaultHTMLPageLayout = "Grid"
-                DefaultTargetSchema = "IE50"
-                DelaySign = "false"
-                OutputType = "Library"
-                PreBuildEvent = ""
-                PostBuildEvent = ""
-                RootNamespace = "DotZLib"
-                RunPostBuildEvent = "OnBuildSuccess"
-                StartupObject = ""
-            >
-                <Config
-                    Name = "Debug"
-                    AllowUnsafeBlocks = "false"
-                    BaseAddress = "285212672"
-                    CheckForOverflowUnderflow = "false"
-                    ConfigurationOverrideFile = ""
-                    DefineConstants = "DEBUG;TRACE"
-                    DocumentationFile = "docs\DotZLib.xml"
-                    DebugSymbols = "true"
-                    FileAlignment = "4096"
-                    IncrementalBuild = "false"
-                    NoStdLib = "false"
-                    NoWarn = "1591"
-                    Optimize = "false"
-                    OutputPath = "bin\Debug\"
-                    RegisterForComInterop = "false"
-                    RemoveIntegerChecks = "false"
-                    TreatWarningsAsErrors = "false"
-                    WarningLevel = "4"
-                />
-                <Config
-                    Name = "Release"
-                    AllowUnsafeBlocks = "false"
-                    BaseAddress = "285212672"
-                    CheckForOverflowUnderflow = "false"
-                    ConfigurationOverrideFile = ""
-                    DefineConstants = "TRACE"
-                    DocumentationFile = "docs\DotZLib.xml"
-                    DebugSymbols = "false"
-                    FileAlignment = "4096"
-                    IncrementalBuild = "false"
-                    NoStdLib = "false"
-                    NoWarn = ""
-                    Optimize = "true"
-                    OutputPath = "bin\Release\"
-                    RegisterForComInterop = "false"
-                    RemoveIntegerChecks = "false"
-                    TreatWarningsAsErrors = "false"
-                    WarningLevel = "4"
-                />
-            </Settings>
-            <References>
-                <Reference
-                    Name = "System"
-                    AssemblyName = "System"
-                    HintPath = "C:\WINNT\Microsoft.NET\Framework\v1.1.4322\System.dll"
-                />
-                <Reference
-                    Name = "System.Data"
-                    AssemblyName = "System.Data"
-                    HintPath = "C:\WINNT\Microsoft.NET\Framework\v1.1.4322\System.Data.dll"
-                />
-                <Reference
-                    Name = "System.XML"
-                    AssemblyName = "System.Xml"
-                    HintPath = "C:\WINNT\Microsoft.NET\Framework\v1.1.4322\System.XML.dll"
-                />
-                <Reference
-                    Name = "nunit.framework"
-                    AssemblyName = "nunit.framework"
-                    HintPath = "E:\apps\NUnit V2.1\\bin\nunit.framework.dll"
-                    AssemblyFolderKey = "hklm\dn\nunit.framework"
-                />
-            </References>
-        </Build>
-        <Files>
-            <Include>
-                <File
-                    RelPath = "AssemblyInfo.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "ChecksumImpl.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "CircularBuffer.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "CodecBase.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "Deflater.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "DotZLib.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "GZipStream.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "Inflater.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "UnitTests.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-            </Include>
-        </Files>
-    </CSHARP>
-</VisualStudioProject>
-
diff -Nbaur gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/GZipStream.cs gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/GZipStream.cs
--- gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/GZipStream.cs	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/GZipStream.cs	1970-01-01 01:00:00.000000000 +0100
@@ -1,301 +0,0 @@
-//
-//  Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.IO;
-using System.Runtime.InteropServices;
-
-namespace DotZLib
-{
-	/// <summary>
-	/// Implements a compressed <see cref="Stream"/>, in GZip (.gz) format.
-	/// </summary>
-	public class GZipStream : Stream, IDisposable
-	{
-        #region Dll Imports
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl, CharSet=CharSet.Ansi)]
-        private static extern IntPtr gzopen(string name, string mode);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int gzclose(IntPtr gzFile);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int gzwrite(IntPtr gzFile, int data, int length);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int gzread(IntPtr gzFile, int data, int length);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int gzgetc(IntPtr gzFile);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int gzputc(IntPtr gzFile, int c);
-
-        #endregion
-
-        #region Private data
-        private IntPtr _gzFile;
-        private bool _isDisposed = false;
-        private bool _isWriting;
-        #endregion
-
-        #region Constructors
-        /// <summary>
-        /// Creates a new file as a writeable GZipStream
-        /// </summary>
-        /// <param name="fileName">The name of the compressed file to create</param>
-        /// <param name="level">The compression level to use when adding data</param>
-        /// <exception cref="ZLibException">If an error occurred in the internal zlib function</exception>
-		public GZipStream(string fileName, CompressLevel level)
-		{
-            _isWriting = true;
-            _gzFile = gzopen(fileName, String.Format("wb{0}", (int)level));
-            if (_gzFile == IntPtr.Zero)
-                throw new ZLibException(-1, "Could not open " + fileName);
-		}
-
-        /// <summary>
-        /// Opens an existing file as a readable GZipStream
-        /// </summary>
-        /// <param name="fileName">The name of the file to open</param>
-        /// <exception cref="ZLibException">If an error occurred in the internal zlib function</exception>
-        public GZipStream(string fileName)
-        {
-            _isWriting = false;
-            _gzFile = gzopen(fileName, "rb");
-            if (_gzFile == IntPtr.Zero)
-                throw new ZLibException(-1, "Could not open " + fileName);
-
-        }
-        #endregion
-
-        #region Access properties
-        /// <summary>
-        /// Returns true of this stream can be read from, false otherwise
-        /// </summary>
-        public override bool CanRead
-        {
-            get
-            {
-                return !_isWriting;
-            }
-        }
-
-
-        /// <summary>
-        /// Returns false.
-        /// </summary>
-        public override bool CanSeek
-        {
-            get
-            {
-                return false;
-            }
-        }
-
-        /// <summary>
-        /// Returns true if this tsream is writeable, false otherwise
-        /// </summary>
-        public override bool CanWrite
-        {
-            get
-            {
-                return _isWriting;
-            }
-        }
-        #endregion
-
-        #region Destructor & IDispose stuff
-
-        /// <summary>
-        /// Destroys this instance
-        /// </summary>
-        ~GZipStream()
-        {
-            cleanUp(false);
-        }
-
-        /// <summary>
-        /// Closes the external file handle
-        /// </summary>
-        public void Dispose()
-        {
-            cleanUp(true);
-        }
-
-        // Does the actual closing of the file handle.
-        private void cleanUp(bool isDisposing)
-        {
-            if (!_isDisposed)
-            {
-                gzclose(_gzFile);
-                _isDisposed = true;
-            }
-        }
-        #endregion
-
-        #region Basic reading and writing
-        /// <summary>
-        /// Attempts to read a number of bytes from the stream.
-        /// </summary>
-        /// <param name="buffer">The destination data buffer</param>
-        /// <param name="offset">The index of the first destination byte in <c>buffer</c></param>
-        /// <param name="count">The number of bytes requested</param>
-        /// <returns>The number of bytes read</returns>
-        /// <exception cref="ArgumentNullException">If <c>buffer</c> is null</exception>
-        /// <exception cref="ArgumentOutOfRangeException">If <c>count</c> or <c>offset</c> are negative</exception>
-        /// <exception cref="ArgumentException">If <c>offset</c>  + <c>count</c> is &gt; buffer.Length</exception>
-        /// <exception cref="NotSupportedException">If this stream is not readable.</exception>
-        /// <exception cref="ObjectDisposedException">If this stream has been disposed.</exception>
-        public override int Read(byte[] buffer, int offset, int count)
-        {
-            if (!CanRead) throw new NotSupportedException();
-            if (buffer == null) throw new ArgumentNullException();
-            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();
-            if ((offset+count) > buffer.Length) throw new ArgumentException();
-            if (_isDisposed) throw new ObjectDisposedException("GZipStream");
-
-            GCHandle h = GCHandle.Alloc(buffer, GCHandleType.Pinned);
-            int result;
-            try
-            {
-                result = gzread(_gzFile, h.AddrOfPinnedObject().ToInt32() + offset, count);
-                if (result < 0)
-                    throw new IOException();
-            }
-            finally
-            {
-                h.Free();
-            }
-            return result;
-        }
-
-        /// <summary>
-        /// Attempts to read a single byte from the stream.
-        /// </summary>
-        /// <returns>The byte that was read, or -1 in case of error or End-Of-File</returns>
-        public override int ReadByte()
-        {
-            if (!CanRead) throw new NotSupportedException();
-            if (_isDisposed) throw new ObjectDisposedException("GZipStream");
-            return gzgetc(_gzFile);
-        }
-
-        /// <summary>
-        /// Writes a number of bytes to the stream
-        /// </summary>
-        /// <param name="buffer"></param>
-        /// <param name="offset"></param>
-        /// <param name="count"></param>
-        /// <exception cref="ArgumentNullException">If <c>buffer</c> is null</exception>
-        /// <exception cref="ArgumentOutOfRangeException">If <c>count</c> or <c>offset</c> are negative</exception>
-        /// <exception cref="ArgumentException">If <c>offset</c>  + <c>count</c> is &gt; buffer.Length</exception>
-        /// <exception cref="NotSupportedException">If this stream is not writeable.</exception>
-        /// <exception cref="ObjectDisposedException">If this stream has been disposed.</exception>
-        public override void Write(byte[] buffer, int offset, int count)
-        {
-            if (!CanWrite) throw new NotSupportedException();
-            if (buffer == null) throw new ArgumentNullException();
-            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();
-            if ((offset+count) > buffer.Length) throw new ArgumentException();
-            if (_isDisposed) throw new ObjectDisposedException("GZipStream");
-
-            GCHandle h = GCHandle.Alloc(buffer, GCHandleType.Pinned);
-            try
-            {
-                int result = gzwrite(_gzFile, h.AddrOfPinnedObject().ToInt32() + offset, count);
-                if (result < 0)
-                    throw new IOException();
-            }
-            finally
-            {
-                h.Free();
-            }
-        }
-
-        /// <summary>
-        /// Writes a single byte to the stream
-        /// </summary>
-        /// <param name="value">The byte to add to the stream.</param>
-        /// <exception cref="NotSupportedException">If this stream is not writeable.</exception>
-        /// <exception cref="ObjectDisposedException">If this stream has been disposed.</exception>
-        public override void WriteByte(byte value)
-        {
-            if (!CanWrite) throw new NotSupportedException();
-            if (_isDisposed) throw new ObjectDisposedException("GZipStream");
-
-            int result = gzputc(_gzFile, (int)value);
-            if (result < 0)
-                throw new IOException();
-        }
-        #endregion
-
-        #region Position & length stuff
-        /// <summary>
-        /// Not supported.
-        /// </summary>
-        /// <param name="value"></param>
-        /// <exception cref="NotSupportedException">Always thrown</exception>
-        public override void SetLength(long value)
-        {
-            throw new NotSupportedException();
-        }
-
-        /// <summary>
-        ///  Not suppported.
-        /// </summary>
-        /// <param name="offset"></param>
-        /// <param name="origin"></param>
-        /// <returns></returns>
-        /// <exception cref="NotSupportedException">Always thrown</exception>
-        public override long Seek(long offset, SeekOrigin origin)
-        {
-            throw new NotSupportedException();
-        }
-
-        /// <summary>
-        /// Flushes the <c>GZipStream</c>.
-        /// </summary>
-        /// <remarks>In this implementation, this method does nothing. This is because excessive
-        /// flushing may degrade the achievable compression rates.</remarks>
-        public override void Flush()
-        {
-            // left empty on purpose
-        }
-
-        /// <summary>
-        /// Gets/sets the current position in the <c>GZipStream</c>. Not suppported.
-        /// </summary>
-        /// <remarks>In this implementation this property is not supported</remarks>
-        /// <exception cref="NotSupportedException">Always thrown</exception>
-        public override long Position
-        {
-            get
-            {
-                throw new NotSupportedException();
-            }
-            set
-            {
-                throw new NotSupportedException();
-            }
-        }
-
-        /// <summary>
-        /// Gets the size of the stream. Not suppported.
-        /// </summary>
-        /// <remarks>In this implementation this property is not supported</remarks>
-        /// <exception cref="NotSupportedException">Always thrown</exception>
-        public override long Length
-        {
-            get
-            {
-                throw new NotSupportedException();
-            }
-        }
-        #endregion
-    }
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/Inflater.cs gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/Inflater.cs
--- gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/Inflater.cs	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/Inflater.cs	1970-01-01 01:00:00.000000000 +0100
@@ -1,105 +0,0 @@
-//
-//  Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.Diagnostics;
-using System.Runtime.InteropServices;
-
-namespace DotZLib
-{
-
-    /// <summary>
-    /// Implements a data decompressor, using the inflate algorithm in the ZLib dll
-    /// </summary>
-    public class Inflater : CodecBase
-	{
-        #region Dll imports
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl, CharSet=CharSet.Ansi)]
-        private static extern int inflateInit_(ref ZStream sz, string vs, int size);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int inflate(ref ZStream sz, int flush);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int inflateReset(ref ZStream sz);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int inflateEnd(ref ZStream sz);
-        #endregion
-
-        /// <summary>
-        /// Constructs an new instance of the <c>Inflater</c>
-        /// </summary>
-        public Inflater() : base()
-		{
-            int retval = inflateInit_(ref _ztream, Info.Version, Marshal.SizeOf(_ztream));
-            if (retval != 0)
-                throw new ZLibException(retval, "Could not initialize inflater");
-
-            resetOutput();
-        }
-
-
-        /// <summary>
-        /// Adds more data to the codec to be processed.
-        /// </summary>
-        /// <param name="data">Byte array containing the data to be added to the codec</param>
-        /// <param name="offset">The index of the first byte to add from <c>data</c></param>
-        /// <param name="count">The number of bytes to add</param>
-        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
-        public override void Add(byte[] data, int offset, int count)
-        {
-            if (data == null) throw new ArgumentNullException();
-            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();
-            if ((offset+count) > data.Length) throw new ArgumentException();
-
-            int total = count;
-            int inputIndex = offset;
-            int err = 0;
-
-            while (err >= 0 && inputIndex < total)
-            {
-                copyInput(data, inputIndex, Math.Min(total - inputIndex, kBufferSize));
-                err = inflate(ref _ztream, (int)FlushTypes.None);
-                if (err == 0)
-                    while (_ztream.avail_out == 0)
-                    {
-                        OnDataAvailable();
-                        err = inflate(ref _ztream, (int)FlushTypes.None);
-                    }
-
-                inputIndex += (int)_ztream.total_in;
-            }
-            setChecksum( _ztream.adler );
-        }
-
-
-        /// <summary>
-        /// Finishes up any pending data that needs to be processed and handled.
-        /// </summary>
-        public override void Finish()
-        {
-            int err;
-            do
-            {
-                err = inflate(ref _ztream, (int)FlushTypes.Finish);
-                OnDataAvailable();
-            }
-            while (err == 0);
-            setChecksum( _ztream.adler );
-            inflateReset(ref _ztream);
-            resetOutput();
-        }
-
-        /// <summary>
-        /// Closes the internal zlib inflate stream
-        /// </summary>
-        protected override void CleanUp() { inflateEnd(ref _ztream); }
-
-
-	}
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/UnitTests.cs gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/UnitTests.cs
--- gcc-4.8.1/zlib/contrib/dotzlib/DotZLib/UnitTests.cs	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib/UnitTests.cs	1970-01-01 01:00:00.000000000 +0100
@@ -1,274 +0,0 @@
-//
-//  Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0.
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.Collections;
-using System.IO;
-
-// uncomment the define below to include unit tests
-//#define nunit
-#if nunit
-using NUnit.Framework;
-
-// Unit tests for the DotZLib class library
-// ----------------------------------------
-//
-// Use this with NUnit 2 from http://www.nunit.org
-//
-
-namespace DotZLibTests
-{
-    using DotZLib;
-
-    // helper methods
-    internal class Utils
-    {
-        public static bool byteArrEqual( byte[] lhs, byte[] rhs )
-        {
-            if (lhs.Length != rhs.Length)
-                return false;
-            for (int i = lhs.Length-1; i >= 0; --i)
-                if (lhs[i] != rhs[i])
-                    return false;
-            return true;
-        }
-
-    }
-
-
-    [TestFixture]
-    public class CircBufferTests
-    {
-        #region Circular buffer tests
-        [Test]
-        public void SinglePutGet()
-        {
-            CircularBuffer buf = new CircularBuffer(10);
-            Assert.AreEqual( 0, buf.Size );
-            Assert.AreEqual( -1, buf.Get() );
-
-            Assert.IsTrue(buf.Put( 1 ));
-            Assert.AreEqual( 1, buf.Size );
-            Assert.AreEqual( 1, buf.Get() );
-            Assert.AreEqual( 0, buf.Size );
-            Assert.AreEqual( -1, buf.Get() );
-        }
-
-        [Test]
-        public void BlockPutGet()
-        {
-            CircularBuffer buf = new CircularBuffer(10);
-            byte[] arr = {1,2,3,4,5,6,7,8,9,10};
-            Assert.AreEqual( 10, buf.Put(arr,0,10) );
-            Assert.AreEqual( 10, buf.Size );
-            Assert.IsFalse( buf.Put(11) );
-            Assert.AreEqual( 1, buf.Get() );
-            Assert.IsTrue( buf.Put(11) );
-
-            byte[] arr2 = (byte[])arr.Clone();
-            Assert.AreEqual( 9, buf.Get(arr2,1,9) );
-            Assert.IsTrue( Utils.byteArrEqual(arr,arr2) );
-        }
-
-        #endregion
-    }
-
-    [TestFixture]
-    public class ChecksumTests
-    {
-        #region CRC32 Tests
-        [Test]
-        public void CRC32_Null()
-        {
-            CRC32Checksum crc32 = new CRC32Checksum();
-            Assert.AreEqual( 0, crc32.Value );
-
-            crc32 = new CRC32Checksum(1);
-            Assert.AreEqual( 1, crc32.Value );
-
-            crc32 = new CRC32Checksum(556);
-            Assert.AreEqual( 556, crc32.Value );
-        }
-
-        [Test]
-        public void CRC32_Data()
-        {
-            CRC32Checksum crc32 = new CRC32Checksum();
-            byte[] data = { 1,2,3,4,5,6,7 };
-            crc32.Update(data);
-            Assert.AreEqual( 0x70e46888, crc32.Value  );
-
-            crc32 = new CRC32Checksum();
-            crc32.Update("penguin");
-            Assert.AreEqual( 0x0e5c1a120, crc32.Value );
-
-            crc32 = new CRC32Checksum(1);
-            crc32.Update("penguin");
-            Assert.AreEqual(0x43b6aa94, crc32.Value);
-
-        }
-        #endregion
-
-        #region Adler tests
-
-        [Test]
-        public void Adler_Null()
-        {
-            AdlerChecksum adler = new AdlerChecksum();
-            Assert.AreEqual(0, adler.Value);
-
-            adler = new AdlerChecksum(1);
-            Assert.AreEqual( 1, adler.Value );
-
-            adler = new AdlerChecksum(556);
-            Assert.AreEqual( 556, adler.Value );
-        }
-
-        [Test]
-        public void Adler_Data()
-        {
-            AdlerChecksum adler = new AdlerChecksum(1);
-            byte[] data = { 1,2,3,4,5,6,7 };
-            adler.Update(data);
-            Assert.AreEqual( 0x5b001d, adler.Value  );
-
-            adler = new AdlerChecksum();
-            adler.Update("penguin");
-            Assert.AreEqual(0x0bcf02f6, adler.Value );
-
-            adler = new AdlerChecksum(1);
-            adler.Update("penguin");
-            Assert.AreEqual(0x0bd602f7, adler.Value);
-
-        }
-        #endregion
-    }
-
-    [TestFixture]
-    public class InfoTests
-    {
-        #region Info tests
-        [Test]
-        public void Info_Version()
-        {
-            Info info = new Info();
-            Assert.AreEqual("1.2.7", Info.Version);
-            Assert.AreEqual(32, info.SizeOfUInt);
-            Assert.AreEqual(32, info.SizeOfULong);
-            Assert.AreEqual(32, info.SizeOfPointer);
-            Assert.AreEqual(32, info.SizeOfOffset);
-        }
-        #endregion
-    }
-
-    [TestFixture]
-    public class DeflateInflateTests
-    {
-        #region Deflate tests
-        [Test]
-        public void Deflate_Init()
-        {
-            using (Deflater def = new Deflater(CompressLevel.Default))
-            {
-            }
-        }
-
-        private ArrayList compressedData = new ArrayList();
-        private uint adler1;
-
-        private ArrayList uncompressedData = new ArrayList();
-        private uint adler2;
-
-        public void CDataAvail(byte[] data, int startIndex, int count)
-        {
-            for (int i = 0; i < count; ++i)
-                compressedData.Add(data[i+startIndex]);
-        }
-
-        [Test]
-        public void Deflate_Compress()
-        {
-            compressedData.Clear();
-
-            byte[] testData = new byte[35000];
-            for (int i = 0; i < testData.Length; ++i)
-                testData[i] = 5;
-
-            using (Deflater def = new Deflater((CompressLevel)5))
-            {
-                def.DataAvailable += new DataAvailableHandler(CDataAvail);
-                def.Add(testData);
-                def.Finish();
-                adler1 = def.Checksum;
-            }
-        }
-        #endregion
-
-        #region Inflate tests
-        [Test]
-        public void Inflate_Init()
-        {
-            using (Inflater inf = new Inflater())
-            {
-            }
-        }
-
-        private void DDataAvail(byte[] data, int startIndex, int count)
-        {
-            for (int i = 0; i < count; ++i)
-                uncompressedData.Add(data[i+startIndex]);
-        }
-
-        [Test]
-        public void Inflate_Expand()
-        {
-            uncompressedData.Clear();
-
-            using (Inflater inf = new Inflater())
-            {
-                inf.DataAvailable += new DataAvailableHandler(DDataAvail);
-                inf.Add((byte[])compressedData.ToArray(typeof(byte)));
-                inf.Finish();
-                adler2 = inf.Checksum;
-            }
-            Assert.AreEqual( adler1, adler2 );
-        }
-        #endregion
-    }
-
-    [TestFixture]
-    public class GZipStreamTests
-    {
-        #region GZipStream test
-        [Test]
-        public void GZipStream_WriteRead()
-        {
-            using (GZipStream gzOut = new GZipStream("gzstream.gz", CompressLevel.Best))
-            {
-                BinaryWriter writer = new BinaryWriter(gzOut);
-                writer.Write("hi there");
-                writer.Write(Math.PI);
-                writer.Write(42);
-            }
-
-            using (GZipStream gzIn = new GZipStream("gzstream.gz"))
-            {
-                BinaryReader reader = new BinaryReader(gzIn);
-                string s = reader.ReadString();
-                Assert.AreEqual("hi there",s);
-                double d = reader.ReadDouble();
-                Assert.AreEqual(Math.PI, d);
-                int i = reader.ReadInt32();
-                Assert.AreEqual(42,i);
-            }
-
-        }
-        #endregion
-	}
-}
-
-#endif
diff -Nbaur gcc-4.8.1/zlib/contrib/dotzlib/DotZLib.build gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib.build
--- gcc-4.8.1/zlib/contrib/dotzlib/DotZLib.build	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib.build	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="utf-8" ?>
-<project name="DotZLib" default="build" basedir="./DotZLib">
-	<description>A .Net wrapper library around ZLib1.dll</description>
-
-	<property name="nunit.location" value="c:/program files/NUnit V2.1/bin" />
-	<property name="build.root" value="bin" />
-
-	<property name="debug" value="true" />
-	<property name="nunit" value="true" />
-
-	<property name="build.folder" value="${build.root}/debug/" if="${debug}" />
-	<property name="build.folder" value="${build.root}/release/" unless="${debug}" />
-
-	<target name="clean" description="Remove all generated files">
-		<delete dir="${build.root}" failonerror="false" />
-	</target>
-
-	<target name="build" description="compiles the source code">
-
-		<mkdir dir="${build.folder}" />
-		<csc target="library" output="${build.folder}DotZLib.dll" debug="${debug}">
-			<references basedir="${nunit.location}">
-				<includes if="${nunit}" name="nunit.framework.dll" />
-			</references>
-			<sources>
-				<includes name="*.cs" />
-				<excludes name="UnitTests.cs" unless="${nunit}" />
-			</sources>
-			<arg value="/d:nunit" if="${nunit}" />
-		</csc>
-	</target>
-
-</project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/dotzlib/DotZLib.chm gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib.chm
--- gcc-4.8.1/zlib/contrib/dotzlib/DotZLib.chm	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib.chm	1970-01-01 01:00:00.000000000 +0100
@@ -1,213 +0,0 @@
-ITSF   `      LZ  |{ "|{ "`              x       T0      0                         ITSP   T   
-                         	  j].! "T   PMGLA          /   /#IDXHDRy /#ITBITS   	/#STRINGSs/#SYSTEM ,/#TOPICSy`/#URLSTR!R/#URLTBLYH	/#WINDOWS"L/$FIftiMaini	/$OBJINST*?/$WWAssociativeLinks/   /$WWAssociativeLinks/Property&/$WWKeywordLinks/   /$WWKeywordLinks/BTreenL/$WWKeywordLinks/Data:z/$WWKeywordLinks/Map4R/$WWKeywordLinks/Property /Documentation.hhcEx/Documentation.hhk=A/DotZLib.AdlerChecksum.htmlB-/DotZLib.AdlerChecksum.Update_overload_3.htmlyU,/DotZLib.AdlerChecksum.Update_overloads.htmlz&/DotZLib.AdlerChecksumConstructor.html '/DotZLib.AdlerChecksumConstructor1.html?S'/DotZLib.AdlerChecksumConstructor2.htmlm"/DotZLib.AdlerChecksumMembers.htmlXG"/DotZLib.AdlerChecksumMethods.html{/DotZLib.ChecksumGenerator.htmlNL%/DotZLib.ChecksumGenerator.Reset.htmlJ:1/DotZLib.ChecksumGenerator.Update_overload_1.html1/DotZLib.ChecksumGenerator.Update_overload_2.htmlv1/DotZLib.ChecksumGenerator.Update_overload_3.html_1/DotZLib.ChecksumGenerator.Update_overload_4.htmll+0/DotZLib.ChecksumGenerator.Update_overloads.htmlh%/DotZLib.ChecksumGenerator.Value.html<V,/DotZLib.ChecksumGeneratorBase._current.html0d#/DotZLib.ChecksumGeneratorBase.html)L)/DotZLib.ChecksumGeneratorBase.Reset.htmlB5/DotZLib.ChecksumGeneratorBase.Update_overload_1.html<55/DotZLib.ChecksumGeneratorBase.Update_overload_2.html
-25/DotZLib.ChecksumGeneratorBase.Update_overload_3.htmlAI5/DotZLib.ChecksumGeneratorBase.Update_overload_4.html{F4/DotZLib.ChecksumGeneratorBase.Update_overloads.htmlO,)/DotZLib.ChecksumGeneratorBase.Value.htmlXT./DotZLib.ChecksumGeneratorBaseConstructor.htmlND//DotZLib.ChecksumGeneratorBaseConstructor1.html>//DotZLib.ChecksumGeneratorBaseConstructor2.htmlP#)/DotZLib.ChecksumGeneratorBaseFields.htmls=*/DotZLib.ChecksumGeneratorBaseMembers.htmluY*/DotZLib.ChecksumGeneratorBaseMethods.html,a-/DotZLib.ChecksumGeneratorBaseProperties.htmlD&/DotZLib.ChecksumGeneratorMembers.htmlo&/DotZLib.ChecksumGeneratorMethods.html8)/DotZLib.ChecksumGeneratorProperties.html	3"/DotZLib.Codec.Add_overload_1.htmlb"/DotZLib.Codec.Add_overload_2.htmlJK!/DotZLib.Codec.Add_overloads.html!)/DotZLib.Codec.Checksum.html'A!/DotZLib.Codec.DataAvailable.htmlt&/DotZLib.Codec.Finish.htmlw1/DotZLib.Codec.htmlqm#/DotZLib.CodecBase._isDisposed.htmlI[&/DotZLib.CodecBase.Add_overload_1.htmlz&/DotZLib.CodecBase.Add_overload_2.html3G%/DotZLib.CodecBase.Add_overloads.html`S /DotZLib.CodecBase.Checksum.html\4/DotZLib.CodecBase.CleanUp.html!/DotZLib.CodecBase.copyInput.htmlJ%/DotZLib.CodecBase.DataAvailable.htmla#/DotZLib.CodecBase.Dispose.htmlZ# /DotZLib.CodecBase.Finalize.html}*/DotZLib.CodecBase.Finish.html'y/DotZLib.CodecBase.html1#/DotZLib.CodecBase.kBufferSize.html$A'/DotZLib.CodecBase.OnDataAvailable.html o#/DotZLib.CodecBase.resetOutput.html]#/DotZLib.CodecBase.setChecksum.htmll"/DotZLib.CodecBaseConstructor.htmla/DotZLib.CodecBaseEvents.html}d/DotZLib.CodecBaseFields.htmluT/DotZLib.CodecBaseMembers.htmlKI/DotZLib.CodecBaseMethods.htmlP!/DotZLib.CodecBaseProperties.htmlew/DotZLib.CodecEvents.html(L/DotZLib.CodecMembers.html^j/DotZLib.CodecMethods.htmlh9/DotZLib.CodecProperties.htmlH_/DotZLib.CompressLevel.html/DotZLib.CRC32Checksum.htmls-/DotZLib.CRC32Checksum.Update_overload_3.html3U,/DotZLib.CRC32Checksum.Update_overloads.html4&/DotZLib.CRC32ChecksumConstructor.htmlY '/DotZLib.CRC32ChecksumConstructor1.htmlyS'/DotZLib.CRC32ChecksumConstructor2.htmlLm"/DotZLib.CRC32ChecksumMembers.htmlG"/DotZLib.CRC32ChecksumMethods.html9{"/DotZLib.DataAvailableHandler.html<%/DotZLib.Deflater.Add_overload_1.htmlb$/DotZLib.Deflater.Add_overloads.htmlLD/DotZLib.Deflater.CleanUp.htmlr4/DotZLib.Deflater.Finish.html&&                       b@q
-	+	fwuVaJx > f PMGL,          /DotZLib.Deflater.htmlDK!/DotZLib.DeflaterConstructor.html/DotZLib.DeflaterMembers.html/DotZLib.DeflaterMethods.html/ /DotZLib.GZipStream.CanRead.html3f /DotZLib.GZipStream.CanSeek.html7!/DotZLib.GZipStream.CanWrite.htmlPe /DotZLib.GZipStream.Dispose.html|G!/DotZLib.GZipStream.Finalize.htmlC./DotZLib.GZipStream.Flush.htmlqc/DotZLib.GZipStream.htmlLZ/DotZLib.GZipStream.Length.html56!/DotZLib.GZipStream.Position.htmlkd/DotZLib.GZipStream.Read.htmlT7!/DotZLib.GZipStream.ReadByte.html*/DotZLib.GZipStream.Seek.html55"/DotZLib.GZipStream.SetLength.htmljs/DotZLib.GZipStream.Write.html]w"/DotZLib.GZipStream.WriteByte.htmlT#/DotZLib.GZipStreamConstructor.html{`$/DotZLib.GZipStreamConstructor1.html[P$/DotZLib.GZipStreamConstructor2.html+/DotZLib.GZipStreamMembers.html&U/DotZLib.GZipStreamMethods.htmlO-"/DotZLib.GZipStreamProperties.html9z/DotZLib.html9	%/DotZLib.Inflater.Add_overload_1.html`b$/DotZLib.Inflater.Add_overloads.htmlD/DotZLib.Inflater.CleanUp.htmlB4/DotZLib.Inflater.Finish.htmlv&/DotZLib.Inflater.htmlnE!/DotZLib.InflaterConstructor.html9F/DotZLib.InflaterMembers.html3/DotZLib.InflaterMethods.html/DotZLib.Info.HasDebugInfo.html4E/DotZLib.Info.htmlG/DotZLib.Info.SizeOfOffset.htmlyP /DotZLib.Info.SizeOfPointer.htmlIP/DotZLib.Info.SizeOfUInt.htmlJ/DotZLib.Info.SizeOfULong.htmlcN#/DotZLib.Info.UsesAssemblyCode.html1]/DotZLib.Info.Version.htmlB/DotZLib.InfoConstructor.html?/DotZLib.InfoMembers.htmlc;/DotZLib.InfoProperties.html]W/DotZLib.ZLibException.htmlP8&/DotZLib.ZLibExceptionConstructor.html '/DotZLib.ZLibExceptionConstructor1.html$'/DotZLib.ZLibExceptionConstructor2.html&"/DotZLib.ZLibExceptionMembers.html|	/MSDN.css+w/privmethod.gif/protfield.gift/protmethod.gif/protproperty.gif/pubevent.gife/pubmethod.gif~y/pubproperty.gifw}/static.gifw::DataSpace/NameList  <(::DataSpace/Storage/MSCompressed/Content B
-,::DataSpace/Storage/MSCompressed/ControlData j)::DataSpace/Storage/MSCompressed/SpanInfo b/::DataSpace/Storage/MSCompressed/Transform/List <&_::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/   i::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable otZLib.CodecBase.Add_overload_2.html3G%/DotZLib.CodecBase.Add_overloads.html`S /DotZLib.CodecBase.Checksum.html\4/DotZLib.CodecBase.CleanUp.html!/DotZLib.CodecBase.copyInput.htmlJ%/DotZLib.CodecBase.DataAvailable.htmla#/DotZLib.CodecBase.Dispose.htmlZ# /DotZLib.CodecBase.Finalize.html}*/DotZLib.CodecBase.Finish.html'y/DotZLib.CodecBase.html1#/DotZLib.CodecBase.kBufferSize.html$A'/DotZLib.CodecBase.OnDataAvailable.html o#/DotZLib.CodecBase.resetOutput.html]#/DotZLib.CodecBase.setChecksum.htmll"/DotZLib.CodecBaseConstructor.htmla/DotZLib.CodecBaseEvents.html}d/DotZLib.CodecBaseFields.htmluT/DotZLib.CodecBaseMembers.htmlKI/DotZLib.CodecBaseMethods.htmlP!/DotZLib.CodecBaseProperties.htmlew/DotZLib.CodecEvents.html(L/DotZLib.CodecMembers.html^j/DotZLib.CodecMethods.htmlh9/DotZLib.CodecProperties.htmlH_/DotZLib.CompressLevel.html/DotZLib.CRC32Checksum.htmls-/DotZLib.CRC32Checksum.Update_overload_3.html3U,/DotZLib.CRC32Checksum.Update_overloads.html4&/DotZLib.CRC32ChecksumConstructor.htmlY '/DotZLib.CRC32ChecksumConstructor1.htmlyS'/DotZLib.CRC32ChecksumConstructor2.htmlLm"/DotZLib.CRC32ChecksumMembers.htmlG"/DotZLib.CRC32ChecksumMethods.html9{"/DotZLib.DataAvailableHandler.html<%/DotZLib.Deflater.Add_overload_1.htmlb$/DotZLib.Deflater.Add_overloads.htmlLD/DotZLib.Deflater.CleanUp.htmlr4/DotZLib.Deflater.Finish.html&&                       b@q
-Q	/\'t0w B PMGI  / /DotZLib.Deflater.html                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               U n c o m p r e s s e d    M S C o m p r e s s e d   { 7 F C 2 8 9 4 0 - 9 D 3 1 - 1 1 D 0 s        LZXC                         (   s                                 r            z$      1      6      4C      H      V      _      v      T         
-  eLA	  HHA Version 4.74.8702  $ 	                W          DotZLib.html   Documentation   documentation  	 MsdnHelp   c        T#SM"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          3@3  U i?	eM0qC`Y-,1"4o+XG0  #2`E I %eNVB$KKFI,y 'K(([s._(lt)\`vEU AUn	]K  3 53 `o@{m$9v[{lYX6inZ44H"|lcBhI!1@@&@$\ #@D piLqZK!A'KpuIvc`w'F%,`%3Zged2>	$%TfYq5 |;M98VR:TTzxM~{kUIupr[ c>'W&s%5a{V 8@Z OA6 
-H\:&@j!Kja?"pj\UU&Meo
-w6vRP'B8Vr [b3oX"B6Fn@		m BDt=:OQ7Eh5]_7<@Jh=o#O}|mteU)wX#`O3rdR^8Q//xlK%R4!IhV"9%5.K*2Mo5	>?{>af`?>`;z('1 r
-n\No:%aY)`O2%UMMo)HdK	
-Z)|=IId@':!gV%0])
- 1Z1Z;jMR\:DdONxcBcU.l jXAG&|F;)%o$M3p@|vA+P96@}u2X(=)-]ZR-Gm7zrw"&X, XM_on^
-$mJM+Zl6o[^"e1NnX0GJ,z7tU`}VS"QyN/,DX/.	FrQ	4hfD_NdCjo!E0|NhpV,ZpxYZH
- /[/0bX_4|SiFHV'MD4#mI_C0)P`rRRP.Lbn/mn<,
-1~n U7w;a*b#zE:J PEFK+nz]CmF:mz}hjHf,MV	xKd$Qxu2fW!x^ =Q(jq['y{SH2H!QXs$ypk']++CZ8)1]qIUO	n%eIK5gwo@i<;c4e&>uF'b>
-[jB:D@)gZM`..#$&|8-tpTvIXi[5W%i0V^lpsPdroL/vZIGYt/XHoL\c:H{X^PUO1>n?1H([fWvrLz
-+D]+1/_)]\Y,Y\V[4EE1X[mIP.5-[FeXXB	KEhs+:eU rfr#{HKAnFl`g-=Fxrg7&@[:gb2T2&Qu7:q+Z~rPO0$\XH"sxzoI,v;o=T'-K]wvyz)bGiV	R:YOm-YWxgu!]0`$~] LMWsd)Uv_r~7wM{vrjv6@h]vtH	OJu1qj7`7?)$HU-gAbly_E7^g&9 m Nfe`CNpuxgV%7|bD9;3D
-UWs.,7&Q\RbOeVJ& 6Nr|GJ"ETIGKs8=6l"v
-1,;Kf/D~f+:5H/{}x'#"-x>C]Nr7D"O-	U=SK+qE
-}<P~F1cSveQl>A{O@r0HD.\*StVE bC0P|p2'{]>)-g8.i/rqT.nD)'fxc_r{2*g"ua`{i`-J2;HU;eekT]K$%E(X[zoiz,`))7Wg-<MNz<BlBLl`wrz-
-E6{
-I h &J$l0Do4))1B1-+$P.v]M/3+T_A
-gd%Wx	:c1pa>8W/
-boY ~uAmM>nY-:Wu|A%	4t;W>*{	+5>,6=BPRMG-M$/Z+x6a{/=fUrg |wU{O9bB_REnpwIdj]+T1{X%3kTPg64:~\	7d77A|Q]r>=?O)'+T4R( WY@GBC}	mOM;^xXdTn1Z8P_a=2nerGCw*	f"\(WF=2E;Npa+JO-;@]G[v{Y|.%u1A\o!QAp!hJJ]t0ysJBcH-qNptH3 I53G~r"BC)s)"mi2n fF6:5b6<Lc#r}7X_1@.U:d{
-m7 [lTaf@z
-c<eH5tCQ
-D@oaIj3Wc(Qd*yn
-w|:}u|m-Ii]B1fIle1EjQXTn,J@N|!%6r5^Op[i9qh7hx;`hA?nWOcO:
-Ar?7u=}	:l2DHWTP&xo=z7;^3mzF7R#G{j%: 7WsO{%Q_)R\+L W!'	5{58/*K^Z^mVf7p=^6w$TQTw1UHPiRRKyq"grzo (
-Ly~pCo=rEh"z>PPFd@{%mRM+|PP0j#T +?ezX(q[a.{iN*Wb)`:&0#6
-8
-V>TL*^u'?NQn!A:bLgR
-J|QdT|Y|[JqZoI`->qD<XA6q"C>|@i$z:0f^:[Dl
- Q,LT(Ls[G-m~{_Q(a/"p1XtO*4I)HR>BD>z*Ax\ZPA- _A2RQ:./8<Y?*#5P(6
-DoNFQ8<""^h#G	4. 7e&\aL>`D(aYv(}D&6^&ev/ZE-<K?@7$K.H>"	v%f~@y@C9`)x@U(p!Rh68   3@3  oeLAqn1Y-~AvfG   H`+>rCo]vXvwjmk/<ZmxWgn@  !  10?SeYnkiTM3-[tf*4Lx	2 ? ? s)B54cv7'fnj&Q3.YSgf@?AC=y-yZz	E4ej"ZE~tMPv@els; ;\{#D
-RbmC:,^MJ:_{M'	mvZZO902{.-@gT"J
-[K9Yv<';(<qbWBqzDA	P}Cx`YCKE8y/vrIe#Z|&W[s1Z_<GtP!cPc.Pp474;&Tc|+K'VDN:KAVabm/b+;lH!kUO>ccxv[OI:K) 
-Ngt'ZvvX3tbhTV%@
-h8h>$-fM`'1U)+fvbQ!M_bc\svD27g~y5/G3v#Sk7=Fj*~q-#zfV6;gAZh+3g93'A]8F[;Kie`s	1KM?j!@F*,1	=BE7d#t2 :3='$L_Mv;j_?Q1I.<Q"WM:5O8gj3dk|O^	eNCUN%l(S)ph
-D}Vj/ q4Au6F\A/m|cw9/^[/
-<2Yi;l&"]A9Qi1<Ih2s[?1;,~<RLE" *{`>Ga;hL$^OEq"6e-'F=gGw[P1RbG<Q%s8cbKh-8Hm/maXZFKcf$V!E'$)8uR9R0|1YgQ[CU"z^a5bN#Wy\/^TFbVw5$*"'cj>?"0=a3MP~Ep,pT"'P	)Fz@	=oP7GFFX}{a$_Y=!x=hWvGmiIf{5&,LYc2YQ1T4fn YOopL5O`}ePkS!&.e%%\-i2(9s@% ?1$1+*$`!lsB5_Bj8!EL1"Phg4B  $/yR!7y6.B]bKKK"XB|bv|zm-*e:x9ltt~ eDNH:h"i#gK W?=JGSE;h1<-M	dx	%cDR5*K/( t  @   c* @ S.NFnA$u/E.}3n/RjQ>1c[Uw0WR!O`"p.j5L8P&<mZ':h<ZP1x7*69[xnr/F'(3@=/&nw	}JC/^uR<>#L	8Lef}v\r^g]-C
-	'2}cEptAc%5#Axh
-H=I#'	B&t/gkPzAdT43rbzzBE#yZfi7ztn=g8~Ncb&:?o}0MJoBR-O<mE}8t);<j7/c(*
-MF=cVL{g&_o{Qy$ 3kL<w|(b~^l%GK8.3Q1$L|!M^Q0~/
-JnYBDwG#?xZ :h,N&O3eQ,>F? @8)&w0R4w%z {1~k6T*/w n$\SW}&D|DC 47ir-*PP16}}S,On y"  96H*KVWdw/YE;LI
-|
-Oo71NQ,^qxD[s+eiV=`;Vba |eN{] #(G+WwU"o&U[3qb\OQ2X"7U vV`Hk`a`)[476BsEQf50n'5GGBAC';:prQ|R[s,9Gf[DS}GC,l#8Rtl bQkd|z+!B[%[R|*
-*#=, <F>qJzSpuUEjA
-YG	"|PYU*R07nm*gJUQ~=&MX_[UbP#GM'2:HLqWYQ 1CzCkK]~q'ntA/WBk%%(FETH`mDW`T05_~!$tzBdC&
-.w&JEbx,E d<xL ,wU-egzi `&gMKZrO_. c}B`+95N+G8 s$*KU0-@b@4{'"gp^lB%fo(P93.?x/O"XXvu+H`'us8 E>PomlTzFLER{c1[QY2lxLdhbT-T8F;~H`-E&j}ne7/:?v~loh j32l7 <#n|,oq})OE4`(xJ`Q8<*
-y84LxM[$D1	
-21Nm#.E,&RN4B-gh5EyG<w8!ap{HiL6v<8JMHjw9b=.VEq.%j{&0`C#7,T :-#PB7a\!.GACQORKm EfQ]O	Enq9`FZzj"0WQrbJ$XI|HR`yg$z>'+&nZk8aakL^I%`010}`3`mi+$b8iDVQS~`8T@Uz
-`L-b/3dU)C@Iab%GL~fB2 /v	V/PBc[zU*(6dO$:J $P v @   3c@3  e(N ,HG]%)%44C;v  dh  iB	[4$@Uzv-g7no-r=}.'mk.[, ;K @ hf{{[zm(C]JAKF		I	B$XE%~q,~ !+ ~1y;PSv];iYY*LsWl1sxQl.3x#;;]+lvVSc7XDj")+32
-d}Y\2zo35`zYt&%[5|yoh
-bA,^sIU`Xk7rf|4i}9Y![E,ox${JqFb!4'R_-{#)\r44XUb*0e, =e=4
-/A<nW+agL#W2%z4rm?t:"n>#uK/6j=\$ LowuUWe-.:-=Ke^~$Uc};8DT]aaBz`!inHjO'ShojGne)/5*<;}lj)l.>1j`mwF. #@DZ|3[$tHHqF:F}McNA(GHzLMU O83(%0j#r (,iR~6~tYvjIL|QO0Kq&08zQ*{4Nc	8_xk^6nv9Q)'{wSI#S&';SQPl7ku*BMBt0\,]l2{gw*[E-0|T/\vjafdEBl'LA6#ej,}	iz=#UCw-]lhaFvkryqGfN(JwLQE
-=^TJ]~2puJyf`A%Blc/4:i/d?0<&~<uW9GTC`j6^7%JuQ aC`}`.2#7;oqf1a+w@[XQ	NI^whJ"$Ez&[p@7$h`[^<I{)!yB_yk-:Jx'UC)vX6+T3XT}xD	/
-Q`/?Ew'CiW[Jqi	b8q=$8_B:ylK
-+	'9Au
-4A;r_Be&<] o7fL ck8ZnYgu}A&\o~&_')CrS}nS[Mvi#"6oqm"P3H;`d@(]kkM(CG5q>9!1 T"	f`P}q.[~znXj_$'geC9$&)d/0 0P~]&B E`>=\
-)md	+tg%TF|6lMkh[x>$%u`<|}oA1!	&;o}\BqFoT dJ_ M%)Yh'6("6Eq:!DJ@n@Djdr&\*--D@i7a^ef2080@0D*=!97B%iY_f8i|q2{A&(!8c=759Vf=<G[n	&nIW3f,\fcU./z2XscU+4:vWW
- lTC:-~}U/a"JAtnEF}1SA7Y0pW$JVp17 ,D;^Kz>a':5R40Eqs_Q|^n'D9M`mW\d:w6H4_/4\bXkKl/9vC<
-B0O#.MU9fvv1ikv|7U`kt>E=QQj2?R'R,O?v<yW?}i{DtRd.DByE<5HA	17rm3_t v2MRZ7<XePWj)Ip[(==;9&kK[$|qF0 /S$" :}$@<G ^WeGqQJJ&DI9_2}m5?ZC(<_?Alma\8vS/DU;n>!)+s]U $od%9M#snV ,.zgY5_3L?xItLm#Whn, =T^BO?TA,t>tvUj6VbTEzxrOFt_7U4&Wbr:unR'')~Y8J1,~4.^r5933>QFDx	z	W-?em3`^+ $b.7$v<.HN]1^J>+-c!|g&[^
-+PWJrF}<J<-MG{`,RUjB-~EHl!i{@$A^j?| Bq+}X=,hm-
-xo9T9fe19%$6`"BRHyAF4SNsfsJTTE	 >   { T   ;u~2+~((XJVeXq) "Abtx~/y/P?(pa!K6Ja;7&#LLnh.hwW>g0o]UzY?i,y i*+\+.YT uuZO4`
-O5	!VT73v!;=uNMeo.ck!twm2HGi1hz#0~XB { BteJ^8mysUe*wD@hDS4Wj@
-Nt+kzf*U;PsV/*Q\!0L9Y}s($$r]WW<Z{^M5[;0b[WAjHk+y.Z!MSB|#Py
-yC'"b.z.dnVchAI%S	~
-V+f*b96W7oe[H{/>Ry~xelF%Go1YND]/QJ@3|RL_6@ZXNPFw 7 >eZ,5geb3D, >VbI4dfp<3Eh*I`~>'R(b{REL(x\Tl4>tkc(&>!tdCydticoYMx Tv=q-&uJ`RK288I-"y4%Tb?I)9!@r	bpBJyZardeH_M[I 
-   |@  9 w        L%7}f6Qe1;*JIbW?Exxs*80, *( Q!70I>d~KL.4A	D @   304  U i?	
-^5,P({w7emnh_Q   dh  	,c7F&m+;^YsvdqvemV+>bYop  q  )4 Gwv%wWm];UgYTDM$[N!QQ~Dp89#i$hG	EWS$.yTK0&PV`Ujc><c' 62)S"\bXvvL@%'MGJE,}22*LcMm;8#bWeEv^f)<%kR(lw^k3\%##0eYRJ1P:kU.2,Yh-S3^xNrYZ%)'[%2kZRK$kn{j&b>V;~a.E[=N@pX|KjM~h{kw[^c>gfyXE*;.Oy^Kmky:J+X&'iU/dQ5G:vK[(aq092[eNqOc\XZvO7jd-rM}rfG_<'d!1 Z#kXDjTv'"\93< [A8uM #dS(zfj
-/yHR[*lCD&R-dCyyc"r0YmWx5O4:>3*kZkZt-|Zjr=d!+]Sj?aZ,Dm)E)jhsP1xw9Av#;eO\F`3>wGZ!
-!?Cd.XoJD7V)7"V.W.Jo;df2oce%\;c;8_b?"}[-2B\:QWT=/NXOX ^m}=/<fQ.=T%]>F,*]v>5M.RJjvMubKje>	A6cmu/QPmaU]pX>p/t}eI%F/s-s2wg3YG[=2Q]3qYc;d!]gjMHU9$A{-y]i}$c$dMk%Ig/~n /a!et$=) 0F)xW~*f2|#DQ9(]{2].UqZj/,ozi;ma`4xm[j94i`.!Tut b$2_g
- !w/N f)hYWMVOlWx{3]J=I7F^g=I+p[-jC4@<
-(jVmjh4=lZOJ%!	O  CPoks4|M|6a174'M"Yku!?sza:'#8l.5*ZInE%1k~ZsxF;qYf?n!/SjaAPA;!:[pv!DeI1+gpc	+lqivS2@q_oyr$BiC]pw2I~}Gj=(ae(b/4wD5:S-qxBCh	Oi:QuwN/Z}]*>Lr>sn wMX
-}ep]qTsa]GBbGda?b3H^g;$,d(81J<M5@ q;rb:cny7_~y )=;q'Ug E $mCc/f>pnJUu(`~%jT2:vXs|mW~j@:4\];;:<>W6ss1#^nz`wX04R9Ni5?Y3{vt6'HF#(!tHaxY&:2/s?		.* "6{8uZ)Gt>9(0f3nbW	tKvjGG4r	z4j$2o1~[t:%1C~U` DWHE0z@)X$D  }PH;ceB<_l \O{CyP\ZsNr
-P `  Dp H@z(?`M!:([_Q.JkyM/*d ~0XrAW 
-D~(fyH :Vox5!p3OntAXNc[o
-Ox9Kg$L9NK>1O*J2N'>18D`?G$h`LD 4vP)yKJ?AC    ;       4 @  ; d     `    C[	&%KycA^$W>Ih72A:om3^E}f@`AIB\lk^<B|?DPX`;
-hbee$nz%:g[eh
-n63_TD.)5 <Z;d:uuaF1Z}UOW=YsfoQwI.2lg!4Svj[x
-W,?#)')nwp$\m4$(1TT"u>
-jR8$$yRMVWN9`OFD~w&R`kG]d	u5`^5E`J#oJ=le`2]"ost2GV-K@Vo |Yj0$k=A -Y*tj+6,<??U/ `kQf('3<1@G~X )DOmQP= "a(y:	+#T|d
-@GQ2bZ_  u KPy\;}g% S?+Q?Y!93  'D-Hb>|o]F_Fu3lfi|q n,d28nGbG%haM #gLj>`k3~IbD_8"kJaIG"]W)sS
-9\cEd+i)xRMT#Vfbs=HLx>hBBQ\EQ
-	HWwnPuB'+cU?J&Va6*7~N} Qf?H{@AD??1TK0mR?HM96i*de>W"}QE,6wH16Vt,Ht*aB b"UG@+JJ	I&qb40%wVXY-C2#=QwzjC%).'j!1hXb|Q\/Nhu}@if*p7AZh+7MyeIc^$zSI=D/3az"(M6 Pj^hKQ@;iT]YTAUq  HA 
-  ` x* ( (4     4#`5  }puaulwvmTooz{}j4,e0Ff1AZz6 $ jU    Q &%$EHXI4O[JwMBnmnVl;]69FmmzrJ)~y`||*VNEA92(Hi@8  fh n]-]^w-[wJQ29Hb)12QB$A=}L;%rIH@,d9
-0zJ*Jadb9&KB@)9U+Cr"l3Fg9Q!g
-; @)T^%Ftc?g|6	 @d`\<Ria${iTv4)9U*,HY_8~'yB_&%a)ND.4Q`ZH(eL':M3#@KyyJHstD30>k'JE
-RPExDa+v#T!z\ULsBtP	ATPSMIxui[A+uUQX?aOG'PQvhJ=g"gnb->#{YC$h
-CT@$	"8R',dpO2jUgVuUkmUz~vIdV,'pF:Zi2_C|5%*=FNT*n:%25@L|tu.3yC4:[ONKZaW\Y:AnuccN,c$"[W'3u|jtGz^d?nD-Q /uVj\ZzbbarK3?,_v:"~Dw/t";AYl~PRMoFmzLKD\~\A9$J%ucwNM+Vt&e1qj39)N1,-O a#Bn?a6sy4`!NK DHO&T
-[RV\(|s`5\6rJaec>~@1A1m0.T\jjuP=%7f5=\7;V4@GzJ3s?9	]Y7PZs%WyZ5U x*<*qSgipRE@&JT aw:d4P>-#$(+cJr=[ht%D>!MD].:`$E^.teo+pw%/tM9b/hK~ /#7$~O[l#]n4m2n/h{4?&! 6<i-:@iq'f`c|hto:5WfKQTj4f[( ;$K Na!23a	"Tod"D*F;k)Vb6RXq% Z5.% 18>	|= O:".o(Cc?MA+v',Kg.;Cb^w$c9jQT,c#X(.GjV ~e2\ytAA:'b De7fZb%^28+s?i]@-';m	`bZ0s	D5o+[N6RMD:6}}\K:J:B"MZ$#Ls$gx"Mu~%ySgor1~Q/[Qhl{X3^]3H_D;g$"ta?*k>(qU8D:#"ZEIl0-1z=/* cs!0DQD7w[n]F	h{tVh-T^.98[.W#:.tn r-N!Y&dS|dw:HSo01m:)q|17>Qj!3ImrvQ	7FsVN@r[eD%
-<W^4[g]YRpzgIo"'MJsv!rfj@/];Xo
-LY{a6`*l5W
-0'B!2hKI&Zu{eJ!4'`c`p~Bge2g Q,|R7H"q P-t}OcCC9CZ0AWffQ7eoQ*>P}7^xb">&  /x?ovw6 !EqPcD8y Dx{yA G0qZX\&gJEw+*\9Go"<MX,".YP:M$|$q9*UM-?{	H*>b&ki?+FiuJWIu]RY;WTcWTq_Jg]Y|KZ\9m4kuKO1h;]kB`^NE\i9!O&XV3Q"nNIE{h8nuYbZOMFs;Cw`g7D]M(II]2p<?u+cB^A<\~:=#7<  JLgnnka>LG#UnHktLra$yg#5nK
-aaST%QM_)}MY1<QE%;2P{f;6 _SDZ:` 'BE2DToLPE{I#qKu?)eKD51"a?o}ph6tq	Rqb"6FvS?>BM<?klUfLf|;7^Buq!Xa-j4y72I&5ruqF6&>9))5:JE6:1mz$u[]u90#t0rx9{@wM%hp aCtqnN1!X7~ ;1|Yx(/ndW)&2jlU@#P	0>;:hF9QYvdZ*x
-mz5 ir9ml$KHav{du1e|@Z#>j|%f<n/GW\E5:oe*fM#Qg1x? !:vs[o)4	IJX_tE 1!^rex,+$X^<_\KP@SZkiC
-/;h+joi!Js	_KgN5 Bj]#!ifCR.
-1%]d97d!AGEuUWCq9=O
-<o<xnAz>q%P^:Tmf^fJJb{v)kxYk5Qroc]HL-&cN`;ezo5_a3c1F~SLbwL3Wg5lIp~,cU^/?B:<;}=MN-l	zp*kwV0h$mB
-RRW^BOmR1Y1}xTco%|g)R]JKe k"dF2%OFg> nd};Jg/M5Qo$?&'CLmmCC!h"bfKYkZ_$Q7.\}Ir A7^1I#lH4)lEu1#E"Z.ZQLz&rRPG0uT1tR<j<Q%~Bx)CW1&;vTg6m:4'	eh%u+7k6dhnA:y7$$o qIMA&m:92Vb7g.HN{78g2O)R#F"-EAR4IuaVNR[-;?m<f*
-[}YCdCejXM@ZX]\:l~=.h`+u}JCEPQ0GQ=J#G	y.PAT\Phl	AulZEqeQ\hG,ha\CYha#nV9e 'J;"yek?yDXn-GwI9]+>yOU`aD udxt?1|q3\<,Vtd0/=sB(Ife8l 	gR@>cqkZ2p!O@Ory0^\'Sy!ce7	ko7/d|{dra~<'_~`/2^]A']%\30X[>!^#e~_0^o>ywpsAH=0{c~pf|0yg?K?0w<J~:>_G
-?pDk<X0fSRr`yqg_ ~_C5>P8WO1omg'0N\M:^}(qEfY%3t9rh/c|('?%{y3rzpoR8}kyX+<~3#/w1=[S=38;8	/<  	v{  #2`4  _ nm?[jkw>ZVunsn{[QDXW%I@QCdBOI (@J ff |j{6@jd{U[kknnmuoI}Gk/{SmdodG/^>x` @~!   !D+ ={~,fWJ75s3 ~D0p}CmY54x08{JZehlh$JZuupg]pFui?jA,m7b>#VUv//G6=!#{OLYq#jjT;,p9nV}^,`!{iFL/yQEYLbX!aM=/Y5UEL5{_ts1qfi\W	J5B+5|Do~U@#r71~6y6l?&5lH75lH75lLnk!;v7dID)'#'Ph!(AMr8!(
-AQ,qVI"G4GCNhN!("N!Q2DQQ~|bD1,+CFDMEG+Q$dd
-"CM" 3&>My12[%+#HV=?"903&{?i#8$32#pO28Ej2!QpyQox7LSd9<~?ri5;bP6vM.ly9F>SoToA5;.y9n7A'y?;1>x',W3//xpq/!zy,ETN0)*}qx7qbpsf'mJV`ke?Z/;k]_hs/^f;{*~;	nzD~!S{z26RH)OL'1hql :U9]|xDh^ 
-q&	n3vVw9_ID?@m|3zY0/{U	\<]7(m"VjkzXK_E8L096am1P';&09H9YX25?Fd,2w9m5+W&Uj&eB{0W.oU1Ud^WL	}0F=pXR2L~_\Mz\'vP~!nL]D4r'83ql.{60Y@8?#\laj%
-Wv[^}$fH\!,St	gS],x/^|4[AuXE`*7)Cx7+{,$B.~\>#T:n1Hv_;4~fMs:u<&;Q;(4pzP"*	/N/hZR2es:uAyth|G.}\;:|NcNZvzZ8=I$JO3DPodfZ%/<th<wHP\r*!i wg0D|%TM+. d*:]1G*d_gsg^TpSY2W/b"@-13Rc~E)D	Om3R&Ac@w*`b";;/Wm,|i)=Dgs#K0C;1t|Q$
-Qy@>PjM P`aBr+0U>~;;~P?.`XEBI}PS)`Qgvj"wGy;V'tiu'aai9,_tz$wd Y@vPzKLk6Kkgf>hf$-fX5_
-joKn+TrCyuvj]ei*]b`?e3KCG $EBl"4:pCDkdZ_&`x"j;29}YsPtwf:{}{AP,w<zLw?3gkGBQ\](RDD	tHs5y|_h{e&26a-|Ho6=Ks7$X5V]AZQaJdA5(&H+Ho&9d!}}QajFUv pXEH9\S(M;W6{OfM,BV?O-8PY	+Wdx).lm5Q{UmEsKr8hMg>RKmdauJ(
-"/dSd;e1a; s_|{KPQ9%XS2Hde!b Oe(@'jZoWWl5pGb'nn^-3S$Fk> XCwlpW*}X2|x)I[$u:1
-2Cd_' #c:sZDrxzq_H"jS)A5J`C[S?VFnx="]>v
-fpz]`i+\i(oi.{4;+WBir0tU*~L5XCO,679D5;g	96v)+@	wG{&EMurOu0lXjZPid_gmS:e;C$"I[iIliln9ooVab?d{=Lu1fWW{l#.JA.#/irO*u4:+RR*xHA1;+=!.>'m$xa0"T	O+PG h0$`%fqSQoC@KC3C
-GFWxyp!f['j']F	dE?qexy	raK-XBe|cqu;faa]Q*2_PqB1.PPic8fu$V>V0:s^yZT=0Yu\cmBv>k4u5E<0#[)gT{ .e/9|v_8!Y}; \b*0#L/{fDq	lKZaR")e[8[=~zaThBZ]	0XEJw3eW\*o-`#(,_;>c^ QU* 2X<_&ctF47dY6	n#,mvzQH[ }pl5j%74Xue?c.z1SF"_(?
-cFr!;:B+NP*Arj{ps+0m_s
-@'v +*MZe5N0+bc;1TYx/dPw,]P]!,YHtWDMP#5U|_M:sz$]_e\^Y`~E<s?sl?1acv79974rE7V"-JMaD1LH*ss [2	{B`'.j'9BO~^YRG7
-+ &ie71JVP<qwf_!Q~y88.7F2Y|=\u:9g+HJgr-aHy#E  {?s-YxRQFes*g ^s R"z_amIdne`Z*EE.^B&Wg
-i9^:K|)o&$ ?	Jj?d1Q*T)9 =Tm:,=v1$j=-ABi4 p`J{9 wXtfQlbR9C&3 +Q 	nI+n9> 	{EzHNLO3mvgS9a10G~q.Y@pN'Wzq]n1DX`#Qx<mC
-XQ9sAXac	D},60-[^`Y>v5Xc/["m7rp^I.5|SAaM0`!_3O9G Q):'jGTAj'5 5><TSWX)iHk*Zp'eMS3a'I[3^u:L
- ~2;_8jnK.xn^|N_Yo cv1o@oF*TL(sFO5J &kP3RN@HbQ0e>J3U2c hu
-*em2N9F!fH@>eK$XyI7qm	6!7t}jw  .d'pQw N%*S7Xf b;G=dp"6{CQiPTcz`)Lem^Yb,1#.c;f{>	4'[%hy< VYC
-gI5V-p~9o>O7.t/!|`_2HX W'51V Ig|:^,ww 4DgTo1O	$Z",QCRfs	bB~.<H\L4co'f @M~4EDTD"C+B:';p];pw?d3gy}TAfFdVwzSQa782VM!Jb)!)BP6ul
-P( "b-"-rn.b3ib|fPlJSB*+MQ	RQ55C{K5X(Jg)(TR	u6
-Rf'PDATY(OXAn]"%J"#,Q(+?i_RSZT(?nW/36h=MpFI&i76re60%&!4F]uOLf$e<1A13862$%#X)#
-oQ`iRom&vM2g#{-'v;AI;Q& lKNvoy[P'[''4OiM=Mi]'$Oj yMWW|TA?|'jM<pD?ic
-Yy7VL+BM(DIJ$%Q(&1)DII$JQL%bR(ID$JQ&%(<D/SD'&O	/+?}2p5 w  SXCc MDn=cw6pdMHW+JlVHV>,J[<y,,kio[W*#*3"81V\0~	8Ftk?!	55R]iirPU]sI)U@4c^ZS{qzy	Yg   GAc*IAQA9@kz#	]3|srFo9>E]XH!^[=H"?^ni[rDMUOsEn;P*|))J}0
-RoR?WA]A<0<!ptE=V?q=
-vmEQh1s,X>kX<IWqGzXa.\!C96w8mVCSXEqb?WXW{KWq ?k${{bc1ZQ`n7QW9Spv;?&T??Jj<<]jCSYGM J;b]<dn_%``~CdN?O<j~p
-Sh9lSKH],r+#av*!0,{sP;-f] #Dj?j:Rjn]SD U#UU%I$g5Z
--ITHV3Z(H*TI2T-I:THV~0}BL3JTIVSMIS),g%;U;}LX905W7k/Vg/sP[n
-j;*u96Po2sv9nikx-~~]v~.jzMkW,hHZPXCjA8!*+-*bvc^4Ne 2%#kBH<>9-ou fERF@ ##ma~,?#l5r`BcNX:3>r0]-	-92pHZLaVL(sk5_'Ht)>l`{@qmHQyi!m!rLip0(ZMsGdiZ{"/swq(]d1`[P^#86.P2a^1ld-34\ sD~j*edive	<PQ0HuF	owm'F|da%je_'pbL66l'<*}
-`UID\9<M1vqrPguXY:)%Bc,|T#Jj,Ovs1!T):\3>8iI*r]xvMq'm)FvI7<iMw?f</M`F2VC=WXLA;Du?M/P.| ]b@Q]`*Y~3-6 vH/%foH"zL:d{ic%|JmzH$d/J$YVU+ZS9	'W 7cN
-KH5:som	!]J% 4@(y5 >M;Ha< FQ#8%%-ua[
-ZdDk*W":~NL&TR\$E$C_.:&(3!gcEq!1"YGQP$TKU!Kn.dpJyBaKR^FV)lf)0IL%Z:ge)ab1[28._'RzYLNZ)wp3:oD/\`Y?NU6p:t't;G5XL}o'TvS 83/km,6tQ9T0*{1v5NRn3%1-l^XT	a:*T{dS
-/O;]<j/q[(V>nl-FC'R$LuM2<BF`yH!BHX[
-GA
-1 lt@H#i8A3t<Jh!^@O#s	&Wxp!
-$"!i)^qwt"Sg(!I
-h8pm%2c#nIUF\~>rK/=)X7Ap$o]P^U	#~;$b"bbi"1)3WO~*{<"B_4I"a\=-uz~[G<b0JgGVWE>k/[z1P'cc:55w+L]y!a`>X2/xhm:\Q4KHBz"zbk$xPTuMaAPI3.m	'9*(Qjk>CVcQ0pS``K:"Px6PlUeO|"pd%|tb"fSqT_EA'p
-XoI|sC5Fyd2]?GY3uAt2=IZ2)+g:VZZ$'hx0<t5k2:8IAO0[sdv|4xm9-rKn/)Wu9vGD-@7WjyrS82=s"i"B{;(b
->+G>u%fFBS&H[\MN3>I|QC#5Gkp~ {+.^M,%#p7VQhJ|y&u&y7;5=yLIa^=ds(x,w\e}gxBQuu >=!59i5uH`:b#4E%_=ZM=PD+HcW&V2$?@uE\/O0:j7N4d3`s]o^\JW,7V:'H(R8~Pd'W#hfXfffgxU!_Ve>12gN/aBjdjspT9'iF@YzzPW=j$ ;65|r'z2/B&4p}^::y>`Nq'qy0JW9cIMK_3t2ua4 "_&JKm(F<C2AMlG	Z_/p.,Aw-C=G1RqCHIYV?CqSyH_mmz4VjJ:CuB!dx-3R#zn`.~';ezdhZM11(J<cU&r|ds.3FD'c#wQt@f}Gr~[qvqkp\.9@2f
-iy,X~D-/gkv^mgeNA.+SbyN[ikqW(?\?$D^#h`j	waFoQ O&y[:?bDr%@,}\>hN]6><U&dVE5D1@(%Bg)3ZV rkV8T_P#t	&T@b
-?5^b`U\0D7n;2ld$I~KXIf9>loYa<8><8,;\8w9L| ;>[M**Ks.c}|[+gA!& 7 	H%F#<B#~r,K3@v{"w?kHK tBo~:Q)cqX",(Zs@BvqVKMH7HaZ	JN!@2fqm\`vqBr+IhV:S bK26DWskJ# hYv5~69e:]-n'@MURw]]_&6\C/00k(j3?RWU5^n5cIZO)<l`d4$$	* kFY!|++?X{9RaTJ%^nx>*MqCuj*(W n$X!`3M?5GtB}N5NU4g>oSlRhs{c3|}QO x<
-*Q8xe
-/g6b?S`|y>kuqVmn$_cpd&qR:`ItmYSMrMzb@4Cb@qJWyPgLQxTVy)vcN1TF{rkAMq1SyRxK?3aP390(eF+Oe];au!I)wOHx%V"}v;p@c~tT\(.W884|GeFIZD17fJ0.?#!+M{_NH(LQLME?w<u2N_&^`DQi4B<d$sX7ds&cAO
-`j2o<Le9kwB!\9\)$|^)h?gW.UB7B}MOQ_hXo4Mp_~}+]Y{?>}#yp|5z,5z0B`uUDHoM1?|8J0:nAMo"zr;UIy:[B	SRl)I`V{Phf9#WMQHlC,5yc6aJY>JM5~? mQA;y*xphC] mmG5sZv.UHJYNb_!/X-/.-pq4Y6o&x?=Enyf!L	jp7Rs(	T#\#	xbVez7W}"Q	G[IU2 
-&&wpC3& a~U;Lb?<VL	e^~'AK-T:TD<Es=Brx!3#ej7yi
-h%m	A2_W@jvSFMHUn,U<m5Eb	+J[kRBHCTH09uT&[+f'?J{(yLHZQuCaS9RPopt]0nUOk|=r0VdM13`/@P='KZ7J+23>5V*.o',zT1	_jbCj<Z`:2xAyE|O,FG}4k_`::Cyt(/:F333vDM>U?FcN`p'i#	 <u(14Fl+sd6GAz!!q6Jw33<>4|#k{w$,ncm=+c?.0J^Xz'|K+GBxmI~gn~	+?+F8_x%=U,nsV%!WaFKRbom0=Lxi42r/K/T)@["J=']%D=%Rks uR;bFf,[g&RpJb.M+ 3WxP7) AAC_Y$x
-qOT>
-%ZIoR	q5+,4~H2b0qI*bG	W% b$:gK{8sF'2S39d5?Y+	'-(,dp!Lx8 Wi2t'-_jmy 24wwDr+WYw]+Y6[	gs]:q
-0u=8OPDv&4[02sAA/JL][l`BezHcDk	yg0QHGtramAU&X<PC.I`qb>zBZj.k@\<b+fO9SBFzP` w"x\g v@hWL	N{T PjT*<v
-t\
-]a;TNfm+_uw7B
-:;t}xrXy`-\Z4~gL3-^O.YsP=^	IN8`'NJM0_YrAs'&14&*uK=	IL>B'NBblm{cMiL$ c)mw48.=WlPItz'3v]@mVZ<)DPJr1x}y:_=]h!_hZ&VwwSu-~BMhVZ;	>4]}6jFAfm0n
-Pq{v t"mz.~
-O^PJUG%FSOOLF4b'%%OF+g}cNWh"0glDsG(vx'+X6mq76Y1O@q`)O-g#4mVcz&	,d[28U{a<1UZsw6I6O=n
-e<]\SB%,?z&|iSJ_\.	$g6$|O9[1/jvuHv(}/2AO$,Mu6%E=Sb
-[R72H}3sBdwPEO*)h@x(=	$(S!g<\)tC;
-|&)+dQ}lnB%EKi*">\*r'N$Aq5	_,'6>r)X+)$ojX>u7 Ix-KR|(Jjfxk&/t4st1qu$&p3'-tf.~IJ Gs/35a&lIksY=,][biqWi(MKH13n9=*Amy1{7FO*i&),g;lQ.uT9um}rIhL)Cu~4yTZMF"*&>1s
-OU4bL}hP*jT3UM$%gtS6uQZ`X?4%]K1zzTNLg^@[urWAShcE:3ZPB%MTs3j"?@h=[F-0X<p!> ;tL3Qh'$)6ec>9IZmUF>5t
-0kO_T h})7.z-DSsKGJL(qC)0&UqR2dmrC*Gd))Sh]T [JD{_U,_ ]_q?_}dn[/Ly<waOW2MV&fnit#UtKL#n-I8#~,F $zHk]O8i&4-yh?Gzg|KV<fj(t}5`_$dmyh=Q{h@GY~ZQ%k^xO:11_S'6_;@B9}.v+qt_jw?JO++l&\*SLR~a4)o&y_Z@9Y[*j6lxhKll24c?VfH&#
-N?'cr*:U~nJMRFb,bLiF)U@mSODfB?G'K'm=%$NMn.;*y(#5!kHnHxo<C|h?SZRf>J5=v?*"y|A}EkOfY$@,mEP3=Zb\ER^=O3&53IDg%s*~;8g	K .qfVK#zn1_?	uc$fio3NyZoMB9#v@`8^6/7XP-D+ q76]=oz-6+r$x=X'xx,9u03r-`s%CiKl{KW9P>+Dw)\!;0QL W>]jZVp;NFtwYVg!
-w=!yyH(#"'7&;x[v29 =a;<h4I	E/!I$P/+uCjr@ kWXB1;12{R3Hh	'R "G44nGkBT %iDYmZc.QHzPL>p49orT}n8H`vOT5]^Mu2#N 72}jz:VDKwh3{'9h{n_ieppnO<88'394YKzCgH.L^Rc_&0[89,<~' A+eI0f+NA}4:px'&,5 Z+fI3x(Y$Y[	cFO2MklO'tVtb\MiUzlmlt;D1[^6/k\_z42~s)K?v&d>*u \j3#cdWr,:3q<H>y[j=1aLFFdr]F0' cgZ;!UAP'J6Cd[#a^ I2`~Q4n-a+7~x8@AF\JtCqwjpq|7Sf/B#{2gG9G14J O#T_X>y=x%jkjU2qt&^|/Zwk`
-]S]>QI.GQ {hou5$7}	[:k`\tk&j(EV#R)p[Yyj{.Yc95^-awQ`^0l"1wohf^c|y%A(CSV*3FtSD (; g/|FW#v(F4D~"U"WXiDx MO|Oz^V9^:dwbLXLf3lh2xbp=WearPSpr|_hC~u0,OkG[/FEUn	~O2C=	X#i5$XTHN[`(gS+,llX~l'\$@11{%n.ceh{eUNPT{4GfQlJxb*	!l]:y&+kOUUe zj#jx 2<eT/#RAkp$!) ?jd6ZkOQy&# P?Pnccd/=?u,{vtOSK&\
-}(-qOv9"j@9lwc'/&g5hU+u
-	V4#?rZDRy$iTk@m,i<4C5lm/WBTD	Es.aX$== ,/bts\y$ 6W5-RZVNT,Y z	\P4#gm)gTX4L[#%l!Jk7I`j,F__F<e5a-z@Yy)?<O3emxH&GG5Pv-'AMq!p*x"%[9,7pO)HC9$ER!c\{={\5ZY|9PZGP[Tqi*D%Xqx}dOID8za^]rAT=9	<c?H#CkUh,0R'q#-GJ'3L*Vgix-zI&0@+CEz<BuXnBL* FySVPec>kIlIWt`fAM|Qm}~;T;l]Y}	PQlM|O=KM-[5*@	wv"{TBSYDlBJbu@v|V"ra2[V*,YBa_U,m16irwnTlK%f6l^<Wii|vfQ1z}gC6s?[ol~~tyZ0az{VO}=/	[1t?s'*6!8 .Z"k]XDPrp!z2EinyW>j%g}f+>48w_Pm5SDs*QZ[= xg,y5v:SdBVoqO}`RQ(nJ+l`{L cEx<o{^ !O%8?Sg&"'^h+3>\puc4 eDQBQz~<q>=b7#6s	Kdm<i{qXZ ^b1	E(NG;{fN)(y388xl`yenQz-U$rDL8rH)~'?{%c1qIC].5
-*s/6Hof\Uf1#=ZOHSVYgWo|I
-vw'5#+x^gs+qY%%22[YmazS3SW\	;gz)'&wqD}OTpAFG8XNeELyh5EzCDF{.J4u
--;wD(Xg-FC=Mwi"/ FLs&{CNT^I<=M9W! &#~OGZU1awb/lMbS(v&|_Io5 "~^^H`\'9Bi%}9CFa>\%"p~J^!j}h~{_:4_	41Ju|\Q[TQVuHks](2Wr%a3:Ui~CbWQUP)bJp,+(sO@8KOH*[Dke3B[+%UfN`]@51/GE>wr._U#A#m5 9cPP,l8G%,jmKawVIfA8	}d-sRq4<_vkGP2N>msc<1/s/qTt$pf-4UhKz
-E%iF"P-*<HWi~klZv^yXBupRG7d%c3>p0Z>\=j1,< cZ!|:`$6!Dv1"IF@lr]|U!BEWJjO2*mUl5[-~9"jk8!~dny-2()a F$s!f2$<I9cT4G9  P#/ h
-_&$f`@f/B\/~doCnH(*
-)U,^Ah!L72nB!f${XZx5*3u-ps  >?([w WD;4, Ni]hQ$<GILW \D=hYK|U=+B[X29Eq"0*<V~qm5%!O+hU	pn<~H5'  ?=0VThWX5.*G`b5kJB
-kh/!L@e0{Sskj%%C6E'B!EQfg$L;]%'S~l%tCL3M(-&oC/XO%m tz]f7>mv\O0N;<'^t Z!n&`#e~IiF","bZxX,}CL2Yl+'%er(iB;HCrEBru"}c G@^"[geII'#$WLb
-t|2jit#zq+bwX~9:_kd*DG>BsAQ	Bt3_[eG:GRMQMd	z=[Ge4"1>S(@'r%*/nn,!- 0Ems	5VY`+hiH9<FGk#8wSNIii[AyNhI=c=OUd}US2ao;\WJ%7x^L6K>Q_UrlfB=>~f\1&Y!16 z!3|`(hkb-M~ii$etkI1:,rp{[.i#8a
-#/O*He,yqqgk>w,,RB#wi_b;^C| Tba~.ch"]r3EEtA0I|0&|yJ(<-iNMb^[yX!Pi}(\)7PQ.o4'8	E?x;A^Fa3a:$p2YuA=U,W'6fHM@0Gmb"e]cvliUj	\7}-<U@W=W#U.]i[6b3:bMR@1)Dw%?PTgS3YO+837f5@&D}%F;^ty\zR.izKk)M#9Go?W.Z]tj++>gnZ{])5x]B`5^tY^L^oh1d=)V#~iy-Nx rsOt,+%}jn!LNuBM u+\X*/WJs/J,^BVMBnOMEw^v0	$C|7GL*Qm%`M;(no~lEb:\*3GWl6uXvd[(0u|IGscGKo^>8-	}4R_&[
-rO@'LEsb@dc7V'lM`BM_qTT[t@kk4Z4R`]?.6z]s?'3<~w]&ob^[Ljviu,mA.kO]'|:"|mO]H;/,7IuQE@KJ-ESCGK1.!]?.3I9P-6uWfph95I/5&Nau-04'+],zu	5na3vUVItM*'Y]R8ey1 BleAr`D}D^TREhrP >EA~p3i2pDb%zb5FFx A?S*GV&BrjJb}Ux/9W?IGL1s]dUgO&mT:g^)	oV]VCkpj|o{T&O?g~+WqIje6zIH\/J6(|I*	8*)pU6.\E25=$-TRr
-'|hkFWE&McZ?j!Q
-4L%&]o~~v9 ?P!czY$^q#.@3OtIH+J"6qS$!iJvOzYtM.~^gR{{xC-x*3-vVCls\aO>;4x3n?$++RTUucmB/qs:(HcNs]W^n=b!>C.F b^hJ:mm.<o pw'}+z{LXw0BVfn)6xB.WHKQF~o&C;gmIF[3n^MgB?L4tj&[xz/-l"~M_!Js/@}[ .wKwwP@  q t 5! p  o}f{oRA~&|`L-1w';wIV
-E%!!K[Y C3 4# fP OZnkM6M4DqV:	u/	
-i!%&jdRNTA2FJTGPI #  4"D S0Ehiry?XR:(fJV5@L#{bB/ucJ4YYRd4!7e.!w!"iq86g#$XPX8e%VO?+]%!%lp!T/1
--RB#P$oh/!x_X4Q_UbuGnBBgb/M<ItZ9O
-KKaryGM:
-tNc&47:TJ4'S=!fM sBX *T;5knLul:B%wCWJ65RrBC;t 1
-zuP#r$<2dv6.D!yqt&pR	QIGRF"FB2/PUP#0212XzF\,n7lx}!0'n!F|ST*I"0l>,APTQ$}?dPSaAln\*]z,\;n&& F\of7T
-[C`lsV~k2.tXhZTL3#~!WTvd7Q-FMA!Mh;9BReM.$#%]yPy7xQEjJpBH5{)7qQO2U:_
-J!xaThPBfSHv8 ~jw**2oqqE9-aS}34)SwOTP{S)9dzMhMGO!|Vyd}r>s41tH[_2}/bn|K"(I
-+	!5TgG%;:Yb*"kpP'`5II.BZfN;G3C\0G$
-JO G^iII$#X>Cz?PxR^8v"&}*1
-K?%d'xDl!\/NQTe_[j~'=UHFG[
-@_INH,qiNU+UP2JdK?	0#UXO$!sK,(:[7~ 7 ]st R>7^}azG^Tc&XN]?MF+X?YCNm/J4V~n-^e#kkwA4o>`L/hD(^oQxvbg?$s-'By/)}zdZ(4`:`d8!ae6qO#	s4%H<Y$[R
-qWL1)]gvow}q|s6TBA2'UTt*LvM2
->UW4d7m}d"l?j1{7!-=]Y$"}n.dv73'W51:<a/g10Zr8X	{6d1_X>t7vv{f._p+Pkt(pq]6I7_];&@AZ6b<<Jw8QUFi'x8k+&a,et99~TV-+j]Ra/dOei\Nk-K~s0{dn#9j:NS7MEgX&Zi	[YK~mpOE]N=gKw%Z6onXkgqG2}w]3,Vv@-x92,5p7{Ps_z8:to	O7kvn{cdm~h0!A7#:hai
-uB!hrgc-9,u+z1oZ_LPjT}=]Rf@vXA !R~lvD_7&\Wd<CKm_.c.Wj<3qsyvxupE^rW%h
-s/YCkS{\aq
-r{?p(nf6]k
-~JB)d\(%{UV\ eD+h.it".GHaGQj9PiRuo_;DuO@v
-wb?|mL/,%Iy8GM;kCR'[SAzy1/CC
-
-l;{S	L&f|$/E
-YYax<&=`1%kKqn!l;HH u^R;Ts1d(qK^Cx9Y,~@AA*2W+R>g ?*e$3p#4 RcP9LR p&hBsweZq.n~x
-iT
-X)NCxBZie$)Vqn<<l*A3.`0^)Pg s5+)
-uw6e7	`00`UT/xPW/GSIp0`K'|'	Wc8\CIl84[ a}1OX&]qhxHY^OfwW> }h#/zPo8,*\5;3%~/`vAP`8l>0.AW9K1_&o@`@VKU^M>my);Vi78!V;Lk^^bt
-7 MEp4F{ ^C9E,gO&$|	b6`1pf[p Z4U&11V ep7'xNCn~i;j2;@~'cN	w`4{mk[iwO	 ~w@0q|CChH >_=(,o A=}#** | P^Uz$
-pxH(8zp,P9(}`@|3S51zF:/`rAqt8/N) KKAjA.0 Xj?]y`@;EM x>g4e=]B% H@M{pZX ~v|u wf~pfB5o(xg(x^()^d{=#UK\	WG0%|ck b n|UFMLRb2B*C5mkxf,*>SuAj{%)
-Mm}$|NB`z$]nX-s
-'`dJs&bfvb&j8@VU_G }o`LUjV>%]}^W@L=,OWs
-gK?	{+GC>rMP*20T3V W+]vYh}*H`s[
-lmwtI0;mM.#'O{NS!*e5/gp{j)  O,*+%BKdU@o/	b*r 	E\hL0a/MrBRgC_)ALKibGmU#EK`R kM`2=:bJ|jqUjr,B
-t@1NHK3AdE-i')`#lMwGBSz{.Uz3Z6Lal>Nvfy#O!R}JGZ I+#7kw42_U7poY*-qx{"VdfCr Y(WU?#.SQh.=2W,n9%+
-,ru0z}M*N-X&<,CWp+s@$mY'_iAMM}z{(d1udQtYPS:_ kC$Yv7e_`i|jq,%L,O'`?~;oF{N	_&7KBMJs =:m|Z&SZ'nZLj (hwmC';\skb&<d5I~&y;	euG%lUoXJ(1eY,
-rzc0Rdu^vySTjtc+?R{	G{K%2hT[	9+pBx:i:*0/^VGQH[_KX^=#
-'n"S;HTVG09W`IMXBnShoO+0covFNniM^<NIUWy)}wJ%g,	GkU"IMuVbdm*[	n	G05dk-oHBre1ZU2RJb$^j*^d YoT|j'	}a%W4Z;OIO1;U3RsMvQVmFFr60$T+,[(NhZ	+=O%>3IX}jH!#L$ZES-(mPN;Lj$<SmjhRG/M'uwS!3Jjsk'	.?>~/FSiROMa@cfj'<u$^Kl)-67'FOU=:	EQVak;QlvM)2?e2fSj^	UzjPtv?KGN*	NZ+,Gf*^	w20m>)}hmaS6Ff>LvK!<7Q'3K.v{k2ewE?$N@5zyEZJD;#;_.%D=$0
-{;f=+sS'b !,-b\b=};uu!#>ZANoi/^Fy1.w-[~wSxDS*zB#j.j1>K 4vtD8u221VG{pmg6n/G;D7"h9"UEM52gPoi2ZD-r\}R\%*YO4a1re=')N4;Xbi"v&"vwH|j/du5{kXfdNhu9&w\M\jOy@:k[BOGFD]|,Wmo{q$iofwDP=%~6i 0` 
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/dotzlib/DotZLib.sln gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib.sln
--- gcc-4.8.1/zlib/contrib/dotzlib/DotZLib.sln	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/dotzlib/DotZLib.sln	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-Microsoft Visual Studio Solution File, Format Version 8.00
-Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DotZLib", "DotZLib\DotZLib.csproj", "{BB1EE0B1-1808-46CB-B786-949D91117FC5}"
-	ProjectSection(ProjectDependencies) = postProject
-	EndProjectSection
-EndProject
-Global
-	GlobalSection(SolutionConfiguration) = preSolution
-		Debug = Debug
-		Release = Release
-	EndGlobalSection
-	GlobalSection(ProjectConfiguration) = postSolution
-		{BB1EE0B1-1808-46CB-B786-949D91117FC5}.Debug.ActiveCfg = Debug|.NET
-		{BB1EE0B1-1808-46CB-B786-949D91117FC5}.Debug.Build.0 = Debug|.NET
-		{BB1EE0B1-1808-46CB-B786-949D91117FC5}.Release.ActiveCfg = Release|.NET
-		{BB1EE0B1-1808-46CB-B786-949D91117FC5}.Release.Build.0 = Release|.NET
-	EndGlobalSection
-	GlobalSection(ExtensibilityGlobals) = postSolution
-	EndGlobalSection
-	GlobalSection(ExtensibilityAddIns) = postSolution
-	EndGlobalSection
-EndGlobal
diff -Nbaur gcc-4.8.1/zlib/contrib/dotzlib/LICENSE_1_0.txt gcc-4.8.1-ppc/zlib/contrib/dotzlib/LICENSE_1_0.txt
--- gcc-4.8.1/zlib/contrib/dotzlib/LICENSE_1_0.txt	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/dotzlib/LICENSE_1_0.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,23 +0,0 @@
-Boost Software License - Version 1.0 - August 17th, 2003
-
-Permission is hereby granted, free of charge, to any person or organization
-obtaining a copy of the software and accompanying documentation covered by
-this license (the "Software") to use, reproduce, display, distribute,
-execute, and transmit the Software, and to prepare derivative works of the
-Software, and to permit third-parties to whom the Software is furnished to
-do so, all subject to the following:
-
-The copyright notices in the Software and this entire statement, including
-the above license grant, this restriction and the following disclaimer,
-must be included in all copies of the Software, in whole or in part, and
-all derivative works of the Software, unless such copies or derivative
-works are solely in the form of machine-executable object code generated by
-a source language processor.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
-SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
-FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
-ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/dotzlib/readme.txt gcc-4.8.1-ppc/zlib/contrib/dotzlib/readme.txt
--- gcc-4.8.1/zlib/contrib/dotzlib/readme.txt	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/dotzlib/readme.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,58 +0,0 @@
-This directory contains a .Net wrapper class library for the ZLib1.dll
-
-The wrapper includes support for inflating/deflating memory buffers,
-.Net streaming wrappers for the gz streams part of zlib, and wrappers
-for the checksum parts of zlib. See DotZLib/UnitTests.cs for examples.
-
-Directory structure:
---------------------
-
-LICENSE_1_0.txt       - License file.
-readme.txt            - This file.
-DotZLib.chm           - Class library documentation
-DotZLib.build         - NAnt build file
-DotZLib.sln           - Microsoft Visual Studio 2003 solution file
-
-DotZLib\*.cs          - Source files for the class library
-
-Unit tests:
------------
-The file DotZLib/UnitTests.cs contains unit tests for use with NUnit 2.1 or higher.
-To include unit tests in the build, define nunit before building.
-
-
-Build instructions:
--------------------
-
-1. Using Visual Studio.Net 2003:
-   Open DotZLib.sln in VS.Net and build from there. Output file (DotZLib.dll)
-   will be found ./DotZLib/bin/release or ./DotZLib/bin/debug, depending on
-   you are building the release or debug version of the library. Check
-   DotZLib/UnitTests.cs for instructions on how to include unit tests in the
-   build.
-
-2. Using NAnt:
-   Open a command prompt with access to the build environment and run nant
-   in the same directory as the DotZLib.build file.
-   You can define 2 properties on the nant command-line to control the build:
-   debug={true|false} to toggle between release/debug builds (default=true).
-   nunit={true|false} to include or esclude unit tests (default=true).
-   Also the target clean will remove binaries.
-   Output file (DotZLib.dll) will be found in either ./DotZLib/bin/release
-   or ./DotZLib/bin/debug, depending on whether you are building the release
-   or debug version of the library.
-
-   Examples:
-     nant -D:debug=false -D:nunit=false
-       will build a release mode version of the library without unit tests.
-     nant
-       will build a debug version of the library with unit tests
-     nant clean
-       will remove all previously built files.
-
-
----------------------------------
-Copyright (c) Henrik Ravn 2004
-
-Use, modification and distribution are subject to the Boost Software License, Version 1.0.
-(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff -Nbaur gcc-4.8.1/zlib/contrib/gcc_gvmat64/gvmat64.S gcc-4.8.1-ppc/zlib/contrib/gcc_gvmat64/gvmat64.S
--- gcc-4.8.1/zlib/contrib/gcc_gvmat64/gvmat64.S	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/gcc_gvmat64/gvmat64.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,574 +0,0 @@
-/*
-;uInt longest_match_x64(
-;    deflate_state *s,
-;    IPos cur_match);                             // current match 
-
-; gvmat64.S -- Asm portion of the optimized longest_match for 32 bits x86_64
-;  (AMD64 on Athlon 64, Opteron, Phenom
-;     and Intel EM64T on Pentium 4 with EM64T, Pentium D, Core 2 Duo, Core I5/I7)
-; this file is translation from gvmat64.asm to GCC 4.x (for Linux, Mac XCode)
-; Copyright (C) 1995-2010 Jean-loup Gailly, Brian Raiter and Gilles Vollant.
-;
-; File written by Gilles Vollant, by converting to assembly the longest_match
-;  from Jean-loup Gailly in deflate.c of zLib and infoZip zip.
-;  and by taking inspiration on asm686 with masm, optimised assembly code
-;        from Brian Raiter, written 1998
-;
-;  This software is provided 'as-is', without any express or implied
-;  warranty.  In no event will the authors be held liable for any damages
-;  arising from the use of this software.
-;
-;  Permission is granted to anyone to use this software for any purpose,
-;  including commercial applications, and to alter it and redistribute it
-;  freely, subject to the following restrictions:
-;
-;  1. The origin of this software must not be misrepresented; you must not
-;     claim that you wrote the original software. If you use this software
-;     in a product, an acknowledgment in the product documentation would be
-;     appreciated but is not required.
-;  2. Altered source versions must be plainly marked as such, and must not be
-;     misrepresented as being the original software
-;  3. This notice may not be removed or altered from any source distribution.
-;
-;         http://www.zlib.net
-;         http://www.winimage.com/zLibDll
-;         http://www.muppetlabs.com/~breadbox/software/assembly.html
-;
-; to compile this file for zLib, I use option:
-;   gcc -c -arch x86_64 gvmat64.S
-
-
-;uInt longest_match(s, cur_match)
-;    deflate_state *s;
-;    IPos cur_match;                             // current match /
-;
-; with XCode for Mac, I had strange error with some jump on intel syntax
-; this is why BEFORE_JMP and AFTER_JMP are used
- */
-
-
-#define BEFORE_JMP .att_syntax
-#define AFTER_JMP .intel_syntax noprefix
-
-#ifndef NO_UNDERLINE
-#	define	match_init	_match_init
-#	define	longest_match	_longest_match
-#endif
-
-.intel_syntax noprefix
-
-.globl	match_init, longest_match
-.text
-longest_match:
-
-
-
-#define LocalVarsSize 96
-/*
-; register used : rax,rbx,rcx,rdx,rsi,rdi,r8,r9,r10,r11,r12
-; free register :  r14,r15
-; register can be saved : rsp
-*/
-
-#define chainlenwmask     (rsp + 8 - LocalVarsSize)
-#define nicematch         (rsp + 16 - LocalVarsSize)
-
-#define save_rdi        (rsp + 24 - LocalVarsSize)
-#define save_rsi        (rsp + 32 - LocalVarsSize)
-#define save_rbx        (rsp + 40 - LocalVarsSize)
-#define save_rbp        (rsp + 48 - LocalVarsSize)
-#define save_r12        (rsp + 56 - LocalVarsSize)
-#define save_r13        (rsp + 64 - LocalVarsSize)
-#define save_r14        (rsp + 72 - LocalVarsSize)
-#define save_r15        (rsp + 80 - LocalVarsSize)
-
-
-/*
-;  all the +4 offsets are due to the addition of pending_buf_size (in zlib
-;  in the deflate_state structure since the asm code was first written
-;  (if you compile with zlib 1.0.4 or older, remove the +4).
-;  Note : these value are good with a 8 bytes boundary pack structure
-*/
-
-#define    MAX_MATCH              258
-#define    MIN_MATCH              3
-#define    MIN_LOOKAHEAD          (MAX_MATCH+MIN_MATCH+1)
-
-/*
-;;; Offsets for fields in the deflate_state structure. These numbers
-;;; are calculated from the definition of deflate_state, with the
-;;; assumption that the compiler will dword-align the fields. (Thus,
-;;; changing the definition of deflate_state could easily cause this
-;;; program to crash horribly, without so much as a warning at
-;;; compile time. Sigh.)
-
-;  all the +zlib1222add offsets are due to the addition of fields
-;  in zlib in the deflate_state structure since the asm code was first written
-;  (if you compile with zlib 1.0.4 or older, use "zlib1222add equ (-4)").
-;  (if you compile with zlib between 1.0.5 and 1.2.2.1, use "zlib1222add equ 0").
-;  if you compile with zlib 1.2.2.2 or later , use "zlib1222add equ 8").
-*/
-
-
-
-/* you can check the structure offset by running
-
-#include <stdlib.h>
-#include <stdio.h>
-#include "deflate.h"
-
-void print_depl()
-{
-deflate_state ds;
-deflate_state *s=&ds;
-printf("size pointer=%u\n",(int)sizeof(void*));
-
-printf("#define dsWSize         %u\n",(int)(((char*)&(s->w_size))-((char*)s)));
-printf("#define dsWMask         %u\n",(int)(((char*)&(s->w_mask))-((char*)s)));
-printf("#define dsWindow        %u\n",(int)(((char*)&(s->window))-((char*)s)));
-printf("#define dsPrev          %u\n",(int)(((char*)&(s->prev))-((char*)s)));
-printf("#define dsMatchLen      %u\n",(int)(((char*)&(s->match_length))-((char*)s)));
-printf("#define dsPrevMatch     %u\n",(int)(((char*)&(s->prev_match))-((char*)s)));
-printf("#define dsStrStart      %u\n",(int)(((char*)&(s->strstart))-((char*)s)));
-printf("#define dsMatchStart    %u\n",(int)(((char*)&(s->match_start))-((char*)s)));
-printf("#define dsLookahead     %u\n",(int)(((char*)&(s->lookahead))-((char*)s)));
-printf("#define dsPrevLen       %u\n",(int)(((char*)&(s->prev_length))-((char*)s)));
-printf("#define dsMaxChainLen   %u\n",(int)(((char*)&(s->max_chain_length))-((char*)s)));
-printf("#define dsGoodMatch     %u\n",(int)(((char*)&(s->good_match))-((char*)s)));
-printf("#define dsNiceMatch     %u\n",(int)(((char*)&(s->nice_match))-((char*)s)));
-}
-*/
-
-#define dsWSize          68
-#define dsWMask          76
-#define dsWindow         80
-#define dsPrev           96
-#define dsMatchLen       144
-#define dsPrevMatch      148
-#define dsStrStart       156
-#define dsMatchStart     160
-#define dsLookahead      164
-#define dsPrevLen        168
-#define dsMaxChainLen    172
-#define dsGoodMatch      188
-#define dsNiceMatch      192
-
-#define window_size      [ rcx + dsWSize]
-#define WMask            [ rcx + dsWMask]
-#define window_ad        [ rcx + dsWindow]
-#define prev_ad          [ rcx + dsPrev]
-#define strstart         [ rcx + dsStrStart]
-#define match_start      [ rcx + dsMatchStart]
-#define Lookahead        [ rcx + dsLookahead] //; 0ffffffffh on infozip
-#define prev_length      [ rcx + dsPrevLen]
-#define max_chain_length [ rcx + dsMaxChainLen]
-#define good_match       [ rcx + dsGoodMatch]
-#define nice_match       [ rcx + dsNiceMatch]
-
-/*
-; windows:
-; parameter 1 in rcx(deflate state s), param 2 in rdx (cur match)
-
-; see http://weblogs.asp.net/oldnewthing/archive/2004/01/14/58579.aspx and
-; http://msdn.microsoft.com/library/en-us/kmarch/hh/kmarch/64bitAMD_8e951dd2-ee77-4728-8702-55ce4b5dd24a.xml.asp
-;
-; All registers must be preserved across the call, except for
-;   rax, rcx, rdx, r8, r9, r10, and r11, which are scratch.
-
-;
-; gcc on macosx-linux:
-; see http://www.x86-64.org/documentation/abi-0.99.pdf
-; param 1 in rdi, param 2 in rsi
-; rbx, rsp, rbp, r12 to r15 must be preserved
-
-;;; Save registers that the compiler may be using, and adjust esp to
-;;; make room for our stack frame.
-
-
-;;; Retrieve the function arguments. r8d will hold cur_match
-;;; throughout the entire function. edx will hold the pointer to the
-;;; deflate_state structure during the function's setup (before
-;;; entering the main loop.
-
-; ms: parameter 1 in rcx (deflate_state* s), param 2 in edx -> r8 (cur match)
-; mac: param 1 in rdi, param 2 rsi
-; this clear high 32 bits of r8, which can be garbage in both r8 and rdx
-*/
-        mov [save_rbx],rbx
-        mov [save_rbp],rbp
-
-
-        mov rcx,rdi
-
-        mov r8d,esi
-
-
-        mov [save_r12],r12
-        mov [save_r13],r13
-        mov [save_r14],r14
-        mov [save_r15],r15
-
-
-//;;; uInt wmask = s->w_mask;
-//;;; unsigned chain_length = s->max_chain_length;
-//;;; if (s->prev_length >= s->good_match) {
-//;;;     chain_length >>= 2;
-//;;; }
-
-
-        mov edi, prev_length
-        mov esi, good_match
-        mov eax, WMask
-        mov ebx, max_chain_length
-        cmp edi, esi
-        jl  LastMatchGood
-        shr ebx, 2
-LastMatchGood:
-
-//;;; chainlen is decremented once beforehand so that the function can
-//;;; use the sign flag instead of the zero flag for the exit test.
-//;;; It is then shifted into the high word, to make room for the wmask
-//;;; value, which it will always accompany.
-
-        dec ebx
-        shl ebx, 16
-        or  ebx, eax
-
-//;;; on zlib only
-//;;; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
-
-
-
-        mov eax, nice_match
-        mov [chainlenwmask], ebx
-        mov r10d, Lookahead
-        cmp r10d, eax
-        cmovnl r10d, eax
-        mov [nicematch],r10d
-
-
-
-//;;; register Bytef *scan = s->window + s->strstart;
-        mov r10, window_ad
-        mov ebp, strstart
-        lea r13, [r10 + rbp]
-
-//;;; Determine how many bytes the scan ptr is off from being
-//;;; dword-aligned.
-
-         mov r9,r13
-         neg r13
-         and r13,3
-
-//;;; IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
-//;;;     s->strstart - (IPos)MAX_DIST(s) : NIL;
-
-
-        mov eax, window_size
-        sub eax, MIN_LOOKAHEAD
-
-
-        xor edi,edi
-        sub ebp, eax
-
-        mov r11d, prev_length
-
-        cmovng ebp,edi
-
-//;;; int best_len = s->prev_length;
-
-
-//;;; Store the sum of s->window + best_len in esi locally, and in esi.
-
-       lea  rsi,[r10+r11]
-
-//;;; register ush scan_start = *(ushf*)scan;
-//;;; register ush scan_end   = *(ushf*)(scan+best_len-1);
-//;;; Posf *prev = s->prev;
-
-        movzx r12d,word ptr [r9]
-        movzx ebx, word ptr [r9 + r11 - 1]
-
-        mov rdi, prev_ad
-
-//;;; Jump into the main loop.
-
-        mov edx, [chainlenwmask]
-
-        cmp bx,word ptr [rsi + r8 - 1]
-        jz  LookupLoopIsZero
-				
-						
-						
-LookupLoop1:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-        jbe LeaveNow
-		
-		
-		
-        sub edx, 0x00010000
-		BEFORE_JMP
-        js  LeaveNow
-		AFTER_JMP
-
-LoopEntry1:
-        cmp bx,word ptr [rsi + r8 - 1]
-		BEFORE_JMP
-        jz  LookupLoopIsZero
-		AFTER_JMP
-
-LookupLoop2:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-		BEFORE_JMP
-        jbe LeaveNow
-		AFTER_JMP
-        sub edx, 0x00010000
-		BEFORE_JMP
-        js  LeaveNow
-		AFTER_JMP
-
-LoopEntry2:
-        cmp bx,word ptr [rsi + r8 - 1]
-		BEFORE_JMP
-        jz  LookupLoopIsZero
-		AFTER_JMP
-
-LookupLoop4:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-		BEFORE_JMP
-        jbe LeaveNow
-		AFTER_JMP
-        sub edx, 0x00010000
-		BEFORE_JMP
-        js  LeaveNow
-		AFTER_JMP
-
-LoopEntry4:
-
-        cmp bx,word ptr [rsi + r8 - 1]
-		BEFORE_JMP
-        jnz LookupLoop1
-        jmp LookupLoopIsZero
-		AFTER_JMP
-/*
-;;; do {
-;;;     match = s->window + cur_match;
-;;;     if (*(ushf*)(match+best_len-1) != scan_end ||
-;;;         *(ushf*)match != scan_start) continue;
-;;;     [...]
-;;; } while ((cur_match = prev[cur_match & wmask]) > limit
-;;;          && --chain_length != 0);
-;;;
-;;; Here is the inner loop of the function. The function will spend the
-;;; majority of its time in this loop, and majority of that time will
-;;; be spent in the first ten instructions.
-;;;
-;;; Within this loop:
-;;; ebx = scanend
-;;; r8d = curmatch
-;;; edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)
-;;; esi = windowbestlen - i.e., (window + bestlen)
-;;; edi = prev
-;;; ebp = limit
-*/
-.balign 16
-LookupLoop:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-		BEFORE_JMP
-        jbe LeaveNow
-		AFTER_JMP
-        sub edx, 0x00010000
-		BEFORE_JMP
-        js  LeaveNow
-		AFTER_JMP
-
-LoopEntry:
-
-        cmp bx,word ptr [rsi + r8 - 1]
-		BEFORE_JMP
-        jnz LookupLoop1
-		AFTER_JMP
-LookupLoopIsZero:
-        cmp     r12w, word ptr [r10 + r8]
-		BEFORE_JMP
-        jnz LookupLoop1
-		AFTER_JMP
-
-
-//;;; Store the current value of chainlen.
-        mov [chainlenwmask], edx
-/*
-;;; Point edi to the string under scrutiny, and esi to the string we
-;;; are hoping to match it up with. In actuality, esi and edi are
-;;; both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and edx is
-;;; initialized to -(MAX_MATCH_8 - scanalign).
-*/
-        lea rsi,[r8+r10]
-        mov rdx, 0xfffffffffffffef8 //; -(MAX_MATCH_8)
-        lea rsi, [rsi + r13 + 0x0108] //;MAX_MATCH_8]
-        lea rdi, [r9 + r13 + 0x0108] //;MAX_MATCH_8]
-
-        prefetcht1 [rsi+rdx]
-        prefetcht1 [rdi+rdx]
-
-/*
-;;; Test the strings for equality, 8 bytes at a time. At the end,
-;;; adjust rdx so that it is offset to the exact byte that mismatched.
-;;;
-;;; We already know at this point that the first three bytes of the
-;;; strings match each other, and they can be safely passed over before
-;;; starting the compare loop. So what this code does is skip over 0-3
-;;; bytes, as much as necessary in order to dword-align the edi
-;;; pointer. (rsi will still be misaligned three times out of four.)
-;;;
-;;; It should be confessed that this loop usually does not represent
-;;; much of the total running time. Replacing it with a more
-;;; straightforward "rep cmpsb" would not drastically degrade
-;;; performance.
-*/
-
-LoopCmps:
-        mov rax, [rsi + rdx]
-        xor rax, [rdi + rdx]
-        jnz LeaveLoopCmps
-
-        mov rax, [rsi + rdx + 8]
-        xor rax, [rdi + rdx + 8]
-        jnz LeaveLoopCmps8
-
-
-        mov rax, [rsi + rdx + 8+8]
-        xor rax, [rdi + rdx + 8+8]
-        jnz LeaveLoopCmps16
-
-        add rdx,8+8+8
-
-		BEFORE_JMP
-        jnz  LoopCmps
-        jmp  LenMaximum
-		AFTER_JMP
-		
-LeaveLoopCmps16: add rdx,8
-LeaveLoopCmps8: add rdx,8
-LeaveLoopCmps:
-
-        test    eax, 0x0000FFFF
-        jnz LenLower
-
-        test eax,0xffffffff
-
-        jnz LenLower32
-
-        add rdx,4
-        shr rax,32
-        or ax,ax
-		BEFORE_JMP
-        jnz LenLower
-		AFTER_JMP
-
-LenLower32:
-        shr eax,16
-        add rdx,2
-		
-LenLower:		
-        sub al, 1
-        adc rdx, 0
-//;;; Calculate the length of the match. If it is longer than MAX_MATCH,
-//;;; then automatically accept it as the best possible match and leave.
-
-        lea rax, [rdi + rdx]
-        sub rax, r9
-        cmp eax, MAX_MATCH
-		BEFORE_JMP
-        jge LenMaximum
-		AFTER_JMP
-/*
-;;; If the length of the match is not longer than the best match we
-;;; have so far, then forget it and return to the lookup loop.
-;///////////////////////////////////
-*/
-        cmp eax, r11d
-        jg  LongerMatch
-
-        lea rsi,[r10+r11]
-
-        mov rdi, prev_ad
-        mov edx, [chainlenwmask]
-		BEFORE_JMP
-        jmp LookupLoop
-		AFTER_JMP
-/*
-;;;         s->match_start = cur_match;
-;;;         best_len = len;
-;;;         if (len >= nice_match) break;
-;;;         scan_end = *(ushf*)(scan+best_len-1);
-*/
-LongerMatch:
-        mov r11d, eax
-        mov match_start, r8d
-        cmp eax, [nicematch]
-		BEFORE_JMP
-        jge LeaveNow
-		AFTER_JMP
-
-        lea rsi,[r10+rax]
-
-        movzx   ebx, word ptr [r9 + rax - 1]
-        mov rdi, prev_ad
-        mov edx, [chainlenwmask]
-		BEFORE_JMP
-        jmp LookupLoop
-		AFTER_JMP
-
-//;;; Accept the current string, with the maximum possible length.
-
-LenMaximum:
-        mov r11d,MAX_MATCH
-        mov match_start, r8d
-
-//;;; if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
-//;;; return s->lookahead;
-
-LeaveNow:
-        mov eax, Lookahead
-        cmp r11d, eax
-        cmovng eax, r11d
-
-
-
-//;;; Restore the stack and return from whence we came.
-
-
-//        mov rsi,[save_rsi]
-//        mov rdi,[save_rdi]
-        mov rbx,[save_rbx]
-        mov rbp,[save_rbp]
-        mov r12,[save_r12]
-        mov r13,[save_r13]
-        mov r14,[save_r14]
-        mov r15,[save_r15]
-
-
-        ret 0
-//; please don't remove this string !
-//; Your can freely use gvmat64 in any free or commercial app
-//; but it is far better don't remove the string in the binary!
- //   db     0dh,0ah,"asm686 with masm, optimised assembly code from Brian Raiter, written 1998, converted to amd 64 by Gilles Vollant 2005",0dh,0ah,0
-
-
-match_init:
-  ret 0
-
-
diff -Nbaur gcc-4.8.1/zlib/contrib/infback9/infback9.c gcc-4.8.1-ppc/zlib/contrib/infback9/infback9.c
--- gcc-4.8.1/zlib/contrib/infback9/infback9.c	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/infback9/infback9.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,617 +0,0 @@
-/* infback9.c -- inflate deflate64 data using a call-back interface
- * Copyright (C) 1995-2008 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "infback9.h"
-#include "inftree9.h"
-#include "inflate9.h"
-
-#define WSIZE 65536UL
-
-/*
-   strm provides memory allocation functions in zalloc and zfree, or
-   Z_NULL to use the library memory allocation functions.
-
-   window is a user-supplied window and output buffer that is 64K bytes.
- */
-int ZEXPORT inflateBack9Init_(strm, window, version, stream_size)
-z_stream FAR *strm;
-unsigned char FAR *window;
-const char *version;
-int stream_size;
-{
-    struct inflate_state FAR *state;
-
-    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
-        stream_size != (int)(sizeof(z_stream)))
-        return Z_VERSION_ERROR;
-    if (strm == Z_NULL || window == Z_NULL)
-        return Z_STREAM_ERROR;
-    strm->msg = Z_NULL;                 /* in case we return an error */
-    if (strm->zalloc == (alloc_func)0) {
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-    }
-    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
-    state = (struct inflate_state FAR *)ZALLOC(strm, 1,
-                                               sizeof(struct inflate_state));
-    if (state == Z_NULL) return Z_MEM_ERROR;
-    Tracev((stderr, "inflate: allocated\n"));
-    strm->state = (voidpf)state;
-    state->window = window;
-    return Z_OK;
-}
-
-/*
-   Build and output length and distance decoding tables for fixed code
-   decoding.
- */
-#ifdef MAKEFIXED
-#include <stdio.h>
-
-void makefixed9(void)
-{
-    unsigned sym, bits, low, size;
-    code *next, *lenfix, *distfix;
-    struct inflate_state state;
-    code fixed[544];
-
-    /* literal/length table */
-    sym = 0;
-    while (sym < 144) state.lens[sym++] = 8;
-    while (sym < 256) state.lens[sym++] = 9;
-    while (sym < 280) state.lens[sym++] = 7;
-    while (sym < 288) state.lens[sym++] = 8;
-    next = fixed;
-    lenfix = next;
-    bits = 9;
-    inflate_table9(LENS, state.lens, 288, &(next), &(bits), state.work);
-
-    /* distance table */
-    sym = 0;
-    while (sym < 32) state.lens[sym++] = 5;
-    distfix = next;
-    bits = 5;
-    inflate_table9(DISTS, state.lens, 32, &(next), &(bits), state.work);
-
-    /* write tables */
-    puts("    /* inffix9.h -- table for decoding deflate64 fixed codes");
-    puts("     * Generated automatically by makefixed9().");
-    puts("     */");
-    puts("");
-    puts("    /* WARNING: this file should *not* be used by applications.");
-    puts("       It is part of the implementation of this library and is");
-    puts("       subject to change. Applications should only use zlib.h.");
-    puts("     */");
-    puts("");
-    size = 1U << 9;
-    printf("    static const code lenfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 6) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", lenfix[low].op, lenfix[low].bits,
-               lenfix[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-    size = 1U << 5;
-    printf("\n    static const code distfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 5) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", distfix[low].op, distfix[low].bits,
-               distfix[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-}
-#endif /* MAKEFIXED */
-
-/* Macros for inflateBack(): */
-
-/* Clear the input bit accumulator */
-#define INITBITS() \
-    do { \
-        hold = 0; \
-        bits = 0; \
-    } while (0)
-
-/* Assure that some input is available.  If input is requested, but denied,
-   then return a Z_BUF_ERROR from inflateBack(). */
-#define PULL() \
-    do { \
-        if (have == 0) { \
-            have = in(in_desc, &next); \
-            if (have == 0) { \
-                next = Z_NULL; \
-                ret = Z_BUF_ERROR; \
-                goto inf_leave; \
-            } \
-        } \
-    } while (0)
-
-/* Get a byte of input into the bit accumulator, or return from inflateBack()
-   with an error if there is no input available. */
-#define PULLBYTE() \
-    do { \
-        PULL(); \
-        have--; \
-        hold += (unsigned long)(*next++) << bits; \
-        bits += 8; \
-    } while (0)
-
-/* Assure that there are at least n bits in the bit accumulator.  If there is
-   not enough available input to do that, then return from inflateBack() with
-   an error. */
-#define NEEDBITS(n) \
-    do { \
-        while (bits < (unsigned)(n)) \
-            PULLBYTE(); \
-    } while (0)
-
-/* Return the low n bits of the bit accumulator (n <= 16) */
-#define BITS(n) \
-    ((unsigned)hold & ((1U << (n)) - 1))
-
-/* Remove n bits from the bit accumulator */
-#define DROPBITS(n) \
-    do { \
-        hold >>= (n); \
-        bits -= (unsigned)(n); \
-    } while (0)
-
-/* Remove zero to seven bits as needed to go to a byte boundary */
-#define BYTEBITS() \
-    do { \
-        hold >>= bits & 7; \
-        bits -= bits & 7; \
-    } while (0)
-
-/* Assure that some output space is available, by writing out the window
-   if it's full.  If the write fails, return from inflateBack() with a
-   Z_BUF_ERROR. */
-#define ROOM() \
-    do { \
-        if (left == 0) { \
-            put = window; \
-            left = WSIZE; \
-            wrap = 1; \
-            if (out(out_desc, put, (unsigned)left)) { \
-                ret = Z_BUF_ERROR; \
-                goto inf_leave; \
-            } \
-        } \
-    } while (0)
-
-/*
-   strm provides the memory allocation functions and window buffer on input,
-   and provides information on the unused input on return.  For Z_DATA_ERROR
-   returns, strm will also provide an error message.
-
-   in() and out() are the call-back input and output functions.  When
-   inflateBack() needs more input, it calls in().  When inflateBack() has
-   filled the window with output, or when it completes with data in the
-   window, it calls out() to write out the data.  The application must not
-   change the provided input until in() is called again or inflateBack()
-   returns.  The application must not change the window/output buffer until
-   inflateBack() returns.
-
-   in() and out() are called with a descriptor parameter provided in the
-   inflateBack() call.  This parameter can be a structure that provides the
-   information required to do the read or write, as well as accumulated
-   information on the input and output such as totals and check values.
-
-   in() should return zero on failure.  out() should return non-zero on
-   failure.  If either in() or out() fails, than inflateBack() returns a
-   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it
-   was in() or out() that caused in the error.  Otherwise,  inflateBack()
-   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
-   error, or Z_MEM_ERROR if it could not allocate memory for the state.
-   inflateBack() can also return Z_STREAM_ERROR if the input parameters
-   are not correct, i.e. strm is Z_NULL or the state was not initialized.
- */
-int ZEXPORT inflateBack9(strm, in, in_desc, out, out_desc)
-z_stream FAR *strm;
-in_func in;
-void FAR *in_desc;
-out_func out;
-void FAR *out_desc;
-{
-    struct inflate_state FAR *state;
-    unsigned char FAR *next;    /* next input */
-    unsigned char FAR *put;     /* next output */
-    unsigned have;              /* available input */
-    unsigned long left;         /* available output */
-    inflate_mode mode;          /* current inflate mode */
-    int lastblock;              /* true if processing last block */
-    int wrap;                   /* true if the window has wrapped */
-    unsigned long write;        /* window write index */
-    unsigned char FAR *window;  /* allocated sliding window, if needed */
-    unsigned long hold;         /* bit buffer */
-    unsigned bits;              /* bits in bit buffer */
-    unsigned extra;             /* extra bits needed */
-    unsigned long length;       /* literal or length of data to copy */
-    unsigned long offset;       /* distance back to copy string from */
-    unsigned long copy;         /* number of stored or match bytes to copy */
-    unsigned char FAR *from;    /* where to copy match bytes from */
-    code const FAR *lencode;    /* starting table for length/literal codes */
-    code const FAR *distcode;   /* starting table for distance codes */
-    unsigned lenbits;           /* index bits for lencode */
-    unsigned distbits;          /* index bits for distcode */
-    code here;                  /* current decoding table entry */
-    code last;                  /* parent table entry */
-    unsigned len;               /* length to copy for repeats, bits to drop */
-    int ret;                    /* return code */
-    static const unsigned short order[19] = /* permutation of code lengths */
-        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-#include "inffix9.h"
-
-    /* Check that the strm exists and that the state was initialized */
-    if (strm == Z_NULL || strm->state == Z_NULL)
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-
-    /* Reset the state */
-    strm->msg = Z_NULL;
-    mode = TYPE;
-    lastblock = 0;
-    write = 0;
-    wrap = 0;
-    window = state->window;
-    next = strm->next_in;
-    have = next != Z_NULL ? strm->avail_in : 0;
-    hold = 0;
-    bits = 0;
-    put = window;
-    left = WSIZE;
-    lencode = Z_NULL;
-    distcode = Z_NULL;
-
-    /* Inflate until end of block marked as last */
-    for (;;)
-        switch (mode) {
-        case TYPE:
-            /* determine and dispatch block type */
-            if (lastblock) {
-                BYTEBITS();
-                mode = DONE;
-                break;
-            }
-            NEEDBITS(3);
-            lastblock = BITS(1);
-            DROPBITS(1);
-            switch (BITS(2)) {
-            case 0:                             /* stored block */
-                Tracev((stderr, "inflate:     stored block%s\n",
-                        lastblock ? " (last)" : ""));
-                mode = STORED;
-                break;
-            case 1:                             /* fixed block */
-                lencode = lenfix;
-                lenbits = 9;
-                distcode = distfix;
-                distbits = 5;
-                Tracev((stderr, "inflate:     fixed codes block%s\n",
-                        lastblock ? " (last)" : ""));
-                mode = LEN;                     /* decode codes */
-                break;
-            case 2:                             /* dynamic block */
-                Tracev((stderr, "inflate:     dynamic codes block%s\n",
-                        lastblock ? " (last)" : ""));
-                mode = TABLE;
-                break;
-            case 3:
-                strm->msg = (char *)"invalid block type";
-                mode = BAD;
-            }
-            DROPBITS(2);
-            break;
-
-        case STORED:
-            /* get and verify stored block length */
-            BYTEBITS();                         /* go to byte boundary */
-            NEEDBITS(32);
-            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
-                strm->msg = (char *)"invalid stored block lengths";
-                mode = BAD;
-                break;
-            }
-            length = (unsigned)hold & 0xffff;
-            Tracev((stderr, "inflate:       stored length %lu\n",
-                    length));
-            INITBITS();
-
-            /* copy stored block from input to output */
-            while (length != 0) {
-                copy = length;
-                PULL();
-                ROOM();
-                if (copy > have) copy = have;
-                if (copy > left) copy = left;
-                zmemcpy(put, next, copy);
-                have -= copy;
-                next += copy;
-                left -= copy;
-                put += copy;
-                length -= copy;
-            }
-            Tracev((stderr, "inflate:       stored end\n"));
-            mode = TYPE;
-            break;
-
-        case TABLE:
-            /* get dynamic table entries descriptor */
-            NEEDBITS(14);
-            state->nlen = BITS(5) + 257;
-            DROPBITS(5);
-            state->ndist = BITS(5) + 1;
-            DROPBITS(5);
-            state->ncode = BITS(4) + 4;
-            DROPBITS(4);
-            if (state->nlen > 286) {
-                strm->msg = (char *)"too many length symbols";
-                mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       table sizes ok\n"));
-
-            /* get code length code lengths (not a typo) */
-            state->have = 0;
-            while (state->have < state->ncode) {
-                NEEDBITS(3);
-                state->lens[order[state->have++]] = (unsigned short)BITS(3);
-                DROPBITS(3);
-            }
-            while (state->have < 19)
-                state->lens[order[state->have++]] = 0;
-            state->next = state->codes;
-            lencode = (code const FAR *)(state->next);
-            lenbits = 7;
-            ret = inflate_table9(CODES, state->lens, 19, &(state->next),
-                                &(lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid code lengths set";
-                mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       code lengths ok\n"));
-
-            /* get length and distance code code lengths */
-            state->have = 0;
-            while (state->have < state->nlen + state->ndist) {
-                for (;;) {
-                    here = lencode[BITS(lenbits)];
-                    if ((unsigned)(here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                if (here.val < 16) {
-                    NEEDBITS(here.bits);
-                    DROPBITS(here.bits);
-                    state->lens[state->have++] = here.val;
-                }
-                else {
-                    if (here.val == 16) {
-                        NEEDBITS(here.bits + 2);
-                        DROPBITS(here.bits);
-                        if (state->have == 0) {
-                            strm->msg = (char *)"invalid bit length repeat";
-                            mode = BAD;
-                            break;
-                        }
-                        len = (unsigned)(state->lens[state->have - 1]);
-                        copy = 3 + BITS(2);
-                        DROPBITS(2);
-                    }
-                    else if (here.val == 17) {
-                        NEEDBITS(here.bits + 3);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 3 + BITS(3);
-                        DROPBITS(3);
-                    }
-                    else {
-                        NEEDBITS(here.bits + 7);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 11 + BITS(7);
-                        DROPBITS(7);
-                    }
-                    if (state->have + copy > state->nlen + state->ndist) {
-                        strm->msg = (char *)"invalid bit length repeat";
-                        mode = BAD;
-                        break;
-                    }
-                    while (copy--)
-                        state->lens[state->have++] = (unsigned short)len;
-                }
-            }
-
-            /* handle error breaks in while */
-            if (mode == BAD) break;
-
-            /* check for end-of-block code (better have one) */
-            if (state->lens[256] == 0) {
-                strm->msg = (char *)"invalid code -- missing end-of-block";
-                mode = BAD;
-                break;
-            }
-
-            /* build code tables -- note: do not change the lenbits or distbits
-               values here (9 and 6) without reading the comments in inftree9.h
-               concerning the ENOUGH constants, which depend on those values */
-            state->next = state->codes;
-            lencode = (code const FAR *)(state->next);
-            lenbits = 9;
-            ret = inflate_table9(LENS, state->lens, state->nlen,
-                            &(state->next), &(lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid literal/lengths set";
-                mode = BAD;
-                break;
-            }
-            distcode = (code const FAR *)(state->next);
-            distbits = 6;
-            ret = inflate_table9(DISTS, state->lens + state->nlen,
-                            state->ndist, &(state->next), &(distbits),
-                            state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid distances set";
-                mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       codes ok\n"));
-            mode = LEN;
-
-        case LEN:
-            /* get a literal, length, or end-of-block code */
-            for (;;) {
-                here = lencode[BITS(lenbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if (here.op && (here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = lencode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-            }
-            DROPBITS(here.bits);
-            length = (unsigned)here.val;
-
-            /* process literal */
-            if (here.op == 0) {
-                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
-                        "inflate:         literal '%c'\n" :
-                        "inflate:         literal 0x%02x\n", here.val));
-                ROOM();
-                *put++ = (unsigned char)(length);
-                left--;
-                mode = LEN;
-                break;
-            }
-
-            /* process end of block */
-            if (here.op & 32) {
-                Tracevv((stderr, "inflate:         end of block\n"));
-                mode = TYPE;
-                break;
-            }
-
-            /* invalid code */
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid literal/length code";
-                mode = BAD;
-                break;
-            }
-
-            /* length code -- get extra bits, if any */
-            extra = (unsigned)(here.op) & 31;
-            if (extra != 0) {
-                NEEDBITS(extra);
-                length += BITS(extra);
-                DROPBITS(extra);
-            }
-            Tracevv((stderr, "inflate:         length %lu\n", length));
-
-            /* get distance code */
-            for (;;) {
-                here = distcode[BITS(distbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if ((here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = distcode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-            }
-            DROPBITS(here.bits);
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid distance code";
-                mode = BAD;
-                break;
-            }
-            offset = (unsigned)here.val;
-
-            /* get distance extra bits, if any */
-            extra = (unsigned)(here.op) & 15;
-            if (extra != 0) {
-                NEEDBITS(extra);
-                offset += BITS(extra);
-                DROPBITS(extra);
-            }
-            if (offset > WSIZE - (wrap ? 0: left)) {
-                strm->msg = (char *)"invalid distance too far back";
-                mode = BAD;
-                break;
-            }
-            Tracevv((stderr, "inflate:         distance %lu\n", offset));
-
-            /* copy match from window to output */
-            do {
-                ROOM();
-                copy = WSIZE - offset;
-                if (copy < left) {
-                    from = put + copy;
-                    copy = left - copy;
-                }
-                else {
-                    from = put - offset;
-                    copy = left;
-                }
-                if (copy > length) copy = length;
-                length -= copy;
-                left -= copy;
-                do {
-                    *put++ = *from++;
-                } while (--copy);
-            } while (length != 0);
-            break;
-
-        case DONE:
-            /* inflate stream terminated properly -- write leftover output */
-            ret = Z_STREAM_END;
-            if (left < WSIZE) {
-                if (out(out_desc, window, (unsigned)(WSIZE - left)))
-                    ret = Z_BUF_ERROR;
-            }
-            goto inf_leave;
-
-        case BAD:
-            ret = Z_DATA_ERROR;
-            goto inf_leave;
-
-        default:                /* can't happen, but makes compilers happy */
-            ret = Z_STREAM_ERROR;
-            goto inf_leave;
-        }
-
-    /* Return unused input */
-  inf_leave:
-    strm->next_in = next;
-    strm->avail_in = have;
-    return ret;
-}
-
-int ZEXPORT inflateBack9End(strm)
-z_stream FAR *strm;
-{
-    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
-        return Z_STREAM_ERROR;
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-    Tracev((stderr, "inflate: end\n"));
-    return Z_OK;
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/infback9/infback9.h gcc-4.8.1-ppc/zlib/contrib/infback9/infback9.h
--- gcc-4.8.1/zlib/contrib/infback9/infback9.h	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/infback9/infback9.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
-/* infback9.h -- header for using inflateBack9 functions
- * Copyright (C) 2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- * This header file and associated patches provide a decoder for PKWare's
- * undocumented deflate64 compression method (method 9).  Use with infback9.c,
- * inftree9.h, inftree9.c, and inffix9.h.  These patches are not supported.
- * This should be compiled with zlib, since it uses zutil.h and zutil.o.
- * This code has not yet been tested on 16-bit architectures.  See the
- * comments in zlib.h for inflateBack() usage.  These functions are used
- * identically, except that there is no windowBits parameter, and a 64K
- * window must be provided.  Also if int's are 16 bits, then a zero for
- * the third parameter of the "out" function actually means 65536UL.
- * zlib.h must be included before this header file.
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-ZEXTERN int ZEXPORT inflateBack9 OF((z_stream FAR *strm,
-                                    in_func in, void FAR *in_desc,
-                                    out_func out, void FAR *out_desc));
-ZEXTERN int ZEXPORT inflateBack9End OF((z_stream FAR *strm));
-ZEXTERN int ZEXPORT inflateBack9Init_ OF((z_stream FAR *strm,
-                                         unsigned char FAR *window,
-                                         const char *version,
-                                         int stream_size));
-#define inflateBack9Init(strm, window) \
-        inflateBack9Init_((strm), (window), \
-        ZLIB_VERSION, sizeof(z_stream))
-
-#ifdef __cplusplus
-}
-#endif
diff -Nbaur gcc-4.8.1/zlib/contrib/infback9/inffix9.h gcc-4.8.1-ppc/zlib/contrib/infback9/inffix9.h
--- gcc-4.8.1/zlib/contrib/infback9/inffix9.h	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/infback9/inffix9.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,107 +0,0 @@
-    /* inffix9.h -- table for decoding deflate64 fixed codes
-     * Generated automatically by makefixed9().
-     */
-
-    /* WARNING: this file should *not* be used by applications.
-       It is part of the implementation of this library and is
-       subject to change. Applications should only use zlib.h.
-     */
-
-    static const code lenfix[512] = {
-        {96,7,0},{0,8,80},{0,8,16},{132,8,115},{130,7,31},{0,8,112},
-        {0,8,48},{0,9,192},{128,7,10},{0,8,96},{0,8,32},{0,9,160},
-        {0,8,0},{0,8,128},{0,8,64},{0,9,224},{128,7,6},{0,8,88},
-        {0,8,24},{0,9,144},{131,7,59},{0,8,120},{0,8,56},{0,9,208},
-        {129,7,17},{0,8,104},{0,8,40},{0,9,176},{0,8,8},{0,8,136},
-        {0,8,72},{0,9,240},{128,7,4},{0,8,84},{0,8,20},{133,8,227},
-        {131,7,43},{0,8,116},{0,8,52},{0,9,200},{129,7,13},{0,8,100},
-        {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},
-        {128,7,8},{0,8,92},{0,8,28},{0,9,152},{132,7,83},{0,8,124},
-        {0,8,60},{0,9,216},{130,7,23},{0,8,108},{0,8,44},{0,9,184},
-        {0,8,12},{0,8,140},{0,8,76},{0,9,248},{128,7,3},{0,8,82},
-        {0,8,18},{133,8,163},{131,7,35},{0,8,114},{0,8,50},{0,9,196},
-        {129,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},{0,8,130},
-        {0,8,66},{0,9,228},{128,7,7},{0,8,90},{0,8,26},{0,9,148},
-        {132,7,67},{0,8,122},{0,8,58},{0,9,212},{130,7,19},{0,8,106},
-        {0,8,42},{0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},
-        {128,7,5},{0,8,86},{0,8,22},{65,8,0},{131,7,51},{0,8,118},
-        {0,8,54},{0,9,204},{129,7,15},{0,8,102},{0,8,38},{0,9,172},
-        {0,8,6},{0,8,134},{0,8,70},{0,9,236},{128,7,9},{0,8,94},
-        {0,8,30},{0,9,156},{132,7,99},{0,8,126},{0,8,62},{0,9,220},
-        {130,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},
-        {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{133,8,131},
-        {130,7,31},{0,8,113},{0,8,49},{0,9,194},{128,7,10},{0,8,97},
-        {0,8,33},{0,9,162},{0,8,1},{0,8,129},{0,8,65},{0,9,226},
-        {128,7,6},{0,8,89},{0,8,25},{0,9,146},{131,7,59},{0,8,121},
-        {0,8,57},{0,9,210},{129,7,17},{0,8,105},{0,8,41},{0,9,178},
-        {0,8,9},{0,8,137},{0,8,73},{0,9,242},{128,7,4},{0,8,85},
-        {0,8,21},{144,8,3},{131,7,43},{0,8,117},{0,8,53},{0,9,202},
-        {129,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},
-        {0,8,69},{0,9,234},{128,7,8},{0,8,93},{0,8,29},{0,9,154},
-        {132,7,83},{0,8,125},{0,8,61},{0,9,218},{130,7,23},{0,8,109},
-        {0,8,45},{0,9,186},{0,8,13},{0,8,141},{0,8,77},{0,9,250},
-        {128,7,3},{0,8,83},{0,8,19},{133,8,195},{131,7,35},{0,8,115},
-        {0,8,51},{0,9,198},{129,7,11},{0,8,99},{0,8,35},{0,9,166},
-        {0,8,3},{0,8,131},{0,8,67},{0,9,230},{128,7,7},{0,8,91},
-        {0,8,27},{0,9,150},{132,7,67},{0,8,123},{0,8,59},{0,9,214},
-        {130,7,19},{0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},
-        {0,8,75},{0,9,246},{128,7,5},{0,8,87},{0,8,23},{77,8,0},
-        {131,7,51},{0,8,119},{0,8,55},{0,9,206},{129,7,15},{0,8,103},
-        {0,8,39},{0,9,174},{0,8,7},{0,8,135},{0,8,71},{0,9,238},
-        {128,7,9},{0,8,95},{0,8,31},{0,9,158},{132,7,99},{0,8,127},
-        {0,8,63},{0,9,222},{130,7,27},{0,8,111},{0,8,47},{0,9,190},
-        {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},
-        {0,8,16},{132,8,115},{130,7,31},{0,8,112},{0,8,48},{0,9,193},
-        {128,7,10},{0,8,96},{0,8,32},{0,9,161},{0,8,0},{0,8,128},
-        {0,8,64},{0,9,225},{128,7,6},{0,8,88},{0,8,24},{0,9,145},
-        {131,7,59},{0,8,120},{0,8,56},{0,9,209},{129,7,17},{0,8,104},
-        {0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},{0,9,241},
-        {128,7,4},{0,8,84},{0,8,20},{133,8,227},{131,7,43},{0,8,116},
-        {0,8,52},{0,9,201},{129,7,13},{0,8,100},{0,8,36},{0,9,169},
-        {0,8,4},{0,8,132},{0,8,68},{0,9,233},{128,7,8},{0,8,92},
-        {0,8,28},{0,9,153},{132,7,83},{0,8,124},{0,8,60},{0,9,217},
-        {130,7,23},{0,8,108},{0,8,44},{0,9,185},{0,8,12},{0,8,140},
-        {0,8,76},{0,9,249},{128,7,3},{0,8,82},{0,8,18},{133,8,163},
-        {131,7,35},{0,8,114},{0,8,50},{0,9,197},{129,7,11},{0,8,98},
-        {0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},
-        {128,7,7},{0,8,90},{0,8,26},{0,9,149},{132,7,67},{0,8,122},
-        {0,8,58},{0,9,213},{130,7,19},{0,8,106},{0,8,42},{0,9,181},
-        {0,8,10},{0,8,138},{0,8,74},{0,9,245},{128,7,5},{0,8,86},
-        {0,8,22},{65,8,0},{131,7,51},{0,8,118},{0,8,54},{0,9,205},
-        {129,7,15},{0,8,102},{0,8,38},{0,9,173},{0,8,6},{0,8,134},
-        {0,8,70},{0,9,237},{128,7,9},{0,8,94},{0,8,30},{0,9,157},
-        {132,7,99},{0,8,126},{0,8,62},{0,9,221},{130,7,27},{0,8,110},
-        {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},
-        {96,7,0},{0,8,81},{0,8,17},{133,8,131},{130,7,31},{0,8,113},
-        {0,8,49},{0,9,195},{128,7,10},{0,8,97},{0,8,33},{0,9,163},
-        {0,8,1},{0,8,129},{0,8,65},{0,9,227},{128,7,6},{0,8,89},
-        {0,8,25},{0,9,147},{131,7,59},{0,8,121},{0,8,57},{0,9,211},
-        {129,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},{0,8,137},
-        {0,8,73},{0,9,243},{128,7,4},{0,8,85},{0,8,21},{144,8,3},
-        {131,7,43},{0,8,117},{0,8,53},{0,9,203},{129,7,13},{0,8,101},
-        {0,8,37},{0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},
-        {128,7,8},{0,8,93},{0,8,29},{0,9,155},{132,7,83},{0,8,125},
-        {0,8,61},{0,9,219},{130,7,23},{0,8,109},{0,8,45},{0,9,187},
-        {0,8,13},{0,8,141},{0,8,77},{0,9,251},{128,7,3},{0,8,83},
-        {0,8,19},{133,8,195},{131,7,35},{0,8,115},{0,8,51},{0,9,199},
-        {129,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},
-        {0,8,67},{0,9,231},{128,7,7},{0,8,91},{0,8,27},{0,9,151},
-        {132,7,67},{0,8,123},{0,8,59},{0,9,215},{130,7,19},{0,8,107},
-        {0,8,43},{0,9,183},{0,8,11},{0,8,139},{0,8,75},{0,9,247},
-        {128,7,5},{0,8,87},{0,8,23},{77,8,0},{131,7,51},{0,8,119},
-        {0,8,55},{0,9,207},{129,7,15},{0,8,103},{0,8,39},{0,9,175},
-        {0,8,7},{0,8,135},{0,8,71},{0,9,239},{128,7,9},{0,8,95},
-        {0,8,31},{0,9,159},{132,7,99},{0,8,127},{0,8,63},{0,9,223},
-        {130,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},
-        {0,8,79},{0,9,255}
-    };
-
-    static const code distfix[32] = {
-        {128,5,1},{135,5,257},{131,5,17},{139,5,4097},{129,5,5},
-        {137,5,1025},{133,5,65},{141,5,16385},{128,5,3},{136,5,513},
-        {132,5,33},{140,5,8193},{130,5,9},{138,5,2049},{134,5,129},
-        {142,5,32769},{128,5,2},{135,5,385},{131,5,25},{139,5,6145},
-        {129,5,7},{137,5,1537},{133,5,97},{141,5,24577},{128,5,4},
-        {136,5,769},{132,5,49},{140,5,12289},{130,5,13},{138,5,3073},
-        {134,5,193},{142,5,49153}
-    };
diff -Nbaur gcc-4.8.1/zlib/contrib/infback9/inflate9.h gcc-4.8.1-ppc/zlib/contrib/infback9/inflate9.h
--- gcc-4.8.1/zlib/contrib/infback9/inflate9.h	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/infback9/inflate9.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,47 +0,0 @@
-/* inflate9.h -- internal inflate state definition
- * Copyright (C) 1995-2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* Possible inflate modes between inflate() calls */
-typedef enum {
-        TYPE,       /* i: waiting for type bits, including last-flag bit */
-        STORED,     /* i: waiting for stored size (length and complement) */
-        TABLE,      /* i: waiting for dynamic block table lengths */
-            LEN,        /* i: waiting for length/lit code */
-    DONE,       /* finished check, done -- remain here until reset */
-    BAD         /* got a data error -- remain here until reset */
-} inflate_mode;
-
-/*
-    State transitions between above modes -
-
-    (most modes can go to the BAD mode -- not shown for clarity)
-
-    Read deflate blocks:
-            TYPE -> STORED or TABLE or LEN or DONE
-            STORED -> TYPE
-            TABLE -> LENLENS -> CODELENS -> LEN
-    Read deflate codes:
-                LEN -> LEN or TYPE
- */
-
-/* state maintained between inflate() calls.  Approximately 7K bytes. */
-struct inflate_state {
-        /* sliding window */
-    unsigned char FAR *window;  /* allocated sliding window, if needed */
-        /* dynamic table building */
-    unsigned ncode;             /* number of code length code lengths */
-    unsigned nlen;              /* number of length code lengths */
-    unsigned ndist;             /* number of distance code lengths */
-    unsigned have;              /* number of code lengths in lens[] */
-    code FAR *next;             /* next available space in codes[] */
-    unsigned short lens[320];   /* temporary storage for code lengths */
-    unsigned short work[288];   /* work area for code table building */
-    code codes[ENOUGH];         /* space for code tables */
-};
diff -Nbaur gcc-4.8.1/zlib/contrib/infback9/inftree9.c gcc-4.8.1-ppc/zlib/contrib/infback9/inftree9.c
--- gcc-4.8.1/zlib/contrib/infback9/inftree9.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/infback9/inftree9.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,324 +0,0 @@
-/* inftree9.c -- generate Huffman trees for efficient decoding
- * Copyright (C) 1995-2012 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "inftree9.h"
-
-#define MAXBITS 15
-
-const char inflate9_copyright[] =
-   " inflate9 1.2.7 Copyright 1995-2012 Mark Adler ";
-/*
-  If you use the zlib library in a product, an acknowledgment is welcome
-  in the documentation of your product. If for some reason you cannot
-  include such an acknowledgment, I would appreciate that you keep this
-  copyright string in the executable of your product.
- */
-
-/*
-   Build a set of tables to decode the provided canonical Huffman code.
-   The code lengths are lens[0..codes-1].  The result starts at *table,
-   whose indices are 0..2^bits-1.  work is a writable array of at least
-   lens shorts, which is used as a work area.  type is the type of code
-   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
-   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
-   on return points to the next available entry's address.  bits is the
-   requested root table index bits, and on return it is the actual root
-   table index bits.  It will differ if the request is greater than the
-   longest code or if it is less than the shortest code.
- */
-int inflate_table9(type, lens, codes, table, bits, work)
-codetype type;
-unsigned short FAR *lens;
-unsigned codes;
-code FAR * FAR *table;
-unsigned FAR *bits;
-unsigned short FAR *work;
-{
-    unsigned len;               /* a code's length in bits */
-    unsigned sym;               /* index of code symbols */
-    unsigned min, max;          /* minimum and maximum code lengths */
-    unsigned root;              /* number of index bits for root table */
-    unsigned curr;              /* number of index bits for current table */
-    unsigned drop;              /* code bits to drop for sub-table */
-    int left;                   /* number of prefix codes available */
-    unsigned used;              /* code entries in table used */
-    unsigned huff;              /* Huffman code */
-    unsigned incr;              /* for incrementing code, index */
-    unsigned fill;              /* index for replicating entries */
-    unsigned low;               /* low bits for current root entry */
-    unsigned mask;              /* mask for low root bits */
-    code this;                  /* table entry for duplication */
-    code FAR *next;             /* next available space in table */
-    const unsigned short FAR *base;     /* base value table to use */
-    const unsigned short FAR *extra;    /* extra bits table to use */
-    int end;                    /* use base and extra for symbol > end */
-    unsigned short count[MAXBITS+1];    /* number of codes of each length */
-    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
-    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
-        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17,
-        19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115,
-        131, 163, 195, 227, 3, 0, 0};
-    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
-        128, 128, 128, 128, 128, 128, 128, 128, 129, 129, 129, 129,
-        130, 130, 130, 130, 131, 131, 131, 131, 132, 132, 132, 132,
-        133, 133, 133, 133, 144, 78, 68};
-    static const unsigned short dbase[32] = { /* Distance codes 0..31 base */
-        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49,
-        65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073,
-        4097, 6145, 8193, 12289, 16385, 24577, 32769, 49153};
-    static const unsigned short dext[32] = { /* Distance codes 0..31 extra */
-        128, 128, 128, 128, 129, 129, 130, 130, 131, 131, 132, 132,
-        133, 133, 134, 134, 135, 135, 136, 136, 137, 137, 138, 138,
-        139, 139, 140, 140, 141, 141, 142, 142};
-
-    /*
-       Process a set of code lengths to create a canonical Huffman code.  The
-       code lengths are lens[0..codes-1].  Each length corresponds to the
-       symbols 0..codes-1.  The Huffman code is generated by first sorting the
-       symbols by length from short to long, and retaining the symbol order
-       for codes with equal lengths.  Then the code starts with all zero bits
-       for the first code of the shortest length, and the codes are integer
-       increments for the same length, and zeros are appended as the length
-       increases.  For the deflate format, these bits are stored backwards
-       from their more natural integer increment ordering, and so when the
-       decoding tables are built in the large loop below, the integer codes
-       are incremented backwards.
-
-       This routine assumes, but does not check, that all of the entries in
-       lens[] are in the range 0..MAXBITS.  The caller must assure this.
-       1..MAXBITS is interpreted as that code length.  zero means that that
-       symbol does not occur in this code.
-
-       The codes are sorted by computing a count of codes for each length,
-       creating from that a table of starting indices for each length in the
-       sorted table, and then entering the symbols in order in the sorted
-       table.  The sorted table is work[], with that space being provided by
-       the caller.
-
-       The length counts are used for other purposes as well, i.e. finding
-       the minimum and maximum length codes, determining if there are any
-       codes at all, checking for a valid set of lengths, and looking ahead
-       at length counts to determine sub-table sizes when building the
-       decoding tables.
-     */
-
-    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
-    for (len = 0; len <= MAXBITS; len++)
-        count[len] = 0;
-    for (sym = 0; sym < codes; sym++)
-        count[lens[sym]]++;
-
-    /* bound code lengths, force root to be within code lengths */
-    root = *bits;
-    for (max = MAXBITS; max >= 1; max--)
-        if (count[max] != 0) break;
-    if (root > max) root = max;
-    if (max == 0) return -1;            /* no codes! */
-    for (min = 1; min <= MAXBITS; min++)
-        if (count[min] != 0) break;
-    if (root < min) root = min;
-
-    /* check for an over-subscribed or incomplete set of lengths */
-    left = 1;
-    for (len = 1; len <= MAXBITS; len++) {
-        left <<= 1;
-        left -= count[len];
-        if (left < 0) return -1;        /* over-subscribed */
-    }
-    if (left > 0 && (type == CODES || max != 1))
-        return -1;                      /* incomplete set */
-
-    /* generate offsets into symbol table for each length for sorting */
-    offs[1] = 0;
-    for (len = 1; len < MAXBITS; len++)
-        offs[len + 1] = offs[len] + count[len];
-
-    /* sort symbols by length, by symbol order within each length */
-    for (sym = 0; sym < codes; sym++)
-        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
-
-    /*
-       Create and fill in decoding tables.  In this loop, the table being
-       filled is at next and has curr index bits.  The code being used is huff
-       with length len.  That code is converted to an index by dropping drop
-       bits off of the bottom.  For codes where len is less than drop + curr,
-       those top drop + curr - len bits are incremented through all values to
-       fill the table with replicated entries.
-
-       root is the number of index bits for the root table.  When len exceeds
-       root, sub-tables are created pointed to by the root entry with an index
-       of the low root bits of huff.  This is saved in low to check for when a
-       new sub-table should be started.  drop is zero when the root table is
-       being filled, and drop is root when sub-tables are being filled.
-
-       When a new sub-table is needed, it is necessary to look ahead in the
-       code lengths to determine what size sub-table is needed.  The length
-       counts are used for this, and so count[] is decremented as codes are
-       entered in the tables.
-
-       used keeps track of how many table entries have been allocated from the
-       provided *table space.  It is checked for LENS and DIST tables against
-       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
-       the initial root table size constants.  See the comments in inftree9.h
-       for more information.
-
-       sym increments through all symbols, and the loop terminates when
-       all codes of length max, i.e. all codes, have been processed.  This
-       routine permits incomplete codes, so another loop after this one fills
-       in the rest of the decoding tables with invalid code markers.
-     */
-
-    /* set up for code type */
-    switch (type) {
-    case CODES:
-        base = extra = work;    /* dummy value--not used */
-        end = 19;
-        break;
-    case LENS:
-        base = lbase;
-        base -= 257;
-        extra = lext;
-        extra -= 257;
-        end = 256;
-        break;
-    default:            /* DISTS */
-        base = dbase;
-        extra = dext;
-        end = -1;
-    }
-
-    /* initialize state for loop */
-    huff = 0;                   /* starting code */
-    sym = 0;                    /* starting code symbol */
-    len = min;                  /* starting code length */
-    next = *table;              /* current table to fill in */
-    curr = root;                /* current table index bits */
-    drop = 0;                   /* current bits to drop from code for index */
-    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
-    used = 1U << root;          /* use root table entries */
-    mask = used - 1;            /* mask for comparing low */
-
-    /* check available table space */
-    if ((type == LENS && used >= ENOUGH_LENS) ||
-        (type == DISTS && used >= ENOUGH_DISTS))
-        return 1;
-
-    /* process all codes and make table entries */
-    for (;;) {
-        /* create table entry */
-        this.bits = (unsigned char)(len - drop);
-        if ((int)(work[sym]) < end) {
-            this.op = (unsigned char)0;
-            this.val = work[sym];
-        }
-        else if ((int)(work[sym]) > end) {
-            this.op = (unsigned char)(extra[work[sym]]);
-            this.val = base[work[sym]];
-        }
-        else {
-            this.op = (unsigned char)(32 + 64);         /* end of block */
-            this.val = 0;
-        }
-
-        /* replicate for those indices with low len bits equal to huff */
-        incr = 1U << (len - drop);
-        fill = 1U << curr;
-        do {
-            fill -= incr;
-            next[(huff >> drop) + fill] = this;
-        } while (fill != 0);
-
-        /* backwards increment the len-bit code huff */
-        incr = 1U << (len - 1);
-        while (huff & incr)
-            incr >>= 1;
-        if (incr != 0) {
-            huff &= incr - 1;
-            huff += incr;
-        }
-        else
-            huff = 0;
-
-        /* go to next symbol, update count, len */
-        sym++;
-        if (--(count[len]) == 0) {
-            if (len == max) break;
-            len = lens[work[sym]];
-        }
-
-        /* create new sub-table if needed */
-        if (len > root && (huff & mask) != low) {
-            /* if first time, transition to sub-tables */
-            if (drop == 0)
-                drop = root;
-
-            /* increment past last table */
-            next += 1U << curr;
-
-            /* determine length of next table */
-            curr = len - drop;
-            left = (int)(1 << curr);
-            while (curr + drop < max) {
-                left -= count[curr + drop];
-                if (left <= 0) break;
-                curr++;
-                left <<= 1;
-            }
-
-            /* check for enough space */
-            used += 1U << curr;
-            if ((type == LENS && used >= ENOUGH_LENS) ||
-                (type == DISTS && used >= ENOUGH_DISTS))
-                return 1;
-
-            /* point entry in root table to sub-table */
-            low = huff & mask;
-            (*table)[low].op = (unsigned char)curr;
-            (*table)[low].bits = (unsigned char)root;
-            (*table)[low].val = (unsigned short)(next - *table);
-        }
-    }
-
-    /*
-       Fill in rest of table for incomplete codes.  This loop is similar to the
-       loop above in incrementing huff for table indices.  It is assumed that
-       len is equal to curr + drop, so there is no loop needed to increment
-       through high index bits.  When the current sub-table is filled, the loop
-       drops back to the root table to fill in any remaining entries there.
-     */
-    this.op = (unsigned char)64;                /* invalid code marker */
-    this.bits = (unsigned char)(len - drop);
-    this.val = (unsigned short)0;
-    while (huff != 0) {
-        /* when done with sub-table, drop back to root table */
-        if (drop != 0 && (huff & mask) != low) {
-            drop = 0;
-            len = root;
-            next = *table;
-            curr = root;
-            this.bits = (unsigned char)len;
-        }
-
-        /* put invalid code marker in table */
-        next[huff >> drop] = this;
-
-        /* backwards increment the len-bit code huff */
-        incr = 1U << (len - 1);
-        while (huff & incr)
-            incr >>= 1;
-        if (incr != 0) {
-            huff &= incr - 1;
-            huff += incr;
-        }
-        else
-            huff = 0;
-    }
-
-    /* set return parameters */
-    *table += used;
-    *bits = root;
-    return 0;
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/infback9/inftree9.h gcc-4.8.1-ppc/zlib/contrib/infback9/inftree9.h
--- gcc-4.8.1/zlib/contrib/infback9/inftree9.h	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/infback9/inftree9.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,61 +0,0 @@
-/* inftree9.h -- header to use inftree9.c
- * Copyright (C) 1995-2008 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* Structure for decoding tables.  Each entry provides either the
-   information needed to do the operation requested by the code that
-   indexed that table entry, or it provides a pointer to another
-   table that indexes more bits of the code.  op indicates whether
-   the entry is a pointer to another table, a literal, a length or
-   distance, an end-of-block, or an invalid code.  For a table
-   pointer, the low four bits of op is the number of index bits of
-   that table.  For a length or distance, the low four bits of op
-   is the number of extra bits to get after the code.  bits is
-   the number of bits in this code or part of the code to drop off
-   of the bit buffer.  val is the actual byte to output in the case
-   of a literal, the base length or distance, or the offset from
-   the current table to the next table.  Each entry is four bytes. */
-typedef struct {
-    unsigned char op;           /* operation, extra bits, table bits */
-    unsigned char bits;         /* bits in this part of the code */
-    unsigned short val;         /* offset in table or code value */
-} code;
-
-/* op values as set by inflate_table():
-    00000000 - literal
-    0000tttt - table link, tttt != 0 is the number of table index bits
-    100eeeee - length or distance, eeee is the number of extra bits
-    01100000 - end of block
-    01000000 - invalid code
- */
-
-/* Maximum size of the dynamic table.  The maximum number of code structures is
-   1446, which is the sum of 852 for literal/length codes and 594 for distance
-   codes.  These values were found by exhaustive searches using the program
-   examples/enough.c found in the zlib distribtution.  The arguments to that
-   program are the number of symbols, the initial root table size, and the
-   maximum bit length of a code.  "enough 286 9 15" for literal/length codes
-   returns returns 852, and "enough 32 6 15" for distance codes returns 594.
-   The initial root table size (9 or 6) is found in the fifth argument of the
-   inflate_table() calls in infback9.c.  If the root table size is changed,
-   then these maximum sizes would be need to be recalculated and updated. */
-#define ENOUGH_LENS 852
-#define ENOUGH_DISTS 594
-#define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)
-
-/* Type of code to build for inflate_table9() */
-typedef enum {
-    CODES,
-    LENS,
-    DISTS
-} codetype;
-
-extern int inflate_table9 OF((codetype type, unsigned short FAR *lens,
-                             unsigned codes, code FAR * FAR *table,
-                             unsigned FAR *bits, unsigned short FAR *work));
diff -Nbaur gcc-4.8.1/zlib/contrib/infback9/README gcc-4.8.1-ppc/zlib/contrib/infback9/README
--- gcc-4.8.1/zlib/contrib/infback9/README	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/infback9/README	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-See infback9.h for what this is and how to use it.
diff -Nbaur gcc-4.8.1/zlib/contrib/inflate86/inffas86.c gcc-4.8.1-ppc/zlib/contrib/inflate86/inffas86.c
--- gcc-4.8.1/zlib/contrib/inflate86/inffas86.c	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/inflate86/inffas86.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1157 +0,0 @@
-/* inffas86.c is a hand tuned assembler version of
- *
- * inffast.c -- fast decoding
- * Copyright (C) 1995-2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * Copyright (C) 2003 Chris Anderson <christop@charm.net>
- * Please use the copyright conditions above.
- *
- * Dec-29-2003 -- I added AMD64 inflate asm support.  This version is also
- * slightly quicker on x86 systems because, instead of using rep movsb to copy
- * data, it uses rep movsw, which moves data in 2-byte chunks instead of single
- * bytes.  I've tested the AMD64 code on a Fedora Core 1 + the x86_64 updates
- * from http://fedora.linux.duke.edu/fc1_x86_64
- * which is running on an Athlon 64 3000+ / Gigabyte GA-K8VT800M system with
- * 1GB ram.  The 64-bit version is about 4% faster than the 32-bit version,
- * when decompressing mozilla-source-1.3.tar.gz.
- *
- * Mar-13-2003 -- Most of this is derived from inffast.S which is derived from
- * the gcc -S output of zlib-1.2.0/inffast.c.  Zlib-1.2.0 is in beta release at
- * the moment.  I have successfully compiled and tested this code with gcc2.96,
- * gcc3.2, icc5.0, msvc6.0.  It is very close to the speed of inffast.S
- * compiled with gcc -DNO_MMX, but inffast.S is still faster on the P3 with MMX
- * enabled.  I will attempt to merge the MMX code into this version.  Newer
- * versions of this and inffast.S can be found at
- * http://www.eetbeetee.com/zlib/ and http://www.charm.net/~christop/zlib/
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-
-/* Mark Adler's comments from inffast.c: */
-
-/*
-   Decode literal, length, and distance codes and write out the resulting
-   literal and match bytes until either not enough input or output is
-   available, an end-of-block is encountered, or a data error is encountered.
-   When large enough input and output buffers are supplied to inflate(), for
-   example, a 16K input buffer and a 64K output buffer, more than 95% of the
-   inflate execution time is spent in this routine.
-
-   Entry assumptions:
-
-        state->mode == LEN
-        strm->avail_in >= 6
-        strm->avail_out >= 258
-        start >= strm->avail_out
-        state->bits < 8
-
-   On return, state->mode is one of:
-
-        LEN -- ran out of enough output space or enough available input
-        TYPE -- reached end of block code, inflate() to interpret next block
-        BAD -- error in block data
-
-   Notes:
-
-    - The maximum input bits used by a length/distance pair is 15 bits for the
-      length code, 5 bits for the length extra, 15 bits for the distance code,
-      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
-      Therefore if strm->avail_in >= 6, then there is enough input to avoid
-      checking for available input while decoding.
-
-    - The maximum bytes that a single length/distance pair can output is 258
-      bytes, which is the maximum length that can be coded.  inflate_fast()
-      requires strm->avail_out >= 258 for each loop to avoid checking for
-      output space.
- */
-void inflate_fast(strm, start)
-z_streamp strm;
-unsigned start;         /* inflate()'s starting value for strm->avail_out */
-{
-    struct inflate_state FAR *state;
-    struct inffast_ar {
-/* 64   32                               x86  x86_64 */
-/* ar offset                              register */
-/*  0    0 */ void *esp;                /* esp save */
-/*  8    4 */ void *ebp;                /* ebp save */
-/* 16    8 */ unsigned char FAR *in;    /* esi rsi  local strm->next_in */
-/* 24   12 */ unsigned char FAR *last;  /*     r9   while in < last */
-/* 32   16 */ unsigned char FAR *out;   /* edi rdi  local strm->next_out */
-/* 40   20 */ unsigned char FAR *beg;   /*          inflate()'s init next_out */
-/* 48   24 */ unsigned char FAR *end;   /*     r10  while out < end */
-/* 56   28 */ unsigned char FAR *window;/*          size of window, wsize!=0 */
-/* 64   32 */ code const FAR *lcode;    /* ebp rbp  local strm->lencode */
-/* 72   36 */ code const FAR *dcode;    /*     r11  local strm->distcode */
-/* 80   40 */ unsigned long hold;       /* edx rdx  local strm->hold */
-/* 88   44 */ unsigned bits;            /* ebx rbx  local strm->bits */
-/* 92   48 */ unsigned wsize;           /*          window size */
-/* 96   52 */ unsigned write;           /*          window write index */
-/*100   56 */ unsigned lmask;           /*     r12  mask for lcode */
-/*104   60 */ unsigned dmask;           /*     r13  mask for dcode */
-/*108   64 */ unsigned len;             /*     r14  match length */
-/*112   68 */ unsigned dist;            /*     r15  match distance */
-/*116   72 */ unsigned status;          /*          set when state chng*/
-    } ar;
-
-#if defined( __GNUC__ ) && defined( __amd64__ ) && ! defined( __i386 )
-#define PAD_AVAIL_IN 6
-#define PAD_AVAIL_OUT 258
-#else
-#define PAD_AVAIL_IN 5
-#define PAD_AVAIL_OUT 257
-#endif
-
-    /* copy state to local variables */
-    state = (struct inflate_state FAR *)strm->state;
-    ar.in = strm->next_in;
-    ar.last = ar.in + (strm->avail_in - PAD_AVAIL_IN);
-    ar.out = strm->next_out;
-    ar.beg = ar.out - (start - strm->avail_out);
-    ar.end = ar.out + (strm->avail_out - PAD_AVAIL_OUT);
-    ar.wsize = state->wsize;
-    ar.write = state->wnext;
-    ar.window = state->window;
-    ar.hold = state->hold;
-    ar.bits = state->bits;
-    ar.lcode = state->lencode;
-    ar.dcode = state->distcode;
-    ar.lmask = (1U << state->lenbits) - 1;
-    ar.dmask = (1U << state->distbits) - 1;
-
-    /* decode literals and length/distances until end-of-block or not enough
-       input data or output space */
-
-    /* align in on 1/2 hold size boundary */
-    while (((unsigned long)(void *)ar.in & (sizeof(ar.hold) / 2 - 1)) != 0) {
-        ar.hold += (unsigned long)*ar.in++ << ar.bits;
-        ar.bits += 8;
-    }
-
-#if defined( __GNUC__ ) && defined( __amd64__ ) && ! defined( __i386 )
-    __asm__ __volatile__ (
-"        leaq    %0, %%rax\n"
-"        movq    %%rbp, 8(%%rax)\n"       /* save regs rbp and rsp */
-"        movq    %%rsp, (%%rax)\n"
-"        movq    %%rax, %%rsp\n"          /* make rsp point to &ar */
-"        movq    16(%%rsp), %%rsi\n"      /* rsi  = in */
-"        movq    32(%%rsp), %%rdi\n"      /* rdi  = out */
-"        movq    24(%%rsp), %%r9\n"       /* r9   = last */
-"        movq    48(%%rsp), %%r10\n"      /* r10  = end */
-"        movq    64(%%rsp), %%rbp\n"      /* rbp  = lcode */
-"        movq    72(%%rsp), %%r11\n"      /* r11  = dcode */
-"        movq    80(%%rsp), %%rdx\n"      /* rdx  = hold */
-"        movl    88(%%rsp), %%ebx\n"      /* ebx  = bits */
-"        movl    100(%%rsp), %%r12d\n"    /* r12d = lmask */
-"        movl    104(%%rsp), %%r13d\n"    /* r13d = dmask */
-                                          /* r14d = len */
-                                          /* r15d = dist */
-"        cld\n"
-"        cmpq    %%rdi, %%r10\n"
-"        je      .L_one_time\n"           /* if only one decode left */
-"        cmpq    %%rsi, %%r9\n"
-"        je      .L_one_time\n"
-"        jmp     .L_do_loop\n"
-
-".L_one_time:\n"
-"        movq    %%r12, %%r8\n"           /* r8 = lmask */
-"        cmpb    $32, %%bl\n"
-"        ja      .L_get_length_code_one_time\n"
-
-"        lodsl\n"                         /* eax = *(uint *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $32, %%bl\n"             /* bits += 32 */
-"        shlq    %%cl, %%rax\n"
-"        orq     %%rax, %%rdx\n"          /* hold |= *((uint *)in)++ << bits */
-"        jmp     .L_get_length_code_one_time\n"
-
-".align 32,0x90\n"
-".L_while_test:\n"
-"        cmpq    %%rdi, %%r10\n"
-"        jbe     .L_break_loop\n"
-"        cmpq    %%rsi, %%r9\n"
-"        jbe     .L_break_loop\n"
-
-".L_do_loop:\n"
-"        movq    %%r12, %%r8\n"           /* r8 = lmask */
-"        cmpb    $32, %%bl\n"
-"        ja      .L_get_length_code\n"    /* if (32 < bits) */
-
-"        lodsl\n"                         /* eax = *(uint *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $32, %%bl\n"             /* bits += 32 */
-"        shlq    %%cl, %%rax\n"
-"        orq     %%rax, %%rdx\n"          /* hold |= *((uint *)in)++ << bits */
-
-".L_get_length_code:\n"
-"        andq    %%rdx, %%r8\n"            /* r8 &= hold */
-"        movl    (%%rbp,%%r8,4), %%eax\n"  /* eax = lcode[hold & lmask] */
-
-"        movb    %%ah, %%cl\n"            /* cl = this.bits */
-"        subb    %%ah, %%bl\n"            /* bits -= this.bits */
-"        shrq    %%cl, %%rdx\n"           /* hold >>= this.bits */
-
-"        testb   %%al, %%al\n"
-"        jnz     .L_test_for_length_base\n" /* if (op != 0) 45.7% */
-
-"        movq    %%r12, %%r8\n"            /* r8 = lmask */
-"        shrl    $16, %%eax\n"            /* output this.val char */
-"        stosb\n"
-
-".L_get_length_code_one_time:\n"
-"        andq    %%rdx, %%r8\n"            /* r8 &= hold */
-"        movl    (%%rbp,%%r8,4), %%eax\n" /* eax = lcode[hold & lmask] */
-
-".L_dolen:\n"
-"        movb    %%ah, %%cl\n"            /* cl = this.bits */
-"        subb    %%ah, %%bl\n"            /* bits -= this.bits */
-"        shrq    %%cl, %%rdx\n"           /* hold >>= this.bits */
-
-"        testb   %%al, %%al\n"
-"        jnz     .L_test_for_length_base\n" /* if (op != 0) 45.7% */
-
-"        shrl    $16, %%eax\n"            /* output this.val char */
-"        stosb\n"
-"        jmp     .L_while_test\n"
-
-".align 32,0x90\n"
-".L_test_for_length_base:\n"
-"        movl    %%eax, %%r14d\n"         /* len = this */
-"        shrl    $16, %%r14d\n"           /* len = this.val */
-"        movb    %%al, %%cl\n"
-
-"        testb   $16, %%al\n"
-"        jz      .L_test_for_second_level_length\n" /* if ((op & 16) == 0) 8% */
-"        andb    $15, %%cl\n"             /* op &= 15 */
-"        jz      .L_decode_distance\n"    /* if (!op) */
-
-".L_add_bits_to_len:\n"
-"        subb    %%cl, %%bl\n"
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"
-"        andl    %%edx, %%eax\n"          /* eax &= hold */
-"        shrq    %%cl, %%rdx\n"
-"        addl    %%eax, %%r14d\n"         /* len += hold & mask[op] */
-
-".L_decode_distance:\n"
-"        movq    %%r13, %%r8\n"           /* r8 = dmask */
-"        cmpb    $32, %%bl\n"
-"        ja      .L_get_distance_code\n"  /* if (32 < bits) */
-
-"        lodsl\n"                         /* eax = *(uint *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $32, %%bl\n"             /* bits += 32 */
-"        shlq    %%cl, %%rax\n"
-"        orq     %%rax, %%rdx\n"          /* hold |= *((uint *)in)++ << bits */
-
-".L_get_distance_code:\n"
-"        andq    %%rdx, %%r8\n"           /* r8 &= hold */
-"        movl    (%%r11,%%r8,4), %%eax\n" /* eax = dcode[hold & dmask] */
-
-".L_dodist:\n"
-"        movl    %%eax, %%r15d\n"         /* dist = this */
-"        shrl    $16, %%r15d\n"           /* dist = this.val */
-"        movb    %%ah, %%cl\n"
-"        subb    %%ah, %%bl\n"            /* bits -= this.bits */
-"        shrq    %%cl, %%rdx\n"           /* hold >>= this.bits */
-"        movb    %%al, %%cl\n"            /* cl = this.op */
-
-"        testb   $16, %%al\n"             /* if ((op & 16) == 0) */
-"        jz      .L_test_for_second_level_dist\n"
-"        andb    $15, %%cl\n"             /* op &= 15 */
-"        jz      .L_check_dist_one\n"
-
-".L_add_bits_to_dist:\n"
-"        subb    %%cl, %%bl\n"
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"                 /* (1 << op) - 1 */
-"        andl    %%edx, %%eax\n"          /* eax &= hold */
-"        shrq    %%cl, %%rdx\n"
-"        addl    %%eax, %%r15d\n"         /* dist += hold & ((1 << op) - 1) */
-
-".L_check_window:\n"
-"        movq    %%rsi, %%r8\n"           /* save in so from can use it's reg */
-"        movq    %%rdi, %%rax\n"
-"        subq    40(%%rsp), %%rax\n"      /* nbytes = out - beg */
-
-"        cmpl    %%r15d, %%eax\n"
-"        jb      .L_clip_window\n"        /* if (dist > nbytes) 4.2% */
-
-"        movl    %%r14d, %%ecx\n"         /* ecx = len */
-"        movq    %%rdi, %%rsi\n"
-"        subq    %%r15, %%rsi\n"          /* from = out - dist */
-
-"        sarl    %%ecx\n"
-"        jnc     .L_copy_two\n"           /* if len % 2 == 0 */
-
-"        rep     movsw\n"
-"        movb    (%%rsi), %%al\n"
-"        movb    %%al, (%%rdi)\n"
-"        incq    %%rdi\n"
-
-"        movq    %%r8, %%rsi\n"           /* move in back to %rsi, toss from */
-"        jmp     .L_while_test\n"
-
-".L_copy_two:\n"
-"        rep     movsw\n"
-"        movq    %%r8, %%rsi\n"           /* move in back to %rsi, toss from */
-"        jmp     .L_while_test\n"
-
-".align 32,0x90\n"
-".L_check_dist_one:\n"
-"        cmpl    $1, %%r15d\n"            /* if dist 1, is a memset */
-"        jne     .L_check_window\n"
-"        cmpq    %%rdi, 40(%%rsp)\n"      /* if out == beg, outside window */
-"        je      .L_check_window\n"
-
-"        movl    %%r14d, %%ecx\n"         /* ecx = len */
-"        movb    -1(%%rdi), %%al\n"
-"        movb    %%al, %%ah\n"
-
-"        sarl    %%ecx\n"
-"        jnc     .L_set_two\n"
-"        movb    %%al, (%%rdi)\n"
-"        incq    %%rdi\n"
-
-".L_set_two:\n"
-"        rep     stosw\n"
-"        jmp     .L_while_test\n"
-
-".align 32,0x90\n"
-".L_test_for_second_level_length:\n"
-"        testb   $64, %%al\n"
-"        jnz     .L_test_for_end_of_block\n" /* if ((op & 64) != 0) */
-
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"
-"        andl    %%edx, %%eax\n"         /* eax &= hold */
-"        addl    %%r14d, %%eax\n"        /* eax += len */
-"        movl    (%%rbp,%%rax,4), %%eax\n" /* eax = lcode[val+(hold&mask[op])]*/
-"        jmp     .L_dolen\n"
-
-".align 32,0x90\n"
-".L_test_for_second_level_dist:\n"
-"        testb   $64, %%al\n"
-"        jnz     .L_invalid_distance_code\n" /* if ((op & 64) != 0) */
-
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"
-"        andl    %%edx, %%eax\n"         /* eax &= hold */
-"        addl    %%r15d, %%eax\n"        /* eax += dist */
-"        movl    (%%r11,%%rax,4), %%eax\n" /* eax = dcode[val+(hold&mask[op])]*/
-"        jmp     .L_dodist\n"
-
-".align 32,0x90\n"
-".L_clip_window:\n"
-"        movl    %%eax, %%ecx\n"         /* ecx = nbytes */
-"        movl    92(%%rsp), %%eax\n"     /* eax = wsize, prepare for dist cmp */
-"        negl    %%ecx\n"                /* nbytes = -nbytes */
-
-"        cmpl    %%r15d, %%eax\n"
-"        jb      .L_invalid_distance_too_far\n" /* if (dist > wsize) */
-
-"        addl    %%r15d, %%ecx\n"         /* nbytes = dist - nbytes */
-"        cmpl    $0, 96(%%rsp)\n"
-"        jne     .L_wrap_around_window\n" /* if (write != 0) */
-
-"        movq    56(%%rsp), %%rsi\n"     /* from  = window */
-"        subl    %%ecx, %%eax\n"         /* eax  -= nbytes */
-"        addq    %%rax, %%rsi\n"         /* from += wsize - nbytes */
-
-"        movl    %%r14d, %%eax\n"        /* eax = len */
-"        cmpl    %%ecx, %%r14d\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* eax -= nbytes */
-"        rep     movsb\n"
-"        movq    %%rdi, %%rsi\n"
-"        subq    %%r15, %%rsi\n"         /* from = &out[ -dist ] */
-"        jmp     .L_do_copy\n"
-
-".align 32,0x90\n"
-".L_wrap_around_window:\n"
-"        movl    96(%%rsp), %%eax\n"     /* eax = write */
-"        cmpl    %%eax, %%ecx\n"
-"        jbe     .L_contiguous_in_window\n" /* if (write >= nbytes) */
-
-"        movl    92(%%rsp), %%esi\n"     /* from  = wsize */
-"        addq    56(%%rsp), %%rsi\n"     /* from += window */
-"        addq    %%rax, %%rsi\n"         /* from += write */
-"        subq    %%rcx, %%rsi\n"         /* from -= nbytes */
-"        subl    %%eax, %%ecx\n"         /* nbytes -= write */
-
-"        movl    %%r14d, %%eax\n"        /* eax = len */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movq    56(%%rsp), %%rsi\n"     /* from = window */
-"        movl    96(%%rsp), %%ecx\n"     /* nbytes = write */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movq    %%rdi, %%rsi\n"
-"        subq    %%r15, %%rsi\n"         /* from = out - dist */
-"        jmp     .L_do_copy\n"
-
-".align 32,0x90\n"
-".L_contiguous_in_window:\n"
-"        movq    56(%%rsp), %%rsi\n"     /* rsi = window */
-"        addq    %%rax, %%rsi\n"
-"        subq    %%rcx, %%rsi\n"         /* from += write - nbytes */
-
-"        movl    %%r14d, %%eax\n"        /* eax = len */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movq    %%rdi, %%rsi\n"
-"        subq    %%r15, %%rsi\n"         /* from = out - dist */
-"        jmp     .L_do_copy\n"           /* if (nbytes >= len) */
-
-".align 32,0x90\n"
-".L_do_copy:\n"
-"        movl    %%eax, %%ecx\n"         /* ecx = len */
-"        rep     movsb\n"
-
-"        movq    %%r8, %%rsi\n"          /* move in back to %esi, toss from */
-"        jmp     .L_while_test\n"
-
-".L_test_for_end_of_block:\n"
-"        testb   $32, %%al\n"
-"        jz      .L_invalid_literal_length_code\n"
-"        movl    $1, 116(%%rsp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_invalid_literal_length_code:\n"
-"        movl    $2, 116(%%rsp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_invalid_distance_code:\n"
-"        movl    $3, 116(%%rsp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_invalid_distance_too_far:\n"
-"        movl    $4, 116(%%rsp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_break_loop:\n"
-"        movl    $0, 116(%%rsp)\n"
-
-".L_break_loop_with_status:\n"
-/* put in, out, bits, and hold back into ar and pop esp */
-"        movq    %%rsi, 16(%%rsp)\n"     /* in */
-"        movq    %%rdi, 32(%%rsp)\n"     /* out */
-"        movl    %%ebx, 88(%%rsp)\n"     /* bits */
-"        movq    %%rdx, 80(%%rsp)\n"     /* hold */
-"        movq    (%%rsp), %%rax\n"       /* restore rbp and rsp */
-"        movq    8(%%rsp), %%rbp\n"
-"        movq    %%rax, %%rsp\n"
-          :
-          : "m" (ar)
-          : "memory", "%rax", "%rbx", "%rcx", "%rdx", "%rsi", "%rdi",
-            "%r8", "%r9", "%r10", "%r11", "%r12", "%r13", "%r14", "%r15"
-    );
-#elif ( defined( __GNUC__ ) || defined( __ICC ) ) && defined( __i386 )
-    __asm__ __volatile__ (
-"        leal    %0, %%eax\n"
-"        movl    %%esp, (%%eax)\n"        /* save esp, ebp */
-"        movl    %%ebp, 4(%%eax)\n"
-"        movl    %%eax, %%esp\n"
-"        movl    8(%%esp), %%esi\n"       /* esi = in */
-"        movl    16(%%esp), %%edi\n"      /* edi = out */
-"        movl    40(%%esp), %%edx\n"      /* edx = hold */
-"        movl    44(%%esp), %%ebx\n"      /* ebx = bits */
-"        movl    32(%%esp), %%ebp\n"      /* ebp = lcode */
-
-"        cld\n"
-"        jmp     .L_do_loop\n"
-
-".align 32,0x90\n"
-".L_while_test:\n"
-"        cmpl    %%edi, 24(%%esp)\n"      /* out < end */
-"        jbe     .L_break_loop\n"
-"        cmpl    %%esi, 12(%%esp)\n"      /* in < last */
-"        jbe     .L_break_loop\n"
-
-".L_do_loop:\n"
-"        cmpb    $15, %%bl\n"
-"        ja      .L_get_length_code\n"    /* if (15 < bits) */
-
-"        xorl    %%eax, %%eax\n"
-"        lodsw\n"                         /* al = *(ushort *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $16, %%bl\n"             /* bits += 16 */
-"        shll    %%cl, %%eax\n"
-"        orl     %%eax, %%edx\n"        /* hold |= *((ushort *)in)++ << bits */
-
-".L_get_length_code:\n"
-"        movl    56(%%esp), %%eax\n"      /* eax = lmask */
-"        andl    %%edx, %%eax\n"          /* eax &= hold */
-"        movl    (%%ebp,%%eax,4), %%eax\n" /* eax = lcode[hold & lmask] */
-
-".L_dolen:\n"
-"        movb    %%ah, %%cl\n"            /* cl = this.bits */
-"        subb    %%ah, %%bl\n"            /* bits -= this.bits */
-"        shrl    %%cl, %%edx\n"           /* hold >>= this.bits */
-
-"        testb   %%al, %%al\n"
-"        jnz     .L_test_for_length_base\n" /* if (op != 0) 45.7% */
-
-"        shrl    $16, %%eax\n"            /* output this.val char */
-"        stosb\n"
-"        jmp     .L_while_test\n"
-
-".align 32,0x90\n"
-".L_test_for_length_base:\n"
-"        movl    %%eax, %%ecx\n"          /* len = this */
-"        shrl    $16, %%ecx\n"            /* len = this.val */
-"        movl    %%ecx, 64(%%esp)\n"      /* save len */
-"        movb    %%al, %%cl\n"
-
-"        testb   $16, %%al\n"
-"        jz      .L_test_for_second_level_length\n" /* if ((op & 16) == 0) 8% */
-"        andb    $15, %%cl\n"             /* op &= 15 */
-"        jz      .L_decode_distance\n"    /* if (!op) */
-"        cmpb    %%cl, %%bl\n"
-"        jae     .L_add_bits_to_len\n"    /* if (op <= bits) */
-
-"        movb    %%cl, %%ch\n"            /* stash op in ch, freeing cl */
-"        xorl    %%eax, %%eax\n"
-"        lodsw\n"                         /* al = *(ushort *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $16, %%bl\n"             /* bits += 16 */
-"        shll    %%cl, %%eax\n"
-"        orl     %%eax, %%edx\n"         /* hold |= *((ushort *)in)++ << bits */
-"        movb    %%ch, %%cl\n"            /* move op back to ecx */
-
-".L_add_bits_to_len:\n"
-"        subb    %%cl, %%bl\n"
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"
-"        andl    %%edx, %%eax\n"          /* eax &= hold */
-"        shrl    %%cl, %%edx\n"
-"        addl    %%eax, 64(%%esp)\n"      /* len += hold & mask[op] */
-
-".L_decode_distance:\n"
-"        cmpb    $15, %%bl\n"
-"        ja      .L_get_distance_code\n"  /* if (15 < bits) */
-
-"        xorl    %%eax, %%eax\n"
-"        lodsw\n"                         /* al = *(ushort *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $16, %%bl\n"             /* bits += 16 */
-"        shll    %%cl, %%eax\n"
-"        orl     %%eax, %%edx\n"         /* hold |= *((ushort *)in)++ << bits */
-
-".L_get_distance_code:\n"
-"        movl    60(%%esp), %%eax\n"      /* eax = dmask */
-"        movl    36(%%esp), %%ecx\n"      /* ecx = dcode */
-"        andl    %%edx, %%eax\n"          /* eax &= hold */
-"        movl    (%%ecx,%%eax,4), %%eax\n"/* eax = dcode[hold & dmask] */
-
-".L_dodist:\n"
-"        movl    %%eax, %%ebp\n"          /* dist = this */
-"        shrl    $16, %%ebp\n"            /* dist = this.val */
-"        movb    %%ah, %%cl\n"
-"        subb    %%ah, %%bl\n"            /* bits -= this.bits */
-"        shrl    %%cl, %%edx\n"           /* hold >>= this.bits */
-"        movb    %%al, %%cl\n"            /* cl = this.op */
-
-"        testb   $16, %%al\n"             /* if ((op & 16) == 0) */
-"        jz      .L_test_for_second_level_dist\n"
-"        andb    $15, %%cl\n"             /* op &= 15 */
-"        jz      .L_check_dist_one\n"
-"        cmpb    %%cl, %%bl\n"
-"        jae     .L_add_bits_to_dist\n"   /* if (op <= bits) 97.6% */
-
-"        movb    %%cl, %%ch\n"            /* stash op in ch, freeing cl */
-"        xorl    %%eax, %%eax\n"
-"        lodsw\n"                         /* al = *(ushort *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $16, %%bl\n"             /* bits += 16 */
-"        shll    %%cl, %%eax\n"
-"        orl     %%eax, %%edx\n"        /* hold |= *((ushort *)in)++ << bits */
-"        movb    %%ch, %%cl\n"            /* move op back to ecx */
-
-".L_add_bits_to_dist:\n"
-"        subb    %%cl, %%bl\n"
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"                 /* (1 << op) - 1 */
-"        andl    %%edx, %%eax\n"          /* eax &= hold */
-"        shrl    %%cl, %%edx\n"
-"        addl    %%eax, %%ebp\n"          /* dist += hold & ((1 << op) - 1) */
-
-".L_check_window:\n"
-"        movl    %%esi, 8(%%esp)\n"       /* save in so from can use it's reg */
-"        movl    %%edi, %%eax\n"
-"        subl    20(%%esp), %%eax\n"      /* nbytes = out - beg */
-
-"        cmpl    %%ebp, %%eax\n"
-"        jb      .L_clip_window\n"        /* if (dist > nbytes) 4.2% */
-
-"        movl    64(%%esp), %%ecx\n"      /* ecx = len */
-"        movl    %%edi, %%esi\n"
-"        subl    %%ebp, %%esi\n"          /* from = out - dist */
-
-"        sarl    %%ecx\n"
-"        jnc     .L_copy_two\n"           /* if len % 2 == 0 */
-
-"        rep     movsw\n"
-"        movb    (%%esi), %%al\n"
-"        movb    %%al, (%%edi)\n"
-"        incl    %%edi\n"
-
-"        movl    8(%%esp), %%esi\n"       /* move in back to %esi, toss from */
-"        movl    32(%%esp), %%ebp\n"      /* ebp = lcode */
-"        jmp     .L_while_test\n"
-
-".L_copy_two:\n"
-"        rep     movsw\n"
-"        movl    8(%%esp), %%esi\n"       /* move in back to %esi, toss from */
-"        movl    32(%%esp), %%ebp\n"      /* ebp = lcode */
-"        jmp     .L_while_test\n"
-
-".align 32,0x90\n"
-".L_check_dist_one:\n"
-"        cmpl    $1, %%ebp\n"            /* if dist 1, is a memset */
-"        jne     .L_check_window\n"
-"        cmpl    %%edi, 20(%%esp)\n"
-"        je      .L_check_window\n"      /* out == beg, if outside window */
-
-"        movl    64(%%esp), %%ecx\n"      /* ecx = len */
-"        movb    -1(%%edi), %%al\n"
-"        movb    %%al, %%ah\n"
-
-"        sarl    %%ecx\n"
-"        jnc     .L_set_two\n"
-"        movb    %%al, (%%edi)\n"
-"        incl    %%edi\n"
-
-".L_set_two:\n"
-"        rep     stosw\n"
-"        movl    32(%%esp), %%ebp\n"      /* ebp = lcode */
-"        jmp     .L_while_test\n"
-
-".align 32,0x90\n"
-".L_test_for_second_level_length:\n"
-"        testb   $64, %%al\n"
-"        jnz     .L_test_for_end_of_block\n" /* if ((op & 64) != 0) */
-
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"
-"        andl    %%edx, %%eax\n"         /* eax &= hold */
-"        addl    64(%%esp), %%eax\n"     /* eax += len */
-"        movl    (%%ebp,%%eax,4), %%eax\n" /* eax = lcode[val+(hold&mask[op])]*/
-"        jmp     .L_dolen\n"
-
-".align 32,0x90\n"
-".L_test_for_second_level_dist:\n"
-"        testb   $64, %%al\n"
-"        jnz     .L_invalid_distance_code\n" /* if ((op & 64) != 0) */
-
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"
-"        andl    %%edx, %%eax\n"         /* eax &= hold */
-"        addl    %%ebp, %%eax\n"         /* eax += dist */
-"        movl    36(%%esp), %%ecx\n"     /* ecx = dcode */
-"        movl    (%%ecx,%%eax,4), %%eax\n" /* eax = dcode[val+(hold&mask[op])]*/
-"        jmp     .L_dodist\n"
-
-".align 32,0x90\n"
-".L_clip_window:\n"
-"        movl    %%eax, %%ecx\n"
-"        movl    48(%%esp), %%eax\n"     /* eax = wsize */
-"        negl    %%ecx\n"                /* nbytes = -nbytes */
-"        movl    28(%%esp), %%esi\n"     /* from = window */
-
-"        cmpl    %%ebp, %%eax\n"
-"        jb      .L_invalid_distance_too_far\n" /* if (dist > wsize) */
-
-"        addl    %%ebp, %%ecx\n"         /* nbytes = dist - nbytes */
-"        cmpl    $0, 52(%%esp)\n"
-"        jne     .L_wrap_around_window\n" /* if (write != 0) */
-
-"        subl    %%ecx, %%eax\n"
-"        addl    %%eax, %%esi\n"         /* from += wsize - nbytes */
-
-"        movl    64(%%esp), %%eax\n"     /* eax = len */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movl    %%edi, %%esi\n"
-"        subl    %%ebp, %%esi\n"         /* from = out - dist */
-"        jmp     .L_do_copy\n"
-
-".align 32,0x90\n"
-".L_wrap_around_window:\n"
-"        movl    52(%%esp), %%eax\n"     /* eax = write */
-"        cmpl    %%eax, %%ecx\n"
-"        jbe     .L_contiguous_in_window\n" /* if (write >= nbytes) */
-
-"        addl    48(%%esp), %%esi\n"     /* from += wsize */
-"        addl    %%eax, %%esi\n"         /* from += write */
-"        subl    %%ecx, %%esi\n"         /* from -= nbytes */
-"        subl    %%eax, %%ecx\n"         /* nbytes -= write */
-
-"        movl    64(%%esp), %%eax\n"     /* eax = len */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movl    28(%%esp), %%esi\n"     /* from = window */
-"        movl    52(%%esp), %%ecx\n"     /* nbytes = write */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movl    %%edi, %%esi\n"
-"        subl    %%ebp, %%esi\n"         /* from = out - dist */
-"        jmp     .L_do_copy\n"
-
-".align 32,0x90\n"
-".L_contiguous_in_window:\n"
-"        addl    %%eax, %%esi\n"
-"        subl    %%ecx, %%esi\n"         /* from += write - nbytes */
-
-"        movl    64(%%esp), %%eax\n"     /* eax = len */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movl    %%edi, %%esi\n"
-"        subl    %%ebp, %%esi\n"         /* from = out - dist */
-"        jmp     .L_do_copy\n"           /* if (nbytes >= len) */
-
-".align 32,0x90\n"
-".L_do_copy:\n"
-"        movl    %%eax, %%ecx\n"
-"        rep     movsb\n"
-
-"        movl    8(%%esp), %%esi\n"      /* move in back to %esi, toss from */
-"        movl    32(%%esp), %%ebp\n"     /* ebp = lcode */
-"        jmp     .L_while_test\n"
-
-".L_test_for_end_of_block:\n"
-"        testb   $32, %%al\n"
-"        jz      .L_invalid_literal_length_code\n"
-"        movl    $1, 72(%%esp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_invalid_literal_length_code:\n"
-"        movl    $2, 72(%%esp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_invalid_distance_code:\n"
-"        movl    $3, 72(%%esp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_invalid_distance_too_far:\n"
-"        movl    8(%%esp), %%esi\n"
-"        movl    $4, 72(%%esp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_break_loop:\n"
-"        movl    $0, 72(%%esp)\n"
-
-".L_break_loop_with_status:\n"
-/* put in, out, bits, and hold back into ar and pop esp */
-"        movl    %%esi, 8(%%esp)\n"      /* save in */
-"        movl    %%edi, 16(%%esp)\n"     /* save out */
-"        movl    %%ebx, 44(%%esp)\n"     /* save bits */
-"        movl    %%edx, 40(%%esp)\n"     /* save hold */
-"        movl    4(%%esp), %%ebp\n"      /* restore esp, ebp */
-"        movl    (%%esp), %%esp\n"
-          :
-          : "m" (ar)
-          : "memory", "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi"
-    );
-#elif defined( _MSC_VER ) && ! defined( _M_AMD64 )
-    __asm {
-	lea	eax, ar
-	mov	[eax], esp         /* save esp, ebp */
-	mov	[eax+4], ebp
-	mov	esp, eax
-	mov	esi, [esp+8]       /* esi = in */
-	mov	edi, [esp+16]      /* edi = out */
-	mov	edx, [esp+40]      /* edx = hold */
-	mov	ebx, [esp+44]      /* ebx = bits */
-	mov	ebp, [esp+32]      /* ebp = lcode */
-
-	cld
-	jmp	L_do_loop
-
-ALIGN 4
-L_while_test:
-	cmp	[esp+24], edi
-	jbe	L_break_loop
-	cmp	[esp+12], esi
-	jbe	L_break_loop
-
-L_do_loop:
-	cmp	bl, 15
-	ja	L_get_length_code    /* if (15 < bits) */
-
-	xor	eax, eax
-	lodsw                         /* al = *(ushort *)in++ */
-	mov	cl, bl            /* cl = bits, needs it for shifting */
-	add	bl, 16             /* bits += 16 */
-	shl	eax, cl
-	or	edx, eax        /* hold |= *((ushort *)in)++ << bits */
-
-L_get_length_code:
-	mov	eax, [esp+56]      /* eax = lmask */
-	and	eax, edx          /* eax &= hold */
-	mov	eax, [ebp+eax*4] /* eax = lcode[hold & lmask] */
-
-L_dolen:
-	mov	cl, ah            /* cl = this.bits */
-	sub	bl, ah            /* bits -= this.bits */
-	shr	edx, cl           /* hold >>= this.bits */
-
-	test	al, al
-	jnz	L_test_for_length_base /* if (op != 0) 45.7% */
-
-	shr	eax, 16            /* output this.val char */
-	stosb
-	jmp	L_while_test
-
-ALIGN 4
-L_test_for_length_base:
-	mov	ecx, eax          /* len = this */
-	shr	ecx, 16            /* len = this.val */
-	mov	[esp+64], ecx      /* save len */
-	mov	cl, al
-
-	test	al, 16
-	jz	L_test_for_second_level_length /* if ((op & 16) == 0) 8% */
-	and	cl, 15             /* op &= 15 */
-	jz	L_decode_distance    /* if (!op) */
-	cmp	bl, cl
-	jae	L_add_bits_to_len    /* if (op <= bits) */
-
-	mov	ch, cl            /* stash op in ch, freeing cl */
-	xor	eax, eax
-	lodsw                         /* al = *(ushort *)in++ */
-	mov	cl, bl            /* cl = bits, needs it for shifting */
-	add	bl, 16             /* bits += 16 */
-	shl	eax, cl
-	or	edx, eax         /* hold |= *((ushort *)in)++ << bits */
-	mov	cl, ch            /* move op back to ecx */
-
-L_add_bits_to_len:
-	sub	bl, cl
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax
-	and	eax, edx          /* eax &= hold */
-	shr	edx, cl
-	add	[esp+64], eax      /* len += hold & mask[op] */
-
-L_decode_distance:
-	cmp	bl, 15
-	ja	L_get_distance_code  /* if (15 < bits) */
-
-	xor	eax, eax
-	lodsw                         /* al = *(ushort *)in++ */
-	mov	cl, bl            /* cl = bits, needs it for shifting */
-	add	bl, 16             /* bits += 16 */
-	shl	eax, cl
-	or	edx, eax         /* hold |= *((ushort *)in)++ << bits */
-
-L_get_distance_code:
-	mov	eax, [esp+60]      /* eax = dmask */
-	mov	ecx, [esp+36]      /* ecx = dcode */
-	and	eax, edx          /* eax &= hold */
-	mov	eax, [ecx+eax*4]/* eax = dcode[hold & dmask] */
-
-L_dodist:
-	mov	ebp, eax          /* dist = this */
-	shr	ebp, 16            /* dist = this.val */
-	mov	cl, ah
-	sub	bl, ah            /* bits -= this.bits */
-	shr	edx, cl           /* hold >>= this.bits */
-	mov	cl, al            /* cl = this.op */
-
-	test	al, 16             /* if ((op & 16) == 0) */
-	jz	L_test_for_second_level_dist
-	and	cl, 15             /* op &= 15 */
-	jz	L_check_dist_one
-	cmp	bl, cl
-	jae	L_add_bits_to_dist   /* if (op <= bits) 97.6% */
-
-	mov	ch, cl            /* stash op in ch, freeing cl */
-	xor	eax, eax
-	lodsw                         /* al = *(ushort *)in++ */
-	mov	cl, bl            /* cl = bits, needs it for shifting */
-	add	bl, 16             /* bits += 16 */
-	shl	eax, cl
-	or	edx, eax        /* hold |= *((ushort *)in)++ << bits */
-	mov	cl, ch            /* move op back to ecx */
-
-L_add_bits_to_dist:
-	sub	bl, cl
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax                 /* (1 << op) - 1 */
-	and	eax, edx          /* eax &= hold */
-	shr	edx, cl
-	add	ebp, eax          /* dist += hold & ((1 << op) - 1) */
-
-L_check_window:
-	mov	[esp+8], esi       /* save in so from can use it's reg */
-	mov	eax, edi
-	sub	eax, [esp+20]      /* nbytes = out - beg */
-
-	cmp	eax, ebp
-	jb	L_clip_window        /* if (dist > nbytes) 4.2% */
-
-	mov	ecx, [esp+64]      /* ecx = len */
-	mov	esi, edi
-	sub	esi, ebp          /* from = out - dist */
-
-	sar	ecx, 1
-	jnc	L_copy_two
-
-	rep     movsw
-	mov	al, [esi]
-	mov	[edi], al
-	inc	edi
-
-	mov	esi, [esp+8]      /* move in back to %esi, toss from */
-	mov	ebp, [esp+32]     /* ebp = lcode */
-	jmp	L_while_test
-
-L_copy_two:
-	rep     movsw
-	mov	esi, [esp+8]      /* move in back to %esi, toss from */
-	mov	ebp, [esp+32]     /* ebp = lcode */
-	jmp	L_while_test
-
-ALIGN 4
-L_check_dist_one:
-	cmp	ebp, 1            /* if dist 1, is a memset */
-	jne	L_check_window
-	cmp	[esp+20], edi
-	je	L_check_window    /* out == beg, if outside window */
-
-	mov	ecx, [esp+64]     /* ecx = len */
-	mov	al, [edi-1]
-	mov	ah, al
-
-	sar	ecx, 1
-	jnc	L_set_two
-	mov	[edi], al         /* memset out with from[-1] */
-	inc	edi
-
-L_set_two:
-	rep     stosw
-	mov	ebp, [esp+32]     /* ebp = lcode */
-	jmp	L_while_test
-
-ALIGN 4
-L_test_for_second_level_length:
-	test	al, 64
-	jnz	L_test_for_end_of_block /* if ((op & 64) != 0) */
-
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax
-	and	eax, edx         /* eax &= hold */
-	add	eax, [esp+64]     /* eax += len */
-	mov	eax, [ebp+eax*4] /* eax = lcode[val+(hold&mask[op])]*/
-	jmp	L_dolen
-
-ALIGN 4
-L_test_for_second_level_dist:
-	test	al, 64
-	jnz	L_invalid_distance_code /* if ((op & 64) != 0) */
-
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax
-	and	eax, edx         /* eax &= hold */
-	add	eax, ebp         /* eax += dist */
-	mov	ecx, [esp+36]     /* ecx = dcode */
-	mov	eax, [ecx+eax*4] /* eax = dcode[val+(hold&mask[op])]*/
-	jmp	L_dodist
-
-ALIGN 4
-L_clip_window:
-	mov	ecx, eax
-	mov	eax, [esp+48]     /* eax = wsize */
-	neg	ecx                /* nbytes = -nbytes */
-	mov	esi, [esp+28]     /* from = window */
-
-	cmp	eax, ebp
-	jb	L_invalid_distance_too_far /* if (dist > wsize) */
-
-	add	ecx, ebp         /* nbytes = dist - nbytes */
-	cmp	dword ptr [esp+52], 0
-	jne	L_wrap_around_window /* if (write != 0) */
-
-	sub	eax, ecx
-	add	esi, eax         /* from += wsize - nbytes */
-
-	mov	eax, [esp+64]    /* eax = len */
-	cmp	eax, ecx
-	jbe	L_do_copy          /* if (nbytes >= len) */
-
-	sub	eax, ecx         /* len -= nbytes */
-	rep     movsb
-	mov	esi, edi
-	sub	esi, ebp         /* from = out - dist */
-	jmp	L_do_copy
-
-ALIGN 4
-L_wrap_around_window:
-	mov	eax, [esp+52]    /* eax = write */
-	cmp	ecx, eax
-	jbe	L_contiguous_in_window /* if (write >= nbytes) */
-
-	add	esi, [esp+48]    /* from += wsize */
-	add	esi, eax         /* from += write */
-	sub	esi, ecx         /* from -= nbytes */
-	sub	ecx, eax         /* nbytes -= write */
-
-	mov	eax, [esp+64]    /* eax = len */
-	cmp	eax, ecx
-	jbe	L_do_copy          /* if (nbytes >= len) */
-
-	sub	eax, ecx         /* len -= nbytes */
-	rep     movsb
-	mov	esi, [esp+28]     /* from = window */
-	mov	ecx, [esp+52]     /* nbytes = write */
-	cmp	eax, ecx
-	jbe	L_do_copy          /* if (nbytes >= len) */
-
-	sub	eax, ecx         /* len -= nbytes */
-	rep     movsb
-	mov	esi, edi
-	sub	esi, ebp         /* from = out - dist */
-	jmp	L_do_copy
-
-ALIGN 4
-L_contiguous_in_window:
-	add	esi, eax
-	sub	esi, ecx         /* from += write - nbytes */
-
-	mov	eax, [esp+64]    /* eax = len */
-	cmp	eax, ecx
-	jbe	L_do_copy          /* if (nbytes >= len) */
-
-	sub	eax, ecx         /* len -= nbytes */
-	rep     movsb
-	mov	esi, edi
-	sub	esi, ebp         /* from = out - dist */
-	jmp	L_do_copy
-
-ALIGN 4
-L_do_copy:
-	mov	ecx, eax
-	rep     movsb
-
-	mov	esi, [esp+8]      /* move in back to %esi, toss from */
-	mov	ebp, [esp+32]     /* ebp = lcode */
-	jmp	L_while_test
-
-L_test_for_end_of_block:
-	test	al, 32
-	jz	L_invalid_literal_length_code
-	mov	dword ptr [esp+72], 1
-	jmp	L_break_loop_with_status
-
-L_invalid_literal_length_code:
-	mov	dword ptr [esp+72], 2
-	jmp	L_break_loop_with_status
-
-L_invalid_distance_code:
-	mov	dword ptr [esp+72], 3
-	jmp	L_break_loop_with_status
-
-L_invalid_distance_too_far:
-	mov	esi, [esp+4]
-	mov	dword ptr [esp+72], 4
-	jmp	L_break_loop_with_status
-
-L_break_loop:
-	mov	dword ptr [esp+72], 0
-
-L_break_loop_with_status:
-/* put in, out, bits, and hold back into ar and pop esp */
-	mov	[esp+8], esi     /* save in */
-	mov	[esp+16], edi    /* save out */
-	mov	[esp+44], ebx    /* save bits */
-	mov	[esp+40], edx    /* save hold */
-	mov	ebp, [esp+4]     /* restore esp, ebp */
-	mov	esp, [esp]
-    }
-#else
-#error "x86 architecture not defined"
-#endif
-
-    if (ar.status > 1) {
-        if (ar.status == 2)
-            strm->msg = "invalid literal/length code";
-        else if (ar.status == 3)
-            strm->msg = "invalid distance code";
-        else
-            strm->msg = "invalid distance too far back";
-        state->mode = BAD;
-    }
-    else if ( ar.status == 1 ) {
-        state->mode = TYPE;
-    }
-
-    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
-    ar.len = ar.bits >> 3;
-    ar.in -= ar.len;
-    ar.bits -= ar.len << 3;
-    ar.hold &= (1U << ar.bits) - 1;
-
-    /* update state and return */
-    strm->next_in = ar.in;
-    strm->next_out = ar.out;
-    strm->avail_in = (unsigned)(ar.in < ar.last ?
-                                PAD_AVAIL_IN + (ar.last - ar.in) :
-                                PAD_AVAIL_IN - (ar.in - ar.last));
-    strm->avail_out = (unsigned)(ar.out < ar.end ?
-                                 PAD_AVAIL_OUT + (ar.end - ar.out) :
-                                 PAD_AVAIL_OUT - (ar.out - ar.end));
-    state->hold = ar.hold;
-    state->bits = ar.bits;
-    return;
-}
-
diff -Nbaur gcc-4.8.1/zlib/contrib/inflate86/inffast.S gcc-4.8.1-ppc/zlib/contrib/inflate86/inffast.S
--- gcc-4.8.1/zlib/contrib/inflate86/inffast.S	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/inflate86/inffast.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,1368 +0,0 @@
-/*
- * inffast.S is a hand tuned assembler version of:
- *
- * inffast.c -- fast decoding
- * Copyright (C) 1995-2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * Copyright (C) 2003 Chris Anderson <christop@charm.net>
- * Please use the copyright conditions above.
- *
- * This version (Jan-23-2003) of inflate_fast was coded and tested under
- * GNU/Linux on a pentium 3, using the gcc-3.2 compiler distribution.  On that
- * machine, I found that gzip style archives decompressed about 20% faster than
- * the gcc-3.2 -O3 -fomit-frame-pointer compiled version.  Your results will
- * depend on how large of a buffer is used for z_stream.next_in & next_out
- * (8K-32K worked best for my 256K cpu cache) and how much overhead there is in
- * stream processing I/O and crc32/addler32.  In my case, this routine used
- * 70% of the cpu time and crc32 used 20%.
- *
- * I am confident that this version will work in the general case, but I have
- * not tested a wide variety of datasets or a wide variety of platforms.
- *
- * Jan-24-2003 -- Added -DUSE_MMX define for slightly faster inflating.
- * It should be a runtime flag instead of compile time flag...
- *
- * Jan-26-2003 -- Added runtime check for MMX support with cpuid instruction.
- * With -DUSE_MMX, only MMX code is compiled.  With -DNO_MMX, only non-MMX code
- * is compiled.  Without either option, runtime detection is enabled.  Runtime
- * detection should work on all modern cpus and the recomended algorithm (flip
- * ID bit on eflags and then use the cpuid instruction) is used in many
- * multimedia applications.  Tested under win2k with gcc-2.95 and gas-2.12
- * distributed with cygwin3.  Compiling with gcc-2.95 -c inffast.S -o
- * inffast.obj generates a COFF object which can then be linked with MSVC++
- * compiled code.  Tested under FreeBSD 4.7 with gcc-2.95.
- *
- * Jan-28-2003 -- Tested Athlon XP... MMX mode is slower than no MMX (and
- * slower than compiler generated code).  Adjusted cpuid check to use the MMX
- * code only for Pentiums < P4 until I have more data on the P4.  Speed
- * improvment is only about 15% on the Athlon when compared with code generated
- * with MSVC++.  Not sure yet, but I think the P4 will also be slower using the
- * MMX mode because many of it's x86 ALU instructions execute in .5 cycles and
- * have less latency than MMX ops.  Added code to buffer the last 11 bytes of
- * the input stream since the MMX code grabs bits in chunks of 32, which
- * differs from the inffast.c algorithm.  I don't think there would have been
- * read overruns where a page boundary was crossed (a segfault), but there
- * could have been overruns when next_in ends on unaligned memory (unintialized
- * memory read).
- *
- * Mar-13-2003 -- P4 MMX is slightly slower than P4 NO_MMX.  I created a C
- * version of the non-MMX code so that it doesn't depend on zstrm and zstate
- * structure offsets which are hard coded in this file.  This was last tested
- * with zlib-1.2.0 which is currently in beta testing, newer versions of this
- * and inffas86.c can be found at http://www.eetbeetee.com/zlib/ and
- * http://www.charm.net/~christop/zlib/
- */
-
-
-/*
- * if you have underscore linking problems (_inflate_fast undefined), try
- * using -DGAS_COFF
- */
-#if ! defined( GAS_COFF ) && ! defined( GAS_ELF )
-
-#if defined( WIN32 ) || defined( __CYGWIN__ )
-#define GAS_COFF /* windows object format */
-#else
-#define GAS_ELF
-#endif
-
-#endif /* ! GAS_COFF && ! GAS_ELF */
-
-
-#if defined( GAS_COFF )
-
-/* coff externals have underscores */
-#define inflate_fast _inflate_fast
-#define inflate_fast_use_mmx _inflate_fast_use_mmx
-
-#endif /* GAS_COFF */
-
-
-.file "inffast.S"
-
-.globl inflate_fast
-
-.text
-.align 4,0
-.L_invalid_literal_length_code_msg:
-.string "invalid literal/length code"
-
-.align 4,0
-.L_invalid_distance_code_msg:
-.string "invalid distance code"
-
-.align 4,0
-.L_invalid_distance_too_far_msg:
-.string "invalid distance too far back"
-
-#if ! defined( NO_MMX )
-.align 4,0
-.L_mask: /* mask[N] = ( 1 << N ) - 1 */
-.long 0
-.long 1
-.long 3
-.long 7
-.long 15
-.long 31
-.long 63
-.long 127
-.long 255
-.long 511
-.long 1023
-.long 2047
-.long 4095
-.long 8191
-.long 16383
-.long 32767
-.long 65535
-.long 131071
-.long 262143
-.long 524287
-.long 1048575
-.long 2097151
-.long 4194303
-.long 8388607
-.long 16777215
-.long 33554431
-.long 67108863
-.long 134217727
-.long 268435455
-.long 536870911
-.long 1073741823
-.long 2147483647
-.long 4294967295
-#endif /* NO_MMX */
-
-.text
-
-/*
- * struct z_stream offsets, in zlib.h
- */
-#define next_in_strm   0   /* strm->next_in */
-#define avail_in_strm  4   /* strm->avail_in */
-#define next_out_strm  12  /* strm->next_out */
-#define avail_out_strm 16  /* strm->avail_out */
-#define msg_strm       24  /* strm->msg */
-#define state_strm     28  /* strm->state */
-
-/*
- * struct inflate_state offsets, in inflate.h
- */
-#define mode_state     0   /* state->mode */
-#define wsize_state    32  /* state->wsize */
-#define write_state    40  /* state->write */
-#define window_state   44  /* state->window */
-#define hold_state     48  /* state->hold */
-#define bits_state     52  /* state->bits */
-#define lencode_state  68  /* state->lencode */
-#define distcode_state 72  /* state->distcode */
-#define lenbits_state  76  /* state->lenbits */
-#define distbits_state 80  /* state->distbits */
-
-/*
- * inflate_fast's activation record
- */
-#define local_var_size 64 /* how much local space for vars */
-#define strm_sp        88 /* first arg: z_stream * (local_var_size + 24) */
-#define start_sp       92 /* second arg: unsigned int (local_var_size + 28) */
-
-/*
- * offsets for local vars on stack
- */
-#define out            60  /* unsigned char* */
-#define window         56  /* unsigned char* */
-#define wsize          52  /* unsigned int */
-#define write          48  /* unsigned int */
-#define in             44  /* unsigned char* */
-#define beg            40  /* unsigned char* */
-#define buf            28  /* char[ 12 ] */
-#define len            24  /* unsigned int */
-#define last           20  /* unsigned char* */
-#define end            16  /* unsigned char* */
-#define dcode          12  /* code* */
-#define lcode           8  /* code* */
-#define dmask           4  /* unsigned int */
-#define lmask           0  /* unsigned int */
-
-/*
- * typedef enum inflate_mode consts, in inflate.h
- */
-#define INFLATE_MODE_TYPE 11  /* state->mode flags enum-ed in inflate.h */
-#define INFLATE_MODE_BAD  26
-
-
-#if ! defined( USE_MMX ) && ! defined( NO_MMX )
-
-#define RUN_TIME_MMX
-
-#define CHECK_MMX    1
-#define DO_USE_MMX   2
-#define DONT_USE_MMX 3
-
-.globl inflate_fast_use_mmx
-
-.data
-
-.align 4,0
-inflate_fast_use_mmx: /* integer flag for run time control 1=check,2=mmx,3=no */
-.long CHECK_MMX
-
-#if defined( GAS_ELF )
-/* elf info */
-.type   inflate_fast_use_mmx,@object
-.size   inflate_fast_use_mmx,4
-#endif
-
-#endif /* RUN_TIME_MMX */
-
-#if defined( GAS_COFF )
-/* coff info: scl 2 = extern, type 32 = function */
-.def inflate_fast; .scl 2; .type 32; .endef
-#endif
-
-.text
-
-.align 32,0x90
-inflate_fast:
-        pushl   %edi
-        pushl   %esi
-        pushl   %ebp
-        pushl   %ebx
-        pushf   /* save eflags (strm_sp, state_sp assumes this is 32 bits) */
-        subl    $local_var_size, %esp
-        cld
-
-#define strm_r  %esi
-#define state_r %edi
-
-        movl    strm_sp(%esp), strm_r
-        movl    state_strm(strm_r), state_r
-
-        /* in = strm->next_in;
-         * out = strm->next_out;
-         * last = in + strm->avail_in - 11;
-         * beg = out - (start - strm->avail_out);
-         * end = out + (strm->avail_out - 257);
-         */
-        movl    avail_in_strm(strm_r), %edx
-        movl    next_in_strm(strm_r), %eax
-
-        addl    %eax, %edx      /* avail_in += next_in */
-        subl    $11, %edx       /* avail_in -= 11 */
-
-        movl    %eax, in(%esp)
-        movl    %edx, last(%esp)
-
-        movl    start_sp(%esp), %ebp
-        movl    avail_out_strm(strm_r), %ecx
-        movl    next_out_strm(strm_r), %ebx
-
-        subl    %ecx, %ebp      /* start -= avail_out */
-        negl    %ebp            /* start = -start */
-        addl    %ebx, %ebp      /* start += next_out */
-
-        subl    $257, %ecx      /* avail_out -= 257 */
-        addl    %ebx, %ecx      /* avail_out += out */
-
-        movl    %ebx, out(%esp)
-        movl    %ebp, beg(%esp)
-        movl    %ecx, end(%esp)
-
-        /* wsize = state->wsize;
-         * write = state->write;
-         * window = state->window;
-         * hold = state->hold;
-         * bits = state->bits;
-         * lcode = state->lencode;
-         * dcode = state->distcode;
-         * lmask = ( 1 << state->lenbits ) - 1;
-         * dmask = ( 1 << state->distbits ) - 1;
-         */
-
-        movl    lencode_state(state_r), %eax
-        movl    distcode_state(state_r), %ecx
-
-        movl    %eax, lcode(%esp)
-        movl    %ecx, dcode(%esp)
-
-        movl    $1, %eax
-        movl    lenbits_state(state_r), %ecx
-        shll    %cl, %eax
-        decl    %eax
-        movl    %eax, lmask(%esp)
-
-        movl    $1, %eax
-        movl    distbits_state(state_r), %ecx
-        shll    %cl, %eax
-        decl    %eax
-        movl    %eax, dmask(%esp)
-
-        movl    wsize_state(state_r), %eax
-        movl    write_state(state_r), %ecx
-        movl    window_state(state_r), %edx
-
-        movl    %eax, wsize(%esp)
-        movl    %ecx, write(%esp)
-        movl    %edx, window(%esp)
-
-        movl    hold_state(state_r), %ebp
-        movl    bits_state(state_r), %ebx
-
-#undef strm_r
-#undef state_r
-
-#define in_r       %esi
-#define from_r     %esi
-#define out_r      %edi
-
-        movl    in(%esp), in_r
-        movl    last(%esp), %ecx
-        cmpl    in_r, %ecx
-        ja      .L_align_long           /* if in < last */
-
-        addl    $11, %ecx               /* ecx = &in[ avail_in ] */
-        subl    in_r, %ecx              /* ecx = avail_in */
-        movl    $12, %eax
-        subl    %ecx, %eax              /* eax = 12 - avail_in */
-        leal    buf(%esp), %edi
-        rep     movsb                   /* memcpy( buf, in, avail_in ) */
-        movl    %eax, %ecx
-        xorl    %eax, %eax
-        rep     stosb         /* memset( &buf[ avail_in ], 0, 12 - avail_in ) */
-        leal    buf(%esp), in_r         /* in = buf */
-        movl    in_r, last(%esp)        /* last = in, do just one iteration */
-        jmp     .L_is_aligned
-
-        /* align in_r on long boundary */
-.L_align_long:
-        testl   $3, in_r
-        jz      .L_is_aligned
-        xorl    %eax, %eax
-        movb    (in_r), %al
-        incl    in_r
-        movl    %ebx, %ecx
-        addl    $8, %ebx
-        shll    %cl, %eax
-        orl     %eax, %ebp
-        jmp     .L_align_long
-
-.L_is_aligned:
-        movl    out(%esp), out_r
-
-#if defined( NO_MMX )
-        jmp     .L_do_loop
-#endif
-
-#if defined( USE_MMX )
-        jmp     .L_init_mmx
-#endif
-
-/*** Runtime MMX check ***/
-
-#if defined( RUN_TIME_MMX )
-.L_check_mmx:
-        cmpl    $DO_USE_MMX, inflate_fast_use_mmx
-        je      .L_init_mmx
-        ja      .L_do_loop /* > 2 */
-
-        pushl   %eax
-        pushl   %ebx
-        pushl   %ecx
-        pushl   %edx
-        pushf
-        movl    (%esp), %eax      /* copy eflags to eax */
-        xorl    $0x200000, (%esp) /* try toggling ID bit of eflags (bit 21)
-                                   * to see if cpu supports cpuid...
-                                   * ID bit method not supported by NexGen but
-                                   * bios may load a cpuid instruction and
-                                   * cpuid may be disabled on Cyrix 5-6x86 */
-        popf
-        pushf
-        popl    %edx              /* copy new eflags to edx */
-        xorl    %eax, %edx        /* test if ID bit is flipped */
-        jz      .L_dont_use_mmx   /* not flipped if zero */
-        xorl    %eax, %eax
-        cpuid
-        cmpl    $0x756e6547, %ebx /* check for GenuineIntel in ebx,ecx,edx */
-        jne     .L_dont_use_mmx
-        cmpl    $0x6c65746e, %ecx
-        jne     .L_dont_use_mmx
-        cmpl    $0x49656e69, %edx
-        jne     .L_dont_use_mmx
-        movl    $1, %eax
-        cpuid                     /* get cpu features */
-        shrl    $8, %eax
-        andl    $15, %eax
-        cmpl    $6, %eax          /* check for Pentium family, is 0xf for P4 */
-        jne     .L_dont_use_mmx
-        testl   $0x800000, %edx   /* test if MMX feature is set (bit 23) */
-        jnz     .L_use_mmx
-        jmp     .L_dont_use_mmx
-.L_use_mmx:
-        movl    $DO_USE_MMX, inflate_fast_use_mmx
-        jmp     .L_check_mmx_pop
-.L_dont_use_mmx:
-        movl    $DONT_USE_MMX, inflate_fast_use_mmx
-.L_check_mmx_pop:
-        popl    %edx
-        popl    %ecx
-        popl    %ebx
-        popl    %eax
-        jmp     .L_check_mmx
-#endif
-
-
-/*** Non-MMX code ***/
-
-#if defined ( NO_MMX ) || defined( RUN_TIME_MMX )
-
-#define hold_r     %ebp
-#define bits_r     %bl
-#define bitslong_r %ebx
-
-.align 32,0x90
-.L_while_test:
-        /* while (in < last && out < end)
-         */
-        cmpl    out_r, end(%esp)
-        jbe     .L_break_loop           /* if (out >= end) */
-
-        cmpl    in_r, last(%esp)
-        jbe     .L_break_loop
-
-.L_do_loop:
-        /* regs: %esi = in, %ebp = hold, %bl = bits, %edi = out
-         *
-         * do {
-         *   if (bits < 15) {
-         *     hold |= *((unsigned short *)in)++ << bits;
-         *     bits += 16
-         *   }
-         *   this = lcode[hold & lmask]
-         */
-        cmpb    $15, bits_r
-        ja      .L_get_length_code      /* if (15 < bits) */
-
-        xorl    %eax, %eax
-        lodsw                           /* al = *(ushort *)in++ */
-        movb    bits_r, %cl             /* cl = bits, needs it for shifting */
-        addb    $16, bits_r             /* bits += 16 */
-        shll    %cl, %eax
-        orl     %eax, hold_r            /* hold |= *((ushort *)in)++ << bits */
-
-.L_get_length_code:
-        movl    lmask(%esp), %edx       /* edx = lmask */
-        movl    lcode(%esp), %ecx       /* ecx = lcode */
-        andl    hold_r, %edx            /* edx &= hold */
-        movl    (%ecx,%edx,4), %eax     /* eax = lcode[hold & lmask] */
-
-.L_dolen:
-        /* regs: %esi = in, %ebp = hold, %bl = bits, %edi = out
-         *
-         * dolen:
-         *    bits -= this.bits;
-         *    hold >>= this.bits
-         */
-        movb    %ah, %cl                /* cl = this.bits */
-        subb    %ah, bits_r             /* bits -= this.bits */
-        shrl    %cl, hold_r             /* hold >>= this.bits */
-
-        /* check if op is a literal
-         * if (op == 0) {
-         *    PUP(out) = this.val;
-         *  }
-         */
-        testb   %al, %al
-        jnz     .L_test_for_length_base /* if (op != 0) 45.7% */
-
-        shrl    $16, %eax               /* output this.val char */
-        stosb
-        jmp     .L_while_test
-
-.L_test_for_length_base:
-        /* regs: %esi = in, %ebp = hold, %bl = bits, %edi = out, %edx = len
-         *
-         * else if (op & 16) {
-         *   len = this.val
-         *   op &= 15
-         *   if (op) {
-         *     if (op > bits) {
-         *       hold |= *((unsigned short *)in)++ << bits;
-         *       bits += 16
-         *     }
-         *     len += hold & mask[op];
-         *     bits -= op;
-         *     hold >>= op;
-         *   }
-         */
-#define len_r %edx
-        movl    %eax, len_r             /* len = this */
-        shrl    $16, len_r              /* len = this.val */
-        movb    %al, %cl
-
-        testb   $16, %al
-        jz      .L_test_for_second_level_length /* if ((op & 16) == 0) 8% */
-        andb    $15, %cl                /* op &= 15 */
-        jz      .L_save_len             /* if (!op) */
-        cmpb    %cl, bits_r
-        jae     .L_add_bits_to_len      /* if (op <= bits) */
-
-        movb    %cl, %ch                /* stash op in ch, freeing cl */
-        xorl    %eax, %eax
-        lodsw                           /* al = *(ushort *)in++ */
-        movb    bits_r, %cl             /* cl = bits, needs it for shifting */
-        addb    $16, bits_r             /* bits += 16 */
-        shll    %cl, %eax
-        orl     %eax, hold_r            /* hold |= *((ushort *)in)++ << bits */
-        movb    %ch, %cl                /* move op back to ecx */
-
-.L_add_bits_to_len:
-        movl    $1, %eax
-        shll    %cl, %eax
-        decl    %eax
-        subb    %cl, bits_r
-        andl    hold_r, %eax            /* eax &= hold */
-        shrl    %cl, hold_r
-        addl    %eax, len_r             /* len += hold & mask[op] */
-
-.L_save_len:
-        movl    len_r, len(%esp)        /* save len */
-#undef  len_r
-
-.L_decode_distance:
-        /* regs: %esi = in, %ebp = hold, %bl = bits, %edi = out, %edx = dist
-         *
-         *   if (bits < 15) {
-         *     hold |= *((unsigned short *)in)++ << bits;
-         *     bits += 16
-         *   }
-         *   this = dcode[hold & dmask];
-         * dodist:
-         *   bits -= this.bits;
-         *   hold >>= this.bits;
-         *   op = this.op;
-         */
-
-        cmpb    $15, bits_r
-        ja      .L_get_distance_code    /* if (15 < bits) */
-
-        xorl    %eax, %eax
-        lodsw                           /* al = *(ushort *)in++ */
-        movb    bits_r, %cl             /* cl = bits, needs it for shifting */
-        addb    $16, bits_r             /* bits += 16 */
-        shll    %cl, %eax
-        orl     %eax, hold_r            /* hold |= *((ushort *)in)++ << bits */
-
-.L_get_distance_code:
-        movl    dmask(%esp), %edx       /* edx = dmask */
-        movl    dcode(%esp), %ecx       /* ecx = dcode */
-        andl    hold_r, %edx            /* edx &= hold */
-        movl    (%ecx,%edx,4), %eax     /* eax = dcode[hold & dmask] */
-
-#define dist_r %edx
-.L_dodist:
-        movl    %eax, dist_r            /* dist = this */
-        shrl    $16, dist_r             /* dist = this.val */
-        movb    %ah, %cl
-        subb    %ah, bits_r             /* bits -= this.bits */
-        shrl    %cl, hold_r             /* hold >>= this.bits */
-
-        /* if (op & 16) {
-         *   dist = this.val
-         *   op &= 15
-         *   if (op > bits) {
-         *     hold |= *((unsigned short *)in)++ << bits;
-         *     bits += 16
-         *   }
-         *   dist += hold & mask[op];
-         *   bits -= op;
-         *   hold >>= op;
-         */
-        movb    %al, %cl                /* cl = this.op */
-
-        testb   $16, %al                /* if ((op & 16) == 0) */
-        jz      .L_test_for_second_level_dist
-        andb    $15, %cl                /* op &= 15 */
-        jz      .L_check_dist_one
-        cmpb    %cl, bits_r
-        jae     .L_add_bits_to_dist     /* if (op <= bits) 97.6% */
-
-        movb    %cl, %ch                /* stash op in ch, freeing cl */
-        xorl    %eax, %eax
-        lodsw                           /* al = *(ushort *)in++ */
-        movb    bits_r, %cl             /* cl = bits, needs it for shifting */
-        addb    $16, bits_r             /* bits += 16 */
-        shll    %cl, %eax
-        orl     %eax, hold_r            /* hold |= *((ushort *)in)++ << bits */
-        movb    %ch, %cl                /* move op back to ecx */
-
-.L_add_bits_to_dist:
-        movl    $1, %eax
-        shll    %cl, %eax
-        decl    %eax                    /* (1 << op) - 1 */
-        subb    %cl, bits_r
-        andl    hold_r, %eax            /* eax &= hold */
-        shrl    %cl, hold_r
-        addl    %eax, dist_r            /* dist += hold & ((1 << op) - 1) */
-        jmp     .L_check_window
-
-.L_check_window:
-        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist
-         *       %ecx = nbytes
-         *
-         * nbytes = out - beg;
-         * if (dist <= nbytes) {
-         *   from = out - dist;
-         *   do {
-         *     PUP(out) = PUP(from);
-         *   } while (--len > 0) {
-         * }
-         */
-
-        movl    in_r, in(%esp)          /* save in so from can use it's reg */
-        movl    out_r, %eax
-        subl    beg(%esp), %eax         /* nbytes = out - beg */
-
-        cmpl    dist_r, %eax
-        jb      .L_clip_window          /* if (dist > nbytes) 4.2% */
-
-        movl    len(%esp), %ecx
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-
-        subl    $3, %ecx
-        movb    (from_r), %al
-        movb    %al, (out_r)
-        movb    1(from_r), %al
-        movb    2(from_r), %dl
-        addl    $3, from_r
-        movb    %al, 1(out_r)
-        movb    %dl, 2(out_r)
-        addl    $3, out_r
-        rep     movsb
-
-        movl    in(%esp), in_r          /* move in back to %esi, toss from */
-        jmp     .L_while_test
-
-.align 16,0x90
-.L_check_dist_one:
-        cmpl    $1, dist_r
-        jne     .L_check_window
-        cmpl    out_r, beg(%esp)
-        je      .L_check_window
-
-        decl    out_r
-        movl    len(%esp), %ecx
-        movb    (out_r), %al
-        subl    $3, %ecx
-
-        movb    %al, 1(out_r)
-        movb    %al, 2(out_r)
-        movb    %al, 3(out_r)
-        addl    $4, out_r
-        rep     stosb
-
-        jmp     .L_while_test
-
-.align 16,0x90
-.L_test_for_second_level_length:
-        /* else if ((op & 64) == 0) {
-         *   this = lcode[this.val + (hold & mask[op])];
-         * }
-         */
-        testb   $64, %al
-        jnz     .L_test_for_end_of_block  /* if ((op & 64) != 0) */
-
-        movl    $1, %eax
-        shll    %cl, %eax
-        decl    %eax
-        andl    hold_r, %eax            /* eax &= hold */
-        addl    %edx, %eax              /* eax += this.val */
-        movl    lcode(%esp), %edx       /* edx = lcode */
-        movl    (%edx,%eax,4), %eax     /* eax = lcode[val + (hold&mask[op])] */
-        jmp     .L_dolen
-
-.align 16,0x90
-.L_test_for_second_level_dist:
-        /* else if ((op & 64) == 0) {
-         *   this = dcode[this.val + (hold & mask[op])];
-         * }
-         */
-        testb   $64, %al
-        jnz     .L_invalid_distance_code  /* if ((op & 64) != 0) */
-
-        movl    $1, %eax
-        shll    %cl, %eax
-        decl    %eax
-        andl    hold_r, %eax            /* eax &= hold */
-        addl    %edx, %eax              /* eax += this.val */
-        movl    dcode(%esp), %edx       /* edx = dcode */
-        movl    (%edx,%eax,4), %eax     /* eax = dcode[val + (hold&mask[op])] */
-        jmp     .L_dodist
-
-.align 16,0x90
-.L_clip_window:
-        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist
-         *       %ecx = nbytes
-         *
-         * else {
-         *   if (dist > wsize) {
-         *     invalid distance
-         *   }
-         *   from = window;
-         *   nbytes = dist - nbytes;
-         *   if (write == 0) {
-         *     from += wsize - nbytes;
-         */
-#define nbytes_r %ecx
-        movl    %eax, nbytes_r
-        movl    wsize(%esp), %eax       /* prepare for dist compare */
-        negl    nbytes_r                /* nbytes = -nbytes */
-        movl    window(%esp), from_r    /* from = window */
-
-        cmpl    dist_r, %eax
-        jb      .L_invalid_distance_too_far /* if (dist > wsize) */
-
-        addl    dist_r, nbytes_r        /* nbytes = dist - nbytes */
-        cmpl    $0, write(%esp)
-        jne     .L_wrap_around_window   /* if (write != 0) */
-
-        subl    nbytes_r, %eax
-        addl    %eax, from_r            /* from += wsize - nbytes */
-
-        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist
-         *       %ecx = nbytes, %eax = len
-         *
-         *     if (nbytes < len) {
-         *       len -= nbytes;
-         *       do {
-         *         PUP(out) = PUP(from);
-         *       } while (--nbytes);
-         *       from = out - dist;
-         *     }
-         *   }
-         */
-#define len_r %eax
-        movl    len(%esp), len_r
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1             /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-        jmp     .L_do_copy1
-
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1             /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-        jmp     .L_do_copy1
-
-.L_wrap_around_window:
-        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist
-         *       %ecx = nbytes, %eax = write, %eax = len
-         *
-         *   else if (write < nbytes) {
-         *     from += wsize + write - nbytes;
-         *     nbytes -= write;
-         *     if (nbytes < len) {
-         *       len -= nbytes;
-         *       do {
-         *         PUP(out) = PUP(from);
-         *       } while (--nbytes);
-         *       from = window;
-         *       nbytes = write;
-         *       if (nbytes < len) {
-         *         len -= nbytes;
-         *         do {
-         *           PUP(out) = PUP(from);
-         *         } while(--nbytes);
-         *         from = out - dist;
-         *       }
-         *     }
-         *   }
-         */
-#define write_r %eax
-        movl    write(%esp), write_r
-        cmpl    write_r, nbytes_r
-        jbe     .L_contiguous_in_window /* if (write >= nbytes) */
-
-        addl    wsize(%esp), from_r
-        addl    write_r, from_r
-        subl    nbytes_r, from_r        /* from += wsize + write - nbytes */
-        subl    write_r, nbytes_r       /* nbytes -= write */
-#undef write_r
-
-        movl    len(%esp), len_r
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1             /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    window(%esp), from_r    /* from = window */
-        movl    write(%esp), nbytes_r   /* nbytes = write */
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1             /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-        jmp     .L_do_copy1
-
-.L_contiguous_in_window:
-        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist
-         *       %ecx = nbytes, %eax = write, %eax = len
-         *
-         *   else {
-         *     from += write - nbytes;
-         *     if (nbytes < len) {
-         *       len -= nbytes;
-         *       do {
-         *         PUP(out) = PUP(from);
-         *       } while (--nbytes);
-         *       from = out - dist;
-         *     }
-         *   }
-         */
-#define write_r %eax
-        addl    write_r, from_r
-        subl    nbytes_r, from_r        /* from += write - nbytes */
-#undef write_r
-
-        movl    len(%esp), len_r
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1             /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-
-.L_do_copy1:
-        /* regs: %esi = from, %esi = in, %ebp = hold, %bl = bits, %edi = out
-         *       %eax = len
-         *
-         *     while (len > 0) {
-         *       PUP(out) = PUP(from);
-         *       len--;
-         *     }
-         *   }
-         * } while (in < last && out < end);
-         */
-#undef nbytes_r
-#define in_r %esi
-        movl    len_r, %ecx
-        rep     movsb
-
-        movl    in(%esp), in_r          /* move in back to %esi, toss from */
-        jmp     .L_while_test
-
-#undef len_r
-#undef dist_r
-
-#endif /* NO_MMX || RUN_TIME_MMX */
-
-
-/*** MMX code ***/
-
-#if defined( USE_MMX ) || defined( RUN_TIME_MMX )
-
-.align 32,0x90
-.L_init_mmx:
-        emms
-
-#undef  bits_r
-#undef  bitslong_r
-#define bitslong_r %ebp
-#define hold_mm    %mm0
-        movd    %ebp, hold_mm
-        movl    %ebx, bitslong_r
-
-#define used_mm   %mm1
-#define dmask2_mm %mm2
-#define lmask2_mm %mm3
-#define lmask_mm  %mm4
-#define dmask_mm  %mm5
-#define tmp_mm    %mm6
-
-        movd    lmask(%esp), lmask_mm
-        movq    lmask_mm, lmask2_mm
-        movd    dmask(%esp), dmask_mm
-        movq    dmask_mm, dmask2_mm
-        pxor    used_mm, used_mm
-        movl    lcode(%esp), %ebx       /* ebx = lcode */
-        jmp     .L_do_loop_mmx
-
-.align 32,0x90
-.L_while_test_mmx:
-        /* while (in < last && out < end)
-         */
-        cmpl    out_r, end(%esp)
-        jbe     .L_break_loop           /* if (out >= end) */
-
-        cmpl    in_r, last(%esp)
-        jbe     .L_break_loop
-
-.L_do_loop_mmx:
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-
-        cmpl    $32, bitslong_r
-        ja      .L_get_length_code_mmx  /* if (32 < bits) */
-
-        movd    bitslong_r, tmp_mm
-        movd    (in_r), %mm7
-        addl    $4, in_r
-        psllq   tmp_mm, %mm7
-        addl    $32, bitslong_r
-        por     %mm7, hold_mm           /* hold_mm |= *((uint *)in)++ << bits */
-
-.L_get_length_code_mmx:
-        pand    hold_mm, lmask_mm
-        movd    lmask_mm, %eax
-        movq    lmask2_mm, lmask_mm
-        movl    (%ebx,%eax,4), %eax     /* eax = lcode[hold & lmask] */
-
-.L_dolen_mmx:
-        movzbl  %ah, %ecx               /* ecx = this.bits */
-        movd    %ecx, used_mm
-        subl    %ecx, bitslong_r        /* bits -= this.bits */
-
-        testb   %al, %al
-        jnz     .L_test_for_length_base_mmx /* if (op != 0) 45.7% */
-
-        shrl    $16, %eax               /* output this.val char */
-        stosb
-        jmp     .L_while_test_mmx
-
-.L_test_for_length_base_mmx:
-#define len_r  %edx
-        movl    %eax, len_r             /* len = this */
-        shrl    $16, len_r              /* len = this.val */
-
-        testb   $16, %al
-        jz      .L_test_for_second_level_length_mmx /* if ((op & 16) == 0) 8% */
-        andl    $15, %eax               /* op &= 15 */
-        jz      .L_decode_distance_mmx  /* if (!op) */
-
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-        movd    %eax, used_mm
-        movd    hold_mm, %ecx
-        subl    %eax, bitslong_r
-        andl    .L_mask(,%eax,4), %ecx
-        addl    %ecx, len_r             /* len += hold & mask[op] */
-
-.L_decode_distance_mmx:
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-
-        cmpl    $32, bitslong_r
-        ja      .L_get_dist_code_mmx    /* if (32 < bits) */
-
-        movd    bitslong_r, tmp_mm
-        movd    (in_r), %mm7
-        addl    $4, in_r
-        psllq   tmp_mm, %mm7
-        addl    $32, bitslong_r
-        por     %mm7, hold_mm           /* hold_mm |= *((uint *)in)++ << bits */
-
-.L_get_dist_code_mmx:
-        movl    dcode(%esp), %ebx       /* ebx = dcode */
-        pand    hold_mm, dmask_mm
-        movd    dmask_mm, %eax
-        movq    dmask2_mm, dmask_mm
-        movl    (%ebx,%eax,4), %eax     /* eax = dcode[hold & lmask] */
-
-.L_dodist_mmx:
-#define dist_r %ebx
-        movzbl  %ah, %ecx               /* ecx = this.bits */
-        movl    %eax, dist_r
-        shrl    $16, dist_r             /* dist  = this.val */
-        subl    %ecx, bitslong_r        /* bits -= this.bits */
-        movd    %ecx, used_mm
-
-        testb   $16, %al                /* if ((op & 16) == 0) */
-        jz      .L_test_for_second_level_dist_mmx
-        andl    $15, %eax               /* op &= 15 */
-        jz      .L_check_dist_one_mmx
-
-.L_add_bits_to_dist_mmx:
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-        movd    %eax, used_mm           /* save bit length of current op */
-        movd    hold_mm, %ecx           /* get the next bits on input stream */
-        subl    %eax, bitslong_r        /* bits -= op bits */
-        andl    .L_mask(,%eax,4), %ecx  /* ecx   = hold & mask[op] */
-        addl    %ecx, dist_r            /* dist += hold & mask[op] */
-
-.L_check_window_mmx:
-        movl    in_r, in(%esp)          /* save in so from can use it's reg */
-        movl    out_r, %eax
-        subl    beg(%esp), %eax         /* nbytes = out - beg */
-
-        cmpl    dist_r, %eax
-        jb      .L_clip_window_mmx      /* if (dist > nbytes) 4.2% */
-
-        movl    len_r, %ecx
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-
-        subl    $3, %ecx
-        movb    (from_r), %al
-        movb    %al, (out_r)
-        movb    1(from_r), %al
-        movb    2(from_r), %dl
-        addl    $3, from_r
-        movb    %al, 1(out_r)
-        movb    %dl, 2(out_r)
-        addl    $3, out_r
-        rep     movsb
-
-        movl    in(%esp), in_r          /* move in back to %esi, toss from */
-        movl    lcode(%esp), %ebx       /* move lcode back to %ebx, toss dist */
-        jmp     .L_while_test_mmx
-
-.align 16,0x90
-.L_check_dist_one_mmx:
-        cmpl    $1, dist_r
-        jne     .L_check_window_mmx
-        cmpl    out_r, beg(%esp)
-        je      .L_check_window_mmx
-
-        decl    out_r
-        movl    len_r, %ecx
-        movb    (out_r), %al
-        subl    $3, %ecx
-
-        movb    %al, 1(out_r)
-        movb    %al, 2(out_r)
-        movb    %al, 3(out_r)
-        addl    $4, out_r
-        rep     stosb
-
-        movl    lcode(%esp), %ebx       /* move lcode back to %ebx, toss dist */
-        jmp     .L_while_test_mmx
-
-.align 16,0x90
-.L_test_for_second_level_length_mmx:
-        testb   $64, %al
-        jnz     .L_test_for_end_of_block  /* if ((op & 64) != 0) */
-
-        andl    $15, %eax
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-        movd    hold_mm, %ecx
-        andl    .L_mask(,%eax,4), %ecx
-        addl    len_r, %ecx
-        movl    (%ebx,%ecx,4), %eax     /* eax = lcode[hold & lmask] */
-        jmp     .L_dolen_mmx
-
-.align 16,0x90
-.L_test_for_second_level_dist_mmx:
-        testb   $64, %al
-        jnz     .L_invalid_distance_code  /* if ((op & 64) != 0) */
-
-        andl    $15, %eax
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-        movd    hold_mm, %ecx
-        andl    .L_mask(,%eax,4), %ecx
-        movl    dcode(%esp), %eax       /* ecx = dcode */
-        addl    dist_r, %ecx
-        movl    (%eax,%ecx,4), %eax     /* eax = lcode[hold & lmask] */
-        jmp     .L_dodist_mmx
-
-.align 16,0x90
-.L_clip_window_mmx:
-#define nbytes_r %ecx
-        movl    %eax, nbytes_r
-        movl    wsize(%esp), %eax       /* prepare for dist compare */
-        negl    nbytes_r                /* nbytes = -nbytes */
-        movl    window(%esp), from_r    /* from = window */
-
-        cmpl    dist_r, %eax
-        jb      .L_invalid_distance_too_far /* if (dist > wsize) */
-
-        addl    dist_r, nbytes_r        /* nbytes = dist - nbytes */
-        cmpl    $0, write(%esp)
-        jne     .L_wrap_around_window_mmx /* if (write != 0) */
-
-        subl    nbytes_r, %eax
-        addl    %eax, from_r            /* from += wsize - nbytes */
-
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-        jmp     .L_do_copy1_mmx
-
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-        jmp     .L_do_copy1_mmx
-
-.L_wrap_around_window_mmx:
-#define write_r %eax
-        movl    write(%esp), write_r
-        cmpl    write_r, nbytes_r
-        jbe     .L_contiguous_in_window_mmx /* if (write >= nbytes) */
-
-        addl    wsize(%esp), from_r
-        addl    write_r, from_r
-        subl    nbytes_r, from_r        /* from += wsize + write - nbytes */
-        subl    write_r, nbytes_r       /* nbytes -= write */
-#undef write_r
-
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    window(%esp), from_r    /* from = window */
-        movl    write(%esp), nbytes_r   /* nbytes = write */
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-        jmp     .L_do_copy1_mmx
-
-.L_contiguous_in_window_mmx:
-#define write_r %eax
-        addl    write_r, from_r
-        subl    nbytes_r, from_r        /* from += write - nbytes */
-#undef write_r
-
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-
-.L_do_copy1_mmx:
-#undef nbytes_r
-#define in_r %esi
-        movl    len_r, %ecx
-        rep     movsb
-
-        movl    in(%esp), in_r          /* move in back to %esi, toss from */
-        movl    lcode(%esp), %ebx       /* move lcode back to %ebx, toss dist */
-        jmp     .L_while_test_mmx
-
-#undef hold_r
-#undef bitslong_r
-
-#endif /* USE_MMX || RUN_TIME_MMX */
-
-
-/*** USE_MMX, NO_MMX, and RUNTIME_MMX from here on ***/
-
-.L_invalid_distance_code:
-        /* else {
-         *   strm->msg = "invalid distance code";
-         *   state->mode = BAD;
-         * }
-         */
-        movl    $.L_invalid_distance_code_msg, %ecx
-        movl    $INFLATE_MODE_BAD, %edx
-        jmp     .L_update_stream_state
-
-.L_test_for_end_of_block:
-        /* else if (op & 32) {
-         *   state->mode = TYPE;
-         *   break;
-         * }
-         */
-        testb   $32, %al
-        jz      .L_invalid_literal_length_code  /* if ((op & 32) == 0) */
-
-        movl    $0, %ecx
-        movl    $INFLATE_MODE_TYPE, %edx
-        jmp     .L_update_stream_state
-
-.L_invalid_literal_length_code:
-        /* else {
-         *   strm->msg = "invalid literal/length code";
-         *   state->mode = BAD;
-         * }
-         */
-        movl    $.L_invalid_literal_length_code_msg, %ecx
-        movl    $INFLATE_MODE_BAD, %edx
-        jmp     .L_update_stream_state
-
-.L_invalid_distance_too_far:
-        /* strm->msg = "invalid distance too far back";
-         * state->mode = BAD;
-         */
-        movl    in(%esp), in_r          /* from_r has in's reg, put in back */
-        movl    $.L_invalid_distance_too_far_msg, %ecx
-        movl    $INFLATE_MODE_BAD, %edx
-        jmp     .L_update_stream_state
-
-.L_update_stream_state:
-        /* set strm->msg = %ecx, strm->state->mode = %edx */
-        movl    strm_sp(%esp), %eax
-        testl   %ecx, %ecx              /* if (msg != NULL) */
-        jz      .L_skip_msg
-        movl    %ecx, msg_strm(%eax)    /* strm->msg = msg */
-.L_skip_msg:
-        movl    state_strm(%eax), %eax  /* state = strm->state */
-        movl    %edx, mode_state(%eax)  /* state->mode = edx (BAD | TYPE) */
-        jmp     .L_break_loop
-
-.align 32,0x90
-.L_break_loop:
-
-/*
- * Regs:
- *
- * bits = %ebp when mmx, and in %ebx when non-mmx
- * hold = %hold_mm when mmx, and in %ebp when non-mmx
- * in   = %esi
- * out  = %edi
- */
-
-#if defined( USE_MMX ) || defined( RUN_TIME_MMX )
-
-#if defined( RUN_TIME_MMX )
-
-        cmpl    $DO_USE_MMX, inflate_fast_use_mmx
-        jne     .L_update_next_in
-
-#endif /* RUN_TIME_MMX */
-
-        movl    %ebp, %ebx
-
-.L_update_next_in:
-
-#endif
-
-#define strm_r  %eax
-#define state_r %edx
-
-        /* len = bits >> 3;
-         * in -= len;
-         * bits -= len << 3;
-         * hold &= (1U << bits) - 1;
-         * state->hold = hold;
-         * state->bits = bits;
-         * strm->next_in = in;
-         * strm->next_out = out;
-         */
-        movl    strm_sp(%esp), strm_r
-        movl    %ebx, %ecx
-        movl    state_strm(strm_r), state_r
-        shrl    $3, %ecx
-        subl    %ecx, in_r
-        shll    $3, %ecx
-        subl    %ecx, %ebx
-        movl    out_r, next_out_strm(strm_r)
-        movl    %ebx, bits_state(state_r)
-        movl    %ebx, %ecx
-
-        leal    buf(%esp), %ebx
-        cmpl    %ebx, last(%esp)
-        jne     .L_buf_not_used         /* if buf != last */
-
-        subl    %ebx, in_r              /* in -= buf */
-        movl    next_in_strm(strm_r), %ebx
-        movl    %ebx, last(%esp)        /* last = strm->next_in */
-        addl    %ebx, in_r              /* in += strm->next_in */
-        movl    avail_in_strm(strm_r), %ebx
-        subl    $11, %ebx
-        addl    %ebx, last(%esp)    /* last = &strm->next_in[ avail_in - 11 ] */
-
-.L_buf_not_used:
-        movl    in_r, next_in_strm(strm_r)
-
-        movl    $1, %ebx
-        shll    %cl, %ebx
-        decl    %ebx
-
-#if defined( USE_MMX ) || defined( RUN_TIME_MMX )
-
-#if defined( RUN_TIME_MMX )
-
-        cmpl    $DO_USE_MMX, inflate_fast_use_mmx
-        jne     .L_update_hold
-
-#endif /* RUN_TIME_MMX */
-
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-        movd    hold_mm, %ebp
-
-        emms
-
-.L_update_hold:
-
-#endif /* USE_MMX || RUN_TIME_MMX */
-
-        andl    %ebx, %ebp
-        movl    %ebp, hold_state(state_r)
-
-#define last_r %ebx
-
-        /* strm->avail_in = in < last ? 11 + (last - in) : 11 - (in - last) */
-        movl    last(%esp), last_r
-        cmpl    in_r, last_r
-        jbe     .L_last_is_smaller     /* if (in >= last) */
-
-        subl    in_r, last_r           /* last -= in */
-        addl    $11, last_r            /* last += 11 */
-        movl    last_r, avail_in_strm(strm_r)
-        jmp     .L_fixup_out
-.L_last_is_smaller:
-        subl    last_r, in_r           /* in -= last */
-        negl    in_r                   /* in = -in */
-        addl    $11, in_r              /* in += 11 */
-        movl    in_r, avail_in_strm(strm_r)
-
-#undef last_r
-#define end_r %ebx
-
-.L_fixup_out:
-        /* strm->avail_out = out < end ? 257 + (end - out) : 257 - (out - end)*/
-        movl    end(%esp), end_r
-        cmpl    out_r, end_r
-        jbe     .L_end_is_smaller      /* if (out >= end) */
-
-        subl    out_r, end_r           /* end -= out */
-        addl    $257, end_r            /* end += 257 */
-        movl    end_r, avail_out_strm(strm_r)
-        jmp     .L_done
-.L_end_is_smaller:
-        subl    end_r, out_r           /* out -= end */
-        negl    out_r                  /* out = -out */
-        addl    $257, out_r            /* out += 257 */
-        movl    out_r, avail_out_strm(strm_r)
-
-#undef end_r
-#undef strm_r
-#undef state_r
-
-.L_done:
-        addl    $local_var_size, %esp
-        popf
-        popl    %ebx
-        popl    %ebp
-        popl    %esi
-        popl    %edi
-        ret
-
-#if defined( GAS_ELF )
-/* elf info */
-.type inflate_fast,@function
-.size inflate_fast,.-inflate_fast
-#endif
diff -Nbaur gcc-4.8.1/zlib/contrib/iostream/test.cpp gcc-4.8.1-ppc/zlib/contrib/iostream/test.cpp
--- gcc-4.8.1/zlib/contrib/iostream/test.cpp	2004-10-11 18:35:40.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/iostream/test.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,24 +0,0 @@
-
-#include "zfstream.h"
-
-int main() {
-
-  // Construct a stream object with this filebuffer.  Anything sent
-  // to this stream will go to standard out.
-  gzofstream os( 1, ios::out );
-
-  // This text is getting compressed and sent to stdout.
-  // To prove this, run 'test | zcat'.
-  os << "Hello, Mommy" << endl;
-
-  os << setcompressionlevel( Z_NO_COMPRESSION );
-  os << "hello, hello, hi, ho!" << endl;
-
-  setcompressionlevel( os, Z_DEFAULT_COMPRESSION )
-    << "I'm compressing again" << endl;
-
-  os.close();
-
-  return 0;
-
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/iostream/zfstream.cpp gcc-4.8.1-ppc/zlib/contrib/iostream/zfstream.cpp
--- gcc-4.8.1/zlib/contrib/iostream/zfstream.cpp	2004-10-11 19:45:43.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/iostream/zfstream.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,329 +0,0 @@
-
-#include "zfstream.h"
-
-gzfilebuf::gzfilebuf() :
-  file(NULL),
-  mode(0),
-  own_file_descriptor(0)
-{ }
-
-gzfilebuf::~gzfilebuf() {
-
-  sync();
-  if ( own_file_descriptor )
-    close();
-
-}
-
-gzfilebuf *gzfilebuf::open( const char *name,
-                            int io_mode ) {
-
-  if ( is_open() )
-    return NULL;
-
-  char char_mode[10];
-  char *p = char_mode;
-
-  if ( io_mode & ios::in ) {
-    mode = ios::in;
-    *p++ = 'r';
-  } else if ( io_mode & ios::app ) {
-    mode = ios::app;
-    *p++ = 'a';
-  } else {
-    mode = ios::out;
-    *p++ = 'w';
-  }
-
-  if ( io_mode & ios::binary ) {
-    mode |= ios::binary;
-    *p++ = 'b';
-  }
-
-  // Hard code the compression level
-  if ( io_mode & (ios::out|ios::app )) {
-    *p++ = '9';
-  }
-
-  // Put the end-of-string indicator
-  *p = '\0';
-
-  if ( (file = gzopen(name, char_mode)) == NULL )
-    return NULL;
-
-  own_file_descriptor = 1;
-
-  return this;
-
-}
-
-gzfilebuf *gzfilebuf::attach( int file_descriptor,
-                              int io_mode ) {
-
-  if ( is_open() )
-    return NULL;
-
-  char char_mode[10];
-  char *p = char_mode;
-
-  if ( io_mode & ios::in ) {
-    mode = ios::in;
-    *p++ = 'r';
-  } else if ( io_mode & ios::app ) {
-    mode = ios::app;
-    *p++ = 'a';
-  } else {
-    mode = ios::out;
-    *p++ = 'w';
-  }
-
-  if ( io_mode & ios::binary ) {
-    mode |= ios::binary;
-    *p++ = 'b';
-  }
-
-  // Hard code the compression level
-  if ( io_mode & (ios::out|ios::app )) {
-    *p++ = '9';
-  }
-
-  // Put the end-of-string indicator
-  *p = '\0';
-
-  if ( (file = gzdopen(file_descriptor, char_mode)) == NULL )
-    return NULL;
-
-  own_file_descriptor = 0;
-
-  return this;
-
-}
-
-gzfilebuf *gzfilebuf::close() {
-
-  if ( is_open() ) {
-
-    sync();
-    gzclose( file );
-    file = NULL;
-
-  }
-
-  return this;
-
-}
-
-int gzfilebuf::setcompressionlevel( int comp_level ) {
-
-  return gzsetparams(file, comp_level, -2);
-
-}
-
-int gzfilebuf::setcompressionstrategy( int comp_strategy ) {
-
-  return gzsetparams(file, -2, comp_strategy);
-
-}
-
-
-streampos gzfilebuf::seekoff( streamoff off, ios::seek_dir dir, int which ) {
-
-  return streampos(EOF);
-
-}
-
-int gzfilebuf::underflow() {
-
-  // If the file hasn't been opened for reading, error.
-  if ( !is_open() || !(mode & ios::in) )
-    return EOF;
-
-  // if a buffer doesn't exists, allocate one.
-  if ( !base() ) {
-
-    if ( (allocate()) == EOF )
-      return EOF;
-    setp(0,0);
-
-  } else {
-
-    if ( in_avail() )
-      return (unsigned char) *gptr();
-
-    if ( out_waiting() ) {
-      if ( flushbuf() == EOF )
-        return EOF;
-    }
-
-  }
-
-  // Attempt to fill the buffer.
-
-  int result = fillbuf();
-  if ( result == EOF ) {
-    // disable get area
-    setg(0,0,0);
-    return EOF;
-  }
-
-  return (unsigned char) *gptr();
-
-}
-
-int gzfilebuf::overflow( int c ) {
-
-  if ( !is_open() || !(mode & ios::out) )
-    return EOF;
-
-  if ( !base() ) {
-    if ( allocate() == EOF )
-      return EOF;
-    setg(0,0,0);
-  } else {
-    if (in_avail()) {
-        return EOF;
-    }
-    if (out_waiting()) {
-      if (flushbuf() == EOF)
-        return EOF;
-    }
-  }
-
-  int bl = blen();
-  setp( base(), base() + bl);
-
-  if ( c != EOF ) {
-
-    *pptr() = c;
-    pbump(1);
-
-  }
-
-  return 0;
-
-}
-
-int gzfilebuf::sync() {
-
-  if ( !is_open() )
-    return EOF;
-
-  if ( out_waiting() )
-    return flushbuf();
-
-  return 0;
-
-}
-
-int gzfilebuf::flushbuf() {
-
-  int n;
-  char *q;
-
-  q = pbase();
-  n = pptr() - q;
-
-  if ( gzwrite( file, q, n) < n )
-    return EOF;
-
-  setp(0,0);
-
-  return 0;
-
-}
-
-int gzfilebuf::fillbuf() {
-
-  int required;
-  char *p;
-
-  p = base();
-
-  required = blen();
-
-  int t = gzread( file, p, required );
-
-  if ( t <= 0) return EOF;
-
-  setg( base(), base(), base()+t);
-
-  return t;
-
-}
-
-gzfilestream_common::gzfilestream_common() :
-  ios( gzfilestream_common::rdbuf() )
-{ }
-
-gzfilestream_common::~gzfilestream_common()
-{ }
-
-void gzfilestream_common::attach( int fd, int io_mode ) {
-
-  if ( !buffer.attach( fd, io_mode) )
-    clear( ios::failbit | ios::badbit );
-  else
-    clear();
-
-}
-
-void gzfilestream_common::open( const char *name, int io_mode ) {
-
-  if ( !buffer.open( name, io_mode ) )
-    clear( ios::failbit | ios::badbit );
-  else
-    clear();
-
-}
-
-void gzfilestream_common::close() {
-
-  if ( !buffer.close() )
-    clear( ios::failbit | ios::badbit );
-
-}
-
-gzfilebuf *gzfilestream_common::rdbuf()
-{
-  return &buffer;
-}
-
-gzifstream::gzifstream() :
-  ios( gzfilestream_common::rdbuf() )
-{
-  clear( ios::badbit );
-}
-
-gzifstream::gzifstream( const char *name, int io_mode ) :
-  ios( gzfilestream_common::rdbuf() )
-{
-  gzfilestream_common::open( name, io_mode );
-}
-
-gzifstream::gzifstream( int fd, int io_mode ) :
-  ios( gzfilestream_common::rdbuf() )
-{
-  gzfilestream_common::attach( fd, io_mode );
-}
-
-gzifstream::~gzifstream() { }
-
-gzofstream::gzofstream() :
-  ios( gzfilestream_common::rdbuf() )
-{
-  clear( ios::badbit );
-}
-
-gzofstream::gzofstream( const char *name, int io_mode ) :
-  ios( gzfilestream_common::rdbuf() )
-{
-  gzfilestream_common::open( name, io_mode );
-}
-
-gzofstream::gzofstream( int fd, int io_mode ) :
-  ios( gzfilestream_common::rdbuf() )
-{
-  gzfilestream_common::attach( fd, io_mode );
-}
-
-gzofstream::~gzofstream() { }
diff -Nbaur gcc-4.8.1/zlib/contrib/iostream/zfstream.h gcc-4.8.1-ppc/zlib/contrib/iostream/zfstream.h
--- gcc-4.8.1/zlib/contrib/iostream/zfstream.h	2004-10-11 19:45:43.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/iostream/zfstream.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,128 +0,0 @@
-
-#ifndef zfstream_h
-#define zfstream_h
-
-#include <fstream.h>
-#include "zlib.h"
-
-class gzfilebuf : public streambuf {
-
-public:
-
-  gzfilebuf( );
-  virtual ~gzfilebuf();
-
-  gzfilebuf *open( const char *name, int io_mode );
-  gzfilebuf *attach( int file_descriptor, int io_mode );
-  gzfilebuf *close();
-
-  int setcompressionlevel( int comp_level );
-  int setcompressionstrategy( int comp_strategy );
-
-  inline int is_open() const { return (file !=NULL); }
-
-  virtual streampos seekoff( streamoff, ios::seek_dir, int );
-
-  virtual int sync();
-
-protected:
-
-  virtual int underflow();
-  virtual int overflow( int = EOF );
-
-private:
-
-  gzFile file;
-  short mode;
-  short own_file_descriptor;
-
-  int flushbuf();
-  int fillbuf();
-
-};
-
-class gzfilestream_common : virtual public ios {
-
-  friend class gzifstream;
-  friend class gzofstream;
-  friend gzofstream &setcompressionlevel( gzofstream &, int );
-  friend gzofstream &setcompressionstrategy( gzofstream &, int );
-
-public:
-  virtual ~gzfilestream_common();
-
-  void attach( int fd, int io_mode );
-  void open( const char *name, int io_mode );
-  void close();
-
-protected:
-  gzfilestream_common();
-
-private:
-  gzfilebuf *rdbuf();
-
-  gzfilebuf buffer;
-
-};
-
-class gzifstream : public gzfilestream_common, public istream {
-
-public:
-
-  gzifstream();
-  gzifstream( const char *name, int io_mode = ios::in );
-  gzifstream( int fd, int io_mode = ios::in );
-
-  virtual ~gzifstream();
-
-};
-
-class gzofstream : public gzfilestream_common, public ostream {
-
-public:
-
-  gzofstream();
-  gzofstream( const char *name, int io_mode = ios::out );
-  gzofstream( int fd, int io_mode = ios::out );
-
-  virtual ~gzofstream();
-
-};
-
-template<class T> class gzomanip {
-  friend gzofstream &operator<<(gzofstream &, const gzomanip<T> &);
-public:
-  gzomanip(gzofstream &(*f)(gzofstream &, T), T v) : func(f), val(v) { }
-private:
-  gzofstream &(*func)(gzofstream &, T);
-  T val;
-};
-
-template<class T> gzofstream &operator<<(gzofstream &s, const gzomanip<T> &m)
-{
-  return (*m.func)(s, m.val);
-}
-
-inline gzofstream &setcompressionlevel( gzofstream &s, int l )
-{
-  (s.rdbuf())->setcompressionlevel(l);
-  return s;
-}
-
-inline gzofstream &setcompressionstrategy( gzofstream &s, int l )
-{
-  (s.rdbuf())->setcompressionstrategy(l);
-  return s;
-}
-
-inline gzomanip<int> setcompressionlevel(int l)
-{
-  return gzomanip<int>(&setcompressionlevel,l);
-}
-
-inline gzomanip<int> setcompressionstrategy(int l)
-{
-  return gzomanip<int>(&setcompressionstrategy,l);
-}
-
-#endif
diff -Nbaur gcc-4.8.1/zlib/contrib/iostream2/zstream.h gcc-4.8.1-ppc/zlib/contrib/iostream2/zstream.h
--- gcc-4.8.1/zlib/contrib/iostream2/zstream.h	2004-10-11 18:35:40.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/iostream2/zstream.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,307 +0,0 @@
-/*
- *
- * Copyright (c) 1997
- * Christian Michelsen Research AS
- * Advanced Computing
- * Fantoftvegen 38, 5036 BERGEN, Norway
- * http://www.cmr.no
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Christian Michelsen Research AS makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- */
-
-#ifndef ZSTREAM__H
-#define ZSTREAM__H
-
-/*
- * zstream.h - C++ interface to the 'zlib' general purpose compression library
- * $Id: zstream.h,v 1.1 1999/05/04 19:30:27 tromey Exp $
- */
-
-#include <strstream.h>
-#include <string.h>
-#include <stdio.h>
-#include "zlib.h"
-
-#if defined(_WIN32)
-#   include <fcntl.h>
-#   include <io.h>
-#   define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
-#else
-#   define SET_BINARY_MODE(file)
-#endif
-
-class zstringlen {
-public:
-    zstringlen(class izstream&);
-    zstringlen(class ozstream&, const char*);
-    size_t value() const { return val.word; }
-private:
-    struct Val { unsigned char byte; size_t word; } val;
-};
-
-//  ----------------------------- izstream -----------------------------
-
-class izstream
-{
-    public:
-        izstream() : m_fp(0) {}
-        izstream(FILE* fp) : m_fp(0) { open(fp); }
-        izstream(const char* name) : m_fp(0) { open(name); }
-        ~izstream() { close(); }
-
-        /* Opens a gzip (.gz) file for reading.
-         * open() can be used to read a file which is not in gzip format;
-         * in this case read() will directly read from the file without
-         * decompression. errno can be checked to distinguish two error
-         * cases (if errno is zero, the zlib error is Z_MEM_ERROR).
-         */
-        void open(const char* name) {
-            if (m_fp) close();
-            m_fp = ::gzopen(name, "rb");
-        }
-
-        void open(FILE* fp) {
-            SET_BINARY_MODE(fp);
-            if (m_fp) close();
-            m_fp = ::gzdopen(fileno(fp), "rb");
-        }
-
-        /* Flushes all pending input if necessary, closes the compressed file
-         * and deallocates all the (de)compression state. The return value is
-         * the zlib error number (see function error() below).
-         */
-        int close() {
-            int r = ::gzclose(m_fp);
-            m_fp = 0; return r;
-        }
-
-        /* Binary read the given number of bytes from the compressed file.
-         */
-        int read(void* buf, size_t len) {
-            return ::gzread(m_fp, buf, len);
-        }
-
-        /* Returns the error message for the last error which occurred on the
-         * given compressed file. errnum is set to zlib error number. If an
-         * error occurred in the file system and not in the compression library,
-         * errnum is set to Z_ERRNO and the application may consult errno
-         * to get the exact error code.
-         */
-        const char* error(int* errnum) {
-            return ::gzerror(m_fp, errnum);
-        }
-
-        gzFile fp() { return m_fp; }
-
-    private:
-        gzFile m_fp;
-};
-
-/*
- * Binary read the given (array of) object(s) from the compressed file.
- * If the input file was not in gzip format, read() copies the objects number
- * of bytes into the buffer.
- * returns the number of uncompressed bytes actually read
- * (0 for end of file, -1 for error).
- */
-template <class T, class Items>
-inline int read(izstream& zs, T* x, Items items) {
-    return ::gzread(zs.fp(), x, items*sizeof(T));
-}
-
-/*
- * Binary input with the '>' operator.
- */
-template <class T>
-inline izstream& operator>(izstream& zs, T& x) {
-    ::gzread(zs.fp(), &x, sizeof(T));
-    return zs;
-}
-
-
-inline zstringlen::zstringlen(izstream& zs) {
-    zs > val.byte;
-    if (val.byte == 255) zs > val.word;
-    else val.word = val.byte;
-}
-
-/*
- * Read length of string + the string with the '>' operator.
- */
-inline izstream& operator>(izstream& zs, char* x) {
-    zstringlen len(zs);
-    ::gzread(zs.fp(), x, len.value());
-    x[len.value()] = '\0';
-    return zs;
-}
-
-inline char* read_string(izstream& zs) {
-    zstringlen len(zs);
-    char* x = new char[len.value()+1];
-    ::gzread(zs.fp(), x, len.value());
-    x[len.value()] = '\0';
-    return x;
-}
-
-// ----------------------------- ozstream -----------------------------
-
-class ozstream
-{
-    public:
-        ozstream() : m_fp(0), m_os(0) {
-        }
-        ozstream(FILE* fp, int level = Z_DEFAULT_COMPRESSION)
-            : m_fp(0), m_os(0) {
-            open(fp, level);
-        }
-        ozstream(const char* name, int level = Z_DEFAULT_COMPRESSION)
-            : m_fp(0), m_os(0) {
-            open(name, level);
-        }
-        ~ozstream() {
-            close();
-        }
-
-        /* Opens a gzip (.gz) file for writing.
-         * The compression level parameter should be in 0..9
-         * errno can be checked to distinguish two error cases
-         * (if errno is zero, the zlib error is Z_MEM_ERROR).
-         */
-        void open(const char* name, int level = Z_DEFAULT_COMPRESSION) {
-            char mode[4] = "wb\0";
-            if (level != Z_DEFAULT_COMPRESSION) mode[2] = '0'+level;
-            if (m_fp) close();
-            m_fp = ::gzopen(name, mode);
-        }
-
-        /* open from a FILE pointer.
-         */
-        void open(FILE* fp, int level = Z_DEFAULT_COMPRESSION) {
-            SET_BINARY_MODE(fp);
-            char mode[4] = "wb\0";
-            if (level != Z_DEFAULT_COMPRESSION) mode[2] = '0'+level;
-            if (m_fp) close();
-            m_fp = ::gzdopen(fileno(fp), mode);
-        }
-
-        /* Flushes all pending output if necessary, closes the compressed file
-         * and deallocates all the (de)compression state. The return value is
-         * the zlib error number (see function error() below).
-         */
-        int close() {
-            if (m_os) {
-                ::gzwrite(m_fp, m_os->str(), m_os->pcount());
-                delete[] m_os->str(); delete m_os; m_os = 0;
-            }
-            int r = ::gzclose(m_fp); m_fp = 0; return r;
-        }
-
-        /* Binary write the given number of bytes into the compressed file.
-         */
-        int write(const void* buf, size_t len) {
-            return ::gzwrite(m_fp, (voidp) buf, len);
-        }
-
-        /* Flushes all pending output into the compressed file. The parameter
-         * _flush is as in the deflate() function. The return value is the zlib
-         * error number (see function gzerror below). flush() returns Z_OK if
-         * the flush_ parameter is Z_FINISH and all output could be flushed.
-         * flush() should be called only when strictly necessary because it can
-         * degrade compression.
-         */
-        int flush(int _flush) {
-            os_flush();
-            return ::gzflush(m_fp, _flush);
-        }
-
-        /* Returns the error message for the last error which occurred on the
-         * given compressed file. errnum is set to zlib error number. If an
-         * error occurred in the file system and not in the compression library,
-         * errnum is set to Z_ERRNO and the application may consult errno
-         * to get the exact error code.
-         */
-        const char* error(int* errnum) {
-            return ::gzerror(m_fp, errnum);
-        }
-
-        gzFile fp() { return m_fp; }
-
-        ostream& os() {
-            if (m_os == 0) m_os = new ostrstream;
-            return *m_os;
-        }
-
-        void os_flush() {
-            if (m_os && m_os->pcount()>0) {
-                ostrstream* oss = new ostrstream;
-                oss->fill(m_os->fill());
-                oss->flags(m_os->flags());
-                oss->precision(m_os->precision());
-                oss->width(m_os->width());
-                ::gzwrite(m_fp, m_os->str(), m_os->pcount());
-                delete[] m_os->str(); delete m_os; m_os = oss;
-            }
-        }
-
-    private:
-        gzFile m_fp;
-        ostrstream* m_os;
-};
-
-/*
- * Binary write the given (array of) object(s) into the compressed file.
- * returns the number of uncompressed bytes actually written
- * (0 in case of error).
- */
-template <class T, class Items>
-inline int write(ozstream& zs, const T* x, Items items) {
-    return ::gzwrite(zs.fp(), (voidp) x, items*sizeof(T));
-}
-
-/*
- * Binary output with the '<' operator.
- */
-template <class T>
-inline ozstream& operator<(ozstream& zs, const T& x) {
-    ::gzwrite(zs.fp(), (voidp) &x, sizeof(T));
-    return zs;
-}
-
-inline zstringlen::zstringlen(ozstream& zs, const char* x) {
-    val.byte = 255;  val.word = ::strlen(x);
-    if (val.word < 255) zs < (val.byte = val.word);
-    else zs < val;
-}
-
-/*
- * Write length of string + the string with the '<' operator.
- */
-inline ozstream& operator<(ozstream& zs, const char* x) {
-    zstringlen len(zs, x);
-    ::gzwrite(zs.fp(), (voidp) x, len.value());
-    return zs;
-}
-
-#ifdef _MSC_VER
-inline ozstream& operator<(ozstream& zs, char* const& x) {
-    return zs < (const char*) x;
-}
-#endif
-
-/*
- * Ascii write with the << operator;
- */
-template <class T>
-inline ostream& operator<<(ozstream& zs, const T& x) {
-    zs.os_flush();
-    return zs.os() << x;
-}
-
-#endif
diff -Nbaur gcc-4.8.1/zlib/contrib/iostream2/zstream_test.cpp gcc-4.8.1-ppc/zlib/contrib/iostream2/zstream_test.cpp
--- gcc-4.8.1/zlib/contrib/iostream2/zstream_test.cpp	2004-10-11 19:45:43.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/iostream2/zstream_test.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-#include "zstream.h"
-#include <math.h>
-#include <stdlib.h>
-#include <iomanip.h>
-
-void main() {
-    char h[256] = "Hello";
-    char* g = "Goodbye";
-    ozstream out("temp.gz");
-    out < "This works well" < h < g;
-    out.close();
-
-    izstream in("temp.gz"); // read it back
-    char *x = read_string(in), *y = new char[256], z[256];
-    in > y > z;
-    in.close();
-    cout << x << endl << y << endl << z << endl;
-
-    out.open("temp.gz"); // try ascii output; zcat temp.gz to see the results
-    out << setw(50) << setfill('#') << setprecision(20) << x << endl << y << endl << z << endl;
-    out << z << endl << y << endl << x << endl;
-    out << 1.1234567890123456789 << endl;
-
-    delete[] x; delete[] y;
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/iostream3/README gcc-4.8.1-ppc/zlib/contrib/iostream3/README
--- gcc-4.8.1/zlib/contrib/iostream3/README	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/iostream3/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,35 +0,0 @@
-These classes provide a C++ stream interface to the zlib library. It allows you
-to do things like:
-
-  gzofstream outf("blah.gz");
-  outf << "These go into the gzip file " << 123 << endl;
-
-It does this by deriving a specialized stream buffer for gzipped files, which is
-the way Stroustrup would have done it. :->
-
-The gzifstream and gzofstream classes were originally written by Kevin Ruland
-and made available in the zlib contrib/iostream directory. The older version still
-compiles under gcc 2.xx, but not under gcc 3.xx, which sparked the development of
-this version.
-
-The new classes are as standard-compliant as possible, closely following the
-approach of the standard library's fstream classes. It compiles under gcc versions
-3.2 and 3.3, but not under gcc 2.xx. This is mainly due to changes in the standard
-library naming scheme. The new version of gzifstream/gzofstream/gzfilebuf differs
-from the previous one in the following respects:
-- added showmanyc
-- added setbuf, with support for unbuffered output via setbuf(0,0)
-- a few bug fixes of stream behavior
-- gzipped output file opened with default compression level instead of maximum level
-- setcompressionlevel()/strategy() members replaced by single setcompression()
-
-The code is provided "as is", with the permission to use, copy, modify, distribute
-and sell it for any purpose without fee.
-
-Ludwig Schwardt
-<schwardt@sun.ac.za>
-
-DSP Lab
-Electrical & Electronic Engineering Department
-University of Stellenbosch
-South Africa
diff -Nbaur gcc-4.8.1/zlib/contrib/iostream3/test.cc gcc-4.8.1-ppc/zlib/contrib/iostream3/test.cc
--- gcc-4.8.1/zlib/contrib/iostream3/test.cc	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/iostream3/test.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,50 +0,0 @@
-/*
- * Test program for gzifstream and gzofstream
- *
- * by Ludwig Schwardt <schwardt@sun.ac.za>
- * original version by Kevin Ruland <kevin@rodin.wustl.edu>
- */
-
-#include "zfstream.h"
-#include <iostream>      // for cout
-
-int main() {
-
-  gzofstream outf;
-  gzifstream inf;
-  char buf[80];
-
-  outf.open("test1.txt.gz");
-  outf << "The quick brown fox sidestepped the lazy canine\n"
-       << 1.3 << "\nPlan " << 9 << std::endl;
-  outf.close();
-  std::cout << "Wrote the following message to 'test1.txt.gz' (check with zcat or zless):\n"
-            << "The quick brown fox sidestepped the lazy canine\n"
-            << 1.3 << "\nPlan " << 9 << std::endl;
-
-  std::cout << "\nReading 'test1.txt.gz' (buffered) produces:\n";
-  inf.open("test1.txt.gz");
-  while (inf.getline(buf,80,'\n')) {
-    std::cout << buf << "\t(" << inf.rdbuf()->in_avail() << " chars left in buffer)\n";
-  }
-  inf.close();
-
-  outf.rdbuf()->pubsetbuf(0,0);
-  outf.open("test2.txt.gz");
-  outf << setcompression(Z_NO_COMPRESSION)
-       << "The quick brown fox sidestepped the lazy canine\n"
-       << 1.3 << "\nPlan " << 9 << std::endl;
-  outf.close();
-  std::cout << "\nWrote the same message to 'test2.txt.gz' in uncompressed form";
-
-  std::cout << "\nReading 'test2.txt.gz' (unbuffered) produces:\n";
-  inf.rdbuf()->pubsetbuf(0,0);
-  inf.open("test2.txt.gz");
-  while (inf.getline(buf,80,'\n')) {
-    std::cout << buf << "\t(" << inf.rdbuf()->in_avail() << " chars left in buffer)\n";
-  }
-  inf.close();
-
-  return 0;
-
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/iostream3/TODO gcc-4.8.1-ppc/zlib/contrib/iostream3/TODO
--- gcc-4.8.1/zlib/contrib/iostream3/TODO	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/iostream3/TODO	1970-01-01 01:00:00.000000000 +0100
@@ -1,17 +0,0 @@
-Possible upgrades to gzfilebuf:
-
-- The ability to do putback (e.g. putbackfail)
-
-- The ability to seek (zlib supports this, but could be slow/tricky)
-
-- Simultaneous read/write access (does it make sense?)
-
-- Support for ios_base::ate open mode
-
-- Locale support?
-
-- Check public interface to see which calls give problems
-  (due to dependence on library internals)
-
-- Override operator<<(ostream&, gzfilebuf*) to allow direct copying
-  of stream buffer to stream ( i.e. os << is.rdbuf(); )
diff -Nbaur gcc-4.8.1/zlib/contrib/iostream3/zfstream.cc gcc-4.8.1-ppc/zlib/contrib/iostream3/zfstream.cc
--- gcc-4.8.1/zlib/contrib/iostream3/zfstream.cc	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/iostream3/zfstream.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,479 +0,0 @@
-/*
- * A C++ I/O streams interface to the zlib gz* functions
- *
- * by Ludwig Schwardt <schwardt@sun.ac.za>
- * original version by Kevin Ruland <kevin@rodin.wustl.edu>
- *
- * This version is standard-compliant and compatible with gcc 3.x.
- */
-
-#include "zfstream.h"
-#include <cstring>          // for strcpy, strcat, strlen (mode strings)
-#include <cstdio>           // for BUFSIZ
-
-// Internal buffer sizes (default and "unbuffered" versions)
-#define BIGBUFSIZE BUFSIZ
-#define SMALLBUFSIZE 1
-
-/*****************************************************************************/
-
-// Default constructor
-gzfilebuf::gzfilebuf()
-: file(NULL), io_mode(std::ios_base::openmode(0)), own_fd(false),
-  buffer(NULL), buffer_size(BIGBUFSIZE), own_buffer(true)
-{
-  // No buffers to start with
-  this->disable_buffer();
-}
-
-// Destructor
-gzfilebuf::~gzfilebuf()
-{
-  // Sync output buffer and close only if responsible for file
-  // (i.e. attached streams should be left open at this stage)
-  this->sync();
-  if (own_fd)
-    this->close();
-  // Make sure internal buffer is deallocated
-  this->disable_buffer();
-}
-
-// Set compression level and strategy
-int
-gzfilebuf::setcompression(int comp_level,
-                          int comp_strategy)
-{
-  return gzsetparams(file, comp_level, comp_strategy);
-}
-
-// Open gzipped file
-gzfilebuf*
-gzfilebuf::open(const char *name,
-                std::ios_base::openmode mode)
-{
-  // Fail if file already open
-  if (this->is_open())
-    return NULL;
-  // Don't support simultaneous read/write access (yet)
-  if ((mode & std::ios_base::in) && (mode & std::ios_base::out))
-    return NULL;
-
-  // Build mode string for gzopen and check it [27.8.1.3.2]
-  char char_mode[6] = "\0\0\0\0\0";
-  if (!this->open_mode(mode, char_mode))
-    return NULL;
-
-  // Attempt to open file
-  if ((file = gzopen(name, char_mode)) == NULL)
-    return NULL;
-
-  // On success, allocate internal buffer and set flags
-  this->enable_buffer();
-  io_mode = mode;
-  own_fd = true;
-  return this;
-}
-
-// Attach to gzipped file
-gzfilebuf*
-gzfilebuf::attach(int fd,
-                  std::ios_base::openmode mode)
-{
-  // Fail if file already open
-  if (this->is_open())
-    return NULL;
-  // Don't support simultaneous read/write access (yet)
-  if ((mode & std::ios_base::in) && (mode & std::ios_base::out))
-    return NULL;
-
-  // Build mode string for gzdopen and check it [27.8.1.3.2]
-  char char_mode[6] = "\0\0\0\0\0";
-  if (!this->open_mode(mode, char_mode))
-    return NULL;
-
-  // Attempt to attach to file
-  if ((file = gzdopen(fd, char_mode)) == NULL)
-    return NULL;
-
-  // On success, allocate internal buffer and set flags
-  this->enable_buffer();
-  io_mode = mode;
-  own_fd = false;
-  return this;
-}
-
-// Close gzipped file
-gzfilebuf*
-gzfilebuf::close()
-{
-  // Fail immediately if no file is open
-  if (!this->is_open())
-    return NULL;
-  // Assume success
-  gzfilebuf* retval = this;
-  // Attempt to sync and close gzipped file
-  if (this->sync() == -1)
-    retval = NULL;
-  if (gzclose(file) < 0)
-    retval = NULL;
-  // File is now gone anyway (postcondition [27.8.1.3.8])
-  file = NULL;
-  own_fd = false;
-  // Destroy internal buffer if it exists
-  this->disable_buffer();
-  return retval;
-}
-
-/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
-
-// Convert int open mode to mode string
-bool
-gzfilebuf::open_mode(std::ios_base::openmode mode,
-                     char* c_mode) const
-{
-  bool testb = mode & std::ios_base::binary;
-  bool testi = mode & std::ios_base::in;
-  bool testo = mode & std::ios_base::out;
-  bool testt = mode & std::ios_base::trunc;
-  bool testa = mode & std::ios_base::app;
-
-  // Check for valid flag combinations - see [27.8.1.3.2] (Table 92)
-  // Original zfstream hardcoded the compression level to maximum here...
-  // Double the time for less than 1% size improvement seems
-  // excessive though - keeping it at the default level
-  // To change back, just append "9" to the next three mode strings
-  if (!testi && testo && !testt && !testa)
-    strcpy(c_mode, "w");
-  if (!testi && testo && !testt && testa)
-    strcpy(c_mode, "a");
-  if (!testi && testo && testt && !testa)
-    strcpy(c_mode, "w");
-  if (testi && !testo && !testt && !testa)
-    strcpy(c_mode, "r");
-  // No read/write mode yet
-//  if (testi && testo && !testt && !testa)
-//    strcpy(c_mode, "r+");
-//  if (testi && testo && testt && !testa)
-//    strcpy(c_mode, "w+");
-
-  // Mode string should be empty for invalid combination of flags
-  if (strlen(c_mode) == 0)
-    return false;
-  if (testb)
-    strcat(c_mode, "b");
-  return true;
-}
-
-// Determine number of characters in internal get buffer
-std::streamsize
-gzfilebuf::showmanyc()
-{
-  // Calls to underflow will fail if file not opened for reading
-  if (!this->is_open() || !(io_mode & std::ios_base::in))
-    return -1;
-  // Make sure get area is in use
-  if (this->gptr() && (this->gptr() < this->egptr()))
-    return std::streamsize(this->egptr() - this->gptr());
-  else
-    return 0;
-}
-
-// Fill get area from gzipped file
-gzfilebuf::int_type
-gzfilebuf::underflow()
-{
-  // If something is left in the get area by chance, return it
-  // (this shouldn't normally happen, as underflow is only supposed
-  // to be called when gptr >= egptr, but it serves as error check)
-  if (this->gptr() && (this->gptr() < this->egptr()))
-    return traits_type::to_int_type(*(this->gptr()));
-
-  // If the file hasn't been opened for reading, produce error
-  if (!this->is_open() || !(io_mode & std::ios_base::in))
-    return traits_type::eof();
-
-  // Attempt to fill internal buffer from gzipped file
-  // (buffer must be guaranteed to exist...)
-  int bytes_read = gzread(file, buffer, buffer_size);
-  // Indicates error or EOF
-  if (bytes_read <= 0)
-  {
-    // Reset get area
-    this->setg(buffer, buffer, buffer);
-    return traits_type::eof();
-  }
-  // Make all bytes read from file available as get area
-  this->setg(buffer, buffer, buffer + bytes_read);
-
-  // Return next character in get area
-  return traits_type::to_int_type(*(this->gptr()));
-}
-
-// Write put area to gzipped file
-gzfilebuf::int_type
-gzfilebuf::overflow(int_type c)
-{
-  // Determine whether put area is in use
-  if (this->pbase())
-  {
-    // Double-check pointer range
-    if (this->pptr() > this->epptr() || this->pptr() < this->pbase())
-      return traits_type::eof();
-    // Add extra character to buffer if not EOF
-    if (!traits_type::eq_int_type(c, traits_type::eof()))
-    {
-      *(this->pptr()) = traits_type::to_char_type(c);
-      this->pbump(1);
-    }
-    // Number of characters to write to file
-    int bytes_to_write = this->pptr() - this->pbase();
-    // Overflow doesn't fail if nothing is to be written
-    if (bytes_to_write > 0)
-    {
-      // If the file hasn't been opened for writing, produce error
-      if (!this->is_open() || !(io_mode & std::ios_base::out))
-        return traits_type::eof();
-      // If gzipped file won't accept all bytes written to it, fail
-      if (gzwrite(file, this->pbase(), bytes_to_write) != bytes_to_write)
-        return traits_type::eof();
-      // Reset next pointer to point to pbase on success
-      this->pbump(-bytes_to_write);
-    }
-  }
-  // Write extra character to file if not EOF
-  else if (!traits_type::eq_int_type(c, traits_type::eof()))
-  {
-    // If the file hasn't been opened for writing, produce error
-    if (!this->is_open() || !(io_mode & std::ios_base::out))
-      return traits_type::eof();
-    // Impromptu char buffer (allows "unbuffered" output)
-    char_type last_char = traits_type::to_char_type(c);
-    // If gzipped file won't accept this character, fail
-    if (gzwrite(file, &last_char, 1) != 1)
-      return traits_type::eof();
-  }
-
-  // If you got here, you have succeeded (even if c was EOF)
-  // The return value should therefore be non-EOF
-  if (traits_type::eq_int_type(c, traits_type::eof()))
-    return traits_type::not_eof(c);
-  else
-    return c;
-}
-
-// Assign new buffer
-std::streambuf*
-gzfilebuf::setbuf(char_type* p,
-                  std::streamsize n)
-{
-  // First make sure stuff is sync'ed, for safety
-  if (this->sync() == -1)
-    return NULL;
-  // If buffering is turned off on purpose via setbuf(0,0), still allocate one...
-  // "Unbuffered" only really refers to put [27.8.1.4.10], while get needs at
-  // least a buffer of size 1 (very inefficient though, therefore make it bigger?)
-  // This follows from [27.5.2.4.3]/12 (gptr needs to point at something, it seems)
-  if (!p || !n)
-  {
-    // Replace existing buffer (if any) with small internal buffer
-    this->disable_buffer();
-    buffer = NULL;
-    buffer_size = 0;
-    own_buffer = true;
-    this->enable_buffer();
-  }
-  else
-  {
-    // Replace existing buffer (if any) with external buffer
-    this->disable_buffer();
-    buffer = p;
-    buffer_size = n;
-    own_buffer = false;
-    this->enable_buffer();
-  }
-  return this;
-}
-
-// Write put area to gzipped file (i.e. ensures that put area is empty)
-int
-gzfilebuf::sync()
-{
-  return traits_type::eq_int_type(this->overflow(), traits_type::eof()) ? -1 : 0;
-}
-
-/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
-
-// Allocate internal buffer
-void
-gzfilebuf::enable_buffer()
-{
-  // If internal buffer required, allocate one
-  if (own_buffer && !buffer)
-  {
-    // Check for buffered vs. "unbuffered"
-    if (buffer_size > 0)
-    {
-      // Allocate internal buffer
-      buffer = new char_type[buffer_size];
-      // Get area starts empty and will be expanded by underflow as need arises
-      this->setg(buffer, buffer, buffer);
-      // Setup entire internal buffer as put area.
-      // The one-past-end pointer actually points to the last element of the buffer,
-      // so that overflow(c) can safely add the extra character c to the sequence.
-      // These pointers remain in place for the duration of the buffer
-      this->setp(buffer, buffer + buffer_size - 1);
-    }
-    else
-    {
-      // Even in "unbuffered" case, (small?) get buffer is still required
-      buffer_size = SMALLBUFSIZE;
-      buffer = new char_type[buffer_size];
-      this->setg(buffer, buffer, buffer);
-      // "Unbuffered" means no put buffer
-      this->setp(0, 0);
-    }
-  }
-  else
-  {
-    // If buffer already allocated, reset buffer pointers just to make sure no
-    // stale chars are lying around
-    this->setg(buffer, buffer, buffer);
-    this->setp(buffer, buffer + buffer_size - 1);
-  }
-}
-
-// Destroy internal buffer
-void
-gzfilebuf::disable_buffer()
-{
-  // If internal buffer exists, deallocate it
-  if (own_buffer && buffer)
-  {
-    // Preserve unbuffered status by zeroing size
-    if (!this->pbase())
-      buffer_size = 0;
-    delete[] buffer;
-    buffer = NULL;
-    this->setg(0, 0, 0);
-    this->setp(0, 0);
-  }
-  else
-  {
-    // Reset buffer pointers to initial state if external buffer exists
-    this->setg(buffer, buffer, buffer);
-    if (buffer)
-      this->setp(buffer, buffer + buffer_size - 1);
-    else
-      this->setp(0, 0);
-  }
-}
-
-/*****************************************************************************/
-
-// Default constructor initializes stream buffer
-gzifstream::gzifstream()
-: std::istream(NULL), sb()
-{ this->init(&sb); }
-
-// Initialize stream buffer and open file
-gzifstream::gzifstream(const char* name,
-                       std::ios_base::openmode mode)
-: std::istream(NULL), sb()
-{
-  this->init(&sb);
-  this->open(name, mode);
-}
-
-// Initialize stream buffer and attach to file
-gzifstream::gzifstream(int fd,
-                       std::ios_base::openmode mode)
-: std::istream(NULL), sb()
-{
-  this->init(&sb);
-  this->attach(fd, mode);
-}
-
-// Open file and go into fail() state if unsuccessful
-void
-gzifstream::open(const char* name,
-                 std::ios_base::openmode mode)
-{
-  if (!sb.open(name, mode | std::ios_base::in))
-    this->setstate(std::ios_base::failbit);
-  else
-    this->clear();
-}
-
-// Attach to file and go into fail() state if unsuccessful
-void
-gzifstream::attach(int fd,
-                   std::ios_base::openmode mode)
-{
-  if (!sb.attach(fd, mode | std::ios_base::in))
-    this->setstate(std::ios_base::failbit);
-  else
-    this->clear();
-}
-
-// Close file
-void
-gzifstream::close()
-{
-  if (!sb.close())
-    this->setstate(std::ios_base::failbit);
-}
-
-/*****************************************************************************/
-
-// Default constructor initializes stream buffer
-gzofstream::gzofstream()
-: std::ostream(NULL), sb()
-{ this->init(&sb); }
-
-// Initialize stream buffer and open file
-gzofstream::gzofstream(const char* name,
-                       std::ios_base::openmode mode)
-: std::ostream(NULL), sb()
-{
-  this->init(&sb);
-  this->open(name, mode);
-}
-
-// Initialize stream buffer and attach to file
-gzofstream::gzofstream(int fd,
-                       std::ios_base::openmode mode)
-: std::ostream(NULL), sb()
-{
-  this->init(&sb);
-  this->attach(fd, mode);
-}
-
-// Open file and go into fail() state if unsuccessful
-void
-gzofstream::open(const char* name,
-                 std::ios_base::openmode mode)
-{
-  if (!sb.open(name, mode | std::ios_base::out))
-    this->setstate(std::ios_base::failbit);
-  else
-    this->clear();
-}
-
-// Attach to file and go into fail() state if unsuccessful
-void
-gzofstream::attach(int fd,
-                   std::ios_base::openmode mode)
-{
-  if (!sb.attach(fd, mode | std::ios_base::out))
-    this->setstate(std::ios_base::failbit);
-  else
-    this->clear();
-}
-
-// Close file
-void
-gzofstream::close()
-{
-  if (!sb.close())
-    this->setstate(std::ios_base::failbit);
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/iostream3/zfstream.h gcc-4.8.1-ppc/zlib/contrib/iostream3/zfstream.h
--- gcc-4.8.1/zlib/contrib/iostream3/zfstream.h	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/iostream3/zfstream.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,466 +0,0 @@
-/*
- * A C++ I/O streams interface to the zlib gz* functions
- *
- * by Ludwig Schwardt <schwardt@sun.ac.za>
- * original version by Kevin Ruland <kevin@rodin.wustl.edu>
- *
- * This version is standard-compliant and compatible with gcc 3.x.
- */
-
-#ifndef ZFSTREAM_H
-#define ZFSTREAM_H
-
-#include <istream>  // not iostream, since we don't need cin/cout
-#include <ostream>
-#include "zlib.h"
-
-/*****************************************************************************/
-
-/**
- *  @brief  Gzipped file stream buffer class.
- *
- *  This class implements basic_filebuf for gzipped files. It doesn't yet support
- *  seeking (allowed by zlib but slow/limited), putback and read/write access
- *  (tricky). Otherwise, it attempts to be a drop-in replacement for the standard
- *  file streambuf.
-*/
-class gzfilebuf : public std::streambuf
-{
-public:
-  //  Default constructor.
-  gzfilebuf();
-
-  //  Destructor.
-  virtual
-  ~gzfilebuf();
-
-  /**
-   *  @brief  Set compression level and strategy on the fly.
-   *  @param  comp_level  Compression level (see zlib.h for allowed values)
-   *  @param  comp_strategy  Compression strategy (see zlib.h for allowed values)
-   *  @return  Z_OK on success, Z_STREAM_ERROR otherwise.
-   *
-   *  Unfortunately, these parameters cannot be modified separately, as the
-   *  previous zfstream version assumed. Since the strategy is seldom changed,
-   *  it can default and setcompression(level) then becomes like the old
-   *  setcompressionlevel(level).
-  */
-  int
-  setcompression(int comp_level,
-                 int comp_strategy = Z_DEFAULT_STRATEGY);
-
-  /**
-   *  @brief  Check if file is open.
-   *  @return  True if file is open.
-  */
-  bool
-  is_open() const { return (file != NULL); }
-
-  /**
-   *  @brief  Open gzipped file.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags.
-   *  @return  @c this on success, NULL on failure.
-  */
-  gzfilebuf*
-  open(const char* name,
-       std::ios_base::openmode mode);
-
-  /**
-   *  @brief  Attach to already open gzipped file.
-   *  @param  fd  File descriptor.
-   *  @param  mode  Open mode flags.
-   *  @return  @c this on success, NULL on failure.
-  */
-  gzfilebuf*
-  attach(int fd,
-         std::ios_base::openmode mode);
-
-  /**
-   *  @brief  Close gzipped file.
-   *  @return  @c this on success, NULL on failure.
-  */
-  gzfilebuf*
-  close();
-
-protected:
-  /**
-   *  @brief  Convert ios open mode int to mode string used by zlib.
-   *  @return  True if valid mode flag combination.
-  */
-  bool
-  open_mode(std::ios_base::openmode mode,
-            char* c_mode) const;
-
-  /**
-   *  @brief  Number of characters available in stream buffer.
-   *  @return  Number of characters.
-   *
-   *  This indicates number of characters in get area of stream buffer.
-   *  These characters can be read without accessing the gzipped file.
-  */
-  virtual std::streamsize
-  showmanyc();
-
-  /**
-   *  @brief  Fill get area from gzipped file.
-   *  @return  First character in get area on success, EOF on error.
-   *
-   *  This actually reads characters from gzipped file to stream
-   *  buffer. Always buffered.
-  */
-  virtual int_type
-  underflow();
-
-  /**
-   *  @brief  Write put area to gzipped file.
-   *  @param  c  Extra character to add to buffer contents.
-   *  @return  Non-EOF on success, EOF on error.
-   *
-   *  This actually writes characters in stream buffer to
-   *  gzipped file. With unbuffered output this is done one
-   *  character at a time.
-  */
-  virtual int_type
-  overflow(int_type c = traits_type::eof());
-
-  /**
-   *  @brief  Installs external stream buffer.
-   *  @param  p  Pointer to char buffer.
-   *  @param  n  Size of external buffer.
-   *  @return  @c this on success, NULL on failure.
-   *
-   *  Call setbuf(0,0) to enable unbuffered output.
-  */
-  virtual std::streambuf*
-  setbuf(char_type* p,
-         std::streamsize n);
-
-  /**
-   *  @brief  Flush stream buffer to file.
-   *  @return  0 on success, -1 on error.
-   *
-   *  This calls underflow(EOF) to do the job.
-  */
-  virtual int
-  sync();
-
-//
-// Some future enhancements
-//
-//  virtual int_type uflow();
-//  virtual int_type pbackfail(int_type c = traits_type::eof());
-//  virtual pos_type
-//  seekoff(off_type off,
-//          std::ios_base::seekdir way,
-//          std::ios_base::openmode mode = std::ios_base::in|std::ios_base::out);
-//  virtual pos_type
-//  seekpos(pos_type sp,
-//          std::ios_base::openmode mode = std::ios_base::in|std::ios_base::out);
-
-private:
-  /**
-   *  @brief  Allocate internal buffer.
-   *
-   *  This function is safe to call multiple times. It will ensure
-   *  that a proper internal buffer exists if it is required. If the
-   *  buffer already exists or is external, the buffer pointers will be
-   *  reset to their original state.
-  */
-  void
-  enable_buffer();
-
-  /**
-   *  @brief  Destroy internal buffer.
-   *
-   *  This function is safe to call multiple times. It will ensure
-   *  that the internal buffer is deallocated if it exists. In any
-   *  case, it will also reset the buffer pointers.
-  */
-  void
-  disable_buffer();
-
-  /**
-   *  Underlying file pointer.
-  */
-  gzFile file;
-
-  /**
-   *  Mode in which file was opened.
-  */
-  std::ios_base::openmode io_mode;
-
-  /**
-   *  @brief  True if this object owns file descriptor.
-   *
-   *  This makes the class responsible for closing the file
-   *  upon destruction.
-  */
-  bool own_fd;
-
-  /**
-   *  @brief  Stream buffer.
-   *
-   *  For simplicity this remains allocated on the free store for the
-   *  entire life span of the gzfilebuf object, unless replaced by setbuf.
-  */
-  char_type* buffer;
-
-  /**
-   *  @brief  Stream buffer size.
-   *
-   *  Defaults to system default buffer size (typically 8192 bytes).
-   *  Modified by setbuf.
-  */
-  std::streamsize buffer_size;
-
-  /**
-   *  @brief  True if this object owns stream buffer.
-   *
-   *  This makes the class responsible for deleting the buffer
-   *  upon destruction.
-  */
-  bool own_buffer;
-};
-
-/*****************************************************************************/
-
-/**
- *  @brief  Gzipped file input stream class.
- *
- *  This class implements ifstream for gzipped files. Seeking and putback
- *  is not supported yet.
-*/
-class gzifstream : public std::istream
-{
-public:
-  //  Default constructor
-  gzifstream();
-
-  /**
-   *  @brief  Construct stream on gzipped file to be opened.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags (forced to contain ios::in).
-  */
-  explicit
-  gzifstream(const char* name,
-             std::ios_base::openmode mode = std::ios_base::in);
-
-  /**
-   *  @brief  Construct stream on already open gzipped file.
-   *  @param  fd    File descriptor.
-   *  @param  mode  Open mode flags (forced to contain ios::in).
-  */
-  explicit
-  gzifstream(int fd,
-             std::ios_base::openmode mode = std::ios_base::in);
-
-  /**
-   *  Obtain underlying stream buffer.
-  */
-  gzfilebuf*
-  rdbuf() const
-  { return const_cast<gzfilebuf*>(&sb); }
-
-  /**
-   *  @brief  Check if file is open.
-   *  @return  True if file is open.
-  */
-  bool
-  is_open() { return sb.is_open(); }
-
-  /**
-   *  @brief  Open gzipped file.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags (forced to contain ios::in).
-   *
-   *  Stream will be in state good() if file opens successfully;
-   *  otherwise in state fail(). This differs from the behavior of
-   *  ifstream, which never sets the state to good() and therefore
-   *  won't allow you to reuse the stream for a second file unless
-   *  you manually clear() the state. The choice is a matter of
-   *  convenience.
-  */
-  void
-  open(const char* name,
-       std::ios_base::openmode mode = std::ios_base::in);
-
-  /**
-   *  @brief  Attach to already open gzipped file.
-   *  @param  fd  File descriptor.
-   *  @param  mode  Open mode flags (forced to contain ios::in).
-   *
-   *  Stream will be in state good() if attach succeeded; otherwise
-   *  in state fail().
-  */
-  void
-  attach(int fd,
-         std::ios_base::openmode mode = std::ios_base::in);
-
-  /**
-   *  @brief  Close gzipped file.
-   *
-   *  Stream will be in state fail() if close failed.
-  */
-  void
-  close();
-
-private:
-  /**
-   *  Underlying stream buffer.
-  */
-  gzfilebuf sb;
-};
-
-/*****************************************************************************/
-
-/**
- *  @brief  Gzipped file output stream class.
- *
- *  This class implements ofstream for gzipped files. Seeking and putback
- *  is not supported yet.
-*/
-class gzofstream : public std::ostream
-{
-public:
-  //  Default constructor
-  gzofstream();
-
-  /**
-   *  @brief  Construct stream on gzipped file to be opened.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags (forced to contain ios::out).
-  */
-  explicit
-  gzofstream(const char* name,
-             std::ios_base::openmode mode = std::ios_base::out);
-
-  /**
-   *  @brief  Construct stream on already open gzipped file.
-   *  @param  fd    File descriptor.
-   *  @param  mode  Open mode flags (forced to contain ios::out).
-  */
-  explicit
-  gzofstream(int fd,
-             std::ios_base::openmode mode = std::ios_base::out);
-
-  /**
-   *  Obtain underlying stream buffer.
-  */
-  gzfilebuf*
-  rdbuf() const
-  { return const_cast<gzfilebuf*>(&sb); }
-
-  /**
-   *  @brief  Check if file is open.
-   *  @return  True if file is open.
-  */
-  bool
-  is_open() { return sb.is_open(); }
-
-  /**
-   *  @brief  Open gzipped file.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags (forced to contain ios::out).
-   *
-   *  Stream will be in state good() if file opens successfully;
-   *  otherwise in state fail(). This differs from the behavior of
-   *  ofstream, which never sets the state to good() and therefore
-   *  won't allow you to reuse the stream for a second file unless
-   *  you manually clear() the state. The choice is a matter of
-   *  convenience.
-  */
-  void
-  open(const char* name,
-       std::ios_base::openmode mode = std::ios_base::out);
-
-  /**
-   *  @brief  Attach to already open gzipped file.
-   *  @param  fd  File descriptor.
-   *  @param  mode  Open mode flags (forced to contain ios::out).
-   *
-   *  Stream will be in state good() if attach succeeded; otherwise
-   *  in state fail().
-  */
-  void
-  attach(int fd,
-         std::ios_base::openmode mode = std::ios_base::out);
-
-  /**
-   *  @brief  Close gzipped file.
-   *
-   *  Stream will be in state fail() if close failed.
-  */
-  void
-  close();
-
-private:
-  /**
-   *  Underlying stream buffer.
-  */
-  gzfilebuf sb;
-};
-
-/*****************************************************************************/
-
-/**
- *  @brief  Gzipped file output stream manipulator class.
- *
- *  This class defines a two-argument manipulator for gzofstream. It is used
- *  as base for the setcompression(int,int) manipulator.
-*/
-template<typename T1, typename T2>
-  class gzomanip2
-  {
-  public:
-    // Allows insertor to peek at internals
-    template <typename Ta, typename Tb>
-      friend gzofstream&
-      operator<<(gzofstream&,
-                 const gzomanip2<Ta,Tb>&);
-
-    // Constructor
-    gzomanip2(gzofstream& (*f)(gzofstream&, T1, T2),
-              T1 v1,
-              T2 v2);
-  private:
-    // Underlying manipulator function
-    gzofstream&
-    (*func)(gzofstream&, T1, T2);
-
-    // Arguments for manipulator function
-    T1 val1;
-    T2 val2;
-  };
-
-/*****************************************************************************/
-
-// Manipulator function thunks through to stream buffer
-inline gzofstream&
-setcompression(gzofstream &gzs, int l, int s = Z_DEFAULT_STRATEGY)
-{
-  (gzs.rdbuf())->setcompression(l, s);
-  return gzs;
-}
-
-// Manipulator constructor stores arguments
-template<typename T1, typename T2>
-  inline
-  gzomanip2<T1,T2>::gzomanip2(gzofstream &(*f)(gzofstream &, T1, T2),
-                              T1 v1,
-                              T2 v2)
-  : func(f), val1(v1), val2(v2)
-  { }
-
-// Insertor applies underlying manipulator function to stream
-template<typename T1, typename T2>
-  inline gzofstream&
-  operator<<(gzofstream& s, const gzomanip2<T1,T2>& m)
-  { return (*m.func)(s, m.val1, m.val2); }
-
-// Insert this onto stream to simplify setting of compression level
-inline gzomanip2<int,int>
-setcompression(int l, int s = Z_DEFAULT_STRATEGY)
-{ return gzomanip2<int,int>(&setcompression, l, s); }
-
-#endif // ZFSTREAM_H
diff -Nbaur gcc-4.8.1/zlib/contrib/masmx64/bld_ml64.bat gcc-4.8.1-ppc/zlib/contrib/masmx64/bld_ml64.bat
--- gcc-4.8.1/zlib/contrib/masmx64/bld_ml64.bat	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/masmx64/bld_ml64.bat	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-ml64.exe /Flinffasx64 /c /Zi inffasx64.asm
-ml64.exe /Flgvmat64   /c /Zi gvmat64.asm
diff -Nbaur gcc-4.8.1/zlib/contrib/masmx64/gvmat64.asm gcc-4.8.1-ppc/zlib/contrib/masmx64/gvmat64.asm
--- gcc-4.8.1/zlib/contrib/masmx64/gvmat64.asm	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/masmx64/gvmat64.asm	1970-01-01 01:00:00.000000000 +0100
@@ -1,553 +0,0 @@
-;uInt longest_match_x64(
-;    deflate_state *s,
-;    IPos cur_match);                             /* current match */
-
-; gvmat64.asm -- Asm portion of the optimized longest_match for 32 bits x86_64
-;  (AMD64 on Athlon 64, Opteron, Phenom
-;     and Intel EM64T on Pentium 4 with EM64T, Pentium D, Core 2 Duo, Core I5/I7)
-; Copyright (C) 1995-2010 Jean-loup Gailly, Brian Raiter and Gilles Vollant.
-;
-; File written by Gilles Vollant, by converting to assembly the longest_match
-;  from Jean-loup Gailly in deflate.c of zLib and infoZip zip.
-;
-;  and by taking inspiration on asm686 with masm, optimised assembly code
-;        from Brian Raiter, written 1998
-;
-;  This software is provided 'as-is', without any express or implied
-;  warranty.  In no event will the authors be held liable for any damages
-;  arising from the use of this software.
-;
-;  Permission is granted to anyone to use this software for any purpose,
-;  including commercial applications, and to alter it and redistribute it
-;  freely, subject to the following restrictions:
-;
-;  1. The origin of this software must not be misrepresented; you must not
-;     claim that you wrote the original software. If you use this software
-;     in a product, an acknowledgment in the product documentation would be
-;     appreciated but is not required.
-;  2. Altered source versions must be plainly marked as such, and must not be
-;     misrepresented as being the original software
-;  3. This notice may not be removed or altered from any source distribution.
-;
-;
-;
-;         http://www.zlib.net
-;         http://www.winimage.com/zLibDll
-;         http://www.muppetlabs.com/~breadbox/software/assembly.html
-;
-; to compile this file for infozip Zip, I use option:
-;   ml64.exe /Flgvmat64 /c /Zi /DINFOZIP gvmat64.asm
-;
-; to compile this file for zLib, I use option:
-;   ml64.exe /Flgvmat64 /c /Zi gvmat64.asm
-; Be carrefull to adapt zlib1222add below to your version of zLib
-;   (if you use a version of zLib before 1.0.4 or after 1.2.2.2, change
-;    value of zlib1222add later)
-;
-; This file compile with Microsoft Macro Assembler (x64) for AMD64
-;
-;   ml64.exe is given with Visual Studio 2005/2008/2010 and Windows WDK
-;
-;   (you can get Windows WDK with ml64 for AMD64 from
-;      http://www.microsoft.com/whdc/Devtools/wdk/default.mspx for low price)
-;
-
-
-;uInt longest_match(s, cur_match)
-;    deflate_state *s;
-;    IPos cur_match;                             /* current match */
-.code
-longest_match PROC
-
-
-;LocalVarsSize   equ 88
- LocalVarsSize   equ 72
-
-; register used : rax,rbx,rcx,rdx,rsi,rdi,r8,r9,r10,r11,r12
-; free register :  r14,r15
-; register can be saved : rsp
-
- chainlenwmask   equ  rsp + 8 - LocalVarsSize    ; high word: current chain len
-                                                 ; low word: s->wmask
-;window          equ  rsp + xx - LocalVarsSize   ; local copy of s->window ; stored in r10
-;windowbestlen   equ  rsp + xx - LocalVarsSize   ; s->window + bestlen , use r10+r11
-;scanstart       equ  rsp + xx - LocalVarsSize   ; first two bytes of string ; stored in r12w
-;scanend         equ  rsp + xx - LocalVarsSize   ; last two bytes of string use ebx
-;scanalign       equ  rsp + xx - LocalVarsSize   ; dword-misalignment of string r13
-;bestlen         equ  rsp + xx - LocalVarsSize   ; size of best match so far -> r11d
-;scan            equ  rsp + xx - LocalVarsSize   ; ptr to string wanting match -> r9
-IFDEF INFOZIP
-ELSE
- nicematch       equ  (rsp + 16 - LocalVarsSize) ; a good enough match size
-ENDIF
-
-save_rdi        equ  rsp + 24 - LocalVarsSize
-save_rsi        equ  rsp + 32 - LocalVarsSize
-save_rbx        equ  rsp + 40 - LocalVarsSize
-save_rbp        equ  rsp + 48 - LocalVarsSize
-save_r12        equ  rsp + 56 - LocalVarsSize
-save_r13        equ  rsp + 64 - LocalVarsSize
-;save_r14        equ  rsp + 72 - LocalVarsSize
-;save_r15        equ  rsp + 80 - LocalVarsSize
-
-
-; summary of register usage
-; scanend     ebx
-; scanendw    bx
-; chainlenwmask   edx
-; curmatch    rsi
-; curmatchd   esi
-; windowbestlen   r8
-; scanalign   r9
-; scanalignd  r9d
-; window      r10
-; bestlen     r11
-; bestlend    r11d
-; scanstart   r12d
-; scanstartw  r12w
-; scan        r13
-; nicematch   r14d
-; limit       r15
-; limitd      r15d
-; prev        rcx
-
-;  all the +4 offsets are due to the addition of pending_buf_size (in zlib
-;  in the deflate_state structure since the asm code was first written
-;  (if you compile with zlib 1.0.4 or older, remove the +4).
-;  Note : these value are good with a 8 bytes boundary pack structure
-
-
-    MAX_MATCH           equ     258
-    MIN_MATCH           equ     3
-    MIN_LOOKAHEAD       equ     (MAX_MATCH+MIN_MATCH+1)
-
-
-;;; Offsets for fields in the deflate_state structure. These numbers
-;;; are calculated from the definition of deflate_state, with the
-;;; assumption that the compiler will dword-align the fields. (Thus,
-;;; changing the definition of deflate_state could easily cause this
-;;; program to crash horribly, without so much as a warning at
-;;; compile time. Sigh.)
-
-;  all the +zlib1222add offsets are due to the addition of fields
-;  in zlib in the deflate_state structure since the asm code was first written
-;  (if you compile with zlib 1.0.4 or older, use "zlib1222add equ (-4)").
-;  (if you compile with zlib between 1.0.5 and 1.2.2.1, use "zlib1222add equ 0").
-;  if you compile with zlib 1.2.2.2 or later , use "zlib1222add equ 8").
-
-
-IFDEF INFOZIP
-
-_DATA   SEGMENT
-COMM    window_size:DWORD
-; WMask ; 7fff
-COMM    window:BYTE:010040H
-COMM    prev:WORD:08000H
-; MatchLen : unused
-; PrevMatch : unused
-COMM    strstart:DWORD
-COMM    match_start:DWORD
-; Lookahead : ignore
-COMM    prev_length:DWORD ; PrevLen
-COMM    max_chain_length:DWORD
-COMM    good_match:DWORD
-COMM    nice_match:DWORD
-prev_ad equ OFFSET prev
-window_ad equ OFFSET window
-nicematch equ nice_match
-_DATA ENDS
-WMask equ 07fffh
-
-ELSE
-
-  IFNDEF zlib1222add
-    zlib1222add equ 8
-  ENDIF
-dsWSize         equ 56+zlib1222add+(zlib1222add/2)
-dsWMask         equ 64+zlib1222add+(zlib1222add/2)
-dsWindow        equ 72+zlib1222add
-dsPrev          equ 88+zlib1222add
-dsMatchLen      equ 128+zlib1222add
-dsPrevMatch     equ 132+zlib1222add
-dsStrStart      equ 140+zlib1222add
-dsMatchStart    equ 144+zlib1222add
-dsLookahead     equ 148+zlib1222add
-dsPrevLen       equ 152+zlib1222add
-dsMaxChainLen   equ 156+zlib1222add
-dsGoodMatch     equ 172+zlib1222add
-dsNiceMatch     equ 176+zlib1222add
-
-window_size     equ [ rcx + dsWSize]
-WMask           equ [ rcx + dsWMask]
-window_ad       equ [ rcx + dsWindow]
-prev_ad         equ [ rcx + dsPrev]
-strstart        equ [ rcx + dsStrStart]
-match_start     equ [ rcx + dsMatchStart]
-Lookahead       equ [ rcx + dsLookahead] ; 0ffffffffh on infozip
-prev_length     equ [ rcx + dsPrevLen]
-max_chain_length equ [ rcx + dsMaxChainLen]
-good_match      equ [ rcx + dsGoodMatch]
-nice_match      equ [ rcx + dsNiceMatch]
-ENDIF
-
-; parameter 1 in r8(deflate state s), param 2 in rdx (cur match)
-
-; see http://weblogs.asp.net/oldnewthing/archive/2004/01/14/58579.aspx and
-; http://msdn.microsoft.com/library/en-us/kmarch/hh/kmarch/64bitAMD_8e951dd2-ee77-4728-8702-55ce4b5dd24a.xml.asp
-;
-; All registers must be preserved across the call, except for
-;   rax, rcx, rdx, r8, r9, r10, and r11, which are scratch.
-
-
-
-;;; Save registers that the compiler may be using, and adjust esp to
-;;; make room for our stack frame.
-
-
-;;; Retrieve the function arguments. r8d will hold cur_match
-;;; throughout the entire function. edx will hold the pointer to the
-;;; deflate_state structure during the function's setup (before
-;;; entering the main loop.
-
-; parameter 1 in rcx (deflate_state* s), param 2 in edx -> r8 (cur match)
-
-; this clear high 32 bits of r8, which can be garbage in both r8 and rdx
-
-        mov [save_rdi],rdi
-        mov [save_rsi],rsi
-        mov [save_rbx],rbx
-        mov [save_rbp],rbp
-IFDEF INFOZIP
-        mov r8d,ecx
-ELSE
-        mov r8d,edx
-ENDIF
-        mov [save_r12],r12
-        mov [save_r13],r13
-;        mov [save_r14],r14
-;        mov [save_r15],r15
-
-
-;;; uInt wmask = s->w_mask;
-;;; unsigned chain_length = s->max_chain_length;
-;;; if (s->prev_length >= s->good_match) {
-;;;     chain_length >>= 2;
-;;; }
-
-        mov edi, prev_length
-        mov esi, good_match
-        mov eax, WMask
-        mov ebx, max_chain_length
-        cmp edi, esi
-        jl  LastMatchGood
-        shr ebx, 2
-LastMatchGood:
-
-;;; chainlen is decremented once beforehand so that the function can
-;;; use the sign flag instead of the zero flag for the exit test.
-;;; It is then shifted into the high word, to make room for the wmask
-;;; value, which it will always accompany.
-
-        dec ebx
-        shl ebx, 16
-        or  ebx, eax
-
-;;; on zlib only
-;;; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
-
-IFDEF INFOZIP
-        mov [chainlenwmask], ebx
-; on infozip nice_match = [nice_match]
-ELSE
-        mov eax, nice_match
-        mov [chainlenwmask], ebx
-        mov r10d, Lookahead
-        cmp r10d, eax
-        cmovnl r10d, eax
-        mov [nicematch],r10d
-ENDIF
-
-;;; register Bytef *scan = s->window + s->strstart;
-        mov r10, window_ad
-        mov ebp, strstart
-        lea r13, [r10 + rbp]
-
-;;; Determine how many bytes the scan ptr is off from being
-;;; dword-aligned.
-
-         mov r9,r13
-         neg r13
-         and r13,3
-
-;;; IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
-;;;     s->strstart - (IPos)MAX_DIST(s) : NIL;
-IFDEF INFOZIP
-        mov eax,07efah ; MAX_DIST = (WSIZE-MIN_LOOKAHEAD) (0x8000-(3+8+1))
-ELSE
-        mov eax, window_size
-        sub eax, MIN_LOOKAHEAD
-ENDIF
-        xor edi,edi
-        sub ebp, eax
-
-        mov r11d, prev_length
-
-        cmovng ebp,edi
-
-;;; int best_len = s->prev_length;
-
-
-;;; Store the sum of s->window + best_len in esi locally, and in esi.
-
-       lea  rsi,[r10+r11]
-
-;;; register ush scan_start = *(ushf*)scan;
-;;; register ush scan_end   = *(ushf*)(scan+best_len-1);
-;;; Posf *prev = s->prev;
-
-        movzx r12d,word ptr [r9]
-        movzx ebx, word ptr [r9 + r11 - 1]
-
-        mov rdi, prev_ad
-
-;;; Jump into the main loop.
-
-        mov edx, [chainlenwmask]
-
-        cmp bx,word ptr [rsi + r8 - 1]
-        jz  LookupLoopIsZero
-
-LookupLoop1:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-        jbe LeaveNow
-        sub edx, 00010000h
-        js  LeaveNow
-
-LoopEntry1:
-        cmp bx,word ptr [rsi + r8 - 1]
-        jz  LookupLoopIsZero
-
-LookupLoop2:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-        jbe LeaveNow
-        sub edx, 00010000h
-        js  LeaveNow
-
-LoopEntry2:
-        cmp bx,word ptr [rsi + r8 - 1]
-        jz  LookupLoopIsZero
-
-LookupLoop4:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-        jbe LeaveNow
-        sub edx, 00010000h
-        js  LeaveNow
-
-LoopEntry4:
-
-        cmp bx,word ptr [rsi + r8 - 1]
-        jnz LookupLoop1
-        jmp LookupLoopIsZero
-
-
-;;; do {
-;;;     match = s->window + cur_match;
-;;;     if (*(ushf*)(match+best_len-1) != scan_end ||
-;;;         *(ushf*)match != scan_start) continue;
-;;;     [...]
-;;; } while ((cur_match = prev[cur_match & wmask]) > limit
-;;;          && --chain_length != 0);
-;;;
-;;; Here is the inner loop of the function. The function will spend the
-;;; majority of its time in this loop, and majority of that time will
-;;; be spent in the first ten instructions.
-;;;
-;;; Within this loop:
-;;; ebx = scanend
-;;; r8d = curmatch
-;;; edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)
-;;; esi = windowbestlen - i.e., (window + bestlen)
-;;; edi = prev
-;;; ebp = limit
-
-LookupLoop:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-        jbe LeaveNow
-        sub edx, 00010000h
-        js  LeaveNow
-
-LoopEntry:
-
-        cmp bx,word ptr [rsi + r8 - 1]
-        jnz LookupLoop1
-LookupLoopIsZero:
-        cmp     r12w, word ptr [r10 + r8]
-        jnz LookupLoop1
-
-
-;;; Store the current value of chainlen.
-        mov [chainlenwmask], edx
-
-;;; Point edi to the string under scrutiny, and esi to the string we
-;;; are hoping to match it up with. In actuality, esi and edi are
-;;; both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and edx is
-;;; initialized to -(MAX_MATCH_8 - scanalign).
-
-        lea rsi,[r8+r10]
-        mov rdx, 0fffffffffffffef8h; -(MAX_MATCH_8)
-        lea rsi, [rsi + r13 + 0108h] ;MAX_MATCH_8]
-        lea rdi, [r9 + r13 + 0108h] ;MAX_MATCH_8]
-
-        prefetcht1 [rsi+rdx]
-        prefetcht1 [rdi+rdx]
-
-
-;;; Test the strings for equality, 8 bytes at a time. At the end,
-;;; adjust rdx so that it is offset to the exact byte that mismatched.
-;;;
-;;; We already know at this point that the first three bytes of the
-;;; strings match each other, and they can be safely passed over before
-;;; starting the compare loop. So what this code does is skip over 0-3
-;;; bytes, as much as necessary in order to dword-align the edi
-;;; pointer. (rsi will still be misaligned three times out of four.)
-;;;
-;;; It should be confessed that this loop usually does not represent
-;;; much of the total running time. Replacing it with a more
-;;; straightforward "rep cmpsb" would not drastically degrade
-;;; performance.
-
-
-LoopCmps:
-        mov rax, [rsi + rdx]
-        xor rax, [rdi + rdx]
-        jnz LeaveLoopCmps
-
-        mov rax, [rsi + rdx + 8]
-        xor rax, [rdi + rdx + 8]
-        jnz LeaveLoopCmps8
-
-
-        mov rax, [rsi + rdx + 8+8]
-        xor rax, [rdi + rdx + 8+8]
-        jnz LeaveLoopCmps16
-
-        add rdx,8+8+8
-
-        jnz short LoopCmps
-        jmp short LenMaximum
-LeaveLoopCmps16: add rdx,8
-LeaveLoopCmps8: add rdx,8
-LeaveLoopCmps:
-
-        test    eax, 0000FFFFh
-        jnz LenLower
-
-        test eax,0ffffffffh
-
-        jnz LenLower32
-
-        add rdx,4
-        shr rax,32
-        or ax,ax
-        jnz LenLower
-
-LenLower32:
-        shr eax,16
-        add rdx,2
-LenLower:   sub al, 1
-        adc rdx, 0
-;;; Calculate the length of the match. If it is longer than MAX_MATCH,
-;;; then automatically accept it as the best possible match and leave.
-
-        lea rax, [rdi + rdx]
-        sub rax, r9
-        cmp eax, MAX_MATCH
-        jge LenMaximum
-
-;;; If the length of the match is not longer than the best match we
-;;; have so far, then forget it and return to the lookup loop.
-;///////////////////////////////////
-
-        cmp eax, r11d
-        jg  LongerMatch
-
-        lea rsi,[r10+r11]
-
-        mov rdi, prev_ad
-        mov edx, [chainlenwmask]
-        jmp LookupLoop
-
-;;;         s->match_start = cur_match;
-;;;         best_len = len;
-;;;         if (len >= nice_match) break;
-;;;         scan_end = *(ushf*)(scan+best_len-1);
-
-LongerMatch:
-        mov r11d, eax
-        mov match_start, r8d
-        cmp eax, [nicematch]
-        jge LeaveNow
-
-        lea rsi,[r10+rax]
-
-        movzx   ebx, word ptr [r9 + rax - 1]
-        mov rdi, prev_ad
-        mov edx, [chainlenwmask]
-        jmp LookupLoop
-
-;;; Accept the current string, with the maximum possible length.
-
-LenMaximum:
-        mov r11d,MAX_MATCH
-        mov match_start, r8d
-
-;;; if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
-;;; return s->lookahead;
-
-LeaveNow:
-IFDEF INFOZIP
-        mov eax,r11d
-ELSE
-        mov eax, Lookahead
-        cmp r11d, eax
-        cmovng eax, r11d
-ENDIF
-
-;;; Restore the stack and return from whence we came.
-
-
-        mov rsi,[save_rsi]
-        mov rdi,[save_rdi]
-        mov rbx,[save_rbx]
-        mov rbp,[save_rbp]
-        mov r12,[save_r12]
-        mov r13,[save_r13]
-;        mov r14,[save_r14]
-;        mov r15,[save_r15]
-
-
-        ret 0
-; please don't remove this string !
-; Your can freely use gvmat64 in any free or commercial app
-; but it is far better don't remove the string in the binary!
-    db     0dh,0ah,"asm686 with masm, optimised assembly code from Brian Raiter, written 1998, converted to amd 64 by Gilles Vollant 2005",0dh,0ah,0
-longest_match   ENDP
-
-match_init PROC
-  ret 0
-match_init ENDP
-
-
-END
diff -Nbaur gcc-4.8.1/zlib/contrib/masmx64/gvmat64.obj gcc-4.8.1-ppc/zlib/contrib/masmx64/gvmat64.obj
--- gcc-4.8.1/zlib/contrib/masmx64/gvmat64.obj	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/masmx64/gvmat64.obj	1970-01-01 01:00:00.000000000 +0100
@@ -1,28 +0,0 @@
-d fB         .text                              P`.data                               @ P.debug$S                  ,   @ B.debug$T        <                 @ BH|$Ht$H\$Hl$DLd$Ll$      AL   ;|   \$D   D;DMDT$LQP   Nl MIIAD-  3+D   NK4E!C\Hy`T$fA;\0   D#FGD;n     b  fA;\0tuD#FGD;I     =  fA;\0tPD#FGD;$       fA;\0u)D#FGD;         fA;\0ffG;$[T$K4HI5  K  2:H2H3:u&HD2H3D:uHD2H3D:uHHH  uuHH fuH,H H:I+=  }=A;K4Hy`T$&DD   ;D$}$J4B\Hy`T$A  D      D;ANHt$H|$H\$Hl$Ld$Ll$
-asm686 with masm, optimised assembly code from Brian Raiter, written 1998, converted to amd 64 by Gilles Vollant 2005
-       *    X:\modifzLib\contrib\masmx64\gvmat64.asm            T-`%*+U                              (             
-                         !     '     -     0     6     8     :     =     ?     B     D     J     N     U     X     \     a     e     k     p     s     v     z     }                                                                                 #    $    '    )    *    +    ,    -    0    1    4    6   7   8   9   :   >   ? !  @ #  X &  Z +  [ .  \ 4  ] :  ^ @  b F  c L  e Q  f W  j [  q _  r i  s q  t y  v }  w                                                                                                                                      $   *   1   7   :   >   C   H   M   R   W   \              /     X:\modifzLib\contrib\masmx64\gvmat64.obj 4              vMicrosoft (R) Macro Assembler   0                                match_init   3                             longest_match         LastMatchGood         LookupLoop1         LoopEntry1         LookupLoop2         LoopEntry2         LookupLoop4         LoopEntry4         LookupLoop         LoopEntry         LookupLoopIsZero         LoopCmps         LeaveLoopCmps16         LeaveLoopCmps8         LeaveLoopCmps         LenLower32         LenLower         LongerMatch         LenMaximum         LeaveNow     `       d      
-   
-      
-   
-   	      	   
-            
-            
-            
-            
- +      /     
- A      E     
- X      \     
- n      r     
-            
-            
-            
-            
-            
-            
-            
- -      1     
- A      E     
- X      \     
- n      r     
-                                      @comp.idv}    .text                          .data                            .debug$S         ,             .debug$T       <                                             $$000000               =           +              7              B              N              Y              e             p   #          {   @             L      LoopCmps                                                          LenLower                          $      LeaveNow1         longest_match match_init LastMatchGood LookupLoop1 LoopEntry1 LookupLoop2 LoopEntry2 LookupLoop4 LoopEntry4 LookupLoop LoopEntry LookupLoopIsZero LeaveLoopCmps16 LeaveLoopCmps8 LeaveLoopCmps LenLower32 LongerMatch LenMaximum 
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/masmx64/inffas8664.c gcc-4.8.1-ppc/zlib/contrib/masmx64/inffas8664.c
--- gcc-4.8.1/zlib/contrib/masmx64/inffas8664.c	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/masmx64/inffas8664.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,186 +0,0 @@
-/* inffas8664.c is a hand tuned assembler version of inffast.c - fast decoding
- * version for AMD64 on Windows using Microsoft C compiler
- *
- * Copyright (C) 1995-2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * Copyright (C) 2003 Chris Anderson <christop@charm.net>
- * Please use the copyright conditions above.
- *
- * 2005 - Adaptation to Microsoft C Compiler for AMD64 by Gilles Vollant
- *
- * inffas8664.c call function inffas8664fnc in inffasx64.asm
- *  inffasx64.asm is automatically convert from AMD64 portion of inffas86.c
- *
- * Dec-29-2003 -- I added AMD64 inflate asm support.  This version is also
- * slightly quicker on x86 systems because, instead of using rep movsb to copy
- * data, it uses rep movsw, which moves data in 2-byte chunks instead of single
- * bytes.  I've tested the AMD64 code on a Fedora Core 1 + the x86_64 updates
- * from http://fedora.linux.duke.edu/fc1_x86_64
- * which is running on an Athlon 64 3000+ / Gigabyte GA-K8VT800M system with
- * 1GB ram.  The 64-bit version is about 4% faster than the 32-bit version,
- * when decompressing mozilla-source-1.3.tar.gz.
- *
- * Mar-13-2003 -- Most of this is derived from inffast.S which is derived from
- * the gcc -S output of zlib-1.2.0/inffast.c.  Zlib-1.2.0 is in beta release at
- * the moment.  I have successfully compiled and tested this code with gcc2.96,
- * gcc3.2, icc5.0, msvc6.0.  It is very close to the speed of inffast.S
- * compiled with gcc -DNO_MMX, but inffast.S is still faster on the P3 with MMX
- * enabled.  I will attempt to merge the MMX code into this version.  Newer
- * versions of this and inffast.S can be found at
- * http://www.eetbeetee.com/zlib/ and http://www.charm.net/~christop/zlib/
- *
- */
-
-#include <stdio.h>
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-
-/* Mark Adler's comments from inffast.c: */
-
-/*
-   Decode literal, length, and distance codes and write out the resulting
-   literal and match bytes until either not enough input or output is
-   available, an end-of-block is encountered, or a data error is encountered.
-   When large enough input and output buffers are supplied to inflate(), for
-   example, a 16K input buffer and a 64K output buffer, more than 95% of the
-   inflate execution time is spent in this routine.
-
-   Entry assumptions:
-
-        state->mode == LEN
-        strm->avail_in >= 6
-        strm->avail_out >= 258
-        start >= strm->avail_out
-        state->bits < 8
-
-   On return, state->mode is one of:
-
-        LEN -- ran out of enough output space or enough available input
-        TYPE -- reached end of block code, inflate() to interpret next block
-        BAD -- error in block data
-
-   Notes:
-
-    - The maximum input bits used by a length/distance pair is 15 bits for the
-      length code, 5 bits for the length extra, 15 bits for the distance code,
-      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
-      Therefore if strm->avail_in >= 6, then there is enough input to avoid
-      checking for available input while decoding.
-
-    - The maximum bytes that a single length/distance pair can output is 258
-      bytes, which is the maximum length that can be coded.  inflate_fast()
-      requires strm->avail_out >= 258 for each loop to avoid checking for
-      output space.
- */
-
-
-
-    typedef struct inffast_ar {
-/* 64   32                               x86  x86_64 */
-/* ar offset                              register */
-/*  0    0 */ void *esp;                /* esp save */
-/*  8    4 */ void *ebp;                /* ebp save */
-/* 16    8 */ unsigned char FAR *in;    /* esi rsi  local strm->next_in */
-/* 24   12 */ unsigned char FAR *last;  /*     r9   while in < last */
-/* 32   16 */ unsigned char FAR *out;   /* edi rdi  local strm->next_out */
-/* 40   20 */ unsigned char FAR *beg;   /*          inflate()'s init next_out */
-/* 48   24 */ unsigned char FAR *end;   /*     r10  while out < end */
-/* 56   28 */ unsigned char FAR *window;/*          size of window, wsize!=0 */
-/* 64   32 */ code const FAR *lcode;    /* ebp rbp  local strm->lencode */
-/* 72   36 */ code const FAR *dcode;    /*     r11  local strm->distcode */
-/* 80   40 */ size_t /*unsigned long */hold;       /* edx rdx  local strm->hold */
-/* 88   44 */ unsigned bits;            /* ebx rbx  local strm->bits */
-/* 92   48 */ unsigned wsize;           /*          window size */
-/* 96   52 */ unsigned write;           /*          window write index */
-/*100   56 */ unsigned lmask;           /*     r12  mask for lcode */
-/*104   60 */ unsigned dmask;           /*     r13  mask for dcode */
-/*108   64 */ unsigned len;             /*     r14  match length */
-/*112   68 */ unsigned dist;            /*     r15  match distance */
-/*116   72 */ unsigned status;          /*          set when state chng*/
-    } type_ar;
-#ifdef ASMINF
-
-void inflate_fast(strm, start)
-z_streamp strm;
-unsigned start;         /* inflate()'s starting value for strm->avail_out */
-{
-    struct inflate_state FAR *state;
-    type_ar ar;
-    void inffas8664fnc(struct inffast_ar * par);
-
-
-
-#if (defined( __GNUC__ ) && defined( __amd64__ ) && ! defined( __i386 )) || (defined(_MSC_VER) && defined(_M_AMD64))
-#define PAD_AVAIL_IN 6
-#define PAD_AVAIL_OUT 258
-#else
-#define PAD_AVAIL_IN 5
-#define PAD_AVAIL_OUT 257
-#endif
-
-    /* copy state to local variables */
-    state = (struct inflate_state FAR *)strm->state;
-
-    ar.in = strm->next_in;
-    ar.last = ar.in + (strm->avail_in - PAD_AVAIL_IN);
-    ar.out = strm->next_out;
-    ar.beg = ar.out - (start - strm->avail_out);
-    ar.end = ar.out + (strm->avail_out - PAD_AVAIL_OUT);
-    ar.wsize = state->wsize;
-    ar.write = state->wnext;
-    ar.window = state->window;
-    ar.hold = state->hold;
-    ar.bits = state->bits;
-    ar.lcode = state->lencode;
-    ar.dcode = state->distcode;
-    ar.lmask = (1U << state->lenbits) - 1;
-    ar.dmask = (1U << state->distbits) - 1;
-
-    /* decode literals and length/distances until end-of-block or not enough
-       input data or output space */
-
-    /* align in on 1/2 hold size boundary */
-    while (((size_t)(void *)ar.in & (sizeof(ar.hold) / 2 - 1)) != 0) {
-        ar.hold += (unsigned long)*ar.in++ << ar.bits;
-        ar.bits += 8;
-    }
-
-    inffas8664fnc(&ar);
-
-    if (ar.status > 1) {
-        if (ar.status == 2)
-            strm->msg = "invalid literal/length code";
-        else if (ar.status == 3)
-            strm->msg = "invalid distance code";
-        else
-            strm->msg = "invalid distance too far back";
-        state->mode = BAD;
-    }
-    else if ( ar.status == 1 ) {
-        state->mode = TYPE;
-    }
-
-    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
-    ar.len = ar.bits >> 3;
-    ar.in -= ar.len;
-    ar.bits -= ar.len << 3;
-    ar.hold &= (1U << ar.bits) - 1;
-
-    /* update state and return */
-    strm->next_in = ar.in;
-    strm->next_out = ar.out;
-    strm->avail_in = (unsigned)(ar.in < ar.last ?
-                                PAD_AVAIL_IN + (ar.last - ar.in) :
-                                PAD_AVAIL_IN - (ar.in - ar.last));
-    strm->avail_out = (unsigned)(ar.out < ar.end ?
-                                 PAD_AVAIL_OUT + (ar.end - ar.out) :
-                                 PAD_AVAIL_OUT - (ar.out - ar.end));
-    state->hold = (unsigned long)ar.hold;
-    state->bits = ar.bits;
-    return;
-}
-
-#endif
diff -Nbaur gcc-4.8.1/zlib/contrib/masmx64/inffasx64.asm gcc-4.8.1-ppc/zlib/contrib/masmx64/inffasx64.asm
--- gcc-4.8.1/zlib/contrib/masmx64/inffasx64.asm	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/masmx64/inffasx64.asm	1970-01-01 01:00:00.000000000 +0100
@@ -1,396 +0,0 @@
-; inffasx64.asm is a hand tuned assembler version of inffast.c - fast decoding
-; version for AMD64 on Windows using Microsoft C compiler
-;
-; inffasx64.asm is automatically convert from AMD64 portion of inffas86.c
-; inffasx64.asm is called by inffas8664.c, which contain more info.
-
-
-; to compile this file, I use option
-;   ml64.exe /Flinffasx64 /c /Zi inffasx64.asm
-;   with Microsoft Macro Assembler (x64) for AMD64
-;
-
-; This file compile with Microsoft Macro Assembler (x64) for AMD64
-;
-;   ml64.exe is given with Visual Studio 2005/2008/2010 and Windows WDK
-;
-;   (you can get Windows WDK with ml64 for AMD64 from
-;      http://www.microsoft.com/whdc/Devtools/wdk/default.mspx for low price)
-;
-
-
-.code
-inffas8664fnc PROC
-
-; see http://weblogs.asp.net/oldnewthing/archive/2004/01/14/58579.aspx and
-; http://msdn.microsoft.com/library/en-us/kmarch/hh/kmarch/64bitAMD_8e951dd2-ee77-4728-8702-55ce4b5dd24a.xml.asp
-;
-; All registers must be preserved across the call, except for
-;   rax, rcx, rdx, r8, r-9, r10, and r11, which are scratch.
-
-
-	mov [rsp-8],rsi
-	mov [rsp-16],rdi
-	mov [rsp-24],r12
-	mov [rsp-32],r13
-	mov [rsp-40],r14
-	mov [rsp-48],r15
-	mov [rsp-56],rbx
-
-	mov rax,rcx
-
-	mov	[rax+8], rbp       ; /* save regs rbp and rsp */
-	mov	[rax], rsp
-
-	mov	rsp, rax          ; /* make rsp point to &ar */
-
-	mov	rsi, [rsp+16]      ; /* rsi  = in */
-	mov	rdi, [rsp+32]      ; /* rdi  = out */
-	mov	r9, [rsp+24]       ; /* r9   = last */
-	mov	r10, [rsp+48]      ; /* r10  = end */
-	mov	rbp, [rsp+64]      ; /* rbp  = lcode */
-	mov	r11, [rsp+72]      ; /* r11  = dcode */
-	mov	rdx, [rsp+80]      ; /* rdx  = hold */
-	mov	ebx, [rsp+88]      ; /* ebx  = bits */
-	mov	r12d, [rsp+100]    ; /* r12d = lmask */
-	mov	r13d, [rsp+104]    ; /* r13d = dmask */
-                                          ; /* r14d = len */
-                                          ; /* r15d = dist */
-
-
-	cld
-	cmp	r10, rdi
-	je	L_one_time           ; /* if only one decode left */
-	cmp	r9, rsi
-
-    jne L_do_loop
-
-
-L_one_time:
-	mov	r8, r12           ; /* r8 = lmask */
-	cmp	bl, 32
-	ja	L_get_length_code_one_time
-
-	lodsd                         ; /* eax = *(uint *)in++ */
-	mov	cl, bl            ; /* cl = bits, needs it for shifting */
-	add	bl, 32             ; /* bits += 32 */
-	shl	rax, cl
-	or	rdx, rax          ; /* hold |= *((uint *)in)++ << bits */
-	jmp	L_get_length_code_one_time
-
-ALIGN 4
-L_while_test:
-	cmp	r10, rdi
-	jbe	L_break_loop
-	cmp	r9, rsi
-	jbe	L_break_loop
-
-L_do_loop:
-	mov	r8, r12           ; /* r8 = lmask */
-	cmp	bl, 32
-	ja	L_get_length_code    ; /* if (32 < bits) */
-
-	lodsd                         ; /* eax = *(uint *)in++ */
-	mov	cl, bl            ; /* cl = bits, needs it for shifting */
-	add	bl, 32             ; /* bits += 32 */
-	shl	rax, cl
-	or	rdx, rax          ; /* hold |= *((uint *)in)++ << bits */
-
-L_get_length_code:
-	and	r8, rdx            ; /* r8 &= hold */
-	mov	eax, [rbp+r8*4]  ; /* eax = lcode[hold & lmask] */
-
-	mov	cl, ah            ; /* cl = this.bits */
-	sub	bl, ah            ; /* bits -= this.bits */
-	shr	rdx, cl           ; /* hold >>= this.bits */
-
-	test	al, al
-	jnz	L_test_for_length_base ; /* if (op != 0) 45.7% */
-
-	mov	r8, r12            ; /* r8 = lmask */
-	shr	eax, 16            ; /* output this.val char */
-	stosb
-
-L_get_length_code_one_time:
-	and	r8, rdx            ; /* r8 &= hold */
-	mov	eax, [rbp+r8*4] ; /* eax = lcode[hold & lmask] */
-
-L_dolen:
-	mov	cl, ah            ; /* cl = this.bits */
-	sub	bl, ah            ; /* bits -= this.bits */
-	shr	rdx, cl           ; /* hold >>= this.bits */
-
-	test	al, al
-	jnz	L_test_for_length_base ; /* if (op != 0) 45.7% */
-
-	shr	eax, 16            ; /* output this.val char */
-	stosb
-	jmp	L_while_test
-
-ALIGN 4
-L_test_for_length_base:
-	mov	r14d, eax         ; /* len = this */
-	shr	r14d, 16           ; /* len = this.val */
-	mov	cl, al
-
-	test	al, 16
-	jz	L_test_for_second_level_length ; /* if ((op & 16) == 0) 8% */
-	and	cl, 15             ; /* op &= 15 */
-	jz	L_decode_distance    ; /* if (!op) */
-
-L_add_bits_to_len:
-	sub	bl, cl
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax
-	and	eax, edx          ; /* eax &= hold */
-	shr	rdx, cl
-	add	r14d, eax         ; /* len += hold & mask[op] */
-
-L_decode_distance:
-	mov	r8, r13           ; /* r8 = dmask */
-	cmp	bl, 32
-	ja	L_get_distance_code  ; /* if (32 < bits) */
-
-	lodsd                         ; /* eax = *(uint *)in++ */
-	mov	cl, bl            ; /* cl = bits, needs it for shifting */
-	add	bl, 32             ; /* bits += 32 */
-	shl	rax, cl
-	or	rdx, rax          ; /* hold |= *((uint *)in)++ << bits */
-
-L_get_distance_code:
-	and	r8, rdx           ; /* r8 &= hold */
-	mov	eax, [r11+r8*4] ; /* eax = dcode[hold & dmask] */
-
-L_dodist:
-	mov	r15d, eax         ; /* dist = this */
-	shr	r15d, 16           ; /* dist = this.val */
-	mov	cl, ah
-	sub	bl, ah            ; /* bits -= this.bits */
-	shr	rdx, cl           ; /* hold >>= this.bits */
-	mov	cl, al            ; /* cl = this.op */
-
-	test	al, 16             ; /* if ((op & 16) == 0) */
-	jz	L_test_for_second_level_dist
-	and	cl, 15             ; /* op &= 15 */
-	jz	L_check_dist_one
-
-L_add_bits_to_dist:
-	sub	bl, cl
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax                 ; /* (1 << op) - 1 */
-	and	eax, edx          ; /* eax &= hold */
-	shr	rdx, cl
-	add	r15d, eax         ; /* dist += hold & ((1 << op) - 1) */
-
-L_check_window:
-	mov	r8, rsi           ; /* save in so from can use it's reg */
-	mov	rax, rdi
-	sub	rax, [rsp+40]      ; /* nbytes = out - beg */
-
-	cmp	eax, r15d
-	jb	L_clip_window        ; /* if (dist > nbytes) 4.2% */
-
-	mov	ecx, r14d         ; /* ecx = len */
-	mov	rsi, rdi
-	sub	rsi, r15          ; /* from = out - dist */
-
-	sar	ecx, 1
-	jnc	L_copy_two           ; /* if len % 2 == 0 */
-
-	rep     movsw
-	mov	al, [rsi]
-	mov	[rdi], al
-	inc	rdi
-
-	mov	rsi, r8           ; /* move in back to %rsi, toss from */
-	jmp	L_while_test
-
-L_copy_two:
-	rep     movsw
-	mov	rsi, r8           ; /* move in back to %rsi, toss from */
-	jmp	L_while_test
-
-ALIGN 4
-L_check_dist_one:
-	cmp	r15d, 1            ; /* if dist 1, is a memset */
-	jne	L_check_window
-	cmp	[rsp+40], rdi      ; /* if out == beg, outside window */
-	je	L_check_window
-
-	mov	ecx, r14d         ; /* ecx = len */
-	mov	al, [rdi-1]
-	mov	ah, al
-
-	sar	ecx, 1
-	jnc	L_set_two
-	mov	[rdi], al
-	inc	rdi
-
-L_set_two:
-	rep     stosw
-	jmp	L_while_test
-
-ALIGN 4
-L_test_for_second_level_length:
-	test	al, 64
-	jnz	L_test_for_end_of_block ; /* if ((op & 64) != 0) */
-
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax
-	and	eax, edx         ; /* eax &= hold */
-	add	eax, r14d        ; /* eax += len */
-	mov	eax, [rbp+rax*4] ; /* eax = lcode[val+(hold&mask[op])]*/
-	jmp	L_dolen
-
-ALIGN 4
-L_test_for_second_level_dist:
-	test	al, 64
-	jnz	L_invalid_distance_code ; /* if ((op & 64) != 0) */
-
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax
-	and	eax, edx         ; /* eax &= hold */
-	add	eax, r15d        ; /* eax += dist */
-	mov	eax, [r11+rax*4] ; /* eax = dcode[val+(hold&mask[op])]*/
-	jmp	L_dodist
-
-ALIGN 4
-L_clip_window:
-	mov	ecx, eax         ; /* ecx = nbytes */
-	mov	eax, [rsp+92]     ; /* eax = wsize, prepare for dist cmp */
-	neg	ecx                ; /* nbytes = -nbytes */
-
-	cmp	eax, r15d
-	jb	L_invalid_distance_too_far ; /* if (dist > wsize) */
-
-	add	ecx, r15d         ; /* nbytes = dist - nbytes */
-	cmp	dword ptr [rsp+96], 0
-	jne	L_wrap_around_window ; /* if (write != 0) */
-
-	mov	rsi, [rsp+56]     ; /* from  = window */
-	sub	eax, ecx         ; /* eax  -= nbytes */
-	add	rsi, rax         ; /* from += wsize - nbytes */
-
-	mov	eax, r14d        ; /* eax = len */
-	cmp	r14d, ecx
-	jbe	L_do_copy           ; /* if (nbytes >= len) */
-
-	sub	eax, ecx         ; /* eax -= nbytes */
-	rep     movsb
-	mov	rsi, rdi
-	sub	rsi, r15         ; /* from = &out[ -dist ] */
-	jmp	L_do_copy
-
-ALIGN 4
-L_wrap_around_window:
-	mov	eax, [rsp+96]     ; /* eax = write */
-	cmp	ecx, eax
-	jbe	L_contiguous_in_window ; /* if (write >= nbytes) */
-
-	mov	esi, [rsp+92]     ; /* from  = wsize */
-	add	rsi, [rsp+56]     ; /* from += window */
-	add	rsi, rax         ; /* from += write */
-	sub	rsi, rcx         ; /* from -= nbytes */
-	sub	ecx, eax         ; /* nbytes -= write */
-
-	mov	eax, r14d        ; /* eax = len */
-	cmp	eax, ecx
-	jbe	L_do_copy           ; /* if (nbytes >= len) */
-
-	sub	eax, ecx         ; /* len -= nbytes */
-	rep     movsb
-	mov	rsi, [rsp+56]     ; /* from = window */
-	mov	ecx, [rsp+96]     ; /* nbytes = write */
-	cmp	eax, ecx
-	jbe	L_do_copy           ; /* if (nbytes >= len) */
-
-	sub	eax, ecx         ; /* len -= nbytes */
-	rep     movsb
-	mov	rsi, rdi
-	sub	rsi, r15         ; /* from = out - dist */
-	jmp	L_do_copy
-
-ALIGN 4
-L_contiguous_in_window:
-	mov	rsi, [rsp+56]     ; /* rsi = window */
-	add	rsi, rax
-	sub	rsi, rcx         ; /* from += write - nbytes */
-
-	mov	eax, r14d        ; /* eax = len */
-	cmp	eax, ecx
-	jbe	L_do_copy           ; /* if (nbytes >= len) */
-
-	sub	eax, ecx         ; /* len -= nbytes */
-	rep     movsb
-	mov	rsi, rdi
-	sub	rsi, r15         ; /* from = out - dist */
-	jmp	L_do_copy           ; /* if (nbytes >= len) */
-
-ALIGN 4
-L_do_copy:
-	mov	ecx, eax         ; /* ecx = len */
-	rep     movsb
-
-	mov	rsi, r8          ; /* move in back to %esi, toss from */
-	jmp	L_while_test
-
-L_test_for_end_of_block:
-	test	al, 32
-	jz	L_invalid_literal_length_code
-	mov	dword ptr [rsp+116], 1
-	jmp	L_break_loop_with_status
-
-L_invalid_literal_length_code:
-	mov	dword ptr [rsp+116], 2
-	jmp	L_break_loop_with_status
-
-L_invalid_distance_code:
-	mov	dword ptr [rsp+116], 3
-	jmp	L_break_loop_with_status
-
-L_invalid_distance_too_far:
-	mov	dword ptr [rsp+116], 4
-	jmp	L_break_loop_with_status
-
-L_break_loop:
-	mov	dword ptr [rsp+116], 0
-
-L_break_loop_with_status:
-; /* put in, out, bits, and hold back into ar and pop esp */
-	mov	[rsp+16], rsi     ; /* in */
-	mov	[rsp+32], rdi     ; /* out */
-	mov	[rsp+88], ebx     ; /* bits */
-	mov	[rsp+80], rdx     ; /* hold */
-
-	mov	rax, [rsp]       ; /* restore rbp and rsp */
-	mov	rbp, [rsp+8]
-	mov	rsp, rax
-
-
-
-	mov rsi,[rsp-8]
-	mov rdi,[rsp-16]
-	mov r12,[rsp-24]
-	mov r13,[rsp-32]
-	mov r14,[rsp-40]
-	mov r15,[rsp-48]
-	mov rbx,[rsp-56]
-
-    ret 0
-;          :
-;          : "m" (ar)
-;          : "memory", "%rax", "%rbx", "%rcx", "%rdx", "%rsi", "%rdi",
-;            "%r8", "%r9", "%r10", "%r11", "%r12", "%r13", "%r14", "%r15"
-;    );
-
-inffas8664fnc 	ENDP
-;_TEXT	ENDS
-END
diff -Nbaur gcc-4.8.1/zlib/contrib/masmx64/inffasx64.obj gcc-4.8.1-ppc/zlib/contrib/masmx64/inffasx64.obj
--- gcc-4.8.1/zlib/contrib/masmx64/inffasx64.obj	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/masmx64/inffasx64.obj	1970-01-01 01:00:00.000000000 +0100
@@ -1,52 +0,0 @@
-d BT  '       .text                              P`.data                               @ P.debug$S                  <   @ B.debug$T        $   0              @ BHt$H|$Ld$Ll$Lt$L|$H\$HHhH HHt$H|$ LL$LT$0Hl$@L\$HHT$P\$XDd$dDl$hL;tL;u*M wP HHBfL;?  L;6  M w HHL#BD *Hu#ML#BD *Hu	ffDA   t*3#HDM w HHL#CDA*H   tP*3#HDLHH+D$(A;   AHI+sfHIfIAuH9|$(tAGsHff@   3#AD f@   3#AA-fD$\A;   A|$` u!Ht$8+HAD;vo+HI+cffD$`;v8t$\Ht$8HH++A;v@+Ht$8L$`;v/+HI+#ffHt$8HH+A;v+HI+fI t
-D$t   &D$t   D$t   D$t   D$t    Ht$H|$ \$XHT$PH$Hl$HHt$H|$Ld$Ll$Lt$L|$H\$      /    O:\zlib-1.2.2.2\contrib\masmx64\inffasx64.asm           Ju,}
-                                           
-                   !     "  #   $  &   &  *   '  -   )  0   +  5   ,  :   -  ?   .  D   /  I   0  N   1  S   2  W   3  \   4  a   9  b   :  e   ;  g   <  j   >  l   B  o   C  r   D  t   F  u   G  w   H  z   I  }   J     K     O     P     Q     R     U     V     W     Y     Z     [     \     ]     `     a     c     d     e     g     h     j     k     l     o     p     s     t     u     w     x     z     {     |                                                                                                                   #    &    *    ,    .    1    3    5    ;    >    @    B    D    F    H    J    L    O    R    U    X    ]    `    f    i    l    o    q    s    v    x    z    }                                                                                                                                                             	        	                         #   %   '   )   ,   /   4  " 8  # :  $ <  & @  ' E  ( H  ) K  * M  , P  - R  . T  0 V  1 X  2 ]  3 a  4 c  5 e  7 g  8 i  9 l  : o  ; t  ? y  @ |  A   C   D   E   G   H   I   J   K   O   P   R   S   V   W   X   Y   \   ]   `   a   d   e   h   l   m   n   o   q   r   s   w   x   y   z   {   |   }         4     O:\zlib-1.2.2.2\contrib\masmx64\inffasx64.obj 4              Microsoft (R) Macro Assembler   3                             inffas8664fnc         L_one_time         L_while_test         L_do_loop         L_get_length_code $        L_get_length_code_one_time         L_dolen          L_test_for_length_base         L_add_bits_to_len         L_decode_distance         L_get_distance_code         L_dodist         L_add_bits_to_dist         L_check_window         L_copy_two         L_check_dist_one         L_set_two (        L_test_for_second_level_length &        L_test_for_second_level_dist         L_clip_window         L_wrap_around_window          L_contiguous_in_window         L_do_copy !        L_test_for_end_of_block '        L_invalid_literal_length_code !        L_invalid_distance_code $        L_invalid_distance_too_far         L_break_loop "        L_break_loop_with_status     d   
-    h   
-   
-   	      	   
-            
-            
-       	     
- 	      	     
- 1	      5	     
- W	      [	     
- j	      n	     
- 	      	     
- 	      	     
- 	      	     
- 	      	     
- 	      	     
- 
-      
-     
- 1
-      5
-     
- G
-      K
-     
- c
-      g
-     
- x
-      |
-     
- 
-      
-     
- 
-      
-     
- 
-      
-     
-            
- %       )      
- :  !    >  !   
- ]  "    a  "   
-   #      #   
-   $      $   
-   %      %   
-   &      &   
-                       @comp.id}    .text                          .data                            .debug$S         <             .debug$T       $                                $$000000               l                         *              4              F          L_dolen            a              x                                    L_dodist#             @             R                                                                          4            B  4          W  t          n            x                                                                      inffas8664fnc L_one_time L_while_test L_do_loop L_get_length_code L_get_length_code_one_time L_test_for_length_base L_add_bits_to_len L_decode_distance L_get_distance_code L_add_bits_to_dist L_check_window L_copy_two L_check_dist_one L_set_two L_test_for_second_level_length L_test_for_second_level_dist L_clip_window L_wrap_around_window L_contiguous_in_window L_do_copy L_test_for_end_of_block L_invalid_literal_length_code L_invalid_distance_code L_invalid_distance_too_far L_break_loop L_break_loop_with_status 
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/masmx64/readme.txt gcc-4.8.1-ppc/zlib/contrib/masmx64/readme.txt
--- gcc-4.8.1/zlib/contrib/masmx64/readme.txt	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/masmx64/readme.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,31 +0,0 @@
-Summary
--------
-This directory contains ASM implementations of the functions
-longest_match() and inflate_fast(), for 64 bits x86 (both AMD64 and Intel EM64t),
-for use with Microsoft Macro Assembler (x64) for AMD64 and Microsoft C++ 64 bits.
-
-gvmat64.asm is written by Gilles Vollant (2005), by using Brian Raiter 686/32 bits
-   assembly optimized version from Jean-loup Gailly original longest_match function
-
-inffasx64.asm and inffas8664.c were written by Chris Anderson, by optimizing
-   original function from Mark Adler
-
-Use instructions
-----------------
-Assemble the .asm files using MASM and put the object files into the zlib source
-directory.  You can also get object files here:
-
-     http://www.winimage.com/zLibDll/zlib124_masm_obj.zip
-
-define ASMV and ASMINF in your project. Include inffas8664.c in your source tree,
-and inffasx64.obj and gvmat64.obj as object to link.
-
-
-Build instructions
-------------------
-run bld_64.bat with Microsoft Macro Assembler (x64) for AMD64 (ml64.exe)
-
-ml64.exe is given with Visual Studio 2005, Windows 2003 server DDK
-
-You can get Windows 2003 server DDK with ml64 and cl for AMD64 from
-  http://www.microsoft.com/whdc/devtools/ddk/default.mspx for low price)
diff -Nbaur gcc-4.8.1/zlib/contrib/masmx86/bld_ml32.bat gcc-4.8.1-ppc/zlib/contrib/masmx86/bld_ml32.bat
--- gcc-4.8.1/zlib/contrib/masmx86/bld_ml32.bat	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/masmx86/bld_ml32.bat	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-ml /coff /Zi /c /Flmatch686.lst match686.asm
-ml /coff /Zi /c /Flinffas32.lst inffas32.asm
diff -Nbaur gcc-4.8.1/zlib/contrib/masmx86/gvmat32.obj gcc-4.8.1-ppc/zlib/contrib/masmx86/gvmat32.obj
--- gcc-4.8.1/zlib/contrib/masmx86/gvmat32.obj	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/masmx86/gvmat32.obj	1970-01-01 01:00:00.000000000 +0100
@@ -1,87 +0,0 @@
-L .B~  i       .text                        ]  0`.data                             @ 0.debug$S      |    b         @ B.debug$T      T   *              @ BT$UWVS4U|]x9   wB   T$0Et;s\$(u8Mlt$$|$t$ff\3  fT$4$u,  +w3L$,U@T$ Upfl$D$LT$T$$|$(t$ O|$ND$0  f98t%  fF;  L$0u  f;,u  |$%  fF;  l$0vf98  %  fF;m  f98  %  fF;R  f98T  %  fF;7  f98(  %  fF;  f98  %  fF;  f98  %  fF;  f98  %  fF;  f98u  %  fF;  f98F  %  fF;  f98  %  fF;z  f98   %  fF;_  f98t}%  fF;H  f98tz%  fF;1  f98ts%  fF;  f98tl%  fF;  f98te%  fF;  l$0Y f;,yD$0  f;,uD$0  f;,uD$0   f;,uD$0   f;,uD$0   f;,D$0   f;,D$0   f;,D$0   f;,D$0	   f;,RD$0
-tf;,&D$0cf;,D$0Rf;,D$0Af;,D$00f;,vD$0f;,JD$0|$$f;,8t$V3Wt-
-t   Qft   E t   6   /?   tW3
-uFfu
-F uF+t$;t$(wt$ L$,T$$t$(D$;t$s"L$T$$Nt$fYt$ L$,\\$l$HL$(]pEt;w4[^_]
-GVMat32 optimised assembly code written 1996-98 by Gilles Vollant
-SX5   PX3tQY5    PX3t   [      UWVS$T$8L$<Bx   ;B4Z||K$   Zt;|\$r8t$jl|5 |$ D$B,-  +3BxD$t$\$\8\$z@$#O;         D1;uD$;D$u$t$|$ D$8  0  23:uD23D:uuq  u, :|$ +=  }LT$8\$;t$z@\$$N\$D$Jp;}-t$t$\8z@\$$!T$8D$  JpT$8\$Bt;$[^_]
-asm686 with masm, optimised assembly code from Brian Raiter, written 1998
-                     	    
-                                     %    )    ,    .     0   ! 2   $ 6   ' 9   ( <   ) @   + D   - F   . J   0 M   2 R   3 X   5 ]   7 `   = c   > i   @ k   A m   B o   D s   G v   H z   K }   L    M    N    P    Q    R    S    T    V    X    f    g    i    j    m    n    p    q    s    t    u    y    z    {    ~                                        4   O   j                     #   :   Q   h                                                0   D   U   f  w    	                   "  #  %  (  )  *  +  -  .  0  1  3  4  5  6  8  9  =	  >  ?  @  B  D  E  F  H  I!  J"  L%  M'  N(  P.  Q0  R1  U5  X9  Y;  [?  \C  ]G  ^L  aP  cT  dX  eZ  f^  gb  hd  if  kg  lk  mo  ps  qw  r|  v  w  x  y  z  {  |  }                                  	   
-                                                              $   %   (   )   ,   -             !  	 "  
- #   &   *   .   1   7   9   <   ?    A  ! D  ) E  * H  + J  , M  0 S  1 V  2 X  3 Z  4 \  5 `  9 c  : g  ; j  < n  = r  B t  C v  D y  E }  J   K   L   M   N   S   T   X   Y   _   `   a   b   c   g   h                                                                                              !   &   (   +   .   0   3   6   :   <   A   C   G   K   M   O   S   V   Z   ]   b   f   j   m   o   q   u   w   {                                                                    ,     O:\updasm\contrib\masmx86\gvmat32.obj 4            
- Microsoft (R) Macro Assembler   8                             _longest_match_686         LastMatchGood         LookaheadLess         LimitPositive         LookupLoop         LoopEntry         LoopCmps         LeaveLoopCmps4         LeaveLoopCmps         LenLower         LongerMatch         LenMaximum         LeaveNow         LookaheadRet   2             >      >            _cpudetect32         exitcpudetect         end_cpu_is_386         is_old_486   9                             _longest_match_7fff         noshr         nolookaheadnicematch         nodist         normalbeg0add16         normalbeg0         rcontlabnoroll         normalbeg2noroll         contloop3         jnbexitloopshort1         beginloop2         do16         rcontloop0         rcontloop1         rcontloop2         rcontloop3         rcontloop4         rcontloop5         rcontloop6         rcontloop7         rcontloop8         rcontloop9         rcontloop10         rcontloop11         rcontloop12         rcontloop13         rcontloop14         rcontloop15         normalbeg2dc11         normalbeg2dc12         normalbeg2dc13         normalbeg2dc14         normalbeg2dc15         normalbeg2dc10         normalbeg2dc9         normalbeg2dc8         normalbeg2dc7         normalbeg2dc6         normalbeg2dc5         normalbeg2dc4         normalbeg2dc3         normalbeg2dc2         normalbeg2dc1         normalbeg2dc0         normalbeg2         iseq         eq1rr         eq1         eq11         begincompare         trfin         trfinval         newbestlen         exitloop         minexlo         InfoAuthor                
-    "       "   
-    #       #   
-    $       $   
-    %       %   
-   &      &   
- $  '    (  '   
- 8  (    <  (   
- R  )    V  )   
- k  *    o  *   
-   +      +   
-   ,      ,   
-   -      -   
-   .      .   
-            
-   /      /   
- )  0    -  0   
- C  1    G  1   
- y      }     
-   2      2   
-   3      3   
-   4      4   
-   5      5   
-   6      6   
-   7      7   
- &  8    *  8   
- B  9    F  9   
- W  :    [  :   
- t  ;    x  ;   
-   <      <   
-   =      =   
-   >      >   
-   ?      ?   
-   @      @   
-   A      A   
-   B      B   
-   C    "  C   
- 4  D    8  D   
- J  E    N  E   
- `  F    d  F   
- v  G    z  G   
-   H      H   
-   I      I   
-   J      J   
-   K      K   
-   L      L   
-    M      M   
-   N      N   
- 4  O    8  O   
- N  P    R  P   
- h  Q    l  Q   
-   R      R   
-   S      S   
-   T      T   
-   U      U   
-   V      V   
-    W      W   
-   X      X   
- 2  Y    6  Y   
- K  Z    O  Z   
- d  [    h  [   
- }  \      \   
-   ]      ]   
-   ^      ^   
-   _      _   
-   `      `   
-   a      a   
-   b      b   
-   c      c   
-   d      d   
- )  e    -  e   
- ?  f    C  f   
- S  g    W  g   
- f  h    j  h   
-                          }              \          .file         gO:\updasm\contrib\masmx86\gvmat32.asm                 @comp.id    .text              ]          .data                            .debug$S       |               .debug$T       T                                           .bf            e                .lf           e .ef          e                               >          .bf          e    (           .lf     !      e .ef          e    U                %                     .bf          e                .lf           e .ef          e                    8   D          F   \          T             b             m         LoopCmps          w                !      LenLower.             b                   LeaveNow                                                          noshr                 2       nodist  o                                                                0             :             L         do16               W             b            m  4          x  O            j                                                                                    #            :            Q            h                                              +            :            I            X            g            u              0            D            U            f            w                                                      iseq          eq1rr         eq1           eq11                      trfin   1      trfinval5            L      exitloop|      minexlo                   !  _longest_match_7fff _cpudetect32 _longest_match_686 LastMatchGood LookaheadLess LimitPositive LookupLoop LoopEntry LeaveLoopCmps4 LeaveLoopCmps LongerMatch LenMaximum LookaheadRet exitcpudetect end_cpu_is_386 is_old_486 nolookaheadnicematch normalbeg0add16 normalbeg0 rcontlabnoroll normalbeg2noroll contloop3 jnbexitloopshort1 beginloop2 rcontloop0 rcontloop1 rcontloop2 rcontloop3 rcontloop4 rcontloop5 rcontloop6 rcontloop7 rcontloop8 rcontloop9 rcontloop10 rcontloop11 rcontloop12 rcontloop13 rcontloop14 rcontloop15 normalbeg2dc11 normalbeg2dc12 normalbeg2dc13 normalbeg2dc14 normalbeg2dc15 normalbeg2dc10 normalbeg2dc9 normalbeg2dc8 normalbeg2dc7 normalbeg2dc6 normalbeg2dc5 normalbeg2dc4 normalbeg2dc3 normalbeg2dc2 normalbeg2dc1 normalbeg2dc0 normalbeg2 begincompare newbestlen InfoAuthor 
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/masmx86/inffas32.asm gcc-4.8.1-ppc/zlib/contrib/masmx86/inffas32.asm
--- gcc-4.8.1/zlib/contrib/masmx86/inffas32.asm	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/masmx86/inffas32.asm	1970-01-01 01:00:00.000000000 +0100
@@ -1,1080 +0,0 @@
-;/* inffas32.asm is a hand tuned assembler version of inffast.c -- fast decoding
-; *
-; * inffas32.asm is derivated from inffas86.c, with translation of assembly code
-; *
-; * Copyright (C) 1995-2003 Mark Adler
-; * For conditions of distribution and use, see copyright notice in zlib.h
-; *
-; * Copyright (C) 2003 Chris Anderson <christop@charm.net>
-; * Please use the copyright conditions above.
-; *
-; * Mar-13-2003 -- Most of this is derived from inffast.S which is derived from
-; * the gcc -S output of zlib-1.2.0/inffast.c.  Zlib-1.2.0 is in beta release at
-; * the moment.  I have successfully compiled and tested this code with gcc2.96,
-; * gcc3.2, icc5.0, msvc6.0.  It is very close to the speed of inffast.S
-; * compiled with gcc -DNO_MMX, but inffast.S is still faster on the P3 with MMX
-; * enabled.  I will attempt to merge the MMX code into this version.  Newer
-; * versions of this and inffast.S can be found at
-; * http://www.eetbeetee.com/zlib/ and http://www.charm.net/~christop/zlib/
-; *
-; * 2005 : modification by Gilles Vollant
-; */
-; For Visual C++ 4.x and higher and ML 6.x and higher
-;   ml.exe is in directory \MASM611C of Win95 DDK
-;   ml.exe is also distributed in http://www.masm32.com/masmdl.htm
-;    and in VC++2003 toolkit at http://msdn.microsoft.com/visualc/vctoolkit2003/
-;
-;
-;   compile with command line option
-;   ml  /coff /Zi /c /Flinffas32.lst inffas32.asm
-
-;   if you define NO_GZIP (see inflate.h), compile with
-;   ml  /coff /Zi /c /Flinffas32.lst /DNO_GUNZIP inffas32.asm
-
-
-; zlib122sup is 0 fort zlib 1.2.2.1 and lower
-; zlib122sup is 8 fort zlib 1.2.2.2 and more (with addition of dmax and head
-;        in inflate_state in inflate.h)
-zlib1222sup      equ    8
-
-
-IFDEF GUNZIP
-  INFLATE_MODE_TYPE    equ 11
-  INFLATE_MODE_BAD     equ 26
-ELSE
-  IFNDEF NO_GUNZIP
-    INFLATE_MODE_TYPE    equ 11
-    INFLATE_MODE_BAD     equ 26
-  ELSE
-    INFLATE_MODE_TYPE    equ 3
-    INFLATE_MODE_BAD     equ 17
-  ENDIF
-ENDIF
-
-
-; 75 "inffast.S"
-;FILE "inffast.S"
-
-;;;GLOBAL _inflate_fast
-
-;;;SECTION .text
-
-
-
-	.586p
-	.mmx
-
-	name	inflate_fast_x86
-	.MODEL	FLAT
-
-_DATA			segment
-inflate_fast_use_mmx:
-	dd	1
-
-
-_TEXT			segment
-
-
-
-ALIGN 4
-	db	'Fast decoding Code from Chris Anderson'
-	db	0
-
-ALIGN 4
-invalid_literal_length_code_msg:
-	db	'invalid literal/length code'
-	db	0
-
-ALIGN 4
-invalid_distance_code_msg:
-	db	'invalid distance code'
-	db	0
-
-ALIGN 4
-invalid_distance_too_far_msg:
-	db	'invalid distance too far back'
-	db	0
-
-
-ALIGN 4
-inflate_fast_mask:
-dd	0
-dd	1
-dd	3
-dd	7
-dd	15
-dd	31
-dd	63
-dd	127
-dd	255
-dd	511
-dd	1023
-dd	2047
-dd	4095
-dd	8191
-dd	16383
-dd	32767
-dd	65535
-dd	131071
-dd	262143
-dd	524287
-dd	1048575
-dd	2097151
-dd	4194303
-dd	8388607
-dd	16777215
-dd	33554431
-dd	67108863
-dd	134217727
-dd	268435455
-dd	536870911
-dd	1073741823
-dd	2147483647
-dd	4294967295
-
-
-mode_state	 equ	0	;/* state->mode	*/
-wsize_state	 equ	(32+zlib1222sup)	;/* state->wsize */
-write_state	 equ	(36+4+zlib1222sup)	;/* state->write */
-window_state	 equ	(40+4+zlib1222sup)	;/* state->window */
-hold_state	 equ	(44+4+zlib1222sup)	;/* state->hold	*/
-bits_state	 equ	(48+4+zlib1222sup)	;/* state->bits	*/
-lencode_state	 equ	(64+4+zlib1222sup)	;/* state->lencode */
-distcode_state	 equ	(68+4+zlib1222sup)	;/* state->distcode */
-lenbits_state	 equ	(72+4+zlib1222sup)	;/* state->lenbits */
-distbits_state	 equ	(76+4+zlib1222sup)	;/* state->distbits */
-
-
-;;SECTION .text
-; 205 "inffast.S"
-;GLOBAL	inflate_fast_use_mmx
-
-;SECTION .data
-
-
-; GLOBAL inflate_fast_use_mmx:object
-;.size inflate_fast_use_mmx, 4
-; 226 "inffast.S"
-;SECTION .text
-
-ALIGN 4
-_inflate_fast proc near
-.FPO (16, 4, 0, 0, 1, 0)
-	push  edi
-	push  esi
-	push  ebp
-	push  ebx
-	pushfd
-	sub  esp,64
-	cld
-
-
-
-
-	mov  esi, [esp+88]
-	mov  edi, [esi+28]
-
-
-
-
-
-
-
-	mov  edx, [esi+4]
-	mov  eax, [esi+0]
-
-	add  edx,eax
-	sub  edx,11
-
-	mov  [esp+44],eax
-	mov  [esp+20],edx
-
-	mov  ebp, [esp+92]
-	mov  ecx, [esi+16]
-	mov  ebx, [esi+12]
-
-	sub  ebp,ecx
-	neg  ebp
-	add  ebp,ebx
-
-	sub  ecx,257
-	add  ecx,ebx
-
-	mov  [esp+60],ebx
-	mov  [esp+40],ebp
-	mov  [esp+16],ecx
-; 285 "inffast.S"
-	mov  eax, [edi+lencode_state]
-	mov  ecx, [edi+distcode_state]
-
-	mov  [esp+8],eax
-	mov  [esp+12],ecx
-
-	mov  eax,1
-	mov  ecx, [edi+lenbits_state]
-	shl  eax,cl
-	dec  eax
-	mov  [esp+0],eax
-
-	mov  eax,1
-	mov  ecx, [edi+distbits_state]
-	shl  eax,cl
-	dec  eax
-	mov  [esp+4],eax
-
-	mov  eax, [edi+wsize_state]
-	mov  ecx, [edi+write_state]
-	mov  edx, [edi+window_state]
-
-	mov  [esp+52],eax
-	mov  [esp+48],ecx
-	mov  [esp+56],edx
-
-	mov  ebp, [edi+hold_state]
-	mov  ebx, [edi+bits_state]
-; 321 "inffast.S"
-	mov  esi, [esp+44]
-	mov  ecx, [esp+20]
-	cmp  ecx,esi
-	ja   L_align_long
-
-	add  ecx,11
-	sub  ecx,esi
-	mov  eax,12
-	sub  eax,ecx
-	lea  edi, [esp+28]
-	rep movsb
-	mov  ecx,eax
-	xor  eax,eax
-	rep stosb
-	lea  esi, [esp+28]
-	mov  [esp+20],esi
-	jmp  L_is_aligned
-
-
-L_align_long:
-	test  esi,3
-	jz   L_is_aligned
-	xor  eax,eax
-	mov  al, [esi]
-	inc  esi
-	mov  ecx,ebx
-	add  ebx,8
-	shl  eax,cl
-	or  ebp,eax
-	jmp L_align_long
-
-L_is_aligned:
-	mov  edi, [esp+60]
-; 366 "inffast.S"
-L_check_mmx:
-	cmp  dword ptr [inflate_fast_use_mmx],2
-	je   L_init_mmx
-	ja   L_do_loop
-
-	push  eax
-	push  ebx
-	push  ecx
-	push  edx
-	pushfd
-	mov  eax, [esp]
-	xor  dword ptr [esp],0200000h
-
-
-
-
-	popfd
-	pushfd
-	pop  edx
-	xor  edx,eax
-	jz   L_dont_use_mmx
-	xor  eax,eax
-	cpuid
-	cmp  ebx,0756e6547h
-	jne  L_dont_use_mmx
-	cmp  ecx,06c65746eh
-	jne  L_dont_use_mmx
-	cmp  edx,049656e69h
-	jne  L_dont_use_mmx
-	mov  eax,1
-	cpuid
-	shr  eax,8
-	and  eax,15
-	cmp  eax,6
-	jne  L_dont_use_mmx
-	test  edx,0800000h
-	jnz  L_use_mmx
-	jmp  L_dont_use_mmx
-L_use_mmx:
-	mov  dword ptr [inflate_fast_use_mmx],2
-	jmp  L_check_mmx_pop
-L_dont_use_mmx:
-	mov  dword ptr [inflate_fast_use_mmx],3
-L_check_mmx_pop:
-	pop  edx
-	pop  ecx
-	pop  ebx
-	pop  eax
-	jmp  L_check_mmx
-; 426 "inffast.S"
-ALIGN 4
-L_do_loop:
-; 437 "inffast.S"
-	cmp  bl,15
-	ja   L_get_length_code
-
-	xor  eax,eax
-	lodsw
-	mov  cl,bl
-	add  bl,16
-	shl  eax,cl
-	or  ebp,eax
-
-L_get_length_code:
-	mov  edx, [esp+0]
-	mov  ecx, [esp+8]
-	and  edx,ebp
-	mov  eax, [ecx+edx*4]
-
-L_dolen:
-
-
-
-
-
-
-	mov  cl,ah
-	sub  bl,ah
-	shr  ebp,cl
-
-
-
-
-
-
-	test  al,al
-	jnz   L_test_for_length_base
-
-	shr  eax,16
-	stosb
-
-L_while_test:
-
-
-	cmp  [esp+16],edi
-	jbe  L_break_loop
-
-	cmp  [esp+20],esi
-	ja   L_do_loop
-	jmp  L_break_loop
-
-L_test_for_length_base:
-; 502 "inffast.S"
-	mov  edx,eax
-	shr  edx,16
-	mov  cl,al
-
-	test  al,16
-	jz   L_test_for_second_level_length
-	and  cl,15
-	jz   L_save_len
-	cmp  bl,cl
-	jae  L_add_bits_to_len
-
-	mov  ch,cl
-	xor  eax,eax
-	lodsw
-	mov  cl,bl
-	add  bl,16
-	shl  eax,cl
-	or  ebp,eax
-	mov  cl,ch
-
-L_add_bits_to_len:
-	mov  eax,1
-	shl  eax,cl
-	dec  eax
-	sub  bl,cl
-	and  eax,ebp
-	shr  ebp,cl
-	add  edx,eax
-
-L_save_len:
-	mov  [esp+24],edx
-
-
-L_decode_distance:
-; 549 "inffast.S"
-	cmp  bl,15
-	ja   L_get_distance_code
-
-	xor  eax,eax
-	lodsw
-	mov  cl,bl
-	add  bl,16
-	shl  eax,cl
-	or  ebp,eax
-
-L_get_distance_code:
-	mov  edx, [esp+4]
-	mov  ecx, [esp+12]
-	and  edx,ebp
-	mov  eax, [ecx+edx*4]
-
-
-L_dodist:
-	mov  edx,eax
-	shr  edx,16
-	mov  cl,ah
-	sub  bl,ah
-	shr  ebp,cl
-; 584 "inffast.S"
-	mov  cl,al
-
-	test  al,16
-	jz  L_test_for_second_level_dist
-	and  cl,15
-	jz  L_check_dist_one
-	cmp  bl,cl
-	jae  L_add_bits_to_dist
-
-	mov  ch,cl
-	xor  eax,eax
-	lodsw
-	mov  cl,bl
-	add  bl,16
-	shl  eax,cl
-	or  ebp,eax
-	mov  cl,ch
-
-L_add_bits_to_dist:
-	mov  eax,1
-	shl  eax,cl
-	dec  eax
-	sub  bl,cl
-	and  eax,ebp
-	shr  ebp,cl
-	add  edx,eax
-	jmp  L_check_window
-
-L_check_window:
-; 625 "inffast.S"
-	mov  [esp+44],esi
-	mov  eax,edi
-	sub  eax, [esp+40]
-
-	cmp  eax,edx
-	jb   L_clip_window
-
-	mov  ecx, [esp+24]
-	mov  esi,edi
-	sub  esi,edx
-
-	sub  ecx,3
-	mov  al, [esi]
-	mov  [edi],al
-	mov  al, [esi+1]
-	mov  dl, [esi+2]
-	add  esi,3
-	mov  [edi+1],al
-	mov  [edi+2],dl
-	add  edi,3
-	rep movsb
-
-	mov  esi, [esp+44]
-	jmp  L_while_test
-
-ALIGN 4
-L_check_dist_one:
-	cmp  edx,1
-	jne  L_check_window
-	cmp  [esp+40],edi
-	je  L_check_window
-
-	dec  edi
-	mov  ecx, [esp+24]
-	mov  al, [edi]
-	sub  ecx,3
-
-	mov  [edi+1],al
-	mov  [edi+2],al
-	mov  [edi+3],al
-	add  edi,4
-	rep stosb
-
-	jmp  L_while_test
-
-ALIGN 4
-L_test_for_second_level_length:
-
-
-
-
-	test  al,64
-	jnz   L_test_for_end_of_block
-
-	mov  eax,1
-	shl  eax,cl
-	dec  eax
-	and  eax,ebp
-	add  eax,edx
-	mov  edx, [esp+8]
-	mov  eax, [edx+eax*4]
-	jmp  L_dolen
-
-ALIGN 4
-L_test_for_second_level_dist:
-
-
-
-
-	test  al,64
-	jnz   L_invalid_distance_code
-
-	mov  eax,1
-	shl  eax,cl
-	dec  eax
-	and  eax,ebp
-	add  eax,edx
-	mov  edx, [esp+12]
-	mov  eax, [edx+eax*4]
-	jmp  L_dodist
-
-ALIGN 4
-L_clip_window:
-; 721 "inffast.S"
-	mov  ecx,eax
-	mov  eax, [esp+52]
-	neg  ecx
-	mov  esi, [esp+56]
-
-	cmp  eax,edx
-	jb   L_invalid_distance_too_far
-
-	add  ecx,edx
-	cmp  dword ptr [esp+48],0
-	jne  L_wrap_around_window
-
-	sub  eax,ecx
-	add  esi,eax
-; 749 "inffast.S"
-	mov  eax, [esp+24]
-	cmp  eax,ecx
-	jbe  L_do_copy1
-
-	sub  eax,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,edx
-	jmp  L_do_copy1
-
-	cmp  eax,ecx
-	jbe  L_do_copy1
-
-	sub  eax,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,edx
-	jmp  L_do_copy1
-
-L_wrap_around_window:
-; 793 "inffast.S"
-	mov  eax, [esp+48]
-	cmp  ecx,eax
-	jbe  L_contiguous_in_window
-
-	add  esi, [esp+52]
-	add  esi,eax
-	sub  esi,ecx
-	sub  ecx,eax
-
-
-	mov  eax, [esp+24]
-	cmp  eax,ecx
-	jbe  L_do_copy1
-
-	sub  eax,ecx
-	rep movsb
-	mov  esi, [esp+56]
-	mov  ecx, [esp+48]
-	cmp  eax,ecx
-	jbe  L_do_copy1
-
-	sub  eax,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,edx
-	jmp  L_do_copy1
-
-L_contiguous_in_window:
-; 836 "inffast.S"
-	add  esi,eax
-	sub  esi,ecx
-
-
-	mov  eax, [esp+24]
-	cmp  eax,ecx
-	jbe  L_do_copy1
-
-	sub  eax,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,edx
-
-L_do_copy1:
-; 862 "inffast.S"
-	mov  ecx,eax
-	rep movsb
-
-	mov  esi, [esp+44]
-	jmp  L_while_test
-; 878 "inffast.S"
-ALIGN 4
-L_init_mmx:
-	emms
-
-
-
-
-
-	movd mm0,ebp
-	mov  ebp,ebx
-; 896 "inffast.S"
-	movd mm4,dword ptr [esp+0]
-	movq mm3,mm4
-	movd mm5,dword ptr [esp+4]
-	movq mm2,mm5
-	pxor mm1,mm1
-	mov  ebx, [esp+8]
-	jmp  L_do_loop_mmx
-
-ALIGN 4
-L_do_loop_mmx:
-	psrlq mm0,mm1
-
-	cmp  ebp,32
-	ja  L_get_length_code_mmx
-
-	movd mm6,ebp
-	movd mm7,dword ptr [esi]
-	add  esi,4
-	psllq mm7,mm6
-	add  ebp,32
-	por mm0,mm7
-
-L_get_length_code_mmx:
-	pand mm4,mm0
-	movd eax,mm4
-	movq mm4,mm3
-	mov  eax, [ebx+eax*4]
-
-L_dolen_mmx:
-	movzx  ecx,ah
-	movd mm1,ecx
-	sub  ebp,ecx
-
-	test  al,al
-	jnz L_test_for_length_base_mmx
-
-	shr  eax,16
-	stosb
-
-L_while_test_mmx:
-
-
-	cmp  [esp+16],edi
-	jbe L_break_loop
-
-	cmp  [esp+20],esi
-	ja L_do_loop_mmx
-	jmp L_break_loop
-
-L_test_for_length_base_mmx:
-
-	mov  edx,eax
-	shr  edx,16
-
-	test  al,16
-	jz  L_test_for_second_level_length_mmx
-	and  eax,15
-	jz L_decode_distance_mmx
-
-	psrlq mm0,mm1
-	movd mm1,eax
-	movd ecx,mm0
-	sub  ebp,eax
-	and  ecx, [inflate_fast_mask+eax*4]
-	add  edx,ecx
-
-L_decode_distance_mmx:
-	psrlq mm0,mm1
-
-	cmp  ebp,32
-	ja L_get_dist_code_mmx
-
-	movd mm6,ebp
-	movd mm7,dword ptr [esi]
-	add  esi,4
-	psllq mm7,mm6
-	add  ebp,32
-	por mm0,mm7
-
-L_get_dist_code_mmx:
-	mov  ebx, [esp+12]
-	pand mm5,mm0
-	movd eax,mm5
-	movq mm5,mm2
-	mov  eax, [ebx+eax*4]
-
-L_dodist_mmx:
-
-	movzx  ecx,ah
-	mov  ebx,eax
-	shr  ebx,16
-	sub  ebp,ecx
-	movd mm1,ecx
-
-	test  al,16
-	jz L_test_for_second_level_dist_mmx
-	and  eax,15
-	jz L_check_dist_one_mmx
-
-L_add_bits_to_dist_mmx:
-	psrlq mm0,mm1
-	movd mm1,eax
-	movd ecx,mm0
-	sub  ebp,eax
-	and  ecx, [inflate_fast_mask+eax*4]
-	add  ebx,ecx
-
-L_check_window_mmx:
-	mov  [esp+44],esi
-	mov  eax,edi
-	sub  eax, [esp+40]
-
-	cmp  eax,ebx
-	jb L_clip_window_mmx
-
-	mov  ecx,edx
-	mov  esi,edi
-	sub  esi,ebx
-
-	sub  ecx,3
-	mov  al, [esi]
-	mov  [edi],al
-	mov  al, [esi+1]
-	mov  dl, [esi+2]
-	add  esi,3
-	mov  [edi+1],al
-	mov  [edi+2],dl
-	add  edi,3
-	rep movsb
-
-	mov  esi, [esp+44]
-	mov  ebx, [esp+8]
-	jmp  L_while_test_mmx
-
-ALIGN 4
-L_check_dist_one_mmx:
-	cmp  ebx,1
-	jne  L_check_window_mmx
-	cmp  [esp+40],edi
-	je   L_check_window_mmx
-
-	dec  edi
-	mov  ecx,edx
-	mov  al, [edi]
-	sub  ecx,3
-
-	mov  [edi+1],al
-	mov  [edi+2],al
-	mov  [edi+3],al
-	add  edi,4
-	rep stosb
-
-	mov  ebx, [esp+8]
-	jmp  L_while_test_mmx
-
-ALIGN 4
-L_test_for_second_level_length_mmx:
-	test  al,64
-	jnz L_test_for_end_of_block
-
-	and  eax,15
-	psrlq mm0,mm1
-	movd ecx,mm0
-	and  ecx, [inflate_fast_mask+eax*4]
-	add  ecx,edx
-	mov  eax, [ebx+ecx*4]
-	jmp L_dolen_mmx
-
-ALIGN 4
-L_test_for_second_level_dist_mmx:
-	test  al,64
-	jnz L_invalid_distance_code
-
-	and  eax,15
-	psrlq mm0,mm1
-	movd ecx,mm0
-	and  ecx, [inflate_fast_mask+eax*4]
-	mov  eax, [esp+12]
-	add  ecx,ebx
-	mov  eax, [eax+ecx*4]
-	jmp  L_dodist_mmx
-
-ALIGN 4
-L_clip_window_mmx:
-
-	mov  ecx,eax
-	mov  eax, [esp+52]
-	neg  ecx
-	mov  esi, [esp+56]
-
-	cmp  eax,ebx
-	jb  L_invalid_distance_too_far
-
-	add  ecx,ebx
-	cmp  dword ptr [esp+48],0
-	jne  L_wrap_around_window_mmx
-
-	sub  eax,ecx
-	add  esi,eax
-
-	cmp  edx,ecx
-	jbe  L_do_copy1_mmx
-
-	sub  edx,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,ebx
-	jmp  L_do_copy1_mmx
-
-	cmp  edx,ecx
-	jbe  L_do_copy1_mmx
-
-	sub  edx,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,ebx
-	jmp  L_do_copy1_mmx
-
-L_wrap_around_window_mmx:
-
-	mov  eax, [esp+48]
-	cmp  ecx,eax
-	jbe  L_contiguous_in_window_mmx
-
-	add  esi, [esp+52]
-	add  esi,eax
-	sub  esi,ecx
-	sub  ecx,eax
-
-
-	cmp  edx,ecx
-	jbe  L_do_copy1_mmx
-
-	sub  edx,ecx
-	rep movsb
-	mov  esi, [esp+56]
-	mov  ecx, [esp+48]
-	cmp  edx,ecx
-	jbe  L_do_copy1_mmx
-
-	sub  edx,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,ebx
-	jmp  L_do_copy1_mmx
-
-L_contiguous_in_window_mmx:
-
-	add  esi,eax
-	sub  esi,ecx
-
-
-	cmp  edx,ecx
-	jbe  L_do_copy1_mmx
-
-	sub  edx,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,ebx
-
-L_do_copy1_mmx:
-
-
-	mov  ecx,edx
-	rep movsb
-
-	mov  esi, [esp+44]
-	mov  ebx, [esp+8]
-	jmp  L_while_test_mmx
-; 1174 "inffast.S"
-L_invalid_distance_code:
-
-
-
-
-
-	mov  ecx, invalid_distance_code_msg
-	mov  edx,INFLATE_MODE_BAD
-	jmp  L_update_stream_state
-
-L_test_for_end_of_block:
-
-
-
-
-
-	test  al,32
-	jz  L_invalid_literal_length_code
-
-	mov  ecx,0
-	mov  edx,INFLATE_MODE_TYPE
-	jmp  L_update_stream_state
-
-L_invalid_literal_length_code:
-
-
-
-
-
-	mov  ecx, invalid_literal_length_code_msg
-	mov  edx,INFLATE_MODE_BAD
-	jmp  L_update_stream_state
-
-L_invalid_distance_too_far:
-
-
-
-	mov  esi, [esp+44]
-	mov  ecx, invalid_distance_too_far_msg
-	mov  edx,INFLATE_MODE_BAD
-	jmp  L_update_stream_state
-
-L_update_stream_state:
-
-	mov  eax, [esp+88]
-	test  ecx,ecx
-	jz  L_skip_msg
-	mov  [eax+24],ecx
-L_skip_msg:
-	mov  eax, [eax+28]
-	mov  [eax+mode_state],edx
-	jmp  L_break_loop
-
-ALIGN 4
-L_break_loop:
-; 1243 "inffast.S"
-	cmp  dword ptr [inflate_fast_use_mmx],2
-	jne  L_update_next_in
-
-
-
-	mov  ebx,ebp
-
-L_update_next_in:
-; 1266 "inffast.S"
-	mov  eax, [esp+88]
-	mov  ecx,ebx
-	mov  edx, [eax+28]
-	shr  ecx,3
-	sub  esi,ecx
-	shl  ecx,3
-	sub  ebx,ecx
-	mov  [eax+12],edi
-	mov  [edx+bits_state],ebx
-	mov  ecx,ebx
-
-	lea  ebx, [esp+28]
-	cmp  [esp+20],ebx
-	jne  L_buf_not_used
-
-	sub  esi,ebx
-	mov  ebx, [eax+0]
-	mov  [esp+20],ebx
-	add  esi,ebx
-	mov  ebx, [eax+4]
-	sub  ebx,11
-	add  [esp+20],ebx
-
-L_buf_not_used:
-	mov  [eax+0],esi
-
-	mov  ebx,1
-	shl  ebx,cl
-	dec  ebx
-
-
-
-
-
-	cmp  dword ptr [inflate_fast_use_mmx],2
-	jne  L_update_hold
-
-
-
-	psrlq mm0,mm1
-	movd ebp,mm0
-
-	emms
-
-L_update_hold:
-
-
-
-	and  ebp,ebx
-	mov  [edx+hold_state],ebp
-
-
-
-
-	mov  ebx, [esp+20]
-	cmp  ebx,esi
-	jbe  L_last_is_smaller
-
-	sub  ebx,esi
-	add  ebx,11
-	mov  [eax+4],ebx
-	jmp  L_fixup_out
-L_last_is_smaller:
-	sub  esi,ebx
-	neg  esi
-	add  esi,11
-	mov  [eax+4],esi
-
-
-
-
-L_fixup_out:
-
-	mov  ebx, [esp+16]
-	cmp  ebx,edi
-	jbe  L_end_is_smaller
-
-	sub  ebx,edi
-	add  ebx,257
-	mov  [eax+16],ebx
-	jmp  L_done
-L_end_is_smaller:
-	sub  edi,ebx
-	neg  edi
-	add  edi,257
-	mov  [eax+16],edi
-
-
-
-
-
-L_done:
-	add  esp,64
-	popfd
-	pop  ebx
-	pop  ebp
-	pop  esi
-	pop  edi
-	ret
-_inflate_fast endp
-
-_TEXT	ends
-end
diff -Nbaur gcc-4.8.1/zlib/contrib/masmx86/inffas32.obj gcc-4.8.1-ppc/zlib/contrib/masmx86/inffas32.obj
--- gcc-4.8.1/zlib/contrib/masmx86/inffas32.obj	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/masmx86/inffas32.obj	1970-01-01 01:00:00.000000000 +0100
@@ -1,158 +0,0 @@
-L vB/  R       .text                P     Q  P`.data                          @ P.debug$S          %         @ B.debug$T          /              @ B  I Fast decoding Code from Chris Anderson invalid literal/length code invalid distance code invalid distance too far back                    ?                   ?           ?   ?WVUS@t$X~VD$,T$l$\N^+  \$<l$(L$GLOPD$L$   OTH$   OXHD$G(O0W4D$4L$0T$8o8_<t$,L$;w"+   +|$3t$t$   t3F|$<=      wkPSQR$4$    Z3tD3Genuu8ntelu0ineIu(   u   u       
-       ZY[Xw3f$L$#*u9|$b  9t$wW     t%8s3f   H*#T$w3fT$L$#*   te8s3f   H*# t$,+D$(;   L$+FVGWt$,u9|$(tOL$GGG@     H#T$@     H#T$D$4t$8;  |$0 u$+D$;v`++V;vR++HD$0;v,t$4++D$;v.+t$8L$0;v+++D$;v++t$,wnn$$nl$\$ wnn> ~n+u9|$  9t$w     tn~+#     wnn> \$~+n   tWn~+#    t$,+D$(;   +FVGWt$,\$-I u9|$(tOGGG\$ @   ~#    @   ~#    D$D$4t$8;   |$0 u +;vX++N;vJ++@D$0;v(t$4++;v*+t$8L$0;v+++;v++t$,\$$       , t              t$,        D$XtH@ =    uD$XP++xZ<\$9\$u+\$X\$0   K=    u~w#j8\$;v
-+X
-+p\$;v+  X+  x@[]^_       =      I            W                                          @             W 	  X 
-  Y   Z   [   \   ]   b   c   k   l   n   o "  q &  r *  t .  u 1  v 4  x 6  y 8  z :  | @  } B   F   J   N   Q   T   X   \   a   d   f   g   j   o   r   t   u   y   |                                                                                                                                                                              $   &   )   ,   /   1   7   9   ;   E   G   Q   R   S   T   U   X   [   ]   _   a   c   f   h   j  m  q  s  v  x  z  |  ~           !  #  $  %  )  *  +  -  .  /  0  1  2  4  5  6  7  8  9  :  ;  >  ?  @  A  B  C  D  G  L  M  O  P  Q  R  S  T  W  X  Y  Z  ^  _  `  a  b   d  f  g
-  h  i  j  k  m  n  o  p  q  r   s"  t$  w)  x+  y,  z.  {0  |2  }4  ~6  :  <  @  B  H  L  N  P  S  U  W  Z  ]  `  c  f  i  k  o  t  w  y  }                                                                                              	                      !  #  %  )  +   -  /  3  5  7  9  	;  
-?  C  E  G  I  K  M  O  Q  S  U  Y  [  ]  _   a  !c  "e  &g  'i  )m  *t  .v  4y  5{  7  8  9  :  ;  <  =  A  C  D  F  G  H  I  J  K  N  O  P  Q  T  U  V  X  Y  [  \  a  b  d  e  f  j  k  m  n  o  p  r  s  t  u  v  w  z  |  }              #  &  )  ,  /  2  4  7  9  <  >  D  G  I  L  O  R  T  [  ]  a  c  g  i  o  q  s  u  x  z  |                                                                                                 $  &  ,  .  3  5  7  9  ;   =  ?  A  C  E  G  I  	K  M  O  Q  S  U  Y  [  ]  a  c  e  g  i  k   m  !o  "s  #w  $y  %{  '}  (  )  *  +  /  0  3  4  6  7  8  9  >  ?  A  B  C  K  L  M  U  V  X  Y  Z  b  c  d  j  k  l  m  q  r  s  t  v  w  x  }  ~            	                   "  $  (  *  -  0  4  6  ;  =  >  E  G  J  M  O  Q  T  X  Z  \  ^  a  d  f  h  j  m  p  t  v  x  z                                   	    inffas32.obj6    /Microsoft (R) Macro Assembler Version 6.14.8444  	       L_test_for_length_base$ 	       L_invalid_distance_too_far 	       L_check_dist_one_mmx 	       L_do_copy1_mmx 	       L_wrap_around_window 	       
-L_do_copy1 	       L_add_bits_to_len 	       	L_do_loop' 	       L_invalid_literal_length_code# 	       invalid_distance_code_msg 	       L_get_length_code_mmx 	       _inflate_fast 	       
-L_init_mmx( 	       L_test_for_second_level_length 	       
-L_save_len  	       L_add_bits_to_dist_mmx 	       inflate_fast_mask 	       L_update_next_in 	       L_dodist 	       
-L_skip_msg 	       L_get_distance_code" 	       L_wrap_around_window_mmx 	       L_do_loop_mmx! 	       L_invalid_distance_code& 	       L_test_for_second_level_dist! 	       L_test_for_end_of_block) 	       invalid_literal_length_code_msg* 	        L_test_for_second_level_dist_mmx 	       L_clip_window_mmx 	       L_dolen_mmx 	       	L_use_mmx 	       L_break_loop 	       L_get_length_code 	       L_add_bits_to_dist 	       L_fixup_out 	       L_get_dist_code_mmx 	       L_clip_window,                           $$$00001) 	       invalid_literal_length_code_msg# 	       invalid_distance_code_msg& 	       invalid_distance_too_far_msg 	       inflate_fast_mask 	       inflate_fast_entry 	       L_align_long 	       L_is_aligned 	       L_check_mmx 	       	L_use_mmx 	       L_dont_use_mmx 	       L_check_mmx_pop 	       	L_do_loop 	       L_get_length_code 	       L_dolen 	       L_while_test  	       L_test_for_length_base 	       L_add_bits_to_len 	       
-L_save_len 	       L_decode_distance 	       L_get_distance_code 	       L_dodist 	       L_add_bits_to_dist 	       L_check_window 	       L_check_dist_one( 	       L_test_for_second_level_length& 	       L_test_for_second_level_dist 	       L_clip_window 	       L_wrap_around_window  	       L_contiguous_in_window 	       
-L_do_copy1 	       
-L_init_mmx 	       L_do_loop_mmx 	       L_get_length_code_mmx 	       L_dolen_mmx 	       L_while_test_mmx$ 	       L_test_for_length_base_mmx 	       L_decode_distance_mmx 	       L_get_dist_code_mmx 	       L_dodist_mmx  	       L_add_bits_to_dist_mmx 	       L_check_window_mmx 	       L_check_dist_one_mmx, 	       "L_test_for_second_level_length_mmx* 	        L_test_for_second_level_dist_mmx 	       L_clip_window_mmx" 	       L_wrap_around_window_mmx$ 	       L_contiguous_in_window_mmx 	       L_do_copy1_mmx! 	       L_invalid_distance_code! 	       L_test_for_end_of_block' 	       L_invalid_literal_length_code$ 	       L_invalid_distance_too_far 	       L_update_stream_state 	       
-L_skip_msg 	       L_break_loop 	       L_update_next_in 	       L_buf_not_used 	       L_update_hold 	       L_last_is_smaller 	       L_fixup_out 	       L_end_is_smaller 	       L_done   	       L_check_mmx 	       L_decode_distance_mmx 	       L_dont_use_mmx 	       L_is_aligned 	       L_check_window  	       L_contiguous_in_window 	       L_buf_not_used 	       L_update_stream_state 	       L_decode_distance 	       L_while_test 	       inflate_fast_use_mmx, 	       "L_test_for_second_level_length_mmx 	       L_check_dist_one 	       L_end_is_smaller 	       L_check_window_mmx 	       L_while_test_mmx 	       L_update_hold$ 	       L_test_for_length_base_mmx 	       L_dodist_mmx 	       L_align_long 	       inflate_fast_entry 	       L_dolen 	       L_last_is_smaller 	       L_check_mmx_pop 	       L_done$ 	       L_contiguous_in_window_mmx& 	       invalid_distance_too_far_msgU       Y      
- w       {      
-              
-              
-              
-              
-            
- *      .     
- ?       C      
- h      l     
-   !      !   
-            
-   "      "   
-   #      #   
-   $      $   
-   %    !  %   
- ?      C     
- \  &    `  &   
- x  '    |  '   
-   (      (   
-   )      )   
-   *      *   
-   +      +   
-   ,      ,   
- !  -    %  -   
- I  .    M  .   
- l      p     
-   /      /   
-   0      0   
-   1      1   
-   2      2   
-   3      3   
- $  4    (  4   
- A  5    E  5   
- _  6    c  6   
- v  7    z  7   
-   8      8   
-            
-            
-            
- ,      0     
- T      X     
- q  9    u  9   
-   :      :   
-   ;      ;   
-   <      <   
-   2      2   
-   =      =   
-   >    	  >   
-        $     
- 5  4    9  4   
- R  ?    V  ?   
- e  @    i  @   
- }           
-            
-   $      $   
-   A      A   
-   )      )   
-   '      '   
- "  5    &  5   
- @  B    D  B   
- Z  C    ^  C   
- v  #    z  #   
-   -      -   
-   8      8   
-            
-   D      D   
- #      '     
- 9  "    =  "   
- O  +    S  +   
- h  !    l  !   
-   1      1   
-   E      E   
-   F      F   
-   G      G   
- 	  7    	  7   
- "	  H    &	  H   
- :	  %    >	  %   
- \	  I    `	  I   
- z	      ~	     
- 	  J    	  J   
- 	  /    	  /   
- 	  0    	  0   
- 
-  *    
-  *   
- 5
-  K    9
-  K   
- [
-      _
-     
- u
-  ,    y
-  ,   
- 
-  .    
-  .   
- 
-       
-      
- 
-      
-     
- 
-  L      L   
- +  (    /  (   
- A  3    E  3   
- Y  &    ]  &   
- u  M    y  M   
-   N      N   
-   O      O   
-   6      6   
-   P      P   
-   Q      Q   
-   <      <   
- %  G    )  G   
- F  =    J  =   
- `  ;    d  ;   
- x  B    |  B   
-   D      D   
-   M      M   
-   L      L   
-   A      A   
-   @      @   
- $      (     
- D  J    H  J   
- r  C    v  C   
-   P      P   
-   I      I   
-   E      E   
-   N      N   
-   F      F   
- #  H    '  H   
- ;  :    ?  :   
- S  9    W  9   
- q  ?    u  ?   
-   O      O   
-   >      >   
-   Q      Q   
-   K      K   
-            
-        
-          .file         ginffas32.asm      @comp.id     .text             Q          .data                           .debug$S                      .debug$T                                L                          ,              >   0           ^               s   d       $$$00001                    .bf            e    P             .lf     Q     e .ef          e    8                                                                                    e                        X          "            @            V  t          a                          I                  L_dodist                                    U                                              .            F            g            y              ;                        j            $            p                                                                                  (  G          7  Q      L_dolen v          G            T            f  6          u  t            Q                                                /            ]                      "            =            S  4          b  O          p  f                  L_done          invalid_distance_code_msg _inflate_fast inflate_fast_mask invalid_literal_length_code_msg inflate_fast_use_mmx invalid_distance_too_far_msg L_test_for_length_base L_invalid_distance_too_far L_check_dist_one_mmx L_do_copy1_mmx L_wrap_around_window L_do_copy1 L_add_bits_to_len L_do_loop L_invalid_literal_length_code L_get_length_code_mmx L_init_mmx L_test_for_second_level_length L_save_len L_add_bits_to_dist_mmx L_update_next_in L_skip_msg L_get_distance_code L_wrap_around_window_mmx L_do_loop_mmx L_invalid_distance_code L_test_for_second_level_dist L_test_for_end_of_block L_test_for_second_level_dist_mmx L_clip_window_mmx L_dolen_mmx L_use_mmx L_break_loop L_get_length_code L_add_bits_to_dist L_fixup_out L_get_dist_code_mmx L_clip_window inflate_fast_entry L_align_long L_is_aligned L_check_mmx L_dont_use_mmx L_check_mmx_pop L_while_test L_decode_distance L_check_window L_check_dist_one L_contiguous_in_window L_while_test_mmx L_test_for_length_base_mmx L_decode_distance_mmx L_dodist_mmx L_check_window_mmx L_test_for_second_level_length_mmx L_contiguous_in_window_mmx L_update_stream_state L_buf_not_used L_update_hold L_last_is_smaller L_end_is_smaller 
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/masmx86/match686.asm gcc-4.8.1-ppc/zlib/contrib/masmx86/match686.asm
--- gcc-4.8.1/zlib/contrib/masmx86/match686.asm	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/masmx86/match686.asm	1970-01-01 01:00:00.000000000 +0100
@@ -1,479 +0,0 @@
-; match686.asm -- Asm portion of the optimized longest_match for 32 bits x86
-; Copyright (C) 1995-1996 Jean-loup Gailly, Brian Raiter and Gilles Vollant.
-; File written by Gilles Vollant, by converting match686.S from Brian Raiter
-; for MASM. This is as assembly version of longest_match
-;  from Jean-loup Gailly in deflate.c
-;
-;         http://www.zlib.net
-;         http://www.winimage.com/zLibDll
-;         http://www.muppetlabs.com/~breadbox/software/assembly.html
-;
-; For Visual C++ 4.x and higher and ML 6.x and higher
-;   ml.exe is distributed in
-;  http://www.microsoft.com/downloads/details.aspx?FamilyID=7a1c9da0-0510-44a2-b042-7ef370530c64
-;
-; this file contain two implementation of longest_match
-;
-;  this longest_match was written by Brian raiter (1998), optimized for Pentium Pro
-;   (and the faster known version of match_init on modern Core 2 Duo and AMD Phenom)
-;
-;  for using an assembly version of longest_match, you need define ASMV in project
-;
-;    compile the asm file running
-;           ml /coff /Zi /c /Flmatch686.lst match686.asm
-;    and do not include match686.obj in your project
-;
-; note: contrib of zLib 1.2.3 and earlier contained both a deprecated version for
-;  Pentium (prior Pentium Pro) and this version for Pentium Pro and modern processor
-;  with autoselect (with cpu detection code)
-;  if you want support the old pentium optimization, you can still use these version
-;
-; this file is not optimized for old pentium, but it compatible with all x86 32 bits
-; processor (starting 80386)
-;
-;
-; see below : zlib1222add must be adjuster if you use a zlib version < 1.2.2.2
-
-;uInt longest_match(s, cur_match)
-;    deflate_state *s;
-;    IPos cur_match;                             /* current match */
-
-    NbStack         equ     76
-    cur_match       equ     dword ptr[esp+NbStack-0]
-    str_s           equ     dword ptr[esp+NbStack-4]
-; 5 dword on top (ret,ebp,esi,edi,ebx)
-    adrret          equ     dword ptr[esp+NbStack-8]
-    pushebp         equ     dword ptr[esp+NbStack-12]
-    pushedi         equ     dword ptr[esp+NbStack-16]
-    pushesi         equ     dword ptr[esp+NbStack-20]
-    pushebx         equ     dword ptr[esp+NbStack-24]
-
-    chain_length    equ     dword ptr [esp+NbStack-28]
-    limit           equ     dword ptr [esp+NbStack-32]
-    best_len        equ     dword ptr [esp+NbStack-36]
-    window          equ     dword ptr [esp+NbStack-40]
-    prev            equ     dword ptr [esp+NbStack-44]
-    scan_start      equ      word ptr [esp+NbStack-48]
-    wmask           equ     dword ptr [esp+NbStack-52]
-    match_start_ptr equ     dword ptr [esp+NbStack-56]
-    nice_match      equ     dword ptr [esp+NbStack-60]
-    scan            equ     dword ptr [esp+NbStack-64]
-
-    windowlen       equ     dword ptr [esp+NbStack-68]
-    match_start     equ     dword ptr [esp+NbStack-72]
-    strend          equ     dword ptr [esp+NbStack-76]
-    NbStackAdd      equ     (NbStack-24)
-
-    .386p
-
-    name    gvmatch
-    .MODEL  FLAT
-
-
-
-;  all the +zlib1222add offsets are due to the addition of fields
-;  in zlib in the deflate_state structure since the asm code was first written
-;  (if you compile with zlib 1.0.4 or older, use "zlib1222add equ (-4)").
-;  (if you compile with zlib between 1.0.5 and 1.2.2.1, use "zlib1222add equ 0").
-;  if you compile with zlib 1.2.2.2 or later , use "zlib1222add equ 8").
-
-    zlib1222add         equ     8
-
-;  Note : these value are good with a 8 bytes boundary pack structure
-    dep_chain_length    equ     74h+zlib1222add
-    dep_window          equ     30h+zlib1222add
-    dep_strstart        equ     64h+zlib1222add
-    dep_prev_length     equ     70h+zlib1222add
-    dep_nice_match      equ     88h+zlib1222add
-    dep_w_size          equ     24h+zlib1222add
-    dep_prev            equ     38h+zlib1222add
-    dep_w_mask          equ     2ch+zlib1222add
-    dep_good_match      equ     84h+zlib1222add
-    dep_match_start     equ     68h+zlib1222add
-    dep_lookahead       equ     6ch+zlib1222add
-
-
-_TEXT                   segment
-
-IFDEF NOUNDERLINE
-            public  longest_match
-            public  match_init
-ELSE
-            public  _longest_match
-            public  _match_init
-ENDIF
-
-    MAX_MATCH           equ     258
-    MIN_MATCH           equ     3
-    MIN_LOOKAHEAD       equ     (MAX_MATCH+MIN_MATCH+1)
-
-
-
-MAX_MATCH       equ     258
-MIN_MATCH       equ     3
-MIN_LOOKAHEAD   equ     (MAX_MATCH + MIN_MATCH + 1)
-MAX_MATCH_8_     equ     ((MAX_MATCH + 7) AND 0FFF0h)
-
-
-;;; stack frame offsets
-
-chainlenwmask   equ  esp + 0    ; high word: current chain len
-                    ; low word: s->wmask
-window      equ  esp + 4    ; local copy of s->window
-windowbestlen   equ  esp + 8    ; s->window + bestlen
-scanstart   equ  esp + 16   ; first two bytes of string
-scanend     equ  esp + 12   ; last two bytes of string
-scanalign   equ  esp + 20   ; dword-misalignment of string
-nicematch   equ  esp + 24   ; a good enough match size
-bestlen     equ  esp + 28   ; size of best match so far
-scan        equ  esp + 32   ; ptr to string wanting match
-
-LocalVarsSize   equ 36
-;   saved ebx   byte esp + 36
-;   saved edi   byte esp + 40
-;   saved esi   byte esp + 44
-;   saved ebp   byte esp + 48
-;   return address  byte esp + 52
-deflatestate    equ  esp + 56   ; the function arguments
-curmatch    equ  esp + 60
-
-;;; Offsets for fields in the deflate_state structure. These numbers
-;;; are calculated from the definition of deflate_state, with the
-;;; assumption that the compiler will dword-align the fields. (Thus,
-;;; changing the definition of deflate_state could easily cause this
-;;; program to crash horribly, without so much as a warning at
-;;; compile time. Sigh.)
-
-dsWSize     equ 36+zlib1222add
-dsWMask     equ 44+zlib1222add
-dsWindow    equ 48+zlib1222add
-dsPrev      equ 56+zlib1222add
-dsMatchLen  equ 88+zlib1222add
-dsPrevMatch equ 92+zlib1222add
-dsStrStart  equ 100+zlib1222add
-dsMatchStart    equ 104+zlib1222add
-dsLookahead equ 108+zlib1222add
-dsPrevLen   equ 112+zlib1222add
-dsMaxChainLen   equ 116+zlib1222add
-dsGoodMatch equ 132+zlib1222add
-dsNiceMatch equ 136+zlib1222add
-
-
-;;; match686.asm -- Pentium-Pro-optimized version of longest_match()
-;;; Written for zlib 1.1.2
-;;; Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>
-;;; You can look at http://www.muppetlabs.com/~breadbox/software/assembly.html
-;;;
-;;
-;;  This software is provided 'as-is', without any express or implied
-;;  warranty.  In no event will the authors be held liable for any damages
-;;  arising from the use of this software.
-;;
-;;  Permission is granted to anyone to use this software for any purpose,
-;;  including commercial applications, and to alter it and redistribute it
-;;  freely, subject to the following restrictions:
-;;
-;;  1. The origin of this software must not be misrepresented; you must not
-;;     claim that you wrote the original software. If you use this software
-;;     in a product, an acknowledgment in the product documentation would be
-;;     appreciated but is not required.
-;;  2. Altered source versions must be plainly marked as such, and must not be
-;;     misrepresented as being the original software
-;;  3. This notice may not be removed or altered from any source distribution.
-;;
-
-;GLOBAL _longest_match, _match_init
-
-
-;SECTION    .text
-
-;;; uInt longest_match(deflate_state *deflatestate, IPos curmatch)
-
-;_longest_match:
-    IFDEF NOUNDERLINE
-    longest_match       proc near
-    ELSE
-    _longest_match      proc near
-    ENDIF
-.FPO (9, 4, 0, 0, 1, 0)
-
-;;; Save registers that the compiler may be using, and adjust esp to
-;;; make room for our stack frame.
-
-        push    ebp
-        push    edi
-        push    esi
-        push    ebx
-        sub esp, LocalVarsSize
-
-;;; Retrieve the function arguments. ecx will hold cur_match
-;;; throughout the entire function. edx will hold the pointer to the
-;;; deflate_state structure during the function's setup (before
-;;; entering the main loop.
-
-        mov edx, [deflatestate]
-        mov ecx, [curmatch]
-
-;;; uInt wmask = s->w_mask;
-;;; unsigned chain_length = s->max_chain_length;
-;;; if (s->prev_length >= s->good_match) {
-;;;     chain_length >>= 2;
-;;; }
-
-        mov eax, [edx + dsPrevLen]
-        mov ebx, [edx + dsGoodMatch]
-        cmp eax, ebx
-        mov eax, [edx + dsWMask]
-        mov ebx, [edx + dsMaxChainLen]
-        jl  LastMatchGood
-        shr ebx, 2
-LastMatchGood:
-
-;;; chainlen is decremented once beforehand so that the function can
-;;; use the sign flag instead of the zero flag for the exit test.
-;;; It is then shifted into the high word, to make room for the wmask
-;;; value, which it will always accompany.
-
-        dec ebx
-        shl ebx, 16
-        or  ebx, eax
-        mov [chainlenwmask], ebx
-
-;;; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
-
-        mov eax, [edx + dsNiceMatch]
-        mov ebx, [edx + dsLookahead]
-        cmp ebx, eax
-        jl  LookaheadLess
-        mov ebx, eax
-LookaheadLess:  mov [nicematch], ebx
-
-;;; register Bytef *scan = s->window + s->strstart;
-
-        mov esi, [edx + dsWindow]
-        mov [window], esi
-        mov ebp, [edx + dsStrStart]
-        lea edi, [esi + ebp]
-        mov [scan], edi
-
-;;; Determine how many bytes the scan ptr is off from being
-;;; dword-aligned.
-
-        mov eax, edi
-        neg eax
-        and eax, 3
-        mov [scanalign], eax
-
-;;; IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
-;;;     s->strstart - (IPos)MAX_DIST(s) : NIL;
-
-        mov eax, [edx + dsWSize]
-        sub eax, MIN_LOOKAHEAD
-        sub ebp, eax
-        jg  LimitPositive
-        xor ebp, ebp
-LimitPositive:
-
-;;; int best_len = s->prev_length;
-
-        mov eax, [edx + dsPrevLen]
-        mov [bestlen], eax
-
-;;; Store the sum of s->window + best_len in esi locally, and in esi.
-
-        add esi, eax
-        mov [windowbestlen], esi
-
-;;; register ush scan_start = *(ushf*)scan;
-;;; register ush scan_end   = *(ushf*)(scan+best_len-1);
-;;; Posf *prev = s->prev;
-
-        movzx   ebx, word ptr [edi]
-        mov [scanstart], ebx
-        movzx   ebx, word ptr [edi + eax - 1]
-        mov [scanend], ebx
-        mov edi, [edx + dsPrev]
-
-;;; Jump into the main loop.
-
-        mov edx, [chainlenwmask]
-        jmp short LoopEntry
-
-align 4
-
-;;; do {
-;;;     match = s->window + cur_match;
-;;;     if (*(ushf*)(match+best_len-1) != scan_end ||
-;;;         *(ushf*)match != scan_start) continue;
-;;;     [...]
-;;; } while ((cur_match = prev[cur_match & wmask]) > limit
-;;;          && --chain_length != 0);
-;;;
-;;; Here is the inner loop of the function. The function will spend the
-;;; majority of its time in this loop, and majority of that time will
-;;; be spent in the first ten instructions.
-;;;
-;;; Within this loop:
-;;; ebx = scanend
-;;; ecx = curmatch
-;;; edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)
-;;; esi = windowbestlen - i.e., (window + bestlen)
-;;; edi = prev
-;;; ebp = limit
-
-LookupLoop:
-        and ecx, edx
-        movzx   ecx, word ptr [edi + ecx*2]
-        cmp ecx, ebp
-        jbe LeaveNow
-        sub edx, 00010000h
-        js  LeaveNow
-LoopEntry:  movzx   eax, word ptr [esi + ecx - 1]
-        cmp eax, ebx
-        jnz LookupLoop
-        mov eax, [window]
-        movzx   eax, word ptr [eax + ecx]
-        cmp eax, [scanstart]
-        jnz LookupLoop
-
-;;; Store the current value of chainlen.
-
-        mov [chainlenwmask], edx
-
-;;; Point edi to the string under scrutiny, and esi to the string we
-;;; are hoping to match it up with. In actuality, esi and edi are
-;;; both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and edx is
-;;; initialized to -(MAX_MATCH_8 - scanalign).
-
-        mov esi, [window]
-        mov edi, [scan]
-        add esi, ecx
-        mov eax, [scanalign]
-        mov edx, 0fffffef8h; -(MAX_MATCH_8)
-        lea edi, [edi + eax + 0108h] ;MAX_MATCH_8]
-        lea esi, [esi + eax + 0108h] ;MAX_MATCH_8]
-
-;;; Test the strings for equality, 8 bytes at a time. At the end,
-;;; adjust edx so that it is offset to the exact byte that mismatched.
-;;;
-;;; We already know at this point that the first three bytes of the
-;;; strings match each other, and they can be safely passed over before
-;;; starting the compare loop. So what this code does is skip over 0-3
-;;; bytes, as much as necessary in order to dword-align the edi
-;;; pointer. (esi will still be misaligned three times out of four.)
-;;;
-;;; It should be confessed that this loop usually does not represent
-;;; much of the total running time. Replacing it with a more
-;;; straightforward "rep cmpsb" would not drastically degrade
-;;; performance.
-
-LoopCmps:
-        mov eax, [esi + edx]
-        xor eax, [edi + edx]
-        jnz LeaveLoopCmps
-        mov eax, [esi + edx + 4]
-        xor eax, [edi + edx + 4]
-        jnz LeaveLoopCmps4
-        add edx, 8
-        jnz LoopCmps
-        jmp short LenMaximum
-LeaveLoopCmps4: add edx, 4
-LeaveLoopCmps:  test    eax, 0000FFFFh
-        jnz LenLower
-        add edx,  2
-        shr eax, 16
-LenLower:   sub al, 1
-        adc edx, 0
-
-;;; Calculate the length of the match. If it is longer than MAX_MATCH,
-;;; then automatically accept it as the best possible match and leave.
-
-        lea eax, [edi + edx]
-        mov edi, [scan]
-        sub eax, edi
-        cmp eax, MAX_MATCH
-        jge LenMaximum
-
-;;; If the length of the match is not longer than the best match we
-;;; have so far, then forget it and return to the lookup loop.
-
-        mov edx, [deflatestate]
-        mov ebx, [bestlen]
-        cmp eax, ebx
-        jg  LongerMatch
-        mov esi, [windowbestlen]
-        mov edi, [edx + dsPrev]
-        mov ebx, [scanend]
-        mov edx, [chainlenwmask]
-        jmp LookupLoop
-
-;;;         s->match_start = cur_match;
-;;;         best_len = len;
-;;;         if (len >= nice_match) break;
-;;;         scan_end = *(ushf*)(scan+best_len-1);
-
-LongerMatch:    mov ebx, [nicematch]
-        mov [bestlen], eax
-        mov [edx + dsMatchStart], ecx
-        cmp eax, ebx
-        jge LeaveNow
-        mov esi, [window]
-        add esi, eax
-        mov [windowbestlen], esi
-        movzx   ebx, word ptr [edi + eax - 1]
-        mov edi, [edx + dsPrev]
-        mov [scanend], ebx
-        mov edx, [chainlenwmask]
-        jmp LookupLoop
-
-;;; Accept the current string, with the maximum possible length.
-
-LenMaximum: mov edx, [deflatestate]
-        mov dword ptr [bestlen], MAX_MATCH
-        mov [edx + dsMatchStart], ecx
-
-;;; if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
-;;; return s->lookahead;
-
-LeaveNow:
-        mov edx, [deflatestate]
-        mov ebx, [bestlen]
-        mov eax, [edx + dsLookahead]
-        cmp ebx, eax
-        jg  LookaheadRet
-        mov eax, ebx
-LookaheadRet:
-
-;;; Restore the stack and return from whence we came.
-
-        add esp, LocalVarsSize
-        pop ebx
-        pop esi
-        pop edi
-        pop ebp
-
-        ret
-; please don't remove this string !
-; Your can freely use match686 in any free or commercial app if you don't remove the string in the binary!
-    db     0dh,0ah,"asm686 with masm, optimised assembly code from Brian Raiter, written 1998",0dh,0ah
-
-
-    IFDEF NOUNDERLINE
-    longest_match       endp
-    ELSE
-    _longest_match      endp
-    ENDIF
-
-    IFDEF NOUNDERLINE
-    match_init      proc near
-                    ret
-    match_init      endp
-    ELSE
-    _match_init     proc near
-                    ret
-    _match_init     endp
-    ENDIF
-
-
-_TEXT   ends
-end
diff -Nbaur gcc-4.8.1/zlib/contrib/masmx86/readme.txt gcc-4.8.1-ppc/zlib/contrib/masmx86/readme.txt
--- gcc-4.8.1/zlib/contrib/masmx86/readme.txt	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/masmx86/readme.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,27 +0,0 @@
-
-Summary
--------
-This directory contains ASM implementations of the functions
-longest_match() and inflate_fast().
-
-
-Use instructions
-----------------
-Assemble using MASM, and copy the object files into the zlib source
-directory, then run the appropriate makefile, as suggested below.  You can
-donwload MASM from here:
-
-    http://www.microsoft.com/downloads/details.aspx?displaylang=en&FamilyID=7a1c9da0-0510-44a2-b042-7ef370530c64
-
-You can also get objects files here:
-
-    http://www.winimage.com/zLibDll/zlib124_masm_obj.zip
-
-Build instructions
-------------------
-* With Microsoft C and MASM:
-nmake -f win32/Makefile.msc LOC="-DASMV -DASMINF" OBJA="match686.obj inffas32.obj"
-
-* With Borland C and TASM:
-make -f win32/Makefile.bor LOCAL_ZLIB="-DASMV -DASMINF" OBJA="match686.obj inffas32.obj" OBJPA="+match686c.obj+match686.obj+inffas32.obj"
-
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/configure.ac gcc-4.8.1-ppc/zlib/contrib/minizip/configure.ac
--- gcc-4.8.1/zlib/contrib/minizip/configure.ac	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/configure.ac	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-#                                               -*- Autoconf -*-
-# Process this file with autoconf to produce a configure script.
-
-AC_INIT([minizip], [1.2.7], [bugzilla.redhat.com])
-AC_CONFIG_SRCDIR([minizip.c])
-AM_INIT_AUTOMAKE([foreign])
-LT_INIT
-
-AC_MSG_CHECKING([whether to build example programs])
-AC_ARG_ENABLE([demos], AC_HELP_STRING([--enable-demos], [build example programs]))
-AM_CONDITIONAL([COND_DEMOS], [test "$enable_demos" = yes])
-if test "$enable_demos" = yes
-then
-	AC_MSG_RESULT([yes])
-else
-	AC_MSG_RESULT([no])
-fi
-
-case "${host}" in
-	*-mingw* | mingw*)
-		WIN32="yes"
-		;;
-	*)
-		;;
-esac
-AM_CONDITIONAL([WIN32], [test "${WIN32}" = "yes"])
-
-
-AC_SUBST([HAVE_UNISTD_H], [0])
-AC_CHECK_HEADER([unistd.h], [HAVE_UNISTD_H=1], [])
-AC_CONFIG_FILES([Makefile minizip.pc])
-AC_OUTPUT
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/crypt.h gcc-4.8.1-ppc/zlib/contrib/minizip/crypt.h
--- gcc-4.8.1/zlib/contrib/minizip/crypt.h	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/crypt.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,131 +0,0 @@
-/* crypt.h -- base code for crypt/uncrypt ZIPfile
-
-
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-
-   This code is a modified version of crypting code in Infozip distribution
-
-   The encryption/decryption parts of this source code (as opposed to the
-   non-echoing password parts) were originally written in Europe.  The
-   whole source package can be freely distributed, including from the USA.
-   (Prior to January 2000, re-export from the US was a violation of US law.)
-
-   This encryption code is a direct transcription of the algorithm from
-   Roger Schlafly, described by Phil Katz in the file appnote.txt.  This
-   file (appnote.txt) is distributed with the PKZIP program (even in the
-   version without encryption capabilities).
-
-   If you don't need crypting in your application, just define symbols
-   NOCRYPT and NOUNCRYPT.
-
-   This code support the "Traditional PKWARE Encryption".
-
-   The new AES encryption added on Zip format by Winzip (see the page
-   http://www.winzip.com/aes_info.htm ) and PKWare PKZip 5.x Strong
-   Encryption is not supported.
-*/
-
-#define CRC32(c, b) ((*(pcrc_32_tab+(((int)(c) ^ (b)) & 0xff))) ^ ((c) >> 8))
-
-/***********************************************************************
- * Return the next byte in the pseudo-random sequence
- */
-static int decrypt_byte(unsigned long* pkeys, const unsigned long* pcrc_32_tab)
-{
-    unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an
-                     * unpredictable manner on 16-bit systems; not a problem
-                     * with any known compiler so far, though */
-
-    temp = ((unsigned)(*(pkeys+2)) & 0xffff) | 2;
-    return (int)(((temp * (temp ^ 1)) >> 8) & 0xff);
-}
-
-/***********************************************************************
- * Update the encryption keys with the next byte of plain text
- */
-static int update_keys(unsigned long* pkeys,const unsigned long* pcrc_32_tab,int c)
-{
-    (*(pkeys+0)) = CRC32((*(pkeys+0)), c);
-    (*(pkeys+1)) += (*(pkeys+0)) & 0xff;
-    (*(pkeys+1)) = (*(pkeys+1)) * 134775813L + 1;
-    {
-      register int keyshift = (int)((*(pkeys+1)) >> 24);
-      (*(pkeys+2)) = CRC32((*(pkeys+2)), keyshift);
-    }
-    return c;
-}
-
-
-/***********************************************************************
- * Initialize the encryption keys and the random header according to
- * the given password.
- */
-static void init_keys(const char* passwd,unsigned long* pkeys,const unsigned long* pcrc_32_tab)
-{
-    *(pkeys+0) = 305419896L;
-    *(pkeys+1) = 591751049L;
-    *(pkeys+2) = 878082192L;
-    while (*passwd != '\0') {
-        update_keys(pkeys,pcrc_32_tab,(int)*passwd);
-        passwd++;
-    }
-}
-
-#define zdecode(pkeys,pcrc_32_tab,c) \
-    (update_keys(pkeys,pcrc_32_tab,c ^= decrypt_byte(pkeys,pcrc_32_tab)))
-
-#define zencode(pkeys,pcrc_32_tab,c,t) \
-    (t=decrypt_byte(pkeys,pcrc_32_tab), update_keys(pkeys,pcrc_32_tab,c), t^(c))
-
-#ifdef INCLUDECRYPTINGCODE_IFCRYPTALLOWED
-
-#define RAND_HEAD_LEN  12
-   /* "last resort" source for second part of crypt seed pattern */
-#  ifndef ZCR_SEED2
-#    define ZCR_SEED2 3141592654UL     /* use PI as default pattern */
-#  endif
-
-static int crypthead(const char* passwd,      /* password string */
-                     unsigned char* buf,      /* where to write header */
-                     int bufSize,
-                     unsigned long* pkeys,
-                     const unsigned long* pcrc_32_tab,
-                     unsigned long crcForCrypting)
-{
-    int n;                       /* index in random header */
-    int t;                       /* temporary */
-    int c;                       /* random byte */
-    unsigned char header[RAND_HEAD_LEN-2]; /* random header */
-    static unsigned calls = 0;   /* ensure different random header each time */
-
-    if (bufSize<RAND_HEAD_LEN)
-      return 0;
-
-    /* First generate RAND_HEAD_LEN-2 random bytes. We encrypt the
-     * output of rand() to get less predictability, since rand() is
-     * often poorly implemented.
-     */
-    if (++calls == 1)
-    {
-        srand((unsigned)(time(NULL) ^ ZCR_SEED2));
-    }
-    init_keys(passwd, pkeys, pcrc_32_tab);
-    for (n = 0; n < RAND_HEAD_LEN-2; n++)
-    {
-        c = (rand() >> 7) & 0xff;
-        header[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, c, t);
-    }
-    /* Encrypt random header (last two bytes is high word of crc) */
-    init_keys(passwd, pkeys, pcrc_32_tab);
-    for (n = 0; n < RAND_HEAD_LEN-2; n++)
-    {
-        buf[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, header[n], t);
-    }
-    buf[n++] = (unsigned char)zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 16) & 0xff, t);
-    buf[n++] = (unsigned char)zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 24) & 0xff, t);
-    return n;
-}
-
-#endif
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/ioapi.c gcc-4.8.1-ppc/zlib/contrib/minizip/ioapi.c
--- gcc-4.8.1/zlib/contrib/minizip/ioapi.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/ioapi.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,247 +0,0 @@
-/* ioapi.h -- IO base function header for compress/uncompress .zip
-   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications for Zip64 support
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-         For more info read MiniZip_info.txt
-
-*/
-
-#if defined(_WIN32) && (!(defined(_CRT_SECURE_NO_WARNINGS)))
-        #define _CRT_SECURE_NO_WARNINGS
-#endif
-
-#if defined(__APPLE__) || defined(IOAPI_NO_64)
-// In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
-#define FOPEN_FUNC(filename, mode) fopen(filename, mode)
-#define FTELLO_FUNC(stream) ftello(stream)
-#define FSEEKO_FUNC(stream, offset, origin) fseeko(stream, offset, origin)
-#else
-#define FOPEN_FUNC(filename, mode) fopen64(filename, mode)
-#define FTELLO_FUNC(stream) ftello64(stream)
-#define FSEEKO_FUNC(stream, offset, origin) fseeko64(stream, offset, origin)
-#endif
-
-
-#include "ioapi.h"
-
-voidpf call_zopen64 (const zlib_filefunc64_32_def* pfilefunc,const void*filename,int mode)
-{
-    if (pfilefunc->zfile_func64.zopen64_file != NULL)
-        return (*(pfilefunc->zfile_func64.zopen64_file)) (pfilefunc->zfile_func64.opaque,filename,mode);
-    else
-    {
-        return (*(pfilefunc->zopen32_file))(pfilefunc->zfile_func64.opaque,(const char*)filename,mode);
-    }
-}
-
-long call_zseek64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin)
-{
-    if (pfilefunc->zfile_func64.zseek64_file != NULL)
-        return (*(pfilefunc->zfile_func64.zseek64_file)) (pfilefunc->zfile_func64.opaque,filestream,offset,origin);
-    else
-    {
-        uLong offsetTruncated = (uLong)offset;
-        if (offsetTruncated != offset)
-            return -1;
-        else
-            return (*(pfilefunc->zseek32_file))(pfilefunc->zfile_func64.opaque,filestream,offsetTruncated,origin);
-    }
-}
-
-ZPOS64_T call_ztell64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream)
-{
-    if (pfilefunc->zfile_func64.zseek64_file != NULL)
-        return (*(pfilefunc->zfile_func64.ztell64_file)) (pfilefunc->zfile_func64.opaque,filestream);
-    else
-    {
-        uLong tell_uLong = (*(pfilefunc->ztell32_file))(pfilefunc->zfile_func64.opaque,filestream);
-        if ((tell_uLong) == MAXU32)
-            return (ZPOS64_T)-1;
-        else
-            return tell_uLong;
-    }
-}
-
-void fill_zlib_filefunc64_32_def_from_filefunc32(zlib_filefunc64_32_def* p_filefunc64_32,const zlib_filefunc_def* p_filefunc32)
-{
-    p_filefunc64_32->zfile_func64.zopen64_file = NULL;
-    p_filefunc64_32->zopen32_file = p_filefunc32->zopen_file;
-    p_filefunc64_32->zfile_func64.zerror_file = p_filefunc32->zerror_file;
-    p_filefunc64_32->zfile_func64.zread_file = p_filefunc32->zread_file;
-    p_filefunc64_32->zfile_func64.zwrite_file = p_filefunc32->zwrite_file;
-    p_filefunc64_32->zfile_func64.ztell64_file = NULL;
-    p_filefunc64_32->zfile_func64.zseek64_file = NULL;
-    p_filefunc64_32->zfile_func64.zclose_file = p_filefunc32->zclose_file;
-    p_filefunc64_32->zfile_func64.zerror_file = p_filefunc32->zerror_file;
-    p_filefunc64_32->zfile_func64.opaque = p_filefunc32->opaque;
-    p_filefunc64_32->zseek32_file = p_filefunc32->zseek_file;
-    p_filefunc64_32->ztell32_file = p_filefunc32->ztell_file;
-}
-
-
-
-static voidpf  ZCALLBACK fopen_file_func OF((voidpf opaque, const char* filename, int mode));
-static uLong   ZCALLBACK fread_file_func OF((voidpf opaque, voidpf stream, void* buf, uLong size));
-static uLong   ZCALLBACK fwrite_file_func OF((voidpf opaque, voidpf stream, const void* buf,uLong size));
-static ZPOS64_T ZCALLBACK ftell64_file_func OF((voidpf opaque, voidpf stream));
-static long    ZCALLBACK fseek64_file_func OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
-static int     ZCALLBACK fclose_file_func OF((voidpf opaque, voidpf stream));
-static int     ZCALLBACK ferror_file_func OF((voidpf opaque, voidpf stream));
-
-static voidpf ZCALLBACK fopen_file_func (voidpf opaque, const char* filename, int mode)
-{
-    FILE* file = NULL;
-    const char* mode_fopen = NULL;
-    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)
-        mode_fopen = "rb";
-    else
-    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
-        mode_fopen = "r+b";
-    else
-    if (mode & ZLIB_FILEFUNC_MODE_CREATE)
-        mode_fopen = "wb";
-
-    if ((filename!=NULL) && (mode_fopen != NULL))
-        file = fopen(filename, mode_fopen);
-    return file;
-}
-
-static voidpf ZCALLBACK fopen64_file_func (voidpf opaque, const void* filename, int mode)
-{
-    FILE* file = NULL;
-    const char* mode_fopen = NULL;
-    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)
-        mode_fopen = "rb";
-    else
-    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
-        mode_fopen = "r+b";
-    else
-    if (mode & ZLIB_FILEFUNC_MODE_CREATE)
-        mode_fopen = "wb";
-
-    if ((filename!=NULL) && (mode_fopen != NULL))
-        file = FOPEN_FUNC((const char*)filename, mode_fopen);
-    return file;
-}
-
-
-static uLong ZCALLBACK fread_file_func (voidpf opaque, voidpf stream, void* buf, uLong size)
-{
-    uLong ret;
-    ret = (uLong)fread(buf, 1, (size_t)size, (FILE *)stream);
-    return ret;
-}
-
-static uLong ZCALLBACK fwrite_file_func (voidpf opaque, voidpf stream, const void* buf, uLong size)
-{
-    uLong ret;
-    ret = (uLong)fwrite(buf, 1, (size_t)size, (FILE *)stream);
-    return ret;
-}
-
-static long ZCALLBACK ftell_file_func (voidpf opaque, voidpf stream)
-{
-    long ret;
-    ret = ftell((FILE *)stream);
-    return ret;
-}
-
-
-static ZPOS64_T ZCALLBACK ftell64_file_func (voidpf opaque, voidpf stream)
-{
-    ZPOS64_T ret;
-    ret = FTELLO_FUNC((FILE *)stream);
-    return ret;
-}
-
-static long ZCALLBACK fseek_file_func (voidpf  opaque, voidpf stream, uLong offset, int origin)
-{
-    int fseek_origin=0;
-    long ret;
-    switch (origin)
-    {
-    case ZLIB_FILEFUNC_SEEK_CUR :
-        fseek_origin = SEEK_CUR;
-        break;
-    case ZLIB_FILEFUNC_SEEK_END :
-        fseek_origin = SEEK_END;
-        break;
-    case ZLIB_FILEFUNC_SEEK_SET :
-        fseek_origin = SEEK_SET;
-        break;
-    default: return -1;
-    }
-    ret = 0;
-    if (fseek((FILE *)stream, offset, fseek_origin) != 0)
-        ret = -1;
-    return ret;
-}
-
-static long ZCALLBACK fseek64_file_func (voidpf  opaque, voidpf stream, ZPOS64_T offset, int origin)
-{
-    int fseek_origin=0;
-    long ret;
-    switch (origin)
-    {
-    case ZLIB_FILEFUNC_SEEK_CUR :
-        fseek_origin = SEEK_CUR;
-        break;
-    case ZLIB_FILEFUNC_SEEK_END :
-        fseek_origin = SEEK_END;
-        break;
-    case ZLIB_FILEFUNC_SEEK_SET :
-        fseek_origin = SEEK_SET;
-        break;
-    default: return -1;
-    }
-    ret = 0;
-
-    if(FSEEKO_FUNC((FILE *)stream, offset, fseek_origin) != 0)
-                        ret = -1;
-
-    return ret;
-}
-
-
-static int ZCALLBACK fclose_file_func (voidpf opaque, voidpf stream)
-{
-    int ret;
-    ret = fclose((FILE *)stream);
-    return ret;
-}
-
-static int ZCALLBACK ferror_file_func (voidpf opaque, voidpf stream)
-{
-    int ret;
-    ret = ferror((FILE *)stream);
-    return ret;
-}
-
-void fill_fopen_filefunc (pzlib_filefunc_def)
-  zlib_filefunc_def* pzlib_filefunc_def;
-{
-    pzlib_filefunc_def->zopen_file = fopen_file_func;
-    pzlib_filefunc_def->zread_file = fread_file_func;
-    pzlib_filefunc_def->zwrite_file = fwrite_file_func;
-    pzlib_filefunc_def->ztell_file = ftell_file_func;
-    pzlib_filefunc_def->zseek_file = fseek_file_func;
-    pzlib_filefunc_def->zclose_file = fclose_file_func;
-    pzlib_filefunc_def->zerror_file = ferror_file_func;
-    pzlib_filefunc_def->opaque = NULL;
-}
-
-void fill_fopen64_filefunc (zlib_filefunc64_def*  pzlib_filefunc_def)
-{
-    pzlib_filefunc_def->zopen64_file = fopen64_file_func;
-    pzlib_filefunc_def->zread_file = fread_file_func;
-    pzlib_filefunc_def->zwrite_file = fwrite_file_func;
-    pzlib_filefunc_def->ztell64_file = ftell64_file_func;
-    pzlib_filefunc_def->zseek64_file = fseek64_file_func;
-    pzlib_filefunc_def->zclose_file = fclose_file_func;
-    pzlib_filefunc_def->zerror_file = ferror_file_func;
-    pzlib_filefunc_def->opaque = NULL;
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/ioapi.h gcc-4.8.1-ppc/zlib/contrib/minizip/ioapi.h
--- gcc-4.8.1/zlib/contrib/minizip/ioapi.h	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/ioapi.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,208 +0,0 @@
-/* ioapi.h -- IO base function header for compress/uncompress .zip
-   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications for Zip64 support
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-         For more info read MiniZip_info.txt
-
-         Changes
-
-    Oct-2009 - Defined ZPOS64_T to fpos_t on windows and u_int64_t on linux. (might need to find a better why for this)
-    Oct-2009 - Change to fseeko64, ftello64 and fopen64 so large files would work on linux.
-               More if/def section may be needed to support other platforms
-    Oct-2009 - Defined fxxxx64 calls to normal fopen/ftell/fseek so they would compile on windows.
-                          (but you should use iowin32.c for windows instead)
-
-*/
-
-#ifndef _ZLIBIOAPI64_H
-#define _ZLIBIOAPI64_H
-
-#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__))
-
-  // Linux needs this to support file operation on files larger then 4+GB
-  // But might need better if/def to select just the platforms that needs them.
-
-        #ifndef __USE_FILE_OFFSET64
-                #define __USE_FILE_OFFSET64
-        #endif
-        #ifndef __USE_LARGEFILE64
-                #define __USE_LARGEFILE64
-        #endif
-        #ifndef _LARGEFILE64_SOURCE
-                #define _LARGEFILE64_SOURCE
-        #endif
-        #ifndef _FILE_OFFSET_BIT
-                #define _FILE_OFFSET_BIT 64
-        #endif
-
-#endif
-
-#include <stdio.h>
-#include <stdlib.h>
-#include "zlib.h"
-
-#if defined(USE_FILE32API)
-#define fopen64 fopen
-#define ftello64 ftell
-#define fseeko64 fseek
-#else
-#ifdef __FreeBSD__
-#define fopen64 fopen
-#define ftello64 ftello
-#define fseeko64 fseeko
-#endif
-#ifdef _MSC_VER
- #define fopen64 fopen
- #if (_MSC_VER >= 1400) && (!(defined(NO_MSCVER_FILE64_FUNC)))
-  #define ftello64 _ftelli64
-  #define fseeko64 _fseeki64
- #else // old MSC
-  #define ftello64 ftell
-  #define fseeko64 fseek
- #endif
-#endif
-#endif
-
-/*
-#ifndef ZPOS64_T
-  #ifdef _WIN32
-                #define ZPOS64_T fpos_t
-  #else
-    #include <stdint.h>
-    #define ZPOS64_T uint64_t
-  #endif
-#endif
-*/
-
-#ifdef HAVE_MINIZIP64_CONF_H
-#include "mz64conf.h"
-#endif
-
-/* a type choosen by DEFINE */
-#ifdef HAVE_64BIT_INT_CUSTOM
-typedef  64BIT_INT_CUSTOM_TYPE ZPOS64_T;
-#else
-#ifdef HAS_STDINT_H
-#include "stdint.h"
-typedef uint64_t ZPOS64_T;
-#else
-
-/* Maximum unsigned 32-bit value used as placeholder for zip64 */
-#define MAXU32 0xffffffff
-
-#if defined(_MSC_VER) || defined(__BORLANDC__)
-typedef unsigned __int64 ZPOS64_T;
-#else
-typedef unsigned long long int ZPOS64_T;
-#endif
-#endif
-#endif
-
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-#define ZLIB_FILEFUNC_SEEK_CUR (1)
-#define ZLIB_FILEFUNC_SEEK_END (2)
-#define ZLIB_FILEFUNC_SEEK_SET (0)
-
-#define ZLIB_FILEFUNC_MODE_READ      (1)
-#define ZLIB_FILEFUNC_MODE_WRITE     (2)
-#define ZLIB_FILEFUNC_MODE_READWRITEFILTER (3)
-
-#define ZLIB_FILEFUNC_MODE_EXISTING (4)
-#define ZLIB_FILEFUNC_MODE_CREATE   (8)
-
-
-#ifndef ZCALLBACK
- #if (defined(WIN32) || defined(_WIN32) || defined (WINDOWS) || defined (_WINDOWS)) && defined(CALLBACK) && defined (USEWINDOWS_CALLBACK)
-   #define ZCALLBACK CALLBACK
- #else
-   #define ZCALLBACK
- #endif
-#endif
-
-
-
-
-typedef voidpf   (ZCALLBACK *open_file_func)      OF((voidpf opaque, const char* filename, int mode));
-typedef uLong    (ZCALLBACK *read_file_func)      OF((voidpf opaque, voidpf stream, void* buf, uLong size));
-typedef uLong    (ZCALLBACK *write_file_func)     OF((voidpf opaque, voidpf stream, const void* buf, uLong size));
-typedef int      (ZCALLBACK *close_file_func)     OF((voidpf opaque, voidpf stream));
-typedef int      (ZCALLBACK *testerror_file_func) OF((voidpf opaque, voidpf stream));
-
-typedef long     (ZCALLBACK *tell_file_func)      OF((voidpf opaque, voidpf stream));
-typedef long     (ZCALLBACK *seek_file_func)      OF((voidpf opaque, voidpf stream, uLong offset, int origin));
-
-
-/* here is the "old" 32 bits structure structure */
-typedef struct zlib_filefunc_def_s
-{
-    open_file_func      zopen_file;
-    read_file_func      zread_file;
-    write_file_func     zwrite_file;
-    tell_file_func      ztell_file;
-    seek_file_func      zseek_file;
-    close_file_func     zclose_file;
-    testerror_file_func zerror_file;
-    voidpf              opaque;
-} zlib_filefunc_def;
-
-typedef ZPOS64_T (ZCALLBACK *tell64_file_func)    OF((voidpf opaque, voidpf stream));
-typedef long     (ZCALLBACK *seek64_file_func)    OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
-typedef voidpf   (ZCALLBACK *open64_file_func)    OF((voidpf opaque, const void* filename, int mode));
-
-typedef struct zlib_filefunc64_def_s
-{
-    open64_file_func    zopen64_file;
-    read_file_func      zread_file;
-    write_file_func     zwrite_file;
-    tell64_file_func    ztell64_file;
-    seek64_file_func    zseek64_file;
-    close_file_func     zclose_file;
-    testerror_file_func zerror_file;
-    voidpf              opaque;
-} zlib_filefunc64_def;
-
-void fill_fopen64_filefunc OF((zlib_filefunc64_def* pzlib_filefunc_def));
-void fill_fopen_filefunc OF((zlib_filefunc_def* pzlib_filefunc_def));
-
-/* now internal definition, only for zip.c and unzip.h */
-typedef struct zlib_filefunc64_32_def_s
-{
-    zlib_filefunc64_def zfile_func64;
-    open_file_func      zopen32_file;
-    tell_file_func      ztell32_file;
-    seek_file_func      zseek32_file;
-} zlib_filefunc64_32_def;
-
-
-#define ZREAD64(filefunc,filestream,buf,size)     ((*((filefunc).zfile_func64.zread_file))   ((filefunc).zfile_func64.opaque,filestream,buf,size))
-#define ZWRITE64(filefunc,filestream,buf,size)    ((*((filefunc).zfile_func64.zwrite_file))  ((filefunc).zfile_func64.opaque,filestream,buf,size))
-//#define ZTELL64(filefunc,filestream)            ((*((filefunc).ztell64_file)) ((filefunc).opaque,filestream))
-//#define ZSEEK64(filefunc,filestream,pos,mode)   ((*((filefunc).zseek64_file)) ((filefunc).opaque,filestream,pos,mode))
-#define ZCLOSE64(filefunc,filestream)             ((*((filefunc).zfile_func64.zclose_file))  ((filefunc).zfile_func64.opaque,filestream))
-#define ZERROR64(filefunc,filestream)             ((*((filefunc).zfile_func64.zerror_file))  ((filefunc).zfile_func64.opaque,filestream))
-
-voidpf call_zopen64 OF((const zlib_filefunc64_32_def* pfilefunc,const void*filename,int mode));
-long    call_zseek64 OF((const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin));
-ZPOS64_T call_ztell64 OF((const zlib_filefunc64_32_def* pfilefunc,voidpf filestream));
-
-void    fill_zlib_filefunc64_32_def_from_filefunc32(zlib_filefunc64_32_def* p_filefunc64_32,const zlib_filefunc_def* p_filefunc32);
-
-#define ZOPEN64(filefunc,filename,mode)         (call_zopen64((&(filefunc)),(filename),(mode)))
-#define ZTELL64(filefunc,filestream)            (call_ztell64((&(filefunc)),(filestream)))
-#define ZSEEK64(filefunc,filestream,pos,mode)   (call_zseek64((&(filefunc)),(filestream),(pos),(mode)))
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/iowin32.c gcc-4.8.1-ppc/zlib/contrib/minizip/iowin32.c
--- gcc-4.8.1/zlib/contrib/minizip/iowin32.c	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/iowin32.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,389 +0,0 @@
-/* iowin32.c -- IO base function header for compress/uncompress .zip
-     Version 1.1, February 14h, 2010
-     part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications for Zip64 support
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-     For more info read MiniZip_info.txt
-
-*/
-
-#include <stdlib.h>
-
-#include "zlib.h"
-#include "ioapi.h"
-#include "iowin32.h"
-
-#ifndef INVALID_HANDLE_VALUE
-#define INVALID_HANDLE_VALUE (0xFFFFFFFF)
-#endif
-
-#ifndef INVALID_SET_FILE_POINTER
-#define INVALID_SET_FILE_POINTER ((DWORD)-1)
-#endif
-
-voidpf  ZCALLBACK win32_open_file_func  OF((voidpf opaque, const char* filename, int mode));
-uLong   ZCALLBACK win32_read_file_func  OF((voidpf opaque, voidpf stream, void* buf, uLong size));
-uLong   ZCALLBACK win32_write_file_func OF((voidpf opaque, voidpf stream, const void* buf, uLong size));
-ZPOS64_T ZCALLBACK win32_tell64_file_func  OF((voidpf opaque, voidpf stream));
-long    ZCALLBACK win32_seek64_file_func  OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
-int     ZCALLBACK win32_close_file_func OF((voidpf opaque, voidpf stream));
-int     ZCALLBACK win32_error_file_func OF((voidpf opaque, voidpf stream));
-
-typedef struct
-{
-    HANDLE hf;
-    int error;
-} WIN32FILE_IOWIN;
-
-
-static void win32_translate_open_mode(int mode,
-                                      DWORD* lpdwDesiredAccess,
-                                      DWORD* lpdwCreationDisposition,
-                                      DWORD* lpdwShareMode,
-                                      DWORD* lpdwFlagsAndAttributes)
-{
-    *lpdwDesiredAccess = *lpdwShareMode = *lpdwFlagsAndAttributes = *lpdwCreationDisposition = 0;
-
-    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)
-    {
-        *lpdwDesiredAccess = GENERIC_READ;
-        *lpdwCreationDisposition = OPEN_EXISTING;
-        *lpdwShareMode = FILE_SHARE_READ;
-    }
-    else if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
-    {
-        *lpdwDesiredAccess = GENERIC_WRITE | GENERIC_READ;
-        *lpdwCreationDisposition = OPEN_EXISTING;
-    }
-    else if (mode & ZLIB_FILEFUNC_MODE_CREATE)
-    {
-        *lpdwDesiredAccess = GENERIC_WRITE | GENERIC_READ;
-        *lpdwCreationDisposition = CREATE_ALWAYS;
-    }
-}
-
-static voidpf win32_build_iowin(HANDLE hFile)
-{
-    voidpf ret=NULL;
-
-    if ((hFile != NULL) && (hFile != INVALID_HANDLE_VALUE))
-    {
-        WIN32FILE_IOWIN w32fiow;
-        w32fiow.hf = hFile;
-        w32fiow.error = 0;
-        ret = malloc(sizeof(WIN32FILE_IOWIN));
-
-        if (ret==NULL)
-            CloseHandle(hFile);
-        else
-            *((WIN32FILE_IOWIN*)ret) = w32fiow;
-    }
-    return ret;
-}
-
-voidpf ZCALLBACK win32_open64_file_func (voidpf opaque,const void* filename,int mode)
-{
-    const char* mode_fopen = NULL;
-    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;
-    HANDLE hFile = NULL;
-
-    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);
-
-    if ((filename!=NULL) && (dwDesiredAccess != 0))
-        hFile = CreateFile((LPCTSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);
-
-    return win32_build_iowin(hFile);
-}
-
-
-voidpf ZCALLBACK win32_open64_file_funcA (voidpf opaque,const void* filename,int mode)
-{
-    const char* mode_fopen = NULL;
-    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;
-    HANDLE hFile = NULL;
-
-    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);
-
-    if ((filename!=NULL) && (dwDesiredAccess != 0))
-        hFile = CreateFileA((LPCSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);
-
-    return win32_build_iowin(hFile);
-}
-
-
-voidpf ZCALLBACK win32_open64_file_funcW (voidpf opaque,const void* filename,int mode)
-{
-    const char* mode_fopen = NULL;
-    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;
-    HANDLE hFile = NULL;
-
-    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);
-
-    if ((filename!=NULL) && (dwDesiredAccess != 0))
-        hFile = CreateFileW((LPCWSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);
-
-    return win32_build_iowin(hFile);
-}
-
-
-voidpf ZCALLBACK win32_open_file_func (voidpf opaque,const char* filename,int mode)
-{
-    const char* mode_fopen = NULL;
-    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;
-    HANDLE hFile = NULL;
-
-    win32_translate_open_mode(mode,&dwDesiredAccess,&dwCreationDisposition,&dwShareMode,&dwFlagsAndAttributes);
-
-    if ((filename!=NULL) && (dwDesiredAccess != 0))
-        hFile = CreateFile((LPCTSTR)filename, dwDesiredAccess, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);
-
-    return win32_build_iowin(hFile);
-}
-
-
-uLong ZCALLBACK win32_read_file_func (voidpf opaque, voidpf stream, void* buf,uLong size)
-{
-    uLong ret=0;
-    HANDLE hFile = NULL;
-    if (stream!=NULL)
-        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;
-
-    if (hFile != NULL)
-    {
-        if (!ReadFile(hFile, buf, size, &ret, NULL))
-        {
-            DWORD dwErr = GetLastError();
-            if (dwErr == ERROR_HANDLE_EOF)
-                dwErr = 0;
-            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;
-        }
-    }
-
-    return ret;
-}
-
-
-uLong ZCALLBACK win32_write_file_func (voidpf opaque,voidpf stream,const void* buf,uLong size)
-{
-    uLong ret=0;
-    HANDLE hFile = NULL;
-    if (stream!=NULL)
-        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;
-
-    if (hFile != NULL)
-    {
-        if (!WriteFile(hFile, buf, size, &ret, NULL))
-        {
-            DWORD dwErr = GetLastError();
-            if (dwErr == ERROR_HANDLE_EOF)
-                dwErr = 0;
-            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;
-        }
-    }
-
-    return ret;
-}
-
-long ZCALLBACK win32_tell_file_func (voidpf opaque,voidpf stream)
-{
-    long ret=-1;
-    HANDLE hFile = NULL;
-    if (stream!=NULL)
-        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;
-    if (hFile != NULL)
-    {
-        DWORD dwSet = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);
-        if (dwSet == INVALID_SET_FILE_POINTER)
-        {
-            DWORD dwErr = GetLastError();
-            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;
-            ret = -1;
-        }
-        else
-            ret=(long)dwSet;
-    }
-    return ret;
-}
-
-ZPOS64_T ZCALLBACK win32_tell64_file_func (voidpf opaque, voidpf stream)
-{
-    ZPOS64_T ret= (ZPOS64_T)-1;
-    HANDLE hFile = NULL;
-    if (stream!=NULL)
-        hFile = ((WIN32FILE_IOWIN*)stream)->hf;
-
-    if (hFile)
-    {
-        LARGE_INTEGER li;
-        li.QuadPart = 0;
-        li.u.LowPart = SetFilePointer(hFile, li.u.LowPart, &li.u.HighPart, FILE_CURRENT);
-        if ( (li.LowPart == 0xFFFFFFFF) && (GetLastError() != NO_ERROR))
-        {
-            DWORD dwErr = GetLastError();
-            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;
-            ret = (ZPOS64_T)-1;
-        }
-        else
-            ret=li.QuadPart;
-    }
-    return ret;
-}
-
-
-long ZCALLBACK win32_seek_file_func (voidpf opaque,voidpf stream,uLong offset,int origin)
-{
-    DWORD dwMoveMethod=0xFFFFFFFF;
-    HANDLE hFile = NULL;
-
-    long ret=-1;
-    if (stream!=NULL)
-        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;
-    switch (origin)
-    {
-    case ZLIB_FILEFUNC_SEEK_CUR :
-        dwMoveMethod = FILE_CURRENT;
-        break;
-    case ZLIB_FILEFUNC_SEEK_END :
-        dwMoveMethod = FILE_END;
-        break;
-    case ZLIB_FILEFUNC_SEEK_SET :
-        dwMoveMethod = FILE_BEGIN;
-        break;
-    default: return -1;
-    }
-
-    if (hFile != NULL)
-    {
-        DWORD dwSet = SetFilePointer(hFile, offset, NULL, dwMoveMethod);
-        if (dwSet == INVALID_SET_FILE_POINTER)
-        {
-            DWORD dwErr = GetLastError();
-            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;
-            ret = -1;
-        }
-        else
-            ret=0;
-    }
-    return ret;
-}
-
-long ZCALLBACK win32_seek64_file_func (voidpf opaque, voidpf stream,ZPOS64_T offset,int origin)
-{
-    DWORD dwMoveMethod=0xFFFFFFFF;
-    HANDLE hFile = NULL;
-    long ret=-1;
-
-    if (stream!=NULL)
-        hFile = ((WIN32FILE_IOWIN*)stream)->hf;
-
-    switch (origin)
-    {
-        case ZLIB_FILEFUNC_SEEK_CUR :
-            dwMoveMethod = FILE_CURRENT;
-            break;
-        case ZLIB_FILEFUNC_SEEK_END :
-            dwMoveMethod = FILE_END;
-            break;
-        case ZLIB_FILEFUNC_SEEK_SET :
-            dwMoveMethod = FILE_BEGIN;
-            break;
-        default: return -1;
-    }
-
-    if (hFile)
-    {
-        LARGE_INTEGER* li = (LARGE_INTEGER*)&offset;
-        DWORD dwSet = SetFilePointer(hFile, li->u.LowPart, &li->u.HighPart, dwMoveMethod);
-        if (dwSet == INVALID_SET_FILE_POINTER)
-        {
-            DWORD dwErr = GetLastError();
-            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;
-            ret = -1;
-        }
-        else
-            ret=0;
-    }
-    return ret;
-}
-
-int ZCALLBACK win32_close_file_func (voidpf opaque, voidpf stream)
-{
-    int ret=-1;
-
-    if (stream!=NULL)
-    {
-        HANDLE hFile;
-        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;
-        if (hFile != NULL)
-        {
-            CloseHandle(hFile);
-            ret=0;
-        }
-        free(stream);
-    }
-    return ret;
-}
-
-int ZCALLBACK win32_error_file_func (voidpf opaque,voidpf stream)
-{
-    int ret=-1;
-    if (stream!=NULL)
-    {
-        ret = ((WIN32FILE_IOWIN*)stream) -> error;
-    }
-    return ret;
-}
-
-void fill_win32_filefunc (zlib_filefunc_def* pzlib_filefunc_def)
-{
-    pzlib_filefunc_def->zopen_file = win32_open_file_func;
-    pzlib_filefunc_def->zread_file = win32_read_file_func;
-    pzlib_filefunc_def->zwrite_file = win32_write_file_func;
-    pzlib_filefunc_def->ztell_file = win32_tell_file_func;
-    pzlib_filefunc_def->zseek_file = win32_seek_file_func;
-    pzlib_filefunc_def->zclose_file = win32_close_file_func;
-    pzlib_filefunc_def->zerror_file = win32_error_file_func;
-    pzlib_filefunc_def->opaque = NULL;
-}
-
-void fill_win32_filefunc64(zlib_filefunc64_def* pzlib_filefunc_def)
-{
-    pzlib_filefunc_def->zopen64_file = win32_open64_file_func;
-    pzlib_filefunc_def->zread_file = win32_read_file_func;
-    pzlib_filefunc_def->zwrite_file = win32_write_file_func;
-    pzlib_filefunc_def->ztell64_file = win32_tell64_file_func;
-    pzlib_filefunc_def->zseek64_file = win32_seek64_file_func;
-    pzlib_filefunc_def->zclose_file = win32_close_file_func;
-    pzlib_filefunc_def->zerror_file = win32_error_file_func;
-    pzlib_filefunc_def->opaque = NULL;
-}
-
-
-void fill_win32_filefunc64A(zlib_filefunc64_def* pzlib_filefunc_def)
-{
-    pzlib_filefunc_def->zopen64_file = win32_open64_file_funcA;
-    pzlib_filefunc_def->zread_file = win32_read_file_func;
-    pzlib_filefunc_def->zwrite_file = win32_write_file_func;
-    pzlib_filefunc_def->ztell64_file = win32_tell64_file_func;
-    pzlib_filefunc_def->zseek64_file = win32_seek64_file_func;
-    pzlib_filefunc_def->zclose_file = win32_close_file_func;
-    pzlib_filefunc_def->zerror_file = win32_error_file_func;
-    pzlib_filefunc_def->opaque = NULL;
-}
-
-
-void fill_win32_filefunc64W(zlib_filefunc64_def* pzlib_filefunc_def)
-{
-    pzlib_filefunc_def->zopen64_file = win32_open64_file_funcW;
-    pzlib_filefunc_def->zread_file = win32_read_file_func;
-    pzlib_filefunc_def->zwrite_file = win32_write_file_func;
-    pzlib_filefunc_def->ztell64_file = win32_tell64_file_func;
-    pzlib_filefunc_def->zseek64_file = win32_seek64_file_func;
-    pzlib_filefunc_def->zclose_file = win32_close_file_func;
-    pzlib_filefunc_def->zerror_file = win32_error_file_func;
-    pzlib_filefunc_def->opaque = NULL;
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/iowin32.h gcc-4.8.1-ppc/zlib/contrib/minizip/iowin32.h
--- gcc-4.8.1/zlib/contrib/minizip/iowin32.h	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/iowin32.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,28 +0,0 @@
-/* iowin32.h -- IO base function header for compress/uncompress .zip
-     Version 1.1, February 14h, 2010
-     part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications for Zip64 support
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-         For more info read MiniZip_info.txt
-
-*/
-
-#include <windows.h>
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-void fill_win32_filefunc OF((zlib_filefunc_def* pzlib_filefunc_def));
-void fill_win32_filefunc64 OF((zlib_filefunc64_def* pzlib_filefunc_def));
-void fill_win32_filefunc64A OF((zlib_filefunc64_def* pzlib_filefunc_def));
-void fill_win32_filefunc64W OF((zlib_filefunc64_def* pzlib_filefunc_def));
-
-#ifdef __cplusplus
-}
-#endif
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/Makefile gcc-4.8.1-ppc/zlib/contrib/minizip/Makefile
--- gcc-4.8.1/zlib/contrib/minizip/Makefile	2004-10-11 19:45:43.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-CC=cc
-CFLAGS=-O -I../..
-
-UNZ_OBJS = miniunz.o unzip.o ioapi.o ../../libz.a
-ZIP_OBJS = minizip.o zip.o   ioapi.o ../../libz.a
-
-.c.o:
-	$(CC) -c $(CFLAGS) $*.c
-
-all: miniunz minizip
-
-miniunz:  $(UNZ_OBJS)
-	$(CC) $(CFLAGS) -o $@ $(UNZ_OBJS)
-
-minizip:  $(ZIP_OBJS)
-	$(CC) $(CFLAGS) -o $@ $(ZIP_OBJS)
-
-test:	miniunz minizip
-	./minizip test readme.txt
-	./miniunz -l test.zip
-	mv readme.txt readme.old
-	./miniunz test.zip
-
-clean:
-	/bin/rm -f *.o *~ minizip miniunz
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/Makefile.am gcc-4.8.1-ppc/zlib/contrib/minizip/Makefile.am
--- gcc-4.8.1/zlib/contrib/minizip/Makefile.am	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/Makefile.am	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
-lib_LTLIBRARIES = libminizip.la
-
-if COND_DEMOS
-bin_PROGRAMS = miniunzip minizip
-endif
-
-zlib_top_srcdir = $(top_srcdir)/../..
-zlib_top_builddir = $(top_builddir)/../..
-
-AM_CPPFLAGS = -I$(zlib_top_srcdir)
-AM_LDFLAGS = -L$(zlib_top_builddir)
-
-if WIN32
-iowin32_src = iowin32.c
-iowin32_h = iowin32.h
-endif
-
-libminizip_la_SOURCES = \
-	ioapi.c \
-	mztools.c \
-	unzip.c \
-	zip.c \
-	${iowin32_src}
-
-libminizip_la_LDFLAGS = $(AM_LDFLAGS) -version-info 1:0:0 -lz
-
-minizip_includedir = $(includedir)/minizip
-minizip_include_HEADERS = \
-	crypt.h \
-	ioapi.h \
-	mztools.h \
-	unzip.h \
-	zip.h \
-	${iowin32_h}
-
-pkgconfigdir = $(libdir)/pkgconfig
-pkgconfig_DATA = minizip.pc
-
-EXTRA_PROGRAMS = miniunzip minizip
-
-miniunzip_SOURCES = miniunz.c
-miniunzip_LDADD = libminizip.la
-
-minizip_SOURCES = minizip.c
-minizip_LDADD = libminizip.la -lz
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/make_vms.com gcc-4.8.1-ppc/zlib/contrib/minizip/make_vms.com
--- gcc-4.8.1/zlib/contrib/minizip/make_vms.com	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/make_vms.com	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-$ if f$search("ioapi.h_orig") .eqs. "" then copy ioapi.h ioapi.h_orig
-$ open/write zdef vmsdefs.h
-$ copy sys$input: zdef
-$ deck
-#define unix
-#define fill_zlib_filefunc64_32_def_from_filefunc32 fillzffunc64from
-#define Write_Zip64EndOfCentralDirectoryLocator Write_Zip64EoDLocator
-#define Write_Zip64EndOfCentralDirectoryRecord Write_Zip64EoDRecord
-#define Write_EndOfCentralDirectoryRecord Write_EoDRecord
-$ eod
-$ close zdef
-$ copy vmsdefs.h,ioapi.h_orig ioapi.h
-$ cc/include=[--]/prefix=all ioapi.c
-$ cc/include=[--]/prefix=all miniunz.c
-$ cc/include=[--]/prefix=all unzip.c
-$ cc/include=[--]/prefix=all minizip.c
-$ cc/include=[--]/prefix=all zip.c
-$ link miniunz,unzip,ioapi,[--]libz.olb/lib
-$ link minizip,zip,ioapi,[--]libz.olb/lib
-$ mcr []minizip test minizip_info.txt
-$ mcr []miniunz -l test.zip
-$ rename minizip_info.txt; minizip_info.txt_old
-$ mcr []miniunz test.zip
-$ delete test.zip;*
-$exit
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/miniunz.c gcc-4.8.1-ppc/zlib/contrib/minizip/miniunz.c
--- gcc-4.8.1/zlib/contrib/minizip/miniunz.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/miniunz.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,660 +0,0 @@
-/*
-   miniunz.c
-   Version 1.1, February 14h, 2010
-   sample part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications of Unzip for Zip64
-         Copyright (C) 2007-2008 Even Rouault
-
-         Modifications for Zip64 support on both zip and unzip
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-*/
-
-#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__))
-        #ifndef __USE_FILE_OFFSET64
-                #define __USE_FILE_OFFSET64
-        #endif
-        #ifndef __USE_LARGEFILE64
-                #define __USE_LARGEFILE64
-        #endif
-        #ifndef _LARGEFILE64_SOURCE
-                #define _LARGEFILE64_SOURCE
-        #endif
-        #ifndef _FILE_OFFSET_BIT
-                #define _FILE_OFFSET_BIT 64
-        #endif
-#endif
-
-#ifdef __APPLE__
-// In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
-#define FOPEN_FUNC(filename, mode) fopen(filename, mode)
-#define FTELLO_FUNC(stream) ftello(stream)
-#define FSEEKO_FUNC(stream, offset, origin) fseeko(stream, offset, origin)
-#else
-#define FOPEN_FUNC(filename, mode) fopen64(filename, mode)
-#define FTELLO_FUNC(stream) ftello64(stream)
-#define FSEEKO_FUNC(stream, offset, origin) fseeko64(stream, offset, origin)
-#endif
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <errno.h>
-#include <fcntl.h>
-
-#ifdef _WIN32
-# include <direct.h>
-# include <io.h>
-#else
-# include <unistd.h>
-# include <utime.h>
-#endif
-
-
-#include "unzip.h"
-
-#define CASESENSITIVITY (0)
-#define WRITEBUFFERSIZE (8192)
-#define MAXFILENAME (256)
-
-#ifdef _WIN32
-#define USEWIN32IOAPI
-#include "iowin32.h"
-#endif
-/*
-  mini unzip, demo of unzip package
-
-  usage :
-  Usage : miniunz [-exvlo] file.zip [file_to_extract] [-d extractdir]
-
-  list the file in the zipfile, and print the content of FILE_ID.ZIP or README.TXT
-    if it exists
-*/
-
-
-/* change_file_date : change the date/time of a file
-    filename : the filename of the file where date/time must be modified
-    dosdate : the new date at the MSDos format (4 bytes)
-    tmu_date : the SAME new date at the tm_unz format */
-void change_file_date(filename,dosdate,tmu_date)
-    const char *filename;
-    uLong dosdate;
-    tm_unz tmu_date;
-{
-#ifdef _WIN32
-  HANDLE hFile;
-  FILETIME ftm,ftLocal,ftCreate,ftLastAcc,ftLastWrite;
-
-  hFile = CreateFileA(filename,GENERIC_READ | GENERIC_WRITE,
-                      0,NULL,OPEN_EXISTING,0,NULL);
-  GetFileTime(hFile,&ftCreate,&ftLastAcc,&ftLastWrite);
-  DosDateTimeToFileTime((WORD)(dosdate>>16),(WORD)dosdate,&ftLocal);
-  LocalFileTimeToFileTime(&ftLocal,&ftm);
-  SetFileTime(hFile,&ftm,&ftLastAcc,&ftm);
-  CloseHandle(hFile);
-#else
-#ifdef unix || __APPLE__
-  struct utimbuf ut;
-  struct tm newdate;
-  newdate.tm_sec = tmu_date.tm_sec;
-  newdate.tm_min=tmu_date.tm_min;
-  newdate.tm_hour=tmu_date.tm_hour;
-  newdate.tm_mday=tmu_date.tm_mday;
-  newdate.tm_mon=tmu_date.tm_mon;
-  if (tmu_date.tm_year > 1900)
-      newdate.tm_year=tmu_date.tm_year - 1900;
-  else
-      newdate.tm_year=tmu_date.tm_year ;
-  newdate.tm_isdst=-1;
-
-  ut.actime=ut.modtime=mktime(&newdate);
-  utime(filename,&ut);
-#endif
-#endif
-}
-
-
-/* mymkdir and change_file_date are not 100 % portable
-   As I don't know well Unix, I wait feedback for the unix portion */
-
-int mymkdir(dirname)
-    const char* dirname;
-{
-    int ret=0;
-#ifdef _WIN32
-    ret = _mkdir(dirname);
-#elif unix
-    ret = mkdir (dirname,0775);
-#elif __APPLE__
-    ret = mkdir (dirname,0775);
-#endif
-    return ret;
-}
-
-int makedir (newdir)
-    char *newdir;
-{
-  char *buffer ;
-  char *p;
-  int  len = (int)strlen(newdir);
-
-  if (len <= 0)
-    return 0;
-
-  buffer = (char*)malloc(len+1);
-        if (buffer==NULL)
-        {
-                printf("Error allocating memory\n");
-                return UNZ_INTERNALERROR;
-        }
-  strcpy(buffer,newdir);
-
-  if (buffer[len-1] == '/') {
-    buffer[len-1] = '\0';
-  }
-  if (mymkdir(buffer) == 0)
-    {
-      free(buffer);
-      return 1;
-    }
-
-  p = buffer+1;
-  while (1)
-    {
-      char hold;
-
-      while(*p && *p != '\\' && *p != '/')
-        p++;
-      hold = *p;
-      *p = 0;
-      if ((mymkdir(buffer) == -1) && (errno == ENOENT))
-        {
-          printf("couldn't create directory %s\n",buffer);
-          free(buffer);
-          return 0;
-        }
-      if (hold == 0)
-        break;
-      *p++ = hold;
-    }
-  free(buffer);
-  return 1;
-}
-
-void do_banner()
-{
-    printf("MiniUnz 1.01b, demo of zLib + Unz package written by Gilles Vollant\n");
-    printf("more info at http://www.winimage.com/zLibDll/unzip.html\n\n");
-}
-
-void do_help()
-{
-    printf("Usage : miniunz [-e] [-x] [-v] [-l] [-o] [-p password] file.zip [file_to_extr.] [-d extractdir]\n\n" \
-           "  -e  Extract without pathname (junk paths)\n" \
-           "  -x  Extract with pathname\n" \
-           "  -v  list files\n" \
-           "  -l  list files\n" \
-           "  -d  directory to extract into\n" \
-           "  -o  overwrite files without prompting\n" \
-           "  -p  extract crypted file using password\n\n");
-}
-
-void Display64BitsSize(ZPOS64_T n, int size_char)
-{
-  /* to avoid compatibility problem , we do here the conversion */
-  char number[21];
-  int offset=19;
-  int pos_string = 19;
-  number[20]=0;
-  for (;;) {
-      number[offset]=(char)((n%10)+'0');
-      if (number[offset] != '0')
-          pos_string=offset;
-      n/=10;
-      if (offset==0)
-          break;
-      offset--;
-  }
-  {
-      int size_display_string = 19-pos_string;
-      while (size_char > size_display_string)
-      {
-          size_char--;
-          printf(" ");
-      }
-  }
-
-  printf("%s",&number[pos_string]);
-}
-
-int do_list(uf)
-    unzFile uf;
-{
-    uLong i;
-    unz_global_info64 gi;
-    int err;
-
-    err = unzGetGlobalInfo64(uf,&gi);
-    if (err!=UNZ_OK)
-        printf("error %d with zipfile in unzGetGlobalInfo \n",err);
-    printf("  Length  Method     Size Ratio   Date    Time   CRC-32     Name\n");
-    printf("  ------  ------     ---- -----   ----    ----   ------     ----\n");
-    for (i=0;i<gi.number_entry;i++)
-    {
-        char filename_inzip[256];
-        unz_file_info64 file_info;
-        uLong ratio=0;
-        const char *string_method;
-        char charCrypt=' ';
-        err = unzGetCurrentFileInfo64(uf,&file_info,filename_inzip,sizeof(filename_inzip),NULL,0,NULL,0);
-        if (err!=UNZ_OK)
-        {
-            printf("error %d with zipfile in unzGetCurrentFileInfo\n",err);
-            break;
-        }
-        if (file_info.uncompressed_size>0)
-            ratio = (uLong)((file_info.compressed_size*100)/file_info.uncompressed_size);
-
-        /* display a '*' if the file is crypted */
-        if ((file_info.flag & 1) != 0)
-            charCrypt='*';
-
-        if (file_info.compression_method==0)
-            string_method="Stored";
-        else
-        if (file_info.compression_method==Z_DEFLATED)
-        {
-            uInt iLevel=(uInt)((file_info.flag & 0x6)/2);
-            if (iLevel==0)
-              string_method="Defl:N";
-            else if (iLevel==1)
-              string_method="Defl:X";
-            else if ((iLevel==2) || (iLevel==3))
-              string_method="Defl:F"; /* 2:fast , 3 : extra fast*/
-        }
-        else
-        if (file_info.compression_method==Z_BZIP2ED)
-        {
-              string_method="BZip2 ";
-        }
-        else
-            string_method="Unkn. ";
-
-        Display64BitsSize(file_info.uncompressed_size,7);
-        printf("  %6s%c",string_method,charCrypt);
-        Display64BitsSize(file_info.compressed_size,7);
-        printf(" %3lu%%  %2.2lu-%2.2lu-%2.2lu  %2.2lu:%2.2lu  %8.8lx   %s\n",
-                ratio,
-                (uLong)file_info.tmu_date.tm_mon + 1,
-                (uLong)file_info.tmu_date.tm_mday,
-                (uLong)file_info.tmu_date.tm_year % 100,
-                (uLong)file_info.tmu_date.tm_hour,(uLong)file_info.tmu_date.tm_min,
-                (uLong)file_info.crc,filename_inzip);
-        if ((i+1)<gi.number_entry)
-        {
-            err = unzGoToNextFile(uf);
-            if (err!=UNZ_OK)
-            {
-                printf("error %d with zipfile in unzGoToNextFile\n",err);
-                break;
-            }
-        }
-    }
-
-    return 0;
-}
-
-
-int do_extract_currentfile(uf,popt_extract_without_path,popt_overwrite,password)
-    unzFile uf;
-    const int* popt_extract_without_path;
-    int* popt_overwrite;
-    const char* password;
-{
-    char filename_inzip[256];
-    char* filename_withoutpath;
-    char* p;
-    int err=UNZ_OK;
-    FILE *fout=NULL;
-    void* buf;
-    uInt size_buf;
-
-    unz_file_info64 file_info;
-    uLong ratio=0;
-    err = unzGetCurrentFileInfo64(uf,&file_info,filename_inzip,sizeof(filename_inzip),NULL,0,NULL,0);
-
-    if (err!=UNZ_OK)
-    {
-        printf("error %d with zipfile in unzGetCurrentFileInfo\n",err);
-        return err;
-    }
-
-    size_buf = WRITEBUFFERSIZE;
-    buf = (void*)malloc(size_buf);
-    if (buf==NULL)
-    {
-        printf("Error allocating memory\n");
-        return UNZ_INTERNALERROR;
-    }
-
-    p = filename_withoutpath = filename_inzip;
-    while ((*p) != '\0')
-    {
-        if (((*p)=='/') || ((*p)=='\\'))
-            filename_withoutpath = p+1;
-        p++;
-    }
-
-    if ((*filename_withoutpath)=='\0')
-    {
-        if ((*popt_extract_without_path)==0)
-        {
-            printf("creating directory: %s\n",filename_inzip);
-            mymkdir(filename_inzip);
-        }
-    }
-    else
-    {
-        const char* write_filename;
-        int skip=0;
-
-        if ((*popt_extract_without_path)==0)
-            write_filename = filename_inzip;
-        else
-            write_filename = filename_withoutpath;
-
-        err = unzOpenCurrentFilePassword(uf,password);
-        if (err!=UNZ_OK)
-        {
-            printf("error %d with zipfile in unzOpenCurrentFilePassword\n",err);
-        }
-
-        if (((*popt_overwrite)==0) && (err==UNZ_OK))
-        {
-            char rep=0;
-            FILE* ftestexist;
-            ftestexist = FOPEN_FUNC(write_filename,"rb");
-            if (ftestexist!=NULL)
-            {
-                fclose(ftestexist);
-                do
-                {
-                    char answer[128];
-                    int ret;
-
-                    printf("The file %s exists. Overwrite ? [y]es, [n]o, [A]ll: ",write_filename);
-                    ret = scanf("%1s",answer);
-                    if (ret != 1)
-                    {
-                       exit(EXIT_FAILURE);
-                    }
-                    rep = answer[0] ;
-                    if ((rep>='a') && (rep<='z'))
-                        rep -= 0x20;
-                }
-                while ((rep!='Y') && (rep!='N') && (rep!='A'));
-            }
-
-            if (rep == 'N')
-                skip = 1;
-
-            if (rep == 'A')
-                *popt_overwrite=1;
-        }
-
-        if ((skip==0) && (err==UNZ_OK))
-        {
-            fout=FOPEN_FUNC(write_filename,"wb");
-            /* some zipfile don't contain directory alone before file */
-            if ((fout==NULL) && ((*popt_extract_without_path)==0) &&
-                                (filename_withoutpath!=(char*)filename_inzip))
-            {
-                char c=*(filename_withoutpath-1);
-                *(filename_withoutpath-1)='\0';
-                makedir(write_filename);
-                *(filename_withoutpath-1)=c;
-                fout=FOPEN_FUNC(write_filename,"wb");
-            }
-
-            if (fout==NULL)
-            {
-                printf("error opening %s\n",write_filename);
-            }
-        }
-
-        if (fout!=NULL)
-        {
-            printf(" extracting: %s\n",write_filename);
-
-            do
-            {
-                err = unzReadCurrentFile(uf,buf,size_buf);
-                if (err<0)
-                {
-                    printf("error %d with zipfile in unzReadCurrentFile\n",err);
-                    break;
-                }
-                if (err>0)
-                    if (fwrite(buf,err,1,fout)!=1)
-                    {
-                        printf("error in writing extracted file\n");
-                        err=UNZ_ERRNO;
-                        break;
-                    }
-            }
-            while (err>0);
-            if (fout)
-                    fclose(fout);
-
-            if (err==0)
-                change_file_date(write_filename,file_info.dosDate,
-                                 file_info.tmu_date);
-        }
-
-        if (err==UNZ_OK)
-        {
-            err = unzCloseCurrentFile (uf);
-            if (err!=UNZ_OK)
-            {
-                printf("error %d with zipfile in unzCloseCurrentFile\n",err);
-            }
-        }
-        else
-            unzCloseCurrentFile(uf); /* don't lose the error */
-    }
-
-    free(buf);
-    return err;
-}
-
-
-int do_extract(uf,opt_extract_without_path,opt_overwrite,password)
-    unzFile uf;
-    int opt_extract_without_path;
-    int opt_overwrite;
-    const char* password;
-{
-    uLong i;
-    unz_global_info64 gi;
-    int err;
-    FILE* fout=NULL;
-
-    err = unzGetGlobalInfo64(uf,&gi);
-    if (err!=UNZ_OK)
-        printf("error %d with zipfile in unzGetGlobalInfo \n",err);
-
-    for (i=0;i<gi.number_entry;i++)
-    {
-        if (do_extract_currentfile(uf,&opt_extract_without_path,
-                                      &opt_overwrite,
-                                      password) != UNZ_OK)
-            break;
-
-        if ((i+1)<gi.number_entry)
-        {
-            err = unzGoToNextFile(uf);
-            if (err!=UNZ_OK)
-            {
-                printf("error %d with zipfile in unzGoToNextFile\n",err);
-                break;
-            }
-        }
-    }
-
-    return 0;
-}
-
-int do_extract_onefile(uf,filename,opt_extract_without_path,opt_overwrite,password)
-    unzFile uf;
-    const char* filename;
-    int opt_extract_without_path;
-    int opt_overwrite;
-    const char* password;
-{
-    int err = UNZ_OK;
-    if (unzLocateFile(uf,filename,CASESENSITIVITY)!=UNZ_OK)
-    {
-        printf("file %s not found in the zipfile\n",filename);
-        return 2;
-    }
-
-    if (do_extract_currentfile(uf,&opt_extract_without_path,
-                                      &opt_overwrite,
-                                      password) == UNZ_OK)
-        return 0;
-    else
-        return 1;
-}
-
-
-int main(argc,argv)
-    int argc;
-    char *argv[];
-{
-    const char *zipfilename=NULL;
-    const char *filename_to_extract=NULL;
-    const char *password=NULL;
-    char filename_try[MAXFILENAME+16] = "";
-    int i;
-    int ret_value=0;
-    int opt_do_list=0;
-    int opt_do_extract=1;
-    int opt_do_extract_withoutpath=0;
-    int opt_overwrite=0;
-    int opt_extractdir=0;
-    const char *dirname=NULL;
-    unzFile uf=NULL;
-
-    do_banner();
-    if (argc==1)
-    {
-        do_help();
-        return 0;
-    }
-    else
-    {
-        for (i=1;i<argc;i++)
-        {
-            if ((*argv[i])=='-')
-            {
-                const char *p=argv[i]+1;
-
-                while ((*p)!='\0')
-                {
-                    char c=*(p++);;
-                    if ((c=='l') || (c=='L'))
-                        opt_do_list = 1;
-                    if ((c=='v') || (c=='V'))
-                        opt_do_list = 1;
-                    if ((c=='x') || (c=='X'))
-                        opt_do_extract = 1;
-                    if ((c=='e') || (c=='E'))
-                        opt_do_extract = opt_do_extract_withoutpath = 1;
-                    if ((c=='o') || (c=='O'))
-                        opt_overwrite=1;
-                    if ((c=='d') || (c=='D'))
-                    {
-                        opt_extractdir=1;
-                        dirname=argv[i+1];
-                    }
-
-                    if (((c=='p') || (c=='P')) && (i+1<argc))
-                    {
-                        password=argv[i+1];
-                        i++;
-                    }
-                }
-            }
-            else
-            {
-                if (zipfilename == NULL)
-                    zipfilename = argv[i];
-                else if ((filename_to_extract==NULL) && (!opt_extractdir))
-                        filename_to_extract = argv[i] ;
-            }
-        }
-    }
-
-    if (zipfilename!=NULL)
-    {
-
-#        ifdef USEWIN32IOAPI
-        zlib_filefunc64_def ffunc;
-#        endif
-
-        strncpy(filename_try, zipfilename,MAXFILENAME-1);
-        /* strncpy doesnt append the trailing NULL, of the string is too long. */
-        filename_try[ MAXFILENAME ] = '\0';
-
-#        ifdef USEWIN32IOAPI
-        fill_win32_filefunc64A(&ffunc);
-        uf = unzOpen2_64(zipfilename,&ffunc);
-#        else
-        uf = unzOpen64(zipfilename);
-#        endif
-        if (uf==NULL)
-        {
-            strcat(filename_try,".zip");
-#            ifdef USEWIN32IOAPI
-            uf = unzOpen2_64(filename_try,&ffunc);
-#            else
-            uf = unzOpen64(filename_try);
-#            endif
-        }
-    }
-
-    if (uf==NULL)
-    {
-        printf("Cannot open %s or %s.zip\n",zipfilename,zipfilename);
-        return 1;
-    }
-    printf("%s opened\n",filename_try);
-
-    if (opt_do_list==1)
-        ret_value = do_list(uf);
-    else if (opt_do_extract==1)
-    {
-#ifdef _WIN32
-        if (opt_extractdir && _chdir(dirname))
-#else
-        if (opt_extractdir && chdir(dirname))
-#endif
-        {
-          printf("Error changing into %s, aborting\n", dirname);
-          exit(-1);
-        }
-
-        if (filename_to_extract == NULL)
-            ret_value = do_extract(uf, opt_do_extract_withoutpath, opt_overwrite, password);
-        else
-            ret_value = do_extract_onefile(uf, filename_to_extract, opt_do_extract_withoutpath, opt_overwrite, password);
-    }
-
-    unzClose(uf);
-
-    return ret_value;
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/MiniZip64_Changes.txt gcc-4.8.1-ppc/zlib/contrib/minizip/MiniZip64_Changes.txt
--- gcc-4.8.1/zlib/contrib/minizip/MiniZip64_Changes.txt	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/MiniZip64_Changes.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,6 +0,0 @@
-
-MiniZip 1.1 was derrived from MiniZip at version 1.01f
-
-Change in 1.0 (Okt 2009)
- - **TODO - Add history**
-
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/MiniZip64_info.txt gcc-4.8.1-ppc/zlib/contrib/minizip/MiniZip64_info.txt
--- gcc-4.8.1/zlib/contrib/minizip/MiniZip64_info.txt	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/MiniZip64_info.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,74 +0,0 @@
-MiniZip - Copyright (c) 1998-2010 - by Gilles Vollant - version 1.1 64 bits from Mathias Svensson
-
-Introduction
----------------------
-MiniZip 1.1 is built from MiniZip 1.0 by Gilles Vollant ( http://www.winimage.com/zLibDll/minizip.html )
-
-When adding ZIP64 support into minizip it would result into risk of breaking compatibility with minizip 1.0.
-All possible work was done for compatibility.
-
-
-Background
----------------------
-When adding ZIP64 support Mathias Svensson found that Even Rouault have added ZIP64 
-support for unzip.c into minizip for a open source project called gdal ( http://www.gdal.org/ )
-
-That was used as a starting point. And after that ZIP64 support was added to zip.c
-some refactoring and code cleanup was also done.
-
-
-Changed from MiniZip 1.0 to MiniZip 1.1
----------------------------------------
-* Added ZIP64 support for unzip ( by Even Rouault )
-* Added ZIP64 support for zip ( by Mathias Svensson )
-* Reverted some changed that Even Rouault did.
-* Bunch of patches received from Gulles Vollant that he received for MiniZip from various users.
-* Added unzip patch for BZIP Compression method (patch create by Daniel Borca)
-* Added BZIP Compress method for zip
-* Did some refactoring and code cleanup
-
-
-Credits
-
- Gilles Vollant    - Original MiniZip author
- Even Rouault      - ZIP64 unzip Support
- Daniel Borca      - BZip Compression method support in unzip
- Mathias Svensson  - ZIP64 zip support
- Mathias Svensson  - BZip Compression method support in zip
-
- Resources
-
- ZipLayout   http://result42.com/projects/ZipFileLayout
-             Command line tool for Windows that shows the layout and information of the headers in a zip archive.
-             Used when debugging and validating the creation of zip files using MiniZip64
-
-
- ZIP App Note  http://www.pkware.com/documents/casestudies/APPNOTE.TXT
-               Zip File specification
-
-
-Notes.
- * To be able to use BZip compression method in zip64.c or unzip64.c the BZIP2 lib is needed and HAVE_BZIP2 need to be defined.
-
-License
-----------------------------------------------------------
-   Condition of use and distribution are the same than zlib :
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-----------------------------------------------------------
-
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/minizip.c gcc-4.8.1-ppc/zlib/contrib/minizip/minizip.c
--- gcc-4.8.1/zlib/contrib/minizip/minizip.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/minizip.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,520 +0,0 @@
-/*
-   minizip.c
-   Version 1.1, February 14h, 2010
-   sample part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications of Unzip for Zip64
-         Copyright (C) 2007-2008 Even Rouault
-
-         Modifications for Zip64 support on both zip and unzip
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-*/
-
-
-#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__))
-        #ifndef __USE_FILE_OFFSET64
-                #define __USE_FILE_OFFSET64
-        #endif
-        #ifndef __USE_LARGEFILE64
-                #define __USE_LARGEFILE64
-        #endif
-        #ifndef _LARGEFILE64_SOURCE
-                #define _LARGEFILE64_SOURCE
-        #endif
-        #ifndef _FILE_OFFSET_BIT
-                #define _FILE_OFFSET_BIT 64
-        #endif
-#endif
-
-#ifdef __APPLE__
-// In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
-#define FOPEN_FUNC(filename, mode) fopen(filename, mode)
-#define FTELLO_FUNC(stream) ftello(stream)
-#define FSEEKO_FUNC(stream, offset, origin) fseeko(stream, offset, origin)
-#else
-#define FOPEN_FUNC(filename, mode) fopen64(filename, mode)
-#define FTELLO_FUNC(stream) ftello64(stream)
-#define FSEEKO_FUNC(stream, offset, origin) fseeko64(stream, offset, origin)
-#endif
-
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <errno.h>
-#include <fcntl.h>
-
-#ifdef _WIN32
-# include <direct.h>
-# include <io.h>
-#else
-# include <unistd.h>
-# include <utime.h>
-# include <sys/types.h>
-# include <sys/stat.h>
-#endif
-
-#include "zip.h"
-
-#ifdef _WIN32
-        #define USEWIN32IOAPI
-        #include "iowin32.h"
-#endif
-
-
-
-#define WRITEBUFFERSIZE (16384)
-#define MAXFILENAME (256)
-
-#ifdef _WIN32
-uLong filetime(f, tmzip, dt)
-    char *f;                /* name of file to get info on */
-    tm_zip *tmzip;             /* return value: access, modific. and creation times */
-    uLong *dt;             /* dostime */
-{
-  int ret = 0;
-  {
-      FILETIME ftLocal;
-      HANDLE hFind;
-      WIN32_FIND_DATAA ff32;
-
-      hFind = FindFirstFileA(f,&ff32);
-      if (hFind != INVALID_HANDLE_VALUE)
-      {
-        FileTimeToLocalFileTime(&(ff32.ftLastWriteTime),&ftLocal);
-        FileTimeToDosDateTime(&ftLocal,((LPWORD)dt)+1,((LPWORD)dt)+0);
-        FindClose(hFind);
-        ret = 1;
-      }
-  }
-  return ret;
-}
-#else
-#ifdef unix || __APPLE__
-uLong filetime(f, tmzip, dt)
-    char *f;               /* name of file to get info on */
-    tm_zip *tmzip;         /* return value: access, modific. and creation times */
-    uLong *dt;             /* dostime */
-{
-  int ret=0;
-  struct stat s;        /* results of stat() */
-  struct tm* filedate;
-  time_t tm_t=0;
-
-  if (strcmp(f,"-")!=0)
-  {
-    char name[MAXFILENAME+1];
-    int len = strlen(f);
-    if (len > MAXFILENAME)
-      len = MAXFILENAME;
-
-    strncpy(name, f,MAXFILENAME-1);
-    /* strncpy doesnt append the trailing NULL, of the string is too long. */
-    name[ MAXFILENAME ] = '\0';
-
-    if (name[len - 1] == '/')
-      name[len - 1] = '\0';
-    /* not all systems allow stat'ing a file with / appended */
-    if (stat(name,&s)==0)
-    {
-      tm_t = s.st_mtime;
-      ret = 1;
-    }
-  }
-  filedate = localtime(&tm_t);
-
-  tmzip->tm_sec  = filedate->tm_sec;
-  tmzip->tm_min  = filedate->tm_min;
-  tmzip->tm_hour = filedate->tm_hour;
-  tmzip->tm_mday = filedate->tm_mday;
-  tmzip->tm_mon  = filedate->tm_mon ;
-  tmzip->tm_year = filedate->tm_year;
-
-  return ret;
-}
-#else
-uLong filetime(f, tmzip, dt)
-    char *f;                /* name of file to get info on */
-    tm_zip *tmzip;             /* return value: access, modific. and creation times */
-    uLong *dt;             /* dostime */
-{
-    return 0;
-}
-#endif
-#endif
-
-
-
-
-int check_exist_file(filename)
-    const char* filename;
-{
-    FILE* ftestexist;
-    int ret = 1;
-    ftestexist = FOPEN_FUNC(filename,"rb");
-    if (ftestexist==NULL)
-        ret = 0;
-    else
-        fclose(ftestexist);
-    return ret;
-}
-
-void do_banner()
-{
-    printf("MiniZip 1.1, demo of zLib + MiniZip64 package, written by Gilles Vollant\n");
-    printf("more info on MiniZip at http://www.winimage.com/zLibDll/minizip.html\n\n");
-}
-
-void do_help()
-{
-    printf("Usage : minizip [-o] [-a] [-0 to -9] [-p password] [-j] file.zip [files_to_add]\n\n" \
-           "  -o  Overwrite existing file.zip\n" \
-           "  -a  Append to existing file.zip\n" \
-           "  -0  Store only\n" \
-           "  -1  Compress faster\n" \
-           "  -9  Compress better\n\n" \
-           "  -j  exclude path. store only the file name.\n\n");
-}
-
-/* calculate the CRC32 of a file,
-   because to encrypt a file, we need known the CRC32 of the file before */
-int getFileCrc(const char* filenameinzip,void*buf,unsigned long size_buf,unsigned long* result_crc)
-{
-   unsigned long calculate_crc=0;
-   int err=ZIP_OK;
-   FILE * fin = FOPEN_FUNC(filenameinzip,"rb");
-
-   unsigned long size_read = 0;
-   unsigned long total_read = 0;
-   if (fin==NULL)
-   {
-       err = ZIP_ERRNO;
-   }
-
-    if (err == ZIP_OK)
-        do
-        {
-            err = ZIP_OK;
-            size_read = (int)fread(buf,1,size_buf,fin);
-            if (size_read < size_buf)
-                if (feof(fin)==0)
-            {
-                printf("error in reading %s\n",filenameinzip);
-                err = ZIP_ERRNO;
-            }
-
-            if (size_read>0)
-                calculate_crc = crc32(calculate_crc,buf,size_read);
-            total_read += size_read;
-
-        } while ((err == ZIP_OK) && (size_read>0));
-
-    if (fin)
-        fclose(fin);
-
-    *result_crc=calculate_crc;
-    printf("file %s crc %lx\n", filenameinzip, calculate_crc);
-    return err;
-}
-
-int isLargeFile(const char* filename)
-{
-  int largeFile = 0;
-  ZPOS64_T pos = 0;
-  FILE* pFile = FOPEN_FUNC(filename, "rb");
-
-  if(pFile != NULL)
-  {
-    int n = FSEEKO_FUNC(pFile, 0, SEEK_END);
-    pos = FTELLO_FUNC(pFile);
-
-                printf("File : %s is %lld bytes\n", filename, pos);
-
-    if(pos >= 0xffffffff)
-     largeFile = 1;
-
-                fclose(pFile);
-  }
-
- return largeFile;
-}
-
-int main(argc,argv)
-    int argc;
-    char *argv[];
-{
-    int i;
-    int opt_overwrite=0;
-    int opt_compress_level=Z_DEFAULT_COMPRESSION;
-    int opt_exclude_path=0;
-    int zipfilenamearg = 0;
-    char filename_try[MAXFILENAME+16];
-    int zipok;
-    int err=0;
-    int size_buf=0;
-    void* buf=NULL;
-    const char* password=NULL;
-
-
-    do_banner();
-    if (argc==1)
-    {
-        do_help();
-        return 0;
-    }
-    else
-    {
-        for (i=1;i<argc;i++)
-        {
-            if ((*argv[i])=='-')
-            {
-                const char *p=argv[i]+1;
-
-                while ((*p)!='\0')
-                {
-                    char c=*(p++);;
-                    if ((c=='o') || (c=='O'))
-                        opt_overwrite = 1;
-                    if ((c=='a') || (c=='A'))
-                        opt_overwrite = 2;
-                    if ((c>='0') && (c<='9'))
-                        opt_compress_level = c-'0';
-                    if ((c=='j') || (c=='J'))
-                        opt_exclude_path = 1;
-
-                    if (((c=='p') || (c=='P')) && (i+1<argc))
-                    {
-                        password=argv[i+1];
-                        i++;
-                    }
-                }
-            }
-            else
-            {
-                if (zipfilenamearg == 0)
-                {
-                    zipfilenamearg = i ;
-                }
-            }
-        }
-    }
-
-    size_buf = WRITEBUFFERSIZE;
-    buf = (void*)malloc(size_buf);
-    if (buf==NULL)
-    {
-        printf("Error allocating memory\n");
-        return ZIP_INTERNALERROR;
-    }
-
-    if (zipfilenamearg==0)
-    {
-        zipok=0;
-    }
-    else
-    {
-        int i,len;
-        int dot_found=0;
-
-        zipok = 1 ;
-        strncpy(filename_try, argv[zipfilenamearg],MAXFILENAME-1);
-        /* strncpy doesnt append the trailing NULL, of the string is too long. */
-        filename_try[ MAXFILENAME ] = '\0';
-
-        len=(int)strlen(filename_try);
-        for (i=0;i<len;i++)
-            if (filename_try[i]=='.')
-                dot_found=1;
-
-        if (dot_found==0)
-            strcat(filename_try,".zip");
-
-        if (opt_overwrite==2)
-        {
-            /* if the file don't exist, we not append file */
-            if (check_exist_file(filename_try)==0)
-                opt_overwrite=1;
-        }
-        else
-        if (opt_overwrite==0)
-            if (check_exist_file(filename_try)!=0)
-            {
-                char rep=0;
-                do
-                {
-                    char answer[128];
-                    int ret;
-                    printf("The file %s exists. Overwrite ? [y]es, [n]o, [a]ppend : ",filename_try);
-                    ret = scanf("%1s",answer);
-                    if (ret != 1)
-                    {
-                       exit(EXIT_FAILURE);
-                    }
-                    rep = answer[0] ;
-                    if ((rep>='a') && (rep<='z'))
-                        rep -= 0x20;
-                }
-                while ((rep!='Y') && (rep!='N') && (rep!='A'));
-                if (rep=='N')
-                    zipok = 0;
-                if (rep=='A')
-                    opt_overwrite = 2;
-            }
-    }
-
-    if (zipok==1)
-    {
-        zipFile zf;
-        int errclose;
-#        ifdef USEWIN32IOAPI
-        zlib_filefunc64_def ffunc;
-        fill_win32_filefunc64A(&ffunc);
-        zf = zipOpen2_64(filename_try,(opt_overwrite==2) ? 2 : 0,NULL,&ffunc);
-#        else
-        zf = zipOpen64(filename_try,(opt_overwrite==2) ? 2 : 0);
-#        endif
-
-        if (zf == NULL)
-        {
-            printf("error opening %s\n",filename_try);
-            err= ZIP_ERRNO;
-        }
-        else
-            printf("creating %s\n",filename_try);
-
-        for (i=zipfilenamearg+1;(i<argc) && (err==ZIP_OK);i++)
-        {
-            if (!((((*(argv[i]))=='-') || ((*(argv[i]))=='/')) &&
-                  ((argv[i][1]=='o') || (argv[i][1]=='O') ||
-                   (argv[i][1]=='a') || (argv[i][1]=='A') ||
-                   (argv[i][1]=='p') || (argv[i][1]=='P') ||
-                   ((argv[i][1]>='0') || (argv[i][1]<='9'))) &&
-                  (strlen(argv[i]) == 2)))
-            {
-                FILE * fin;
-                int size_read;
-                const char* filenameinzip = argv[i];
-                const char *savefilenameinzip;
-                zip_fileinfo zi;
-                unsigned long crcFile=0;
-                int zip64 = 0;
-
-                zi.tmz_date.tm_sec = zi.tmz_date.tm_min = zi.tmz_date.tm_hour =
-                zi.tmz_date.tm_mday = zi.tmz_date.tm_mon = zi.tmz_date.tm_year = 0;
-                zi.dosDate = 0;
-                zi.internal_fa = 0;
-                zi.external_fa = 0;
-                filetime(filenameinzip,&zi.tmz_date,&zi.dosDate);
-
-/*
-                err = zipOpenNewFileInZip(zf,filenameinzip,&zi,
-                                 NULL,0,NULL,0,NULL / * comment * /,
-                                 (opt_compress_level != 0) ? Z_DEFLATED : 0,
-                                 opt_compress_level);
-*/
-                if ((password != NULL) && (err==ZIP_OK))
-                    err = getFileCrc(filenameinzip,buf,size_buf,&crcFile);
-
-                zip64 = isLargeFile(filenameinzip);
-
-                                                         /* The path name saved, should not include a leading slash. */
-               /*if it did, windows/xp and dynazip couldn't read the zip file. */
-                 savefilenameinzip = filenameinzip;
-                 while( savefilenameinzip[0] == '\\' || savefilenameinzip[0] == '/' )
-                 {
-                     savefilenameinzip++;
-                 }
-
-                 /*should the zip file contain any path at all?*/
-                 if( opt_exclude_path )
-                 {
-                     const char *tmpptr;
-                     const char *lastslash = 0;
-                     for( tmpptr = savefilenameinzip; *tmpptr; tmpptr++)
-                     {
-                         if( *tmpptr == '\\' || *tmpptr == '/')
-                         {
-                             lastslash = tmpptr;
-                         }
-                     }
-                     if( lastslash != NULL )
-                     {
-                         savefilenameinzip = lastslash+1; // base filename follows last slash.
-                     }
-                 }
-
-                 /**/
-                err = zipOpenNewFileInZip3_64(zf,savefilenameinzip,&zi,
-                                 NULL,0,NULL,0,NULL /* comment*/,
-                                 (opt_compress_level != 0) ? Z_DEFLATED : 0,
-                                 opt_compress_level,0,
-                                 /* -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY, */
-                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
-                                 password,crcFile, zip64);
-
-                if (err != ZIP_OK)
-                    printf("error in opening %s in zipfile\n",filenameinzip);
-                else
-                {
-                    fin = FOPEN_FUNC(filenameinzip,"rb");
-                    if (fin==NULL)
-                    {
-                        err=ZIP_ERRNO;
-                        printf("error in opening %s for reading\n",filenameinzip);
-                    }
-                }
-
-                if (err == ZIP_OK)
-                    do
-                    {
-                        err = ZIP_OK;
-                        size_read = (int)fread(buf,1,size_buf,fin);
-                        if (size_read < size_buf)
-                            if (feof(fin)==0)
-                        {
-                            printf("error in reading %s\n",filenameinzip);
-                            err = ZIP_ERRNO;
-                        }
-
-                        if (size_read>0)
-                        {
-                            err = zipWriteInFileInZip (zf,buf,size_read);
-                            if (err<0)
-                            {
-                                printf("error in writing %s in the zipfile\n",
-                                                 filenameinzip);
-                            }
-
-                        }
-                    } while ((err == ZIP_OK) && (size_read>0));
-
-                if (fin)
-                    fclose(fin);
-
-                if (err<0)
-                    err=ZIP_ERRNO;
-                else
-                {
-                    err = zipCloseFileInZip(zf);
-                    if (err!=ZIP_OK)
-                        printf("error in closing %s in the zipfile\n",
-                                    filenameinzip);
-                }
-            }
-        }
-        errclose = zipClose(zf,NULL);
-        if (errclose != ZIP_OK)
-            printf("error in closing %s\n",filename_try);
-    }
-    else
-    {
-       do_help();
-    }
-
-    free(buf);
-    return 0;
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/minizip.pc.in gcc-4.8.1-ppc/zlib/contrib/minizip/minizip.pc.in
--- gcc-4.8.1/zlib/contrib/minizip/minizip.pc.in	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/minizip.pc.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,12 +0,0 @@
-prefix=@prefix@
-exec_prefix=@exec_prefix@
-libdir=@libdir@
-includedir=@includedir@/minizip
-
-Name: minizip
-Description: Minizip zip file manipulation library
-Requires:
-Version: @PACKAGE_VERSION@
-Libs: -L${libdir} -lminizip
-Libs.private: -lz
-Cflags: -I${includedir}
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/mztools.c gcc-4.8.1-ppc/zlib/contrib/minizip/mztools.c
--- gcc-4.8.1/zlib/contrib/minizip/mztools.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/mztools.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,291 +0,0 @@
-/*
-  Additional tools for Minizip
-  Code: Xavier Roche '2004
-  License: Same as ZLIB (www.gzip.org)
-*/
-
-/* Code */
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "zlib.h"
-#include "unzip.h"
-
-#define READ_8(adr)  ((unsigned char)*(adr))
-#define READ_16(adr) ( READ_8(adr) | (READ_8(adr+1) << 8) )
-#define READ_32(adr) ( READ_16(adr) | (READ_16((adr)+2) << 16) )
-
-#define WRITE_8(buff, n) do { \
-  *((unsigned char*)(buff)) = (unsigned char) ((n) & 0xff); \
-} while(0)
-#define WRITE_16(buff, n) do { \
-  WRITE_8((unsigned char*)(buff), n); \
-  WRITE_8(((unsigned char*)(buff)) + 1, (n) >> 8); \
-} while(0)
-#define WRITE_32(buff, n) do { \
-  WRITE_16((unsigned char*)(buff), (n) & 0xffff); \
-  WRITE_16((unsigned char*)(buff) + 2, (n) >> 16); \
-} while(0)
-
-extern int ZEXPORT unzRepair(file, fileOut, fileOutTmp, nRecovered, bytesRecovered)
-const char* file;
-const char* fileOut;
-const char* fileOutTmp;
-uLong* nRecovered;
-uLong* bytesRecovered;
-{
-  int err = Z_OK;
-  FILE* fpZip = fopen(file, "rb");
-  FILE* fpOut = fopen(fileOut, "wb");
-  FILE* fpOutCD = fopen(fileOutTmp, "wb");
-  if (fpZip != NULL &&  fpOut != NULL) {
-    int entries = 0;
-    uLong totalBytes = 0;
-    char header[30];
-    char filename[1024];
-    char extra[1024];
-    int offset = 0;
-    int offsetCD = 0;
-    while ( fread(header, 1, 30, fpZip) == 30 ) {
-      int currentOffset = offset;
-
-      /* File entry */
-      if (READ_32(header) == 0x04034b50) {
-        unsigned int version = READ_16(header + 4);
-        unsigned int gpflag = READ_16(header + 6);
-        unsigned int method = READ_16(header + 8);
-        unsigned int filetime = READ_16(header + 10);
-        unsigned int filedate = READ_16(header + 12);
-        unsigned int crc = READ_32(header + 14); /* crc */
-        unsigned int cpsize = READ_32(header + 18); /* compressed size */
-        unsigned int uncpsize = READ_32(header + 22); /* uncompressed sz */
-        unsigned int fnsize = READ_16(header + 26); /* file name length */
-        unsigned int extsize = READ_16(header + 28); /* extra field length */
-        filename[0] = extra[0] = '\0';
-
-        /* Header */
-        if (fwrite(header, 1, 30, fpOut) == 30) {
-          offset += 30;
-        } else {
-          err = Z_ERRNO;
-          break;
-        }
-
-        /* Filename */
-        if (fnsize > 0) {
-          if (fnsize < sizeof(filename)) {
-            if (fread(filename, 1, fnsize, fpZip) == fnsize) {
-                if (fwrite(filename, 1, fnsize, fpOut) == fnsize) {
-                offset += fnsize;
-              } else {
-                err = Z_ERRNO;
-                break;
-              }
-            } else {
-              err = Z_ERRNO;
-              break;
-            }
-          } else {
-            err = Z_ERRNO;
-            break;
-          }
-        } else {
-          err = Z_STREAM_ERROR;
-          break;
-        }
-
-        /* Extra field */
-        if (extsize > 0) {
-          if (extsize < sizeof(extra)) {
-            if (fread(extra, 1, extsize, fpZip) == extsize) {
-              if (fwrite(extra, 1, extsize, fpOut) == extsize) {
-                offset += extsize;
-                } else {
-                err = Z_ERRNO;
-                break;
-              }
-            } else {
-              err = Z_ERRNO;
-              break;
-            }
-          } else {
-            err = Z_ERRNO;
-            break;
-          }
-        }
-
-        /* Data */
-        {
-          int dataSize = cpsize;
-          if (dataSize == 0) {
-            dataSize = uncpsize;
-          }
-          if (dataSize > 0) {
-            char* data = malloc(dataSize);
-            if (data != NULL) {
-              if ((int)fread(data, 1, dataSize, fpZip) == dataSize) {
-                if ((int)fwrite(data, 1, dataSize, fpOut) == dataSize) {
-                  offset += dataSize;
-                  totalBytes += dataSize;
-                } else {
-                  err = Z_ERRNO;
-                }
-              } else {
-                err = Z_ERRNO;
-              }
-              free(data);
-              if (err != Z_OK) {
-                break;
-              }
-            } else {
-              err = Z_MEM_ERROR;
-              break;
-            }
-          }
-        }
-
-        /* Central directory entry */
-        {
-          char header[46];
-          char* comment = "";
-          int comsize = (int) strlen(comment);
-          WRITE_32(header, 0x02014b50);
-          WRITE_16(header + 4, version);
-          WRITE_16(header + 6, version);
-          WRITE_16(header + 8, gpflag);
-          WRITE_16(header + 10, method);
-          WRITE_16(header + 12, filetime);
-          WRITE_16(header + 14, filedate);
-          WRITE_32(header + 16, crc);
-          WRITE_32(header + 20, cpsize);
-          WRITE_32(header + 24, uncpsize);
-          WRITE_16(header + 28, fnsize);
-          WRITE_16(header + 30, extsize);
-          WRITE_16(header + 32, comsize);
-          WRITE_16(header + 34, 0);     /* disk # */
-          WRITE_16(header + 36, 0);     /* int attrb */
-          WRITE_32(header + 38, 0);     /* ext attrb */
-          WRITE_32(header + 42, currentOffset);
-          /* Header */
-          if (fwrite(header, 1, 46, fpOutCD) == 46) {
-            offsetCD += 46;
-
-            /* Filename */
-            if (fnsize > 0) {
-              if (fwrite(filename, 1, fnsize, fpOutCD) == fnsize) {
-                offsetCD += fnsize;
-              } else {
-                err = Z_ERRNO;
-                break;
-              }
-            } else {
-              err = Z_STREAM_ERROR;
-              break;
-            }
-
-            /* Extra field */
-            if (extsize > 0) {
-              if (fwrite(extra, 1, extsize, fpOutCD) == extsize) {
-                offsetCD += extsize;
-              } else {
-                err = Z_ERRNO;
-                break;
-              }
-            }
-
-            /* Comment field */
-            if (comsize > 0) {
-              if ((int)fwrite(comment, 1, comsize, fpOutCD) == comsize) {
-                offsetCD += comsize;
-              } else {
-                err = Z_ERRNO;
-                break;
-              }
-            }
-
-
-          } else {
-            err = Z_ERRNO;
-            break;
-          }
-        }
-
-        /* Success */
-        entries++;
-
-      } else {
-        break;
-      }
-    }
-
-    /* Final central directory  */
-    {
-      int entriesZip = entries;
-      char header[22];
-      char* comment = ""; // "ZIP File recovered by zlib/minizip/mztools";
-      int comsize = (int) strlen(comment);
-      if (entriesZip > 0xffff) {
-        entriesZip = 0xffff;
-      }
-      WRITE_32(header, 0x06054b50);
-      WRITE_16(header + 4, 0);    /* disk # */
-      WRITE_16(header + 6, 0);    /* disk # */
-      WRITE_16(header + 8, entriesZip);   /* hack */
-      WRITE_16(header + 10, entriesZip);  /* hack */
-      WRITE_32(header + 12, offsetCD);    /* size of CD */
-      WRITE_32(header + 16, offset);      /* offset to CD */
-      WRITE_16(header + 20, comsize);     /* comment */
-
-      /* Header */
-      if (fwrite(header, 1, 22, fpOutCD) == 22) {
-
-        /* Comment field */
-        if (comsize > 0) {
-          if ((int)fwrite(comment, 1, comsize, fpOutCD) != comsize) {
-            err = Z_ERRNO;
-          }
-        }
-
-      } else {
-        err = Z_ERRNO;
-      }
-    }
-
-    /* Final merge (file + central directory) */
-    fclose(fpOutCD);
-    if (err == Z_OK) {
-      fpOutCD = fopen(fileOutTmp, "rb");
-      if (fpOutCD != NULL) {
-        int nRead;
-        char buffer[8192];
-        while ( (nRead = (int)fread(buffer, 1, sizeof(buffer), fpOutCD)) > 0) {
-          if ((int)fwrite(buffer, 1, nRead, fpOut) != nRead) {
-            err = Z_ERRNO;
-            break;
-          }
-        }
-        fclose(fpOutCD);
-      }
-    }
-
-    /* Close */
-    fclose(fpZip);
-    fclose(fpOut);
-
-    /* Wipe temporary file */
-    (void)remove(fileOutTmp);
-
-    /* Number of recovered entries */
-    if (err == Z_OK) {
-      if (nRecovered != NULL) {
-        *nRecovered = entries;
-      }
-      if (bytesRecovered != NULL) {
-        *bytesRecovered = totalBytes;
-      }
-    }
-  } else {
-    err = Z_STREAM_ERROR;
-  }
-  return err;
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/mztools.h gcc-4.8.1-ppc/zlib/contrib/minizip/mztools.h
--- gcc-4.8.1/zlib/contrib/minizip/mztools.h	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/mztools.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
-/*
-  Additional tools for Minizip
-  Code: Xavier Roche '2004
-  License: Same as ZLIB (www.gzip.org)
-*/
-
-#ifndef _zip_tools_H
-#define _zip_tools_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef _ZLIB_H
-#include "zlib.h"
-#endif
-
-#include "unzip.h"
-
-/* Repair a ZIP file (missing central directory)
-   file: file to recover
-   fileOut: output file after recovery
-   fileOutTmp: temporary file name used for recovery
-*/
-extern int ZEXPORT unzRepair(const char* file,
-                             const char* fileOut,
-                             const char* fileOutTmp,
-                             uLong* nRecovered,
-                             uLong* bytesRecovered);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-#endif
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/unzip.c gcc-4.8.1-ppc/zlib/contrib/minizip/unzip.c
--- gcc-4.8.1/zlib/contrib/minizip/unzip.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/unzip.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2125 +0,0 @@
-/* unzip.c -- IO for uncompress .zip files using zlib
-   Version 1.1, February 14h, 2010
-   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications of Unzip for Zip64
-         Copyright (C) 2007-2008 Even Rouault
-
-         Modifications for Zip64 support on both zip and unzip
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-         For more info read MiniZip_info.txt
-
-
-  ------------------------------------------------------------------------------------
-  Decryption code comes from crypt.c by Info-ZIP but has been greatly reduced in terms of
-  compatibility with older software. The following is from the original crypt.c.
-  Code woven in by Terry Thorsen 1/2003.
-
-  Copyright (c) 1990-2000 Info-ZIP.  All rights reserved.
-
-  See the accompanying file LICENSE, version 2000-Apr-09 or later
-  (the contents of which are also included in zip.h) for terms of use.
-  If, for some reason, all these files are missing, the Info-ZIP license
-  also may be found at:  ftp://ftp.info-zip.org/pub/infozip/license.html
-
-        crypt.c (full version) by Info-ZIP.      Last revised:  [see crypt.h]
-
-  The encryption/decryption parts of this source code (as opposed to the
-  non-echoing password parts) were originally written in Europe.  The
-  whole source package can be freely distributed, including from the USA.
-  (Prior to January 2000, re-export from the US was a violation of US law.)
-
-        This encryption code is a direct transcription of the algorithm from
-  Roger Schlafly, described by Phil Katz in the file appnote.txt.  This
-  file (appnote.txt) is distributed with the PKZIP program (even in the
-  version without encryption capabilities).
-
-        ------------------------------------------------------------------------------------
-
-        Changes in unzip.c
-
-        2007-2008 - Even Rouault - Addition of cpl_unzGetCurrentFileZStreamPos
-  2007-2008 - Even Rouault - Decoration of symbol names unz* -> cpl_unz*
-  2007-2008 - Even Rouault - Remove old C style function prototypes
-  2007-2008 - Even Rouault - Add unzip support for ZIP64
-
-        Copyright (C) 2007-2008 Even Rouault
-
-
-        Oct-2009 - Mathias Svensson - Removed cpl_* from symbol names (Even Rouault added them but since this is now moved to a new project (minizip64) I renamed them again).
-  Oct-2009 - Mathias Svensson - Fixed problem if uncompressed size was > 4G and compressed size was <4G
-                                should only read the compressed/uncompressed size from the Zip64 format if
-                                the size from normal header was 0xFFFFFFFF
-  Oct-2009 - Mathias Svensson - Applied some bug fixes from paches recived from Gilles Vollant
-        Oct-2009 - Mathias Svensson - Applied support to unzip files with compression mathod BZIP2 (bzip2 lib is required)
-                                Patch created by Daniel Borca
-
-  Jan-2010 - back to unzip and minizip 1.0 name scheme, with compatibility layer
-
-  Copyright (C) 1998 - 2010 Gilles Vollant, Even Rouault, Mathias Svensson
-
-*/
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#ifndef NOUNCRYPT
-        #define NOUNCRYPT
-#endif
-
-#include "zlib.h"
-#include "unzip.h"
-
-#ifdef STDC
-#  include <stddef.h>
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-#ifdef NO_ERRNO_H
-    extern int errno;
-#else
-#   include <errno.h>
-#endif
-
-
-#ifndef local
-#  define local static
-#endif
-/* compile with -Dlocal if your debugger can't find static symbols */
-
-
-#ifndef CASESENSITIVITYDEFAULT_NO
-#  if !defined(unix) && !defined(CASESENSITIVITYDEFAULT_YES)
-#    define CASESENSITIVITYDEFAULT_NO
-#  endif
-#endif
-
-
-#ifndef UNZ_BUFSIZE
-#define UNZ_BUFSIZE (16384)
-#endif
-
-#ifndef UNZ_MAXFILENAMEINZIP
-#define UNZ_MAXFILENAMEINZIP (256)
-#endif
-
-#ifndef ALLOC
-# define ALLOC(size) (malloc(size))
-#endif
-#ifndef TRYFREE
-# define TRYFREE(p) {if (p) free(p);}
-#endif
-
-#define SIZECENTRALDIRITEM (0x2e)
-#define SIZEZIPLOCALHEADER (0x1e)
-
-
-const char unz_copyright[] =
-   " unzip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll";
-
-/* unz_file_info_interntal contain internal info about a file in zipfile*/
-typedef struct unz_file_info64_internal_s
-{
-    ZPOS64_T offset_curfile;/* relative offset of local header 8 bytes */
-} unz_file_info64_internal;
-
-
-/* file_in_zip_read_info_s contain internal information about a file in zipfile,
-    when reading and decompress it */
-typedef struct
-{
-    char  *read_buffer;         /* internal buffer for compressed data */
-    z_stream stream;            /* zLib stream structure for inflate */
-
-#ifdef HAVE_BZIP2
-    bz_stream bstream;          /* bzLib stream structure for bziped */
-#endif
-
-    ZPOS64_T pos_in_zipfile;       /* position in byte on the zipfile, for fseek*/
-    uLong stream_initialised;   /* flag set if stream structure is initialised*/
-
-    ZPOS64_T offset_local_extrafield;/* offset of the local extra field */
-    uInt  size_local_extrafield;/* size of the local extra field */
-    ZPOS64_T pos_local_extrafield;   /* position in the local extra field in read*/
-    ZPOS64_T total_out_64;
-
-    uLong crc32;                /* crc32 of all data uncompressed */
-    uLong crc32_wait;           /* crc32 we must obtain after decompress all */
-    ZPOS64_T rest_read_compressed; /* number of byte to be decompressed */
-    ZPOS64_T rest_read_uncompressed;/*number of byte to be obtained after decomp*/
-    zlib_filefunc64_32_def z_filefunc;
-    voidpf filestream;        /* io structore of the zipfile */
-    uLong compression_method;   /* compression method (0==store) */
-    ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
-    int   raw;
-} file_in_zip64_read_info_s;
-
-
-/* unz64_s contain internal information about the zipfile
-*/
-typedef struct
-{
-    zlib_filefunc64_32_def z_filefunc;
-    int is64bitOpenFunction;
-    voidpf filestream;        /* io structore of the zipfile */
-    unz_global_info64 gi;       /* public global information */
-    ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
-    ZPOS64_T num_file;             /* number of the current file in the zipfile*/
-    ZPOS64_T pos_in_central_dir;   /* pos of the current file in the central dir*/
-    ZPOS64_T current_file_ok;      /* flag about the usability of the current file*/
-    ZPOS64_T central_pos;          /* position of the beginning of the central dir*/
-
-    ZPOS64_T size_central_dir;     /* size of the central directory  */
-    ZPOS64_T offset_central_dir;   /* offset of start of central directory with
-                                   respect to the starting disk number */
-
-    unz_file_info64 cur_file_info; /* public info about the current file in zip*/
-    unz_file_info64_internal cur_file_info_internal; /* private info about it*/
-    file_in_zip64_read_info_s* pfile_in_zip_read; /* structure about the current
-                                        file if we are decompressing it */
-    int encrypted;
-
-    int isZip64;
-
-#    ifndef NOUNCRYPT
-    unsigned long keys[3];     /* keys defining the pseudo-random sequence */
-    const unsigned long* pcrc_32_tab;
-#    endif
-} unz64_s;
-
-
-#ifndef NOUNCRYPT
-#include "crypt.h"
-#endif
-
-/* ===========================================================================
-     Read a byte from a gz_stream; update next_in and avail_in. Return EOF
-   for end of file.
-   IN assertion: the stream s has been sucessfully opened for reading.
-*/
-
-
-local int unz64local_getByte OF((
-    const zlib_filefunc64_32_def* pzlib_filefunc_def,
-    voidpf filestream,
-    int *pi));
-
-local int unz64local_getByte(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, int *pi)
-{
-    unsigned char c;
-    int err = (int)ZREAD64(*pzlib_filefunc_def,filestream,&c,1);
-    if (err==1)
-    {
-        *pi = (int)c;
-        return UNZ_OK;
-    }
-    else
-    {
-        if (ZERROR64(*pzlib_filefunc_def,filestream))
-            return UNZ_ERRNO;
-        else
-            return UNZ_EOF;
-    }
-}
-
-
-/* ===========================================================================
-   Reads a long in LSB order from the given gz_stream. Sets
-*/
-local int unz64local_getShort OF((
-    const zlib_filefunc64_32_def* pzlib_filefunc_def,
-    voidpf filestream,
-    uLong *pX));
-
-local int unz64local_getShort (const zlib_filefunc64_32_def* pzlib_filefunc_def,
-                             voidpf filestream,
-                             uLong *pX)
-{
-    uLong x ;
-    int i = 0;
-    int err;
-
-    err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x = (uLong)i;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((uLong)i)<<8;
-
-    if (err==UNZ_OK)
-        *pX = x;
-    else
-        *pX = 0;
-    return err;
-}
-
-local int unz64local_getLong OF((
-    const zlib_filefunc64_32_def* pzlib_filefunc_def,
-    voidpf filestream,
-    uLong *pX));
-
-local int unz64local_getLong (const zlib_filefunc64_32_def* pzlib_filefunc_def,
-                            voidpf filestream,
-                            uLong *pX)
-{
-    uLong x ;
-    int i = 0;
-    int err;
-
-    err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x = (uLong)i;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((uLong)i)<<8;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((uLong)i)<<16;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<24;
-
-    if (err==UNZ_OK)
-        *pX = x;
-    else
-        *pX = 0;
-    return err;
-}
-
-local int unz64local_getLong64 OF((
-    const zlib_filefunc64_32_def* pzlib_filefunc_def,
-    voidpf filestream,
-    ZPOS64_T *pX));
-
-
-local int unz64local_getLong64 (const zlib_filefunc64_32_def* pzlib_filefunc_def,
-                            voidpf filestream,
-                            ZPOS64_T *pX)
-{
-    ZPOS64_T x ;
-    int i = 0;
-    int err;
-
-    err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x = (ZPOS64_T)i;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((ZPOS64_T)i)<<8;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((ZPOS64_T)i)<<16;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((ZPOS64_T)i)<<24;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((ZPOS64_T)i)<<32;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((ZPOS64_T)i)<<40;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((ZPOS64_T)i)<<48;
-
-    if (err==UNZ_OK)
-        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x |= ((ZPOS64_T)i)<<56;
-
-    if (err==UNZ_OK)
-        *pX = x;
-    else
-        *pX = 0;
-    return err;
-}
-
-/* My own strcmpi / strcasecmp */
-local int strcmpcasenosensitive_internal (const char* fileName1, const char* fileName2)
-{
-    for (;;)
-    {
-        char c1=*(fileName1++);
-        char c2=*(fileName2++);
-        if ((c1>='a') && (c1<='z'))
-            c1 -= 0x20;
-        if ((c2>='a') && (c2<='z'))
-            c2 -= 0x20;
-        if (c1=='\0')
-            return ((c2=='\0') ? 0 : -1);
-        if (c2=='\0')
-            return 1;
-        if (c1<c2)
-            return -1;
-        if (c1>c2)
-            return 1;
-    }
-}
-
-
-#ifdef  CASESENSITIVITYDEFAULT_NO
-#define CASESENSITIVITYDEFAULTVALUE 2
-#else
-#define CASESENSITIVITYDEFAULTVALUE 1
-#endif
-
-#ifndef STRCMPCASENOSENTIVEFUNCTION
-#define STRCMPCASENOSENTIVEFUNCTION strcmpcasenosensitive_internal
-#endif
-
-/*
-   Compare two filename (fileName1,fileName2).
-   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
-   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
-                                                                or strcasecmp)
-   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
-        (like 1 on Unix, 2 on Windows)
-
-*/
-extern int ZEXPORT unzStringFileNameCompare (const char*  fileName1,
-                                                 const char*  fileName2,
-                                                 int iCaseSensitivity)
-
-{
-    if (iCaseSensitivity==0)
-        iCaseSensitivity=CASESENSITIVITYDEFAULTVALUE;
-
-    if (iCaseSensitivity==1)
-        return strcmp(fileName1,fileName2);
-
-    return STRCMPCASENOSENTIVEFUNCTION(fileName1,fileName2);
-}
-
-#ifndef BUFREADCOMMENT
-#define BUFREADCOMMENT (0x400)
-#endif
-
-/*
-  Locate the Central directory of a zipfile (at the end, just before
-    the global comment)
-*/
-local ZPOS64_T unz64local_SearchCentralDir OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream));
-local ZPOS64_T unz64local_SearchCentralDir(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)
-{
-    unsigned char* buf;
-    ZPOS64_T uSizeFile;
-    ZPOS64_T uBackRead;
-    ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */
-    ZPOS64_T uPosFound=0;
-
-    if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
-        return 0;
-
-
-    uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);
-
-    if (uMaxBack>uSizeFile)
-        uMaxBack = uSizeFile;
-
-    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
-    if (buf==NULL)
-        return 0;
-
-    uBackRead = 4;
-    while (uBackRead<uMaxBack)
-    {
-        uLong uReadSize;
-        ZPOS64_T uReadPos ;
-        int i;
-        if (uBackRead+BUFREADCOMMENT>uMaxBack)
-            uBackRead = uMaxBack;
-        else
-            uBackRead+=BUFREADCOMMENT;
-        uReadPos = uSizeFile-uBackRead ;
-
-        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
-                     (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
-        if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            break;
-
-        if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
-            break;
-
-        for (i=(int)uReadSize-3; (i--)>0;)
-            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&
-                ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))
-            {
-                uPosFound = uReadPos+i;
-                break;
-            }
-
-        if (uPosFound!=0)
-            break;
-    }
-    TRYFREE(buf);
-    return uPosFound;
-}
-
-
-/*
-  Locate the Central directory 64 of a zipfile (at the end, just before
-    the global comment)
-*/
-local ZPOS64_T unz64local_SearchCentralDir64 OF((
-    const zlib_filefunc64_32_def* pzlib_filefunc_def,
-    voidpf filestream));
-
-local ZPOS64_T unz64local_SearchCentralDir64(const zlib_filefunc64_32_def* pzlib_filefunc_def,
-                                      voidpf filestream)
-{
-    unsigned char* buf;
-    ZPOS64_T uSizeFile;
-    ZPOS64_T uBackRead;
-    ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */
-    ZPOS64_T uPosFound=0;
-    uLong uL;
-                ZPOS64_T relativeOffset;
-
-    if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
-        return 0;
-
-
-    uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);
-
-    if (uMaxBack>uSizeFile)
-        uMaxBack = uSizeFile;
-
-    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
-    if (buf==NULL)
-        return 0;
-
-    uBackRead = 4;
-    while (uBackRead<uMaxBack)
-    {
-        uLong uReadSize;
-        ZPOS64_T uReadPos;
-        int i;
-        if (uBackRead+BUFREADCOMMENT>uMaxBack)
-            uBackRead = uMaxBack;
-        else
-            uBackRead+=BUFREADCOMMENT;
-        uReadPos = uSizeFile-uBackRead ;
-
-        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
-                     (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
-        if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            break;
-
-        if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
-            break;
-
-        for (i=(int)uReadSize-3; (i--)>0;)
-            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&
-                ((*(buf+i+2))==0x06) && ((*(buf+i+3))==0x07))
-            {
-                uPosFound = uReadPos+i;
-                break;
-            }
-
-        if (uPosFound!=0)
-            break;
-    }
-    TRYFREE(buf);
-    if (uPosFound == 0)
-        return 0;
-
-    /* Zip64 end of central directory locator */
-    if (ZSEEK64(*pzlib_filefunc_def,filestream, uPosFound,ZLIB_FILEFUNC_SEEK_SET)!=0)
-        return 0;
-
-    /* the signature, already checked */
-    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)
-        return 0;
-
-    /* number of the disk with the start of the zip64 end of  central directory */
-    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)
-        return 0;
-    if (uL != 0)
-        return 0;
-
-    /* relative offset of the zip64 end of central directory record */
-    if (unz64local_getLong64(pzlib_filefunc_def,filestream,&relativeOffset)!=UNZ_OK)
-        return 0;
-
-    /* total number of disks */
-    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)
-        return 0;
-    if (uL != 1)
-        return 0;
-
-    /* Goto end of central directory record */
-    if (ZSEEK64(*pzlib_filefunc_def,filestream, relativeOffset,ZLIB_FILEFUNC_SEEK_SET)!=0)
-        return 0;
-
-     /* the signature */
-    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)
-        return 0;
-
-    if (uL != 0x06064b50)
-        return 0;
-
-    return relativeOffset;
-}
-
-/*
-  Open a Zip file. path contain the full pathname (by example,
-     on a Windows NT computer "c:\\test\\zlib114.zip" or on an Unix computer
-     "zlib/zlib114.zip".
-     If the zipfile cannot be opened (file doesn't exist or in not valid), the
-       return value is NULL.
-     Else, the return value is a unzFile Handle, usable with other function
-       of this unzip package.
-*/
-local unzFile unzOpenInternal (const void *path,
-                               zlib_filefunc64_32_def* pzlib_filefunc64_32_def,
-                               int is64bitOpenFunction)
-{
-    unz64_s us;
-    unz64_s *s;
-    ZPOS64_T central_pos;
-    uLong   uL;
-
-    uLong number_disk;          /* number of the current dist, used for
-                                   spaning ZIP, unsupported, always 0*/
-    uLong number_disk_with_CD;  /* number the the disk with central dir, used
-                                   for spaning ZIP, unsupported, always 0*/
-    ZPOS64_T number_entry_CD;      /* total number of entries in
-                                   the central dir
-                                   (same than number_entry on nospan) */
-
-    int err=UNZ_OK;
-
-    if (unz_copyright[0]!=' ')
-        return NULL;
-
-    us.z_filefunc.zseek32_file = NULL;
-    us.z_filefunc.ztell32_file = NULL;
-    if (pzlib_filefunc64_32_def==NULL)
-        fill_fopen64_filefunc(&us.z_filefunc.zfile_func64);
-    else
-        us.z_filefunc = *pzlib_filefunc64_32_def;
-    us.is64bitOpenFunction = is64bitOpenFunction;
-
-
-
-    us.filestream = ZOPEN64(us.z_filefunc,
-                                                 path,
-                                                 ZLIB_FILEFUNC_MODE_READ |
-                                                 ZLIB_FILEFUNC_MODE_EXISTING);
-    if (us.filestream==NULL)
-        return NULL;
-
-    central_pos = unz64local_SearchCentralDir64(&us.z_filefunc,us.filestream);
-    if (central_pos)
-    {
-        uLong uS;
-        ZPOS64_T uL64;
-
-        us.isZip64 = 1;
-
-        if (ZSEEK64(us.z_filefunc, us.filestream,
-                                      central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-        err=UNZ_ERRNO;
-
-        /* the signature, already checked */
-        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* size of zip64 end of central directory record */
-        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&uL64)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* version made by */
-        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* version needed to extract */
-        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* number of this disk */
-        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* number of the disk with the start of the central directory */
-        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* total number of entries in the central directory on this disk */
-        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.gi.number_entry)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* total number of entries in the central directory */
-        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&number_entry_CD)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        if ((number_entry_CD!=us.gi.number_entry) ||
-            (number_disk_with_CD!=0) ||
-            (number_disk!=0))
-            err=UNZ_BADZIPFILE;
-
-        /* size of the central directory */
-        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.size_central_dir)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* offset of start of central directory with respect to the
-          starting disk number */
-        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.offset_central_dir)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        us.gi.size_comment = 0;
-    }
-    else
-    {
-        central_pos = unz64local_SearchCentralDir(&us.z_filefunc,us.filestream);
-        if (central_pos==0)
-            err=UNZ_ERRNO;
-
-        us.isZip64 = 0;
-
-        if (ZSEEK64(us.z_filefunc, us.filestream,
-                                        central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            err=UNZ_ERRNO;
-
-        /* the signature, already checked */
-        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* number of this disk */
-        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* number of the disk with the start of the central directory */
-        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)
-            err=UNZ_ERRNO;
-
-        /* total number of entries in the central dir on this disk */
-        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
-            err=UNZ_ERRNO;
-        us.gi.number_entry = uL;
-
-        /* total number of entries in the central dir */
-        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
-            err=UNZ_ERRNO;
-        number_entry_CD = uL;
-
-        if ((number_entry_CD!=us.gi.number_entry) ||
-            (number_disk_with_CD!=0) ||
-            (number_disk!=0))
-            err=UNZ_BADZIPFILE;
-
-        /* size of the central directory */
-        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
-            err=UNZ_ERRNO;
-        us.size_central_dir = uL;
-
-        /* offset of start of central directory with respect to the
-            starting disk number */
-        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
-            err=UNZ_ERRNO;
-        us.offset_central_dir = uL;
-
-        /* zipfile comment length */
-        if (unz64local_getShort(&us.z_filefunc, us.filestream,&us.gi.size_comment)!=UNZ_OK)
-            err=UNZ_ERRNO;
-    }
-
-    if ((central_pos<us.offset_central_dir+us.size_central_dir) &&
-        (err==UNZ_OK))
-        err=UNZ_BADZIPFILE;
-
-    if (err!=UNZ_OK)
-    {
-        ZCLOSE64(us.z_filefunc, us.filestream);
-        return NULL;
-    }
-
-    us.byte_before_the_zipfile = central_pos -
-                            (us.offset_central_dir+us.size_central_dir);
-    us.central_pos = central_pos;
-    us.pfile_in_zip_read = NULL;
-    us.encrypted = 0;
-
-
-    s=(unz64_s*)ALLOC(sizeof(unz64_s));
-    if( s != NULL)
-    {
-        *s=us;
-        unzGoToFirstFile((unzFile)s);
-    }
-    return (unzFile)s;
-}
-
-
-extern unzFile ZEXPORT unzOpen2 (const char *path,
-                                        zlib_filefunc_def* pzlib_filefunc32_def)
-{
-    if (pzlib_filefunc32_def != NULL)
-    {
-        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
-        fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill,pzlib_filefunc32_def);
-        return unzOpenInternal(path, &zlib_filefunc64_32_def_fill, 0);
-    }
-    else
-        return unzOpenInternal(path, NULL, 0);
-}
-
-extern unzFile ZEXPORT unzOpen2_64 (const void *path,
-                                     zlib_filefunc64_def* pzlib_filefunc_def)
-{
-    if (pzlib_filefunc_def != NULL)
-    {
-        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
-        zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;
-        zlib_filefunc64_32_def_fill.ztell32_file = NULL;
-        zlib_filefunc64_32_def_fill.zseek32_file = NULL;
-        return unzOpenInternal(path, &zlib_filefunc64_32_def_fill, 1);
-    }
-    else
-        return unzOpenInternal(path, NULL, 1);
-}
-
-extern unzFile ZEXPORT unzOpen (const char *path)
-{
-    return unzOpenInternal(path, NULL, 0);
-}
-
-extern unzFile ZEXPORT unzOpen64 (const void *path)
-{
-    return unzOpenInternal(path, NULL, 1);
-}
-
-/*
-  Close a ZipFile opened with unzipOpen.
-  If there is files inside the .Zip opened with unzipOpenCurrentFile (see later),
-    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.
-  return UNZ_OK if there is no problem. */
-extern int ZEXPORT unzClose (unzFile file)
-{
-    unz64_s* s;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-
-    if (s->pfile_in_zip_read!=NULL)
-        unzCloseCurrentFile(file);
-
-    ZCLOSE64(s->z_filefunc, s->filestream);
-    TRYFREE(s);
-    return UNZ_OK;
-}
-
-
-/*
-  Write info about the ZipFile in the *pglobal_info structure.
-  No preparation of the structure is needed
-  return UNZ_OK if there is no problem. */
-extern int ZEXPORT unzGetGlobalInfo64 (unzFile file, unz_global_info64* pglobal_info)
-{
-    unz64_s* s;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    *pglobal_info=s->gi;
-    return UNZ_OK;
-}
-
-extern int ZEXPORT unzGetGlobalInfo (unzFile file, unz_global_info* pglobal_info32)
-{
-    unz64_s* s;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    /* to do : check if number_entry is not truncated */
-    pglobal_info32->number_entry = (uLong)s->gi.number_entry;
-    pglobal_info32->size_comment = s->gi.size_comment;
-    return UNZ_OK;
-}
-/*
-   Translate date/time from Dos format to tm_unz (readable more easilty)
-*/
-local void unz64local_DosDateToTmuDate (ZPOS64_T ulDosDate, tm_unz* ptm)
-{
-    ZPOS64_T uDate;
-    uDate = (ZPOS64_T)(ulDosDate>>16);
-    ptm->tm_mday = (uInt)(uDate&0x1f) ;
-    ptm->tm_mon =  (uInt)((((uDate)&0x1E0)/0x20)-1) ;
-    ptm->tm_year = (uInt)(((uDate&0x0FE00)/0x0200)+1980) ;
-
-    ptm->tm_hour = (uInt) ((ulDosDate &0xF800)/0x800);
-    ptm->tm_min =  (uInt) ((ulDosDate&0x7E0)/0x20) ;
-    ptm->tm_sec =  (uInt) (2*(ulDosDate&0x1f)) ;
-}
-
-/*
-  Get Info about the current file in the zipfile, with internal only info
-*/
-local int unz64local_GetCurrentFileInfoInternal OF((unzFile file,
-                                                  unz_file_info64 *pfile_info,
-                                                  unz_file_info64_internal
-                                                  *pfile_info_internal,
-                                                  char *szFileName,
-                                                  uLong fileNameBufferSize,
-                                                  void *extraField,
-                                                  uLong extraFieldBufferSize,
-                                                  char *szComment,
-                                                  uLong commentBufferSize));
-
-local int unz64local_GetCurrentFileInfoInternal (unzFile file,
-                                                  unz_file_info64 *pfile_info,
-                                                  unz_file_info64_internal
-                                                  *pfile_info_internal,
-                                                  char *szFileName,
-                                                  uLong fileNameBufferSize,
-                                                  void *extraField,
-                                                  uLong extraFieldBufferSize,
-                                                  char *szComment,
-                                                  uLong commentBufferSize)
-{
-    unz64_s* s;
-    unz_file_info64 file_info;
-    unz_file_info64_internal file_info_internal;
-    int err=UNZ_OK;
-    uLong uMagic;
-    long lSeek=0;
-    uLong uL;
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    if (ZSEEK64(s->z_filefunc, s->filestream,
-              s->pos_in_central_dir+s->byte_before_the_zipfile,
-              ZLIB_FILEFUNC_SEEK_SET)!=0)
-        err=UNZ_ERRNO;
-
-
-    /* we check the magic */
-    if (err==UNZ_OK)
-    {
-        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)
-            err=UNZ_ERRNO;
-        else if (uMagic!=0x02014b50)
-            err=UNZ_BADZIPFILE;
-    }
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.version) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.version_needed) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.flag) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.compression_method) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.dosDate) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    unz64local_DosDateToTmuDate(file_info.dosDate,&file_info.tmu_date);
-
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.crc) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)
-        err=UNZ_ERRNO;
-    file_info.compressed_size = uL;
-
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)
-        err=UNZ_ERRNO;
-    file_info.uncompressed_size = uL;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_filename) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_extra) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_comment) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.disk_num_start) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.internal_fa) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.external_fa) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-                // relative offset of local header
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)
-        err=UNZ_ERRNO;
-    file_info_internal.offset_curfile = uL;
-
-    lSeek+=file_info.size_filename;
-    if ((err==UNZ_OK) && (szFileName!=NULL))
-    {
-        uLong uSizeRead ;
-        if (file_info.size_filename<fileNameBufferSize)
-        {
-            *(szFileName+file_info.size_filename)='\0';
-            uSizeRead = file_info.size_filename;
-        }
-        else
-            uSizeRead = fileNameBufferSize;
-
-        if ((file_info.size_filename>0) && (fileNameBufferSize>0))
-            if (ZREAD64(s->z_filefunc, s->filestream,szFileName,uSizeRead)!=uSizeRead)
-                err=UNZ_ERRNO;
-        lSeek -= uSizeRead;
-    }
-
-    // Read extrafield
-    if ((err==UNZ_OK) && (extraField!=NULL))
-    {
-        ZPOS64_T uSizeRead ;
-        if (file_info.size_file_extra<extraFieldBufferSize)
-            uSizeRead = file_info.size_file_extra;
-        else
-            uSizeRead = extraFieldBufferSize;
-
-        if (lSeek!=0)
-        {
-            if (ZSEEK64(s->z_filefunc, s->filestream,lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)
-                lSeek=0;
-            else
-                err=UNZ_ERRNO;
-        }
-
-        if ((file_info.size_file_extra>0) && (extraFieldBufferSize>0))
-            if (ZREAD64(s->z_filefunc, s->filestream,extraField,(uLong)uSizeRead)!=uSizeRead)
-                err=UNZ_ERRNO;
-
-        lSeek += file_info.size_file_extra - (uLong)uSizeRead;
-    }
-    else
-        lSeek += file_info.size_file_extra;
-
-
-    if ((err==UNZ_OK) && (file_info.size_file_extra != 0))
-    {
-                                uLong acc = 0;
-
-        // since lSeek now points to after the extra field we need to move back
-        lSeek -= file_info.size_file_extra;
-
-        if (lSeek!=0)
-        {
-            if (ZSEEK64(s->z_filefunc, s->filestream,lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)
-                lSeek=0;
-            else
-                err=UNZ_ERRNO;
-        }
-
-        while(acc < file_info.size_file_extra)
-        {
-            uLong headerId;
-                                                uLong dataSize;
-
-            if (unz64local_getShort(&s->z_filefunc, s->filestream,&headerId) != UNZ_OK)
-                err=UNZ_ERRNO;
-
-            if (unz64local_getShort(&s->z_filefunc, s->filestream,&dataSize) != UNZ_OK)
-                err=UNZ_ERRNO;
-
-            /* ZIP64 extra fields */
-            if (headerId == 0x0001)
-            {
-                                                        uLong uL;
-
-                                                                if(file_info.uncompressed_size == MAXU32)
-                                                                {
-                                                                        if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info.uncompressed_size) != UNZ_OK)
-                                                                                        err=UNZ_ERRNO;
-                                                                }
-
-                                                                if(file_info.compressed_size == MAXU32)
-                                                                {
-                                                                        if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info.compressed_size) != UNZ_OK)
-                                                                                  err=UNZ_ERRNO;
-                                                                }
-
-                                                                if(file_info_internal.offset_curfile == MAXU32)
-                                                                {
-                                                                        /* Relative Header offset */
-                                                                        if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info_internal.offset_curfile) != UNZ_OK)
-                                                                                err=UNZ_ERRNO;
-                                                                }
-
-                                                                if(file_info.disk_num_start == MAXU32)
-                                                                {
-                                                                        /* Disk Start Number */
-                                                                        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)
-                                                                                err=UNZ_ERRNO;
-                                                                }
-
-            }
-            else
-            {
-                if (ZSEEK64(s->z_filefunc, s->filestream,dataSize,ZLIB_FILEFUNC_SEEK_CUR)!=0)
-                    err=UNZ_ERRNO;
-            }
-
-            acc += 2 + 2 + dataSize;
-        }
-    }
-
-    if ((err==UNZ_OK) && (szComment!=NULL))
-    {
-        uLong uSizeRead ;
-        if (file_info.size_file_comment<commentBufferSize)
-        {
-            *(szComment+file_info.size_file_comment)='\0';
-            uSizeRead = file_info.size_file_comment;
-        }
-        else
-            uSizeRead = commentBufferSize;
-
-        if (lSeek!=0)
-        {
-            if (ZSEEK64(s->z_filefunc, s->filestream,lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)
-                lSeek=0;
-            else
-                err=UNZ_ERRNO;
-        }
-
-        if ((file_info.size_file_comment>0) && (commentBufferSize>0))
-            if (ZREAD64(s->z_filefunc, s->filestream,szComment,uSizeRead)!=uSizeRead)
-                err=UNZ_ERRNO;
-        lSeek+=file_info.size_file_comment - uSizeRead;
-    }
-    else
-        lSeek+=file_info.size_file_comment;
-
-
-    if ((err==UNZ_OK) && (pfile_info!=NULL))
-        *pfile_info=file_info;
-
-    if ((err==UNZ_OK) && (pfile_info_internal!=NULL))
-        *pfile_info_internal=file_info_internal;
-
-    return err;
-}
-
-
-
-/*
-  Write info about the ZipFile in the *pglobal_info structure.
-  No preparation of the structure is needed
-  return UNZ_OK if there is no problem.
-*/
-extern int ZEXPORT unzGetCurrentFileInfo64 (unzFile file,
-                                          unz_file_info64 * pfile_info,
-                                          char * szFileName, uLong fileNameBufferSize,
-                                          void *extraField, uLong extraFieldBufferSize,
-                                          char* szComment,  uLong commentBufferSize)
-{
-    return unz64local_GetCurrentFileInfoInternal(file,pfile_info,NULL,
-                                                szFileName,fileNameBufferSize,
-                                                extraField,extraFieldBufferSize,
-                                                szComment,commentBufferSize);
-}
-
-extern int ZEXPORT unzGetCurrentFileInfo (unzFile file,
-                                          unz_file_info * pfile_info,
-                                          char * szFileName, uLong fileNameBufferSize,
-                                          void *extraField, uLong extraFieldBufferSize,
-                                          char* szComment,  uLong commentBufferSize)
-{
-    int err;
-    unz_file_info64 file_info64;
-    err = unz64local_GetCurrentFileInfoInternal(file,&file_info64,NULL,
-                                                szFileName,fileNameBufferSize,
-                                                extraField,extraFieldBufferSize,
-                                                szComment,commentBufferSize);
-    if ((err==UNZ_OK) && (pfile_info != NULL))
-    {
-        pfile_info->version = file_info64.version;
-        pfile_info->version_needed = file_info64.version_needed;
-        pfile_info->flag = file_info64.flag;
-        pfile_info->compression_method = file_info64.compression_method;
-        pfile_info->dosDate = file_info64.dosDate;
-        pfile_info->crc = file_info64.crc;
-
-        pfile_info->size_filename = file_info64.size_filename;
-        pfile_info->size_file_extra = file_info64.size_file_extra;
-        pfile_info->size_file_comment = file_info64.size_file_comment;
-
-        pfile_info->disk_num_start = file_info64.disk_num_start;
-        pfile_info->internal_fa = file_info64.internal_fa;
-        pfile_info->external_fa = file_info64.external_fa;
-
-        pfile_info->tmu_date = file_info64.tmu_date,
-
-
-        pfile_info->compressed_size = (uLong)file_info64.compressed_size;
-        pfile_info->uncompressed_size = (uLong)file_info64.uncompressed_size;
-
-    }
-    return err;
-}
-/*
-  Set the current file of the zipfile to the first file.
-  return UNZ_OK if there is no problem
-*/
-extern int ZEXPORT unzGoToFirstFile (unzFile file)
-{
-    int err=UNZ_OK;
-    unz64_s* s;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    s->pos_in_central_dir=s->offset_central_dir;
-    s->num_file=0;
-    err=unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,
-                                             &s->cur_file_info_internal,
-                                             NULL,0,NULL,0,NULL,0);
-    s->current_file_ok = (err == UNZ_OK);
-    return err;
-}
-
-/*
-  Set the current file of the zipfile to the next file.
-  return UNZ_OK if there is no problem
-  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
-*/
-extern int ZEXPORT unzGoToNextFile (unzFile  file)
-{
-    unz64_s* s;
-    int err;
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    if (!s->current_file_ok)
-        return UNZ_END_OF_LIST_OF_FILE;
-    if (s->gi.number_entry != 0xffff)    /* 2^16 files overflow hack */
-      if (s->num_file+1==s->gi.number_entry)
-        return UNZ_END_OF_LIST_OF_FILE;
-
-    s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +
-            s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;
-    s->num_file++;
-    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,
-                                               &s->cur_file_info_internal,
-                                               NULL,0,NULL,0,NULL,0);
-    s->current_file_ok = (err == UNZ_OK);
-    return err;
-}
-
-
-/*
-  Try locate the file szFileName in the zipfile.
-  For the iCaseSensitivity signification, see unzipStringFileNameCompare
-
-  return value :
-  UNZ_OK if the file is found. It becomes the current file.
-  UNZ_END_OF_LIST_OF_FILE if the file is not found
-*/
-extern int ZEXPORT unzLocateFile (unzFile file, const char *szFileName, int iCaseSensitivity)
-{
-    unz64_s* s;
-    int err;
-
-    /* We remember the 'current' position in the file so that we can jump
-     * back there if we fail.
-     */
-    unz_file_info64 cur_file_infoSaved;
-    unz_file_info64_internal cur_file_info_internalSaved;
-    ZPOS64_T num_fileSaved;
-    ZPOS64_T pos_in_central_dirSaved;
-
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-
-    if (strlen(szFileName)>=UNZ_MAXFILENAMEINZIP)
-        return UNZ_PARAMERROR;
-
-    s=(unz64_s*)file;
-    if (!s->current_file_ok)
-        return UNZ_END_OF_LIST_OF_FILE;
-
-    /* Save the current state */
-    num_fileSaved = s->num_file;
-    pos_in_central_dirSaved = s->pos_in_central_dir;
-    cur_file_infoSaved = s->cur_file_info;
-    cur_file_info_internalSaved = s->cur_file_info_internal;
-
-    err = unzGoToFirstFile(file);
-
-    while (err == UNZ_OK)
-    {
-        char szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];
-        err = unzGetCurrentFileInfo64(file,NULL,
-                                    szCurrentFileName,sizeof(szCurrentFileName)-1,
-                                    NULL,0,NULL,0);
-        if (err == UNZ_OK)
-        {
-            if (unzStringFileNameCompare(szCurrentFileName,
-                                            szFileName,iCaseSensitivity)==0)
-                return UNZ_OK;
-            err = unzGoToNextFile(file);
-        }
-    }
-
-    /* We failed, so restore the state of the 'current file' to where we
-     * were.
-     */
-    s->num_file = num_fileSaved ;
-    s->pos_in_central_dir = pos_in_central_dirSaved ;
-    s->cur_file_info = cur_file_infoSaved;
-    s->cur_file_info_internal = cur_file_info_internalSaved;
-    return err;
-}
-
-
-/*
-///////////////////////////////////////////
-// Contributed by Ryan Haksi (mailto://cryogen@infoserve.net)
-// I need random access
-//
-// Further optimization could be realized by adding an ability
-// to cache the directory in memory. The goal being a single
-// comprehensive file read to put the file I need in a memory.
-*/
-
-/*
-typedef struct unz_file_pos_s
-{
-    ZPOS64_T pos_in_zip_directory;   // offset in file
-    ZPOS64_T num_of_file;            // # of file
-} unz_file_pos;
-*/
-
-extern int ZEXPORT unzGetFilePos64(unzFile file, unz64_file_pos*  file_pos)
-{
-    unz64_s* s;
-
-    if (file==NULL || file_pos==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    if (!s->current_file_ok)
-        return UNZ_END_OF_LIST_OF_FILE;
-
-    file_pos->pos_in_zip_directory  = s->pos_in_central_dir;
-    file_pos->num_of_file           = s->num_file;
-
-    return UNZ_OK;
-}
-
-extern int ZEXPORT unzGetFilePos(
-    unzFile file,
-    unz_file_pos* file_pos)
-{
-    unz64_file_pos file_pos64;
-    int err = unzGetFilePos64(file,&file_pos64);
-    if (err==UNZ_OK)
-    {
-        file_pos->pos_in_zip_directory = (uLong)file_pos64.pos_in_zip_directory;
-        file_pos->num_of_file = (uLong)file_pos64.num_of_file;
-    }
-    return err;
-}
-
-extern int ZEXPORT unzGoToFilePos64(unzFile file, const unz64_file_pos* file_pos)
-{
-    unz64_s* s;
-    int err;
-
-    if (file==NULL || file_pos==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-
-    /* jump to the right spot */
-    s->pos_in_central_dir = file_pos->pos_in_zip_directory;
-    s->num_file           = file_pos->num_of_file;
-
-    /* set the current file */
-    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,
-                                               &s->cur_file_info_internal,
-                                               NULL,0,NULL,0,NULL,0);
-    /* return results */
-    s->current_file_ok = (err == UNZ_OK);
-    return err;
-}
-
-extern int ZEXPORT unzGoToFilePos(
-    unzFile file,
-    unz_file_pos* file_pos)
-{
-    unz64_file_pos file_pos64;
-    if (file_pos == NULL)
-        return UNZ_PARAMERROR;
-
-    file_pos64.pos_in_zip_directory = file_pos->pos_in_zip_directory;
-    file_pos64.num_of_file = file_pos->num_of_file;
-    return unzGoToFilePos64(file,&file_pos64);
-}
-
-/*
-// Unzip Helper Functions - should be here?
-///////////////////////////////////////////
-*/
-
-/*
-  Read the local header of the current zipfile
-  Check the coherency of the local header and info in the end of central
-        directory about this file
-  store in *piSizeVar the size of extra info in local header
-        (filename and size of extra field data)
-*/
-local int unz64local_CheckCurrentFileCoherencyHeader (unz64_s* s, uInt* piSizeVar,
-                                                    ZPOS64_T * poffset_local_extrafield,
-                                                    uInt  * psize_local_extrafield)
-{
-    uLong uMagic,uData,uFlags;
-    uLong size_filename;
-    uLong size_extra_field;
-    int err=UNZ_OK;
-
-    *piSizeVar = 0;
-    *poffset_local_extrafield = 0;
-    *psize_local_extrafield = 0;
-
-    if (ZSEEK64(s->z_filefunc, s->filestream,s->cur_file_info_internal.offset_curfile +
-                                s->byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET)!=0)
-        return UNZ_ERRNO;
-
-
-    if (err==UNZ_OK)
-    {
-        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)
-            err=UNZ_ERRNO;
-        else if (uMagic!=0x04034b50)
-            err=UNZ_BADZIPFILE;
-    }
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)
-        err=UNZ_ERRNO;
-/*
-    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))
-        err=UNZ_BADZIPFILE;
-*/
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uFlags) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)
-        err=UNZ_ERRNO;
-    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))
-        err=UNZ_BADZIPFILE;
-
-    if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&
-/* #ifdef HAVE_BZIP2 */
-                         (s->cur_file_info.compression_method!=Z_BZIP2ED) &&
-/* #endif */
-                         (s->cur_file_info.compression_method!=Z_DEFLATED))
-        err=UNZ_BADZIPFILE;
-
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* date/time */
-        err=UNZ_ERRNO;
-
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* crc */
-        err=UNZ_ERRNO;
-    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) && ((uFlags & 8)==0))
-        err=UNZ_BADZIPFILE;
-
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size compr */
-        err=UNZ_ERRNO;
-    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) && ((uFlags & 8)==0))
-        err=UNZ_BADZIPFILE;
-
-    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size uncompr */
-        err=UNZ_ERRNO;
-    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) && ((uFlags & 8)==0))
-        err=UNZ_BADZIPFILE;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_filename) != UNZ_OK)
-        err=UNZ_ERRNO;
-    else if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))
-        err=UNZ_BADZIPFILE;
-
-    *piSizeVar += (uInt)size_filename;
-
-    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_extra_field) != UNZ_OK)
-        err=UNZ_ERRNO;
-    *poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +
-                                    SIZEZIPLOCALHEADER + size_filename;
-    *psize_local_extrafield = (uInt)size_extra_field;
-
-    *piSizeVar += (uInt)size_extra_field;
-
-    return err;
-}
-
-/*
-  Open for reading data the current file in the zipfile.
-  If there is no error and the file is opened, the return value is UNZ_OK.
-*/
-extern int ZEXPORT unzOpenCurrentFile3 (unzFile file, int* method,
-                                            int* level, int raw, const char* password)
-{
-    int err=UNZ_OK;
-    uInt iSizeVar;
-    unz64_s* s;
-    file_in_zip64_read_info_s* pfile_in_zip_read_info;
-    ZPOS64_T offset_local_extrafield;  /* offset of the local extra field */
-    uInt  size_local_extrafield;    /* size of the local extra field */
-#    ifndef NOUNCRYPT
-    char source[12];
-#    else
-    if (password != NULL)
-        return UNZ_PARAMERROR;
-#    endif
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    if (!s->current_file_ok)
-        return UNZ_PARAMERROR;
-
-    if (s->pfile_in_zip_read != NULL)
-        unzCloseCurrentFile(file);
-
-    if (unz64local_CheckCurrentFileCoherencyHeader(s,&iSizeVar, &offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)
-        return UNZ_BADZIPFILE;
-
-    pfile_in_zip_read_info = (file_in_zip64_read_info_s*)ALLOC(sizeof(file_in_zip64_read_info_s));
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_INTERNALERROR;
-
-    pfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);
-    pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;
-    pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;
-    pfile_in_zip_read_info->pos_local_extrafield=0;
-    pfile_in_zip_read_info->raw=raw;
-
-    if (pfile_in_zip_read_info->read_buffer==NULL)
-    {
-        TRYFREE(pfile_in_zip_read_info);
-        return UNZ_INTERNALERROR;
-    }
-
-    pfile_in_zip_read_info->stream_initialised=0;
-
-    if (method!=NULL)
-        *method = (int)s->cur_file_info.compression_method;
-
-    if (level!=NULL)
-    {
-        *level = 6;
-        switch (s->cur_file_info.flag & 0x06)
-        {
-          case 6 : *level = 1; break;
-          case 4 : *level = 2; break;
-          case 2 : *level = 9; break;
-        }
-    }
-
-    if ((s->cur_file_info.compression_method!=0) &&
-/* #ifdef HAVE_BZIP2 */
-        (s->cur_file_info.compression_method!=Z_BZIP2ED) &&
-/* #endif */
-        (s->cur_file_info.compression_method!=Z_DEFLATED))
-
-        err=UNZ_BADZIPFILE;
-
-    pfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;
-    pfile_in_zip_read_info->crc32=0;
-    pfile_in_zip_read_info->total_out_64=0;
-    pfile_in_zip_read_info->compression_method = s->cur_file_info.compression_method;
-    pfile_in_zip_read_info->filestream=s->filestream;
-    pfile_in_zip_read_info->z_filefunc=s->z_filefunc;
-    pfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;
-
-    pfile_in_zip_read_info->stream.total_out = 0;
-
-    if ((s->cur_file_info.compression_method==Z_BZIP2ED) && (!raw))
-    {
-#ifdef HAVE_BZIP2
-      pfile_in_zip_read_info->bstream.bzalloc = (void *(*) (void *, int, int))0;
-      pfile_in_zip_read_info->bstream.bzfree = (free_func)0;
-      pfile_in_zip_read_info->bstream.opaque = (voidpf)0;
-      pfile_in_zip_read_info->bstream.state = (voidpf)0;
-
-      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
-      pfile_in_zip_read_info->stream.zfree = (free_func)0;
-      pfile_in_zip_read_info->stream.opaque = (voidpf)0;
-      pfile_in_zip_read_info->stream.next_in = (voidpf)0;
-      pfile_in_zip_read_info->stream.avail_in = 0;
-
-      err=BZ2_bzDecompressInit(&pfile_in_zip_read_info->bstream, 0, 0);
-      if (err == Z_OK)
-        pfile_in_zip_read_info->stream_initialised=Z_BZIP2ED;
-      else
-      {
-        TRYFREE(pfile_in_zip_read_info);
-        return err;
-      }
-#else
-      pfile_in_zip_read_info->raw=1;
-#endif
-    }
-    else if ((s->cur_file_info.compression_method==Z_DEFLATED) && (!raw))
-    {
-      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
-      pfile_in_zip_read_info->stream.zfree = (free_func)0;
-      pfile_in_zip_read_info->stream.opaque = (voidpf)0;
-      pfile_in_zip_read_info->stream.next_in = 0;
-      pfile_in_zip_read_info->stream.avail_in = 0;
-
-      err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);
-      if (err == Z_OK)
-        pfile_in_zip_read_info->stream_initialised=Z_DEFLATED;
-      else
-      {
-        TRYFREE(pfile_in_zip_read_info);
-        return err;
-      }
-        /* windowBits is passed < 0 to tell that there is no zlib header.
-         * Note that in this case inflate *requires* an extra "dummy" byte
-         * after the compressed stream in order to complete decompression and
-         * return Z_STREAM_END.
-         * In unzip, i don't wait absolutely Z_STREAM_END because I known the
-         * size of both compressed and uncompressed data
-         */
-    }
-    pfile_in_zip_read_info->rest_read_compressed =
-            s->cur_file_info.compressed_size ;
-    pfile_in_zip_read_info->rest_read_uncompressed =
-            s->cur_file_info.uncompressed_size ;
-
-
-    pfile_in_zip_read_info->pos_in_zipfile =
-            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER +
-              iSizeVar;
-
-    pfile_in_zip_read_info->stream.avail_in = (uInt)0;
-
-    s->pfile_in_zip_read = pfile_in_zip_read_info;
-                s->encrypted = 0;
-
-#    ifndef NOUNCRYPT
-    if (password != NULL)
-    {
-        int i;
-        s->pcrc_32_tab = get_crc_table();
-        init_keys(password,s->keys,s->pcrc_32_tab);
-        if (ZSEEK64(s->z_filefunc, s->filestream,
-                  s->pfile_in_zip_read->pos_in_zipfile +
-                     s->pfile_in_zip_read->byte_before_the_zipfile,
-                  SEEK_SET)!=0)
-            return UNZ_INTERNALERROR;
-        if(ZREAD64(s->z_filefunc, s->filestream,source, 12)<12)
-            return UNZ_INTERNALERROR;
-
-        for (i = 0; i<12; i++)
-            zdecode(s->keys,s->pcrc_32_tab,source[i]);
-
-        s->pfile_in_zip_read->pos_in_zipfile+=12;
-        s->encrypted=1;
-    }
-#    endif
-
-
-    return UNZ_OK;
-}
-
-extern int ZEXPORT unzOpenCurrentFile (unzFile file)
-{
-    return unzOpenCurrentFile3(file, NULL, NULL, 0, NULL);
-}
-
-extern int ZEXPORT unzOpenCurrentFilePassword (unzFile file, const char*  password)
-{
-    return unzOpenCurrentFile3(file, NULL, NULL, 0, password);
-}
-
-extern int ZEXPORT unzOpenCurrentFile2 (unzFile file, int* method, int* level, int raw)
-{
-    return unzOpenCurrentFile3(file, method, level, raw, NULL);
-}
-
-/** Addition for GDAL : START */
-
-extern ZPOS64_T ZEXPORT unzGetCurrentFileZStreamPos64( unzFile file)
-{
-    unz64_s* s;
-    file_in_zip64_read_info_s* pfile_in_zip_read_info;
-    s=(unz64_s*)file;
-    if (file==NULL)
-        return 0; //UNZ_PARAMERROR;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-    if (pfile_in_zip_read_info==NULL)
-        return 0; //UNZ_PARAMERROR;
-    return pfile_in_zip_read_info->pos_in_zipfile +
-                         pfile_in_zip_read_info->byte_before_the_zipfile;
-}
-
-/** Addition for GDAL : END */
-
-/*
-  Read bytes from the current file.
-  buf contain buffer where data must be copied
-  len the size of buf.
-
-  return the number of byte copied if somes bytes are copied
-  return 0 if the end of file was reached
-  return <0 with error code if there is an error
-    (UNZ_ERRNO for IO error, or zLib error for uncompress error)
-*/
-extern int ZEXPORT unzReadCurrentFile  (unzFile file, voidp buf, unsigned len)
-{
-    int err=UNZ_OK;
-    uInt iRead = 0;
-    unz64_s* s;
-    file_in_zip64_read_info_s* pfile_in_zip_read_info;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-
-    if (pfile_in_zip_read_info->read_buffer == NULL)
-        return UNZ_END_OF_LIST_OF_FILE;
-    if (len==0)
-        return 0;
-
-    pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;
-
-    pfile_in_zip_read_info->stream.avail_out = (uInt)len;
-
-    if ((len>pfile_in_zip_read_info->rest_read_uncompressed) &&
-        (!(pfile_in_zip_read_info->raw)))
-        pfile_in_zip_read_info->stream.avail_out =
-            (uInt)pfile_in_zip_read_info->rest_read_uncompressed;
-
-    if ((len>pfile_in_zip_read_info->rest_read_compressed+
-           pfile_in_zip_read_info->stream.avail_in) &&
-         (pfile_in_zip_read_info->raw))
-        pfile_in_zip_read_info->stream.avail_out =
-            (uInt)pfile_in_zip_read_info->rest_read_compressed+
-            pfile_in_zip_read_info->stream.avail_in;
-
-    while (pfile_in_zip_read_info->stream.avail_out>0)
-    {
-        if ((pfile_in_zip_read_info->stream.avail_in==0) &&
-            (pfile_in_zip_read_info->rest_read_compressed>0))
-        {
-            uInt uReadThis = UNZ_BUFSIZE;
-            if (pfile_in_zip_read_info->rest_read_compressed<uReadThis)
-                uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;
-            if (uReadThis == 0)
-                return UNZ_EOF;
-            if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,
-                      pfile_in_zip_read_info->filestream,
-                      pfile_in_zip_read_info->pos_in_zipfile +
-                         pfile_in_zip_read_info->byte_before_the_zipfile,
-                         ZLIB_FILEFUNC_SEEK_SET)!=0)
-                return UNZ_ERRNO;
-            if (ZREAD64(pfile_in_zip_read_info->z_filefunc,
-                      pfile_in_zip_read_info->filestream,
-                      pfile_in_zip_read_info->read_buffer,
-                      uReadThis)!=uReadThis)
-                return UNZ_ERRNO;
-
-
-#            ifndef NOUNCRYPT
-            if(s->encrypted)
-            {
-                uInt i;
-                for(i=0;i<uReadThis;i++)
-                  pfile_in_zip_read_info->read_buffer[i] =
-                      zdecode(s->keys,s->pcrc_32_tab,
-                              pfile_in_zip_read_info->read_buffer[i]);
-            }
-#            endif
-
-
-            pfile_in_zip_read_info->pos_in_zipfile += uReadThis;
-
-            pfile_in_zip_read_info->rest_read_compressed-=uReadThis;
-
-            pfile_in_zip_read_info->stream.next_in =
-                (Bytef*)pfile_in_zip_read_info->read_buffer;
-            pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;
-        }
-
-        if ((pfile_in_zip_read_info->compression_method==0) || (pfile_in_zip_read_info->raw))
-        {
-            uInt uDoCopy,i ;
-
-            if ((pfile_in_zip_read_info->stream.avail_in == 0) &&
-                (pfile_in_zip_read_info->rest_read_compressed == 0))
-                return (iRead==0) ? UNZ_EOF : iRead;
-
-            if (pfile_in_zip_read_info->stream.avail_out <
-                            pfile_in_zip_read_info->stream.avail_in)
-                uDoCopy = pfile_in_zip_read_info->stream.avail_out ;
-            else
-                uDoCopy = pfile_in_zip_read_info->stream.avail_in ;
-
-            for (i=0;i<uDoCopy;i++)
-                *(pfile_in_zip_read_info->stream.next_out+i) =
-                        *(pfile_in_zip_read_info->stream.next_in+i);
-
-            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uDoCopy;
-
-            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,
-                                pfile_in_zip_read_info->stream.next_out,
-                                uDoCopy);
-            pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;
-            pfile_in_zip_read_info->stream.avail_in -= uDoCopy;
-            pfile_in_zip_read_info->stream.avail_out -= uDoCopy;
-            pfile_in_zip_read_info->stream.next_out += uDoCopy;
-            pfile_in_zip_read_info->stream.next_in += uDoCopy;
-            pfile_in_zip_read_info->stream.total_out += uDoCopy;
-            iRead += uDoCopy;
-        }
-        else if (pfile_in_zip_read_info->compression_method==Z_BZIP2ED)
-        {
-#ifdef HAVE_BZIP2
-            uLong uTotalOutBefore,uTotalOutAfter;
-            const Bytef *bufBefore;
-            uLong uOutThis;
-
-            pfile_in_zip_read_info->bstream.next_in        = (char*)pfile_in_zip_read_info->stream.next_in;
-            pfile_in_zip_read_info->bstream.avail_in       = pfile_in_zip_read_info->stream.avail_in;
-            pfile_in_zip_read_info->bstream.total_in_lo32  = pfile_in_zip_read_info->stream.total_in;
-            pfile_in_zip_read_info->bstream.total_in_hi32  = 0;
-            pfile_in_zip_read_info->bstream.next_out       = (char*)pfile_in_zip_read_info->stream.next_out;
-            pfile_in_zip_read_info->bstream.avail_out      = pfile_in_zip_read_info->stream.avail_out;
-            pfile_in_zip_read_info->bstream.total_out_lo32 = pfile_in_zip_read_info->stream.total_out;
-            pfile_in_zip_read_info->bstream.total_out_hi32 = 0;
-
-            uTotalOutBefore = pfile_in_zip_read_info->bstream.total_out_lo32;
-            bufBefore = (const Bytef *)pfile_in_zip_read_info->bstream.next_out;
-
-            err=BZ2_bzDecompress(&pfile_in_zip_read_info->bstream);
-
-            uTotalOutAfter = pfile_in_zip_read_info->bstream.total_out_lo32;
-            uOutThis = uTotalOutAfter-uTotalOutBefore;
-
-            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;
-
-            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,bufBefore, (uInt)(uOutThis));
-            pfile_in_zip_read_info->rest_read_uncompressed -= uOutThis;
-            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);
-
-            pfile_in_zip_read_info->stream.next_in   = (Bytef*)pfile_in_zip_read_info->bstream.next_in;
-            pfile_in_zip_read_info->stream.avail_in  = pfile_in_zip_read_info->bstream.avail_in;
-            pfile_in_zip_read_info->stream.total_in  = pfile_in_zip_read_info->bstream.total_in_lo32;
-            pfile_in_zip_read_info->stream.next_out  = (Bytef*)pfile_in_zip_read_info->bstream.next_out;
-            pfile_in_zip_read_info->stream.avail_out = pfile_in_zip_read_info->bstream.avail_out;
-            pfile_in_zip_read_info->stream.total_out = pfile_in_zip_read_info->bstream.total_out_lo32;
-
-            if (err==BZ_STREAM_END)
-              return (iRead==0) ? UNZ_EOF : iRead;
-            if (err!=BZ_OK)
-              break;
-#endif
-        } // end Z_BZIP2ED
-        else
-        {
-            ZPOS64_T uTotalOutBefore,uTotalOutAfter;
-            const Bytef *bufBefore;
-            ZPOS64_T uOutThis;
-            int flush=Z_SYNC_FLUSH;
-
-            uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;
-            bufBefore = pfile_in_zip_read_info->stream.next_out;
-
-            /*
-            if ((pfile_in_zip_read_info->rest_read_uncompressed ==
-                     pfile_in_zip_read_info->stream.avail_out) &&
-                (pfile_in_zip_read_info->rest_read_compressed == 0))
-                flush = Z_FINISH;
-            */
-            err=inflate(&pfile_in_zip_read_info->stream,flush);
-
-            if ((err>=0) && (pfile_in_zip_read_info->stream.msg!=NULL))
-              err = Z_DATA_ERROR;
-
-            uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;
-            uOutThis = uTotalOutAfter-uTotalOutBefore;
-
-            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;
-
-            pfile_in_zip_read_info->crc32 =
-                crc32(pfile_in_zip_read_info->crc32,bufBefore,
-                        (uInt)(uOutThis));
-
-            pfile_in_zip_read_info->rest_read_uncompressed -=
-                uOutThis;
-
-            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);
-
-            if (err==Z_STREAM_END)
-                return (iRead==0) ? UNZ_EOF : iRead;
-            if (err!=Z_OK)
-                break;
-        }
-    }
-
-    if (err==Z_OK)
-        return iRead;
-    return err;
-}
-
-
-/*
-  Give the current position in uncompressed data
-*/
-extern z_off_t ZEXPORT unztell (unzFile file)
-{
-    unz64_s* s;
-    file_in_zip64_read_info_s* pfile_in_zip_read_info;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-    return (z_off_t)pfile_in_zip_read_info->stream.total_out;
-}
-
-extern ZPOS64_T ZEXPORT unztell64 (unzFile file)
-{
-
-    unz64_s* s;
-    file_in_zip64_read_info_s* pfile_in_zip_read_info;
-    if (file==NULL)
-        return (ZPOS64_T)-1;
-    s=(unz64_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return (ZPOS64_T)-1;
-
-    return pfile_in_zip_read_info->total_out_64;
-}
-
-
-/*
-  return 1 if the end of file was reached, 0 elsewhere
-*/
-extern int ZEXPORT unzeof (unzFile file)
-{
-    unz64_s* s;
-    file_in_zip64_read_info_s* pfile_in_zip_read_info;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-    if (pfile_in_zip_read_info->rest_read_uncompressed == 0)
-        return 1;
-    else
-        return 0;
-}
-
-
-
-/*
-Read extra field from the current file (opened by unzOpenCurrentFile)
-This is the local-header version of the extra field (sometimes, there is
-more info in the local-header version than in the central-header)
-
-  if buf==NULL, it return the size of the local extra field that can be read
-
-  if buf!=NULL, len is the size of the buffer, the extra header is copied in
-    buf.
-  the return value is the number of bytes copied in buf, or (if <0)
-    the error code
-*/
-extern int ZEXPORT unzGetLocalExtrafield (unzFile file, voidp buf, unsigned len)
-{
-    unz64_s* s;
-    file_in_zip64_read_info_s* pfile_in_zip_read_info;
-    uInt read_now;
-    ZPOS64_T size_to_read;
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-    size_to_read = (pfile_in_zip_read_info->size_local_extrafield -
-                pfile_in_zip_read_info->pos_local_extrafield);
-
-    if (buf==NULL)
-        return (int)size_to_read;
-
-    if (len>size_to_read)
-        read_now = (uInt)size_to_read;
-    else
-        read_now = (uInt)len ;
-
-    if (read_now==0)
-        return 0;
-
-    if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,
-              pfile_in_zip_read_info->filestream,
-              pfile_in_zip_read_info->offset_local_extrafield +
-              pfile_in_zip_read_info->pos_local_extrafield,
-              ZLIB_FILEFUNC_SEEK_SET)!=0)
-        return UNZ_ERRNO;
-
-    if (ZREAD64(pfile_in_zip_read_info->z_filefunc,
-              pfile_in_zip_read_info->filestream,
-              buf,read_now)!=read_now)
-        return UNZ_ERRNO;
-
-    return (int)read_now;
-}
-
-/*
-  Close the file in zip opened with unzipOpenCurrentFile
-  Return UNZ_CRCERROR if all the file was read but the CRC is not good
-*/
-extern int ZEXPORT unzCloseCurrentFile (unzFile file)
-{
-    int err=UNZ_OK;
-
-    unz64_s* s;
-    file_in_zip64_read_info_s* pfile_in_zip_read_info;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-
-    if ((pfile_in_zip_read_info->rest_read_uncompressed == 0) &&
-        (!pfile_in_zip_read_info->raw))
-    {
-        if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)
-            err=UNZ_CRCERROR;
-    }
-
-
-    TRYFREE(pfile_in_zip_read_info->read_buffer);
-    pfile_in_zip_read_info->read_buffer = NULL;
-    if (pfile_in_zip_read_info->stream_initialised == Z_DEFLATED)
-        inflateEnd(&pfile_in_zip_read_info->stream);
-#ifdef HAVE_BZIP2
-    else if (pfile_in_zip_read_info->stream_initialised == Z_BZIP2ED)
-        BZ2_bzDecompressEnd(&pfile_in_zip_read_info->bstream);
-#endif
-
-
-    pfile_in_zip_read_info->stream_initialised = 0;
-    TRYFREE(pfile_in_zip_read_info);
-
-    s->pfile_in_zip_read=NULL;
-
-    return err;
-}
-
-
-/*
-  Get the global comment string of the ZipFile, in the szComment buffer.
-  uSizeBuf is the size of the szComment buffer.
-  return the number of byte copied or an error code <0
-*/
-extern int ZEXPORT unzGetGlobalComment (unzFile file, char * szComment, uLong uSizeBuf)
-{
-    unz64_s* s;
-    uLong uReadThis ;
-    if (file==NULL)
-        return (int)UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-
-    uReadThis = uSizeBuf;
-    if (uReadThis>s->gi.size_comment)
-        uReadThis = s->gi.size_comment;
-
-    if (ZSEEK64(s->z_filefunc,s->filestream,s->central_pos+22,ZLIB_FILEFUNC_SEEK_SET)!=0)
-        return UNZ_ERRNO;
-
-    if (uReadThis>0)
-    {
-      *szComment='\0';
-      if (ZREAD64(s->z_filefunc,s->filestream,szComment,uReadThis)!=uReadThis)
-        return UNZ_ERRNO;
-    }
-
-    if ((szComment != NULL) && (uSizeBuf > s->gi.size_comment))
-        *(szComment+s->gi.size_comment)='\0';
-    return (int)uReadThis;
-}
-
-/* Additions by RX '2004 */
-extern ZPOS64_T ZEXPORT unzGetOffset64(unzFile file)
-{
-    unz64_s* s;
-
-    if (file==NULL)
-          return 0; //UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-    if (!s->current_file_ok)
-      return 0;
-    if (s->gi.number_entry != 0 && s->gi.number_entry != 0xffff)
-      if (s->num_file==s->gi.number_entry)
-         return 0;
-    return s->pos_in_central_dir;
-}
-
-extern uLong ZEXPORT unzGetOffset (unzFile file)
-{
-    ZPOS64_T offset64;
-
-    if (file==NULL)
-          return 0; //UNZ_PARAMERROR;
-    offset64 = unzGetOffset64(file);
-    return (uLong)offset64;
-}
-
-extern int ZEXPORT unzSetOffset64(unzFile file, ZPOS64_T pos)
-{
-    unz64_s* s;
-    int err;
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz64_s*)file;
-
-    s->pos_in_central_dir = pos;
-    s->num_file = s->gi.number_entry;      /* hack */
-    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,
-                                              &s->cur_file_info_internal,
-                                              NULL,0,NULL,0,NULL,0);
-    s->current_file_ok = (err == UNZ_OK);
-    return err;
-}
-
-extern int ZEXPORT unzSetOffset (unzFile file, uLong pos)
-{
-    return unzSetOffset64(file,pos);
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/unzip.h gcc-4.8.1-ppc/zlib/contrib/minizip/unzip.h
--- gcc-4.8.1/zlib/contrib/minizip/unzip.h	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/unzip.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,437 +0,0 @@
-/* unzip.h -- IO for uncompress .zip files using zlib
-   Version 1.1, February 14h, 2010
-   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications of Unzip for Zip64
-         Copyright (C) 2007-2008 Even Rouault
-
-         Modifications for Zip64 support on both zip and unzip
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-         For more info read MiniZip_info.txt
-
-         ---------------------------------------------------------------------------------
-
-        Condition of use and distribution are the same than zlib :
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  ---------------------------------------------------------------------------------
-
-        Changes
-
-        See header of unzip64.c
-
-*/
-
-#ifndef _unz64_H
-#define _unz64_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef _ZLIB_H
-#include "zlib.h"
-#endif
-
-#ifndef  _ZLIBIOAPI_H
-#include "ioapi.h"
-#endif
-
-#ifdef HAVE_BZIP2
-#include "bzlib.h"
-#endif
-
-#define Z_BZIP2ED 12
-
-#if defined(STRICTUNZIP) || defined(STRICTZIPUNZIP)
-/* like the STRICT of WIN32, we define a pointer that cannot be converted
-    from (void*) without cast */
-typedef struct TagunzFile__ { int unused; } unzFile__;
-typedef unzFile__ *unzFile;
-#else
-typedef voidp unzFile;
-#endif
-
-
-#define UNZ_OK                          (0)
-#define UNZ_END_OF_LIST_OF_FILE         (-100)
-#define UNZ_ERRNO                       (Z_ERRNO)
-#define UNZ_EOF                         (0)
-#define UNZ_PARAMERROR                  (-102)
-#define UNZ_BADZIPFILE                  (-103)
-#define UNZ_INTERNALERROR               (-104)
-#define UNZ_CRCERROR                    (-105)
-
-/* tm_unz contain date/time info */
-typedef struct tm_unz_s
-{
-    uInt tm_sec;            /* seconds after the minute - [0,59] */
-    uInt tm_min;            /* minutes after the hour - [0,59] */
-    uInt tm_hour;           /* hours since midnight - [0,23] */
-    uInt tm_mday;           /* day of the month - [1,31] */
-    uInt tm_mon;            /* months since January - [0,11] */
-    uInt tm_year;           /* years - [1980..2044] */
-} tm_unz;
-
-/* unz_global_info structure contain global data about the ZIPfile
-   These data comes from the end of central dir */
-typedef struct unz_global_info64_s
-{
-    ZPOS64_T number_entry;         /* total number of entries in
-                                     the central dir on this disk */
-    uLong size_comment;         /* size of the global comment of the zipfile */
-} unz_global_info64;
-
-typedef struct unz_global_info_s
-{
-    uLong number_entry;         /* total number of entries in
-                                     the central dir on this disk */
-    uLong size_comment;         /* size of the global comment of the zipfile */
-} unz_global_info;
-
-/* unz_file_info contain information about a file in the zipfile */
-typedef struct unz_file_info64_s
-{
-    uLong version;              /* version made by                 2 bytes */
-    uLong version_needed;       /* version needed to extract       2 bytes */
-    uLong flag;                 /* general purpose bit flag        2 bytes */
-    uLong compression_method;   /* compression method              2 bytes */
-    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */
-    uLong crc;                  /* crc-32                          4 bytes */
-    ZPOS64_T compressed_size;   /* compressed size                 8 bytes */
-    ZPOS64_T uncompressed_size; /* uncompressed size               8 bytes */
-    uLong size_filename;        /* filename length                 2 bytes */
-    uLong size_file_extra;      /* extra field length              2 bytes */
-    uLong size_file_comment;    /* file comment length             2 bytes */
-
-    uLong disk_num_start;       /* disk number start               2 bytes */
-    uLong internal_fa;          /* internal file attributes        2 bytes */
-    uLong external_fa;          /* external file attributes        4 bytes */
-
-    tm_unz tmu_date;
-} unz_file_info64;
-
-typedef struct unz_file_info_s
-{
-    uLong version;              /* version made by                 2 bytes */
-    uLong version_needed;       /* version needed to extract       2 bytes */
-    uLong flag;                 /* general purpose bit flag        2 bytes */
-    uLong compression_method;   /* compression method              2 bytes */
-    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */
-    uLong crc;                  /* crc-32                          4 bytes */
-    uLong compressed_size;      /* compressed size                 4 bytes */
-    uLong uncompressed_size;    /* uncompressed size               4 bytes */
-    uLong size_filename;        /* filename length                 2 bytes */
-    uLong size_file_extra;      /* extra field length              2 bytes */
-    uLong size_file_comment;    /* file comment length             2 bytes */
-
-    uLong disk_num_start;       /* disk number start               2 bytes */
-    uLong internal_fa;          /* internal file attributes        2 bytes */
-    uLong external_fa;          /* external file attributes        4 bytes */
-
-    tm_unz tmu_date;
-} unz_file_info;
-
-extern int ZEXPORT unzStringFileNameCompare OF ((const char* fileName1,
-                                                 const char* fileName2,
-                                                 int iCaseSensitivity));
-/*
-   Compare two filename (fileName1,fileName2).
-   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
-   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
-                                or strcasecmp)
-   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
-    (like 1 on Unix, 2 on Windows)
-*/
-
-
-extern unzFile ZEXPORT unzOpen OF((const char *path));
-extern unzFile ZEXPORT unzOpen64 OF((const void *path));
-/*
-  Open a Zip file. path contain the full pathname (by example,
-     on a Windows XP computer "c:\\zlib\\zlib113.zip" or on an Unix computer
-     "zlib/zlib113.zip".
-     If the zipfile cannot be opened (file don't exist or in not valid), the
-       return value is NULL.
-     Else, the return value is a unzFile Handle, usable with other function
-       of this unzip package.
-     the "64" function take a const void* pointer, because the path is just the
-       value passed to the open64_file_func callback.
-     Under Windows, if UNICODE is defined, using fill_fopen64_filefunc, the path
-       is a pointer to a wide unicode string (LPCTSTR is LPCWSTR), so const char*
-       does not describe the reality
-*/
-
-
-extern unzFile ZEXPORT unzOpen2 OF((const char *path,
-                                    zlib_filefunc_def* pzlib_filefunc_def));
-/*
-   Open a Zip file, like unzOpen, but provide a set of file low level API
-      for read/write the zip file (see ioapi.h)
-*/
-
-extern unzFile ZEXPORT unzOpen2_64 OF((const void *path,
-                                    zlib_filefunc64_def* pzlib_filefunc_def));
-/*
-   Open a Zip file, like unz64Open, but provide a set of file low level API
-      for read/write the zip file (see ioapi.h)
-*/
-
-extern int ZEXPORT unzClose OF((unzFile file));
-/*
-  Close a ZipFile opened with unzipOpen.
-  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),
-    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.
-  return UNZ_OK if there is no problem. */
-
-extern int ZEXPORT unzGetGlobalInfo OF((unzFile file,
-                                        unz_global_info *pglobal_info));
-
-extern int ZEXPORT unzGetGlobalInfo64 OF((unzFile file,
-                                        unz_global_info64 *pglobal_info));
-/*
-  Write info about the ZipFile in the *pglobal_info structure.
-  No preparation of the structure is needed
-  return UNZ_OK if there is no problem. */
-
-
-extern int ZEXPORT unzGetGlobalComment OF((unzFile file,
-                                           char *szComment,
-                                           uLong uSizeBuf));
-/*
-  Get the global comment string of the ZipFile, in the szComment buffer.
-  uSizeBuf is the size of the szComment buffer.
-  return the number of byte copied or an error code <0
-*/
-
-
-/***************************************************************************/
-/* Unzip package allow you browse the directory of the zipfile */
-
-extern int ZEXPORT unzGoToFirstFile OF((unzFile file));
-/*
-  Set the current file of the zipfile to the first file.
-  return UNZ_OK if there is no problem
-*/
-
-extern int ZEXPORT unzGoToNextFile OF((unzFile file));
-/*
-  Set the current file of the zipfile to the next file.
-  return UNZ_OK if there is no problem
-  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
-*/
-
-extern int ZEXPORT unzLocateFile OF((unzFile file,
-                     const char *szFileName,
-                     int iCaseSensitivity));
-/*
-  Try locate the file szFileName in the zipfile.
-  For the iCaseSensitivity signification, see unzStringFileNameCompare
-
-  return value :
-  UNZ_OK if the file is found. It becomes the current file.
-  UNZ_END_OF_LIST_OF_FILE if the file is not found
-*/
-
-
-/* ****************************************** */
-/* Ryan supplied functions */
-/* unz_file_info contain information about a file in the zipfile */
-typedef struct unz_file_pos_s
-{
-    uLong pos_in_zip_directory;   /* offset in zip file directory */
-    uLong num_of_file;            /* # of file */
-} unz_file_pos;
-
-extern int ZEXPORT unzGetFilePos(
-    unzFile file,
-    unz_file_pos* file_pos);
-
-extern int ZEXPORT unzGoToFilePos(
-    unzFile file,
-    unz_file_pos* file_pos);
-
-typedef struct unz64_file_pos_s
-{
-    ZPOS64_T pos_in_zip_directory;   /* offset in zip file directory */
-    ZPOS64_T num_of_file;            /* # of file */
-} unz64_file_pos;
-
-extern int ZEXPORT unzGetFilePos64(
-    unzFile file,
-    unz64_file_pos* file_pos);
-
-extern int ZEXPORT unzGoToFilePos64(
-    unzFile file,
-    const unz64_file_pos* file_pos);
-
-/* ****************************************** */
-
-extern int ZEXPORT unzGetCurrentFileInfo64 OF((unzFile file,
-                         unz_file_info64 *pfile_info,
-                         char *szFileName,
-                         uLong fileNameBufferSize,
-                         void *extraField,
-                         uLong extraFieldBufferSize,
-                         char *szComment,
-                         uLong commentBufferSize));
-
-extern int ZEXPORT unzGetCurrentFileInfo OF((unzFile file,
-                         unz_file_info *pfile_info,
-                         char *szFileName,
-                         uLong fileNameBufferSize,
-                         void *extraField,
-                         uLong extraFieldBufferSize,
-                         char *szComment,
-                         uLong commentBufferSize));
-/*
-  Get Info about the current file
-  if pfile_info!=NULL, the *pfile_info structure will contain somes info about
-        the current file
-  if szFileName!=NULL, the filemane string will be copied in szFileName
-            (fileNameBufferSize is the size of the buffer)
-  if extraField!=NULL, the extra field information will be copied in extraField
-            (extraFieldBufferSize is the size of the buffer).
-            This is the Central-header version of the extra field
-  if szComment!=NULL, the comment string of the file will be copied in szComment
-            (commentBufferSize is the size of the buffer)
-*/
-
-
-/** Addition for GDAL : START */
-
-extern ZPOS64_T ZEXPORT unzGetCurrentFileZStreamPos64 OF((unzFile file));
-
-/** Addition for GDAL : END */
-
-
-/***************************************************************************/
-/* for reading the content of the current zipfile, you can open it, read data
-   from it, and close it (you can close it before reading all the file)
-   */
-
-extern int ZEXPORT unzOpenCurrentFile OF((unzFile file));
-/*
-  Open for reading data the current file in the zipfile.
-  If there is no error, the return value is UNZ_OK.
-*/
-
-extern int ZEXPORT unzOpenCurrentFilePassword OF((unzFile file,
-                                                  const char* password));
-/*
-  Open for reading data the current file in the zipfile.
-  password is a crypting password
-  If there is no error, the return value is UNZ_OK.
-*/
-
-extern int ZEXPORT unzOpenCurrentFile2 OF((unzFile file,
-                                           int* method,
-                                           int* level,
-                                           int raw));
-/*
-  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)
-    if raw==1
-  *method will receive method of compression, *level will receive level of
-     compression
-  note : you can set level parameter as NULL (if you did not want known level,
-         but you CANNOT set method parameter as NULL
-*/
-
-extern int ZEXPORT unzOpenCurrentFile3 OF((unzFile file,
-                                           int* method,
-                                           int* level,
-                                           int raw,
-                                           const char* password));
-/*
-  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)
-    if raw==1
-  *method will receive method of compression, *level will receive level of
-     compression
-  note : you can set level parameter as NULL (if you did not want known level,
-         but you CANNOT set method parameter as NULL
-*/
-
-
-extern int ZEXPORT unzCloseCurrentFile OF((unzFile file));
-/*
-  Close the file in zip opened with unzOpenCurrentFile
-  Return UNZ_CRCERROR if all the file was read but the CRC is not good
-*/
-
-extern int ZEXPORT unzReadCurrentFile OF((unzFile file,
-                      voidp buf,
-                      unsigned len));
-/*
-  Read bytes from the current file (opened by unzOpenCurrentFile)
-  buf contain buffer where data must be copied
-  len the size of buf.
-
-  return the number of byte copied if somes bytes are copied
-  return 0 if the end of file was reached
-  return <0 with error code if there is an error
-    (UNZ_ERRNO for IO error, or zLib error for uncompress error)
-*/
-
-extern z_off_t ZEXPORT unztell OF((unzFile file));
-
-extern ZPOS64_T ZEXPORT unztell64 OF((unzFile file));
-/*
-  Give the current position in uncompressed data
-*/
-
-extern int ZEXPORT unzeof OF((unzFile file));
-/*
-  return 1 if the end of file was reached, 0 elsewhere
-*/
-
-extern int ZEXPORT unzGetLocalExtrafield OF((unzFile file,
-                                             voidp buf,
-                                             unsigned len));
-/*
-  Read extra field from the current file (opened by unzOpenCurrentFile)
-  This is the local-header version of the extra field (sometimes, there is
-    more info in the local-header version than in the central-header)
-
-  if buf==NULL, it return the size of the local extra field
-
-  if buf!=NULL, len is the size of the buffer, the extra header is copied in
-    buf.
-  the return value is the number of bytes copied in buf, or (if <0)
-    the error code
-*/
-
-/***************************************************************************/
-
-/* Get the current file offset */
-extern ZPOS64_T ZEXPORT unzGetOffset64 (unzFile file);
-extern uLong ZEXPORT unzGetOffset (unzFile file);
-
-/* Set the current file offset */
-extern int ZEXPORT unzSetOffset64 (unzFile file, ZPOS64_T pos);
-extern int ZEXPORT unzSetOffset (unzFile file, uLong pos);
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _unz64_H */
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/zip.c gcc-4.8.1-ppc/zlib/contrib/minizip/zip.c
--- gcc-4.8.1/zlib/contrib/minizip/zip.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/zip.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2007 +0,0 @@
-/* zip.c -- IO on .zip files using zlib
-   Version 1.1, February 14h, 2010
-   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications for Zip64 support
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-         For more info read MiniZip_info.txt
-
-         Changes
-   Oct-2009 - Mathias Svensson - Remove old C style function prototypes
-   Oct-2009 - Mathias Svensson - Added Zip64 Support when creating new file archives
-   Oct-2009 - Mathias Svensson - Did some code cleanup and refactoring to get better overview of some functions.
-   Oct-2009 - Mathias Svensson - Added zipRemoveExtraInfoBlock to strip extra field data from its ZIP64 data
-                                 It is used when recreting zip archive with RAW when deleting items from a zip.
-                                 ZIP64 data is automaticly added to items that needs it, and existing ZIP64 data need to be removed.
-   Oct-2009 - Mathias Svensson - Added support for BZIP2 as compression mode (bzip2 lib is required)
-   Jan-2010 - back to unzip and minizip 1.0 name scheme, with compatibility layer
-
-*/
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include "zlib.h"
-#include "zip.h"
-
-#ifdef STDC
-#  include <stddef.h>
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-#ifdef NO_ERRNO_H
-    extern int errno;
-#else
-#   include <errno.h>
-#endif
-
-
-#ifndef local
-#  define local static
-#endif
-/* compile with -Dlocal if your debugger can't find static symbols */
-
-#ifndef VERSIONMADEBY
-# define VERSIONMADEBY   (0x0) /* platform depedent */
-#endif
-
-#ifndef Z_BUFSIZE
-#define Z_BUFSIZE (64*1024) //(16384)
-#endif
-
-#ifndef Z_MAXFILENAMEINZIP
-#define Z_MAXFILENAMEINZIP (256)
-#endif
-
-#ifndef ALLOC
-# define ALLOC(size) (malloc(size))
-#endif
-#ifndef TRYFREE
-# define TRYFREE(p) {if (p) free(p);}
-#endif
-
-/*
-#define SIZECENTRALDIRITEM (0x2e)
-#define SIZEZIPLOCALHEADER (0x1e)
-*/
-
-/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */
-
-
-// NOT sure that this work on ALL platform
-#define MAKEULONG64(a, b) ((ZPOS64_T)(((unsigned long)(a)) | ((ZPOS64_T)((unsigned long)(b))) << 32))
-
-#ifndef SEEK_CUR
-#define SEEK_CUR    1
-#endif
-
-#ifndef SEEK_END
-#define SEEK_END    2
-#endif
-
-#ifndef SEEK_SET
-#define SEEK_SET    0
-#endif
-
-#ifndef DEF_MEM_LEVEL
-#if MAX_MEM_LEVEL >= 8
-#  define DEF_MEM_LEVEL 8
-#else
-#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#endif
-#endif
-const char zip_copyright[] =" zip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll";
-
-
-#define SIZEDATA_INDATABLOCK (4096-(4*4))
-
-#define LOCALHEADERMAGIC    (0x04034b50)
-#define CENTRALHEADERMAGIC  (0x02014b50)
-#define ENDHEADERMAGIC      (0x06054b50)
-#define ZIP64ENDHEADERMAGIC      (0x6064b50)
-#define ZIP64ENDLOCHEADERMAGIC   (0x7064b50)
-
-#define FLAG_LOCALHEADER_OFFSET (0x06)
-#define CRC_LOCALHEADER_OFFSET  (0x0e)
-
-#define SIZECENTRALHEADER (0x2e) /* 46 */
-
-typedef struct linkedlist_datablock_internal_s
-{
-  struct linkedlist_datablock_internal_s* next_datablock;
-  uLong  avail_in_this_block;
-  uLong  filled_in_this_block;
-  uLong  unused; /* for future use and alignement */
-  unsigned char data[SIZEDATA_INDATABLOCK];
-} linkedlist_datablock_internal;
-
-typedef struct linkedlist_data_s
-{
-    linkedlist_datablock_internal* first_block;
-    linkedlist_datablock_internal* last_block;
-} linkedlist_data;
-
-
-typedef struct
-{
-    z_stream stream;            /* zLib stream structure for inflate */
-#ifdef HAVE_BZIP2
-    bz_stream bstream;          /* bzLib stream structure for bziped */
-#endif
-
-    int  stream_initialised;    /* 1 is stream is initialised */
-    uInt pos_in_buffered_data;  /* last written byte in buffered_data */
-
-    ZPOS64_T pos_local_header;     /* offset of the local header of the file
-                                     currenty writing */
-    char* central_header;       /* central header data for the current file */
-    uLong size_centralExtra;
-    uLong size_centralheader;   /* size of the central header for cur file */
-    uLong size_centralExtraFree; /* Extra bytes allocated to the centralheader but that are not used */
-    uLong flag;                 /* flag of the file currently writing */
-
-    int  method;                /* compression method of file currenty wr.*/
-    int  raw;                   /* 1 for directly writing raw data */
-    Byte buffered_data[Z_BUFSIZE];/* buffer contain compressed data to be writ*/
-    uLong dosDate;
-    uLong crc32;
-    int  encrypt;
-    int  zip64;               /* Add ZIP64 extened information in the extra field */
-    ZPOS64_T pos_zip64extrainfo;
-    ZPOS64_T totalCompressedData;
-    ZPOS64_T totalUncompressedData;
-#ifndef NOCRYPT
-    unsigned long keys[3];     /* keys defining the pseudo-random sequence */
-    const unsigned long* pcrc_32_tab;
-    int crypt_header_size;
-#endif
-} curfile64_info;
-
-typedef struct
-{
-    zlib_filefunc64_32_def z_filefunc;
-    voidpf filestream;        /* io structore of the zipfile */
-    linkedlist_data central_dir;/* datablock with central dir in construction*/
-    int  in_opened_file_inzip;  /* 1 if a file in the zip is currently writ.*/
-    curfile64_info ci;            /* info on the file curretly writing */
-
-    ZPOS64_T begin_pos;            /* position of the beginning of the zipfile */
-    ZPOS64_T add_position_when_writting_offset;
-    ZPOS64_T number_entry;
-
-#ifndef NO_ADDFILEINEXISTINGZIP
-    char *globalcomment;
-#endif
-
-} zip64_internal;
-
-
-#ifndef NOCRYPT
-#define INCLUDECRYPTINGCODE_IFCRYPTALLOWED
-#include "crypt.h"
-#endif
-
-local linkedlist_datablock_internal* allocate_new_datablock()
-{
-    linkedlist_datablock_internal* ldi;
-    ldi = (linkedlist_datablock_internal*)
-                 ALLOC(sizeof(linkedlist_datablock_internal));
-    if (ldi!=NULL)
-    {
-        ldi->next_datablock = NULL ;
-        ldi->filled_in_this_block = 0 ;
-        ldi->avail_in_this_block = SIZEDATA_INDATABLOCK ;
-    }
-    return ldi;
-}
-
-local void free_datablock(linkedlist_datablock_internal* ldi)
-{
-    while (ldi!=NULL)
-    {
-        linkedlist_datablock_internal* ldinext = ldi->next_datablock;
-        TRYFREE(ldi);
-        ldi = ldinext;
-    }
-}
-
-local void init_linkedlist(linkedlist_data* ll)
-{
-    ll->first_block = ll->last_block = NULL;
-}
-
-local void free_linkedlist(linkedlist_data* ll)
-{
-    free_datablock(ll->first_block);
-    ll->first_block = ll->last_block = NULL;
-}
-
-
-local int add_data_in_datablock(linkedlist_data* ll, const void* buf, uLong len)
-{
-    linkedlist_datablock_internal* ldi;
-    const unsigned char* from_copy;
-
-    if (ll==NULL)
-        return ZIP_INTERNALERROR;
-
-    if (ll->last_block == NULL)
-    {
-        ll->first_block = ll->last_block = allocate_new_datablock();
-        if (ll->first_block == NULL)
-            return ZIP_INTERNALERROR;
-    }
-
-    ldi = ll->last_block;
-    from_copy = (unsigned char*)buf;
-
-    while (len>0)
-    {
-        uInt copy_this;
-        uInt i;
-        unsigned char* to_copy;
-
-        if (ldi->avail_in_this_block==0)
-        {
-            ldi->next_datablock = allocate_new_datablock();
-            if (ldi->next_datablock == NULL)
-                return ZIP_INTERNALERROR;
-            ldi = ldi->next_datablock ;
-            ll->last_block = ldi;
-        }
-
-        if (ldi->avail_in_this_block < len)
-            copy_this = (uInt)ldi->avail_in_this_block;
-        else
-            copy_this = (uInt)len;
-
-        to_copy = &(ldi->data[ldi->filled_in_this_block]);
-
-        for (i=0;i<copy_this;i++)
-            *(to_copy+i)=*(from_copy+i);
-
-        ldi->filled_in_this_block += copy_this;
-        ldi->avail_in_this_block -= copy_this;
-        from_copy += copy_this ;
-        len -= copy_this;
-    }
-    return ZIP_OK;
-}
-
-
-
-/****************************************************************************/
-
-#ifndef NO_ADDFILEINEXISTINGZIP
-/* ===========================================================================
-   Inputs a long in LSB order to the given file
-   nbByte == 1, 2 ,4 or 8 (byte, short or long, ZPOS64_T)
-*/
-
-local int zip64local_putValue OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T x, int nbByte));
-local int zip64local_putValue (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T x, int nbByte)
-{
-    unsigned char buf[8];
-    int n;
-    for (n = 0; n < nbByte; n++)
-    {
-        buf[n] = (unsigned char)(x & 0xff);
-        x >>= 8;
-    }
-    if (x != 0)
-      {     /* data overflow - hack for ZIP64 (X Roche) */
-      for (n = 0; n < nbByte; n++)
-        {
-          buf[n] = 0xff;
-        }
-      }
-
-    if (ZWRITE64(*pzlib_filefunc_def,filestream,buf,nbByte)!=(uLong)nbByte)
-        return ZIP_ERRNO;
-    else
-        return ZIP_OK;
-}
-
-local void zip64local_putValue_inmemory OF((void* dest, ZPOS64_T x, int nbByte));
-local void zip64local_putValue_inmemory (void* dest, ZPOS64_T x, int nbByte)
-{
-    unsigned char* buf=(unsigned char*)dest;
-    int n;
-    for (n = 0; n < nbByte; n++) {
-        buf[n] = (unsigned char)(x & 0xff);
-        x >>= 8;
-    }
-
-    if (x != 0)
-    {     /* data overflow - hack for ZIP64 */
-       for (n = 0; n < nbByte; n++)
-       {
-          buf[n] = 0xff;
-       }
-    }
-}
-
-/****************************************************************************/
-
-
-local uLong zip64local_TmzDateToDosDate(const tm_zip* ptm)
-{
-    uLong year = (uLong)ptm->tm_year;
-    if (year>=1980)
-        year-=1980;
-    else if (year>=80)
-        year-=80;
-    return
-      (uLong) (((ptm->tm_mday) + (32 * (ptm->tm_mon+1)) + (512 * year)) << 16) |
-        ((ptm->tm_sec/2) + (32* ptm->tm_min) + (2048 * (uLong)ptm->tm_hour));
-}
-
-
-/****************************************************************************/
-
-local int zip64local_getByte OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, int *pi));
-
-local int zip64local_getByte(const zlib_filefunc64_32_def* pzlib_filefunc_def,voidpf filestream,int* pi)
-{
-    unsigned char c;
-    int err = (int)ZREAD64(*pzlib_filefunc_def,filestream,&c,1);
-    if (err==1)
-    {
-        *pi = (int)c;
-        return ZIP_OK;
-    }
-    else
-    {
-        if (ZERROR64(*pzlib_filefunc_def,filestream))
-            return ZIP_ERRNO;
-        else
-            return ZIP_EOF;
-    }
-}
-
-
-/* ===========================================================================
-   Reads a long in LSB order from the given gz_stream. Sets
-*/
-local int zip64local_getShort OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong *pX));
-
-local int zip64local_getShort (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong* pX)
-{
-    uLong x ;
-    int i = 0;
-    int err;
-
-    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x = (uLong)i;
-
-    if (err==ZIP_OK)
-        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<8;
-
-    if (err==ZIP_OK)
-        *pX = x;
-    else
-        *pX = 0;
-    return err;
-}
-
-local int zip64local_getLong OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong *pX));
-
-local int zip64local_getLong (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong* pX)
-{
-    uLong x ;
-    int i = 0;
-    int err;
-
-    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x = (uLong)i;
-
-    if (err==ZIP_OK)
-        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<8;
-
-    if (err==ZIP_OK)
-        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<16;
-
-    if (err==ZIP_OK)
-        err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<24;
-
-    if (err==ZIP_OK)
-        *pX = x;
-    else
-        *pX = 0;
-    return err;
-}
-
-local int zip64local_getLong64 OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T *pX));
-
-
-local int zip64local_getLong64 (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T *pX)
-{
-  ZPOS64_T x;
-  int i = 0;
-  int err;
-
-  err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-  x = (ZPOS64_T)i;
-
-  if (err==ZIP_OK)
-    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-  x += ((ZPOS64_T)i)<<8;
-
-  if (err==ZIP_OK)
-    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-  x += ((ZPOS64_T)i)<<16;
-
-  if (err==ZIP_OK)
-    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-  x += ((ZPOS64_T)i)<<24;
-
-  if (err==ZIP_OK)
-    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-  x += ((ZPOS64_T)i)<<32;
-
-  if (err==ZIP_OK)
-    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-  x += ((ZPOS64_T)i)<<40;
-
-  if (err==ZIP_OK)
-    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-  x += ((ZPOS64_T)i)<<48;
-
-  if (err==ZIP_OK)
-    err = zip64local_getByte(pzlib_filefunc_def,filestream,&i);
-  x += ((ZPOS64_T)i)<<56;
-
-  if (err==ZIP_OK)
-    *pX = x;
-  else
-    *pX = 0;
-
-  return err;
-}
-
-#ifndef BUFREADCOMMENT
-#define BUFREADCOMMENT (0x400)
-#endif
-/*
-  Locate the Central directory of a zipfile (at the end, just before
-    the global comment)
-*/
-local ZPOS64_T zip64local_SearchCentralDir OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream));
-
-local ZPOS64_T zip64local_SearchCentralDir(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)
-{
-  unsigned char* buf;
-  ZPOS64_T uSizeFile;
-  ZPOS64_T uBackRead;
-  ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */
-  ZPOS64_T uPosFound=0;
-
-  if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
-    return 0;
-
-
-  uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);
-
-  if (uMaxBack>uSizeFile)
-    uMaxBack = uSizeFile;
-
-  buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
-  if (buf==NULL)
-    return 0;
-
-  uBackRead = 4;
-  while (uBackRead<uMaxBack)
-  {
-    uLong uReadSize;
-    ZPOS64_T uReadPos ;
-    int i;
-    if (uBackRead+BUFREADCOMMENT>uMaxBack)
-      uBackRead = uMaxBack;
-    else
-      uBackRead+=BUFREADCOMMENT;
-    uReadPos = uSizeFile-uBackRead ;
-
-    uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
-      (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
-    if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-      break;
-
-    if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
-      break;
-
-    for (i=(int)uReadSize-3; (i--)>0;)
-      if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&
-        ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))
-      {
-        uPosFound = uReadPos+i;
-        break;
-      }
-
-      if (uPosFound!=0)
-        break;
-  }
-  TRYFREE(buf);
-  return uPosFound;
-}
-
-/*
-Locate the End of Zip64 Central directory locator and from there find the CD of a zipfile (at the end, just before
-the global comment)
-*/
-local ZPOS64_T zip64local_SearchCentralDir64 OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream));
-
-local ZPOS64_T zip64local_SearchCentralDir64(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)
-{
-  unsigned char* buf;
-  ZPOS64_T uSizeFile;
-  ZPOS64_T uBackRead;
-  ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */
-  ZPOS64_T uPosFound=0;
-  uLong uL;
-  ZPOS64_T relativeOffset;
-
-  if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
-    return 0;
-
-  uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);
-
-  if (uMaxBack>uSizeFile)
-    uMaxBack = uSizeFile;
-
-  buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
-  if (buf==NULL)
-    return 0;
-
-  uBackRead = 4;
-  while (uBackRead<uMaxBack)
-  {
-    uLong uReadSize;
-    ZPOS64_T uReadPos;
-    int i;
-    if (uBackRead+BUFREADCOMMENT>uMaxBack)
-      uBackRead = uMaxBack;
-    else
-      uBackRead+=BUFREADCOMMENT;
-    uReadPos = uSizeFile-uBackRead ;
-
-    uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
-      (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
-    if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-      break;
-
-    if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
-      break;
-
-    for (i=(int)uReadSize-3; (i--)>0;)
-    {
-      // Signature "0x07064b50" Zip64 end of central directory locater
-      if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) && ((*(buf+i+2))==0x06) && ((*(buf+i+3))==0x07))
-      {
-        uPosFound = uReadPos+i;
-        break;
-      }
-    }
-
-      if (uPosFound!=0)
-        break;
-  }
-
-  TRYFREE(buf);
-  if (uPosFound == 0)
-    return 0;
-
-  /* Zip64 end of central directory locator */
-  if (ZSEEK64(*pzlib_filefunc_def,filestream, uPosFound,ZLIB_FILEFUNC_SEEK_SET)!=0)
-    return 0;
-
-  /* the signature, already checked */
-  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)
-    return 0;
-
-  /* number of the disk with the start of the zip64 end of  central directory */
-  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)
-    return 0;
-  if (uL != 0)
-    return 0;
-
-  /* relative offset of the zip64 end of central directory record */
-  if (zip64local_getLong64(pzlib_filefunc_def,filestream,&relativeOffset)!=ZIP_OK)
-    return 0;
-
-  /* total number of disks */
-  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)
-    return 0;
-  if (uL != 1)
-    return 0;
-
-  /* Goto Zip64 end of central directory record */
-  if (ZSEEK64(*pzlib_filefunc_def,filestream, relativeOffset,ZLIB_FILEFUNC_SEEK_SET)!=0)
-    return 0;
-
-  /* the signature */
-  if (zip64local_getLong(pzlib_filefunc_def,filestream,&uL)!=ZIP_OK)
-    return 0;
-
-  if (uL != 0x06064b50) // signature of 'Zip64 end of central directory'
-    return 0;
-
-  return relativeOffset;
-}
-
-int LoadCentralDirectoryRecord(zip64_internal* pziinit)
-{
-  int err=ZIP_OK;
-  ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
-
-  ZPOS64_T size_central_dir;     /* size of the central directory  */
-  ZPOS64_T offset_central_dir;   /* offset of start of central directory */
-  ZPOS64_T central_pos;
-  uLong uL;
-
-  uLong number_disk;          /* number of the current dist, used for
-                              spaning ZIP, unsupported, always 0*/
-  uLong number_disk_with_CD;  /* number the the disk with central dir, used
-                              for spaning ZIP, unsupported, always 0*/
-  ZPOS64_T number_entry;
-  ZPOS64_T number_entry_CD;      /* total number of entries in
-                                the central dir
-                                (same than number_entry on nospan) */
-  uLong VersionMadeBy;
-  uLong VersionNeeded;
-  uLong size_comment;
-
-  int hasZIP64Record = 0;
-
-  // check first if we find a ZIP64 record
-  central_pos = zip64local_SearchCentralDir64(&pziinit->z_filefunc,pziinit->filestream);
-  if(central_pos > 0)
-  {
-    hasZIP64Record = 1;
-  }
-  else if(central_pos == 0)
-  {
-    central_pos = zip64local_SearchCentralDir(&pziinit->z_filefunc,pziinit->filestream);
-  }
-
-/* disable to allow appending to empty ZIP archive
-        if (central_pos==0)
-            err=ZIP_ERRNO;
-*/
-
-  if(hasZIP64Record)
-  {
-    ZPOS64_T sizeEndOfCentralDirectory;
-    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)
-      err=ZIP_ERRNO;
-
-    /* the signature, already checked */
-    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&uL)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* size of zip64 end of central directory record */
-    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &sizeEndOfCentralDirectory)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* version made by */
-    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionMadeBy)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* version needed to extract */
-    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &VersionNeeded)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* number of this disk */
-    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&number_disk)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* number of the disk with the start of the central directory */
-    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&number_disk_with_CD)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* total number of entries in the central directory on this disk */
-    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream, &number_entry)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* total number of entries in the central directory */
-    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&number_entry_CD)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    if ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))
-      err=ZIP_BADZIPFILE;
-
-    /* size of the central directory */
-    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&size_central_dir)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* offset of start of central directory with respect to the
-    starting disk number */
-    if (zip64local_getLong64(&pziinit->z_filefunc, pziinit->filestream,&offset_central_dir)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    // TODO..
-    // read the comment from the standard central header.
-    size_comment = 0;
-  }
-  else
-  {
-    // Read End of central Directory info
-    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-      err=ZIP_ERRNO;
-
-    /* the signature, already checked */
-    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream,&uL)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* number of this disk */
-    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream,&number_disk)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* number of the disk with the start of the central directory */
-    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream,&number_disk_with_CD)!=ZIP_OK)
-      err=ZIP_ERRNO;
-
-    /* total number of entries in the central dir on this disk */
-    number_entry = 0;
-    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)
-      err=ZIP_ERRNO;
-    else
-      number_entry = uL;
-
-    /* total number of entries in the central dir */
-    number_entry_CD = 0;
-    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)
-      err=ZIP_ERRNO;
-    else
-      number_entry_CD = uL;
-
-    if ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))
-      err=ZIP_BADZIPFILE;
-
-    /* size of the central directory */
-    size_central_dir = 0;
-    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)
-      err=ZIP_ERRNO;
-    else
-      size_central_dir = uL;
-
-    /* offset of start of central directory with respect to the starting disk number */
-    offset_central_dir = 0;
-    if (zip64local_getLong(&pziinit->z_filefunc, pziinit->filestream, &uL)!=ZIP_OK)
-      err=ZIP_ERRNO;
-    else
-      offset_central_dir = uL;
-
-
-    /* zipfile global comment length */
-    if (zip64local_getShort(&pziinit->z_filefunc, pziinit->filestream, &size_comment)!=ZIP_OK)
-      err=ZIP_ERRNO;
-  }
-
-  if ((central_pos<offset_central_dir+size_central_dir) &&
-    (err==ZIP_OK))
-    err=ZIP_BADZIPFILE;
-
-  if (err!=ZIP_OK)
-  {
-    ZCLOSE64(pziinit->z_filefunc, pziinit->filestream);
-    return ZIP_ERRNO;
-  }
-
-  if (size_comment>0)
-  {
-    pziinit->globalcomment = (char*)ALLOC(size_comment+1);
-    if (pziinit->globalcomment)
-    {
-      size_comment = ZREAD64(pziinit->z_filefunc, pziinit->filestream, pziinit->globalcomment,size_comment);
-      pziinit->globalcomment[size_comment]=0;
-    }
-  }
-
-  byte_before_the_zipfile = central_pos - (offset_central_dir+size_central_dir);
-  pziinit->add_position_when_writting_offset = byte_before_the_zipfile;
-
-  {
-    ZPOS64_T size_central_dir_to_read = size_central_dir;
-    size_t buf_size = SIZEDATA_INDATABLOCK;
-    void* buf_read = (void*)ALLOC(buf_size);
-    if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir + byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)
-      err=ZIP_ERRNO;
-
-    while ((size_central_dir_to_read>0) && (err==ZIP_OK))
-    {
-      ZPOS64_T read_this = SIZEDATA_INDATABLOCK;
-      if (read_this > size_central_dir_to_read)
-        read_this = size_central_dir_to_read;
-
-      if (ZREAD64(pziinit->z_filefunc, pziinit->filestream,buf_read,(uLong)read_this) != read_this)
-        err=ZIP_ERRNO;
-
-      if (err==ZIP_OK)
-        err = add_data_in_datablock(&pziinit->central_dir,buf_read, (uLong)read_this);
-
-      size_central_dir_to_read-=read_this;
-    }
-    TRYFREE(buf_read);
-  }
-  pziinit->begin_pos = byte_before_the_zipfile;
-  pziinit->number_entry = number_entry_CD;
-
-  if (ZSEEK64(pziinit->z_filefunc, pziinit->filestream, offset_central_dir+byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET) != 0)
-    err=ZIP_ERRNO;
-
-  return err;
-}
-
-
-#endif /* !NO_ADDFILEINEXISTINGZIP*/
-
-
-/************************************************************/
-extern zipFile ZEXPORT zipOpen3 (const void *pathname, int append, zipcharpc* globalcomment, zlib_filefunc64_32_def* pzlib_filefunc64_32_def)
-{
-    zip64_internal ziinit;
-    zip64_internal* zi;
-    int err=ZIP_OK;
-
-    ziinit.z_filefunc.zseek32_file = NULL;
-    ziinit.z_filefunc.ztell32_file = NULL;
-    if (pzlib_filefunc64_32_def==NULL)
-        fill_fopen64_filefunc(&ziinit.z_filefunc.zfile_func64);
-    else
-        ziinit.z_filefunc = *pzlib_filefunc64_32_def;
-
-    ziinit.filestream = ZOPEN64(ziinit.z_filefunc,
-                  pathname,
-                  (append == APPEND_STATUS_CREATE) ?
-                  (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_CREATE) :
-                    (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_EXISTING));
-
-    if (ziinit.filestream == NULL)
-        return NULL;
-
-    if (append == APPEND_STATUS_CREATEAFTER)
-        ZSEEK64(ziinit.z_filefunc,ziinit.filestream,0,SEEK_END);
-
-    ziinit.begin_pos = ZTELL64(ziinit.z_filefunc,ziinit.filestream);
-    ziinit.in_opened_file_inzip = 0;
-    ziinit.ci.stream_initialised = 0;
-    ziinit.number_entry = 0;
-    ziinit.add_position_when_writting_offset = 0;
-    init_linkedlist(&(ziinit.central_dir));
-
-
-
-    zi = (zip64_internal*)ALLOC(sizeof(zip64_internal));
-    if (zi==NULL)
-    {
-        ZCLOSE64(ziinit.z_filefunc,ziinit.filestream);
-        return NULL;
-    }
-
-    /* now we add file in a zipfile */
-#    ifndef NO_ADDFILEINEXISTINGZIP
-    ziinit.globalcomment = NULL;
-    if (append == APPEND_STATUS_ADDINZIP)
-    {
-      // Read and Cache Central Directory Records
-      err = LoadCentralDirectoryRecord(&ziinit);
-    }
-
-    if (globalcomment)
-    {
-      *globalcomment = ziinit.globalcomment;
-    }
-#    endif /* !NO_ADDFILEINEXISTINGZIP*/
-
-    if (err != ZIP_OK)
-    {
-#    ifndef NO_ADDFILEINEXISTINGZIP
-        TRYFREE(ziinit.globalcomment);
-#    endif /* !NO_ADDFILEINEXISTINGZIP*/
-        TRYFREE(zi);
-        return NULL;
-    }
-    else
-    {
-        *zi = ziinit;
-        return (zipFile)zi;
-    }
-}
-
-extern zipFile ZEXPORT zipOpen2 (const char *pathname, int append, zipcharpc* globalcomment, zlib_filefunc_def* pzlib_filefunc32_def)
-{
-    if (pzlib_filefunc32_def != NULL)
-    {
-        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
-        fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill,pzlib_filefunc32_def);
-        return zipOpen3(pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);
-    }
-    else
-        return zipOpen3(pathname, append, globalcomment, NULL);
-}
-
-extern zipFile ZEXPORT zipOpen2_64 (const void *pathname, int append, zipcharpc* globalcomment, zlib_filefunc64_def* pzlib_filefunc_def)
-{
-    if (pzlib_filefunc_def != NULL)
-    {
-        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
-        zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;
-        zlib_filefunc64_32_def_fill.ztell32_file = NULL;
-        zlib_filefunc64_32_def_fill.zseek32_file = NULL;
-        return zipOpen3(pathname, append, globalcomment, &zlib_filefunc64_32_def_fill);
-    }
-    else
-        return zipOpen3(pathname, append, globalcomment, NULL);
-}
-
-
-
-extern zipFile ZEXPORT zipOpen (const char* pathname, int append)
-{
-    return zipOpen3((const void*)pathname,append,NULL,NULL);
-}
-
-extern zipFile ZEXPORT zipOpen64 (const void* pathname, int append)
-{
-    return zipOpen3(pathname,append,NULL,NULL);
-}
-
-int Write_LocalFileHeader(zip64_internal* zi, const char* filename, uInt size_extrafield_local, const void* extrafield_local)
-{
-  /* write the local header */
-  int err;
-  uInt size_filename = (uInt)strlen(filename);
-  uInt size_extrafield = size_extrafield_local;
-
-  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)LOCALHEADERMAGIC, 4);
-
-  if (err==ZIP_OK)
-  {
-    if(zi->ci.zip64)
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);/* version needed to extract */
-    else
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)20,2);/* version needed to extract */
-  }
-
-  if (err==ZIP_OK)
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.flag,2);
-
-  if (err==ZIP_OK)
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.method,2);
-
-  if (err==ZIP_OK)
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.dosDate,4);
-
-  // CRC / Compressed size / Uncompressed size will be filled in later and rewritten later
-  if (err==ZIP_OK)
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* crc 32, unknown */
-  if (err==ZIP_OK)
-  {
-    if(zi->ci.zip64)
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xFFFFFFFF,4); /* compressed size, unknown */
-    else
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* compressed size, unknown */
-  }
-  if (err==ZIP_OK)
-  {
-    if(zi->ci.zip64)
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xFFFFFFFF,4); /* uncompressed size, unknown */
-    else
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* uncompressed size, unknown */
-  }
-
-  if (err==ZIP_OK)
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_filename,2);
-
-  if(zi->ci.zip64)
-  {
-    size_extrafield += 20;
-  }
-
-  if (err==ZIP_OK)
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_extrafield,2);
-
-  if ((err==ZIP_OK) && (size_filename > 0))
-  {
-    if (ZWRITE64(zi->z_filefunc,zi->filestream,filename,size_filename)!=size_filename)
-      err = ZIP_ERRNO;
-  }
-
-  if ((err==ZIP_OK) && (size_extrafield_local > 0))
-  {
-    if (ZWRITE64(zi->z_filefunc, zi->filestream, extrafield_local, size_extrafield_local) != size_extrafield_local)
-      err = ZIP_ERRNO;
-  }
-
-
-  if ((err==ZIP_OK) && (zi->ci.zip64))
-  {
-      // write the Zip64 extended info
-      short HeaderID = 1;
-      short DataSize = 16;
-      ZPOS64_T CompressedSize = 0;
-      ZPOS64_T UncompressedSize = 0;
-
-      // Remember position of Zip64 extended info for the local file header. (needed when we update size after done with file)
-      zi->ci.pos_zip64extrainfo = ZTELL64(zi->z_filefunc,zi->filestream);
-
-      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (short)HeaderID,2);
-      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (short)DataSize,2);
-
-      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)UncompressedSize,8);
-      err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)CompressedSize,8);
-  }
-
-  return err;
-}
-
-/*
- NOTE.
- When writing RAW the ZIP64 extended information in extrafield_local and extrafield_global needs to be stripped
- before calling this function it can be done with zipRemoveExtraInfoBlock
-
- It is not done here because then we need to realloc a new buffer since parameters are 'const' and I want to minimize
- unnecessary allocations.
- */
-extern int ZEXPORT zipOpenNewFileInZip4_64 (zipFile file, const char* filename, const zip_fileinfo* zipfi,
-                                         const void* extrafield_local, uInt size_extrafield_local,
-                                         const void* extrafield_global, uInt size_extrafield_global,
-                                         const char* comment, int method, int level, int raw,
-                                         int windowBits,int memLevel, int strategy,
-                                         const char* password, uLong crcForCrypting,
-                                         uLong versionMadeBy, uLong flagBase, int zip64)
-{
-    zip64_internal* zi;
-    uInt size_filename;
-    uInt size_comment;
-    uInt i;
-    int err = ZIP_OK;
-
-#    ifdef NOCRYPT
-    (crcForCrypting);
-    if (password != NULL)
-        return ZIP_PARAMERROR;
-#    endif
-
-    if (file == NULL)
-        return ZIP_PARAMERROR;
-
-#ifdef HAVE_BZIP2
-    if ((method!=0) && (method!=Z_DEFLATED) && (method!=Z_BZIP2ED))
-      return ZIP_PARAMERROR;
-#else
-    if ((method!=0) && (method!=Z_DEFLATED))
-      return ZIP_PARAMERROR;
-#endif
-
-    zi = (zip64_internal*)file;
-
-    if (zi->in_opened_file_inzip == 1)
-    {
-        err = zipCloseFileInZip (file);
-        if (err != ZIP_OK)
-            return err;
-    }
-
-    if (filename==NULL)
-        filename="-";
-
-    if (comment==NULL)
-        size_comment = 0;
-    else
-        size_comment = (uInt)strlen(comment);
-
-    size_filename = (uInt)strlen(filename);
-
-    if (zipfi == NULL)
-        zi->ci.dosDate = 0;
-    else
-    {
-        if (zipfi->dosDate != 0)
-            zi->ci.dosDate = zipfi->dosDate;
-        else
-          zi->ci.dosDate = zip64local_TmzDateToDosDate(&zipfi->tmz_date);
-    }
-
-    zi->ci.flag = flagBase;
-    if ((level==8) || (level==9))
-      zi->ci.flag |= 2;
-    if (level==2)
-      zi->ci.flag |= 4;
-    if (level==1)
-      zi->ci.flag |= 6;
-    if (password != NULL)
-      zi->ci.flag |= 1;
-
-    zi->ci.crc32 = 0;
-    zi->ci.method = method;
-    zi->ci.encrypt = 0;
-    zi->ci.stream_initialised = 0;
-    zi->ci.pos_in_buffered_data = 0;
-    zi->ci.raw = raw;
-    zi->ci.pos_local_header = ZTELL64(zi->z_filefunc,zi->filestream);
-
-    zi->ci.size_centralheader = SIZECENTRALHEADER + size_filename + size_extrafield_global + size_comment;
-    zi->ci.size_centralExtraFree = 32; // Extra space we have reserved in case we need to add ZIP64 extra info data
-
-    zi->ci.central_header = (char*)ALLOC((uInt)zi->ci.size_centralheader + zi->ci.size_centralExtraFree);
-
-    zi->ci.size_centralExtra = size_extrafield_global;
-    zip64local_putValue_inmemory(zi->ci.central_header,(uLong)CENTRALHEADERMAGIC,4);
-    /* version info */
-    zip64local_putValue_inmemory(zi->ci.central_header+4,(uLong)versionMadeBy,2);
-    zip64local_putValue_inmemory(zi->ci.central_header+6,(uLong)20,2);
-    zip64local_putValue_inmemory(zi->ci.central_header+8,(uLong)zi->ci.flag,2);
-    zip64local_putValue_inmemory(zi->ci.central_header+10,(uLong)zi->ci.method,2);
-    zip64local_putValue_inmemory(zi->ci.central_header+12,(uLong)zi->ci.dosDate,4);
-    zip64local_putValue_inmemory(zi->ci.central_header+16,(uLong)0,4); /*crc*/
-    zip64local_putValue_inmemory(zi->ci.central_header+20,(uLong)0,4); /*compr size*/
-    zip64local_putValue_inmemory(zi->ci.central_header+24,(uLong)0,4); /*uncompr size*/
-    zip64local_putValue_inmemory(zi->ci.central_header+28,(uLong)size_filename,2);
-    zip64local_putValue_inmemory(zi->ci.central_header+30,(uLong)size_extrafield_global,2);
-    zip64local_putValue_inmemory(zi->ci.central_header+32,(uLong)size_comment,2);
-    zip64local_putValue_inmemory(zi->ci.central_header+34,(uLong)0,2); /*disk nm start*/
-
-    if (zipfi==NULL)
-        zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)0,2);
-    else
-        zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)zipfi->internal_fa,2);
-
-    if (zipfi==NULL)
-        zip64local_putValue_inmemory(zi->ci.central_header+38,(uLong)0,4);
-    else
-        zip64local_putValue_inmemory(zi->ci.central_header+38,(uLong)zipfi->external_fa,4);
-
-    if(zi->ci.pos_local_header >= 0xffffffff)
-      zip64local_putValue_inmemory(zi->ci.central_header+42,(uLong)0xffffffff,4);
-    else
-      zip64local_putValue_inmemory(zi->ci.central_header+42,(uLong)zi->ci.pos_local_header - zi->add_position_when_writting_offset,4);
-
-    for (i=0;i<size_filename;i++)
-        *(zi->ci.central_header+SIZECENTRALHEADER+i) = *(filename+i);
-
-    for (i=0;i<size_extrafield_global;i++)
-        *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+i) =
-              *(((const char*)extrafield_global)+i);
-
-    for (i=0;i<size_comment;i++)
-        *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+
-              size_extrafield_global+i) = *(comment+i);
-    if (zi->ci.central_header == NULL)
-        return ZIP_INTERNALERROR;
-
-    zi->ci.zip64 = zip64;
-    zi->ci.totalCompressedData = 0;
-    zi->ci.totalUncompressedData = 0;
-    zi->ci.pos_zip64extrainfo = 0;
-
-    err = Write_LocalFileHeader(zi, filename, size_extrafield_local, extrafield_local);
-
-#ifdef HAVE_BZIP2
-    zi->ci.bstream.avail_in = (uInt)0;
-    zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
-    zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
-    zi->ci.bstream.total_in_hi32 = 0;
-    zi->ci.bstream.total_in_lo32 = 0;
-    zi->ci.bstream.total_out_hi32 = 0;
-    zi->ci.bstream.total_out_lo32 = 0;
-#endif
-
-    zi->ci.stream.avail_in = (uInt)0;
-    zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
-    zi->ci.stream.next_out = zi->ci.buffered_data;
-    zi->ci.stream.total_in = 0;
-    zi->ci.stream.total_out = 0;
-    zi->ci.stream.data_type = Z_BINARY;
-
-#ifdef HAVE_BZIP2
-    if ((err==ZIP_OK) && (zi->ci.method == Z_DEFLATED || zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
-#else
-    if ((err==ZIP_OK) && (zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
-#endif
-    {
-        if(zi->ci.method == Z_DEFLATED)
-        {
-          zi->ci.stream.zalloc = (alloc_func)0;
-          zi->ci.stream.zfree = (free_func)0;
-          zi->ci.stream.opaque = (voidpf)0;
-
-          if (windowBits>0)
-              windowBits = -windowBits;
-
-          err = deflateInit2(&zi->ci.stream, level, Z_DEFLATED, windowBits, memLevel, strategy);
-
-          if (err==Z_OK)
-              zi->ci.stream_initialised = Z_DEFLATED;
-        }
-        else if(zi->ci.method == Z_BZIP2ED)
-        {
-#ifdef HAVE_BZIP2
-            // Init BZip stuff here
-          zi->ci.bstream.bzalloc = 0;
-          zi->ci.bstream.bzfree = 0;
-          zi->ci.bstream.opaque = (voidpf)0;
-
-          err = BZ2_bzCompressInit(&zi->ci.bstream, level, 0,35);
-          if(err == BZ_OK)
-            zi->ci.stream_initialised = Z_BZIP2ED;
-#endif
-        }
-
-    }
-
-#    ifndef NOCRYPT
-    zi->ci.crypt_header_size = 0;
-    if ((err==Z_OK) && (password != NULL))
-    {
-        unsigned char bufHead[RAND_HEAD_LEN];
-        unsigned int sizeHead;
-        zi->ci.encrypt = 1;
-        zi->ci.pcrc_32_tab = get_crc_table();
-        /*init_keys(password,zi->ci.keys,zi->ci.pcrc_32_tab);*/
-
-        sizeHead=crypthead(password,bufHead,RAND_HEAD_LEN,zi->ci.keys,zi->ci.pcrc_32_tab,crcForCrypting);
-        zi->ci.crypt_header_size = sizeHead;
-
-        if (ZWRITE64(zi->z_filefunc,zi->filestream,bufHead,sizeHead) != sizeHead)
-                err = ZIP_ERRNO;
-    }
-#    endif
-
-    if (err==Z_OK)
-        zi->in_opened_file_inzip = 1;
-    return err;
-}
-
-extern int ZEXPORT zipOpenNewFileInZip4 (zipFile file, const char* filename, const zip_fileinfo* zipfi,
-                                         const void* extrafield_local, uInt size_extrafield_local,
-                                         const void* extrafield_global, uInt size_extrafield_global,
-                                         const char* comment, int method, int level, int raw,
-                                         int windowBits,int memLevel, int strategy,
-                                         const char* password, uLong crcForCrypting,
-                                         uLong versionMadeBy, uLong flagBase)
-{
-    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
-                                 extrafield_local, size_extrafield_local,
-                                 extrafield_global, size_extrafield_global,
-                                 comment, method, level, raw,
-                                 windowBits, memLevel, strategy,
-                                 password, crcForCrypting, versionMadeBy, flagBase, 0);
-}
-
-extern int ZEXPORT zipOpenNewFileInZip3 (zipFile file, const char* filename, const zip_fileinfo* zipfi,
-                                         const void* extrafield_local, uInt size_extrafield_local,
-                                         const void* extrafield_global, uInt size_extrafield_global,
-                                         const char* comment, int method, int level, int raw,
-                                         int windowBits,int memLevel, int strategy,
-                                         const char* password, uLong crcForCrypting)
-{
-    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
-                                 extrafield_local, size_extrafield_local,
-                                 extrafield_global, size_extrafield_global,
-                                 comment, method, level, raw,
-                                 windowBits, memLevel, strategy,
-                                 password, crcForCrypting, VERSIONMADEBY, 0, 0);
-}
-
-extern int ZEXPORT zipOpenNewFileInZip3_64(zipFile file, const char* filename, const zip_fileinfo* zipfi,
-                                         const void* extrafield_local, uInt size_extrafield_local,
-                                         const void* extrafield_global, uInt size_extrafield_global,
-                                         const char* comment, int method, int level, int raw,
-                                         int windowBits,int memLevel, int strategy,
-                                         const char* password, uLong crcForCrypting, int zip64)
-{
-    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
-                                 extrafield_local, size_extrafield_local,
-                                 extrafield_global, size_extrafield_global,
-                                 comment, method, level, raw,
-                                 windowBits, memLevel, strategy,
-                                 password, crcForCrypting, VERSIONMADEBY, 0, zip64);
-}
-
-extern int ZEXPORT zipOpenNewFileInZip2(zipFile file, const char* filename, const zip_fileinfo* zipfi,
-                                        const void* extrafield_local, uInt size_extrafield_local,
-                                        const void* extrafield_global, uInt size_extrafield_global,
-                                        const char* comment, int method, int level, int raw)
-{
-    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
-                                 extrafield_local, size_extrafield_local,
-                                 extrafield_global, size_extrafield_global,
-                                 comment, method, level, raw,
-                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
-                                 NULL, 0, VERSIONMADEBY, 0, 0);
-}
-
-extern int ZEXPORT zipOpenNewFileInZip2_64(zipFile file, const char* filename, const zip_fileinfo* zipfi,
-                                        const void* extrafield_local, uInt size_extrafield_local,
-                                        const void* extrafield_global, uInt size_extrafield_global,
-                                        const char* comment, int method, int level, int raw, int zip64)
-{
-    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
-                                 extrafield_local, size_extrafield_local,
-                                 extrafield_global, size_extrafield_global,
-                                 comment, method, level, raw,
-                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
-                                 NULL, 0, VERSIONMADEBY, 0, zip64);
-}
-
-extern int ZEXPORT zipOpenNewFileInZip64 (zipFile file, const char* filename, const zip_fileinfo* zipfi,
-                                        const void* extrafield_local, uInt size_extrafield_local,
-                                        const void*extrafield_global, uInt size_extrafield_global,
-                                        const char* comment, int method, int level, int zip64)
-{
-    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
-                                 extrafield_local, size_extrafield_local,
-                                 extrafield_global, size_extrafield_global,
-                                 comment, method, level, 0,
-                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
-                                 NULL, 0, VERSIONMADEBY, 0, zip64);
-}
-
-extern int ZEXPORT zipOpenNewFileInZip (zipFile file, const char* filename, const zip_fileinfo* zipfi,
-                                        const void* extrafield_local, uInt size_extrafield_local,
-                                        const void*extrafield_global, uInt size_extrafield_global,
-                                        const char* comment, int method, int level)
-{
-    return zipOpenNewFileInZip4_64 (file, filename, zipfi,
-                                 extrafield_local, size_extrafield_local,
-                                 extrafield_global, size_extrafield_global,
-                                 comment, method, level, 0,
-                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
-                                 NULL, 0, VERSIONMADEBY, 0, 0);
-}
-
-local int zip64FlushWriteBuffer(zip64_internal* zi)
-{
-    int err=ZIP_OK;
-
-    if (zi->ci.encrypt != 0)
-    {
-#ifndef NOCRYPT
-        uInt i;
-        int t;
-        for (i=0;i<zi->ci.pos_in_buffered_data;i++)
-            zi->ci.buffered_data[i] = zencode(zi->ci.keys, zi->ci.pcrc_32_tab, zi->ci.buffered_data[i],t);
-#endif
-    }
-
-    if (ZWRITE64(zi->z_filefunc,zi->filestream,zi->ci.buffered_data,zi->ci.pos_in_buffered_data) != zi->ci.pos_in_buffered_data)
-      err = ZIP_ERRNO;
-
-    zi->ci.totalCompressedData += zi->ci.pos_in_buffered_data;
-
-#ifdef HAVE_BZIP2
-    if(zi->ci.method == Z_BZIP2ED)
-    {
-      zi->ci.totalUncompressedData += zi->ci.bstream.total_in_lo32;
-      zi->ci.bstream.total_in_lo32 = 0;
-      zi->ci.bstream.total_in_hi32 = 0;
-    }
-    else
-#endif
-    {
-      zi->ci.totalUncompressedData += zi->ci.stream.total_in;
-      zi->ci.stream.total_in = 0;
-    }
-
-
-    zi->ci.pos_in_buffered_data = 0;
-
-    return err;
-}
-
-extern int ZEXPORT zipWriteInFileInZip (zipFile file,const void* buf,unsigned int len)
-{
-    zip64_internal* zi;
-    int err=ZIP_OK;
-
-    if (file == NULL)
-        return ZIP_PARAMERROR;
-    zi = (zip64_internal*)file;
-
-    if (zi->in_opened_file_inzip == 0)
-        return ZIP_PARAMERROR;
-
-    zi->ci.crc32 = crc32(zi->ci.crc32,buf,(uInt)len);
-
-#ifdef HAVE_BZIP2
-    if(zi->ci.method == Z_BZIP2ED && (!zi->ci.raw))
-    {
-      zi->ci.bstream.next_in = (void*)buf;
-      zi->ci.bstream.avail_in = len;
-      err = BZ_RUN_OK;
-
-      while ((err==BZ_RUN_OK) && (zi->ci.bstream.avail_in>0))
-      {
-        if (zi->ci.bstream.avail_out == 0)
-        {
-          if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
-            err = ZIP_ERRNO;
-          zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
-          zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
-        }
-
-
-        if(err != BZ_RUN_OK)
-          break;
-
-        if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
-        {
-          uLong uTotalOutBefore_lo = zi->ci.bstream.total_out_lo32;
-//          uLong uTotalOutBefore_hi = zi->ci.bstream.total_out_hi32;
-          err=BZ2_bzCompress(&zi->ci.bstream,  BZ_RUN);
-
-          zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore_lo) ;
-        }
-      }
-
-      if(err == BZ_RUN_OK)
-        err = ZIP_OK;
-    }
-    else
-#endif
-    {
-      zi->ci.stream.next_in = (Bytef*)buf;
-      zi->ci.stream.avail_in = len;
-
-      while ((err==ZIP_OK) && (zi->ci.stream.avail_in>0))
-      {
-          if (zi->ci.stream.avail_out == 0)
-          {
-              if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
-                  err = ZIP_ERRNO;
-              zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
-              zi->ci.stream.next_out = zi->ci.buffered_data;
-          }
-
-
-          if(err != ZIP_OK)
-              break;
-
-          if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
-          {
-              uLong uTotalOutBefore = zi->ci.stream.total_out;
-              err=deflate(&zi->ci.stream,  Z_NO_FLUSH);
-              if(uTotalOutBefore > zi->ci.stream.total_out)
-              {
-                int bBreak = 0;
-                bBreak++;
-              }
-
-              zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;
-          }
-          else
-          {
-              uInt copy_this,i;
-              if (zi->ci.stream.avail_in < zi->ci.stream.avail_out)
-                  copy_this = zi->ci.stream.avail_in;
-              else
-                  copy_this = zi->ci.stream.avail_out;
-
-              for (i = 0; i < copy_this; i++)
-                  *(((char*)zi->ci.stream.next_out)+i) =
-                      *(((const char*)zi->ci.stream.next_in)+i);
-              {
-                  zi->ci.stream.avail_in -= copy_this;
-                  zi->ci.stream.avail_out-= copy_this;
-                  zi->ci.stream.next_in+= copy_this;
-                  zi->ci.stream.next_out+= copy_this;
-                  zi->ci.stream.total_in+= copy_this;
-                  zi->ci.stream.total_out+= copy_this;
-                  zi->ci.pos_in_buffered_data += copy_this;
-              }
-          }
-      }// while(...)
-    }
-
-    return err;
-}
-
-extern int ZEXPORT zipCloseFileInZipRaw (zipFile file, uLong uncompressed_size, uLong crc32)
-{
-    return zipCloseFileInZipRaw64 (file, uncompressed_size, crc32);
-}
-
-extern int ZEXPORT zipCloseFileInZipRaw64 (zipFile file, ZPOS64_T uncompressed_size, uLong crc32)
-{
-    zip64_internal* zi;
-    ZPOS64_T compressed_size;
-    uLong invalidValue = 0xffffffff;
-    short datasize = 0;
-    int err=ZIP_OK;
-
-    if (file == NULL)
-        return ZIP_PARAMERROR;
-    zi = (zip64_internal*)file;
-
-    if (zi->in_opened_file_inzip == 0)
-        return ZIP_PARAMERROR;
-    zi->ci.stream.avail_in = 0;
-
-    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
-                {
-                        while (err==ZIP_OK)
-                        {
-                                uLong uTotalOutBefore;
-                                if (zi->ci.stream.avail_out == 0)
-                                {
-                                        if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
-                                                err = ZIP_ERRNO;
-                                        zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
-                                        zi->ci.stream.next_out = zi->ci.buffered_data;
-                                }
-                                uTotalOutBefore = zi->ci.stream.total_out;
-                                err=deflate(&zi->ci.stream,  Z_FINISH);
-                                zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;
-                        }
-                }
-    else if ((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
-    {
-#ifdef HAVE_BZIP2
-      err = BZ_FINISH_OK;
-      while (err==BZ_FINISH_OK)
-      {
-        uLong uTotalOutBefore;
-        if (zi->ci.bstream.avail_out == 0)
-        {
-          if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
-            err = ZIP_ERRNO;
-          zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
-          zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
-        }
-        uTotalOutBefore = zi->ci.bstream.total_out_lo32;
-        err=BZ2_bzCompress(&zi->ci.bstream,  BZ_FINISH);
-        if(err == BZ_STREAM_END)
-          err = Z_STREAM_END;
-
-        zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore);
-      }
-
-      if(err == BZ_FINISH_OK)
-        err = ZIP_OK;
-#endif
-    }
-
-    if (err==Z_STREAM_END)
-        err=ZIP_OK; /* this is normal */
-
-    if ((zi->ci.pos_in_buffered_data>0) && (err==ZIP_OK))
-                {
-        if (zip64FlushWriteBuffer(zi)==ZIP_ERRNO)
-            err = ZIP_ERRNO;
-                }
-
-    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
-    {
-        int tmp_err = deflateEnd(&zi->ci.stream);
-        if (err == ZIP_OK)
-            err = tmp_err;
-        zi->ci.stream_initialised = 0;
-    }
-#ifdef HAVE_BZIP2
-    else if((zi->ci.method == Z_BZIP2ED) && (!zi->ci.raw))
-    {
-      int tmperr = BZ2_bzCompressEnd(&zi->ci.bstream);
-                        if (err==ZIP_OK)
-                                err = tmperr;
-                        zi->ci.stream_initialised = 0;
-    }
-#endif
-
-    if (!zi->ci.raw)
-    {
-        crc32 = (uLong)zi->ci.crc32;
-        uncompressed_size = zi->ci.totalUncompressedData;
-    }
-    compressed_size = zi->ci.totalCompressedData;
-
-#    ifndef NOCRYPT
-    compressed_size += zi->ci.crypt_header_size;
-#    endif
-
-    // update Current Item crc and sizes,
-    if(compressed_size >= 0xffffffff || uncompressed_size >= 0xffffffff || zi->ci.pos_local_header >= 0xffffffff)
-    {
-      /*version Made by*/
-      zip64local_putValue_inmemory(zi->ci.central_header+4,(uLong)45,2);
-      /*version needed*/
-      zip64local_putValue_inmemory(zi->ci.central_header+6,(uLong)45,2);
-
-    }
-
-    zip64local_putValue_inmemory(zi->ci.central_header+16,crc32,4); /*crc*/
-
-
-    if(compressed_size >= 0xffffffff)
-      zip64local_putValue_inmemory(zi->ci.central_header+20, invalidValue,4); /*compr size*/
-    else
-      zip64local_putValue_inmemory(zi->ci.central_header+20, compressed_size,4); /*compr size*/
-
-    /// set internal file attributes field
-    if (zi->ci.stream.data_type == Z_ASCII)
-        zip64local_putValue_inmemory(zi->ci.central_header+36,(uLong)Z_ASCII,2);
-
-    if(uncompressed_size >= 0xffffffff)
-      zip64local_putValue_inmemory(zi->ci.central_header+24, invalidValue,4); /*uncompr size*/
-    else
-      zip64local_putValue_inmemory(zi->ci.central_header+24, uncompressed_size,4); /*uncompr size*/
-
-    // Add ZIP64 extra info field for uncompressed size
-    if(uncompressed_size >= 0xffffffff)
-      datasize += 8;
-
-    // Add ZIP64 extra info field for compressed size
-    if(compressed_size >= 0xffffffff)
-      datasize += 8;
-
-    // Add ZIP64 extra info field for relative offset to local file header of current file
-    if(zi->ci.pos_local_header >= 0xffffffff)
-      datasize += 8;
-
-    if(datasize > 0)
-    {
-      char* p = NULL;
-
-      if((uLong)(datasize + 4) > zi->ci.size_centralExtraFree)
-      {
-        // we can not write more data to the buffer that we have room for.
-        return ZIP_BADZIPFILE;
-      }
-
-      p = zi->ci.central_header + zi->ci.size_centralheader;
-
-      // Add Extra Information Header for 'ZIP64 information'
-      zip64local_putValue_inmemory(p, 0x0001, 2); // HeaderID
-      p += 2;
-      zip64local_putValue_inmemory(p, datasize, 2); // DataSize
-      p += 2;
-
-      if(uncompressed_size >= 0xffffffff)
-      {
-        zip64local_putValue_inmemory(p, uncompressed_size, 8);
-        p += 8;
-      }
-
-      if(compressed_size >= 0xffffffff)
-      {
-        zip64local_putValue_inmemory(p, compressed_size, 8);
-        p += 8;
-      }
-
-      if(zi->ci.pos_local_header >= 0xffffffff)
-      {
-        zip64local_putValue_inmemory(p, zi->ci.pos_local_header, 8);
-        p += 8;
-      }
-
-      // Update how much extra free space we got in the memory buffer
-      // and increase the centralheader size so the new ZIP64 fields are included
-      // ( 4 below is the size of HeaderID and DataSize field )
-      zi->ci.size_centralExtraFree -= datasize + 4;
-      zi->ci.size_centralheader += datasize + 4;
-
-      // Update the extra info size field
-      zi->ci.size_centralExtra += datasize + 4;
-      zip64local_putValue_inmemory(zi->ci.central_header+30,(uLong)zi->ci.size_centralExtra,2);
-    }
-
-    if (err==ZIP_OK)
-        err = add_data_in_datablock(&zi->central_dir, zi->ci.central_header, (uLong)zi->ci.size_centralheader);
-
-    free(zi->ci.central_header);
-
-    if (err==ZIP_OK)
-    {
-        // Update the LocalFileHeader with the new values.
-
-        ZPOS64_T cur_pos_inzip = ZTELL64(zi->z_filefunc,zi->filestream);
-
-        if (ZSEEK64(zi->z_filefunc,zi->filestream, zi->ci.pos_local_header + 14,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            err = ZIP_ERRNO;
-
-        if (err==ZIP_OK)
-            err = zip64local_putValue(&zi->z_filefunc,zi->filestream,crc32,4); /* crc 32, unknown */
-
-        if(uncompressed_size >= 0xffffffff || compressed_size >= 0xffffffff )
-        {
-          if(zi->ci.pos_zip64extrainfo > 0)
-          {
-            // Update the size in the ZIP64 extended field.
-            if (ZSEEK64(zi->z_filefunc,zi->filestream, zi->ci.pos_zip64extrainfo + 4,ZLIB_FILEFUNC_SEEK_SET)!=0)
-              err = ZIP_ERRNO;
-
-            if (err==ZIP_OK) /* compressed size, unknown */
-              err = zip64local_putValue(&zi->z_filefunc, zi->filestream, uncompressed_size, 8);
-
-            if (err==ZIP_OK) /* uncompressed size, unknown */
-              err = zip64local_putValue(&zi->z_filefunc, zi->filestream, compressed_size, 8);
-          }
-          else
-              err = ZIP_BADZIPFILE; // Caller passed zip64 = 0, so no room for zip64 info -> fatal
-        }
-        else
-        {
-          if (err==ZIP_OK) /* compressed size, unknown */
-              err = zip64local_putValue(&zi->z_filefunc,zi->filestream,compressed_size,4);
-
-          if (err==ZIP_OK) /* uncompressed size, unknown */
-              err = zip64local_putValue(&zi->z_filefunc,zi->filestream,uncompressed_size,4);
-        }
-
-        if (ZSEEK64(zi->z_filefunc,zi->filestream, cur_pos_inzip,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            err = ZIP_ERRNO;
-    }
-
-    zi->number_entry ++;
-    zi->in_opened_file_inzip = 0;
-
-    return err;
-}
-
-extern int ZEXPORT zipCloseFileInZip (zipFile file)
-{
-    return zipCloseFileInZipRaw (file,0,0);
-}
-
-int Write_Zip64EndOfCentralDirectoryLocator(zip64_internal* zi, ZPOS64_T zip64eocd_pos_inzip)
-{
-  int err = ZIP_OK;
-  ZPOS64_T pos = zip64eocd_pos_inzip - zi->add_position_when_writting_offset;
-
-  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDLOCHEADERMAGIC,4);
-
-  /*num disks*/
-    if (err==ZIP_OK) /* number of the disk with the start of the central directory */
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);
-
-  /*relative offset*/
-    if (err==ZIP_OK) /* Relative offset to the Zip64EndOfCentralDirectory */
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, pos,8);
-
-  /*total disks*/ /* Do not support spawning of disk so always say 1 here*/
-    if (err==ZIP_OK) /* number of the disk with the start of the central directory */
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)1,4);
-
-    return err;
-}
-
-int Write_Zip64EndOfCentralDirectoryRecord(zip64_internal* zi, uLong size_centraldir, ZPOS64_T centraldir_pos_inzip)
-{
-  int err = ZIP_OK;
-
-  uLong Zip64DataSize = 44;
-
-  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ZIP64ENDHEADERMAGIC,4);
-
-  if (err==ZIP_OK) /* size of this 'zip64 end of central directory' */
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(ZPOS64_T)Zip64DataSize,8); // why ZPOS64_T of this ?
-
-  if (err==ZIP_OK) /* version made by */
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);
-
-  if (err==ZIP_OK) /* version needed */
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)45,2);
-
-  if (err==ZIP_OK) /* number of this disk */
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);
-
-  if (err==ZIP_OK) /* number of the disk with the start of the central directory */
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4);
-
-  if (err==ZIP_OK) /* total number of entries in the central dir on this disk */
-    err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);
-
-  if (err==ZIP_OK) /* total number of entries in the central dir */
-    err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);
-
-  if (err==ZIP_OK) /* size of the central directory */
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(ZPOS64_T)size_centraldir,8);
-
-  if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */
-  {
-    ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (ZPOS64_T)pos,8);
-  }
-  return err;
-}
-int Write_EndOfCentralDirectoryRecord(zip64_internal* zi, uLong size_centraldir, ZPOS64_T centraldir_pos_inzip)
-{
-  int err = ZIP_OK;
-
-  /*signature*/
-  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)ENDHEADERMAGIC,4);
-
-  if (err==ZIP_OK) /* number of this disk */
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);
-
-  if (err==ZIP_OK) /* number of the disk with the start of the central directory */
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);
-
-  if (err==ZIP_OK) /* total number of entries in the central dir on this disk */
-  {
-    {
-      if(zi->number_entry >= 0xFFFF)
-        err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xffff,2); // use value in ZIP64 record
-      else
-        err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);
-    }
-  }
-
-  if (err==ZIP_OK) /* total number of entries in the central dir */
-  {
-    if(zi->number_entry >= 0xFFFF)
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)0xffff,2); // use value in ZIP64 record
-    else
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);
-  }
-
-  if (err==ZIP_OK) /* size of the central directory */
-    err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_centraldir,4);
-
-  if (err==ZIP_OK) /* offset of start of central directory with respect to the starting disk number */
-  {
-    ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;
-    if(pos >= 0xffffffff)
-    {
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)0xffffffff,4);
-    }
-    else
-      err = zip64local_putValue(&zi->z_filefunc,zi->filestream, (uLong)(centraldir_pos_inzip - zi->add_position_when_writting_offset),4);
-  }
-
-   return err;
-}
-
-int Write_GlobalComment(zip64_internal* zi, const char* global_comment)
-{
-  int err = ZIP_OK;
-  uInt size_global_comment = 0;
-
-  if(global_comment != NULL)
-    size_global_comment = (uInt)strlen(global_comment);
-
-  err = zip64local_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_global_comment,2);
-
-  if (err == ZIP_OK && size_global_comment > 0)
-  {
-    if (ZWRITE64(zi->z_filefunc,zi->filestream, global_comment, size_global_comment) != size_global_comment)
-      err = ZIP_ERRNO;
-  }
-  return err;
-}
-
-extern int ZEXPORT zipClose (zipFile file, const char* global_comment)
-{
-    zip64_internal* zi;
-    int err = 0;
-    uLong size_centraldir = 0;
-    ZPOS64_T centraldir_pos_inzip;
-    ZPOS64_T pos;
-
-    if (file == NULL)
-        return ZIP_PARAMERROR;
-
-    zi = (zip64_internal*)file;
-
-    if (zi->in_opened_file_inzip == 1)
-    {
-        err = zipCloseFileInZip (file);
-    }
-
-#ifndef NO_ADDFILEINEXISTINGZIP
-    if (global_comment==NULL)
-        global_comment = zi->globalcomment;
-#endif
-
-    centraldir_pos_inzip = ZTELL64(zi->z_filefunc,zi->filestream);
-
-    if (err==ZIP_OK)
-    {
-        linkedlist_datablock_internal* ldi = zi->central_dir.first_block;
-        while (ldi!=NULL)
-        {
-            if ((err==ZIP_OK) && (ldi->filled_in_this_block>0))
-            {
-                if (ZWRITE64(zi->z_filefunc,zi->filestream, ldi->data, ldi->filled_in_this_block) != ldi->filled_in_this_block)
-                    err = ZIP_ERRNO;
-            }
-
-            size_centraldir += ldi->filled_in_this_block;
-            ldi = ldi->next_datablock;
-        }
-    }
-    free_linkedlist(&(zi->central_dir));
-
-    pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;
-    if(pos >= 0xffffffff || zi->number_entry > 0xFFFF)
-    {
-      ZPOS64_T Zip64EOCDpos = ZTELL64(zi->z_filefunc,zi->filestream);
-      Write_Zip64EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);
-
-      Write_Zip64EndOfCentralDirectoryLocator(zi, Zip64EOCDpos);
-    }
-
-    if (err==ZIP_OK)
-      err = Write_EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);
-
-    if(err == ZIP_OK)
-      err = Write_GlobalComment(zi, global_comment);
-
-    if (ZCLOSE64(zi->z_filefunc,zi->filestream) != 0)
-        if (err == ZIP_OK)
-            err = ZIP_ERRNO;
-
-#ifndef NO_ADDFILEINEXISTINGZIP
-    TRYFREE(zi->globalcomment);
-#endif
-    TRYFREE(zi);
-
-    return err;
-}
-
-extern int ZEXPORT zipRemoveExtraInfoBlock (char* pData, int* dataLen, short sHeader)
-{
-  char* p = pData;
-  int size = 0;
-  char* pNewHeader;
-  char* pTmp;
-  short header;
-  short dataSize;
-
-  int retVal = ZIP_OK;
-
-  if(pData == NULL || *dataLen < 4)
-    return ZIP_PARAMERROR;
-
-  pNewHeader = (char*)ALLOC(*dataLen);
-  pTmp = pNewHeader;
-
-  while(p < (pData + *dataLen))
-  {
-    header = *(short*)p;
-    dataSize = *(((short*)p)+1);
-
-    if( header == sHeader ) // Header found.
-    {
-      p += dataSize + 4; // skip it. do not copy to temp buffer
-    }
-    else
-    {
-      // Extra Info block should not be removed, So copy it to the temp buffer.
-      memcpy(pTmp, p, dataSize + 4);
-      p += dataSize + 4;
-      size += dataSize + 4;
-    }
-
-  }
-
-  if(size < *dataLen)
-  {
-    // clean old extra info block.
-    memset(pData,0, *dataLen);
-
-    // copy the new extra info block over the old
-    if(size > 0)
-      memcpy(pData, pNewHeader, size);
-
-    // set the new extra info size
-    *dataLen = size;
-
-    retVal = ZIP_OK;
-  }
-  else
-    retVal = ZIP_ERRNO;
-
-  TRYFREE(pNewHeader);
-
-  return retVal;
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/minizip/zip.h gcc-4.8.1-ppc/zlib/contrib/minizip/zip.h
--- gcc-4.8.1/zlib/contrib/minizip/zip.h	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/minizip/zip.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,362 +0,0 @@
-/* zip.h -- IO on .zip files using zlib
-   Version 1.1, February 14h, 2010
-   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
-
-         Modifications for Zip64 support
-         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
-
-         For more info read MiniZip_info.txt
-
-         ---------------------------------------------------------------------------
-
-   Condition of use and distribution are the same than zlib :
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-        ---------------------------------------------------------------------------
-
-        Changes
-
-        See header of zip.h
-
-*/
-
-#ifndef _zip12_H
-#define _zip12_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-//#define HAVE_BZIP2
-
-#ifndef _ZLIB_H
-#include "zlib.h"
-#endif
-
-#ifndef _ZLIBIOAPI_H
-#include "ioapi.h"
-#endif
-
-#ifdef HAVE_BZIP2
-#include "bzlib.h"
-#endif
-
-#define Z_BZIP2ED 12
-
-#if defined(STRICTZIP) || defined(STRICTZIPUNZIP)
-/* like the STRICT of WIN32, we define a pointer that cannot be converted
-    from (void*) without cast */
-typedef struct TagzipFile__ { int unused; } zipFile__;
-typedef zipFile__ *zipFile;
-#else
-typedef voidp zipFile;
-#endif
-
-#define ZIP_OK                          (0)
-#define ZIP_EOF                         (0)
-#define ZIP_ERRNO                       (Z_ERRNO)
-#define ZIP_PARAMERROR                  (-102)
-#define ZIP_BADZIPFILE                  (-103)
-#define ZIP_INTERNALERROR               (-104)
-
-#ifndef DEF_MEM_LEVEL
-#  if MAX_MEM_LEVEL >= 8
-#    define DEF_MEM_LEVEL 8
-#  else
-#    define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#  endif
-#endif
-/* default memLevel */
-
-/* tm_zip contain date/time info */
-typedef struct tm_zip_s
-{
-    uInt tm_sec;            /* seconds after the minute - [0,59] */
-    uInt tm_min;            /* minutes after the hour - [0,59] */
-    uInt tm_hour;           /* hours since midnight - [0,23] */
-    uInt tm_mday;           /* day of the month - [1,31] */
-    uInt tm_mon;            /* months since January - [0,11] */
-    uInt tm_year;           /* years - [1980..2044] */
-} tm_zip;
-
-typedef struct
-{
-    tm_zip      tmz_date;       /* date in understandable format           */
-    uLong       dosDate;       /* if dos_date == 0, tmu_date is used      */
-/*    uLong       flag;        */   /* general purpose bit flag        2 bytes */
-
-    uLong       internal_fa;    /* internal file attributes        2 bytes */
-    uLong       external_fa;    /* external file attributes        4 bytes */
-} zip_fileinfo;
-
-typedef const char* zipcharpc;
-
-
-#define APPEND_STATUS_CREATE        (0)
-#define APPEND_STATUS_CREATEAFTER   (1)
-#define APPEND_STATUS_ADDINZIP      (2)
-
-extern zipFile ZEXPORT zipOpen OF((const char *pathname, int append));
-extern zipFile ZEXPORT zipOpen64 OF((const void *pathname, int append));
-/*
-  Create a zipfile.
-     pathname contain on Windows XP a filename like "c:\\zlib\\zlib113.zip" or on
-       an Unix computer "zlib/zlib113.zip".
-     if the file pathname exist and append==APPEND_STATUS_CREATEAFTER, the zip
-       will be created at the end of the file.
-         (useful if the file contain a self extractor code)
-     if the file pathname exist and append==APPEND_STATUS_ADDINZIP, we will
-       add files in existing zip (be sure you don't add file that doesn't exist)
-     If the zipfile cannot be opened, the return value is NULL.
-     Else, the return value is a zipFile Handle, usable with other function
-       of this zip package.
-*/
-
-/* Note : there is no delete function into a zipfile.
-   If you want delete file into a zipfile, you must open a zipfile, and create another
-   Of couse, you can use RAW reading and writing to copy the file you did not want delte
-*/
-
-extern zipFile ZEXPORT zipOpen2 OF((const char *pathname,
-                                   int append,
-                                   zipcharpc* globalcomment,
-                                   zlib_filefunc_def* pzlib_filefunc_def));
-
-extern zipFile ZEXPORT zipOpen2_64 OF((const void *pathname,
-                                   int append,
-                                   zipcharpc* globalcomment,
-                                   zlib_filefunc64_def* pzlib_filefunc_def));
-
-extern int ZEXPORT zipOpenNewFileInZip OF((zipFile file,
-                       const char* filename,
-                       const zip_fileinfo* zipfi,
-                       const void* extrafield_local,
-                       uInt size_extrafield_local,
-                       const void* extrafield_global,
-                       uInt size_extrafield_global,
-                       const char* comment,
-                       int method,
-                       int level));
-
-extern int ZEXPORT zipOpenNewFileInZip64 OF((zipFile file,
-                       const char* filename,
-                       const zip_fileinfo* zipfi,
-                       const void* extrafield_local,
-                       uInt size_extrafield_local,
-                       const void* extrafield_global,
-                       uInt size_extrafield_global,
-                       const char* comment,
-                       int method,
-                       int level,
-                       int zip64));
-
-/*
-  Open a file in the ZIP for writing.
-  filename : the filename in zip (if NULL, '-' without quote will be used
-  *zipfi contain supplemental information
-  if extrafield_local!=NULL and size_extrafield_local>0, extrafield_local
-    contains the extrafield data the the local header
-  if extrafield_global!=NULL and size_extrafield_global>0, extrafield_global
-    contains the extrafield data the the local header
-  if comment != NULL, comment contain the comment string
-  method contain the compression method (0 for store, Z_DEFLATED for deflate)
-  level contain the level of compression (can be Z_DEFAULT_COMPRESSION)
-  zip64 is set to 1 if a zip64 extended information block should be added to the local file header.
-                    this MUST be '1' if the uncompressed size is >= 0xffffffff.
-
-*/
-
-
-extern int ZEXPORT zipOpenNewFileInZip2 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw));
-
-
-extern int ZEXPORT zipOpenNewFileInZip2_64 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw,
-                                            int zip64));
-/*
-  Same than zipOpenNewFileInZip, except if raw=1, we write raw file
- */
-
-extern int ZEXPORT zipOpenNewFileInZip3 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw,
-                                            int windowBits,
-                                            int memLevel,
-                                            int strategy,
-                                            const char* password,
-                                            uLong crcForCrypting));
-
-extern int ZEXPORT zipOpenNewFileInZip3_64 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw,
-                                            int windowBits,
-                                            int memLevel,
-                                            int strategy,
-                                            const char* password,
-                                            uLong crcForCrypting,
-                                            int zip64
-                                            ));
-
-/*
-  Same than zipOpenNewFileInZip2, except
-    windowBits,memLevel,,strategy : see parameter strategy in deflateInit2
-    password : crypting password (NULL for no crypting)
-    crcForCrypting : crc of file to compress (needed for crypting)
- */
-
-extern int ZEXPORT zipOpenNewFileInZip4 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw,
-                                            int windowBits,
-                                            int memLevel,
-                                            int strategy,
-                                            const char* password,
-                                            uLong crcForCrypting,
-                                            uLong versionMadeBy,
-                                            uLong flagBase
-                                            ));
-
-
-extern int ZEXPORT zipOpenNewFileInZip4_64 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw,
-                                            int windowBits,
-                                            int memLevel,
-                                            int strategy,
-                                            const char* password,
-                                            uLong crcForCrypting,
-                                            uLong versionMadeBy,
-                                            uLong flagBase,
-                                            int zip64
-                                            ));
-/*
-  Same than zipOpenNewFileInZip4, except
-    versionMadeBy : value for Version made by field
-    flag : value for flag field (compression level info will be added)
- */
-
-
-extern int ZEXPORT zipWriteInFileInZip OF((zipFile file,
-                       const void* buf,
-                       unsigned len));
-/*
-  Write data in the zipfile
-*/
-
-extern int ZEXPORT zipCloseFileInZip OF((zipFile file));
-/*
-  Close the current file in the zipfile
-*/
-
-extern int ZEXPORT zipCloseFileInZipRaw OF((zipFile file,
-                                            uLong uncompressed_size,
-                                            uLong crc32));
-
-extern int ZEXPORT zipCloseFileInZipRaw64 OF((zipFile file,
-                                            ZPOS64_T uncompressed_size,
-                                            uLong crc32));
-
-/*
-  Close the current file in the zipfile, for file opened with
-    parameter raw=1 in zipOpenNewFileInZip2
-  uncompressed_size and crc32 are value for the uncompressed size
-*/
-
-extern int ZEXPORT zipClose OF((zipFile file,
-                const char* global_comment));
-/*
-  Close the zipfile
-*/
-
-
-extern int ZEXPORT zipRemoveExtraInfoBlock OF((char* pData, int* dataLen, short sHeader));
-/*
-  zipRemoveExtraInfoBlock -  Added by Mathias Svensson
-
-  Remove extra information block from a extra information data for the local file header or central directory header
-
-  It is needed to remove ZIP64 extra information blocks when before data is written if using RAW mode.
-
-  0x0001 is the signature header for the ZIP64 extra information blocks
-
-  usage.
-                        Remove ZIP64 Extra information from a central director extra field data
-              zipRemoveExtraInfoBlock(pCenDirExtraFieldData, &nCenDirExtraFieldDataLen, 0x0001);
-
-                        Remove ZIP64 Extra information from a Local File Header extra field data
-        zipRemoveExtraInfoBlock(pLocalHeaderExtraFieldData, &nLocalHeaderExtraFieldDataLen, 0x0001);
-*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _zip64_H */
diff -Nbaur gcc-4.8.1/zlib/contrib/pascal/example.pas gcc-4.8.1-ppc/zlib/contrib/pascal/example.pas
--- gcc-4.8.1/zlib/contrib/pascal/example.pas	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/pascal/example.pas	1970-01-01 01:00:00.000000000 +0100
@@ -1,599 +0,0 @@
-(* example.c -- usage example of the zlib compression library
- * Copyright (C) 1995-2003 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * Pascal translation
- * Copyright (C) 1998 by Jacques Nomssi Nzali.
- * For conditions of distribution and use, see copyright notice in readme.txt
- *
- * Adaptation to the zlibpas interface
- * Copyright (C) 2003 by Cosmin Truta.
- * For conditions of distribution and use, see copyright notice in readme.txt
- *)
-
-program example;
-
-{$DEFINE TEST_COMPRESS}
-{DO NOT $DEFINE TEST_GZIO}
-{$DEFINE TEST_DEFLATE}
-{$DEFINE TEST_INFLATE}
-{$DEFINE TEST_FLUSH}
-{$DEFINE TEST_SYNC}
-{$DEFINE TEST_DICT}
-
-uses SysUtils, zlibpas;
-
-const TESTFILE = 'foo.gz';
-
-(* "hello world" would be more standard, but the repeated "hello"
- * stresses the compression code better, sorry...
- *)
-const hello: PChar = 'hello, hello!';
-
-const dictionary: PChar = 'hello';
-
-var dictId: LongInt; (* Adler32 value of the dictionary *)
-
-procedure CHECK_ERR(err: Integer; msg: String);
-begin
-  if err <> Z_OK then
-  begin
-    WriteLn(msg, ' error: ', err);
-    Halt(1);
-  end;
-end;
-
-procedure EXIT_ERR(const msg: String);
-begin
-  WriteLn('Error: ', msg);
-  Halt(1);
-end;
-
-(* ===========================================================================
- * Test compress and uncompress
- *)
-{$IFDEF TEST_COMPRESS}
-procedure test_compress(compr: Pointer; comprLen: LongInt;
-                        uncompr: Pointer; uncomprLen: LongInt);
-var err: Integer;
-    len: LongInt;
-begin
-  len := StrLen(hello)+1;
-
-  err := compress(compr, comprLen, hello, len);
-  CHECK_ERR(err, 'compress');
-
-  StrCopy(PChar(uncompr), 'garbage');
-
-  err := uncompress(uncompr, uncomprLen, compr, comprLen);
-  CHECK_ERR(err, 'uncompress');
-
-  if StrComp(PChar(uncompr), hello) <> 0 then
-    EXIT_ERR('bad uncompress')
-  else
-    WriteLn('uncompress(): ', PChar(uncompr));
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test read/write of .gz files
- *)
-{$IFDEF TEST_GZIO}
-procedure test_gzio(const fname: PChar; (* compressed file name *)
-                    uncompr: Pointer;
-                    uncomprLen: LongInt);
-var err: Integer;
-    len: Integer;
-    zfile: gzFile;
-    pos: LongInt;
-begin
-  len := StrLen(hello)+1;
-
-  zfile := gzopen(fname, 'wb');
-  if zfile = NIL then
-  begin
-    WriteLn('gzopen error');
-    Halt(1);
-  end;
-  gzputc(zfile, 'h');
-  if gzputs(zfile, 'ello') <> 4 then
-  begin
-    WriteLn('gzputs err: ', gzerror(zfile, err));
-    Halt(1);
-  end;
-  {$IFDEF GZ_FORMAT_STRING}
-  if gzprintf(zfile, ', %s!', 'hello') <> 8 then
-  begin
-    WriteLn('gzprintf err: ', gzerror(zfile, err));
-    Halt(1);
-  end;
-  {$ELSE}
-  if gzputs(zfile, ', hello!') <> 8 then
-  begin
-    WriteLn('gzputs err: ', gzerror(zfile, err));
-    Halt(1);
-  end;
-  {$ENDIF}
-  gzseek(zfile, 1, SEEK_CUR); (* add one zero byte *)
-  gzclose(zfile);
-
-  zfile := gzopen(fname, 'rb');
-  if zfile = NIL then
-  begin
-    WriteLn('gzopen error');
-    Halt(1);
-  end;
-
-  StrCopy(PChar(uncompr), 'garbage');
-
-  if gzread(zfile, uncompr, uncomprLen) <> len then
-  begin
-    WriteLn('gzread err: ', gzerror(zfile, err));
-    Halt(1);
-  end;
-  if StrComp(PChar(uncompr), hello) <> 0 then
-  begin
-    WriteLn('bad gzread: ', PChar(uncompr));
-    Halt(1);
-  end
-  else
-    WriteLn('gzread(): ', PChar(uncompr));
-
-  pos := gzseek(zfile, -8, SEEK_CUR);
-  if (pos <> 6) or (gztell(zfile) <> pos) then
-  begin
-    WriteLn('gzseek error, pos=', pos, ', gztell=', gztell(zfile));
-    Halt(1);
-  end;
-
-  if gzgetc(zfile) <> ' ' then
-  begin
-    WriteLn('gzgetc error');
-    Halt(1);
-  end;
-
-  if gzungetc(' ', zfile) <> ' ' then
-  begin
-    WriteLn('gzungetc error');
-    Halt(1);
-  end;
-
-  gzgets(zfile, PChar(uncompr), uncomprLen);
-  uncomprLen := StrLen(PChar(uncompr));
-  if uncomprLen <> 7 then (* " hello!" *)
-  begin
-    WriteLn('gzgets err after gzseek: ', gzerror(zfile, err));
-    Halt(1);
-  end;
-  if StrComp(PChar(uncompr), hello + 6) <> 0 then
-  begin
-    WriteLn('bad gzgets after gzseek');
-    Halt(1);
-  end
-  else
-    WriteLn('gzgets() after gzseek: ', PChar(uncompr));
-
-  gzclose(zfile);
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test deflate with small buffers
- *)
-{$IFDEF TEST_DEFLATE}
-procedure test_deflate(compr: Pointer; comprLen: LongInt);
-var c_stream: z_stream; (* compression stream *)
-    err: Integer;
-    len: LongInt;
-begin
-  len := StrLen(hello)+1;
-
-  c_stream.zalloc := NIL;
-  c_stream.zfree := NIL;
-  c_stream.opaque := NIL;
-
-  err := deflateInit(c_stream, Z_DEFAULT_COMPRESSION);
-  CHECK_ERR(err, 'deflateInit');
-
-  c_stream.next_in := hello;
-  c_stream.next_out := compr;
-
-  while (c_stream.total_in <> len) and
-        (c_stream.total_out < comprLen) do
-  begin
-    c_stream.avail_out := 1; { force small buffers }
-    c_stream.avail_in := 1;
-    err := deflate(c_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, 'deflate');
-  end;
-
-  (* Finish the stream, still forcing small buffers: *)
-  while TRUE do
-  begin
-    c_stream.avail_out := 1;
-    err := deflate(c_stream, Z_FINISH);
-    if err = Z_STREAM_END then
-      break;
-    CHECK_ERR(err, 'deflate');
-  end;
-
-  err := deflateEnd(c_stream);
-  CHECK_ERR(err, 'deflateEnd');
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test inflate with small buffers
- *)
-{$IFDEF TEST_INFLATE}
-procedure test_inflate(compr: Pointer; comprLen : LongInt;
-                       uncompr: Pointer; uncomprLen : LongInt);
-var err: Integer;
-    d_stream: z_stream; (* decompression stream *)
-begin
-  StrCopy(PChar(uncompr), 'garbage');
-
-  d_stream.zalloc := NIL;
-  d_stream.zfree := NIL;
-  d_stream.opaque := NIL;
-
-  d_stream.next_in := compr;
-  d_stream.avail_in := 0;
-  d_stream.next_out := uncompr;
-
-  err := inflateInit(d_stream);
-  CHECK_ERR(err, 'inflateInit');
-
-  while (d_stream.total_out < uncomprLen) and
-        (d_stream.total_in < comprLen) do
-  begin
-    d_stream.avail_out := 1; (* force small buffers *)
-    d_stream.avail_in := 1;
-    err := inflate(d_stream, Z_NO_FLUSH);
-    if err = Z_STREAM_END then
-      break;
-    CHECK_ERR(err, 'inflate');
-  end;
-
-  err := inflateEnd(d_stream);
-  CHECK_ERR(err, 'inflateEnd');
-
-  if StrComp(PChar(uncompr), hello) <> 0 then
-    EXIT_ERR('bad inflate')
-  else
-    WriteLn('inflate(): ', PChar(uncompr));
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test deflate with large buffers and dynamic change of compression level
- *)
-{$IFDEF TEST_DEFLATE}
-procedure test_large_deflate(compr: Pointer; comprLen: LongInt;
-                             uncompr: Pointer; uncomprLen: LongInt);
-var c_stream: z_stream; (* compression stream *)
-    err: Integer;
-begin
-  c_stream.zalloc := NIL;
-  c_stream.zfree := NIL;
-  c_stream.opaque := NIL;
-
-  err := deflateInit(c_stream, Z_BEST_SPEED);
-  CHECK_ERR(err, 'deflateInit');
-
-  c_stream.next_out := compr;
-  c_stream.avail_out := Integer(comprLen);
-
-  (* At this point, uncompr is still mostly zeroes, so it should compress
-   * very well:
-   *)
-  c_stream.next_in := uncompr;
-  c_stream.avail_in := Integer(uncomprLen);
-  err := deflate(c_stream, Z_NO_FLUSH);
-  CHECK_ERR(err, 'deflate');
-  if c_stream.avail_in <> 0 then
-    EXIT_ERR('deflate not greedy');
-
-  (* Feed in already compressed data and switch to no compression: *)
-  deflateParams(c_stream, Z_NO_COMPRESSION, Z_DEFAULT_STRATEGY);
-  c_stream.next_in := compr;
-  c_stream.avail_in := Integer(comprLen div 2);
-  err := deflate(c_stream, Z_NO_FLUSH);
-  CHECK_ERR(err, 'deflate');
-
-  (* Switch back to compressing mode: *)
-  deflateParams(c_stream, Z_BEST_COMPRESSION, Z_FILTERED);
-  c_stream.next_in := uncompr;
-  c_stream.avail_in := Integer(uncomprLen);
-  err := deflate(c_stream, Z_NO_FLUSH);
-  CHECK_ERR(err, 'deflate');
-
-  err := deflate(c_stream, Z_FINISH);
-  if err <> Z_STREAM_END then
-    EXIT_ERR('deflate should report Z_STREAM_END');
-
-  err := deflateEnd(c_stream);
-  CHECK_ERR(err, 'deflateEnd');
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test inflate with large buffers
- *)
-{$IFDEF TEST_INFLATE}
-procedure test_large_inflate(compr: Pointer; comprLen: LongInt;
-                             uncompr: Pointer; uncomprLen: LongInt);
-var err: Integer;
-    d_stream: z_stream; (* decompression stream *)
-begin
-  StrCopy(PChar(uncompr), 'garbage');
-
-  d_stream.zalloc := NIL;
-  d_stream.zfree := NIL;
-  d_stream.opaque := NIL;
-
-  d_stream.next_in := compr;
-  d_stream.avail_in := Integer(comprLen);
-
-  err := inflateInit(d_stream);
-  CHECK_ERR(err, 'inflateInit');
-
-  while TRUE do
-  begin
-    d_stream.next_out := uncompr;            (* discard the output *)
-    d_stream.avail_out := Integer(uncomprLen);
-    err := inflate(d_stream, Z_NO_FLUSH);
-    if err = Z_STREAM_END then
-      break;
-    CHECK_ERR(err, 'large inflate');
-  end;
-
-  err := inflateEnd(d_stream);
-  CHECK_ERR(err, 'inflateEnd');
-
-  if d_stream.total_out <> 2 * uncomprLen + comprLen div 2 then
-  begin
-    WriteLn('bad large inflate: ', d_stream.total_out);
-    Halt(1);
-  end
-  else
-    WriteLn('large_inflate(): OK');
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test deflate with full flush
- *)
-{$IFDEF TEST_FLUSH}
-procedure test_flush(compr: Pointer; var comprLen : LongInt);
-var c_stream: z_stream; (* compression stream *)
-    err: Integer;
-    len: Integer;
-begin
-  len := StrLen(hello)+1;
-
-  c_stream.zalloc := NIL;
-  c_stream.zfree := NIL;
-  c_stream.opaque := NIL;
-
-  err := deflateInit(c_stream, Z_DEFAULT_COMPRESSION);
-  CHECK_ERR(err, 'deflateInit');
-
-  c_stream.next_in := hello;
-  c_stream.next_out := compr;
-  c_stream.avail_in := 3;
-  c_stream.avail_out := Integer(comprLen);
-  err := deflate(c_stream, Z_FULL_FLUSH);
-  CHECK_ERR(err, 'deflate');
-
-  Inc(PByteArray(compr)^[3]); (* force an error in first compressed block *)
-  c_stream.avail_in := len - 3;
-
-  err := deflate(c_stream, Z_FINISH);
-  if err <> Z_STREAM_END then
-    CHECK_ERR(err, 'deflate');
-
-  err := deflateEnd(c_stream);
-  CHECK_ERR(err, 'deflateEnd');
-
-  comprLen := c_stream.total_out;
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test inflateSync()
- *)
-{$IFDEF TEST_SYNC}
-procedure test_sync(compr: Pointer; comprLen: LongInt;
-                    uncompr: Pointer; uncomprLen : LongInt);
-var err: Integer;
-    d_stream: z_stream; (* decompression stream *)
-begin
-  StrCopy(PChar(uncompr), 'garbage');
-
-  d_stream.zalloc := NIL;
-  d_stream.zfree := NIL;
-  d_stream.opaque := NIL;
-
-  d_stream.next_in := compr;
-  d_stream.avail_in := 2; (* just read the zlib header *)
-
-  err := inflateInit(d_stream);
-  CHECK_ERR(err, 'inflateInit');
-
-  d_stream.next_out := uncompr;
-  d_stream.avail_out := Integer(uncomprLen);
-
-  inflate(d_stream, Z_NO_FLUSH);
-  CHECK_ERR(err, 'inflate');
-
-  d_stream.avail_in := Integer(comprLen-2);   (* read all compressed data *)
-  err := inflateSync(d_stream);               (* but skip the damaged part *)
-  CHECK_ERR(err, 'inflateSync');
-
-  err := inflate(d_stream, Z_FINISH);
-  if err <> Z_DATA_ERROR then
-    EXIT_ERR('inflate should report DATA_ERROR');
-    (* Because of incorrect adler32 *)
-
-  err := inflateEnd(d_stream);
-  CHECK_ERR(err, 'inflateEnd');
-
-  WriteLn('after inflateSync(): hel', PChar(uncompr));
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test deflate with preset dictionary
- *)
-{$IFDEF TEST_DICT}
-procedure test_dict_deflate(compr: Pointer; comprLen: LongInt);
-var c_stream: z_stream; (* compression stream *)
-    err: Integer;
-begin
-  c_stream.zalloc := NIL;
-  c_stream.zfree := NIL;
-  c_stream.opaque := NIL;
-
-  err := deflateInit(c_stream, Z_BEST_COMPRESSION);
-  CHECK_ERR(err, 'deflateInit');
-
-  err := deflateSetDictionary(c_stream, dictionary, StrLen(dictionary));
-  CHECK_ERR(err, 'deflateSetDictionary');
-
-  dictId := c_stream.adler;
-  c_stream.next_out := compr;
-  c_stream.avail_out := Integer(comprLen);
-
-  c_stream.next_in := hello;
-  c_stream.avail_in := StrLen(hello)+1;
-
-  err := deflate(c_stream, Z_FINISH);
-  if err <> Z_STREAM_END then
-    EXIT_ERR('deflate should report Z_STREAM_END');
-
-  err := deflateEnd(c_stream);
-  CHECK_ERR(err, 'deflateEnd');
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test inflate with a preset dictionary
- *)
-{$IFDEF TEST_DICT}
-procedure test_dict_inflate(compr: Pointer; comprLen: LongInt;
-                            uncompr: Pointer; uncomprLen: LongInt);
-var err: Integer;
-    d_stream: z_stream; (* decompression stream *)
-begin
-  StrCopy(PChar(uncompr), 'garbage');
-
-  d_stream.zalloc := NIL;
-  d_stream.zfree := NIL;
-  d_stream.opaque := NIL;
-
-  d_stream.next_in := compr;
-  d_stream.avail_in := Integer(comprLen);
-
-  err := inflateInit(d_stream);
-  CHECK_ERR(err, 'inflateInit');
-
-  d_stream.next_out := uncompr;
-  d_stream.avail_out := Integer(uncomprLen);
-
-  while TRUE do
-  begin
-    err := inflate(d_stream, Z_NO_FLUSH);
-    if err = Z_STREAM_END then
-      break;
-    if err = Z_NEED_DICT then
-    begin
-      if d_stream.adler <> dictId then
-        EXIT_ERR('unexpected dictionary');
-      err := inflateSetDictionary(d_stream, dictionary, StrLen(dictionary));
-    end;
-    CHECK_ERR(err, 'inflate with dict');
-  end;
-
-  err := inflateEnd(d_stream);
-  CHECK_ERR(err, 'inflateEnd');
-
-  if StrComp(PChar(uncompr), hello) <> 0 then
-    EXIT_ERR('bad inflate with dict')
-  else
-    WriteLn('inflate with dictionary: ', PChar(uncompr));
-end;
-{$ENDIF}
-
-var compr, uncompr: Pointer;
-    comprLen, uncomprLen: LongInt;
-
-begin
-  if zlibVersion^ <> ZLIB_VERSION[1] then
-    EXIT_ERR('Incompatible zlib version');
-
-  WriteLn('zlib version: ', zlibVersion);
-  WriteLn('zlib compile flags: ', Format('0x%x', [zlibCompileFlags]));
-
-  comprLen := 10000 * SizeOf(Integer); (* don't overflow on MSDOS *)
-  uncomprLen := comprLen;
-  GetMem(compr, comprLen);
-  GetMem(uncompr, uncomprLen);
-  if (compr = NIL) or (uncompr = NIL) then
-    EXIT_ERR('Out of memory');
-  (* compr and uncompr are cleared to avoid reading uninitialized
-   * data and to ensure that uncompr compresses well.
-   *)
-  FillChar(compr^, comprLen, 0);
-  FillChar(uncompr^, uncomprLen, 0);
-
-  {$IFDEF TEST_COMPRESS}
-  WriteLn('** Testing compress');
-  test_compress(compr, comprLen, uncompr, uncomprLen);
-  {$ENDIF}
-
-  {$IFDEF TEST_GZIO}
-  WriteLn('** Testing gzio');
-  if ParamCount >= 1 then
-    test_gzio(ParamStr(1), uncompr, uncomprLen)
-  else
-    test_gzio(TESTFILE, uncompr, uncomprLen);
-  {$ENDIF}
-
-  {$IFDEF TEST_DEFLATE}
-  WriteLn('** Testing deflate with small buffers');
-  test_deflate(compr, comprLen);
-  {$ENDIF}
-  {$IFDEF TEST_INFLATE}
-  WriteLn('** Testing inflate with small buffers');
-  test_inflate(compr, comprLen, uncompr, uncomprLen);
-  {$ENDIF}
-
-  {$IFDEF TEST_DEFLATE}
-  WriteLn('** Testing deflate with large buffers');
-  test_large_deflate(compr, comprLen, uncompr, uncomprLen);
-  {$ENDIF}
-  {$IFDEF TEST_INFLATE}
-  WriteLn('** Testing inflate with large buffers');
-  test_large_inflate(compr, comprLen, uncompr, uncomprLen);
-  {$ENDIF}
-
-  {$IFDEF TEST_FLUSH}
-  WriteLn('** Testing deflate with full flush');
-  test_flush(compr, comprLen);
-  {$ENDIF}
-  {$IFDEF TEST_SYNC}
-  WriteLn('** Testing inflateSync');
-  test_sync(compr, comprLen, uncompr, uncomprLen);
-  {$ENDIF}
-  comprLen := uncomprLen;
-
-  {$IFDEF TEST_DICT}
-  WriteLn('** Testing deflate and inflate with preset dictionary');
-  test_dict_deflate(compr, comprLen);
-  test_dict_inflate(compr, comprLen, uncompr, uncomprLen);
-  {$ENDIF}
-
-  FreeMem(compr, comprLen);
-  FreeMem(uncompr, uncomprLen);
-end.
diff -Nbaur gcc-4.8.1/zlib/contrib/pascal/readme.txt gcc-4.8.1-ppc/zlib/contrib/pascal/readme.txt
--- gcc-4.8.1/zlib/contrib/pascal/readme.txt	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/pascal/readme.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-
-This directory contains a Pascal (Delphi, Kylix) interface to the
-zlib data compression library.
-
-
-Directory listing
-=================
-
-zlibd32.mak     makefile for Borland C++
-example.pas     usage example of zlib
-zlibpas.pas     the Pascal interface to zlib
-readme.txt      this file
-
-
-Compatibility notes
-===================
-
-- Although the name "zlib" would have been more normal for the
-  zlibpas unit, this name is already taken by Borland's ZLib unit.
-  This is somehow unfortunate, because that unit is not a genuine
-  interface to the full-fledged zlib functionality, but a suite of
-  class wrappers around zlib streams.  Other essential features,
-  such as checksums, are missing.
-  It would have been more appropriate for that unit to have a name
-  like "ZStreams", or something similar.
-
-- The C and zlib-supplied types int, uInt, long, uLong, etc. are
-  translated directly into Pascal types of similar sizes (Integer,
-  LongInt, etc.), to avoid namespace pollution.  In particular,
-  there is no conversion of unsigned int into a Pascal unsigned
-  integer.  The Word type is non-portable and has the same size
-  (16 bits) both in a 16-bit and in a 32-bit environment, unlike
-  Integer.  Even if there is a 32-bit Cardinal type, there is no
-  real need for unsigned int in zlib under a 32-bit environment.
-
-- Except for the callbacks, the zlib function interfaces are
-  assuming the calling convention normally used in Pascal
-  (__pascal for DOS and Windows16, __fastcall for Windows32).
-  Since the cdecl keyword is used, the old Turbo Pascal does
-  not work with this interface.
-
-- The gz* function interfaces are not translated, to avoid
-  interfacing problems with the C runtime library.  Besides,
-    gzprintf(gzFile file, const char *format, ...)
-  cannot be translated into Pascal.
-
-
-Legal issues
-============
-
-The zlibpas interface is:
-  Copyright (C) 1995-2003 Jean-loup Gailly and Mark Adler.
-  Copyright (C) 1998 by Bob Dellaca.
-  Copyright (C) 2003 by Cosmin Truta.
-
-The example program is:
-  Copyright (C) 1995-2003 by Jean-loup Gailly.
-  Copyright (C) 1998,1999,2000 by Jacques Nomssi Nzali.
-  Copyright (C) 2003 by Cosmin Truta.
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
diff -Nbaur gcc-4.8.1/zlib/contrib/pascal/zlibd32.mak gcc-4.8.1-ppc/zlib/contrib/pascal/zlibd32.mak
--- gcc-4.8.1/zlib/contrib/pascal/zlibd32.mak	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/pascal/zlibd32.mak	1970-01-01 01:00:00.000000000 +0100
@@ -1,99 +0,0 @@
-# Makefile for zlib
-# For use with Delphi and C++ Builder under Win32
-# Updated for zlib 1.2.x by Cosmin Truta
-
-# ------------ Borland C++ ------------
-
-# This project uses the Delphi (fastcall/register) calling convention:
-LOC = -DZEXPORT=__fastcall -DZEXPORTVA=__cdecl
-
-CC = bcc32
-LD = bcc32
-AR = tlib
-# do not use "-pr" in CFLAGS
-CFLAGS = -a -d -k- -O2 $(LOC)
-LDFLAGS =
-
-
-# variables
-ZLIB_LIB = zlib.lib
-
-OBJ1 = adler32.obj compress.obj crc32.obj deflate.obj gzclose.obj gzlib.obj gzread.obj
-OBJ2 = gzwrite.obj infback.obj inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj
-OBJP1 = +adler32.obj+compress.obj+crc32.obj+deflate.obj+gzclose.obj+gzlib.obj+gzread.obj
-OBJP2 = +gzwrite.obj+infback.obj+inffast.obj+inflate.obj+inftrees.obj+trees.obj+uncompr.obj+zutil.obj
-
-
-# targets
-all: $(ZLIB_LIB) example.exe minigzip.exe
-
-.c.obj:
-	$(CC) -c $(CFLAGS) $*.c
-
-adler32.obj: adler32.c zlib.h zconf.h
-
-compress.obj: compress.c zlib.h zconf.h
-
-crc32.obj: crc32.c zlib.h zconf.h crc32.h
-
-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h
-
-gzclose.obj: gzclose.c zlib.h zconf.h gzguts.h
-
-gzlib.obj: gzlib.c zlib.h zconf.h gzguts.h
-
-gzread.obj: gzread.c zlib.h zconf.h gzguts.h
-
-gzwrite.obj: gzwrite.c zlib.h zconf.h gzguts.h
-
-infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h
-
-inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h
-
-trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h
-
-uncompr.obj: uncompr.c zlib.h zconf.h
-
-zutil.obj: zutil.c zutil.h zlib.h zconf.h
-
-example.obj: test/example.c zlib.h zconf.h
-
-minigzip.obj: test/minigzip.c zlib.h zconf.h
-
-
-# For the sake of the old Borland make,
-# the command line is cut to fit in the MS-DOS 128 byte limit:
-$(ZLIB_LIB): $(OBJ1) $(OBJ2)
-	-del $(ZLIB_LIB)
-	$(AR) $(ZLIB_LIB) $(OBJP1)
-	$(AR) $(ZLIB_LIB) $(OBJP2)
-
-
-# testing
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d
-
-example.exe: example.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) example.obj $(ZLIB_LIB)
-
-minigzip.exe: minigzip.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) minigzip.obj $(ZLIB_LIB)
-
-
-# cleanup
-clean:
-	-del *.obj
-	-del *.exe
-	-del *.lib
-	-del *.tds
-	-del zlib.bak
-	-del foo.gz
-
diff -Nbaur gcc-4.8.1/zlib/contrib/pascal/zlibpas.pas gcc-4.8.1-ppc/zlib/contrib/pascal/zlibpas.pas
--- gcc-4.8.1/zlib/contrib/pascal/zlibpas.pas	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/pascal/zlibpas.pas	1970-01-01 01:00:00.000000000 +0100
@@ -1,276 +0,0 @@
-(* zlibpas -- Pascal interface to the zlib data compression library
- *
- * Copyright (C) 2003 Cosmin Truta.
- * Derived from original sources by Bob Dellaca.
- * For conditions of distribution and use, see copyright notice in readme.txt
- *)
-
-unit zlibpas;
-
-interface
-
-const
-  ZLIB_VERSION = '1.2.7';
-  ZLIB_VERNUM  = $1270;
-
-type
-  alloc_func = function(opaque: Pointer; items, size: Integer): Pointer;
-                 cdecl;
-  free_func  = procedure(opaque, address: Pointer);
-                 cdecl;
-
-  in_func    = function(opaque: Pointer; var buf: PByte): Integer;
-                 cdecl;
-  out_func   = function(opaque: Pointer; buf: PByte; size: Integer): Integer;
-                 cdecl;
-
-  z_streamp = ^z_stream;
-  z_stream = packed record
-    next_in: PChar;       (* next input byte *)
-    avail_in: Integer;    (* number of bytes available at next_in *)
-    total_in: LongInt;    (* total nb of input bytes read so far *)
-
-    next_out: PChar;      (* next output byte should be put there *)
-    avail_out: Integer;   (* remaining free space at next_out *)
-    total_out: LongInt;   (* total nb of bytes output so far *)
-
-    msg: PChar;           (* last error message, NULL if no error *)
-    state: Pointer;       (* not visible by applications *)
-
-    zalloc: alloc_func;   (* used to allocate the internal state *)
-    zfree: free_func;     (* used to free the internal state *)
-    opaque: Pointer;      (* private data object passed to zalloc and zfree *)
-
-    data_type: Integer;   (* best guess about the data type: ascii or binary *)
-    adler: LongInt;       (* adler32 value of the uncompressed data *)
-    reserved: LongInt;    (* reserved for future use *)
-  end;
-
-  gz_headerp = ^gz_header;
-  gz_header = packed record
-    text: Integer;        (* true if compressed data believed to be text *)
-    time: LongInt;        (* modification time *)
-    xflags: Integer;      (* extra flags (not used when writing a gzip file) *)
-    os: Integer;          (* operating system *)
-    extra: PChar;         (* pointer to extra field or Z_NULL if none *)
-    extra_len: Integer;   (* extra field length (valid if extra != Z_NULL) *)
-    extra_max: Integer;   (* space at extra (only when reading header) *)
-    name: PChar;          (* pointer to zero-terminated file name or Z_NULL *)
-    name_max: Integer;    (* space at name (only when reading header) *)
-    comment: PChar;       (* pointer to zero-terminated comment or Z_NULL *)
-    comm_max: Integer;    (* space at comment (only when reading header) *)
-    hcrc: Integer;        (* true if there was or will be a header crc *)
-    done: Integer;        (* true when done reading gzip header *)
-  end;
-
-(* constants *)
-const
-  Z_NO_FLUSH      = 0;
-  Z_PARTIAL_FLUSH = 1;
-  Z_SYNC_FLUSH    = 2;
-  Z_FULL_FLUSH    = 3;
-  Z_FINISH        = 4;
-  Z_BLOCK         = 5;
-  Z_TREES         = 6;
-
-  Z_OK            =  0;
-  Z_STREAM_END    =  1;
-  Z_NEED_DICT     =  2;
-  Z_ERRNO         = -1;
-  Z_STREAM_ERROR  = -2;
-  Z_DATA_ERROR    = -3;
-  Z_MEM_ERROR     = -4;
-  Z_BUF_ERROR     = -5;
-  Z_VERSION_ERROR = -6;
-
-  Z_NO_COMPRESSION       =  0;
-  Z_BEST_SPEED           =  1;
-  Z_BEST_COMPRESSION     =  9;
-  Z_DEFAULT_COMPRESSION  = -1;
-
-  Z_FILTERED            = 1;
-  Z_HUFFMAN_ONLY        = 2;
-  Z_RLE                 = 3;
-  Z_FIXED               = 4;
-  Z_DEFAULT_STRATEGY    = 0;
-
-  Z_BINARY   = 0;
-  Z_TEXT     = 1;
-  Z_ASCII    = 1;
-  Z_UNKNOWN  = 2;
-
-  Z_DEFLATED = 8;
-
-(* basic functions *)
-function zlibVersion: PChar;
-function deflateInit(var strm: z_stream; level: Integer): Integer;
-function deflate(var strm: z_stream; flush: Integer): Integer;
-function deflateEnd(var strm: z_stream): Integer;
-function inflateInit(var strm: z_stream): Integer;
-function inflate(var strm: z_stream; flush: Integer): Integer;
-function inflateEnd(var strm: z_stream): Integer;
-
-(* advanced functions *)
-function deflateInit2(var strm: z_stream; level, method, windowBits,
-                      memLevel, strategy: Integer): Integer;
-function deflateSetDictionary(var strm: z_stream; const dictionary: PChar;
-                              dictLength: Integer): Integer;
-function deflateCopy(var dest, source: z_stream): Integer;
-function deflateReset(var strm: z_stream): Integer;
-function deflateParams(var strm: z_stream; level, strategy: Integer): Integer;
-function deflateTune(var strm: z_stream; good_length, max_lazy, nice_length, max_chain: Integer): Integer;
-function deflateBound(var strm: z_stream; sourceLen: LongInt): LongInt;
-function deflatePending(var strm: z_stream; var pending: Integer; var bits: Integer): Integer;
-function deflatePrime(var strm: z_stream; bits, value: Integer): Integer;
-function deflateSetHeader(var strm: z_stream; head: gz_header): Integer;
-function inflateInit2(var strm: z_stream; windowBits: Integer): Integer;
-function inflateSetDictionary(var strm: z_stream; const dictionary: PChar;
-                              dictLength: Integer): Integer;
-function inflateSync(var strm: z_stream): Integer;
-function inflateCopy(var dest, source: z_stream): Integer;
-function inflateReset(var strm: z_stream): Integer;
-function inflateReset2(var strm: z_stream; windowBits: Integer): Integer;
-function inflatePrime(var strm: z_stream; bits, value: Integer): Integer;
-function inflateMark(var strm: z_stream): LongInt;
-function inflateGetHeader(var strm: z_stream; var head: gz_header): Integer;
-function inflateBackInit(var strm: z_stream;
-                         windowBits: Integer; window: PChar): Integer;
-function inflateBack(var strm: z_stream; in_fn: in_func; in_desc: Pointer;
-                     out_fn: out_func; out_desc: Pointer): Integer;
-function inflateBackEnd(var strm: z_stream): Integer;
-function zlibCompileFlags: LongInt;
-
-(* utility functions *)
-function compress(dest: PChar; var destLen: LongInt;
-                  const source: PChar; sourceLen: LongInt): Integer;
-function compress2(dest: PChar; var destLen: LongInt;
-                  const source: PChar; sourceLen: LongInt;
-                  level: Integer): Integer;
-function compressBound(sourceLen: LongInt): LongInt;
-function uncompress(dest: PChar; var destLen: LongInt;
-                    const source: PChar; sourceLen: LongInt): Integer;
-
-(* checksum functions *)
-function adler32(adler: LongInt; const buf: PChar; len: Integer): LongInt;
-function adler32_combine(adler1, adler2, len2: LongInt): LongInt;
-function crc32(crc: LongInt; const buf: PChar; len: Integer): LongInt;
-function crc32_combine(crc1, crc2, len2: LongInt): LongInt;
-
-(* various hacks, don't look :) *)
-function deflateInit_(var strm: z_stream; level: Integer;
-                      const version: PChar; stream_size: Integer): Integer;
-function inflateInit_(var strm: z_stream; const version: PChar;
-                      stream_size: Integer): Integer;
-function deflateInit2_(var strm: z_stream;
-                       level, method, windowBits, memLevel, strategy: Integer;
-                       const version: PChar; stream_size: Integer): Integer;
-function inflateInit2_(var strm: z_stream; windowBits: Integer;
-                       const version: PChar; stream_size: Integer): Integer;
-function inflateBackInit_(var strm: z_stream;
-                          windowBits: Integer; window: PChar;
-                          const version: PChar; stream_size: Integer): Integer;
-
-
-implementation
-
-{$L adler32.obj}
-{$L compress.obj}
-{$L crc32.obj}
-{$L deflate.obj}
-{$L infback.obj}
-{$L inffast.obj}
-{$L inflate.obj}
-{$L inftrees.obj}
-{$L trees.obj}
-{$L uncompr.obj}
-{$L zutil.obj}
-
-function adler32; external;
-function adler32_combine; external;
-function compress; external;
-function compress2; external;
-function compressBound; external;
-function crc32; external;
-function crc32_combine; external;
-function deflate; external;
-function deflateBound; external;
-function deflateCopy; external;
-function deflateEnd; external;
-function deflateInit_; external;
-function deflateInit2_; external;
-function deflateParams; external;
-function deflatePending; external;
-function deflatePrime; external;
-function deflateReset; external;
-function deflateSetDictionary; external;
-function deflateSetHeader; external;
-function deflateTune; external;
-function inflate; external;
-function inflateBack; external;
-function inflateBackEnd; external;
-function inflateBackInit_; external;
-function inflateCopy; external;
-function inflateEnd; external;
-function inflateGetHeader; external;
-function inflateInit_; external;
-function inflateInit2_; external;
-function inflateMark; external;
-function inflatePrime; external;
-function inflateReset; external;
-function inflateReset2; external;
-function inflateSetDictionary; external;
-function inflateSync; external;
-function uncompress; external;
-function zlibCompileFlags; external;
-function zlibVersion; external;
-
-function deflateInit(var strm: z_stream; level: Integer): Integer;
-begin
-  Result := deflateInit_(strm, level, ZLIB_VERSION, sizeof(z_stream));
-end;
-
-function deflateInit2(var strm: z_stream; level, method, windowBits, memLevel,
-                      strategy: Integer): Integer;
-begin
-  Result := deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
-                          ZLIB_VERSION, sizeof(z_stream));
-end;
-
-function inflateInit(var strm: z_stream): Integer;
-begin
-  Result := inflateInit_(strm, ZLIB_VERSION, sizeof(z_stream));
-end;
-
-function inflateInit2(var strm: z_stream; windowBits: Integer): Integer;
-begin
-  Result := inflateInit2_(strm, windowBits, ZLIB_VERSION, sizeof(z_stream));
-end;
-
-function inflateBackInit(var strm: z_stream;
-                         windowBits: Integer; window: PChar): Integer;
-begin
-  Result := inflateBackInit_(strm, windowBits, window,
-                             ZLIB_VERSION, sizeof(z_stream));
-end;
-
-function _malloc(Size: Integer): Pointer; cdecl;
-begin
-  GetMem(Result, Size);
-end;
-
-procedure _free(Block: Pointer); cdecl;
-begin
-  FreeMem(Block);
-end;
-
-procedure _memset(P: Pointer; B: Byte; count: Integer); cdecl;
-begin
-  FillChar(P^, count, B);
-end;
-
-procedure _memcpy(dest, source: Pointer; count: Integer); cdecl;
-begin
-  Move(source^, dest^, count);
-end;
-
-end.
diff -Nbaur gcc-4.8.1/zlib/contrib/puff/Makefile gcc-4.8.1-ppc/zlib/contrib/puff/Makefile
--- gcc-4.8.1/zlib/contrib/puff/Makefile	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/puff/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,42 +0,0 @@
-CFLAGS=-O
-
-puff: puff.o pufftest.o
-
-puff.o: puff.h
-
-pufftest.o: puff.h
-
-test: puff
-	puff zeros.raw
-
-puft: puff.c puff.h pufftest.o
-	cc -fprofile-arcs -ftest-coverage -o puft puff.c pufftest.o
-
-# puff full coverage test (should say 100%)
-cov: puft
-	@rm -f *.gcov *.gcda
-	@puft -w zeros.raw 2>&1 | cat > /dev/null
-	@echo '04' | xxd -r -p | puft 2> /dev/null || test $$? -eq 2
-	@echo '00' | xxd -r -p | puft 2> /dev/null || test $$? -eq 2
-	@echo '00 00 00 00 00' | xxd -r -p | puft 2> /dev/null || test $$? -eq 254
-	@echo '00 01 00 fe ff' | xxd -r -p | puft 2> /dev/null || test $$? -eq 2
-	@echo '01 01 00 fe ff 0a' | xxd -r -p | puft -f 2>&1 | cat > /dev/null
-	@echo '02 7e ff ff' | xxd -r -p | puft 2> /dev/null || test $$? -eq 246
-	@echo '02' | xxd -r -p | puft 2> /dev/null || test $$? -eq 2
-	@echo '04 80 49 92 24 49 92 24 0f b4 ff ff c3 04' | xxd -r -p | puft 2> /dev/null || test $$? -eq 2
-	@echo '04 80 49 92 24 49 92 24 71 ff ff 93 11 00' | xxd -r -p | puft 2> /dev/null || test $$? -eq 249
-	@echo '04 c0 81 08 00 00 00 00 20 7f eb 0b 00 00' | xxd -r -p | puft 2> /dev/null || test $$? -eq 246
-	@echo '0b 00 00' | xxd -r -p | puft -f 2>&1 | cat > /dev/null
-	@echo '1a 07' | xxd -r -p | puft 2> /dev/null || test $$? -eq 246
-	@echo '0c c0 81 00 00 00 00 00 90 ff 6b 04' | xxd -r -p | puft 2> /dev/null || test $$? -eq 245
-	@puft -f zeros.raw 2>&1 | cat > /dev/null
-	@echo 'fc 00 00' | xxd -r -p | puft 2> /dev/null || test $$? -eq 253
-	@echo '04 00 fe ff' | xxd -r -p | puft 2> /dev/null || test $$? -eq 252
-	@echo '04 00 24 49' | xxd -r -p | puft 2> /dev/null || test $$? -eq 251
-	@echo '04 80 49 92 24 49 92 24 0f b4 ff ff c3 84' | xxd -r -p | puft 2> /dev/null || test $$? -eq 248
-	@echo '04 00 24 e9 ff ff' | xxd -r -p | puft 2> /dev/null || test $$? -eq 250
-	@echo '04 00 24 e9 ff 6d' | xxd -r -p | puft 2> /dev/null || test $$? -eq 247
-	@gcov -n puff.c
-
-clean:
-	rm -f puff puft *.o *.gc*
diff -Nbaur gcc-4.8.1/zlib/contrib/puff/puff.c gcc-4.8.1-ppc/zlib/contrib/puff/puff.c
--- gcc-4.8.1/zlib/contrib/puff/puff.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/puff/puff.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,837 +0,0 @@
-/*
- * puff.c
- * Copyright (C) 2002-2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in puff.h
- * version 2.2, 25 Apr 2010
- *
- * puff.c is a simple inflate written to be an unambiguous way to specify the
- * deflate format.  It is not written for speed but rather simplicity.  As a
- * side benefit, this code might actually be useful when small code is more
- * important than speed, such as bootstrap applications.  For typical deflate
- * data, zlib's inflate() is about four times as fast as puff().  zlib's
- * inflate compiles to around 20K on my machine, whereas puff.c compiles to
- * around 4K on my machine (a PowerPC using GNU cc).  If the faster decode()
- * function here is used, then puff() is only twice as slow as zlib's
- * inflate().
- *
- * All dynamically allocated memory comes from the stack.  The stack required
- * is less than 2K bytes.  This code is compatible with 16-bit int's and
- * assumes that long's are at least 32 bits.  puff.c uses the short data type,
- * assumed to be 16 bits, for arrays in order to to conserve memory.  The code
- * works whether integers are stored big endian or little endian.
- *
- * In the comments below are "Format notes" that describe the inflate process
- * and document some of the less obvious aspects of the format.  This source
- * code is meant to supplement RFC 1951, which formally describes the deflate
- * format:
- *
- *    http://www.zlib.org/rfc-deflate.html
- */
-
-/*
- * Change history:
- *
- * 1.0  10 Feb 2002     - First version
- * 1.1  17 Feb 2002     - Clarifications of some comments and notes
- *                      - Update puff() dest and source pointers on negative
- *                        errors to facilitate debugging deflators
- *                      - Remove longest from struct huffman -- not needed
- *                      - Simplify offs[] index in construct()
- *                      - Add input size and checking, using longjmp() to
- *                        maintain easy readability
- *                      - Use short data type for large arrays
- *                      - Use pointers instead of long to specify source and
- *                        destination sizes to avoid arbitrary 4 GB limits
- * 1.2  17 Mar 2002     - Add faster version of decode(), doubles speed (!),
- *                        but leave simple version for readabilty
- *                      - Make sure invalid distances detected if pointers
- *                        are 16 bits
- *                      - Fix fixed codes table error
- *                      - Provide a scanning mode for determining size of
- *                        uncompressed data
- * 1.3  20 Mar 2002     - Go back to lengths for puff() parameters [Gailly]
- *                      - Add a puff.h file for the interface
- *                      - Add braces in puff() for else do [Gailly]
- *                      - Use indexes instead of pointers for readability
- * 1.4  31 Mar 2002     - Simplify construct() code set check
- *                      - Fix some comments
- *                      - Add FIXLCODES #define
- * 1.5   6 Apr 2002     - Minor comment fixes
- * 1.6   7 Aug 2002     - Minor format changes
- * 1.7   3 Mar 2003     - Added test code for distribution
- *                      - Added zlib-like license
- * 1.8   9 Jan 2004     - Added some comments on no distance codes case
- * 1.9  21 Feb 2008     - Fix bug on 16-bit integer architectures [Pohland]
- *                      - Catch missing end-of-block symbol error
- * 2.0  25 Jul 2008     - Add #define to permit distance too far back
- *                      - Add option in TEST code for puff to write the data
- *                      - Add option in TEST code to skip input bytes
- *                      - Allow TEST code to read from piped stdin
- * 2.1   4 Apr 2010     - Avoid variable initialization for happier compilers
- *                      - Avoid unsigned comparisons for even happier compilers
- * 2.2  25 Apr 2010     - Fix bug in variable initializations [Oberhumer]
- *                      - Add const where appropriate [Oberhumer]
- *                      - Split if's and ?'s for coverage testing
- *                      - Break out test code to separate file
- *                      - Move NIL to puff.h
- *                      - Allow incomplete code only if single code length is 1
- *                      - Add full code coverage test to Makefile
- */
-
-#include <setjmp.h>             /* for setjmp(), longjmp(), and jmp_buf */
-#include "puff.h"               /* prototype for puff() */
-
-#define local static            /* for local function definitions */
-
-/*
- * Maximums for allocations and loops.  It is not useful to change these --
- * they are fixed by the deflate format.
- */
-#define MAXBITS 15              /* maximum bits in a code */
-#define MAXLCODES 286           /* maximum number of literal/length codes */
-#define MAXDCODES 30            /* maximum number of distance codes */
-#define MAXCODES (MAXLCODES+MAXDCODES)  /* maximum codes lengths to read */
-#define FIXLCODES 288           /* number of fixed literal/length codes */
-
-/* input and output state */
-struct state {
-    /* output state */
-    unsigned char *out;         /* output buffer */
-    unsigned long outlen;       /* available space at out */
-    unsigned long outcnt;       /* bytes written to out so far */
-
-    /* input state */
-    const unsigned char *in;    /* input buffer */
-    unsigned long inlen;        /* available input at in */
-    unsigned long incnt;        /* bytes read so far */
-    int bitbuf;                 /* bit buffer */
-    int bitcnt;                 /* number of bits in bit buffer */
-
-    /* input limit error return state for bits() and decode() */
-    jmp_buf env;
-};
-
-/*
- * Return need bits from the input stream.  This always leaves less than
- * eight bits in the buffer.  bits() works properly for need == 0.
- *
- * Format notes:
- *
- * - Bits are stored in bytes from the least significant bit to the most
- *   significant bit.  Therefore bits are dropped from the bottom of the bit
- *   buffer, using shift right, and new bytes are appended to the top of the
- *   bit buffer, using shift left.
- */
-local int bits(struct state *s, int need)
-{
-    long val;           /* bit accumulator (can use up to 20 bits) */
-
-    /* load at least need bits into val */
-    val = s->bitbuf;
-    while (s->bitcnt < need) {
-        if (s->incnt == s->inlen)
-            longjmp(s->env, 1);         /* out of input */
-        val |= (long)(s->in[s->incnt++]) << s->bitcnt;  /* load eight bits */
-        s->bitcnt += 8;
-    }
-
-    /* drop need bits and update buffer, always zero to seven bits left */
-    s->bitbuf = (int)(val >> need);
-    s->bitcnt -= need;
-
-    /* return need bits, zeroing the bits above that */
-    return (int)(val & ((1L << need) - 1));
-}
-
-/*
- * Process a stored block.
- *
- * Format notes:
- *
- * - After the two-bit stored block type (00), the stored block length and
- *   stored bytes are byte-aligned for fast copying.  Therefore any leftover
- *   bits in the byte that has the last bit of the type, as many as seven, are
- *   discarded.  The value of the discarded bits are not defined and should not
- *   be checked against any expectation.
- *
- * - The second inverted copy of the stored block length does not have to be
- *   checked, but it's probably a good idea to do so anyway.
- *
- * - A stored block can have zero length.  This is sometimes used to byte-align
- *   subsets of the compressed data for random access or partial recovery.
- */
-local int stored(struct state *s)
-{
-    unsigned len;       /* length of stored block */
-
-    /* discard leftover bits from current byte (assumes s->bitcnt < 8) */
-    s->bitbuf = 0;
-    s->bitcnt = 0;
-
-    /* get length and check against its one's complement */
-    if (s->incnt + 4 > s->inlen)
-        return 2;                               /* not enough input */
-    len = s->in[s->incnt++];
-    len |= s->in[s->incnt++] << 8;
-    if (s->in[s->incnt++] != (~len & 0xff) ||
-        s->in[s->incnt++] != ((~len >> 8) & 0xff))
-        return -2;                              /* didn't match complement! */
-
-    /* copy len bytes from in to out */
-    if (s->incnt + len > s->inlen)
-        return 2;                               /* not enough input */
-    if (s->out != NIL) {
-        if (s->outcnt + len > s->outlen)
-            return 1;                           /* not enough output space */
-        while (len--)
-            s->out[s->outcnt++] = s->in[s->incnt++];
-    }
-    else {                                      /* just scanning */
-        s->outcnt += len;
-        s->incnt += len;
-    }
-
-    /* done with a valid stored block */
-    return 0;
-}
-
-/*
- * Huffman code decoding tables.  count[1..MAXBITS] is the number of symbols of
- * each length, which for a canonical code are stepped through in order.
- * symbol[] are the symbol values in canonical order, where the number of
- * entries is the sum of the counts in count[].  The decoding process can be
- * seen in the function decode() below.
- */
-struct huffman {
-    short *count;       /* number of symbols of each length */
-    short *symbol;      /* canonically ordered symbols */
-};
-
-/*
- * Decode a code from the stream s using huffman table h.  Return the symbol or
- * a negative value if there is an error.  If all of the lengths are zero, i.e.
- * an empty code, or if the code is incomplete and an invalid code is received,
- * then -10 is returned after reading MAXBITS bits.
- *
- * Format notes:
- *
- * - The codes as stored in the compressed data are bit-reversed relative to
- *   a simple integer ordering of codes of the same lengths.  Hence below the
- *   bits are pulled from the compressed data one at a time and used to
- *   build the code value reversed from what is in the stream in order to
- *   permit simple integer comparisons for decoding.  A table-based decoding
- *   scheme (as used in zlib) does not need to do this reversal.
- *
- * - The first code for the shortest length is all zeros.  Subsequent codes of
- *   the same length are simply integer increments of the previous code.  When
- *   moving up a length, a zero bit is appended to the code.  For a complete
- *   code, the last code of the longest length will be all ones.
- *
- * - Incomplete codes are handled by this decoder, since they are permitted
- *   in the deflate format.  See the format notes for fixed() and dynamic().
- */
-#ifdef SLOW
-local int decode(struct state *s, const struct huffman *h)
-{
-    int len;            /* current number of bits in code */
-    int code;           /* len bits being decoded */
-    int first;          /* first code of length len */
-    int count;          /* number of codes of length len */
-    int index;          /* index of first code of length len in symbol table */
-
-    code = first = index = 0;
-    for (len = 1; len <= MAXBITS; len++) {
-        code |= bits(s, 1);             /* get next bit */
-        count = h->count[len];
-        if (code - count < first)       /* if length len, return symbol */
-            return h->symbol[index + (code - first)];
-        index += count;                 /* else update for next length */
-        first += count;
-        first <<= 1;
-        code <<= 1;
-    }
-    return -10;                         /* ran out of codes */
-}
-
-/*
- * A faster version of decode() for real applications of this code.   It's not
- * as readable, but it makes puff() twice as fast.  And it only makes the code
- * a few percent larger.
- */
-#else /* !SLOW */
-local int decode(struct state *s, const struct huffman *h)
-{
-    int len;            /* current number of bits in code */
-    int code;           /* len bits being decoded */
-    int first;          /* first code of length len */
-    int count;          /* number of codes of length len */
-    int index;          /* index of first code of length len in symbol table */
-    int bitbuf;         /* bits from stream */
-    int left;           /* bits left in next or left to process */
-    short *next;        /* next number of codes */
-
-    bitbuf = s->bitbuf;
-    left = s->bitcnt;
-    code = first = index = 0;
-    len = 1;
-    next = h->count + 1;
-    while (1) {
-        while (left--) {
-            code |= bitbuf & 1;
-            bitbuf >>= 1;
-            count = *next++;
-            if (code - count < first) { /* if length len, return symbol */
-                s->bitbuf = bitbuf;
-                s->bitcnt = (s->bitcnt - len) & 7;
-                return h->symbol[index + (code - first)];
-            }
-            index += count;             /* else update for next length */
-            first += count;
-            first <<= 1;
-            code <<= 1;
-            len++;
-        }
-        left = (MAXBITS+1) - len;
-        if (left == 0)
-            break;
-        if (s->incnt == s->inlen)
-            longjmp(s->env, 1);         /* out of input */
-        bitbuf = s->in[s->incnt++];
-        if (left > 8)
-            left = 8;
-    }
-    return -10;                         /* ran out of codes */
-}
-#endif /* SLOW */
-
-/*
- * Given the list of code lengths length[0..n-1] representing a canonical
- * Huffman code for n symbols, construct the tables required to decode those
- * codes.  Those tables are the number of codes of each length, and the symbols
- * sorted by length, retaining their original order within each length.  The
- * return value is zero for a complete code set, negative for an over-
- * subscribed code set, and positive for an incomplete code set.  The tables
- * can be used if the return value is zero or positive, but they cannot be used
- * if the return value is negative.  If the return value is zero, it is not
- * possible for decode() using that table to return an error--any stream of
- * enough bits will resolve to a symbol.  If the return value is positive, then
- * it is possible for decode() using that table to return an error for received
- * codes past the end of the incomplete lengths.
- *
- * Not used by decode(), but used for error checking, h->count[0] is the number
- * of the n symbols not in the code.  So n - h->count[0] is the number of
- * codes.  This is useful for checking for incomplete codes that have more than
- * one symbol, which is an error in a dynamic block.
- *
- * Assumption: for all i in 0..n-1, 0 <= length[i] <= MAXBITS
- * This is assured by the construction of the length arrays in dynamic() and
- * fixed() and is not verified by construct().
- *
- * Format notes:
- *
- * - Permitted and expected examples of incomplete codes are one of the fixed
- *   codes and any code with a single symbol which in deflate is coded as one
- *   bit instead of zero bits.  See the format notes for fixed() and dynamic().
- *
- * - Within a given code length, the symbols are kept in ascending order for
- *   the code bits definition.
- */
-local int construct(struct huffman *h, const short *length, int n)
-{
-    int symbol;         /* current symbol when stepping through length[] */
-    int len;            /* current length when stepping through h->count[] */
-    int left;           /* number of possible codes left of current length */
-    short offs[MAXBITS+1];      /* offsets in symbol table for each length */
-
-    /* count number of codes of each length */
-    for (len = 0; len <= MAXBITS; len++)
-        h->count[len] = 0;
-    for (symbol = 0; symbol < n; symbol++)
-        (h->count[length[symbol]])++;   /* assumes lengths are within bounds */
-    if (h->count[0] == n)               /* no codes! */
-        return 0;                       /* complete, but decode() will fail */
-
-    /* check for an over-subscribed or incomplete set of lengths */
-    left = 1;                           /* one possible code of zero length */
-    for (len = 1; len <= MAXBITS; len++) {
-        left <<= 1;                     /* one more bit, double codes left */
-        left -= h->count[len];          /* deduct count from possible codes */
-        if (left < 0)
-            return left;                /* over-subscribed--return negative */
-    }                                   /* left > 0 means incomplete */
-
-    /* generate offsets into symbol table for each length for sorting */
-    offs[1] = 0;
-    for (len = 1; len < MAXBITS; len++)
-        offs[len + 1] = offs[len] + h->count[len];
-
-    /*
-     * put symbols in table sorted by length, by symbol order within each
-     * length
-     */
-    for (symbol = 0; symbol < n; symbol++)
-        if (length[symbol] != 0)
-            h->symbol[offs[length[symbol]]++] = symbol;
-
-    /* return zero for complete set, positive for incomplete set */
-    return left;
-}
-
-/*
- * Decode literal/length and distance codes until an end-of-block code.
- *
- * Format notes:
- *
- * - Compressed data that is after the block type if fixed or after the code
- *   description if dynamic is a combination of literals and length/distance
- *   pairs terminated by and end-of-block code.  Literals are simply Huffman
- *   coded bytes.  A length/distance pair is a coded length followed by a
- *   coded distance to represent a string that occurs earlier in the
- *   uncompressed data that occurs again at the current location.
- *
- * - Literals, lengths, and the end-of-block code are combined into a single
- *   code of up to 286 symbols.  They are 256 literals (0..255), 29 length
- *   symbols (257..285), and the end-of-block symbol (256).
- *
- * - There are 256 possible lengths (3..258), and so 29 symbols are not enough
- *   to represent all of those.  Lengths 3..10 and 258 are in fact represented
- *   by just a length symbol.  Lengths 11..257 are represented as a symbol and
- *   some number of extra bits that are added as an integer to the base length
- *   of the length symbol.  The number of extra bits is determined by the base
- *   length symbol.  These are in the static arrays below, lens[] for the base
- *   lengths and lext[] for the corresponding number of extra bits.
- *
- * - The reason that 258 gets its own symbol is that the longest length is used
- *   often in highly redundant files.  Note that 258 can also be coded as the
- *   base value 227 plus the maximum extra value of 31.  While a good deflate
- *   should never do this, it is not an error, and should be decoded properly.
- *
- * - If a length is decoded, including its extra bits if any, then it is
- *   followed a distance code.  There are up to 30 distance symbols.  Again
- *   there are many more possible distances (1..32768), so extra bits are added
- *   to a base value represented by the symbol.  The distances 1..4 get their
- *   own symbol, but the rest require extra bits.  The base distances and
- *   corresponding number of extra bits are below in the static arrays dist[]
- *   and dext[].
- *
- * - Literal bytes are simply written to the output.  A length/distance pair is
- *   an instruction to copy previously uncompressed bytes to the output.  The
- *   copy is from distance bytes back in the output stream, copying for length
- *   bytes.
- *
- * - Distances pointing before the beginning of the output data are not
- *   permitted.
- *
- * - Overlapped copies, where the length is greater than the distance, are
- *   allowed and common.  For example, a distance of one and a length of 258
- *   simply copies the last byte 258 times.  A distance of four and a length of
- *   twelve copies the last four bytes three times.  A simple forward copy
- *   ignoring whether the length is greater than the distance or not implements
- *   this correctly.  You should not use memcpy() since its behavior is not
- *   defined for overlapped arrays.  You should not use memmove() or bcopy()
- *   since though their behavior -is- defined for overlapping arrays, it is
- *   defined to do the wrong thing in this case.
- */
-local int codes(struct state *s,
-                const struct huffman *lencode,
-                const struct huffman *distcode)
-{
-    int symbol;         /* decoded symbol */
-    int len;            /* length for copy */
-    unsigned dist;      /* distance for copy */
-    static const short lens[29] = { /* Size base for length codes 257..285 */
-        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
-        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};
-    static const short lext[29] = { /* Extra bits for length codes 257..285 */
-        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
-        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};
-    static const short dists[30] = { /* Offset base for distance codes 0..29 */
-        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
-        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
-        8193, 12289, 16385, 24577};
-    static const short dext[30] = { /* Extra bits for distance codes 0..29 */
-        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
-        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
-        12, 12, 13, 13};
-
-    /* decode literals and length/distance pairs */
-    do {
-        symbol = decode(s, lencode);
-        if (symbol < 0)
-            return symbol;              /* invalid symbol */
-        if (symbol < 256) {             /* literal: symbol is the byte */
-            /* write out the literal */
-            if (s->out != NIL) {
-                if (s->outcnt == s->outlen)
-                    return 1;
-                s->out[s->outcnt] = symbol;
-            }
-            s->outcnt++;
-        }
-        else if (symbol > 256) {        /* length */
-            /* get and compute length */
-            symbol -= 257;
-            if (symbol >= 29)
-                return -10;             /* invalid fixed code */
-            len = lens[symbol] + bits(s, lext[symbol]);
-
-            /* get and check distance */
-            symbol = decode(s, distcode);
-            if (symbol < 0)
-                return symbol;          /* invalid symbol */
-            dist = dists[symbol] + bits(s, dext[symbol]);
-#ifndef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-            if (dist > s->outcnt)
-                return -11;     /* distance too far back */
-#endif
-
-            /* copy length bytes from distance bytes back */
-            if (s->out != NIL) {
-                if (s->outcnt + len > s->outlen)
-                    return 1;
-                while (len--) {
-                    s->out[s->outcnt] =
-#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-                        dist > s->outcnt ?
-                            0 :
-#endif
-                            s->out[s->outcnt - dist];
-                    s->outcnt++;
-                }
-            }
-            else
-                s->outcnt += len;
-        }
-    } while (symbol != 256);            /* end of block symbol */
-
-    /* done with a valid fixed or dynamic block */
-    return 0;
-}
-
-/*
- * Process a fixed codes block.
- *
- * Format notes:
- *
- * - This block type can be useful for compressing small amounts of data for
- *   which the size of the code descriptions in a dynamic block exceeds the
- *   benefit of custom codes for that block.  For fixed codes, no bits are
- *   spent on code descriptions.  Instead the code lengths for literal/length
- *   codes and distance codes are fixed.  The specific lengths for each symbol
- *   can be seen in the "for" loops below.
- *
- * - The literal/length code is complete, but has two symbols that are invalid
- *   and should result in an error if received.  This cannot be implemented
- *   simply as an incomplete code since those two symbols are in the "middle"
- *   of the code.  They are eight bits long and the longest literal/length\
- *   code is nine bits.  Therefore the code must be constructed with those
- *   symbols, and the invalid symbols must be detected after decoding.
- *
- * - The fixed distance codes also have two invalid symbols that should result
- *   in an error if received.  Since all of the distance codes are the same
- *   length, this can be implemented as an incomplete code.  Then the invalid
- *   codes are detected while decoding.
- */
-local int fixed(struct state *s)
-{
-    static int virgin = 1;
-    static short lencnt[MAXBITS+1], lensym[FIXLCODES];
-    static short distcnt[MAXBITS+1], distsym[MAXDCODES];
-    static struct huffman lencode, distcode;
-
-    /* build fixed huffman tables if first call (may not be thread safe) */
-    if (virgin) {
-        int symbol;
-        short lengths[FIXLCODES];
-
-        /* construct lencode and distcode */
-        lencode.count = lencnt;
-        lencode.symbol = lensym;
-        distcode.count = distcnt;
-        distcode.symbol = distsym;
-
-        /* literal/length table */
-        for (symbol = 0; symbol < 144; symbol++)
-            lengths[symbol] = 8;
-        for (; symbol < 256; symbol++)
-            lengths[symbol] = 9;
-        for (; symbol < 280; symbol++)
-            lengths[symbol] = 7;
-        for (; symbol < FIXLCODES; symbol++)
-            lengths[symbol] = 8;
-        construct(&lencode, lengths, FIXLCODES);
-
-        /* distance table */
-        for (symbol = 0; symbol < MAXDCODES; symbol++)
-            lengths[symbol] = 5;
-        construct(&distcode, lengths, MAXDCODES);
-
-        /* do this just once */
-        virgin = 0;
-    }
-
-    /* decode data until end-of-block code */
-    return codes(s, &lencode, &distcode);
-}
-
-/*
- * Process a dynamic codes block.
- *
- * Format notes:
- *
- * - A dynamic block starts with a description of the literal/length and
- *   distance codes for that block.  New dynamic blocks allow the compressor to
- *   rapidly adapt to changing data with new codes optimized for that data.
- *
- * - The codes used by the deflate format are "canonical", which means that
- *   the actual bits of the codes are generated in an unambiguous way simply
- *   from the number of bits in each code.  Therefore the code descriptions
- *   are simply a list of code lengths for each symbol.
- *
- * - The code lengths are stored in order for the symbols, so lengths are
- *   provided for each of the literal/length symbols, and for each of the
- *   distance symbols.
- *
- * - If a symbol is not used in the block, this is represented by a zero as
- *   as the code length.  This does not mean a zero-length code, but rather
- *   that no code should be created for this symbol.  There is no way in the
- *   deflate format to represent a zero-length code.
- *
- * - The maximum number of bits in a code is 15, so the possible lengths for
- *   any code are 1..15.
- *
- * - The fact that a length of zero is not permitted for a code has an
- *   interesting consequence.  Normally if only one symbol is used for a given
- *   code, then in fact that code could be represented with zero bits.  However
- *   in deflate, that code has to be at least one bit.  So for example, if
- *   only a single distance base symbol appears in a block, then it will be
- *   represented by a single code of length one, in particular one 0 bit.  This
- *   is an incomplete code, since if a 1 bit is received, it has no meaning,
- *   and should result in an error.  So incomplete distance codes of one symbol
- *   should be permitted, and the receipt of invalid codes should be handled.
- *
- * - It is also possible to have a single literal/length code, but that code
- *   must be the end-of-block code, since every dynamic block has one.  This
- *   is not the most efficient way to create an empty block (an empty fixed
- *   block is fewer bits), but it is allowed by the format.  So incomplete
- *   literal/length codes of one symbol should also be permitted.
- *
- * - If there are only literal codes and no lengths, then there are no distance
- *   codes.  This is represented by one distance code with zero bits.
- *
- * - The list of up to 286 length/literal lengths and up to 30 distance lengths
- *   are themselves compressed using Huffman codes and run-length encoding.  In
- *   the list of code lengths, a 0 symbol means no code, a 1..15 symbol means
- *   that length, and the symbols 16, 17, and 18 are run-length instructions.
- *   Each of 16, 17, and 18 are follwed by extra bits to define the length of
- *   the run.  16 copies the last length 3 to 6 times.  17 represents 3 to 10
- *   zero lengths, and 18 represents 11 to 138 zero lengths.  Unused symbols
- *   are common, hence the special coding for zero lengths.
- *
- * - The symbols for 0..18 are Huffman coded, and so that code must be
- *   described first.  This is simply a sequence of up to 19 three-bit values
- *   representing no code (0) or the code length for that symbol (1..7).
- *
- * - A dynamic block starts with three fixed-size counts from which is computed
- *   the number of literal/length code lengths, the number of distance code
- *   lengths, and the number of code length code lengths (ok, you come up with
- *   a better name!) in the code descriptions.  For the literal/length and
- *   distance codes, lengths after those provided are considered zero, i.e. no
- *   code.  The code length code lengths are received in a permuted order (see
- *   the order[] array below) to make a short code length code length list more
- *   likely.  As it turns out, very short and very long codes are less likely
- *   to be seen in a dynamic code description, hence what may appear initially
- *   to be a peculiar ordering.
- *
- * - Given the number of literal/length code lengths (nlen) and distance code
- *   lengths (ndist), then they are treated as one long list of nlen + ndist
- *   code lengths.  Therefore run-length coding can and often does cross the
- *   boundary between the two sets of lengths.
- *
- * - So to summarize, the code description at the start of a dynamic block is
- *   three counts for the number of code lengths for the literal/length codes,
- *   the distance codes, and the code length codes.  This is followed by the
- *   code length code lengths, three bits each.  This is used to construct the
- *   code length code which is used to read the remainder of the lengths.  Then
- *   the literal/length code lengths and distance lengths are read as a single
- *   set of lengths using the code length codes.  Codes are constructed from
- *   the resulting two sets of lengths, and then finally you can start
- *   decoding actual compressed data in the block.
- *
- * - For reference, a "typical" size for the code description in a dynamic
- *   block is around 80 bytes.
- */
-local int dynamic(struct state *s)
-{
-    int nlen, ndist, ncode;             /* number of lengths in descriptor */
-    int index;                          /* index of lengths[] */
-    int err;                            /* construct() return value */
-    short lengths[MAXCODES];            /* descriptor code lengths */
-    short lencnt[MAXBITS+1], lensym[MAXLCODES];         /* lencode memory */
-    short distcnt[MAXBITS+1], distsym[MAXDCODES];       /* distcode memory */
-    struct huffman lencode, distcode;   /* length and distance codes */
-    static const short order[19] =      /* permutation of code length codes */
-        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-
-    /* construct lencode and distcode */
-    lencode.count = lencnt;
-    lencode.symbol = lensym;
-    distcode.count = distcnt;
-    distcode.symbol = distsym;
-
-    /* get number of lengths in each table, check lengths */
-    nlen = bits(s, 5) + 257;
-    ndist = bits(s, 5) + 1;
-    ncode = bits(s, 4) + 4;
-    if (nlen > MAXLCODES || ndist > MAXDCODES)
-        return -3;                      /* bad counts */
-
-    /* read code length code lengths (really), missing lengths are zero */
-    for (index = 0; index < ncode; index++)
-        lengths[order[index]] = bits(s, 3);
-    for (; index < 19; index++)
-        lengths[order[index]] = 0;
-
-    /* build huffman table for code lengths codes (use lencode temporarily) */
-    err = construct(&lencode, lengths, 19);
-    if (err != 0)               /* require complete code set here */
-        return -4;
-
-    /* read length/literal and distance code length tables */
-    index = 0;
-    while (index < nlen + ndist) {
-        int symbol;             /* decoded value */
-        int len;                /* last length to repeat */
-
-        symbol = decode(s, &lencode);
-        if (symbol < 16)                /* length in 0..15 */
-            lengths[index++] = symbol;
-        else {                          /* repeat instruction */
-            len = 0;                    /* assume repeating zeros */
-            if (symbol == 16) {         /* repeat last length 3..6 times */
-                if (index == 0)
-                    return -5;          /* no last length! */
-                len = lengths[index - 1];       /* last length */
-                symbol = 3 + bits(s, 2);
-            }
-            else if (symbol == 17)      /* repeat zero 3..10 times */
-                symbol = 3 + bits(s, 3);
-            else                        /* == 18, repeat zero 11..138 times */
-                symbol = 11 + bits(s, 7);
-            if (index + symbol > nlen + ndist)
-                return -6;              /* too many lengths! */
-            while (symbol--)            /* repeat last or zero symbol times */
-                lengths[index++] = len;
-        }
-    }
-
-    /* check for end-of-block code -- there better be one! */
-    if (lengths[256] == 0)
-        return -9;
-
-    /* build huffman table for literal/length codes */
-    err = construct(&lencode, lengths, nlen);
-    if (err && (err < 0 || nlen != lencode.count[0] + lencode.count[1]))
-        return -7;      /* incomplete code ok only for single length 1 code */
-
-    /* build huffman table for distance codes */
-    err = construct(&distcode, lengths + nlen, ndist);
-    if (err && (err < 0 || ndist != distcode.count[0] + distcode.count[1]))
-        return -8;      /* incomplete code ok only for single length 1 code */
-
-    /* decode data until end-of-block code */
-    return codes(s, &lencode, &distcode);
-}
-
-/*
- * Inflate source to dest.  On return, destlen and sourcelen are updated to the
- * size of the uncompressed data and the size of the deflate data respectively.
- * On success, the return value of puff() is zero.  If there is an error in the
- * source data, i.e. it is not in the deflate format, then a negative value is
- * returned.  If there is not enough input available or there is not enough
- * output space, then a positive error is returned.  In that case, destlen and
- * sourcelen are not updated to facilitate retrying from the beginning with the
- * provision of more input data or more output space.  In the case of invalid
- * inflate data (a negative error), the dest and source pointers are updated to
- * facilitate the debugging of deflators.
- *
- * puff() also has a mode to determine the size of the uncompressed output with
- * no output written.  For this dest must be (unsigned char *)0.  In this case,
- * the input value of *destlen is ignored, and on return *destlen is set to the
- * size of the uncompressed output.
- *
- * The return codes are:
- *
- *   2:  available inflate data did not terminate
- *   1:  output space exhausted before completing inflate
- *   0:  successful inflate
- *  -1:  invalid block type (type == 3)
- *  -2:  stored block length did not match one's complement
- *  -3:  dynamic block code description: too many length or distance codes
- *  -4:  dynamic block code description: code lengths codes incomplete
- *  -5:  dynamic block code description: repeat lengths with no first length
- *  -6:  dynamic block code description: repeat more than specified lengths
- *  -7:  dynamic block code description: invalid literal/length code lengths
- *  -8:  dynamic block code description: invalid distance code lengths
- *  -9:  dynamic block code description: missing end-of-block code
- * -10:  invalid literal/length or distance code in fixed or dynamic block
- * -11:  distance is too far back in fixed or dynamic block
- *
- * Format notes:
- *
- * - Three bits are read for each block to determine the kind of block and
- *   whether or not it is the last block.  Then the block is decoded and the
- *   process repeated if it was not the last block.
- *
- * - The leftover bits in the last byte of the deflate data after the last
- *   block (if it was a fixed or dynamic block) are undefined and have no
- *   expected values to check.
- */
-int puff(unsigned char *dest,           /* pointer to destination pointer */
-         unsigned long *destlen,        /* amount of output space */
-         const unsigned char *source,   /* pointer to source data pointer */
-         unsigned long *sourcelen)      /* amount of input available */
-{
-    struct state s;             /* input/output state */
-    int last, type;             /* block information */
-    int err;                    /* return value */
-
-    /* initialize output state */
-    s.out = dest;
-    s.outlen = *destlen;                /* ignored if dest is NIL */
-    s.outcnt = 0;
-
-    /* initialize input state */
-    s.in = source;
-    s.inlen = *sourcelen;
-    s.incnt = 0;
-    s.bitbuf = 0;
-    s.bitcnt = 0;
-
-    /* return if bits() or decode() tries to read past available input */
-    if (setjmp(s.env) != 0)             /* if came back here via longjmp() */
-        err = 2;                        /* then skip do-loop, return error */
-    else {
-        /* process blocks until last block or error */
-        do {
-            last = bits(&s, 1);         /* one if last block */
-            type = bits(&s, 2);         /* block type 0..3 */
-            err = type == 0 ?
-                    stored(&s) :
-                    (type == 1 ?
-                        fixed(&s) :
-                        (type == 2 ?
-                            dynamic(&s) :
-                            -1));       /* type == 3, invalid */
-            if (err != 0)
-                break;                  /* return with error */
-        } while (!last);
-    }
-
-    /* update the lengths and return */
-    if (err <= 0) {
-        *destlen = s.outcnt;
-        *sourcelen = s.incnt;
-    }
-    return err;
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/puff/puff.h gcc-4.8.1-ppc/zlib/contrib/puff/puff.h
--- gcc-4.8.1/zlib/contrib/puff/puff.h	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/puff/puff.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,35 +0,0 @@
-/* puff.h
-  Copyright (C) 2002-2010 Mark Adler, all rights reserved
-  version 2.2, 25 Apr 2010
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Mark Adler    madler@alumni.caltech.edu
- */
-
-
-/*
- * See puff.c for purpose and usage.
- */
-#ifndef NIL
-#  define NIL ((unsigned char *)0)      /* for no output option */
-#endif
-
-int puff(unsigned char *dest,           /* pointer to destination pointer */
-         unsigned long *destlen,        /* amount of output space */
-         const unsigned char *source,   /* pointer to source data pointer */
-         unsigned long *sourcelen);     /* amount of input available */
diff -Nbaur gcc-4.8.1/zlib/contrib/puff/pufftest.c gcc-4.8.1-ppc/zlib/contrib/puff/pufftest.c
--- gcc-4.8.1/zlib/contrib/puff/pufftest.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/puff/pufftest.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,165 +0,0 @@
-/*
- * pufftest.c
- * Copyright (C) 2002-2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in puff.h
- * version 2.2, 25 Apr 2010
- */
-
-/* Example of how to use puff().
-
-   Usage: puff [-w] [-f] [-nnn] file
-          ... | puff [-w] [-f] [-nnn]
-
-   where file is the input file with deflate data, nnn is the number of bytes
-   of input to skip before inflating (e.g. to skip a zlib or gzip header), and
-   -w is used to write the decompressed data to stdout.  -f is for coverage
-   testing, and causes pufftest to fail with not enough output space (-f does
-   a write like -w, so -w is not required). */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include "puff.h"
-
-#if defined(MSDOS) || defined(OS2) || defined(WIN32) || defined(__CYGWIN__)
-#  include <fcntl.h>
-#  include <io.h>
-#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
-#else
-#  define SET_BINARY_MODE(file)
-#endif
-
-#define local static
-
-/* Return size times approximately the cube root of 2, keeping the result as 1,
-   3, or 5 times a power of 2 -- the result is always > size, until the result
-   is the maximum value of an unsigned long, where it remains.  This is useful
-   to keep reallocations less than ~33% over the actual data. */
-local size_t bythirds(size_t size)
-{
-    int n;
-    size_t m;
-
-    m = size;
-    for (n = 0; m; n++)
-        m >>= 1;
-    if (n < 3)
-        return size + 1;
-    n -= 3;
-    m = size >> n;
-    m += m == 6 ? 2 : 1;
-    m <<= n;
-    return m > size ? m : (size_t)(-1);
-}
-
-/* Read the input file *name, or stdin if name is NULL, into allocated memory.
-   Reallocate to larger buffers until the entire file is read in.  Return a
-   pointer to the allocated data, or NULL if there was a memory allocation
-   failure.  *len is the number of bytes of data read from the input file (even
-   if load() returns NULL).  If the input file was empty or could not be opened
-   or read, *len is zero. */
-local void *load(const char *name, size_t *len)
-{
-    size_t size;
-    void *buf, *swap;
-    FILE *in;
-
-    *len = 0;
-    buf = malloc(size = 4096);
-    if (buf == NULL)
-        return NULL;
-    in = name == NULL ? stdin : fopen(name, "rb");
-    if (in != NULL) {
-        for (;;) {
-            *len += fread((char *)buf + *len, 1, size - *len, in);
-            if (*len < size) break;
-            size = bythirds(size);
-            if (size == *len || (swap = realloc(buf, size)) == NULL) {
-                free(buf);
-                buf = NULL;
-                break;
-            }
-            buf = swap;
-        }
-        fclose(in);
-    }
-    return buf;
-}
-
-int main(int argc, char **argv)
-{
-    int ret, put = 0, fail = 0;
-    unsigned skip = 0;
-    char *arg, *name = NULL;
-    unsigned char *source = NULL, *dest;
-    size_t len = 0;
-    unsigned long sourcelen, destlen;
-
-    /* process arguments */
-    while (arg = *++argv, --argc)
-        if (arg[0] == '-') {
-            if (arg[1] == 'w' && arg[2] == 0)
-                put = 1;
-            else if (arg[1] == 'f' && arg[2] == 0)
-                fail = 1, put = 1;
-            else if (arg[1] >= '0' && arg[1] <= '9')
-                skip = (unsigned)atoi(arg + 1);
-            else {
-                fprintf(stderr, "invalid option %s\n", arg);
-                return 3;
-            }
-        }
-        else if (name != NULL) {
-            fprintf(stderr, "only one file name allowed\n");
-            return 3;
-        }
-        else
-            name = arg;
-    source = load(name, &len);
-    if (source == NULL) {
-        fprintf(stderr, "memory allocation failure\n");
-        return 4;
-    }
-    if (len == 0) {
-        fprintf(stderr, "could not read %s, or it was empty\n",
-                name == NULL ? "<stdin>" : name);
-        free(source);
-        return 3;
-    }
-    if (skip >= len) {
-        fprintf(stderr, "skip request of %d leaves no input\n", skip);
-        free(source);
-        return 3;
-    }
-
-    /* test inflate data with offset skip */
-    len -= skip;
-    sourcelen = (unsigned long)len;
-    ret = puff(NIL, &destlen, source + skip, &sourcelen);
-    if (ret)
-        fprintf(stderr, "puff() failed with return code %d\n", ret);
-    else {
-        fprintf(stderr, "puff() succeeded uncompressing %lu bytes\n", destlen);
-        if (sourcelen < len) fprintf(stderr, "%lu compressed bytes unused\n",
-                                     len - sourcelen);
-    }
-
-    /* if requested, inflate again and write decompressd data to stdout */
-    if (put && ret == 0) {
-        if (fail)
-            destlen >>= 1;
-        dest = malloc(destlen);
-        if (dest == NULL) {
-            fprintf(stderr, "memory allocation failure\n");
-            free(source);
-            return 4;
-        }
-        puff(dest, &destlen, source + skip, &sourcelen);
-        SET_BINARY_MODE(stdout);
-        fwrite(dest, 1, destlen, stdout);
-        free(dest);
-    }
-
-    /* clean up */
-    free(source);
-    return ret;
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/puff/README gcc-4.8.1-ppc/zlib/contrib/puff/README
--- gcc-4.8.1/zlib/contrib/puff/README	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/puff/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,63 +0,0 @@
-Puff -- A Simple Inflate
-3 Mar 2003
-Mark Adler
-madler@alumni.caltech.edu
-
-What this is --
-
-puff.c provides the routine puff() to decompress the deflate data format.  It
-does so more slowly than zlib, but the code is about one-fifth the size of the
-inflate code in zlib, and written to be very easy to read.
-
-Why I wrote this --
-
-puff.c was written to document the deflate format unambiguously, by virtue of
-being working C code.  It is meant to supplement RFC 1951, which formally
-describes the deflate format.  I have received many questions on details of the
-deflate format, and I hope that reading this code will answer those questions.
-puff.c is heavily commented with details of the deflate format, especially
-those little nooks and cranies of the format that might not be obvious from a
-specification.
-
-puff.c may also be useful in applications where code size or memory usage is a
-very limited resource, and speed is not as important.
-
-How to use it --
-
-Well, most likely you should just be reading puff.c and using zlib for actual
-applications, but if you must ...
-
-Include puff.h in your code, which provides this prototype:
-
-int puff(unsigned char *dest,           /* pointer to destination pointer */
-         unsigned long *destlen,        /* amount of output space */
-         unsigned char *source,         /* pointer to source data pointer */
-         unsigned long *sourcelen);     /* amount of input available */
-
-Then you can call puff() to decompress a deflate stream that is in memory in
-its entirety at source, to a sufficiently sized block of memory for the
-decompressed data at dest.  puff() is the only external symbol in puff.c  The
-only C library functions that puff.c needs are setjmp() and longjmp(), which
-are used to simplify error checking in the code to improve readabilty.  puff.c
-does no memory allocation, and uses less than 2K bytes off of the stack.
-
-If destlen is not enough space for the uncompressed data, then inflate will
-return an error without writing more than destlen bytes.  Note that this means
-that in order to decompress the deflate data successfully, you need to know
-the size of the uncompressed data ahead of time.
-
-If needed, puff() can determine the size of the uncompressed data with no
-output space.  This is done by passing dest equal to (unsigned char *)0.  Then
-the initial value of *destlen is ignored and *destlen is set to the length of
-the uncompressed data.  So if the size of the uncompressed data is not known,
-then two passes of puff() can be used--first to determine the size, and second
-to do the actual inflation after allocating the appropriate memory.  Not
-pretty, but it works.  (This is one of the reasons you should be using zlib.)
-
-The deflate format is self-terminating.  If the deflate stream does not end
-in *sourcelen bytes, puff() will return an error without reading at or past
-endsource.
-
-On return, *sourcelen is updated to the amount of input data consumed, and
-*destlen is updated to the size of the uncompressed data.  See the comments
-in puff.c for the possible return codes for puff().
diff -Nbaur gcc-4.8.1/zlib/contrib/puff/zeros.raw gcc-4.8.1-ppc/zlib/contrib/puff/zeros.raw
--- gcc-4.8.1/zlib/contrib/puff/zeros.raw	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/puff/zeros.raw	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-    S_ U                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           p
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/README.contrib gcc-4.8.1-ppc/zlib/contrib/README.contrib
--- gcc-4.8.1/zlib/contrib/README.contrib	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/README.contrib	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-All files under this contrib directory are UNSUPPORTED. There were
-provided by users of zlib and were not tested by the authors of zlib.
-Use at your own risk. Please contact the authors of the contributions
-for help about these, not the zlib authors. Thanks.
-
-
-ada/        by Dmitriy Anisimkov <anisimkov@yahoo.com>
-        Support for Ada
-        See http://zlib-ada.sourceforge.net/
-
-amd64/      by Mikhail Teterin <mi@ALDAN.algebra.com>
-        asm code for AMD64
-        See patch at http://www.freebsd.org/cgi/query-pr.cgi?pr=bin/96393
-
-asm686/     by Brian Raiter <breadbox@muppetlabs.com>
-        asm code for Pentium and PPro/PII, using the AT&T (GNU as) syntax
-        See http://www.muppetlabs.com/~breadbox/software/assembly.html
-
-blast/      by Mark Adler <madler@alumni.caltech.edu>
-        Decompressor for output of PKWare Data Compression Library (DCL)
-
-delphi/     by Cosmin Truta <cosmint@cs.ubbcluj.ro>
-        Support for Delphi and C++ Builder
-
-dotzlib/    by Henrik Ravn <henrik@ravn.com>
-        Support for Microsoft .Net and Visual C++ .Net
-
-gcc_gvmat64/by Gilles Vollant <info@winimage.com>
-        GCC Version of x86 64-bit (AMD64 and Intel EM64t) code for x64
-        assembler to replace longest_match() and inflate_fast()
-
-infback9/   by Mark Adler <madler@alumni.caltech.edu>
-        Unsupported diffs to infback to decode the deflate64 format
-
-inflate86/  by Chris Anderson <christop@charm.net>
-        Tuned x86 gcc asm code to replace inflate_fast()
-
-iostream/   by Kevin Ruland <kevin@rodin.wustl.edu>
-        A C++ I/O streams interface to the zlib gz* functions
-
-iostream2/  by Tyge Lvset <Tyge.Lovset@cmr.no>
-        Another C++ I/O streams interface
-
-iostream3/  by Ludwig Schwardt <schwardt@sun.ac.za>
-            and Kevin Ruland <kevin@rodin.wustl.edu>
-        Yet another C++ I/O streams interface
-
-masmx64/    by Gilles Vollant <info@winimage.com>
-        x86 64-bit (AMD64 and Intel EM64t) code for x64 assembler to
-        replace longest_match() and inflate_fast(),  also masm x86
-        64-bits translation of Chris Anderson inflate_fast()
-
-masmx86/    by Gilles Vollant <info@winimage.com>
-        x86 asm code to replace longest_match() and inflate_fast(),
-        for Visual C++ and MASM (32 bits).
-        Based on Brian Raiter (asm686) and Chris Anderson (inflate86)
-
-minizip/    by Gilles Vollant <info@winimage.com>
-        Mini zip and unzip based on zlib
-        Includes Zip64 support by Mathias Svensson <mathias@result42.com>
-        See http://www.winimage.com/zLibDll/unzip.html
-
-pascal/     by Bob Dellaca <bobdl@xtra.co.nz> et al.
-        Support for Pascal
-
-puff/       by Mark Adler <madler@alumni.caltech.edu>
-        Small, low memory usage inflate.  Also serves to provide an
-        unambiguous description of the deflate format.
-
-testzlib/   by Gilles Vollant <info@winimage.com>
-        Example of the use of zlib
-
-untgz/      by Pedro A. Aranda Gutierrez <paag@tid.es>
-        A very simple tar.gz file extractor using zlib
-
-vstudio/    by Gilles Vollant <info@winimage.com>
-        Building a minizip-enhanced zlib with Microsoft Visual Studio
diff -Nbaur gcc-4.8.1/zlib/contrib/testzlib/testzlib.c gcc-4.8.1-ppc/zlib/contrib/testzlib/testzlib.c
--- gcc-4.8.1/zlib/contrib/testzlib/testzlib.c	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/testzlib/testzlib.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,275 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <windows.h>
-
-#include "zlib.h"
-
-
-void MyDoMinus64(LARGE_INTEGER *R,LARGE_INTEGER A,LARGE_INTEGER B)
-{
-    R->HighPart = A.HighPart - B.HighPart;
-    if (A.LowPart >= B.LowPart)
-        R->LowPart = A.LowPart - B.LowPart;
-    else
-    {
-        R->LowPart = A.LowPart - B.LowPart;
-        R->HighPart --;
-    }
-}
-
-#ifdef _M_X64
-// see http://msdn2.microsoft.com/library/twchhe95(en-us,vs.80).aspx for __rdtsc
-unsigned __int64 __rdtsc(void);
-void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)
-{
- //   printf("rdtsc = %I64x\n",__rdtsc());
-   pbeginTime64->QuadPart=__rdtsc();
-}
-
-LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)
-{
-    LARGE_INTEGER LIres;
-    unsigned _int64 res=__rdtsc()-((unsigned _int64)(beginTime64.QuadPart));
-    LIres.QuadPart=res;
-   // printf("rdtsc = %I64x\n",__rdtsc());
-    return LIres;
-}
-#else
-#ifdef _M_IX86
-void myGetRDTSC32(LARGE_INTEGER * pbeginTime64)
-{
-    DWORD dwEdx,dwEax;
-    _asm
-    {
-        rdtsc
-        mov dwEax,eax
-        mov dwEdx,edx
-    }
-    pbeginTime64->LowPart=dwEax;
-    pbeginTime64->HighPart=dwEdx;
-}
-
-void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)
-{
-    myGetRDTSC32(pbeginTime64);
-}
-
-LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)
-{
-    LARGE_INTEGER LIres,endTime64;
-    myGetRDTSC32(&endTime64);
-
-    LIres.LowPart=LIres.HighPart=0;
-    MyDoMinus64(&LIres,endTime64,beginTime64);
-    return LIres;
-}
-#else
-void myGetRDTSC32(LARGE_INTEGER * pbeginTime64)
-{
-}
-
-void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)
-{
-}
-
-LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)
-{
-    LARGE_INTEGER lr;
-    lr.QuadPart=0;
-    return lr;
-}
-#endif
-#endif
-
-void BeginCountPerfCounter(LARGE_INTEGER * pbeginTime64,BOOL fComputeTimeQueryPerf)
-{
-    if ((!fComputeTimeQueryPerf) || (!QueryPerformanceCounter(pbeginTime64)))
-    {
-        pbeginTime64->LowPart = GetTickCount();
-        pbeginTime64->HighPart = 0;
-    }
-}
-
-DWORD GetMsecSincePerfCounter(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)
-{
-    LARGE_INTEGER endTime64,ticksPerSecond,ticks;
-    DWORDLONG ticksShifted,tickSecShifted;
-    DWORD dwLog=16+0;
-    DWORD dwRet;
-    if ((!fComputeTimeQueryPerf) || (!QueryPerformanceCounter(&endTime64)))
-        dwRet = (GetTickCount() - beginTime64.LowPart)*1;
-    else
-    {
-        MyDoMinus64(&ticks,endTime64,beginTime64);
-        QueryPerformanceFrequency(&ticksPerSecond);
-
-
-        {
-            ticksShifted = Int64ShrlMod32(*(DWORDLONG*)&ticks,dwLog);
-            tickSecShifted = Int64ShrlMod32(*(DWORDLONG*)&ticksPerSecond,dwLog);
-
-        }
-
-        dwRet = (DWORD)((((DWORD)ticksShifted)*1000)/(DWORD)(tickSecShifted));
-        dwRet *=1;
-    }
-    return dwRet;
-}
-
-int ReadFileMemory(const char* filename,long* plFileSize,void** pFilePtr)
-{
-    FILE* stream;
-    void* ptr;
-    int retVal=1;
-    stream=fopen(filename, "rb");
-    if (stream==NULL)
-        return 0;
-
-    fseek(stream,0,SEEK_END);
-
-    *plFileSize=ftell(stream);
-    fseek(stream,0,SEEK_SET);
-    ptr=malloc((*plFileSize)+1);
-    if (ptr==NULL)
-        retVal=0;
-    else
-    {
-        if (fread(ptr, 1, *plFileSize,stream) != (*plFileSize))
-            retVal=0;
-    }
-    fclose(stream);
-    *pFilePtr=ptr;
-    return retVal;
-}
-
-int main(int argc, char *argv[])
-{
-    int BlockSizeCompress=0x8000;
-    int BlockSizeUncompress=0x8000;
-    int cprLevel=Z_DEFAULT_COMPRESSION ;
-    long lFileSize;
-    unsigned char* FilePtr;
-    long lBufferSizeCpr;
-    long lBufferSizeUncpr;
-    long lCompressedSize=0;
-    unsigned char* CprPtr;
-    unsigned char* UncprPtr;
-    long lSizeCpr,lSizeUncpr;
-    DWORD dwGetTick,dwMsecQP;
-    LARGE_INTEGER li_qp,li_rdtsc,dwResRdtsc;
-
-    if (argc<=1)
-    {
-        printf("run TestZlib <File> [BlockSizeCompress] [BlockSizeUncompress] [compres. level]\n");
-        return 0;
-    }
-
-    if (ReadFileMemory(argv[1],&lFileSize,&FilePtr)==0)
-    {
-        printf("error reading %s\n",argv[1]);
-        return 1;
-    }
-    else printf("file %s read, %u bytes\n",argv[1],lFileSize);
-
-    if (argc>=3)
-        BlockSizeCompress=atol(argv[2]);
-
-    if (argc>=4)
-        BlockSizeUncompress=atol(argv[3]);
-
-    if (argc>=5)
-        cprLevel=(int)atol(argv[4]);
-
-    lBufferSizeCpr = lFileSize + (lFileSize/0x10) + 0x200;
-    lBufferSizeUncpr = lBufferSizeCpr;
-
-    CprPtr=(unsigned char*)malloc(lBufferSizeCpr + BlockSizeCompress);
-
-    BeginCountPerfCounter(&li_qp,TRUE);
-    dwGetTick=GetTickCount();
-    BeginCountRdtsc(&li_rdtsc);
-    {
-        z_stream zcpr;
-        int ret=Z_OK;
-        long lOrigToDo = lFileSize;
-        long lOrigDone = 0;
-        int step=0;
-        memset(&zcpr,0,sizeof(z_stream));
-        deflateInit(&zcpr,cprLevel);
-
-        zcpr.next_in = FilePtr;
-        zcpr.next_out = CprPtr;
-
-
-        do
-        {
-            long all_read_before = zcpr.total_in;
-            zcpr.avail_in = min(lOrigToDo,BlockSizeCompress);
-            zcpr.avail_out = BlockSizeCompress;
-            ret=deflate(&zcpr,(zcpr.avail_in==lOrigToDo) ? Z_FINISH : Z_SYNC_FLUSH);
-            lOrigDone += (zcpr.total_in-all_read_before);
-            lOrigToDo -= (zcpr.total_in-all_read_before);
-            step++;
-        } while (ret==Z_OK);
-
-        lSizeCpr=zcpr.total_out;
-        deflateEnd(&zcpr);
-        dwGetTick=GetTickCount()-dwGetTick;
-        dwMsecQP=GetMsecSincePerfCounter(li_qp,TRUE);
-        dwResRdtsc=GetResRdtsc(li_rdtsc,TRUE);
-        printf("total compress size = %u, in %u step\n",lSizeCpr,step);
-        printf("time = %u msec = %f sec\n",dwGetTick,dwGetTick/(double)1000.);
-        printf("defcpr time QP = %u msec = %f sec\n",dwMsecQP,dwMsecQP/(double)1000.);
-        printf("defcpr result rdtsc = %I64x\n\n",dwResRdtsc.QuadPart);
-    }
-
-    CprPtr=(unsigned char*)realloc(CprPtr,lSizeCpr);
-    UncprPtr=(unsigned char*)malloc(lBufferSizeUncpr + BlockSizeUncompress);
-
-    BeginCountPerfCounter(&li_qp,TRUE);
-    dwGetTick=GetTickCount();
-    BeginCountRdtsc(&li_rdtsc);
-    {
-        z_stream zcpr;
-        int ret=Z_OK;
-        long lOrigToDo = lSizeCpr;
-        long lOrigDone = 0;
-        int step=0;
-        memset(&zcpr,0,sizeof(z_stream));
-        inflateInit(&zcpr);
-
-        zcpr.next_in = CprPtr;
-        zcpr.next_out = UncprPtr;
-
-
-        do
-        {
-            long all_read_before = zcpr.total_in;
-            zcpr.avail_in = min(lOrigToDo,BlockSizeUncompress);
-            zcpr.avail_out = BlockSizeUncompress;
-            ret=inflate(&zcpr,Z_SYNC_FLUSH);
-            lOrigDone += (zcpr.total_in-all_read_before);
-            lOrigToDo -= (zcpr.total_in-all_read_before);
-            step++;
-        } while (ret==Z_OK);
-
-        lSizeUncpr=zcpr.total_out;
-        inflateEnd(&zcpr);
-        dwGetTick=GetTickCount()-dwGetTick;
-        dwMsecQP=GetMsecSincePerfCounter(li_qp,TRUE);
-        dwResRdtsc=GetResRdtsc(li_rdtsc,TRUE);
-        printf("total uncompress size = %u, in %u step\n",lSizeUncpr,step);
-        printf("time = %u msec = %f sec\n",dwGetTick,dwGetTick/(double)1000.);
-        printf("uncpr  time QP = %u msec = %f sec\n",dwMsecQP,dwMsecQP/(double)1000.);
-        printf("uncpr  result rdtsc = %I64x\n\n",dwResRdtsc.QuadPart);
-    }
-
-    if (lSizeUncpr==lFileSize)
-    {
-        if (memcmp(FilePtr,UncprPtr,lFileSize)==0)
-            printf("compare ok\n");
-
-    }
-
-    return 0;
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/testzlib/testzlib.txt gcc-4.8.1-ppc/zlib/contrib/testzlib/testzlib.txt
--- gcc-4.8.1/zlib/contrib/testzlib/testzlib.txt	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/testzlib/testzlib.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,10 +0,0 @@
-To build testzLib with Visual Studio 2005:
-
-copy to a directory file from :
-- root of zLib tree
-- contrib/testzlib
-- contrib/masmx86
-- contrib/masmx64
-- contrib/vstudio/vc7
-
-and open testzlib8.sln
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/untgz/Makefile gcc-4.8.1-ppc/zlib/contrib/untgz/Makefile
--- gcc-4.8.1/zlib/contrib/untgz/Makefile	2004-10-11 19:45:43.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/untgz/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,14 +0,0 @@
-CC=cc
-CFLAGS=-g
-
-untgz: untgz.o ../../libz.a
-	$(CC) $(CFLAGS) -o untgz untgz.o -L../.. -lz
-
-untgz.o: untgz.c ../../zlib.h
-	$(CC) $(CFLAGS) -c -I../.. untgz.c
-
-../../libz.a:
-	cd ../..; ./configure; make
-
-clean:
-	rm -f untgz untgz.o *~
diff -Nbaur gcc-4.8.1/zlib/contrib/untgz/Makefile.msc gcc-4.8.1-ppc/zlib/contrib/untgz/Makefile.msc
--- gcc-4.8.1/zlib/contrib/untgz/Makefile.msc	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/untgz/Makefile.msc	1970-01-01 01:00:00.000000000 +0100
@@ -1,17 +0,0 @@
-CC=cl
-CFLAGS=-MD
-
-untgz.exe: untgz.obj ..\..\zlib.lib
-	$(CC) $(CFLAGS) untgz.obj ..\..\zlib.lib
-
-untgz.obj: untgz.c ..\..\zlib.h
-	$(CC) $(CFLAGS) -c -I..\.. untgz.c
-
-..\..\zlib.lib:
-	cd ..\..
-	$(MAKE) -f win32\makefile.msc
-	cd contrib\untgz
-
-clean:
-	-del untgz.obj
-	-del untgz.exe
diff -Nbaur gcc-4.8.1/zlib/contrib/untgz/untgz.c gcc-4.8.1-ppc/zlib/contrib/untgz/untgz.c
--- gcc-4.8.1/zlib/contrib/untgz/untgz.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/contrib/untgz/untgz.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,674 +0,0 @@
-/*
- * untgz.c -- Display contents and extract files from a gzip'd TAR file
- *
- * written by Pedro A. Aranda Gutierrez <paag@tid.es>
- * adaptation to Unix by Jean-loup Gailly <jloup@gzip.org>
- * various fixes by Cosmin Truta <cosmint@cs.ubbcluj.ro>
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <errno.h>
-
-#include "zlib.h"
-
-#ifdef unix
-#  include <unistd.h>
-#else
-#  include <direct.h>
-#  include <io.h>
-#endif
-
-#ifdef WIN32
-#include <windows.h>
-#  ifndef F_OK
-#    define F_OK  0
-#  endif
-#  define mkdir(dirname,mode)   _mkdir(dirname)
-#  ifdef _MSC_VER
-#    define access(path,mode)   _access(path,mode)
-#    define chmod(path,mode)    _chmod(path,mode)
-#    define strdup(str)         _strdup(str)
-#  endif
-#else
-#  include <utime.h>
-#endif
-
-
-/* values used in typeflag field */
-
-#define REGTYPE  '0'            /* regular file */
-#define AREGTYPE '\0'           /* regular file */
-#define LNKTYPE  '1'            /* link */
-#define SYMTYPE  '2'            /* reserved */
-#define CHRTYPE  '3'            /* character special */
-#define BLKTYPE  '4'            /* block special */
-#define DIRTYPE  '5'            /* directory */
-#define FIFOTYPE '6'            /* FIFO special */
-#define CONTTYPE '7'            /* reserved */
-
-/* GNU tar extensions */
-
-#define GNUTYPE_DUMPDIR  'D'    /* file names from dumped directory */
-#define GNUTYPE_LONGLINK 'K'    /* long link name */
-#define GNUTYPE_LONGNAME 'L'    /* long file name */
-#define GNUTYPE_MULTIVOL 'M'    /* continuation of file from another volume */
-#define GNUTYPE_NAMES    'N'    /* file name that does not fit into main hdr */
-#define GNUTYPE_SPARSE   'S'    /* sparse file */
-#define GNUTYPE_VOLHDR   'V'    /* tape/volume header */
-
-
-/* tar header */
-
-#define BLOCKSIZE     512
-#define SHORTNAMESIZE 100
-
-struct tar_header
-{                               /* byte offset */
-  char name[100];               /*   0 */
-  char mode[8];                 /* 100 */
-  char uid[8];                  /* 108 */
-  char gid[8];                  /* 116 */
-  char size[12];                /* 124 */
-  char mtime[12];               /* 136 */
-  char chksum[8];               /* 148 */
-  char typeflag;                /* 156 */
-  char linkname[100];           /* 157 */
-  char magic[6];                /* 257 */
-  char version[2];              /* 263 */
-  char uname[32];               /* 265 */
-  char gname[32];               /* 297 */
-  char devmajor[8];             /* 329 */
-  char devminor[8];             /* 337 */
-  char prefix[155];             /* 345 */
-                                /* 500 */
-};
-
-union tar_buffer
-{
-  char               buffer[BLOCKSIZE];
-  struct tar_header  header;
-};
-
-struct attr_item
-{
-  struct attr_item  *next;
-  char              *fname;
-  int                mode;
-  time_t             time;
-};
-
-enum { TGZ_EXTRACT, TGZ_LIST, TGZ_INVALID };
-
-char *TGZfname          OF((const char *));
-void TGZnotfound        OF((const char *));
-
-int getoct              OF((char *, int));
-char *strtime           OF((time_t *));
-int setfiletime         OF((char *, time_t));
-void push_attr          OF((struct attr_item **, char *, int, time_t));
-void restore_attr       OF((struct attr_item **));
-
-int ExprMatch           OF((char *, char *));
-
-int makedir             OF((char *));
-int matchname           OF((int, int, char **, char *));
-
-void error              OF((const char *));
-int tar                 OF((gzFile, int, int, int, char **));
-
-void help               OF((int));
-int main                OF((int, char **));
-
-char *prog;
-
-const char *TGZsuffix[] = { "\0", ".tar", ".tar.gz", ".taz", ".tgz", NULL };
-
-/* return the file name of the TGZ archive */
-/* or NULL if it does not exist */
-
-char *TGZfname (const char *arcname)
-{
-  static char buffer[1024];
-  int origlen,i;
-
-  strcpy(buffer,arcname);
-  origlen = strlen(buffer);
-
-  for (i=0; TGZsuffix[i]; i++)
-    {
-       strcpy(buffer+origlen,TGZsuffix[i]);
-       if (access(buffer,F_OK) == 0)
-         return buffer;
-    }
-  return NULL;
-}
-
-
-/* error message for the filename */
-
-void TGZnotfound (const char *arcname)
-{
-  int i;
-
-  fprintf(stderr,"%s: Couldn't find ",prog);
-  for (i=0;TGZsuffix[i];i++)
-    fprintf(stderr,(TGZsuffix[i+1]) ? "%s%s, " : "or %s%s\n",
-            arcname,
-            TGZsuffix[i]);
-  exit(1);
-}
-
-
-/* convert octal digits to int */
-/* on error return -1 */
-
-int getoct (char *p,int width)
-{
-  int result = 0;
-  char c;
-
-  while (width--)
-    {
-      c = *p++;
-      if (c == 0)
-        break;
-      if (c == ' ')
-        continue;
-      if (c < '0' || c > '7')
-        return -1;
-      result = result * 8 + (c - '0');
-    }
-  return result;
-}
-
-
-/* convert time_t to string */
-/* use the "YYYY/MM/DD hh:mm:ss" format */
-
-char *strtime (time_t *t)
-{
-  struct tm   *local;
-  static char result[32];
-
-  local = localtime(t);
-  sprintf(result,"%4d/%02d/%02d %02d:%02d:%02d",
-          local->tm_year+1900, local->tm_mon+1, local->tm_mday,
-          local->tm_hour, local->tm_min, local->tm_sec);
-  return result;
-}
-
-
-/* set file time */
-
-int setfiletime (char *fname,time_t ftime)
-{
-#ifdef WIN32
-  static int isWinNT = -1;
-  SYSTEMTIME st;
-  FILETIME locft, modft;
-  struct tm *loctm;
-  HANDLE hFile;
-  int result;
-
-  loctm = localtime(&ftime);
-  if (loctm == NULL)
-    return -1;
-
-  st.wYear         = (WORD)loctm->tm_year + 1900;
-  st.wMonth        = (WORD)loctm->tm_mon + 1;
-  st.wDayOfWeek    = (WORD)loctm->tm_wday;
-  st.wDay          = (WORD)loctm->tm_mday;
-  st.wHour         = (WORD)loctm->tm_hour;
-  st.wMinute       = (WORD)loctm->tm_min;
-  st.wSecond       = (WORD)loctm->tm_sec;
-  st.wMilliseconds = 0;
-  if (!SystemTimeToFileTime(&st, &locft) ||
-      !LocalFileTimeToFileTime(&locft, &modft))
-    return -1;
-
-  if (isWinNT < 0)
-    isWinNT = (GetVersion() < 0x80000000) ? 1 : 0;
-  hFile = CreateFile(fname, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
-                     (isWinNT ? FILE_FLAG_BACKUP_SEMANTICS : 0),
-                     NULL);
-  if (hFile == INVALID_HANDLE_VALUE)
-    return -1;
-  result = SetFileTime(hFile, NULL, NULL, &modft) ? 0 : -1;
-  CloseHandle(hFile);
-  return result;
-#else
-  struct utimbuf settime;
-
-  settime.actime = settime.modtime = ftime;
-  return utime(fname,&settime);
-#endif
-}
-
-
-/* push file attributes */
-
-void push_attr(struct attr_item **list,char *fname,int mode,time_t time)
-{
-  struct attr_item *item;
-
-  item = (struct attr_item *)malloc(sizeof(struct attr_item));
-  if (item == NULL)
-    error("Out of memory");
-  item->fname = strdup(fname);
-  item->mode  = mode;
-  item->time  = time;
-  item->next  = *list;
-  *list       = item;
-}
-
-
-/* restore file attributes */
-
-void restore_attr(struct attr_item **list)
-{
-  struct attr_item *item, *prev;
-
-  for (item = *list; item != NULL; )
-    {
-      setfiletime(item->fname,item->time);
-      chmod(item->fname,item->mode);
-      prev = item;
-      item = item->next;
-      free(prev);
-    }
-  *list = NULL;
-}
-
-
-/* match regular expression */
-
-#define ISSPECIAL(c) (((c) == '*') || ((c) == '/'))
-
-int ExprMatch (char *string,char *expr)
-{
-  while (1)
-    {
-      if (ISSPECIAL(*expr))
-        {
-          if (*expr == '/')
-            {
-              if (*string != '\\' && *string != '/')
-                return 0;
-              string ++; expr++;
-            }
-          else if (*expr == '*')
-            {
-              if (*expr ++ == 0)
-                return 1;
-              while (*++string != *expr)
-                if (*string == 0)
-                  return 0;
-            }
-        }
-      else
-        {
-          if (*string != *expr)
-            return 0;
-          if (*expr++ == 0)
-            return 1;
-          string++;
-        }
-    }
-}
-
-
-/* recursive mkdir */
-/* abort on ENOENT; ignore other errors like "directory already exists" */
-/* return 1 if OK */
-/*        0 on error */
-
-int makedir (char *newdir)
-{
-  char *buffer = strdup(newdir);
-  char *p;
-  int  len = strlen(buffer);
-
-  if (len <= 0) {
-    free(buffer);
-    return 0;
-  }
-  if (buffer[len-1] == '/') {
-    buffer[len-1] = '\0';
-  }
-  if (mkdir(buffer, 0755) == 0)
-    {
-      free(buffer);
-      return 1;
-    }
-
-  p = buffer+1;
-  while (1)
-    {
-      char hold;
-
-      while(*p && *p != '\\' && *p != '/')
-        p++;
-      hold = *p;
-      *p = 0;
-      if ((mkdir(buffer, 0755) == -1) && (errno == ENOENT))
-        {
-          fprintf(stderr,"%s: Couldn't create directory %s\n",prog,buffer);
-          free(buffer);
-          return 0;
-        }
-      if (hold == 0)
-        break;
-      *p++ = hold;
-    }
-  free(buffer);
-  return 1;
-}
-
-
-int matchname (int arg,int argc,char **argv,char *fname)
-{
-  if (arg == argc)      /* no arguments given (untgz tgzarchive) */
-    return 1;
-
-  while (arg < argc)
-    if (ExprMatch(fname,argv[arg++]))
-      return 1;
-
-  return 0; /* ignore this for the moment being */
-}
-
-
-/* tar file list or extract */
-
-int tar (gzFile in,int action,int arg,int argc,char **argv)
-{
-  union  tar_buffer buffer;
-  int    len;
-  int    err;
-  int    getheader = 1;
-  int    remaining = 0;
-  FILE   *outfile = NULL;
-  char   fname[BLOCKSIZE];
-  int    tarmode;
-  time_t tartime;
-  struct attr_item *attributes = NULL;
-
-  if (action == TGZ_LIST)
-    printf("    date      time     size                       file\n"
-           " ---------- -------- --------- -------------------------------------\n");
-  while (1)
-    {
-      len = gzread(in, &buffer, BLOCKSIZE);
-      if (len < 0)
-        error(gzerror(in, &err));
-      /*
-       * Always expect complete blocks to process
-       * the tar information.
-       */
-      if (len != BLOCKSIZE)
-        {
-          action = TGZ_INVALID; /* force error exit */
-          remaining = 0;        /* force I/O cleanup */
-        }
-
-      /*
-       * If we have to get a tar header
-       */
-      if (getheader >= 1)
-        {
-          /*
-           * if we met the end of the tar
-           * or the end-of-tar block,
-           * we are done
-           */
-          if (len == 0 || buffer.header.name[0] == 0)
-            break;
-
-          tarmode = getoct(buffer.header.mode,8);
-          tartime = (time_t)getoct(buffer.header.mtime,12);
-          if (tarmode == -1 || tartime == (time_t)-1)
-            {
-              buffer.header.name[0] = 0;
-              action = TGZ_INVALID;
-            }
-
-          if (getheader == 1)
-            {
-              strncpy(fname,buffer.header.name,SHORTNAMESIZE);
-              if (fname[SHORTNAMESIZE-1] != 0)
-                  fname[SHORTNAMESIZE] = 0;
-            }
-          else
-            {
-              /*
-               * The file name is longer than SHORTNAMESIZE
-               */
-              if (strncmp(fname,buffer.header.name,SHORTNAMESIZE-1) != 0)
-                  error("bad long name");
-              getheader = 1;
-            }
-
-          /*
-           * Act according to the type flag
-           */
-          switch (buffer.header.typeflag)
-            {
-            case DIRTYPE:
-              if (action == TGZ_LIST)
-                printf(" %s     <dir> %s\n",strtime(&tartime),fname);
-              if (action == TGZ_EXTRACT)
-                {
-                  makedir(fname);
-                  push_attr(&attributes,fname,tarmode,tartime);
-                }
-              break;
-            case REGTYPE:
-            case AREGTYPE:
-              remaining = getoct(buffer.header.size,12);
-              if (remaining == -1)
-                {
-                  action = TGZ_INVALID;
-                  break;
-                }
-              if (action == TGZ_LIST)
-                printf(" %s %9d %s\n",strtime(&tartime),remaining,fname);
-              else if (action == TGZ_EXTRACT)
-                {
-                  if (matchname(arg,argc,argv,fname))
-                    {
-                      outfile = fopen(fname,"wb");
-                      if (outfile == NULL) {
-                        /* try creating directory */
-                        char *p = strrchr(fname, '/');
-                        if (p != NULL) {
-                          *p = '\0';
-                          makedir(fname);
-                          *p = '/';
-                          outfile = fopen(fname,"wb");
-                        }
-                      }
-                      if (outfile != NULL)
-                        printf("Extracting %s\n",fname);
-                      else
-                        fprintf(stderr, "%s: Couldn't create %s",prog,fname);
-                    }
-                  else
-                    outfile = NULL;
-                }
-              getheader = 0;
-              break;
-            case GNUTYPE_LONGLINK:
-            case GNUTYPE_LONGNAME:
-              remaining = getoct(buffer.header.size,12);
-              if (remaining < 0 || remaining >= BLOCKSIZE)
-                {
-                  action = TGZ_INVALID;
-                  break;
-                }
-              len = gzread(in, fname, BLOCKSIZE);
-              if (len < 0)
-                error(gzerror(in, &err));
-              if (fname[BLOCKSIZE-1] != 0 || (int)strlen(fname) > remaining)
-                {
-                  action = TGZ_INVALID;
-                  break;
-                }
-              getheader = 2;
-              break;
-            default:
-              if (action == TGZ_LIST)
-                printf(" %s     <---> %s\n",strtime(&tartime),fname);
-              break;
-            }
-        }
-      else
-        {
-          unsigned int bytes = (remaining > BLOCKSIZE) ? BLOCKSIZE : remaining;
-
-          if (outfile != NULL)
-            {
-              if (fwrite(&buffer,sizeof(char),bytes,outfile) != bytes)
-                {
-                  fprintf(stderr,
-                    "%s: Error writing %s -- skipping\n",prog,fname);
-                  fclose(outfile);
-                  outfile = NULL;
-                  remove(fname);
-                }
-            }
-          remaining -= bytes;
-        }
-
-      if (remaining == 0)
-        {
-          getheader = 1;
-          if (outfile != NULL)
-            {
-              fclose(outfile);
-              outfile = NULL;
-              if (action != TGZ_INVALID)
-                push_attr(&attributes,fname,tarmode,tartime);
-            }
-        }
-
-      /*
-       * Abandon if errors are found
-       */
-      if (action == TGZ_INVALID)
-        {
-          error("broken archive");
-          break;
-        }
-    }
-
-  /*
-   * Restore file modes and time stamps
-   */
-  restore_attr(&attributes);
-
-  if (gzclose(in) != Z_OK)
-    error("failed gzclose");
-
-  return 0;
-}
-
-
-/* ============================================================ */
-
-void help(int exitval)
-{
-  printf("untgz version 0.2.1\n"
-         "  using zlib version %s\n\n",
-         zlibVersion());
-  printf("Usage: untgz file.tgz            extract all files\n"
-         "       untgz file.tgz fname ...  extract selected files\n"
-         "       untgz -l file.tgz         list archive contents\n"
-         "       untgz -h                  display this help\n");
-  exit(exitval);
-}
-
-void error(const char *msg)
-{
-  fprintf(stderr, "%s: %s\n", prog, msg);
-  exit(1);
-}
-
-
-/* ============================================================ */
-
-#if defined(WIN32) && defined(__GNUC__)
-int _CRT_glob = 0;      /* disable argument globbing in MinGW */
-#endif
-
-int main(int argc,char **argv)
-{
-    int         action = TGZ_EXTRACT;
-    int         arg = 1;
-    char        *TGZfile;
-    gzFile      *f;
-
-    prog = strrchr(argv[0],'\\');
-    if (prog == NULL)
-      {
-        prog = strrchr(argv[0],'/');
-        if (prog == NULL)
-          {
-            prog = strrchr(argv[0],':');
-            if (prog == NULL)
-              prog = argv[0];
-            else
-              prog++;
-          }
-        else
-          prog++;
-      }
-    else
-      prog++;
-
-    if (argc == 1)
-      help(0);
-
-    if (strcmp(argv[arg],"-l") == 0)
-      {
-        action = TGZ_LIST;
-        if (argc == ++arg)
-          help(0);
-      }
-    else if (strcmp(argv[arg],"-h") == 0)
-      {
-        help(0);
-      }
-
-    if ((TGZfile = TGZfname(argv[arg])) == NULL)
-      TGZnotfound(argv[arg]);
-
-    ++arg;
-    if ((action == TGZ_LIST) && (arg != argc))
-      help(1);
-
-/*
- *  Process the TGZ file
- */
-    switch(action)
-      {
-      case TGZ_LIST:
-      case TGZ_EXTRACT:
-        f = gzopen(TGZfile,"rb");
-        if (f == NULL)
-          {
-            fprintf(stderr,"%s: Couldn't gzopen %s\n",prog,TGZfile);
-            return 1;
-          }
-        exit(tar(f, action, arg, argc, argv));
-      break;
-
-      default:
-        error("Unknown option");
-        exit(1);
-      }
-
-    return 0;
-}
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/readme.txt gcc-4.8.1-ppc/zlib/contrib/vstudio/readme.txt
--- gcc-4.8.1/zlib/contrib/vstudio/readme.txt	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/readme.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,60 +0,0 @@
-Building instructions for the DLL versions of Zlib 1.2.7
-========================================================
-
-This directory contains projects that build zlib and minizip using
-Microsoft Visual C++ 9.0/10.0.
-
-You don't need to build these projects yourself. You can download the
-binaries from:
-  http://www.winimage.com/zLibDll
-
-More information can be found at this site.
-
-
-
-
-
-Build instructions for Visual Studio 2008 (32 bits or 64 bits)
---------------------------------------------------------------
-- Uncompress current zlib, including all contrib/* files
-- Compile assembly code (with Visual Studio Command Prompt) by running:
-   bld_ml64.bat (in contrib\masmx64)
-   bld_ml32.bat (in contrib\masmx86)
-- Open contrib\vstudio\vc9\zlibvc.sln with Microsoft Visual C++ 2008
-- Or run: vcbuild /rebuild contrib\vstudio\vc9\zlibvc.sln "Release|Win32"
-
-Build instructions for Visual Studio 2010 (32 bits or 64 bits)
---------------------------------------------------------------
-- Uncompress current zlib, including all contrib/* files
-- Open contrib\vstudio\vc10\zlibvc.sln with Microsoft Visual C++ 2010
-
-
-Important
----------
-- To use zlibwapi.dll in your application, you must define the
-  macro ZLIB_WINAPI when compiling your application's source files.
-
-
-Additional notes
-----------------
-- This DLL, named zlibwapi.dll, is compatible to the old zlib.dll built
-  by Gilles Vollant from the zlib 1.1.x sources, and distributed at
-    http://www.winimage.com/zLibDll
-  It uses the WINAPI calling convention for the exported functions, and
-  includes the minizip functionality. If your application needs that
-  particular build of zlib.dll, you can rename zlibwapi.dll to zlib.dll.
-
-- The new DLL was renamed because there exist several incompatible
-  versions of zlib.dll on the Internet.
-
-- There is also an official DLL build of zlib, named zlib1.dll. This one
-  is exporting the functions using the CDECL convention. See the file
-  win32\DLL_FAQ.txt found in this zlib distribution.
-
-- There used to be a ZLIB_DLL macro in zlib 1.1.x, but now this symbol
-  has a slightly different effect. To avoid compatibility problems, do
-  not define it here.
-
-
-Gilles Vollant
-info@winimage.com
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/miniunz.vcxproj gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/miniunz.vcxproj
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/miniunz.vcxproj	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/miniunz.vcxproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,310 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Itanium">
-      <Configuration>Debug</Configuration>
-      <Platform>Itanium</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Itanium">
-      <Configuration>Release</Configuration>
-      <Platform>Itanium</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{C52F9E7B-498A-42BE-8DB4-85A15694382A}</ProjectGuid>
-    <Keyword>Win32Proj</Keyword>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.30128.1</_ProjectFileVersion>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">x86\MiniUnzip$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">x86\MiniUnzip$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">x86\MiniUnzip$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">x86\MiniUnzip$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">x64\MiniUnzip$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">x64\MiniUnzip$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">ia64\MiniUnzip$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">ia64\MiniUnzip$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">true</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">x64\MiniUnzip$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">x64\MiniUnzip$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">ia64\MiniUnzip$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">ia64\MiniUnzip$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">false</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">false</GenerateManifest>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..;..\..\minizip;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MinimalRebuild>true</MinimalRebuild>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>x86\ZlibDllDebug\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)miniunz.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <ProgramDatabaseFile>$(OutDir)miniunz.pdb</ProgramDatabaseFile>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX86</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <OmitFramePointers>true</OmitFramePointers>
-      <AdditionalIncludeDirectories>..\..\..;..\..\minizip;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>x86\ZlibDllRelease\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)miniunz.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <SubSystem>Console</SubSystem>
-      <OptimizeReferences>true</OptimizeReferences>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX86</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <Midl>
-      <TargetEnvironment>X64</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..;..\..\minizip;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MinimalRebuild>true</MinimalRebuild>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>x64\ZlibDllDebug\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)miniunz.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <ProgramDatabaseFile>$(OutDir)miniunz.pdb</ProgramDatabaseFile>
-      <SubSystem>Console</SubSystem>
-      <TargetMachine>MachineX64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">
-    <Midl>
-      <TargetEnvironment>Itanium</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..;..\..\minizip;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MinimalRebuild>true</MinimalRebuild>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>ia64\ZlibDllDebug\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)miniunz.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <ProgramDatabaseFile>$(OutDir)miniunz.pdb</ProgramDatabaseFile>
-      <SubSystem>Console</SubSystem>
-      <TargetMachine>MachineIA64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <Midl>
-      <TargetEnvironment>X64</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <OmitFramePointers>true</OmitFramePointers>
-      <AdditionalIncludeDirectories>..\..\..;..\..\minizip;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>x64\ZlibDllRelease\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)miniunz.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <SubSystem>Console</SubSystem>
-      <OptimizeReferences>true</OptimizeReferences>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <TargetMachine>MachineX64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">
-    <Midl>
-      <TargetEnvironment>Itanium</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <OmitFramePointers>true</OmitFramePointers>
-      <AdditionalIncludeDirectories>..\..\..;..\..\minizip;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>ia64\ZlibDllRelease\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)miniunz.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <SubSystem>Console</SubSystem>
-      <OptimizeReferences>true</OptimizeReferences>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <TargetMachine>MachineIA64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\minizip\miniunz.c" />
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="zlibvc.vcxproj">
-      <Project>{8fd826f8-3739-44e6-8cc8-997122e53b8d}</Project>
-    </ProjectReference>
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/miniunz.vcxproj.filters gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/miniunz.vcxproj.filters
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/miniunz.vcxproj.filters	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/miniunz.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
@@ -1,22 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="Source Files">
-      <UniqueIdentifier>{048af943-022b-4db6-beeb-a54c34774ee2}</UniqueIdentifier>
-      <Extensions>cpp;c;cxx;def;odl;idl;hpj;bat;asm</Extensions>
-    </Filter>
-    <Filter Include="Header Files">
-      <UniqueIdentifier>{c1d600d2-888f-4aea-b73e-8b0dd9befa0c}</UniqueIdentifier>
-      <Extensions>h;hpp;hxx;hm;inl;inc</Extensions>
-    </Filter>
-    <Filter Include="Resource Files">
-      <UniqueIdentifier>{0844199a-966b-4f19-81db-1e0125e141b9}</UniqueIdentifier>
-      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\minizip\miniunz.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/miniunz.vcxproj.user gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/miniunz.vcxproj.user
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/miniunz.vcxproj.user	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/miniunz.vcxproj.user	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-</Project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/minizip.vcxproj gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/minizip.vcxproj
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/minizip.vcxproj	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/minizip.vcxproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,307 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Itanium">
-      <Configuration>Debug</Configuration>
-      <Platform>Itanium</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Itanium">
-      <Configuration>Release</Configuration>
-      <Platform>Itanium</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}</ProjectGuid>
-    <Keyword>Win32Proj</Keyword>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.30128.1</_ProjectFileVersion>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">x86\MiniZip$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">x86\MiniZip$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">x86\MiniZip$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">x86\MiniZip$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">x64\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">x64\$(Configuration)\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">ia64\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">ia64\$(Configuration)\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">true</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">x64\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">x64\$(Configuration)\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">ia64\$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">ia64\$(Configuration)\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">false</LinkIncremental>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..;..\..\minizip;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MinimalRebuild>true</MinimalRebuild>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>x86\ZlibDllDebug\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)minizip.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <ProgramDatabaseFile>$(OutDir)minizip.pdb</ProgramDatabaseFile>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX86</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <OmitFramePointers>true</OmitFramePointers>
-      <AdditionalIncludeDirectories>..\..\..;..\..\minizip;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>x86\ZlibDllRelease\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)minizip.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <SubSystem>Console</SubSystem>
-      <OptimizeReferences>true</OptimizeReferences>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX86</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <Midl>
-      <TargetEnvironment>X64</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..;..\..\minizip;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MinimalRebuild>true</MinimalRebuild>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>x64\ZlibDllDebug\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)minizip.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <ProgramDatabaseFile>$(OutDir)minizip.pdb</ProgramDatabaseFile>
-      <SubSystem>Console</SubSystem>
-      <TargetMachine>MachineX64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">
-    <Midl>
-      <TargetEnvironment>Itanium</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..;..\..\minizip;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MinimalRebuild>true</MinimalRebuild>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>ia64\ZlibDllDebug\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)minizip.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <ProgramDatabaseFile>$(OutDir)minizip.pdb</ProgramDatabaseFile>
-      <SubSystem>Console</SubSystem>
-      <TargetMachine>MachineIA64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <Midl>
-      <TargetEnvironment>X64</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <OmitFramePointers>true</OmitFramePointers>
-      <AdditionalIncludeDirectories>..\..\..;..\..\minizip;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>x64\ZlibDllRelease\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)minizip.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <SubSystem>Console</SubSystem>
-      <OptimizeReferences>true</OptimizeReferences>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <TargetMachine>MachineX64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">
-    <Midl>
-      <TargetEnvironment>Itanium</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <OmitFramePointers>true</OmitFramePointers>
-      <AdditionalIncludeDirectories>..\..\..;..\..\minizip;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>ia64\ZlibDllRelease\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)minizip.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <SubSystem>Console</SubSystem>
-      <OptimizeReferences>true</OptimizeReferences>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <TargetMachine>MachineIA64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\minizip\minizip.c" />
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="zlibvc.vcxproj">
-      <Project>{8fd826f8-3739-44e6-8cc8-997122e53b8d}</Project>
-    </ProjectReference>
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/minizip.vcxproj.filters gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/minizip.vcxproj.filters
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/minizip.vcxproj.filters	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/minizip.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
@@ -1,22 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="Source Files">
-      <UniqueIdentifier>{c0419b40-bf50-40da-b153-ff74215b79de}</UniqueIdentifier>
-      <Extensions>cpp;c;cxx;def;odl;idl;hpj;bat;asm</Extensions>
-    </Filter>
-    <Filter Include="Header Files">
-      <UniqueIdentifier>{bb87b070-735b-478e-92ce-7383abb2f36c}</UniqueIdentifier>
-      <Extensions>h;hpp;hxx;hm;inl;inc</Extensions>
-    </Filter>
-    <Filter Include="Resource Files">
-      <UniqueIdentifier>{f46ab6a6-548f-43cb-ae96-681abb5bd5db}</UniqueIdentifier>
-      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\minizip\minizip.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/minizip.vcxproj.user gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/minizip.vcxproj.user
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/minizip.vcxproj.user	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/minizip.vcxproj.user	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-</Project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/testzlibdll.vcxproj gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/testzlibdll.vcxproj
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/testzlibdll.vcxproj	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/testzlibdll.vcxproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,310 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Itanium">
-      <Configuration>Debug</Configuration>
-      <Platform>Itanium</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Itanium">
-      <Configuration>Release</Configuration>
-      <Platform>Itanium</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{C52F9E7B-498A-42BE-8DB4-85A15694366A}</ProjectGuid>
-    <Keyword>Win32Proj</Keyword>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.30128.1</_ProjectFileVersion>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">x86\TestZlibDll$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">x86\TestZlibDll$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">x86\TestZlibDll$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">x86\TestZlibDll$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">x64\TestZlibDll$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">x64\TestZlibDll$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">ia64\TestZlibDll$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">ia64\TestZlibDll$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">true</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">x64\TestZlibDll$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">x64\TestZlibDll$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">ia64\TestZlibDll$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">ia64\TestZlibDll$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">false</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">false</GenerateManifest>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..;..\..\minizip;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MinimalRebuild>true</MinimalRebuild>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>x86\ZlibDllDebug\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)testzlibdll.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <ProgramDatabaseFile>$(OutDir)testzlib.pdb</ProgramDatabaseFile>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX86</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <OmitFramePointers>true</OmitFramePointers>
-      <AdditionalIncludeDirectories>..\..\..;..\..\minizip;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>x86\ZlibDllRelease\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)testzlibdll.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <SubSystem>Console</SubSystem>
-      <OptimizeReferences>true</OptimizeReferences>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX86</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <Midl>
-      <TargetEnvironment>X64</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..;..\..\minizip;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MinimalRebuild>true</MinimalRebuild>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>x64\ZlibDllDebug\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)testzlibdll.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <ProgramDatabaseFile>$(OutDir)testzlib.pdb</ProgramDatabaseFile>
-      <SubSystem>Console</SubSystem>
-      <TargetMachine>MachineX64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">
-    <Midl>
-      <TargetEnvironment>Itanium</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..;..\..\minizip;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MinimalRebuild>true</MinimalRebuild>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>ia64\ZlibDllDebug\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)testzlibdll.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <ProgramDatabaseFile>$(OutDir)testzlib.pdb</ProgramDatabaseFile>
-      <SubSystem>Console</SubSystem>
-      <TargetMachine>MachineIA64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <Midl>
-      <TargetEnvironment>X64</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <OmitFramePointers>true</OmitFramePointers>
-      <AdditionalIncludeDirectories>..\..\..;..\..\minizip;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>x64\ZlibDllRelease\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)testzlibdll.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <SubSystem>Console</SubSystem>
-      <OptimizeReferences>true</OptimizeReferences>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <TargetMachine>MachineX64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">
-    <Midl>
-      <TargetEnvironment>Itanium</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <OmitFramePointers>true</OmitFramePointers>
-      <AdditionalIncludeDirectories>..\..\..;..\..\minizip;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>ia64\ZlibDllRelease\zlibwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)testzlibdll.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <SubSystem>Console</SubSystem>
-      <OptimizeReferences>true</OptimizeReferences>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <TargetMachine>MachineIA64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\testzlib\testzlib.c" />
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="zlibvc.vcxproj">
-      <Project>{8fd826f8-3739-44e6-8cc8-997122e53b8d}</Project>
-    </ProjectReference>
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/testzlibdll.vcxproj.filters gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/testzlibdll.vcxproj.filters
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/testzlibdll.vcxproj.filters	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/testzlibdll.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
@@ -1,22 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="Source Files">
-      <UniqueIdentifier>{fa61a89f-93fc-4c89-b29e-36224b7592f4}</UniqueIdentifier>
-      <Extensions>cpp;c;cxx;def;odl;idl;hpj;bat;asm</Extensions>
-    </Filter>
-    <Filter Include="Header Files">
-      <UniqueIdentifier>{d4b85da0-2ba2-4934-b57f-e2584e3848ee}</UniqueIdentifier>
-      <Extensions>h;hpp;hxx;hm;inl;inc</Extensions>
-    </Filter>
-    <Filter Include="Resource Files">
-      <UniqueIdentifier>{e573e075-00bd-4a7d-bd67-a8cc9bfc5aca}</UniqueIdentifier>
-      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\testzlib\testzlib.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/testzlibdll.vcxproj.user gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/testzlibdll.vcxproj.user
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/testzlibdll.vcxproj.user	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/testzlibdll.vcxproj.user	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-</Project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/testzlib.vcxproj gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/testzlib.vcxproj
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/testzlib.vcxproj	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/testzlib.vcxproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,420 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Itanium">
-      <Configuration>Debug</Configuration>
-      <Platform>Itanium</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="ReleaseWithoutAsm|Itanium">
-      <Configuration>ReleaseWithoutAsm</Configuration>
-      <Platform>Itanium</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="ReleaseWithoutAsm|Win32">
-      <Configuration>ReleaseWithoutAsm</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="ReleaseWithoutAsm|x64">
-      <Configuration>ReleaseWithoutAsm</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Itanium">
-      <Configuration>Release</Configuration>
-      <Platform>Itanium</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}</ProjectGuid>
-    <RootNamespace>testzlib</RootNamespace>
-    <Keyword>Win32Proj</Keyword>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.30128.1</_ProjectFileVersion>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">x86\TestZlib$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">x86\TestZlib$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">x86\TestZlib$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">x86\TestZlib$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">false</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">x86\TestZlib$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">x86\TestZlib$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">x64\TestZlib$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">x64\TestZlib$(Configuration)\Tmp\</IntDir>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">ia64\TestZlib$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">ia64\TestZlib$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">true</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'">x64\TestZlib$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'">x64\TestZlib$(Configuration)\Tmp\</IntDir>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">ia64\TestZlib$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">ia64\TestZlib$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">false</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">x64\TestZlib$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">x64\TestZlib$(Configuration)\Tmp\</IntDir>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">ia64\TestZlib$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">ia64\TestZlib$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">false</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">false</GenerateManifest>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>ASMV;ASMINF;WIN32;ZLIB_WINAPI;_DEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MinimalRebuild>true</MinimalRebuild>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerOutput>AssemblyAndSourceCode</AssemblerOutput>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>..\..\masmx86\match686.obj;..\..\masmx86\inffas32.obj;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)testzlib.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <ProgramDatabaseFile>$(OutDir)testzlib.pdb</ProgramDatabaseFile>
-      <SubSystem>Console</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX86</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <OmitFramePointers>true</OmitFramePointers>
-      <AdditionalIncludeDirectories>..\..\..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <OutputFile>$(OutDir)testzlib.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <SubSystem>Console</SubSystem>
-      <OptimizeReferences>true</OptimizeReferences>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX86</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <OmitFramePointers>true</OmitFramePointers>
-      <AdditionalIncludeDirectories>..\..\..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>ASMV;ASMINF;WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>..\..\masmx86\match686.obj;..\..\masmx86\inffas32.obj;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)testzlib.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <SubSystem>Console</SubSystem>
-      <OptimizeReferences>true</OptimizeReferences>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <TargetMachine>MachineX86</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <ClCompile>
-      <AdditionalIncludeDirectories>..\..\..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>ASMV;ASMINF;WIN32;ZLIB_WINAPI;_DEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>..\..\masmx64\gvmat64.obj;..\..\masmx64\inffasx64.obj;%(AdditionalDependencies)</AdditionalDependencies>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">
-    <Midl>
-      <TargetEnvironment>Itanium</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>ZLIB_WINAPI;_DEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MinimalRebuild>true</MinimalRebuild>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerOutput>AssemblyAndSourceCode</AssemblerOutput>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <OutputFile>$(OutDir)testzlib.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <ProgramDatabaseFile>$(OutDir)testzlib.pdb</ProgramDatabaseFile>
-      <SubSystem>Console</SubSystem>
-      <TargetMachine>MachineIA64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'">
-    <ClCompile>
-      <AdditionalIncludeDirectories>..\..\..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">
-    <Midl>
-      <TargetEnvironment>Itanium</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <OmitFramePointers>true</OmitFramePointers>
-      <AdditionalIncludeDirectories>..\..\..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <OutputFile>$(OutDir)testzlib.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <SubSystem>Console</SubSystem>
-      <OptimizeReferences>true</OptimizeReferences>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <TargetMachine>MachineIA64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <ClCompile>
-      <AdditionalIncludeDirectories>..\..\..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>ASMV;ASMINF;WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-    </ClCompile>
-    <Link>
-      <AdditionalDependencies>..\..\masmx64\gvmat64.obj;..\..\masmx64\inffasx64.obj;%(AdditionalDependencies)</AdditionalDependencies>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">
-    <Midl>
-      <TargetEnvironment>Itanium</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <OmitFramePointers>true</OmitFramePointers>
-      <AdditionalIncludeDirectories>..\..\..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeader>
-      </PrecompiledHeader>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <WarningLevel>Level3</WarningLevel>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <Link>
-      <OutputFile>$(OutDir)testzlib.exe</OutputFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <SubSystem>Console</SubSystem>
-      <OptimizeReferences>true</OptimizeReferences>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <TargetMachine>MachineIA64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\adler32.c" />
-    <ClCompile Include="..\..\..\compress.c" />
-    <ClCompile Include="..\..\..\crc32.c" />
-    <ClCompile Include="..\..\..\deflate.c" />
-    <ClCompile Include="..\..\..\infback.c" />
-    <ClCompile Include="..\..\masmx64\inffas8664.c">
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
-    </ClCompile>
-    <ClCompile Include="..\..\..\inffast.c" />
-    <ClCompile Include="..\..\..\inflate.c" />
-    <ClCompile Include="..\..\..\inftrees.c" />
-    <ClCompile Include="..\..\testzlib\testzlib.c" />
-    <ClCompile Include="..\..\..\trees.c" />
-    <ClCompile Include="..\..\..\uncompr.c" />
-    <ClCompile Include="..\..\..\zutil.c" />
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/testzlib.vcxproj.filters gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/testzlib.vcxproj.filters
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/testzlib.vcxproj.filters	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/testzlib.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
@@ -1,58 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="Source Files">
-      <UniqueIdentifier>{c1f6a2e3-5da5-4955-8653-310d3efe05a9}</UniqueIdentifier>
-      <Extensions>cpp;c;cxx;def;odl;idl;hpj;bat;asm</Extensions>
-    </Filter>
-    <Filter Include="Header Files">
-      <UniqueIdentifier>{c2aaffdc-2c95-4d6f-8466-4bec5890af2c}</UniqueIdentifier>
-      <Extensions>h;hpp;hxx;hm;inl;inc</Extensions>
-    </Filter>
-    <Filter Include="Resource Files">
-      <UniqueIdentifier>{c274fe07-05f2-461c-964b-f6341e4e7eb5}</UniqueIdentifier>
-      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe</Extensions>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\adler32.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\compress.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\crc32.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\deflate.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\infback.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\masmx64\inffas8664.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\inffast.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\inflate.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\inftrees.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\testzlib\testzlib.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\trees.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\uncompr.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\zutil.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/testzlib.vcxproj.user gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/testzlib.vcxproj.user
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/testzlib.vcxproj.user	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/testzlib.vcxproj.user	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-</Project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/zlib.rc gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/zlib.rc
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/zlib.rc	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/zlib.rc	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-#include <windows.h>
-
-#define IDR_VERSION1  1
-IDR_VERSION1	VERSIONINFO	MOVEABLE IMPURE LOADONCALL DISCARDABLE
-  FILEVERSION	 1.2.7,0
-  PRODUCTVERSION 1.2.7,0
-  FILEFLAGSMASK	VS_FFI_FILEFLAGSMASK
-  FILEFLAGS	0
-  FILEOS	VOS_DOS_WINDOWS32
-  FILETYPE	VFT_DLL
-  FILESUBTYPE	0	// not used
-BEGIN
-  BLOCK "StringFileInfo"
-  BEGIN
-    BLOCK "040904E4"
-    //language ID = U.S. English, char set = Windows, Multilingual
-
-    BEGIN
-      VALUE "FileDescription", "zlib data compression and ZIP file I/O library\0"
-      VALUE "FileVersion",	"1.2.7\0"
-      VALUE "InternalName",	"zlib\0"
-      VALUE "OriginalFilename",	"zlib.dll\0"
-      VALUE "ProductName",	"ZLib.DLL\0"
-      VALUE "Comments","DLL support by Alessandro Iacopetti & Gilles Vollant\0"
-      VALUE "LegalCopyright", "(C) 1995-2012 Jean-loup Gailly & Mark Adler\0"
-    END
-  END
-  BLOCK "VarFileInfo"
-  BEGIN
-    VALUE "Translation", 0x0409, 1252
-  END
-END
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/zlibstat.vcxproj gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/zlibstat.vcxproj
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/zlibstat.vcxproj	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/zlibstat.vcxproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,457 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Itanium">
-      <Configuration>Debug</Configuration>
-      <Platform>Itanium</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="ReleaseWithoutAsm|Itanium">
-      <Configuration>ReleaseWithoutAsm</Configuration>
-      <Platform>Itanium</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="ReleaseWithoutAsm|Win32">
-      <Configuration>ReleaseWithoutAsm</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="ReleaseWithoutAsm|x64">
-      <Configuration>ReleaseWithoutAsm</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Itanium">
-      <Configuration>Release</Configuration>
-      <Platform>Itanium</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}</ProjectGuid>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>StaticLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.30128.1</_ProjectFileVersion>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">x86\ZlibStat$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">x86\ZlibStat$(Configuration)\Tmp\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">x86\ZlibStat$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">x86\ZlibStat$(Configuration)\Tmp\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">x86\ZlibStat$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">x86\ZlibStat$(Configuration)\Tmp\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">x64\ZlibStat$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">x64\ZlibStat$(Configuration)\Tmp\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">ia64\ZlibStat$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">ia64\ZlibStat$(Configuration)\Tmp\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">x64\ZlibStat$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">x64\ZlibStat$(Configuration)\Tmp\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">ia64\ZlibStat$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">ia64\ZlibStat$(Configuration)\Tmp\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'">x64\ZlibStat$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'">x64\ZlibStat$(Configuration)\Tmp\</IntDir>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">ia64\ZlibStat$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">ia64\ZlibStat$(Configuration)\Tmp\</IntDir>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..;..\..\masmx86;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <PrecompiledHeaderOutputFile>$(IntDir)zlibstat.pch</PrecompiledHeaderOutputFile>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <ObjectFileName>$(IntDir)</ObjectFileName>
-      <ProgramDataBaseFileName>$(OutDir)</ProgramDataBaseFileName>
-      <WarningLevel>Level3</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>OldStyle</DebugInformationFormat>
-    </ClCompile>
-    <ResourceCompile>
-      <Culture>0x040c</Culture>
-    </ResourceCompile>
-    <Lib>
-      <AdditionalOptions>/MACHINE:X86 /NODEFAULTLIB %(AdditionalOptions)</AdditionalOptions>
-      <OutputFile>$(OutDir)zlibstat.lib</OutputFile>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </Lib>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <ClCompile>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <AdditionalIncludeDirectories>..\..\..;..\..\masmx86;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ASMV;ASMINF;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeaderOutputFile>$(IntDir)zlibstat.pch</PrecompiledHeaderOutputFile>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <ObjectFileName>$(IntDir)</ObjectFileName>
-      <ProgramDataBaseFileName>$(OutDir)</ProgramDataBaseFileName>
-      <WarningLevel>Level3</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </ClCompile>
-    <ResourceCompile>
-      <Culture>0x040c</Culture>
-    </ResourceCompile>
-    <Lib>
-      <AdditionalOptions>/MACHINE:X86 /NODEFAULTLIB %(AdditionalOptions)</AdditionalOptions>
-      <AdditionalDependencies>..\..\masmx86\match686.obj;..\..\masmx86\inffas32.obj;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)zlibstat.lib</OutputFile>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </Lib>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">
-    <ClCompile>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <AdditionalIncludeDirectories>..\..\..;..\..\masmx86;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeaderOutputFile>$(IntDir)zlibstat.pch</PrecompiledHeaderOutputFile>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <ObjectFileName>$(IntDir)</ObjectFileName>
-      <ProgramDataBaseFileName>$(OutDir)</ProgramDataBaseFileName>
-      <WarningLevel>Level3</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </ClCompile>
-    <ResourceCompile>
-      <Culture>0x040c</Culture>
-    </ResourceCompile>
-    <Lib>
-      <AdditionalOptions>/MACHINE:X86 /NODEFAULTLIB %(AdditionalOptions)</AdditionalOptions>
-      <OutputFile>$(OutDir)zlibstat.lib</OutputFile>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </Lib>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <Midl>
-      <TargetEnvironment>X64</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..;..\..\masmx86;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <PrecompiledHeaderOutputFile>$(IntDir)zlibstat.pch</PrecompiledHeaderOutputFile>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <ObjectFileName>$(IntDir)</ObjectFileName>
-      <ProgramDataBaseFileName>$(OutDir)</ProgramDataBaseFileName>
-      <WarningLevel>Level3</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>OldStyle</DebugInformationFormat>
-    </ClCompile>
-    <ResourceCompile>
-      <Culture>0x040c</Culture>
-    </ResourceCompile>
-    <Lib>
-      <AdditionalOptions>/MACHINE:AMD64 /NODEFAULTLIB %(AdditionalOptions)</AdditionalOptions>
-      <OutputFile>$(OutDir)zlibstat.lib</OutputFile>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </Lib>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">
-    <Midl>
-      <TargetEnvironment>Itanium</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..;..\..\masmx86;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <PrecompiledHeaderOutputFile>$(IntDir)zlibstat.pch</PrecompiledHeaderOutputFile>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <ObjectFileName>$(IntDir)</ObjectFileName>
-      <ProgramDataBaseFileName>$(OutDir)</ProgramDataBaseFileName>
-      <WarningLevel>Level3</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>OldStyle</DebugInformationFormat>
-    </ClCompile>
-    <ResourceCompile>
-      <Culture>0x040c</Culture>
-    </ResourceCompile>
-    <Lib>
-      <AdditionalOptions>/MACHINE:IA64 /NODEFAULTLIB %(AdditionalOptions)</AdditionalOptions>
-      <OutputFile>$(OutDir)zlibstat.lib</OutputFile>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </Lib>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <Midl>
-      <TargetEnvironment>X64</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <AdditionalIncludeDirectories>..\..\..;..\..\masmx86;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ASMV;ASMINF;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeaderOutputFile>$(IntDir)zlibstat.pch</PrecompiledHeaderOutputFile>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <ObjectFileName>$(IntDir)</ObjectFileName>
-      <ProgramDataBaseFileName>$(OutDir)</ProgramDataBaseFileName>
-      <WarningLevel>Level3</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </ClCompile>
-    <ResourceCompile>
-      <Culture>0x040c</Culture>
-    </ResourceCompile>
-    <Lib>
-      <AdditionalOptions>/MACHINE:AMD64 /NODEFAULTLIB %(AdditionalOptions)</AdditionalOptions>
-      <AdditionalDependencies>..\..\masmx64\gvmat64.obj;..\..\masmx64\inffasx64.obj;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)zlibstat.lib</OutputFile>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </Lib>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">
-    <Midl>
-      <TargetEnvironment>Itanium</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <AdditionalIncludeDirectories>..\..\..;..\..\masmx86;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeaderOutputFile>$(IntDir)zlibstat.pch</PrecompiledHeaderOutputFile>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <ObjectFileName>$(IntDir)</ObjectFileName>
-      <ProgramDataBaseFileName>$(OutDir)</ProgramDataBaseFileName>
-      <WarningLevel>Level3</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </ClCompile>
-    <ResourceCompile>
-      <Culture>0x040c</Culture>
-    </ResourceCompile>
-    <Lib>
-      <AdditionalOptions>/MACHINE:IA64 /NODEFAULTLIB %(AdditionalOptions)</AdditionalOptions>
-      <OutputFile>$(OutDir)zlibstat.lib</OutputFile>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </Lib>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'">
-    <Midl>
-      <TargetEnvironment>X64</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <AdditionalIncludeDirectories>..\..\..;..\..\masmx86;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeaderOutputFile>$(IntDir)zlibstat.pch</PrecompiledHeaderOutputFile>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <ObjectFileName>$(IntDir)</ObjectFileName>
-      <ProgramDataBaseFileName>$(OutDir)</ProgramDataBaseFileName>
-      <WarningLevel>Level3</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </ClCompile>
-    <ResourceCompile>
-      <Culture>0x040c</Culture>
-    </ResourceCompile>
-    <Lib>
-      <AdditionalOptions>/MACHINE:AMD64 /NODEFAULTLIB %(AdditionalOptions)</AdditionalOptions>
-      <OutputFile>$(OutDir)zlibstat.lib</OutputFile>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </Lib>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">
-    <Midl>
-      <TargetEnvironment>Itanium</TargetEnvironment>
-    </Midl>
-    <ClCompile>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <AdditionalIncludeDirectories>..\..\..;..\..\masmx86;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeaderOutputFile>$(IntDir)zlibstat.pch</PrecompiledHeaderOutputFile>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <ObjectFileName>$(IntDir)</ObjectFileName>
-      <ProgramDataBaseFileName>$(OutDir)</ProgramDataBaseFileName>
-      <WarningLevel>Level3</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </ClCompile>
-    <ResourceCompile>
-      <Culture>0x040c</Culture>
-    </ResourceCompile>
-    <Lib>
-      <AdditionalOptions>/MACHINE:IA64 /NODEFAULTLIB %(AdditionalOptions)</AdditionalOptions>
-      <OutputFile>$(OutDir)zlibstat.lib</OutputFile>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </Lib>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\adler32.c" />
-    <ClCompile Include="..\..\..\compress.c" />
-    <ClCompile Include="..\..\..\crc32.c" />
-    <ClCompile Include="..\..\..\deflate.c" />
-    <ClCompile Include="..\..\..\gzclose.c" />
-    <ClCompile Include="..\..\..\gzlib.c" />
-    <ClCompile Include="..\..\..\gzread.c" />
-    <ClCompile Include="..\..\..\gzwrite.c" />
-    <ClCompile Include="..\..\..\infback.c" />
-    <ClCompile Include="..\..\masmx64\inffas8664.c">
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
-    </ClCompile>
-    <ClCompile Include="..\..\..\inffast.c" />
-    <ClCompile Include="..\..\..\inflate.c" />
-    <ClCompile Include="..\..\..\inftrees.c" />
-    <ClCompile Include="..\..\minizip\ioapi.c" />
-    <ClCompile Include="..\..\..\trees.c" />
-    <ClCompile Include="..\..\..\uncompr.c" />
-    <ClCompile Include="..\..\minizip\unzip.c" />
-    <ClCompile Include="..\..\minizip\zip.c" />
-    <ClCompile Include="..\..\..\zutil.c" />
-  </ItemGroup>
-  <ItemGroup>
-    <ResourceCompile Include="zlib.rc" />
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="zlibvc.def" />
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/zlibstat.vcxproj.filters gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/zlibstat.vcxproj.filters
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/zlibstat.vcxproj.filters	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/zlibstat.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="Source Files">
-      <UniqueIdentifier>{174213f6-7f66-4ae8-a3a8-a1e0a1e6ffdd}</UniqueIdentifier>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\adler32.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\compress.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\crc32.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\deflate.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gzclose.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gzlib.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gzread.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gzwrite.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\infback.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\masmx64\inffas8664.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\inffast.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\inflate.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\inftrees.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\minizip\ioapi.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\trees.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\uncompr.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\minizip\unzip.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\minizip\zip.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\zutil.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <ResourceCompile Include="zlib.rc">
-      <Filter>Source Files</Filter>
-    </ResourceCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="zlibvc.def">
-      <Filter>Source Files</Filter>
-    </None>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/zlibstat.vcxproj.user gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/zlibstat.vcxproj.user
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/zlibstat.vcxproj.user	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/zlibstat.vcxproj.user	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-</Project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/zlibvc.def gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/zlibvc.def
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/zlibvc.def	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/zlibvc.def	1970-01-01 01:00:00.000000000 +0100
@@ -1,139 +0,0 @@
-LIBRARY
-; zlib data compression and ZIP file I/O library
-
-VERSION		1.2.7
-
-EXPORTS
-        adler32                                  @1
-        compress                                 @2
-        crc32                                    @3
-        deflate                                  @4
-        deflateCopy                              @5
-        deflateEnd                               @6
-        deflateInit2_                            @7
-        deflateInit_                             @8
-        deflateParams                            @9
-        deflateReset                             @10
-        deflateSetDictionary                     @11
-        gzclose                                  @12
-        gzdopen                                  @13
-        gzerror                                  @14
-        gzflush                                  @15
-        gzopen                                   @16
-        gzread                                   @17
-        gzwrite                                  @18
-        inflate                                  @19
-        inflateEnd                               @20
-        inflateInit2_                            @21
-        inflateInit_                             @22
-        inflateReset                             @23
-        inflateSetDictionary                     @24
-        inflateSync                              @25
-        uncompress                               @26
-        zlibVersion                              @27
-        gzprintf                                 @28
-        gzputc                                   @29
-        gzgetc                                   @30
-        gzseek                                   @31
-        gzrewind                                 @32
-        gztell                                   @33
-        gzeof                                    @34
-        gzsetparams                              @35
-        zError                                   @36
-        inflateSyncPoint                         @37
-        get_crc_table                            @38
-        compress2                                @39
-        gzputs                                   @40
-        gzgets                                   @41
-        inflateCopy                              @42
-        inflateBackInit_                         @43
-        inflateBack                              @44
-        inflateBackEnd                           @45
-        compressBound                            @46
-        deflateBound                             @47
-        gzclearerr                               @48
-        gzungetc                                 @49
-        zlibCompileFlags                         @50
-        deflatePrime                             @51
-        deflatePending                           @52
-
-        unzOpen                                  @61
-        unzClose                                 @62
-        unzGetGlobalInfo                         @63
-        unzGetCurrentFileInfo                    @64
-        unzGoToFirstFile                         @65
-        unzGoToNextFile                          @66
-        unzOpenCurrentFile                       @67
-        unzReadCurrentFile                       @68
-        unzOpenCurrentFile3                      @69
-        unztell                                  @70
-        unzeof                                   @71
-        unzCloseCurrentFile                      @72
-        unzGetGlobalComment                      @73
-        unzStringFileNameCompare                 @74
-        unzLocateFile                            @75
-        unzGetLocalExtrafield                    @76
-        unzOpen2                                 @77
-        unzOpenCurrentFile2                      @78
-        unzOpenCurrentFilePassword               @79
-
-        zipOpen                                  @80
-        zipOpenNewFileInZip                      @81
-        zipWriteInFileInZip                      @82
-        zipCloseFileInZip                        @83
-        zipClose                                 @84
-        zipOpenNewFileInZip2                     @86
-        zipCloseFileInZipRaw                     @87
-        zipOpen2                                 @88
-        zipOpenNewFileInZip3                     @89
-
-        unzGetFilePos                            @100
-        unzGoToFilePos                           @101
-
-        fill_win32_filefunc                      @110
-
-; zlibwapi v1.2.4 added:
-        fill_win32_filefunc64                   @111
-        fill_win32_filefunc64A                  @112
-        fill_win32_filefunc64W                  @113
-
-        unzOpen64                               @120
-        unzOpen2_64                             @121
-        unzGetGlobalInfo64                      @122
-        unzGetCurrentFileInfo64                 @124
-        unzGetCurrentFileZStreamPos64           @125
-        unztell64                               @126
-        unzGetFilePos64                         @127
-        unzGoToFilePos64                        @128
-
-        zipOpen64                               @130
-        zipOpen2_64                             @131
-        zipOpenNewFileInZip64                   @132
-        zipOpenNewFileInZip2_64                 @133
-        zipOpenNewFileInZip3_64                 @134
-        zipOpenNewFileInZip4_64                 @135
-        zipCloseFileInZipRaw64                  @136
-
-; zlib1 v1.2.4 added:
-        adler32_combine                         @140
-        crc32_combine                           @142
-        deflateSetHeader                        @144
-        deflateTune                             @145
-        gzbuffer                                @146
-        gzclose_r                               @147
-        gzclose_w                               @148
-        gzdirect                                @149
-        gzoffset                                @150
-        inflateGetHeader                        @156
-        inflateMark                             @157
-        inflatePrime                            @158
-        inflateReset2                           @159
-        inflateUndermine                        @160
-
-; zlib1 v1.2.6 added:
-        gzgetc_                                 @161
-        inflateResetKeep                        @163
-        deflateResetKeep                        @164
-
-; zlib1 v1.2.7 added:
-        gzopen_w                                @165
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/zlibvc.sln gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/zlibvc.sln
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/zlibvc.sln	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/zlibvc.sln	1970-01-01 01:00:00.000000000 +0100
@@ -1,135 +0,0 @@
-
-Microsoft Visual Studio Solution File, Format Version 11.00
-# Visual Studio 2010
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "zlibvc", "zlibvc.vcxproj", "{8FD826F8-3739-44E6-8CC8-997122E53B8D}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "zlibstat", "zlibstat.vcxproj", "{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "testzlib", "testzlib.vcxproj", "{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "testzlibdll", "testzlibdll.vcxproj", "{C52F9E7B-498A-42BE-8DB4-85A15694366A}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "minizip", "minizip.vcxproj", "{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "miniunz", "miniunz.vcxproj", "{C52F9E7B-498A-42BE-8DB4-85A15694382A}"
-EndProject
-Global
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|Itanium = Debug|Itanium
-		Debug|Win32 = Debug|Win32
-		Debug|x64 = Debug|x64
-		Release|Itanium = Release|Itanium
-		Release|Win32 = Release|Win32
-		Release|x64 = Release|x64
-		ReleaseWithoutAsm|Itanium = ReleaseWithoutAsm|Itanium
-		ReleaseWithoutAsm|Win32 = ReleaseWithoutAsm|Win32
-		ReleaseWithoutAsm|x64 = ReleaseWithoutAsm|x64
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|Itanium.ActiveCfg = Debug|Itanium
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|Itanium.Build.0 = Debug|Itanium
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|Win32.ActiveCfg = Debug|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|Win32.Build.0 = Debug|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|x64.ActiveCfg = Debug|x64
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|x64.Build.0 = Debug|x64
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|Itanium.ActiveCfg = Release|Itanium
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|Itanium.Build.0 = Release|Itanium
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|Win32.ActiveCfg = Release|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|Win32.Build.0 = Release|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|x64.ActiveCfg = Release|x64
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|x64.Build.0 = Release|x64
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|Itanium.ActiveCfg = ReleaseWithoutAsm|Itanium
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|Itanium.Build.0 = ReleaseWithoutAsm|Itanium
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|Win32.ActiveCfg = ReleaseWithoutAsm|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|Win32.Build.0 = ReleaseWithoutAsm|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|x64.ActiveCfg = ReleaseWithoutAsm|x64
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|x64.Build.0 = ReleaseWithoutAsm|x64
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|Itanium.ActiveCfg = Debug|Itanium
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|Itanium.Build.0 = Debug|Itanium
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|Win32.ActiveCfg = Debug|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|Win32.Build.0 = Debug|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|x64.ActiveCfg = Debug|x64
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|x64.Build.0 = Debug|x64
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|Itanium.ActiveCfg = Release|Itanium
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|Itanium.Build.0 = Release|Itanium
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|Win32.ActiveCfg = Release|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|Win32.Build.0 = Release|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|x64.ActiveCfg = Release|x64
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|x64.Build.0 = Release|x64
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|Itanium.ActiveCfg = ReleaseWithoutAsm|Itanium
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|Itanium.Build.0 = ReleaseWithoutAsm|Itanium
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|Win32.ActiveCfg = ReleaseWithoutAsm|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|Win32.Build.0 = ReleaseWithoutAsm|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|x64.ActiveCfg = ReleaseWithoutAsm|x64
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|x64.Build.0 = ReleaseWithoutAsm|x64
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|Itanium.ActiveCfg = Debug|Itanium
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|Itanium.Build.0 = Debug|Itanium
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|Win32.ActiveCfg = Debug|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|Win32.Build.0 = Debug|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|x64.ActiveCfg = Debug|x64
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|x64.Build.0 = Debug|x64
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|Itanium.ActiveCfg = Release|Itanium
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|Itanium.Build.0 = Release|Itanium
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|Win32.ActiveCfg = Release|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|Win32.Build.0 = Release|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|x64.ActiveCfg = Release|x64
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|x64.Build.0 = Release|x64
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Itanium.ActiveCfg = ReleaseWithoutAsm|Itanium
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Itanium.Build.0 = ReleaseWithoutAsm|Itanium
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Win32.ActiveCfg = ReleaseWithoutAsm|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Win32.Build.0 = ReleaseWithoutAsm|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|x64.ActiveCfg = ReleaseWithoutAsm|x64
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|x64.Build.0 = ReleaseWithoutAsm|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|Itanium.ActiveCfg = Debug|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|Itanium.Build.0 = Debug|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|Win32.ActiveCfg = Debug|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|Win32.Build.0 = Debug|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|x64.ActiveCfg = Debug|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|x64.Build.0 = Debug|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|Itanium.ActiveCfg = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|Itanium.Build.0 = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|Win32.ActiveCfg = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|Win32.Build.0 = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|x64.ActiveCfg = Release|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|x64.Build.0 = Release|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.ReleaseWithoutAsm|Itanium.ActiveCfg = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.ReleaseWithoutAsm|Itanium.Build.0 = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.ReleaseWithoutAsm|Win32.ActiveCfg = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.ReleaseWithoutAsm|x64.ActiveCfg = Release|x64
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|Itanium.ActiveCfg = Debug|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|Itanium.Build.0 = Debug|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|Win32.ActiveCfg = Debug|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|Win32.Build.0 = Debug|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|x64.ActiveCfg = Debug|x64
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|x64.Build.0 = Debug|x64
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|Itanium.ActiveCfg = Release|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|Itanium.Build.0 = Release|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|Win32.ActiveCfg = Release|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|Win32.Build.0 = Release|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|x64.ActiveCfg = Release|x64
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|x64.Build.0 = Release|x64
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Itanium.ActiveCfg = Release|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Itanium.Build.0 = Release|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Win32.ActiveCfg = Release|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|x64.ActiveCfg = Release|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|Itanium.ActiveCfg = Debug|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|Itanium.Build.0 = Debug|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|Win32.ActiveCfg = Debug|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|Win32.Build.0 = Debug|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|x64.ActiveCfg = Debug|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|x64.Build.0 = Debug|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|Itanium.ActiveCfg = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|Itanium.Build.0 = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|Win32.ActiveCfg = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|Win32.Build.0 = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|x64.ActiveCfg = Release|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|x64.Build.0 = Release|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm|Itanium.ActiveCfg = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm|Itanium.Build.0 = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm|Win32.ActiveCfg = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm|x64.ActiveCfg = Release|x64
-	EndGlobalSection
-	GlobalSection(SolutionProperties) = preSolution
-		HideSolutionNode = FALSE
-	EndGlobalSection
-EndGlobal
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/zlibvc.vcxproj gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/zlibvc.vcxproj
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/zlibvc.vcxproj	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/zlibvc.vcxproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,681 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Itanium">
-      <Configuration>Debug</Configuration>
-      <Platform>Itanium</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="ReleaseWithoutAsm|Itanium">
-      <Configuration>ReleaseWithoutAsm</Configuration>
-      <Platform>Itanium</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="ReleaseWithoutAsm|Win32">
-      <Configuration>ReleaseWithoutAsm</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="ReleaseWithoutAsm|x64">
-      <Configuration>ReleaseWithoutAsm</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Itanium">
-      <Configuration>Release</Configuration>
-      <Platform>Itanium</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{8FD826F8-3739-44E6-8CC8-997122E53B8D}</ProjectGuid>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <UseOfMfc>false</UseOfMfc>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup>
-    <_ProjectFileVersion>10.0.30128.1</_ProjectFileVersion>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">x86\ZlibDll$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">x86\ZlibDll$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">x86\ZlibDll$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">x86\ZlibDll$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">false</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">x86\ZlibDll$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">x86\ZlibDll$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">x64\ZlibDll$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">x64\ZlibDll$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">ia64\ZlibDll$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">ia64\ZlibDll$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">true</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'">x64\ZlibDll$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'">x64\ZlibDll$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'">false</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">ia64\ZlibDll$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">ia64\ZlibDll$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">false</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">x64\ZlibDll$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">x64\ZlibDll$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</GenerateManifest>
-    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">ia64\ZlibDll$(Configuration)\</OutDir>
-    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">ia64\ZlibDll$(Configuration)\Tmp\</IntDir>
-    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">false</LinkIncremental>
-    <GenerateManifest Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">false</GenerateManifest>
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" />
-    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
-    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
-    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">zlibwapi</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">zlibwapi</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">zlibwapi</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">zlibwapi</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'">zlibwapi</TargetName>
-    <TargetName Condition="'$(Configuration)|$(Platform)'=='Release|x64'">zlibwapi</TargetName>
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <Midl>
-      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MkTypLibCompatible>true</MkTypLibCompatible>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <TargetEnvironment>Win32</TargetEnvironment>
-      <TypeLibraryName>$(OutDir)zlibvc.tlb</TypeLibraryName>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..;..\..\masmx86;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ZLIB_WINAPI;ASMV;ASMINF;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <PrecompiledHeaderOutputFile>$(IntDir)zlibvc.pch</PrecompiledHeaderOutputFile>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <ObjectFileName>$(IntDir)</ObjectFileName>
-      <ProgramDataBaseFileName>$(OutDir)</ProgramDataBaseFileName>
-      <BrowseInformation>
-      </BrowseInformation>
-      <WarningLevel>Level3</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x040c</Culture>
-    </ResourceCompile>
-    <Link>
-      <AdditionalOptions>/MACHINE:I386 %(AdditionalOptions)</AdditionalOptions>
-      <AdditionalDependencies>..\..\masmx86\match686.obj;..\..\masmx86\inffas32.obj;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)zlibwapi.dll</OutputFile>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <ModuleDefinitionFile>.\zlibvc.def</ModuleDefinitionFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <ProgramDatabaseFile>$(OutDir)zlibwapi.pdb</ProgramDatabaseFile>
-      <GenerateMapFile>true</GenerateMapFile>
-      <MapFileName>$(OutDir)zlibwapi.map</MapFileName>
-      <SubSystem>Windows</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <ImportLibrary>$(OutDir)zlibwapi.lib</ImportLibrary>
-    </Link>
-    <PreBuildEvent>
-      <Command>cd ..\..\masmx86
-bld_ml32.bat</Command>
-    </PreBuildEvent>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">
-    <Midl>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MkTypLibCompatible>true</MkTypLibCompatible>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <TargetEnvironment>Win32</TargetEnvironment>
-      <TypeLibraryName>$(OutDir)zlibvc.tlb</TypeLibraryName>
-    </Midl>
-    <ClCompile>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <AdditionalIncludeDirectories>..\..\..;..\..\masmx86;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ZLIB_WINAPI;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeaderOutputFile>$(IntDir)zlibvc.pch</PrecompiledHeaderOutputFile>
-      <AssemblerOutput>All</AssemblerOutput>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <ObjectFileName>$(IntDir)</ObjectFileName>
-      <ProgramDataBaseFileName>$(OutDir)</ProgramDataBaseFileName>
-      <BrowseInformation>
-      </BrowseInformation>
-      <WarningLevel>Level3</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x040c</Culture>
-    </ResourceCompile>
-    <Link>
-      <AdditionalOptions>/MACHINE:I386 %(AdditionalOptions)</AdditionalOptions>
-      <OutputFile>$(OutDir)zlibwapi.dll</OutputFile>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
-      <ModuleDefinitionFile>.\zlibvc.def</ModuleDefinitionFile>
-      <ProgramDatabaseFile>$(OutDir)zlibwapi.pdb</ProgramDatabaseFile>
-      <GenerateMapFile>true</GenerateMapFile>
-      <MapFileName>$(OutDir)zlibwapi.map</MapFileName>
-      <SubSystem>Windows</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <ImportLibrary>$(OutDir)zlibwapi.lib</ImportLibrary>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <Midl>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MkTypLibCompatible>true</MkTypLibCompatible>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <TargetEnvironment>Win32</TargetEnvironment>
-      <TypeLibraryName>$(OutDir)zlibvc.tlb</TypeLibraryName>
-    </Midl>
-    <ClCompile>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <AdditionalIncludeDirectories>..\..\..;..\..\masmx86;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ZLIB_WINAPI;ASMV;ASMINF;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeaderOutputFile>$(IntDir)zlibvc.pch</PrecompiledHeaderOutputFile>
-      <AssemblerOutput>All</AssemblerOutput>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <ObjectFileName>$(IntDir)</ObjectFileName>
-      <ProgramDataBaseFileName>$(OutDir)</ProgramDataBaseFileName>
-      <BrowseInformation>
-      </BrowseInformation>
-      <WarningLevel>Level3</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x040c</Culture>
-    </ResourceCompile>
-    <Link>
-      <AdditionalOptions>/MACHINE:I386 %(AdditionalOptions)</AdditionalOptions>
-      <AdditionalDependencies>..\..\masmx86\match686.obj;..\..\masmx86\inffas32.obj;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)zlibwapi.dll</OutputFile>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
-      <ModuleDefinitionFile>.\zlibvc.def</ModuleDefinitionFile>
-      <ProgramDatabaseFile>$(OutDir)zlibwapi.pdb</ProgramDatabaseFile>
-      <GenerateMapFile>true</GenerateMapFile>
-      <MapFileName>$(OutDir)zlibwapi.map</MapFileName>
-      <SubSystem>Windows</SubSystem>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <DataExecutionPrevention>
-      </DataExecutionPrevention>
-      <ImportLibrary>$(OutDir)zlibwapi.lib</ImportLibrary>
-    </Link>
-    <PreBuildEvent>
-      <Command>cd ..\..\masmx86
-bld_ml32.bat</Command>
-    </PreBuildEvent>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <Midl>
-      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MkTypLibCompatible>true</MkTypLibCompatible>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <TargetEnvironment>X64</TargetEnvironment>
-      <TypeLibraryName>$(OutDir)zlibvc.tlb</TypeLibraryName>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..;..\..\masmx86;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ZLIB_WINAPI;ASMV;ASMINF;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <PrecompiledHeaderOutputFile>$(IntDir)zlibvc.pch</PrecompiledHeaderOutputFile>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <ObjectFileName>$(IntDir)</ObjectFileName>
-      <ProgramDataBaseFileName>$(OutDir)</ProgramDataBaseFileName>
-      <BrowseInformation>
-      </BrowseInformation>
-      <WarningLevel>Level3</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x040c</Culture>
-    </ResourceCompile>
-    <Link>
-      <AdditionalDependencies>..\..\masmx64\gvmat64.obj;..\..\masmx64\inffasx64.obj;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)zlibwapi.dll</OutputFile>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <ModuleDefinitionFile>.\zlibvc.def</ModuleDefinitionFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <ProgramDatabaseFile>$(OutDir)zlibwapi.pdb</ProgramDatabaseFile>
-      <GenerateMapFile>true</GenerateMapFile>
-      <MapFileName>$(OutDir)zlibwapi.map</MapFileName>
-      <SubSystem>Windows</SubSystem>
-      <ImportLibrary>$(OutDir)zlibwapi.lib</ImportLibrary>
-      <TargetMachine>MachineX64</TargetMachine>
-    </Link>
-    <PreBuildEvent>
-      <Command>cd ..\..\contrib\masmx64
-bld_ml64.bat</Command>
-    </PreBuildEvent>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">
-    <Midl>
-      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MkTypLibCompatible>true</MkTypLibCompatible>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <TargetEnvironment>Itanium</TargetEnvironment>
-      <TypeLibraryName>$(OutDir)zlibvc.tlb</TypeLibraryName>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>..\..\..;..\..\masmx86;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ZLIB_WINAPI;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <PrecompiledHeaderOutputFile>$(IntDir)zlibvc.pch</PrecompiledHeaderOutputFile>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <ObjectFileName>$(IntDir)</ObjectFileName>
-      <ProgramDataBaseFileName>$(OutDir)</ProgramDataBaseFileName>
-      <BrowseInformation>
-      </BrowseInformation>
-      <WarningLevel>Level3</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x040c</Culture>
-    </ResourceCompile>
-    <Link>
-      <OutputFile>$(OutDir)zlibwapi.dll</OutputFile>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <ModuleDefinitionFile>.\zlibvc.def</ModuleDefinitionFile>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <ProgramDatabaseFile>$(OutDir)zlibwapi.pdb</ProgramDatabaseFile>
-      <GenerateMapFile>true</GenerateMapFile>
-      <MapFileName>$(OutDir)zlibwapi.map</MapFileName>
-      <SubSystem>Windows</SubSystem>
-      <ImportLibrary>$(OutDir)zlibwapi.lib</ImportLibrary>
-      <TargetMachine>MachineIA64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|x64'">
-    <Midl>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MkTypLibCompatible>true</MkTypLibCompatible>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <TargetEnvironment>X64</TargetEnvironment>
-      <TypeLibraryName>$(OutDir)zlibvc.tlb</TypeLibraryName>
-    </Midl>
-    <ClCompile>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <AdditionalIncludeDirectories>..\..\..;..\..\masmx86;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ZLIB_WINAPI;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeaderOutputFile>$(IntDir)zlibvc.pch</PrecompiledHeaderOutputFile>
-      <AssemblerOutput>All</AssemblerOutput>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <ObjectFileName>$(IntDir)</ObjectFileName>
-      <ProgramDataBaseFileName>$(OutDir)</ProgramDataBaseFileName>
-      <BrowseInformation>
-      </BrowseInformation>
-      <WarningLevel>Level3</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x040c</Culture>
-    </ResourceCompile>
-    <Link>
-      <OutputFile>$(OutDir)zlibwapi.dll</OutputFile>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
-      <ModuleDefinitionFile>.\zlibvc.def</ModuleDefinitionFile>
-      <ProgramDatabaseFile>$(OutDir)zlibwapi.pdb</ProgramDatabaseFile>
-      <GenerateMapFile>true</GenerateMapFile>
-      <MapFileName>$(OutDir)zlibwapi.map</MapFileName>
-      <SubSystem>Windows</SubSystem>
-      <ImportLibrary>$(OutDir)zlibwapi.lib</ImportLibrary>
-      <TargetMachine>MachineX64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">
-    <Midl>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MkTypLibCompatible>true</MkTypLibCompatible>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <TargetEnvironment>Itanium</TargetEnvironment>
-      <TypeLibraryName>$(OutDir)zlibvc.tlb</TypeLibraryName>
-    </Midl>
-    <ClCompile>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <AdditionalIncludeDirectories>..\..\..;..\..\masmx86;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ZLIB_WINAPI;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeaderOutputFile>$(IntDir)zlibvc.pch</PrecompiledHeaderOutputFile>
-      <AssemblerOutput>All</AssemblerOutput>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <ObjectFileName>$(IntDir)</ObjectFileName>
-      <ProgramDataBaseFileName>$(OutDir)</ProgramDataBaseFileName>
-      <BrowseInformation>
-      </BrowseInformation>
-      <WarningLevel>Level3</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x040c</Culture>
-    </ResourceCompile>
-    <Link>
-      <OutputFile>$(OutDir)zlibwapi.dll</OutputFile>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
-      <ModuleDefinitionFile>.\zlibvc.def</ModuleDefinitionFile>
-      <ProgramDatabaseFile>$(OutDir)zlibwapi.pdb</ProgramDatabaseFile>
-      <GenerateMapFile>true</GenerateMapFile>
-      <MapFileName>$(OutDir)zlibwapi.map</MapFileName>
-      <SubSystem>Windows</SubSystem>
-      <ImportLibrary>$(OutDir)zlibwapi.lib</ImportLibrary>
-      <TargetMachine>MachineIA64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <Midl>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MkTypLibCompatible>true</MkTypLibCompatible>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <TargetEnvironment>X64</TargetEnvironment>
-      <TypeLibraryName>$(OutDir)zlibvc.tlb</TypeLibraryName>
-    </Midl>
-    <ClCompile>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <AdditionalIncludeDirectories>..\..\..;..\..\masmx86;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ZLIB_WINAPI;ASMV;ASMINF;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeaderOutputFile>$(IntDir)zlibvc.pch</PrecompiledHeaderOutputFile>
-      <AssemblerOutput>All</AssemblerOutput>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <ObjectFileName>$(IntDir)</ObjectFileName>
-      <ProgramDataBaseFileName>$(OutDir)</ProgramDataBaseFileName>
-      <BrowseInformation>
-      </BrowseInformation>
-      <WarningLevel>Level3</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x040c</Culture>
-    </ResourceCompile>
-    <Link>
-      <AdditionalDependencies>..\..\masmx64\gvmat64.obj;..\..\masmx64\inffasx64.obj;%(AdditionalDependencies)</AdditionalDependencies>
-      <OutputFile>$(OutDir)zlibwapi.dll</OutputFile>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
-      <ModuleDefinitionFile>.\zlibvc.def</ModuleDefinitionFile>
-      <ProgramDatabaseFile>$(OutDir)zlibwapi.pdb</ProgramDatabaseFile>
-      <GenerateMapFile>true</GenerateMapFile>
-      <MapFileName>$(OutDir)zlibwapi.map</MapFileName>
-      <SubSystem>Windows</SubSystem>
-      <ImportLibrary>$(OutDir)zlibwapi.lib</ImportLibrary>
-      <TargetMachine>MachineX64</TargetMachine>
-    </Link>
-    <PreBuildEvent>
-      <Command>cd ..\..\masmx64
-bld_ml64.bat</Command>
-    </PreBuildEvent>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">
-    <Midl>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MkTypLibCompatible>true</MkTypLibCompatible>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <TargetEnvironment>Itanium</TargetEnvironment>
-      <TypeLibraryName>$(OutDir)zlibvc.tlb</TypeLibraryName>
-    </Midl>
-    <ClCompile>
-      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
-      <AdditionalIncludeDirectories>..\..\..;..\..\masmx86;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ZLIB_WINAPI;WIN64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <PrecompiledHeaderOutputFile>$(IntDir)zlibvc.pch</PrecompiledHeaderOutputFile>
-      <AssemblerOutput>All</AssemblerOutput>
-      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
-      <ObjectFileName>$(IntDir)</ObjectFileName>
-      <ProgramDataBaseFileName>$(OutDir)</ProgramDataBaseFileName>
-      <BrowseInformation>
-      </BrowseInformation>
-      <WarningLevel>Level3</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x040c</Culture>
-    </ResourceCompile>
-    <Link>
-      <OutputFile>$(OutDir)zlibwapi.dll</OutputFile>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
-      <ModuleDefinitionFile>.\zlibvc.def</ModuleDefinitionFile>
-      <ProgramDatabaseFile>$(OutDir)zlibwapi.pdb</ProgramDatabaseFile>
-      <GenerateMapFile>true</GenerateMapFile>
-      <MapFileName>$(OutDir)zlibwapi.map</MapFileName>
-      <SubSystem>Windows</SubSystem>
-      <ImportLibrary>$(OutDir)zlibwapi.lib</ImportLibrary>
-      <TargetMachine>MachineIA64</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\adler32.c" />
-    <ClCompile Include="..\..\..\compress.c" />
-    <ClCompile Include="..\..\..\crc32.c" />
-    <ClCompile Include="..\..\..\deflate.c" />
-    <ClCompile Include="..\..\..\gzclose.c" />
-    <ClCompile Include="..\..\..\gzlib.c" />
-    <ClCompile Include="..\..\..\gzread.c" />
-    <ClCompile Include="..\..\..\gzwrite.c" />
-    <ClCompile Include="..\..\..\infback.c" />
-    <ClCompile Include="..\..\masmx64\inffas8664.c">
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Itanium'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Itanium'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='ReleaseWithoutAsm|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
-    </ClCompile>
-    <ClCompile Include="..\..\..\inffast.c" />
-    <ClCompile Include="..\..\..\inflate.c" />
-    <ClCompile Include="..\..\..\inftrees.c" />
-    <ClCompile Include="..\..\minizip\ioapi.c" />
-    <ClCompile Include="..\..\minizip\iowin32.c" />
-    <ClCompile Include="..\..\..\trees.c" />
-    <ClCompile Include="..\..\..\uncompr.c" />
-    <ClCompile Include="..\..\minizip\unzip.c">
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">ZLIB_INTERNAL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">ZLIB_INTERNAL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|x64'">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">ZLIB_INTERNAL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-    </ClCompile>
-    <ClCompile Include="..\..\minizip\zip.c">
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Itanium'">ZLIB_INTERNAL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">ZLIB_INTERNAL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|x64'">%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">ZLIB_INTERNAL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-    </ClCompile>
-    <ClCompile Include="..\..\..\zutil.c" />
-  </ItemGroup>
-  <ItemGroup>
-    <ResourceCompile Include="zlib.rc" />
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="zlibvc.def" />
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\..\..\deflate.h" />
-    <ClInclude Include="..\..\..\infblock.h" />
-    <ClInclude Include="..\..\..\infcodes.h" />
-    <ClInclude Include="..\..\..\inffast.h" />
-    <ClInclude Include="..\..\..\inftrees.h" />
-    <ClInclude Include="..\..\..\infutil.h" />
-    <ClInclude Include="..\..\..\zconf.h" />
-    <ClInclude Include="..\..\..\zlib.h" />
-    <ClInclude Include="..\..\..\zutil.h" />
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/zlibvc.vcxproj.filters gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/zlibvc.vcxproj.filters
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/zlibvc.vcxproj.filters	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/zlibvc.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
@@ -1,118 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="Source Files">
-      <UniqueIdentifier>{07934a85-8b61-443d-a0ee-b2eedb74f3cd}</UniqueIdentifier>
-      <Extensions>cpp;c;cxx;rc;def;r;odl;hpj;bat;for;f90</Extensions>
-    </Filter>
-    <Filter Include="Header Files">
-      <UniqueIdentifier>{1d99675b-433d-4a21-9e50-ed4ab8b19762}</UniqueIdentifier>
-      <Extensions>h;hpp;hxx;hm;inl;fi;fd</Extensions>
-    </Filter>
-    <Filter Include="Resource Files">
-      <UniqueIdentifier>{431c0958-fa71-44d0-9084-2d19d100c0cc}</UniqueIdentifier>
-      <Extensions>ico;cur;bmp;dlg;rc2;rct;bin;cnt;rtf;gif;jpg;jpeg;jpe</Extensions>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\..\adler32.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\compress.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\crc32.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\deflate.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gzclose.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gzlib.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gzread.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\gzwrite.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\infback.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\masmx64\inffas8664.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\inffast.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\inflate.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\inftrees.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\minizip\ioapi.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\minizip\iowin32.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\trees.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\uncompr.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\minizip\unzip.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\minizip\zip.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\..\zutil.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <ResourceCompile Include="zlib.rc">
-      <Filter>Source Files</Filter>
-    </ResourceCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="zlibvc.def">
-      <Filter>Source Files</Filter>
-    </None>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\..\..\deflate.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\infblock.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\infcodes.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\inffast.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\inftrees.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\infutil.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\zconf.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\zlib.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\..\zutil.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc10/zlibvc.vcxproj.user gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/zlibvc.vcxproj.user
--- gcc-4.8.1/zlib/contrib/vstudio/vc10/zlibvc.vcxproj.user	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc10/zlibvc.vcxproj.user	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-</Project>
\ No newline at end of file
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc9/miniunz.vcproj gcc-4.8.1-ppc/zlib/contrib/vstudio/vc9/miniunz.vcproj
--- gcc-4.8.1/zlib/contrib/vstudio/vc9/miniunz.vcproj	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc9/miniunz.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,565 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="miniunz"
-	ProjectGUID="{C52F9E7B-498A-42BE-8DB4-85A15694382A}"
-	Keyword="Win32Proj"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-		<Platform
-			Name="x64"
-		/>
-		<Platform
-			Name="Itanium"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="x86\MiniUnzip$(ConfigurationName)"
-			IntermediateDirectory="x86\MiniUnzip$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x86\ZlibDllDebug\zlibwapi.lib"
-				OutputFile="$(OutDir)/miniunz.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/miniunz.pdb"
-				SubSystem="1"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="x86\MiniUnzip$(ConfigurationName)"
-			IntermediateDirectory="x86\MiniUnzip$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x86\ZlibDllRelease\zlibwapi.lib"
-				OutputFile="$(OutDir)/miniunz.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="x64\MiniUnzip$(ConfigurationName)"
-			IntermediateDirectory="x64\MiniUnzip$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x64\ZlibDllDebug\zlibwapi.lib"
-				OutputFile="$(OutDir)/miniunz.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/miniunz.pdb"
-				SubSystem="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Itanium"
-			OutputDirectory="ia64\MiniUnzip$(ConfigurationName)"
-			IntermediateDirectory="ia64\MiniUnzip$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="ia64\ZlibDllDebug\zlibwapi.lib"
-				OutputFile="$(OutDir)/miniunz.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/miniunz.pdb"
-				SubSystem="1"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="x64\MiniUnzip$(ConfigurationName)"
-			IntermediateDirectory="x64\MiniUnzip$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x64\ZlibDllRelease\zlibwapi.lib"
-				OutputFile="$(OutDir)/miniunz.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Itanium"
-			OutputDirectory="ia64\MiniUnzip$(ConfigurationName)"
-			IntermediateDirectory="ia64\MiniUnzip$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="ia64\ZlibDllRelease\zlibwapi.lib"
-				OutputFile="$(OutDir)/miniunz.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm"
-			>
-			<File
-				RelativePath="..\..\minizip\miniunz.c"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc"
-			>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc9/minizip.vcproj gcc-4.8.1-ppc/zlib/contrib/vstudio/vc9/minizip.vcproj
--- gcc-4.8.1/zlib/contrib/vstudio/vc9/minizip.vcproj	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc9/minizip.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,562 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="minizip"
-	ProjectGUID="{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}"
-	Keyword="Win32Proj"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-		<Platform
-			Name="x64"
-		/>
-		<Platform
-			Name="Itanium"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="x86\MiniZip$(ConfigurationName)"
-			IntermediateDirectory="x86\MiniZip$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x86\ZlibDllDebug\zlibwapi.lib"
-				OutputFile="$(OutDir)/minizip.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/minizip.pdb"
-				SubSystem="1"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="x86\MiniZip$(ConfigurationName)"
-			IntermediateDirectory="x86\MiniZip$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x86\ZlibDllRelease\zlibwapi.lib"
-				OutputFile="$(OutDir)/minizip.exe"
-				LinkIncremental="1"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="x64\$(ConfigurationName)"
-			IntermediateDirectory="x64\$(ConfigurationName)"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x64\ZlibDllDebug\zlibwapi.lib"
-				OutputFile="$(OutDir)/minizip.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/minizip.pdb"
-				SubSystem="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Itanium"
-			OutputDirectory="ia64\$(ConfigurationName)"
-			IntermediateDirectory="ia64\$(ConfigurationName)"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="ia64\ZlibDllDebug\zlibwapi.lib"
-				OutputFile="$(OutDir)/minizip.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/minizip.pdb"
-				SubSystem="1"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="x64\$(ConfigurationName)"
-			IntermediateDirectory="x64\$(ConfigurationName)"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x64\ZlibDllRelease\zlibwapi.lib"
-				OutputFile="$(OutDir)/minizip.exe"
-				LinkIncremental="1"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Itanium"
-			OutputDirectory="ia64\$(ConfigurationName)"
-			IntermediateDirectory="ia64\$(ConfigurationName)"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="ia64\ZlibDllRelease\zlibwapi.lib"
-				OutputFile="$(OutDir)/minizip.exe"
-				LinkIncremental="1"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm"
-			>
-			<File
-				RelativePath="..\..\minizip\minizip.c"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc"
-			>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc9/testzlibdll.vcproj gcc-4.8.1-ppc/zlib/contrib/vstudio/vc9/testzlibdll.vcproj
--- gcc-4.8.1/zlib/contrib/vstudio/vc9/testzlibdll.vcproj	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc9/testzlibdll.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,565 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="TestZlibDll"
-	ProjectGUID="{C52F9E7B-498A-42BE-8DB4-85A15694366A}"
-	Keyword="Win32Proj"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-		<Platform
-			Name="x64"
-		/>
-		<Platform
-			Name="Itanium"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="x86\TestZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x86\TestZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x86\ZlibDllDebug\zlibwapi.lib"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/testzlib.pdb"
-				SubSystem="1"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="x86\TestZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x86\TestZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x86\ZlibDllRelease\zlibwapi.lib"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="x64\TestZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x64\TestZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x64\ZlibDllDebug\zlibwapi.lib"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/testzlib.pdb"
-				SubSystem="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Itanium"
-			OutputDirectory="ia64\TestZlibDll$(ConfigurationName)"
-			IntermediateDirectory="ia64\TestZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="ia64\ZlibDllDebug\zlibwapi.lib"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/testzlib.pdb"
-				SubSystem="1"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="x64\TestZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x64\TestZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x64\ZlibDllRelease\zlibwapi.lib"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Itanium"
-			OutputDirectory="ia64\TestZlibDll$(ConfigurationName)"
-			IntermediateDirectory="ia64\TestZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="ia64\ZlibDllRelease\zlibwapi.lib"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm"
-			>
-			<File
-				RelativePath="..\..\testzlib\testzlib.c"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc"
-			>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc9/testzlib.vcproj gcc-4.8.1-ppc/zlib/contrib/vstudio/vc9/testzlib.vcproj
--- gcc-4.8.1/zlib/contrib/vstudio/vc9/testzlib.vcproj	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc9/testzlib.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,852 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9,00"
-	Name="testzlib"
-	ProjectGUID="{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}"
-	RootNamespace="testzlib"
-	Keyword="Win32Proj"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-		<Platform
-			Name="x64"
-		/>
-		<Platform
-			Name="Itanium"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="x86\TestZlib$(ConfigurationName)"
-			IntermediateDirectory="x86\TestZlib$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="ASMV;ASMINF;WIN32;ZLIB_WINAPI;_DEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerOutput="4"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="..\..\masmx86\match686.obj ..\..\masmx86\inffas32.obj"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/testzlib.pdb"
-				SubSystem="1"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="x64\TestZlib$(ConfigurationName)"
-			IntermediateDirectory="x64\TestZlib$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="ASMV;ASMINF;WIN32;ZLIB_WINAPI;_DEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				AssemblerListingLocation="$(IntDir)\"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="..\..\masmx64\gvmat64.obj ..\..\masmx64\inffasx64.obj"
-				GenerateManifest="false"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Itanium"
-			OutputDirectory="ia64\TestZlib$(ConfigurationName)"
-			IntermediateDirectory="ia64\TestZlib$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="ZLIB_WINAPI;_DEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;WIN64"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerOutput="4"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/testzlib.pdb"
-				SubSystem="1"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|Win32"
-			OutputDirectory="x86\TestZlib$(ConfigurationName)"
-			IntermediateDirectory="x86\TestZlib$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			CharacterSet="2"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|x64"
-			OutputDirectory="x64\TestZlib$(ConfigurationName)"
-			IntermediateDirectory="x64\TestZlib$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				AssemblerListingLocation="$(IntDir)\"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies=""
-				GenerateManifest="false"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|Itanium"
-			OutputDirectory="ia64\TestZlib$(ConfigurationName)"
-			IntermediateDirectory="ia64\TestZlib$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			CharacterSet="2"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;WIN64"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="x86\TestZlib$(ConfigurationName)"
-			IntermediateDirectory="x86\TestZlib$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			CharacterSet="2"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="ASMV;ASMINF;WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="..\..\masmx86\match686.obj ..\..\masmx86\inffas32.obj"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="x64\TestZlib$(ConfigurationName)"
-			IntermediateDirectory="x64\TestZlib$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="ASMV;ASMINF;WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				AssemblerListingLocation="$(IntDir)\"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="..\..\masmx64\gvmat64.obj ..\..\masmx64\inffasx64.obj"
-				GenerateManifest="false"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Itanium"
-			OutputDirectory="ia64\TestZlib$(ConfigurationName)"
-			IntermediateDirectory="ia64\TestZlib$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			CharacterSet="2"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;WIN64"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm"
-			>
-			<File
-				RelativePath="..\..\..\adler32.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\compress.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\crc32.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\deflate.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\infback.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\masmx64\inffas8664.c"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\..\..\inffast.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\inflate.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\inftrees.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\testzlib\testzlib.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\trees.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\uncompr.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\zutil.c"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc"
-			>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc9/zlib.rc gcc-4.8.1-ppc/zlib/contrib/vstudio/vc9/zlib.rc
--- gcc-4.8.1/zlib/contrib/vstudio/vc9/zlib.rc	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc9/zlib.rc	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-#include <windows.h>
-
-#define IDR_VERSION1  1
-IDR_VERSION1	VERSIONINFO	MOVEABLE IMPURE LOADONCALL DISCARDABLE
-  FILEVERSION	 1.2.7,0
-  PRODUCTVERSION 1.2.7,0
-  FILEFLAGSMASK	VS_FFI_FILEFLAGSMASK
-  FILEFLAGS	0
-  FILEOS	VOS_DOS_WINDOWS32
-  FILETYPE	VFT_DLL
-  FILESUBTYPE	0	// not used
-BEGIN
-  BLOCK "StringFileInfo"
-  BEGIN
-    BLOCK "040904E4"
-    //language ID = U.S. English, char set = Windows, Multilingual
-
-    BEGIN
-      VALUE "FileDescription", "zlib data compression and ZIP file I/O library\0"
-      VALUE "FileVersion",	"1.2.7\0"
-      VALUE "InternalName",	"zlib\0"
-      VALUE "OriginalFilename",	"zlib.dll\0"
-      VALUE "ProductName",	"ZLib.DLL\0"
-      VALUE "Comments","DLL support by Alessandro Iacopetti & Gilles Vollant\0"
-      VALUE "LegalCopyright", "(C) 1995-2012 Jean-loup Gailly & Mark Adler\0"
-    END
-  END
-  BLOCK "VarFileInfo"
-  BEGIN
-    VALUE "Translation", 0x0409, 1252
-  END
-END
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc9/zlibstat.vcproj gcc-4.8.1-ppc/zlib/contrib/vstudio/vc9/zlibstat.vcproj
--- gcc-4.8.1/zlib/contrib/vstudio/vc9/zlibstat.vcproj	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc9/zlibstat.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,835 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9,00"
-	Name="zlibstat"
-	ProjectGUID="{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-		<Platform
-			Name="x64"
-		/>
-		<Platform
-			Name="Itanium"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="x86\ZlibStat$(ConfigurationName)"
-			IntermediateDirectory="x86\ZlibStat$(ConfigurationName)\Tmp"
-			ConfigurationType="4"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS"
-				ExceptionHandling="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				PrecompiledHeaderFile="$(IntDir)/zlibstat.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="1"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/MACHINE:X86 /NODEFAULTLIB"
-				OutputFile="$(OutDir)\zlibstat.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="x64\ZlibStat$(ConfigurationName)"
-			IntermediateDirectory="x64\ZlibStat$(ConfigurationName)\Tmp"
-			ConfigurationType="4"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;WIN64"
-				ExceptionHandling="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				PrecompiledHeaderFile="$(IntDir)/zlibstat.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="1"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/MACHINE:AMD64 /NODEFAULTLIB"
-				OutputFile="$(OutDir)\zlibstat.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Itanium"
-			OutputDirectory="ia64\ZlibStat$(ConfigurationName)"
-			IntermediateDirectory="ia64\ZlibStat$(ConfigurationName)\Tmp"
-			ConfigurationType="4"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;WIN64"
-				ExceptionHandling="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				PrecompiledHeaderFile="$(IntDir)/zlibstat.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="1"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/MACHINE:IA64 /NODEFAULTLIB"
-				OutputFile="$(OutDir)\zlibstat.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="x86\ZlibStat$(ConfigurationName)"
-			IntermediateDirectory="x86\ZlibStat$(ConfigurationName)\Tmp"
-			ConfigurationType="4"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ASMV;ASMINF"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibstat.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/MACHINE:X86 /NODEFAULTLIB"
-				AdditionalDependencies="..\..\masmx86\match686.obj ..\..\masmx86\inffas32.obj "
-				OutputFile="$(OutDir)\zlibstat.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="x64\ZlibStat$(ConfigurationName)"
-			IntermediateDirectory="x64\ZlibStat$(ConfigurationName)\Tmp"
-			ConfigurationType="4"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ASMV;ASMINF;WIN64"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibstat.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/MACHINE:AMD64 /NODEFAULTLIB"
-				AdditionalDependencies="..\..\masmx64\gvmat64.obj ..\..\masmx64\inffasx64.obj "
-				OutputFile="$(OutDir)\zlibstat.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Itanium"
-			OutputDirectory="ia64\ZlibStat$(ConfigurationName)"
-			IntermediateDirectory="ia64\ZlibStat$(ConfigurationName)\Tmp"
-			ConfigurationType="4"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;WIN64"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibstat.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/MACHINE:IA64 /NODEFAULTLIB"
-				OutputFile="$(OutDir)\zlibstat.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|Win32"
-			OutputDirectory="x86\ZlibStat$(ConfigurationName)"
-			IntermediateDirectory="x86\ZlibStat$(ConfigurationName)\Tmp"
-			ConfigurationType="4"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibstat.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/MACHINE:X86 /NODEFAULTLIB"
-				OutputFile="$(OutDir)\zlibstat.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|x64"
-			OutputDirectory="x64\ZlibStat$(ConfigurationName)"
-			IntermediateDirectory="x64\ZlibStat$(ConfigurationName)\Tmp"
-			ConfigurationType="4"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;WIN64"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibstat.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/MACHINE:AMD64 /NODEFAULTLIB"
-				OutputFile="$(OutDir)\zlibstat.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|Itanium"
-			OutputDirectory="ia64\ZlibStat$(ConfigurationName)"
-			IntermediateDirectory="ia64\ZlibStat$(ConfigurationName)\Tmp"
-			ConfigurationType="4"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;WIN64"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibstat.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/MACHINE:IA64 /NODEFAULTLIB"
-				OutputFile="$(OutDir)\zlibstat.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			>
-			<File
-				RelativePath="..\..\..\adler32.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\compress.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\crc32.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\deflate.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\gzclose.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\gzguts.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\gzlib.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\gzread.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\gzwrite.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\infback.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\masmx64\inffas8664.c"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\..\..\inffast.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\inflate.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\inftrees.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\minizip\ioapi.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\trees.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\uncompr.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\minizip\unzip.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\minizip\zip.c"
-				>
-			</File>
-			<File
-				RelativePath=".\zlib.rc"
-				>
-			</File>
-			<File
-				RelativePath=".\zlibvc.def"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\zutil.c"
-				>
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc9/zlibvc.def gcc-4.8.1-ppc/zlib/contrib/vstudio/vc9/zlibvc.def
--- gcc-4.8.1/zlib/contrib/vstudio/vc9/zlibvc.def	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc9/zlibvc.def	1970-01-01 01:00:00.000000000 +0100
@@ -1,139 +0,0 @@
-LIBRARY
-; zlib data compression and ZIP file I/O library
-
-VERSION		1.2.7
-
-EXPORTS
-        adler32                                  @1
-        compress                                 @2
-        crc32                                    @3
-        deflate                                  @4
-        deflateCopy                              @5
-        deflateEnd                               @6
-        deflateInit2_                            @7
-        deflateInit_                             @8
-        deflateParams                            @9
-        deflateReset                             @10
-        deflateSetDictionary                     @11
-        gzclose                                  @12
-        gzdopen                                  @13
-        gzerror                                  @14
-        gzflush                                  @15
-        gzopen                                   @16
-        gzread                                   @17
-        gzwrite                                  @18
-        inflate                                  @19
-        inflateEnd                               @20
-        inflateInit2_                            @21
-        inflateInit_                             @22
-        inflateReset                             @23
-        inflateSetDictionary                     @24
-        inflateSync                              @25
-        uncompress                               @26
-        zlibVersion                              @27
-        gzprintf                                 @28
-        gzputc                                   @29
-        gzgetc                                   @30
-        gzseek                                   @31
-        gzrewind                                 @32
-        gztell                                   @33
-        gzeof                                    @34
-        gzsetparams                              @35
-        zError                                   @36
-        inflateSyncPoint                         @37
-        get_crc_table                            @38
-        compress2                                @39
-        gzputs                                   @40
-        gzgets                                   @41
-        inflateCopy                              @42
-        inflateBackInit_                         @43
-        inflateBack                              @44
-        inflateBackEnd                           @45
-        compressBound                            @46
-        deflateBound                             @47
-        gzclearerr                               @48
-        gzungetc                                 @49
-        zlibCompileFlags                         @50
-        deflatePrime                             @51
-        deflatePending                           @52
-
-        unzOpen                                  @61
-        unzClose                                 @62
-        unzGetGlobalInfo                         @63
-        unzGetCurrentFileInfo                    @64
-        unzGoToFirstFile                         @65
-        unzGoToNextFile                          @66
-        unzOpenCurrentFile                       @67
-        unzReadCurrentFile                       @68
-        unzOpenCurrentFile3                      @69
-        unztell                                  @70
-        unzeof                                   @71
-        unzCloseCurrentFile                      @72
-        unzGetGlobalComment                      @73
-        unzStringFileNameCompare                 @74
-        unzLocateFile                            @75
-        unzGetLocalExtrafield                    @76
-        unzOpen2                                 @77
-        unzOpenCurrentFile2                      @78
-        unzOpenCurrentFilePassword               @79
-
-        zipOpen                                  @80
-        zipOpenNewFileInZip                      @81
-        zipWriteInFileInZip                      @82
-        zipCloseFileInZip                        @83
-        zipClose                                 @84
-        zipOpenNewFileInZip2                     @86
-        zipCloseFileInZipRaw                     @87
-        zipOpen2                                 @88
-        zipOpenNewFileInZip3                     @89
-
-        unzGetFilePos                            @100
-        unzGoToFilePos                           @101
-
-        fill_win32_filefunc                      @110
-
-; zlibwapi v1.2.4 added:
-        fill_win32_filefunc64                   @111
-        fill_win32_filefunc64A                  @112
-        fill_win32_filefunc64W                  @113
-
-        unzOpen64                               @120
-        unzOpen2_64                             @121
-        unzGetGlobalInfo64                      @122
-        unzGetCurrentFileInfo64                 @124
-        unzGetCurrentFileZStreamPos64           @125
-        unztell64                               @126
-        unzGetFilePos64                         @127
-        unzGoToFilePos64                        @128
-
-        zipOpen64                               @130
-        zipOpen2_64                             @131
-        zipOpenNewFileInZip64                   @132
-        zipOpenNewFileInZip2_64                 @133
-        zipOpenNewFileInZip3_64                 @134
-        zipOpenNewFileInZip4_64                 @135
-        zipCloseFileInZipRaw64                  @136
-
-; zlib1 v1.2.4 added:
-        adler32_combine                         @140
-        crc32_combine                           @142
-        deflateSetHeader                        @144
-        deflateTune                             @145
-        gzbuffer                                @146
-        gzclose_r                               @147
-        gzclose_w                               @148
-        gzdirect                                @149
-        gzoffset                                @150
-        inflateGetHeader                        @156
-        inflateMark                             @157
-        inflatePrime                            @158
-        inflateReset2                           @159
-        inflateUndermine                        @160
-
-; zlib1 v1.2.6 added:
-        gzgetc_                                 @161
-        inflateResetKeep                        @163
-        deflateResetKeep                        @164
-
-; zlib1 v1.2.7 added:
-        gzopen_w                                @165
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc9/zlibvc.sln gcc-4.8.1-ppc/zlib/contrib/vstudio/vc9/zlibvc.sln
--- gcc-4.8.1/zlib/contrib/vstudio/vc9/zlibvc.sln	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc9/zlibvc.sln	1970-01-01 01:00:00.000000000 +0100
@@ -1,144 +0,0 @@
-
-Microsoft Visual Studio Solution File, Format Version 10.00
-# Visual Studio 2008
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "zlibvc", "zlibvc.vcproj", "{8FD826F8-3739-44E6-8CC8-997122E53B8D}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "zlibstat", "zlibstat.vcproj", "{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "testzlib", "testzlib.vcproj", "{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "TestZlibDll", "testzlibdll.vcproj", "{C52F9E7B-498A-42BE-8DB4-85A15694366A}"
-	ProjectSection(ProjectDependencies) = postProject
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D} = {8FD826F8-3739-44E6-8CC8-997122E53B8D}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "minizip", "minizip.vcproj", "{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}"
-	ProjectSection(ProjectDependencies) = postProject
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D} = {8FD826F8-3739-44E6-8CC8-997122E53B8D}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "miniunz", "miniunz.vcproj", "{C52F9E7B-498A-42BE-8DB4-85A15694382A}"
-	ProjectSection(ProjectDependencies) = postProject
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D} = {8FD826F8-3739-44E6-8CC8-997122E53B8D}
-	EndProjectSection
-EndProject
-Global
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|Itanium = Debug|Itanium
-		Debug|Win32 = Debug|Win32
-		Debug|x64 = Debug|x64
-		Release|Itanium = Release|Itanium
-		Release|Win32 = Release|Win32
-		Release|x64 = Release|x64
-		ReleaseWithoutAsm|Itanium = ReleaseWithoutAsm|Itanium
-		ReleaseWithoutAsm|Win32 = ReleaseWithoutAsm|Win32
-		ReleaseWithoutAsm|x64 = ReleaseWithoutAsm|x64
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|Itanium.ActiveCfg = Debug|Itanium
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|Itanium.Build.0 = Debug|Itanium
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|Win32.ActiveCfg = Debug|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|Win32.Build.0 = Debug|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|x64.ActiveCfg = Debug|x64
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|x64.Build.0 = Debug|x64
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|Itanium.ActiveCfg = Release|Itanium
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|Itanium.Build.0 = Release|Itanium
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|Win32.ActiveCfg = Release|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|Win32.Build.0 = Release|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|x64.ActiveCfg = Release|x64
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|x64.Build.0 = Release|x64
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|Itanium.ActiveCfg = ReleaseWithoutAsm|Itanium
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|Itanium.Build.0 = ReleaseWithoutAsm|Itanium
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|Win32.ActiveCfg = ReleaseWithoutAsm|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|Win32.Build.0 = ReleaseWithoutAsm|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|x64.ActiveCfg = ReleaseWithoutAsm|x64
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|x64.Build.0 = ReleaseWithoutAsm|x64
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|Itanium.ActiveCfg = Debug|Itanium
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|Itanium.Build.0 = Debug|Itanium
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|Win32.ActiveCfg = Debug|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|Win32.Build.0 = Debug|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|x64.ActiveCfg = Debug|x64
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|x64.Build.0 = Debug|x64
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|Itanium.ActiveCfg = Release|Itanium
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|Itanium.Build.0 = Release|Itanium
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|Win32.ActiveCfg = Release|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|Win32.Build.0 = Release|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|x64.ActiveCfg = Release|x64
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|x64.Build.0 = Release|x64
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|Itanium.ActiveCfg = ReleaseWithoutAsm|Itanium
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|Itanium.Build.0 = ReleaseWithoutAsm|Itanium
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|Win32.ActiveCfg = ReleaseWithoutAsm|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|Win32.Build.0 = ReleaseWithoutAsm|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|x64.ActiveCfg = ReleaseWithoutAsm|x64
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|x64.Build.0 = ReleaseWithoutAsm|x64
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|Itanium.ActiveCfg = Debug|Itanium
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|Itanium.Build.0 = Debug|Itanium
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|Win32.ActiveCfg = Debug|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|Win32.Build.0 = Debug|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|x64.ActiveCfg = Debug|x64
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|x64.Build.0 = Debug|x64
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|Itanium.ActiveCfg = Release|Itanium
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|Itanium.Build.0 = Release|Itanium
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|Win32.ActiveCfg = Release|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|Win32.Build.0 = Release|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|x64.ActiveCfg = Release|x64
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|x64.Build.0 = Release|x64
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Itanium.ActiveCfg = ReleaseWithoutAsm|Itanium
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Itanium.Build.0 = ReleaseWithoutAsm|Itanium
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Win32.ActiveCfg = ReleaseWithoutAsm|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Win32.Build.0 = ReleaseWithoutAsm|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|x64.ActiveCfg = ReleaseWithoutAsm|x64
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|x64.Build.0 = ReleaseWithoutAsm|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|Itanium.ActiveCfg = Debug|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|Itanium.Build.0 = Debug|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|Win32.ActiveCfg = Debug|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|Win32.Build.0 = Debug|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|x64.ActiveCfg = Debug|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|x64.Build.0 = Debug|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|Itanium.ActiveCfg = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|Itanium.Build.0 = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|Win32.ActiveCfg = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|Win32.Build.0 = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|x64.ActiveCfg = Release|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|x64.Build.0 = Release|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.ReleaseWithoutAsm|Itanium.ActiveCfg = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.ReleaseWithoutAsm|Itanium.Build.0 = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.ReleaseWithoutAsm|Win32.ActiveCfg = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.ReleaseWithoutAsm|x64.ActiveCfg = Release|x64
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|Itanium.ActiveCfg = Debug|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|Itanium.Build.0 = Debug|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|Win32.ActiveCfg = Debug|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|Win32.Build.0 = Debug|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|x64.ActiveCfg = Debug|x64
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|x64.Build.0 = Debug|x64
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|Itanium.ActiveCfg = Release|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|Itanium.Build.0 = Release|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|Win32.ActiveCfg = Release|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|Win32.Build.0 = Release|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|x64.ActiveCfg = Release|x64
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|x64.Build.0 = Release|x64
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Itanium.ActiveCfg = Release|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Itanium.Build.0 = Release|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Win32.ActiveCfg = Release|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|x64.ActiveCfg = Release|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|Itanium.ActiveCfg = Debug|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|Itanium.Build.0 = Debug|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|Win32.ActiveCfg = Debug|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|Win32.Build.0 = Debug|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|x64.ActiveCfg = Debug|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|x64.Build.0 = Debug|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|Itanium.ActiveCfg = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|Itanium.Build.0 = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|Win32.ActiveCfg = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|Win32.Build.0 = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|x64.ActiveCfg = Release|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|x64.Build.0 = Release|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm|Itanium.ActiveCfg = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm|Itanium.Build.0 = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm|Win32.ActiveCfg = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm|x64.ActiveCfg = Release|x64
-	EndGlobalSection
-	GlobalSection(SolutionProperties) = preSolution
-		HideSolutionNode = FALSE
-	EndGlobalSection
-EndGlobal
diff -Nbaur gcc-4.8.1/zlib/contrib/vstudio/vc9/zlibvc.vcproj gcc-4.8.1-ppc/zlib/contrib/vstudio/vc9/zlibvc.vcproj
--- gcc-4.8.1/zlib/contrib/vstudio/vc9/zlibvc.vcproj	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/contrib/vstudio/vc9/zlibvc.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,1156 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9,00"
-	Name="zlibvc"
-	ProjectGUID="{8FD826F8-3739-44E6-8CC8-997122E53B8D}"
-	RootNamespace="zlibvc"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-		<Platform
-			Name="x64"
-		/>
-		<Platform
-			Name="Itanium"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="x86\ZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x86\ZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="2"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="_DEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="1"
-				TypeLibraryName="$(OutDir)/zlibvc.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ZLIB_WINAPI;ASMV;ASMINF"
-				ExceptionHandling="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				PrecompiledHeaderFile="$(IntDir)/zlibvc.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="..\..\masmx86\match686.obj ..\..\masmx86\inffas32.obj"
-				OutputFile="$(OutDir)\zlibwapi.dll"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				GenerateManifest="false"
-				ModuleDefinitionFile=".\zlibvc.def"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/zlibwapi.pdb"
-				GenerateMapFile="true"
-				MapFileName="$(OutDir)/zlibwapi.map"
-				SubSystem="2"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				ImportLibrary="$(OutDir)/zlibwapi.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="x64\ZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x64\ZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="2"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="_DEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="3"
-				TypeLibraryName="$(OutDir)/zlibvc.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ZLIB_WINAPI;ASMV;ASMINF;WIN64"
-				ExceptionHandling="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				PrecompiledHeaderFile="$(IntDir)/zlibvc.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="..\..\masmx64\gvmat64.obj ..\..\masmx64\inffasx64.obj "
-				OutputFile="$(OutDir)\zlibwapi.dll"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				GenerateManifest="false"
-				ModuleDefinitionFile=".\zlibvc.def"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/zlibwapi.pdb"
-				GenerateMapFile="true"
-				MapFileName="$(OutDir)/zlibwapi.map"
-				SubSystem="2"
-				ImportLibrary="$(OutDir)/zlibwapi.lib"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Itanium"
-			OutputDirectory="ia64\ZlibDll$(ConfigurationName)"
-			IntermediateDirectory="ia64\ZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="2"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="_DEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="2"
-				TypeLibraryName="$(OutDir)/zlibvc.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ZLIB_WINAPI;WIN64"
-				ExceptionHandling="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				PrecompiledHeaderFile="$(IntDir)/zlibvc.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)\zlibwapi.dll"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				GenerateManifest="false"
-				ModuleDefinitionFile=".\zlibvc.def"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/zlibwapi.pdb"
-				GenerateMapFile="true"
-				MapFileName="$(OutDir)/zlibwapi.map"
-				SubSystem="2"
-				ImportLibrary="$(OutDir)/zlibwapi.lib"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|Win32"
-			OutputDirectory="x86\ZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x86\ZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="2"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="1"
-				TypeLibraryName="$(OutDir)/zlibvc.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ZLIB_WINAPI"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibvc.pch"
-				AssemblerOutput="2"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/MACHINE:I386"
-				OutputFile="$(OutDir)\zlibwapi.dll"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				GenerateManifest="false"
-				IgnoreAllDefaultLibraries="false"
-				ModuleDefinitionFile=".\zlibvc.def"
-				ProgramDatabaseFile="$(OutDir)/zlibwapi.pdb"
-				GenerateMapFile="true"
-				MapFileName="$(OutDir)/zlibwapi.map"
-				SubSystem="2"
-				OptimizeForWindows98="1"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				ImportLibrary="$(OutDir)/zlibwapi.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|x64"
-			OutputDirectory="x64\ZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x64\ZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="2"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="3"
-				TypeLibraryName="$(OutDir)/zlibvc.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ZLIB_WINAPI;WIN64"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibvc.pch"
-				AssemblerOutput="2"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)\zlibwapi.dll"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				GenerateManifest="false"
-				IgnoreAllDefaultLibraries="false"
-				ModuleDefinitionFile=".\zlibvc.def"
-				ProgramDatabaseFile="$(OutDir)/zlibwapi.pdb"
-				GenerateMapFile="true"
-				MapFileName="$(OutDir)/zlibwapi.map"
-				SubSystem="2"
-				OptimizeForWindows98="1"
-				ImportLibrary="$(OutDir)/zlibwapi.lib"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|Itanium"
-			OutputDirectory="ia64\ZlibDll$(ConfigurationName)"
-			IntermediateDirectory="ia64\ZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="2"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="2"
-				TypeLibraryName="$(OutDir)/zlibvc.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ZLIB_WINAPI;WIN64"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibvc.pch"
-				AssemblerOutput="2"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)\zlibwapi.dll"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				GenerateManifest="false"
-				IgnoreAllDefaultLibraries="false"
-				ModuleDefinitionFile=".\zlibvc.def"
-				ProgramDatabaseFile="$(OutDir)/zlibwapi.pdb"
-				GenerateMapFile="true"
-				MapFileName="$(OutDir)/zlibwapi.map"
-				SubSystem="2"
-				OptimizeForWindows98="1"
-				ImportLibrary="$(OutDir)/zlibwapi.lib"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="x86\ZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x86\ZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="2"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="1"
-				TypeLibraryName="$(OutDir)/zlibvc.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ZLIB_WINAPI;ASMV;ASMINF"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibvc.pch"
-				AssemblerOutput="2"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="..\..\masmx86\match686.obj ..\..\masmx86\inffas32.obj "
-				OutputFile="$(OutDir)\zlibwapi.dll"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				GenerateManifest="false"
-				IgnoreAllDefaultLibraries="false"
-				ModuleDefinitionFile=".\zlibvc.def"
-				ProgramDatabaseFile="$(OutDir)/zlibwapi.pdb"
-				GenerateMapFile="true"
-				MapFileName="$(OutDir)/zlibwapi.map"
-				SubSystem="2"
-				OptimizeForWindows98="1"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				ImportLibrary="$(OutDir)/zlibwapi.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="x64\ZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x64\ZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="2"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="3"
-				TypeLibraryName="$(OutDir)/zlibvc.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ZLIB_WINAPI;ASMV;ASMINF;WIN64"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibvc.pch"
-				AssemblerOutput="2"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="..\..\masmx64\gvmat64.obj ..\..\masmx64\inffasx64.obj "
-				OutputFile="$(OutDir)\zlibwapi.dll"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				GenerateManifest="false"
-				IgnoreAllDefaultLibraries="false"
-				ModuleDefinitionFile=".\zlibvc.def"
-				ProgramDatabaseFile="$(OutDir)/zlibwapi.pdb"
-				GenerateMapFile="true"
-				MapFileName="$(OutDir)/zlibwapi.map"
-				SubSystem="2"
-				OptimizeForWindows98="1"
-				ImportLibrary="$(OutDir)/zlibwapi.lib"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Itanium"
-			OutputDirectory="ia64\ZlibDll$(ConfigurationName)"
-			IntermediateDirectory="ia64\ZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="2"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="2"
-				TypeLibraryName="$(OutDir)/zlibvc.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;_CRT_NONSTDC_NO_WARNINGS;ZLIB_WINAPI;WIN64"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibvc.pch"
-				AssemblerOutput="2"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)\zlibwapi.dll"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				GenerateManifest="false"
-				IgnoreAllDefaultLibraries="false"
-				ModuleDefinitionFile=".\zlibvc.def"
-				ProgramDatabaseFile="$(OutDir)/zlibwapi.pdb"
-				GenerateMapFile="true"
-				MapFileName="$(OutDir)/zlibwapi.map"
-				SubSystem="2"
-				OptimizeForWindows98="1"
-				ImportLibrary="$(OutDir)/zlibwapi.lib"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;rc;def;r;odl;hpj;bat;for;f90"
-			>
-			<File
-				RelativePath="..\..\..\adler32.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\compress.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\crc32.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\deflate.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\gzclose.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\gzguts.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\gzlib.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\gzread.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\gzwrite.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\infback.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\masmx64\inffas8664.c"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\..\..\inffast.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\inflate.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\inftrees.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\minizip\ioapi.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\minizip\iowin32.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\trees.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\uncompr.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\minizip\unzip.c"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions="ZLIB_INTERNAL"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|x64"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions="ZLIB_INTERNAL"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Itanium"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions="ZLIB_INTERNAL"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\..\minizip\zip.c"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions="ZLIB_INTERNAL"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|x64"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions="ZLIB_INTERNAL"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Itanium"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions="ZLIB_INTERNAL"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath=".\zlib.rc"
-				>
-			</File>
-			<File
-				RelativePath=".\zlibvc.def"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\zutil.c"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;fi;fd"
-			>
-			<File
-				RelativePath="..\..\..\deflate.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\infblock.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\infcodes.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\inffast.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\inftrees.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\infutil.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\zconf.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\zlib.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\zutil.h"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="ico;cur;bmp;dlg;rc2;rct;bin;cnt;rtf;gif;jpg;jpeg;jpe"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nbaur gcc-4.8.1/zlib/crc32.c gcc-4.8.1-ppc/zlib/crc32.c
--- gcc-4.8.1/zlib/crc32.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/crc32.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,425 +0,0 @@
-/* crc32.c -- compute the CRC-32 of a data stream
- * Copyright (C) 1995-2006, 2010, 2011, 2012 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster
- * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing
- * tables for updating the shift register in one step with three exclusive-ors
- * instead of four steps with four exclusive-ors.  This results in about a
- * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.
- */
-
-/* @(#) $Id: crc32.c,v 1.1.1.2 2002/03/11 21:53:23 tromey Exp $ */
-
-/*
-  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
-  protection on the static variables used to control the first-use generation
-  of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should
-  first call get_crc_table() to initialize the tables before allowing more than
-  one thread to use crc32().
-
-  DYNAMIC_CRC_TABLE and MAKECRCH can be #defined to write out crc32.h.
- */
-
-#ifdef MAKECRCH
-#  include <stdio.h>
-#  ifndef DYNAMIC_CRC_TABLE
-#    define DYNAMIC_CRC_TABLE
-#  endif /* !DYNAMIC_CRC_TABLE */
-#endif /* MAKECRCH */
-
-#include "zutil.h"      /* for STDC and FAR definitions */
-
-#define local static
-
-/* Definitions for doing the crc four data bytes at a time. */
-#if !defined(NOBYFOUR) && defined(Z_U4)
-#  define BYFOUR
-#endif
-#ifdef BYFOUR
-   local unsigned long crc32_little OF((unsigned long,
-                        const unsigned char FAR *, unsigned));
-   local unsigned long crc32_big OF((unsigned long,
-                        const unsigned char FAR *, unsigned));
-#  define TBLS 8
-#else
-#  define TBLS 1
-#endif /* BYFOUR */
-
-/* Local functions for crc concatenation */
-local unsigned long gf2_matrix_times OF((unsigned long *mat,
-                                         unsigned long vec));
-local void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));
-local uLong crc32_combine_ OF((uLong crc1, uLong crc2, z_off64_t len2));
-
-
-#ifdef DYNAMIC_CRC_TABLE
-
-local volatile int crc_table_empty = 1;
-local z_crc_t FAR crc_table[TBLS][256];
-local void make_crc_table OF((void));
-#ifdef MAKECRCH
-   local void write_table OF((FILE *, const z_crc_t FAR *));
-#endif /* MAKECRCH */
-/*
-  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
-  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
-
-  Polynomials over GF(2) are represented in binary, one bit per coefficient,
-  with the lowest powers in the most significant bit.  Then adding polynomials
-  is just exclusive-or, and multiplying a polynomial by x is a right shift by
-  one.  If we call the above polynomial p, and represent a byte as the
-  polynomial q, also with the lowest power in the most significant bit (so the
-  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
-  where a mod b means the remainder after dividing a by b.
-
-  This calculation is done using the shift-register method of multiplying and
-  taking the remainder.  The register is initialized to zero, and for each
-  incoming bit, x^32 is added mod p to the register if the bit is a one (where
-  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
-  x (which is shifting right by one and adding x^32 mod p if the bit shifted
-  out is a one).  We start with the highest power (least significant bit) of
-  q and repeat for all eight bits of q.
-
-  The first table is simply the CRC of all possible eight bit values.  This is
-  all the information needed to generate CRCs on data a byte at a time for all
-  combinations of CRC register values and incoming bytes.  The remaining tables
-  allow for word-at-a-time CRC calculation for both big-endian and little-
-  endian machines, where a word is four bytes.
-*/
-local void make_crc_table()
-{
-    z_crc_t c;
-    int n, k;
-    z_crc_t poly;                       /* polynomial exclusive-or pattern */
-    /* terms of polynomial defining this crc (except x^32): */
-    static volatile int first = 1;      /* flag to limit concurrent making */
-    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
-
-    /* See if another task is already doing this (not thread-safe, but better
-       than nothing -- significantly reduces duration of vulnerability in
-       case the advice about DYNAMIC_CRC_TABLE is ignored) */
-    if (first) {
-        first = 0;
-
-        /* make exclusive-or pattern from polynomial (0xedb88320UL) */
-        poly = 0;
-        for (n = 0; n < (int)(sizeof(p)/sizeof(unsigned char)); n++)
-            poly |= (z_crc_t)1 << (31 - p[n]);
-
-        /* generate a crc for every 8-bit value */
-        for (n = 0; n < 256; n++) {
-            c = (z_crc_t)n;
-            for (k = 0; k < 8; k++)
-                c = c & 1 ? poly ^ (c >> 1) : c >> 1;
-            crc_table[0][n] = c;
-        }
-
-#ifdef BYFOUR
-        /* generate crc for each value followed by one, two, and three zeros,
-           and then the byte reversal of those as well as the first table */
-        for (n = 0; n < 256; n++) {
-            c = crc_table[0][n];
-            crc_table[4][n] = ZSWAP32(c);
-            for (k = 1; k < 4; k++) {
-                c = crc_table[0][c & 0xff] ^ (c >> 8);
-                crc_table[k][n] = c;
-                crc_table[k + 4][n] = ZSWAP32(c);
-            }
-        }
-#endif /* BYFOUR */
-
-        crc_table_empty = 0;
-    }
-    else {      /* not first */
-        /* wait for the other guy to finish (not efficient, but rare) */
-        while (crc_table_empty)
-            ;
-    }
-
-#ifdef MAKECRCH
-    /* write out CRC tables to crc32.h */
-    {
-        FILE *out;
-
-        out = fopen("crc32.h", "w");
-        if (out == NULL) return;
-        fprintf(out, "/* crc32.h -- tables for rapid CRC calculation\n");
-        fprintf(out, " * Generated automatically by crc32.c\n */\n\n");
-        fprintf(out, "local const z_crc_t FAR ");
-        fprintf(out, "crc_table[TBLS][256] =\n{\n  {\n");
-        write_table(out, crc_table[0]);
-#  ifdef BYFOUR
-        fprintf(out, "#ifdef BYFOUR\n");
-        for (k = 1; k < 8; k++) {
-            fprintf(out, "  },\n  {\n");
-            write_table(out, crc_table[k]);
-        }
-        fprintf(out, "#endif\n");
-#  endif /* BYFOUR */
-        fprintf(out, "  }\n};\n");
-        fclose(out);
-    }
-#endif /* MAKECRCH */
-}
-
-#ifdef MAKECRCH
-local void write_table(out, table)
-    FILE *out;
-    const z_crc_t FAR *table;
-{
-    int n;
-
-    for (n = 0; n < 256; n++)
-        fprintf(out, "%s0x%08lxUL%s", n % 5 ? "" : "    ",
-                (unsigned long)(table[n]),
-                n == 255 ? "\n" : (n % 5 == 4 ? ",\n" : ", "));
-}
-#endif /* MAKECRCH */
-
-#else /* !DYNAMIC_CRC_TABLE */
-/* ========================================================================
- * Tables of CRC-32s of all single-byte values, made by make_crc_table().
- */
-#include "crc32.h"
-#endif /* DYNAMIC_CRC_TABLE */
-
-/* =========================================================================
- * This function can be used by asm versions of crc32()
- */
-const z_crc_t FAR * ZEXPORT get_crc_table()
-{
-#ifdef DYNAMIC_CRC_TABLE
-    if (crc_table_empty)
-        make_crc_table();
-#endif /* DYNAMIC_CRC_TABLE */
-    return (const z_crc_t FAR *)crc_table;
-}
-
-/* ========================================================================= */
-#define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8)
-#define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1
-
-/* ========================================================================= */
-unsigned long ZEXPORT crc32(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    uInt len;
-{
-    if (buf == Z_NULL) return 0UL;
-
-#ifdef DYNAMIC_CRC_TABLE
-    if (crc_table_empty)
-        make_crc_table();
-#endif /* DYNAMIC_CRC_TABLE */
-
-#ifdef BYFOUR
-    if (sizeof(void *) == sizeof(ptrdiff_t)) {
-        z_crc_t endian;
-
-        endian = 1;
-        if (*((unsigned char *)(&endian)))
-            return crc32_little(crc, buf, len);
-        else
-            return crc32_big(crc, buf, len);
-    }
-#endif /* BYFOUR */
-    crc = crc ^ 0xffffffffUL;
-    while (len >= 8) {
-        DO8;
-        len -= 8;
-    }
-    if (len) do {
-        DO1;
-    } while (--len);
-    return crc ^ 0xffffffffUL;
-}
-
-#ifdef BYFOUR
-
-/* ========================================================================= */
-#define DOLIT4 c ^= *buf4++; \
-        c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ \
-            crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24]
-#define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4
-
-/* ========================================================================= */
-local unsigned long crc32_little(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    unsigned len;
-{
-    register z_crc_t c;
-    register const z_crc_t FAR *buf4;
-
-    c = (z_crc_t)crc;
-    c = ~c;
-    while (len && ((ptrdiff_t)buf & 3)) {
-        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
-        len--;
-    }
-
-    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;
-    while (len >= 32) {
-        DOLIT32;
-        len -= 32;
-    }
-    while (len >= 4) {
-        DOLIT4;
-        len -= 4;
-    }
-    buf = (const unsigned char FAR *)buf4;
-
-    if (len) do {
-        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
-    } while (--len);
-    c = ~c;
-    return (unsigned long)c;
-}
-
-/* ========================================================================= */
-#define DOBIG4 c ^= *++buf4; \
-        c = crc_table[4][c & 0xff] ^ crc_table[5][(c >> 8) & 0xff] ^ \
-            crc_table[6][(c >> 16) & 0xff] ^ crc_table[7][c >> 24]
-#define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4
-
-/* ========================================================================= */
-local unsigned long crc32_big(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    unsigned len;
-{
-    register z_crc_t c;
-    register const z_crc_t FAR *buf4;
-
-    c = ZSWAP32((z_crc_t)crc);
-    c = ~c;
-    while (len && ((ptrdiff_t)buf & 3)) {
-        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
-        len--;
-    }
-
-    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;
-    buf4--;
-    while (len >= 32) {
-        DOBIG32;
-        len -= 32;
-    }
-    while (len >= 4) {
-        DOBIG4;
-        len -= 4;
-    }
-    buf4++;
-    buf = (const unsigned char FAR *)buf4;
-
-    if (len) do {
-        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
-    } while (--len);
-    c = ~c;
-    return (unsigned long)(ZSWAP32(c));
-}
-
-#endif /* BYFOUR */
-
-#define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */
-
-/* ========================================================================= */
-local unsigned long gf2_matrix_times(mat, vec)
-    unsigned long *mat;
-    unsigned long vec;
-{
-    unsigned long sum;
-
-    sum = 0;
-    while (vec) {
-        if (vec & 1)
-            sum ^= *mat;
-        vec >>= 1;
-        mat++;
-    }
-    return sum;
-}
-
-/* ========================================================================= */
-local void gf2_matrix_square(square, mat)
-    unsigned long *square;
-    unsigned long *mat;
-{
-    int n;
-
-    for (n = 0; n < GF2_DIM; n++)
-        square[n] = gf2_matrix_times(mat, mat[n]);
-}
-
-/* ========================================================================= */
-local uLong crc32_combine_(crc1, crc2, len2)
-    uLong crc1;
-    uLong crc2;
-    z_off64_t len2;
-{
-    int n;
-    unsigned long row;
-    unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */
-    unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */
-
-    /* degenerate case (also disallow negative lengths) */
-    if (len2 <= 0)
-        return crc1;
-
-    /* put operator for one zero bit in odd */
-    odd[0] = 0xedb88320UL;          /* CRC-32 polynomial */
-    row = 1;
-    for (n = 1; n < GF2_DIM; n++) {
-        odd[n] = row;
-        row <<= 1;
-    }
-
-    /* put operator for two zero bits in even */
-    gf2_matrix_square(even, odd);
-
-    /* put operator for four zero bits in odd */
-    gf2_matrix_square(odd, even);
-
-    /* apply len2 zeros to crc1 (first square will put the operator for one
-       zero byte, eight zero bits, in even) */
-    do {
-        /* apply zeros operator for this bit of len2 */
-        gf2_matrix_square(even, odd);
-        if (len2 & 1)
-            crc1 = gf2_matrix_times(even, crc1);
-        len2 >>= 1;
-
-        /* if no more bits set, then done */
-        if (len2 == 0)
-            break;
-
-        /* another iteration of the loop with odd and even swapped */
-        gf2_matrix_square(odd, even);
-        if (len2 & 1)
-            crc1 = gf2_matrix_times(odd, crc1);
-        len2 >>= 1;
-
-        /* if no more bits set, then done */
-    } while (len2 != 0);
-
-    /* return combined crc */
-    crc1 ^= crc2;
-    return crc1;
-}
-
-/* ========================================================================= */
-uLong ZEXPORT crc32_combine(crc1, crc2, len2)
-    uLong crc1;
-    uLong crc2;
-    z_off_t len2;
-{
-    return crc32_combine_(crc1, crc2, len2);
-}
-
-uLong ZEXPORT crc32_combine64(crc1, crc2, len2)
-    uLong crc1;
-    uLong crc2;
-    z_off64_t len2;
-{
-    return crc32_combine_(crc1, crc2, len2);
-}
diff -Nbaur gcc-4.8.1/zlib/crc32.h gcc-4.8.1-ppc/zlib/crc32.h
--- gcc-4.8.1/zlib/crc32.h	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/crc32.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,441 +0,0 @@
-/* crc32.h -- tables for rapid CRC calculation
- * Generated automatically by crc32.c
- */
-
-local const z_crc_t FAR crc_table[TBLS][256] =
-{
-  {
-    0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
-    0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,
-    0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,
-    0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,
-    0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,
-    0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,
-    0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,
-    0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,
-    0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,
-    0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,
-    0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,
-    0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,
-    0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,
-    0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,
-    0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,
-    0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,
-    0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,
-    0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,
-    0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,
-    0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,
-    0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,
-    0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,
-    0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,
-    0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,
-    0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,
-    0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,
-    0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,
-    0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,
-    0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,
-    0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,
-    0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,
-    0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,
-    0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,
-    0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,
-    0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,
-    0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,
-    0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,
-    0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,
-    0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,
-    0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,
-    0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,
-    0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,
-    0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,
-    0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,
-    0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,
-    0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,
-    0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,
-    0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,
-    0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,
-    0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,
-    0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,
-    0x2d02ef8dUL
-#ifdef BYFOUR
-  },
-  {
-    0x00000000UL, 0x191b3141UL, 0x32366282UL, 0x2b2d53c3UL, 0x646cc504UL,
-    0x7d77f445UL, 0x565aa786UL, 0x4f4196c7UL, 0xc8d98a08UL, 0xd1c2bb49UL,
-    0xfaefe88aUL, 0xe3f4d9cbUL, 0xacb54f0cUL, 0xb5ae7e4dUL, 0x9e832d8eUL,
-    0x87981ccfUL, 0x4ac21251UL, 0x53d92310UL, 0x78f470d3UL, 0x61ef4192UL,
-    0x2eaed755UL, 0x37b5e614UL, 0x1c98b5d7UL, 0x05838496UL, 0x821b9859UL,
-    0x9b00a918UL, 0xb02dfadbUL, 0xa936cb9aUL, 0xe6775d5dUL, 0xff6c6c1cUL,
-    0xd4413fdfUL, 0xcd5a0e9eUL, 0x958424a2UL, 0x8c9f15e3UL, 0xa7b24620UL,
-    0xbea97761UL, 0xf1e8e1a6UL, 0xe8f3d0e7UL, 0xc3de8324UL, 0xdac5b265UL,
-    0x5d5daeaaUL, 0x44469febUL, 0x6f6bcc28UL, 0x7670fd69UL, 0x39316baeUL,
-    0x202a5aefUL, 0x0b07092cUL, 0x121c386dUL, 0xdf4636f3UL, 0xc65d07b2UL,
-    0xed705471UL, 0xf46b6530UL, 0xbb2af3f7UL, 0xa231c2b6UL, 0x891c9175UL,
-    0x9007a034UL, 0x179fbcfbUL, 0x0e848dbaUL, 0x25a9de79UL, 0x3cb2ef38UL,
-    0x73f379ffUL, 0x6ae848beUL, 0x41c51b7dUL, 0x58de2a3cUL, 0xf0794f05UL,
-    0xe9627e44UL, 0xc24f2d87UL, 0xdb541cc6UL, 0x94158a01UL, 0x8d0ebb40UL,
-    0xa623e883UL, 0xbf38d9c2UL, 0x38a0c50dUL, 0x21bbf44cUL, 0x0a96a78fUL,
-    0x138d96ceUL, 0x5ccc0009UL, 0x45d73148UL, 0x6efa628bUL, 0x77e153caUL,
-    0xbabb5d54UL, 0xa3a06c15UL, 0x888d3fd6UL, 0x91960e97UL, 0xded79850UL,
-    0xc7cca911UL, 0xece1fad2UL, 0xf5facb93UL, 0x7262d75cUL, 0x6b79e61dUL,
-    0x4054b5deUL, 0x594f849fUL, 0x160e1258UL, 0x0f152319UL, 0x243870daUL,
-    0x3d23419bUL, 0x65fd6ba7UL, 0x7ce65ae6UL, 0x57cb0925UL, 0x4ed03864UL,
-    0x0191aea3UL, 0x188a9fe2UL, 0x33a7cc21UL, 0x2abcfd60UL, 0xad24e1afUL,
-    0xb43fd0eeUL, 0x9f12832dUL, 0x8609b26cUL, 0xc94824abUL, 0xd05315eaUL,
-    0xfb7e4629UL, 0xe2657768UL, 0x2f3f79f6UL, 0x362448b7UL, 0x1d091b74UL,
-    0x04122a35UL, 0x4b53bcf2UL, 0x52488db3UL, 0x7965de70UL, 0x607eef31UL,
-    0xe7e6f3feUL, 0xfefdc2bfUL, 0xd5d0917cUL, 0xcccba03dUL, 0x838a36faUL,
-    0x9a9107bbUL, 0xb1bc5478UL, 0xa8a76539UL, 0x3b83984bUL, 0x2298a90aUL,
-    0x09b5fac9UL, 0x10aecb88UL, 0x5fef5d4fUL, 0x46f46c0eUL, 0x6dd93fcdUL,
-    0x74c20e8cUL, 0xf35a1243UL, 0xea412302UL, 0xc16c70c1UL, 0xd8774180UL,
-    0x9736d747UL, 0x8e2de606UL, 0xa500b5c5UL, 0xbc1b8484UL, 0x71418a1aUL,
-    0x685abb5bUL, 0x4377e898UL, 0x5a6cd9d9UL, 0x152d4f1eUL, 0x0c367e5fUL,
-    0x271b2d9cUL, 0x3e001cddUL, 0xb9980012UL, 0xa0833153UL, 0x8bae6290UL,
-    0x92b553d1UL, 0xddf4c516UL, 0xc4eff457UL, 0xefc2a794UL, 0xf6d996d5UL,
-    0xae07bce9UL, 0xb71c8da8UL, 0x9c31de6bUL, 0x852aef2aUL, 0xca6b79edUL,
-    0xd37048acUL, 0xf85d1b6fUL, 0xe1462a2eUL, 0x66de36e1UL, 0x7fc507a0UL,
-    0x54e85463UL, 0x4df36522UL, 0x02b2f3e5UL, 0x1ba9c2a4UL, 0x30849167UL,
-    0x299fa026UL, 0xe4c5aeb8UL, 0xfdde9ff9UL, 0xd6f3cc3aUL, 0xcfe8fd7bUL,
-    0x80a96bbcUL, 0x99b25afdUL, 0xb29f093eUL, 0xab84387fUL, 0x2c1c24b0UL,
-    0x350715f1UL, 0x1e2a4632UL, 0x07317773UL, 0x4870e1b4UL, 0x516bd0f5UL,
-    0x7a468336UL, 0x635db277UL, 0xcbfad74eUL, 0xd2e1e60fUL, 0xf9ccb5ccUL,
-    0xe0d7848dUL, 0xaf96124aUL, 0xb68d230bUL, 0x9da070c8UL, 0x84bb4189UL,
-    0x03235d46UL, 0x1a386c07UL, 0x31153fc4UL, 0x280e0e85UL, 0x674f9842UL,
-    0x7e54a903UL, 0x5579fac0UL, 0x4c62cb81UL, 0x8138c51fUL, 0x9823f45eUL,
-    0xb30ea79dUL, 0xaa1596dcUL, 0xe554001bUL, 0xfc4f315aUL, 0xd7626299UL,
-    0xce7953d8UL, 0x49e14f17UL, 0x50fa7e56UL, 0x7bd72d95UL, 0x62cc1cd4UL,
-    0x2d8d8a13UL, 0x3496bb52UL, 0x1fbbe891UL, 0x06a0d9d0UL, 0x5e7ef3ecUL,
-    0x4765c2adUL, 0x6c48916eUL, 0x7553a02fUL, 0x3a1236e8UL, 0x230907a9UL,
-    0x0824546aUL, 0x113f652bUL, 0x96a779e4UL, 0x8fbc48a5UL, 0xa4911b66UL,
-    0xbd8a2a27UL, 0xf2cbbce0UL, 0xebd08da1UL, 0xc0fdde62UL, 0xd9e6ef23UL,
-    0x14bce1bdUL, 0x0da7d0fcUL, 0x268a833fUL, 0x3f91b27eUL, 0x70d024b9UL,
-    0x69cb15f8UL, 0x42e6463bUL, 0x5bfd777aUL, 0xdc656bb5UL, 0xc57e5af4UL,
-    0xee530937UL, 0xf7483876UL, 0xb809aeb1UL, 0xa1129ff0UL, 0x8a3fcc33UL,
-    0x9324fd72UL
-  },
-  {
-    0x00000000UL, 0x01c26a37UL, 0x0384d46eUL, 0x0246be59UL, 0x0709a8dcUL,
-    0x06cbc2ebUL, 0x048d7cb2UL, 0x054f1685UL, 0x0e1351b8UL, 0x0fd13b8fUL,
-    0x0d9785d6UL, 0x0c55efe1UL, 0x091af964UL, 0x08d89353UL, 0x0a9e2d0aUL,
-    0x0b5c473dUL, 0x1c26a370UL, 0x1de4c947UL, 0x1fa2771eUL, 0x1e601d29UL,
-    0x1b2f0bacUL, 0x1aed619bUL, 0x18abdfc2UL, 0x1969b5f5UL, 0x1235f2c8UL,
-    0x13f798ffUL, 0x11b126a6UL, 0x10734c91UL, 0x153c5a14UL, 0x14fe3023UL,
-    0x16b88e7aUL, 0x177ae44dUL, 0x384d46e0UL, 0x398f2cd7UL, 0x3bc9928eUL,
-    0x3a0bf8b9UL, 0x3f44ee3cUL, 0x3e86840bUL, 0x3cc03a52UL, 0x3d025065UL,
-    0x365e1758UL, 0x379c7d6fUL, 0x35dac336UL, 0x3418a901UL, 0x3157bf84UL,
-    0x3095d5b3UL, 0x32d36beaUL, 0x331101ddUL, 0x246be590UL, 0x25a98fa7UL,
-    0x27ef31feUL, 0x262d5bc9UL, 0x23624d4cUL, 0x22a0277bUL, 0x20e69922UL,
-    0x2124f315UL, 0x2a78b428UL, 0x2bbade1fUL, 0x29fc6046UL, 0x283e0a71UL,
-    0x2d711cf4UL, 0x2cb376c3UL, 0x2ef5c89aUL, 0x2f37a2adUL, 0x709a8dc0UL,
-    0x7158e7f7UL, 0x731e59aeUL, 0x72dc3399UL, 0x7793251cUL, 0x76514f2bUL,
-    0x7417f172UL, 0x75d59b45UL, 0x7e89dc78UL, 0x7f4bb64fUL, 0x7d0d0816UL,
-    0x7ccf6221UL, 0x798074a4UL, 0x78421e93UL, 0x7a04a0caUL, 0x7bc6cafdUL,
-    0x6cbc2eb0UL, 0x6d7e4487UL, 0x6f38fadeUL, 0x6efa90e9UL, 0x6bb5866cUL,
-    0x6a77ec5bUL, 0x68315202UL, 0x69f33835UL, 0x62af7f08UL, 0x636d153fUL,
-    0x612bab66UL, 0x60e9c151UL, 0x65a6d7d4UL, 0x6464bde3UL, 0x662203baUL,
-    0x67e0698dUL, 0x48d7cb20UL, 0x4915a117UL, 0x4b531f4eUL, 0x4a917579UL,
-    0x4fde63fcUL, 0x4e1c09cbUL, 0x4c5ab792UL, 0x4d98dda5UL, 0x46c49a98UL,
-    0x4706f0afUL, 0x45404ef6UL, 0x448224c1UL, 0x41cd3244UL, 0x400f5873UL,
-    0x4249e62aUL, 0x438b8c1dUL, 0x54f16850UL, 0x55330267UL, 0x5775bc3eUL,
-    0x56b7d609UL, 0x53f8c08cUL, 0x523aaabbUL, 0x507c14e2UL, 0x51be7ed5UL,
-    0x5ae239e8UL, 0x5b2053dfUL, 0x5966ed86UL, 0x58a487b1UL, 0x5deb9134UL,
-    0x5c29fb03UL, 0x5e6f455aUL, 0x5fad2f6dUL, 0xe1351b80UL, 0xe0f771b7UL,
-    0xe2b1cfeeUL, 0xe373a5d9UL, 0xe63cb35cUL, 0xe7fed96bUL, 0xe5b86732UL,
-    0xe47a0d05UL, 0xef264a38UL, 0xeee4200fUL, 0xeca29e56UL, 0xed60f461UL,
-    0xe82fe2e4UL, 0xe9ed88d3UL, 0xebab368aUL, 0xea695cbdUL, 0xfd13b8f0UL,
-    0xfcd1d2c7UL, 0xfe976c9eUL, 0xff5506a9UL, 0xfa1a102cUL, 0xfbd87a1bUL,
-    0xf99ec442UL, 0xf85cae75UL, 0xf300e948UL, 0xf2c2837fUL, 0xf0843d26UL,
-    0xf1465711UL, 0xf4094194UL, 0xf5cb2ba3UL, 0xf78d95faUL, 0xf64fffcdUL,
-    0xd9785d60UL, 0xd8ba3757UL, 0xdafc890eUL, 0xdb3ee339UL, 0xde71f5bcUL,
-    0xdfb39f8bUL, 0xddf521d2UL, 0xdc374be5UL, 0xd76b0cd8UL, 0xd6a966efUL,
-    0xd4efd8b6UL, 0xd52db281UL, 0xd062a404UL, 0xd1a0ce33UL, 0xd3e6706aUL,
-    0xd2241a5dUL, 0xc55efe10UL, 0xc49c9427UL, 0xc6da2a7eUL, 0xc7184049UL,
-    0xc25756ccUL, 0xc3953cfbUL, 0xc1d382a2UL, 0xc011e895UL, 0xcb4dafa8UL,
-    0xca8fc59fUL, 0xc8c97bc6UL, 0xc90b11f1UL, 0xcc440774UL, 0xcd866d43UL,
-    0xcfc0d31aUL, 0xce02b92dUL, 0x91af9640UL, 0x906dfc77UL, 0x922b422eUL,
-    0x93e92819UL, 0x96a63e9cUL, 0x976454abUL, 0x9522eaf2UL, 0x94e080c5UL,
-    0x9fbcc7f8UL, 0x9e7eadcfUL, 0x9c381396UL, 0x9dfa79a1UL, 0x98b56f24UL,
-    0x99770513UL, 0x9b31bb4aUL, 0x9af3d17dUL, 0x8d893530UL, 0x8c4b5f07UL,
-    0x8e0de15eUL, 0x8fcf8b69UL, 0x8a809decUL, 0x8b42f7dbUL, 0x89044982UL,
-    0x88c623b5UL, 0x839a6488UL, 0x82580ebfUL, 0x801eb0e6UL, 0x81dcdad1UL,
-    0x8493cc54UL, 0x8551a663UL, 0x8717183aUL, 0x86d5720dUL, 0xa9e2d0a0UL,
-    0xa820ba97UL, 0xaa6604ceUL, 0xaba46ef9UL, 0xaeeb787cUL, 0xaf29124bUL,
-    0xad6fac12UL, 0xacadc625UL, 0xa7f18118UL, 0xa633eb2fUL, 0xa4755576UL,
-    0xa5b73f41UL, 0xa0f829c4UL, 0xa13a43f3UL, 0xa37cfdaaUL, 0xa2be979dUL,
-    0xb5c473d0UL, 0xb40619e7UL, 0xb640a7beUL, 0xb782cd89UL, 0xb2cddb0cUL,
-    0xb30fb13bUL, 0xb1490f62UL, 0xb08b6555UL, 0xbbd72268UL, 0xba15485fUL,
-    0xb853f606UL, 0xb9919c31UL, 0xbcde8ab4UL, 0xbd1ce083UL, 0xbf5a5edaUL,
-    0xbe9834edUL
-  },
-  {
-    0x00000000UL, 0xb8bc6765UL, 0xaa09c88bUL, 0x12b5afeeUL, 0x8f629757UL,
-    0x37def032UL, 0x256b5fdcUL, 0x9dd738b9UL, 0xc5b428efUL, 0x7d084f8aUL,
-    0x6fbde064UL, 0xd7018701UL, 0x4ad6bfb8UL, 0xf26ad8ddUL, 0xe0df7733UL,
-    0x58631056UL, 0x5019579fUL, 0xe8a530faUL, 0xfa109f14UL, 0x42acf871UL,
-    0xdf7bc0c8UL, 0x67c7a7adUL, 0x75720843UL, 0xcdce6f26UL, 0x95ad7f70UL,
-    0x2d111815UL, 0x3fa4b7fbUL, 0x8718d09eUL, 0x1acfe827UL, 0xa2738f42UL,
-    0xb0c620acUL, 0x087a47c9UL, 0xa032af3eUL, 0x188ec85bUL, 0x0a3b67b5UL,
-    0xb28700d0UL, 0x2f503869UL, 0x97ec5f0cUL, 0x8559f0e2UL, 0x3de59787UL,
-    0x658687d1UL, 0xdd3ae0b4UL, 0xcf8f4f5aUL, 0x7733283fUL, 0xeae41086UL,
-    0x525877e3UL, 0x40edd80dUL, 0xf851bf68UL, 0xf02bf8a1UL, 0x48979fc4UL,
-    0x5a22302aUL, 0xe29e574fUL, 0x7f496ff6UL, 0xc7f50893UL, 0xd540a77dUL,
-    0x6dfcc018UL, 0x359fd04eUL, 0x8d23b72bUL, 0x9f9618c5UL, 0x272a7fa0UL,
-    0xbafd4719UL, 0x0241207cUL, 0x10f48f92UL, 0xa848e8f7UL, 0x9b14583dUL,
-    0x23a83f58UL, 0x311d90b6UL, 0x89a1f7d3UL, 0x1476cf6aUL, 0xaccaa80fUL,
-    0xbe7f07e1UL, 0x06c36084UL, 0x5ea070d2UL, 0xe61c17b7UL, 0xf4a9b859UL,
-    0x4c15df3cUL, 0xd1c2e785UL, 0x697e80e0UL, 0x7bcb2f0eUL, 0xc377486bUL,
-    0xcb0d0fa2UL, 0x73b168c7UL, 0x6104c729UL, 0xd9b8a04cUL, 0x446f98f5UL,
-    0xfcd3ff90UL, 0xee66507eUL, 0x56da371bUL, 0x0eb9274dUL, 0xb6054028UL,
-    0xa4b0efc6UL, 0x1c0c88a3UL, 0x81dbb01aUL, 0x3967d77fUL, 0x2bd27891UL,
-    0x936e1ff4UL, 0x3b26f703UL, 0x839a9066UL, 0x912f3f88UL, 0x299358edUL,
-    0xb4446054UL, 0x0cf80731UL, 0x1e4da8dfUL, 0xa6f1cfbaUL, 0xfe92dfecUL,
-    0x462eb889UL, 0x549b1767UL, 0xec277002UL, 0x71f048bbUL, 0xc94c2fdeUL,
-    0xdbf98030UL, 0x6345e755UL, 0x6b3fa09cUL, 0xd383c7f9UL, 0xc1366817UL,
-    0x798a0f72UL, 0xe45d37cbUL, 0x5ce150aeUL, 0x4e54ff40UL, 0xf6e89825UL,
-    0xae8b8873UL, 0x1637ef16UL, 0x048240f8UL, 0xbc3e279dUL, 0x21e91f24UL,
-    0x99557841UL, 0x8be0d7afUL, 0x335cb0caUL, 0xed59b63bUL, 0x55e5d15eUL,
-    0x47507eb0UL, 0xffec19d5UL, 0x623b216cUL, 0xda874609UL, 0xc832e9e7UL,
-    0x708e8e82UL, 0x28ed9ed4UL, 0x9051f9b1UL, 0x82e4565fUL, 0x3a58313aUL,
-    0xa78f0983UL, 0x1f336ee6UL, 0x0d86c108UL, 0xb53aa66dUL, 0xbd40e1a4UL,
-    0x05fc86c1UL, 0x1749292fUL, 0xaff54e4aUL, 0x322276f3UL, 0x8a9e1196UL,
-    0x982bbe78UL, 0x2097d91dUL, 0x78f4c94bUL, 0xc048ae2eUL, 0xd2fd01c0UL,
-    0x6a4166a5UL, 0xf7965e1cUL, 0x4f2a3979UL, 0x5d9f9697UL, 0xe523f1f2UL,
-    0x4d6b1905UL, 0xf5d77e60UL, 0xe762d18eUL, 0x5fdeb6ebUL, 0xc2098e52UL,
-    0x7ab5e937UL, 0x680046d9UL, 0xd0bc21bcUL, 0x88df31eaUL, 0x3063568fUL,
-    0x22d6f961UL, 0x9a6a9e04UL, 0x07bda6bdUL, 0xbf01c1d8UL, 0xadb46e36UL,
-    0x15080953UL, 0x1d724e9aUL, 0xa5ce29ffUL, 0xb77b8611UL, 0x0fc7e174UL,
-    0x9210d9cdUL, 0x2aacbea8UL, 0x38191146UL, 0x80a57623UL, 0xd8c66675UL,
-    0x607a0110UL, 0x72cfaefeUL, 0xca73c99bUL, 0x57a4f122UL, 0xef189647UL,
-    0xfdad39a9UL, 0x45115eccUL, 0x764dee06UL, 0xcef18963UL, 0xdc44268dUL,
-    0x64f841e8UL, 0xf92f7951UL, 0x41931e34UL, 0x5326b1daUL, 0xeb9ad6bfUL,
-    0xb3f9c6e9UL, 0x0b45a18cUL, 0x19f00e62UL, 0xa14c6907UL, 0x3c9b51beUL,
-    0x842736dbUL, 0x96929935UL, 0x2e2efe50UL, 0x2654b999UL, 0x9ee8defcUL,
-    0x8c5d7112UL, 0x34e11677UL, 0xa9362eceUL, 0x118a49abUL, 0x033fe645UL,
-    0xbb838120UL, 0xe3e09176UL, 0x5b5cf613UL, 0x49e959fdUL, 0xf1553e98UL,
-    0x6c820621UL, 0xd43e6144UL, 0xc68bceaaUL, 0x7e37a9cfUL, 0xd67f4138UL,
-    0x6ec3265dUL, 0x7c7689b3UL, 0xc4caeed6UL, 0x591dd66fUL, 0xe1a1b10aUL,
-    0xf3141ee4UL, 0x4ba87981UL, 0x13cb69d7UL, 0xab770eb2UL, 0xb9c2a15cUL,
-    0x017ec639UL, 0x9ca9fe80UL, 0x241599e5UL, 0x36a0360bUL, 0x8e1c516eUL,
-    0x866616a7UL, 0x3eda71c2UL, 0x2c6fde2cUL, 0x94d3b949UL, 0x090481f0UL,
-    0xb1b8e695UL, 0xa30d497bUL, 0x1bb12e1eUL, 0x43d23e48UL, 0xfb6e592dUL,
-    0xe9dbf6c3UL, 0x516791a6UL, 0xccb0a91fUL, 0x740cce7aUL, 0x66b96194UL,
-    0xde0506f1UL
-  },
-  {
-    0x00000000UL, 0x96300777UL, 0x2c610eeeUL, 0xba510999UL, 0x19c46d07UL,
-    0x8ff46a70UL, 0x35a563e9UL, 0xa395649eUL, 0x3288db0eUL, 0xa4b8dc79UL,
-    0x1ee9d5e0UL, 0x88d9d297UL, 0x2b4cb609UL, 0xbd7cb17eUL, 0x072db8e7UL,
-    0x911dbf90UL, 0x6410b71dUL, 0xf220b06aUL, 0x4871b9f3UL, 0xde41be84UL,
-    0x7dd4da1aUL, 0xebe4dd6dUL, 0x51b5d4f4UL, 0xc785d383UL, 0x56986c13UL,
-    0xc0a86b64UL, 0x7af962fdUL, 0xecc9658aUL, 0x4f5c0114UL, 0xd96c0663UL,
-    0x633d0ffaUL, 0xf50d088dUL, 0xc8206e3bUL, 0x5e10694cUL, 0xe44160d5UL,
-    0x727167a2UL, 0xd1e4033cUL, 0x47d4044bUL, 0xfd850dd2UL, 0x6bb50aa5UL,
-    0xfaa8b535UL, 0x6c98b242UL, 0xd6c9bbdbUL, 0x40f9bcacUL, 0xe36cd832UL,
-    0x755cdf45UL, 0xcf0dd6dcUL, 0x593dd1abUL, 0xac30d926UL, 0x3a00de51UL,
-    0x8051d7c8UL, 0x1661d0bfUL, 0xb5f4b421UL, 0x23c4b356UL, 0x9995bacfUL,
-    0x0fa5bdb8UL, 0x9eb80228UL, 0x0888055fUL, 0xb2d90cc6UL, 0x24e90bb1UL,
-    0x877c6f2fUL, 0x114c6858UL, 0xab1d61c1UL, 0x3d2d66b6UL, 0x9041dc76UL,
-    0x0671db01UL, 0xbc20d298UL, 0x2a10d5efUL, 0x8985b171UL, 0x1fb5b606UL,
-    0xa5e4bf9fUL, 0x33d4b8e8UL, 0xa2c90778UL, 0x34f9000fUL, 0x8ea80996UL,
-    0x18980ee1UL, 0xbb0d6a7fUL, 0x2d3d6d08UL, 0x976c6491UL, 0x015c63e6UL,
-    0xf4516b6bUL, 0x62616c1cUL, 0xd8306585UL, 0x4e0062f2UL, 0xed95066cUL,
-    0x7ba5011bUL, 0xc1f40882UL, 0x57c40ff5UL, 0xc6d9b065UL, 0x50e9b712UL,
-    0xeab8be8bUL, 0x7c88b9fcUL, 0xdf1ddd62UL, 0x492dda15UL, 0xf37cd38cUL,
-    0x654cd4fbUL, 0x5861b24dUL, 0xce51b53aUL, 0x7400bca3UL, 0xe230bbd4UL,
-    0x41a5df4aUL, 0xd795d83dUL, 0x6dc4d1a4UL, 0xfbf4d6d3UL, 0x6ae96943UL,
-    0xfcd96e34UL, 0x468867adUL, 0xd0b860daUL, 0x732d0444UL, 0xe51d0333UL,
-    0x5f4c0aaaUL, 0xc97c0dddUL, 0x3c710550UL, 0xaa410227UL, 0x10100bbeUL,
-    0x86200cc9UL, 0x25b56857UL, 0xb3856f20UL, 0x09d466b9UL, 0x9fe461ceUL,
-    0x0ef9de5eUL, 0x98c9d929UL, 0x2298d0b0UL, 0xb4a8d7c7UL, 0x173db359UL,
-    0x810db42eUL, 0x3b5cbdb7UL, 0xad6cbac0UL, 0x2083b8edUL, 0xb6b3bf9aUL,
-    0x0ce2b603UL, 0x9ad2b174UL, 0x3947d5eaUL, 0xaf77d29dUL, 0x1526db04UL,
-    0x8316dc73UL, 0x120b63e3UL, 0x843b6494UL, 0x3e6a6d0dUL, 0xa85a6a7aUL,
-    0x0bcf0ee4UL, 0x9dff0993UL, 0x27ae000aUL, 0xb19e077dUL, 0x44930ff0UL,
-    0xd2a30887UL, 0x68f2011eUL, 0xfec20669UL, 0x5d5762f7UL, 0xcb676580UL,
-    0x71366c19UL, 0xe7066b6eUL, 0x761bd4feUL, 0xe02bd389UL, 0x5a7ada10UL,
-    0xcc4add67UL, 0x6fdfb9f9UL, 0xf9efbe8eUL, 0x43beb717UL, 0xd58eb060UL,
-    0xe8a3d6d6UL, 0x7e93d1a1UL, 0xc4c2d838UL, 0x52f2df4fUL, 0xf167bbd1UL,
-    0x6757bca6UL, 0xdd06b53fUL, 0x4b36b248UL, 0xda2b0dd8UL, 0x4c1b0aafUL,
-    0xf64a0336UL, 0x607a0441UL, 0xc3ef60dfUL, 0x55df67a8UL, 0xef8e6e31UL,
-    0x79be6946UL, 0x8cb361cbUL, 0x1a8366bcUL, 0xa0d26f25UL, 0x36e26852UL,
-    0x95770cccUL, 0x03470bbbUL, 0xb9160222UL, 0x2f260555UL, 0xbe3bbac5UL,
-    0x280bbdb2UL, 0x925ab42bUL, 0x046ab35cUL, 0xa7ffd7c2UL, 0x31cfd0b5UL,
-    0x8b9ed92cUL, 0x1daede5bUL, 0xb0c2649bUL, 0x26f263ecUL, 0x9ca36a75UL,
-    0x0a936d02UL, 0xa906099cUL, 0x3f360eebUL, 0x85670772UL, 0x13570005UL,
-    0x824abf95UL, 0x147ab8e2UL, 0xae2bb17bUL, 0x381bb60cUL, 0x9b8ed292UL,
-    0x0dbed5e5UL, 0xb7efdc7cUL, 0x21dfdb0bUL, 0xd4d2d386UL, 0x42e2d4f1UL,
-    0xf8b3dd68UL, 0x6e83da1fUL, 0xcd16be81UL, 0x5b26b9f6UL, 0xe177b06fUL,
-    0x7747b718UL, 0xe65a0888UL, 0x706a0fffUL, 0xca3b0666UL, 0x5c0b0111UL,
-    0xff9e658fUL, 0x69ae62f8UL, 0xd3ff6b61UL, 0x45cf6c16UL, 0x78e20aa0UL,
-    0xeed20dd7UL, 0x5483044eUL, 0xc2b30339UL, 0x612667a7UL, 0xf71660d0UL,
-    0x4d476949UL, 0xdb776e3eUL, 0x4a6ad1aeUL, 0xdc5ad6d9UL, 0x660bdf40UL,
-    0xf03bd837UL, 0x53aebca9UL, 0xc59ebbdeUL, 0x7fcfb247UL, 0xe9ffb530UL,
-    0x1cf2bdbdUL, 0x8ac2bacaUL, 0x3093b353UL, 0xa6a3b424UL, 0x0536d0baUL,
-    0x9306d7cdUL, 0x2957de54UL, 0xbf67d923UL, 0x2e7a66b3UL, 0xb84a61c4UL,
-    0x021b685dUL, 0x942b6f2aUL, 0x37be0bb4UL, 0xa18e0cc3UL, 0x1bdf055aUL,
-    0x8def022dUL
-  },
-  {
-    0x00000000UL, 0x41311b19UL, 0x82623632UL, 0xc3532d2bUL, 0x04c56c64UL,
-    0x45f4777dUL, 0x86a75a56UL, 0xc796414fUL, 0x088ad9c8UL, 0x49bbc2d1UL,
-    0x8ae8effaUL, 0xcbd9f4e3UL, 0x0c4fb5acUL, 0x4d7eaeb5UL, 0x8e2d839eUL,
-    0xcf1c9887UL, 0x5112c24aUL, 0x1023d953UL, 0xd370f478UL, 0x9241ef61UL,
-    0x55d7ae2eUL, 0x14e6b537UL, 0xd7b5981cUL, 0x96848305UL, 0x59981b82UL,
-    0x18a9009bUL, 0xdbfa2db0UL, 0x9acb36a9UL, 0x5d5d77e6UL, 0x1c6c6cffUL,
-    0xdf3f41d4UL, 0x9e0e5acdUL, 0xa2248495UL, 0xe3159f8cUL, 0x2046b2a7UL,
-    0x6177a9beUL, 0xa6e1e8f1UL, 0xe7d0f3e8UL, 0x2483dec3UL, 0x65b2c5daUL,
-    0xaaae5d5dUL, 0xeb9f4644UL, 0x28cc6b6fUL, 0x69fd7076UL, 0xae6b3139UL,
-    0xef5a2a20UL, 0x2c09070bUL, 0x6d381c12UL, 0xf33646dfUL, 0xb2075dc6UL,
-    0x715470edUL, 0x30656bf4UL, 0xf7f32abbUL, 0xb6c231a2UL, 0x75911c89UL,
-    0x34a00790UL, 0xfbbc9f17UL, 0xba8d840eUL, 0x79dea925UL, 0x38efb23cUL,
-    0xff79f373UL, 0xbe48e86aUL, 0x7d1bc541UL, 0x3c2ade58UL, 0x054f79f0UL,
-    0x447e62e9UL, 0x872d4fc2UL, 0xc61c54dbUL, 0x018a1594UL, 0x40bb0e8dUL,
-    0x83e823a6UL, 0xc2d938bfUL, 0x0dc5a038UL, 0x4cf4bb21UL, 0x8fa7960aUL,
-    0xce968d13UL, 0x0900cc5cUL, 0x4831d745UL, 0x8b62fa6eUL, 0xca53e177UL,
-    0x545dbbbaUL, 0x156ca0a3UL, 0xd63f8d88UL, 0x970e9691UL, 0x5098d7deUL,
-    0x11a9ccc7UL, 0xd2fae1ecUL, 0x93cbfaf5UL, 0x5cd76272UL, 0x1de6796bUL,
-    0xdeb55440UL, 0x9f844f59UL, 0x58120e16UL, 0x1923150fUL, 0xda703824UL,
-    0x9b41233dUL, 0xa76bfd65UL, 0xe65ae67cUL, 0x2509cb57UL, 0x6438d04eUL,
-    0xa3ae9101UL, 0xe29f8a18UL, 0x21cca733UL, 0x60fdbc2aUL, 0xafe124adUL,
-    0xeed03fb4UL, 0x2d83129fUL, 0x6cb20986UL, 0xab2448c9UL, 0xea1553d0UL,
-    0x29467efbUL, 0x687765e2UL, 0xf6793f2fUL, 0xb7482436UL, 0x741b091dUL,
-    0x352a1204UL, 0xf2bc534bUL, 0xb38d4852UL, 0x70de6579UL, 0x31ef7e60UL,
-    0xfef3e6e7UL, 0xbfc2fdfeUL, 0x7c91d0d5UL, 0x3da0cbccUL, 0xfa368a83UL,
-    0xbb07919aUL, 0x7854bcb1UL, 0x3965a7a8UL, 0x4b98833bUL, 0x0aa99822UL,
-    0xc9fab509UL, 0x88cbae10UL, 0x4f5def5fUL, 0x0e6cf446UL, 0xcd3fd96dUL,
-    0x8c0ec274UL, 0x43125af3UL, 0x022341eaUL, 0xc1706cc1UL, 0x804177d8UL,
-    0x47d73697UL, 0x06e62d8eUL, 0xc5b500a5UL, 0x84841bbcUL, 0x1a8a4171UL,
-    0x5bbb5a68UL, 0x98e87743UL, 0xd9d96c5aUL, 0x1e4f2d15UL, 0x5f7e360cUL,
-    0x9c2d1b27UL, 0xdd1c003eUL, 0x120098b9UL, 0x533183a0UL, 0x9062ae8bUL,
-    0xd153b592UL, 0x16c5f4ddUL, 0x57f4efc4UL, 0x94a7c2efUL, 0xd596d9f6UL,
-    0xe9bc07aeUL, 0xa88d1cb7UL, 0x6bde319cUL, 0x2aef2a85UL, 0xed796bcaUL,
-    0xac4870d3UL, 0x6f1b5df8UL, 0x2e2a46e1UL, 0xe136de66UL, 0xa007c57fUL,
-    0x6354e854UL, 0x2265f34dUL, 0xe5f3b202UL, 0xa4c2a91bUL, 0x67918430UL,
-    0x26a09f29UL, 0xb8aec5e4UL, 0xf99fdefdUL, 0x3accf3d6UL, 0x7bfde8cfUL,
-    0xbc6ba980UL, 0xfd5ab299UL, 0x3e099fb2UL, 0x7f3884abUL, 0xb0241c2cUL,
-    0xf1150735UL, 0x32462a1eUL, 0x73773107UL, 0xb4e17048UL, 0xf5d06b51UL,
-    0x3683467aUL, 0x77b25d63UL, 0x4ed7facbUL, 0x0fe6e1d2UL, 0xccb5ccf9UL,
-    0x8d84d7e0UL, 0x4a1296afUL, 0x0b238db6UL, 0xc870a09dUL, 0x8941bb84UL,
-    0x465d2303UL, 0x076c381aUL, 0xc43f1531UL, 0x850e0e28UL, 0x42984f67UL,
-    0x03a9547eUL, 0xc0fa7955UL, 0x81cb624cUL, 0x1fc53881UL, 0x5ef42398UL,
-    0x9da70eb3UL, 0xdc9615aaUL, 0x1b0054e5UL, 0x5a314ffcUL, 0x996262d7UL,
-    0xd85379ceUL, 0x174fe149UL, 0x567efa50UL, 0x952dd77bUL, 0xd41ccc62UL,
-    0x138a8d2dUL, 0x52bb9634UL, 0x91e8bb1fUL, 0xd0d9a006UL, 0xecf37e5eUL,
-    0xadc26547UL, 0x6e91486cUL, 0x2fa05375UL, 0xe836123aUL, 0xa9070923UL,
-    0x6a542408UL, 0x2b653f11UL, 0xe479a796UL, 0xa548bc8fUL, 0x661b91a4UL,
-    0x272a8abdUL, 0xe0bccbf2UL, 0xa18dd0ebUL, 0x62defdc0UL, 0x23efe6d9UL,
-    0xbde1bc14UL, 0xfcd0a70dUL, 0x3f838a26UL, 0x7eb2913fUL, 0xb924d070UL,
-    0xf815cb69UL, 0x3b46e642UL, 0x7a77fd5bUL, 0xb56b65dcUL, 0xf45a7ec5UL,
-    0x370953eeUL, 0x763848f7UL, 0xb1ae09b8UL, 0xf09f12a1UL, 0x33cc3f8aUL,
-    0x72fd2493UL
-  },
-  {
-    0x00000000UL, 0x376ac201UL, 0x6ed48403UL, 0x59be4602UL, 0xdca80907UL,
-    0xebc2cb06UL, 0xb27c8d04UL, 0x85164f05UL, 0xb851130eUL, 0x8f3bd10fUL,
-    0xd685970dUL, 0xe1ef550cUL, 0x64f91a09UL, 0x5393d808UL, 0x0a2d9e0aUL,
-    0x3d475c0bUL, 0x70a3261cUL, 0x47c9e41dUL, 0x1e77a21fUL, 0x291d601eUL,
-    0xac0b2f1bUL, 0x9b61ed1aUL, 0xc2dfab18UL, 0xf5b56919UL, 0xc8f23512UL,
-    0xff98f713UL, 0xa626b111UL, 0x914c7310UL, 0x145a3c15UL, 0x2330fe14UL,
-    0x7a8eb816UL, 0x4de47a17UL, 0xe0464d38UL, 0xd72c8f39UL, 0x8e92c93bUL,
-    0xb9f80b3aUL, 0x3cee443fUL, 0x0b84863eUL, 0x523ac03cUL, 0x6550023dUL,
-    0x58175e36UL, 0x6f7d9c37UL, 0x36c3da35UL, 0x01a91834UL, 0x84bf5731UL,
-    0xb3d59530UL, 0xea6bd332UL, 0xdd011133UL, 0x90e56b24UL, 0xa78fa925UL,
-    0xfe31ef27UL, 0xc95b2d26UL, 0x4c4d6223UL, 0x7b27a022UL, 0x2299e620UL,
-    0x15f32421UL, 0x28b4782aUL, 0x1fdeba2bUL, 0x4660fc29UL, 0x710a3e28UL,
-    0xf41c712dUL, 0xc376b32cUL, 0x9ac8f52eUL, 0xada2372fUL, 0xc08d9a70UL,
-    0xf7e75871UL, 0xae591e73UL, 0x9933dc72UL, 0x1c259377UL, 0x2b4f5176UL,
-    0x72f11774UL, 0x459bd575UL, 0x78dc897eUL, 0x4fb64b7fUL, 0x16080d7dUL,
-    0x2162cf7cUL, 0xa4748079UL, 0x931e4278UL, 0xcaa0047aUL, 0xfdcac67bUL,
-    0xb02ebc6cUL, 0x87447e6dUL, 0xdefa386fUL, 0xe990fa6eUL, 0x6c86b56bUL,
-    0x5bec776aUL, 0x02523168UL, 0x3538f369UL, 0x087faf62UL, 0x3f156d63UL,
-    0x66ab2b61UL, 0x51c1e960UL, 0xd4d7a665UL, 0xe3bd6464UL, 0xba032266UL,
-    0x8d69e067UL, 0x20cbd748UL, 0x17a11549UL, 0x4e1f534bUL, 0x7975914aUL,
-    0xfc63de4fUL, 0xcb091c4eUL, 0x92b75a4cUL, 0xa5dd984dUL, 0x989ac446UL,
-    0xaff00647UL, 0xf64e4045UL, 0xc1248244UL, 0x4432cd41UL, 0x73580f40UL,
-    0x2ae64942UL, 0x1d8c8b43UL, 0x5068f154UL, 0x67023355UL, 0x3ebc7557UL,
-    0x09d6b756UL, 0x8cc0f853UL, 0xbbaa3a52UL, 0xe2147c50UL, 0xd57ebe51UL,
-    0xe839e25aUL, 0xdf53205bUL, 0x86ed6659UL, 0xb187a458UL, 0x3491eb5dUL,
-    0x03fb295cUL, 0x5a456f5eUL, 0x6d2fad5fUL, 0x801b35e1UL, 0xb771f7e0UL,
-    0xeecfb1e2UL, 0xd9a573e3UL, 0x5cb33ce6UL, 0x6bd9fee7UL, 0x3267b8e5UL,
-    0x050d7ae4UL, 0x384a26efUL, 0x0f20e4eeUL, 0x569ea2ecUL, 0x61f460edUL,
-    0xe4e22fe8UL, 0xd388ede9UL, 0x8a36abebUL, 0xbd5c69eaUL, 0xf0b813fdUL,
-    0xc7d2d1fcUL, 0x9e6c97feUL, 0xa90655ffUL, 0x2c101afaUL, 0x1b7ad8fbUL,
-    0x42c49ef9UL, 0x75ae5cf8UL, 0x48e900f3UL, 0x7f83c2f2UL, 0x263d84f0UL,
-    0x115746f1UL, 0x944109f4UL, 0xa32bcbf5UL, 0xfa958df7UL, 0xcdff4ff6UL,
-    0x605d78d9UL, 0x5737bad8UL, 0x0e89fcdaUL, 0x39e33edbUL, 0xbcf571deUL,
-    0x8b9fb3dfUL, 0xd221f5ddUL, 0xe54b37dcUL, 0xd80c6bd7UL, 0xef66a9d6UL,
-    0xb6d8efd4UL, 0x81b22dd5UL, 0x04a462d0UL, 0x33cea0d1UL, 0x6a70e6d3UL,
-    0x5d1a24d2UL, 0x10fe5ec5UL, 0x27949cc4UL, 0x7e2adac6UL, 0x494018c7UL,
-    0xcc5657c2UL, 0xfb3c95c3UL, 0xa282d3c1UL, 0x95e811c0UL, 0xa8af4dcbUL,
-    0x9fc58fcaUL, 0xc67bc9c8UL, 0xf1110bc9UL, 0x740744ccUL, 0x436d86cdUL,
-    0x1ad3c0cfUL, 0x2db902ceUL, 0x4096af91UL, 0x77fc6d90UL, 0x2e422b92UL,
-    0x1928e993UL, 0x9c3ea696UL, 0xab546497UL, 0xf2ea2295UL, 0xc580e094UL,
-    0xf8c7bc9fUL, 0xcfad7e9eUL, 0x9613389cUL, 0xa179fa9dUL, 0x246fb598UL,
-    0x13057799UL, 0x4abb319bUL, 0x7dd1f39aUL, 0x3035898dUL, 0x075f4b8cUL,
-    0x5ee10d8eUL, 0x698bcf8fUL, 0xec9d808aUL, 0xdbf7428bUL, 0x82490489UL,
-    0xb523c688UL, 0x88649a83UL, 0xbf0e5882UL, 0xe6b01e80UL, 0xd1dadc81UL,
-    0x54cc9384UL, 0x63a65185UL, 0x3a181787UL, 0x0d72d586UL, 0xa0d0e2a9UL,
-    0x97ba20a8UL, 0xce0466aaUL, 0xf96ea4abUL, 0x7c78ebaeUL, 0x4b1229afUL,
-    0x12ac6fadUL, 0x25c6adacUL, 0x1881f1a7UL, 0x2feb33a6UL, 0x765575a4UL,
-    0x413fb7a5UL, 0xc429f8a0UL, 0xf3433aa1UL, 0xaafd7ca3UL, 0x9d97bea2UL,
-    0xd073c4b5UL, 0xe71906b4UL, 0xbea740b6UL, 0x89cd82b7UL, 0x0cdbcdb2UL,
-    0x3bb10fb3UL, 0x620f49b1UL, 0x55658bb0UL, 0x6822d7bbUL, 0x5f4815baUL,
-    0x06f653b8UL, 0x319c91b9UL, 0xb48adebcUL, 0x83e01cbdUL, 0xda5e5abfUL,
-    0xed3498beUL
-  },
-  {
-    0x00000000UL, 0x6567bcb8UL, 0x8bc809aaUL, 0xeeafb512UL, 0x5797628fUL,
-    0x32f0de37UL, 0xdc5f6b25UL, 0xb938d79dUL, 0xef28b4c5UL, 0x8a4f087dUL,
-    0x64e0bd6fUL, 0x018701d7UL, 0xb8bfd64aUL, 0xddd86af2UL, 0x3377dfe0UL,
-    0x56106358UL, 0x9f571950UL, 0xfa30a5e8UL, 0x149f10faUL, 0x71f8ac42UL,
-    0xc8c07bdfUL, 0xada7c767UL, 0x43087275UL, 0x266fcecdUL, 0x707fad95UL,
-    0x1518112dUL, 0xfbb7a43fUL, 0x9ed01887UL, 0x27e8cf1aUL, 0x428f73a2UL,
-    0xac20c6b0UL, 0xc9477a08UL, 0x3eaf32a0UL, 0x5bc88e18UL, 0xb5673b0aUL,
-    0xd00087b2UL, 0x6938502fUL, 0x0c5fec97UL, 0xe2f05985UL, 0x8797e53dUL,
-    0xd1878665UL, 0xb4e03addUL, 0x5a4f8fcfUL, 0x3f283377UL, 0x8610e4eaUL,
-    0xe3775852UL, 0x0dd8ed40UL, 0x68bf51f8UL, 0xa1f82bf0UL, 0xc49f9748UL,
-    0x2a30225aUL, 0x4f579ee2UL, 0xf66f497fUL, 0x9308f5c7UL, 0x7da740d5UL,
-    0x18c0fc6dUL, 0x4ed09f35UL, 0x2bb7238dUL, 0xc518969fUL, 0xa07f2a27UL,
-    0x1947fdbaUL, 0x7c204102UL, 0x928ff410UL, 0xf7e848a8UL, 0x3d58149bUL,
-    0x583fa823UL, 0xb6901d31UL, 0xd3f7a189UL, 0x6acf7614UL, 0x0fa8caacUL,
-    0xe1077fbeUL, 0x8460c306UL, 0xd270a05eUL, 0xb7171ce6UL, 0x59b8a9f4UL,
-    0x3cdf154cUL, 0x85e7c2d1UL, 0xe0807e69UL, 0x0e2fcb7bUL, 0x6b4877c3UL,
-    0xa20f0dcbUL, 0xc768b173UL, 0x29c70461UL, 0x4ca0b8d9UL, 0xf5986f44UL,
-    0x90ffd3fcUL, 0x7e5066eeUL, 0x1b37da56UL, 0x4d27b90eUL, 0x284005b6UL,
-    0xc6efb0a4UL, 0xa3880c1cUL, 0x1ab0db81UL, 0x7fd76739UL, 0x9178d22bUL,
-    0xf41f6e93UL, 0x03f7263bUL, 0x66909a83UL, 0x883f2f91UL, 0xed589329UL,
-    0x546044b4UL, 0x3107f80cUL, 0xdfa84d1eUL, 0xbacff1a6UL, 0xecdf92feUL,
-    0x89b82e46UL, 0x67179b54UL, 0x027027ecUL, 0xbb48f071UL, 0xde2f4cc9UL,
-    0x3080f9dbUL, 0x55e74563UL, 0x9ca03f6bUL, 0xf9c783d3UL, 0x176836c1UL,
-    0x720f8a79UL, 0xcb375de4UL, 0xae50e15cUL, 0x40ff544eUL, 0x2598e8f6UL,
-    0x73888baeUL, 0x16ef3716UL, 0xf8408204UL, 0x9d273ebcUL, 0x241fe921UL,
-    0x41785599UL, 0xafd7e08bUL, 0xcab05c33UL, 0x3bb659edUL, 0x5ed1e555UL,
-    0xb07e5047UL, 0xd519ecffUL, 0x6c213b62UL, 0x094687daUL, 0xe7e932c8UL,
-    0x828e8e70UL, 0xd49eed28UL, 0xb1f95190UL, 0x5f56e482UL, 0x3a31583aUL,
-    0x83098fa7UL, 0xe66e331fUL, 0x08c1860dUL, 0x6da63ab5UL, 0xa4e140bdUL,
-    0xc186fc05UL, 0x2f294917UL, 0x4a4ef5afUL, 0xf3762232UL, 0x96119e8aUL,
-    0x78be2b98UL, 0x1dd99720UL, 0x4bc9f478UL, 0x2eae48c0UL, 0xc001fdd2UL,
-    0xa566416aUL, 0x1c5e96f7UL, 0x79392a4fUL, 0x97969f5dUL, 0xf2f123e5UL,
-    0x05196b4dUL, 0x607ed7f5UL, 0x8ed162e7UL, 0xebb6de5fUL, 0x528e09c2UL,
-    0x37e9b57aUL, 0xd9460068UL, 0xbc21bcd0UL, 0xea31df88UL, 0x8f566330UL,
-    0x61f9d622UL, 0x049e6a9aUL, 0xbda6bd07UL, 0xd8c101bfUL, 0x366eb4adUL,
-    0x53090815UL, 0x9a4e721dUL, 0xff29cea5UL, 0x11867bb7UL, 0x74e1c70fUL,
-    0xcdd91092UL, 0xa8beac2aUL, 0x46111938UL, 0x2376a580UL, 0x7566c6d8UL,
-    0x10017a60UL, 0xfeaecf72UL, 0x9bc973caUL, 0x22f1a457UL, 0x479618efUL,
-    0xa939adfdUL, 0xcc5e1145UL, 0x06ee4d76UL, 0x6389f1ceUL, 0x8d2644dcUL,
-    0xe841f864UL, 0x51792ff9UL, 0x341e9341UL, 0xdab12653UL, 0xbfd69aebUL,
-    0xe9c6f9b3UL, 0x8ca1450bUL, 0x620ef019UL, 0x07694ca1UL, 0xbe519b3cUL,
-    0xdb362784UL, 0x35999296UL, 0x50fe2e2eUL, 0x99b95426UL, 0xfcdee89eUL,
-    0x12715d8cUL, 0x7716e134UL, 0xce2e36a9UL, 0xab498a11UL, 0x45e63f03UL,
-    0x208183bbUL, 0x7691e0e3UL, 0x13f65c5bUL, 0xfd59e949UL, 0x983e55f1UL,
-    0x2106826cUL, 0x44613ed4UL, 0xaace8bc6UL, 0xcfa9377eUL, 0x38417fd6UL,
-    0x5d26c36eUL, 0xb389767cUL, 0xd6eecac4UL, 0x6fd61d59UL, 0x0ab1a1e1UL,
-    0xe41e14f3UL, 0x8179a84bUL, 0xd769cb13UL, 0xb20e77abUL, 0x5ca1c2b9UL,
-    0x39c67e01UL, 0x80fea99cUL, 0xe5991524UL, 0x0b36a036UL, 0x6e511c8eUL,
-    0xa7166686UL, 0xc271da3eUL, 0x2cde6f2cUL, 0x49b9d394UL, 0xf0810409UL,
-    0x95e6b8b1UL, 0x7b490da3UL, 0x1e2eb11bUL, 0x483ed243UL, 0x2d596efbUL,
-    0xc3f6dbe9UL, 0xa6916751UL, 0x1fa9b0ccUL, 0x7ace0c74UL, 0x9461b966UL,
-    0xf10605deUL
-#endif
-  }
-};
diff -Nbaur gcc-4.8.1/zlib/deflate.c gcc-4.8.1-ppc/zlib/deflate.c
--- gcc-4.8.1/zlib/deflate.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/deflate.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1965 +0,0 @@
-/* deflate.c -- compress data using the deflation algorithm
- * Copyright (C) 1995-2012 Jean-loup Gailly and Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- *  ALGORITHM
- *
- *      The "deflation" process depends on being able to identify portions
- *      of the input text which are identical to earlier input (within a
- *      sliding window trailing behind the input currently being processed).
- *
- *      The most straightforward technique turns out to be the fastest for
- *      most input files: try all possible matches and select the longest.
- *      The key feature of this algorithm is that insertions into the string
- *      dictionary are very simple and thus fast, and deletions are avoided
- *      completely. Insertions are performed at each input character, whereas
- *      string matches are performed only when the previous match ends. So it
- *      is preferable to spend more time in matches to allow very fast string
- *      insertions and avoid deletions. The matching algorithm for small
- *      strings is inspired from that of Rabin & Karp. A brute force approach
- *      is used to find longer strings when a small match has been found.
- *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
- *      (by Leonid Broukhis).
- *         A previous version of this file used a more sophisticated algorithm
- *      (by Fiala and Greene) which is guaranteed to run in linear amortized
- *      time, but has a larger average cost, uses more memory and is patented.
- *      However the F&G algorithm may be faster for some highly redundant
- *      files if the parameter max_chain_length (described below) is too large.
- *
- *  ACKNOWLEDGEMENTS
- *
- *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
- *      I found it in 'freeze' written by Leonid Broukhis.
- *      Thanks to many people for bug reports and testing.
- *
- *  REFERENCES
- *
- *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
- *      Available in http://tools.ietf.org/html/rfc1951
- *
- *      A description of the Rabin and Karp algorithm is given in the book
- *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
- *
- *      Fiala,E.R., and Greene,D.H.
- *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
- *
- */
-
-/* @(#) $Id: deflate.c,v 1.1.1.2 2002/03/11 21:53:23 tromey Exp $ */
-
-#include "deflate.h"
-
-const char deflate_copyright[] =
-   " deflate 1.2.7 Copyright 1995-2012 Jean-loup Gailly and Mark Adler ";
-/*
-  If you use the zlib library in a product, an acknowledgment is welcome
-  in the documentation of your product. If for some reason you cannot
-  include such an acknowledgment, I would appreciate that you keep this
-  copyright string in the executable of your product.
- */
-
-/* ===========================================================================
- *  Function prototypes.
- */
-typedef enum {
-    need_more,      /* block not completed, need more input or more output */
-    block_done,     /* block flush performed */
-    finish_started, /* finish started, need only more output at next deflate */
-    finish_done     /* finish done, accept no more input or output */
-} block_state;
-
-typedef block_state (*compress_func) OF((deflate_state *s, int flush));
-/* Compression function. Returns the block state after the call. */
-
-local void fill_window    OF((deflate_state *s));
-local block_state deflate_stored OF((deflate_state *s, int flush));
-local block_state deflate_fast   OF((deflate_state *s, int flush));
-#ifndef FASTEST
-local block_state deflate_slow   OF((deflate_state *s, int flush));
-#endif
-local block_state deflate_rle    OF((deflate_state *s, int flush));
-local block_state deflate_huff   OF((deflate_state *s, int flush));
-local void lm_init        OF((deflate_state *s));
-local void putShortMSB    OF((deflate_state *s, uInt b));
-local void flush_pending  OF((z_streamp strm));
-local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
-#ifdef ASMV
-      void match_init OF((void)); /* asm code initialization */
-      uInt longest_match  OF((deflate_state *s, IPos cur_match));
-#else
-local uInt longest_match  OF((deflate_state *s, IPos cur_match));
-#endif
-
-#ifdef DEBUG
-local  void check_match OF((deflate_state *s, IPos start, IPos match,
-                            int length));
-#endif
-
-/* ===========================================================================
- * Local data
- */
-
-#define NIL 0
-/* Tail of hash chains */
-
-#ifndef TOO_FAR
-#  define TOO_FAR 4096
-#endif
-/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
-
-/* Values for max_lazy_match, good_match and max_chain_length, depending on
- * the desired pack level (0..9). The values given below have been tuned to
- * exclude worst case performance for pathological files. Better values may be
- * found for specific files.
- */
-typedef struct config_s {
-   ush good_length; /* reduce lazy search above this match length */
-   ush max_lazy;    /* do not perform lazy search above this match length */
-   ush nice_length; /* quit search above this match length */
-   ush max_chain;
-   compress_func func;
-} config;
-
-#ifdef FASTEST
-local const config configuration_table[2] = {
-/*      good lazy nice chain */
-/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
-/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
-#else
-local const config configuration_table[10] = {
-/*      good lazy nice chain */
-/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
-/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
-/* 2 */ {4,    5, 16,    8, deflate_fast},
-/* 3 */ {4,    6, 32,   32, deflate_fast},
-
-/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
-/* 5 */ {8,   16, 32,   32, deflate_slow},
-/* 6 */ {8,   16, 128, 128, deflate_slow},
-/* 7 */ {8,   32, 128, 256, deflate_slow},
-/* 8 */ {32, 128, 258, 1024, deflate_slow},
-/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
-#endif
-
-/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
- * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
- * meaning.
- */
-
-#define EQUAL 0
-/* result of memcmp for equal strings */
-
-#ifndef NO_DUMMY_DECL
-struct static_tree_desc_s {int dummy;}; /* for buggy compilers */
-#endif
-
-/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */
-#define RANK(f) (((f) << 1) - ((f) > 4 ? 9 : 0))
-
-/* ===========================================================================
- * Update a hash value with the given input byte
- * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
- *    input characters, so that a running hash key can be computed from the
- *    previous key instead of complete recalculation each time.
- */
-#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)
-
-
-/* ===========================================================================
- * Insert string str in the dictionary and set match_head to the previous head
- * of the hash chain (the most recent string with same hash key). Return
- * the previous length of the hash chain.
- * If this file is compiled with -DFASTEST, the compression level is forced
- * to 1, and no hash chains are maintained.
- * IN  assertion: all calls to to INSERT_STRING are made with consecutive
- *    input characters and the first MIN_MATCH bytes of str are valid
- *    (except for the last MIN_MATCH-1 bytes of the input file).
- */
-#ifdef FASTEST
-#define INSERT_STRING(s, str, match_head) \
-   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
-    match_head = s->head[s->ins_h], \
-    s->head[s->ins_h] = (Pos)(str))
-#else
-#define INSERT_STRING(s, str, match_head) \
-   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
-    match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \
-    s->head[s->ins_h] = (Pos)(str))
-#endif
-
-/* ===========================================================================
- * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
- * prev[] will be initialized on the fly.
- */
-#define CLEAR_HASH(s) \
-    s->head[s->hash_size-1] = NIL; \
-    zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));
-
-/* ========================================================================= */
-int ZEXPORT deflateInit_(strm, level, version, stream_size)
-    z_streamp strm;
-    int level;
-    const char *version;
-    int stream_size;
-{
-    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
-                         Z_DEFAULT_STRATEGY, version, stream_size);
-    /* To do: ignore strm->next_in if we use it as window */
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
-                  version, stream_size)
-    z_streamp strm;
-    int  level;
-    int  method;
-    int  windowBits;
-    int  memLevel;
-    int  strategy;
-    const char *version;
-    int stream_size;
-{
-    deflate_state *s;
-    int wrap = 1;
-    static const char my_version[] = ZLIB_VERSION;
-
-    ushf *overlay;
-    /* We overlay pending_buf and d_buf+l_buf. This works since the average
-     * output size for (length,distance) codes is <= 24 bits.
-     */
-
-    if (version == Z_NULL || version[0] != my_version[0] ||
-        stream_size != sizeof(z_stream)) {
-        return Z_VERSION_ERROR;
-    }
-    if (strm == Z_NULL) return Z_STREAM_ERROR;
-
-    strm->msg = Z_NULL;
-    if (strm->zalloc == (alloc_func)0) {
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-#endif
-    }
-    if (strm->zfree == (free_func)0)
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zfree = zcfree;
-#endif
-
-#ifdef FASTEST
-    if (level != 0) level = 1;
-#else
-    if (level == Z_DEFAULT_COMPRESSION) level = 6;
-#endif
-
-    if (windowBits < 0) { /* suppress zlib wrapper */
-        wrap = 0;
-        windowBits = -windowBits;
-    }
-#ifdef GZIP
-    else if (windowBits > 15) {
-        wrap = 2;       /* write gzip wrapper instead */
-        windowBits -= 16;
-    }
-#endif
-    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
-        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
-        strategy < 0 || strategy > Z_FIXED) {
-        return Z_STREAM_ERROR;
-    }
-    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
-    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
-    if (s == Z_NULL) return Z_MEM_ERROR;
-    strm->state = (struct internal_state FAR *)s;
-    s->strm = strm;
-
-    s->wrap = wrap;
-    s->gzhead = Z_NULL;
-    s->w_bits = windowBits;
-    s->w_size = 1 << s->w_bits;
-    s->w_mask = s->w_size - 1;
-
-    s->hash_bits = memLevel + 7;
-    s->hash_size = 1 << s->hash_bits;
-    s->hash_mask = s->hash_size - 1;
-    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
-
-    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
-    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
-    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
-
-    s->high_water = 0;      /* nothing written to s->window yet */
-
-    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
-
-    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
-    s->pending_buf = (uchf *) overlay;
-    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);
-
-    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
-        s->pending_buf == Z_NULL) {
-        s->status = FINISH_STATE;
-        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);
-        deflateEnd (strm);
-        return Z_MEM_ERROR;
-    }
-    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
-    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
-
-    s->level = level;
-    s->strategy = strategy;
-    s->method = (Byte)method;
-
-    return deflateReset(strm);
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
-    z_streamp strm;
-    const Bytef *dictionary;
-    uInt  dictLength;
-{
-    deflate_state *s;
-    uInt str, n;
-    int wrap;
-    unsigned avail;
-    unsigned char *next;
-
-    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL)
-        return Z_STREAM_ERROR;
-    s = strm->state;
-    wrap = s->wrap;
-    if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)
-        return Z_STREAM_ERROR;
-
-    /* when using zlib wrappers, compute Adler-32 for provided dictionary */
-    if (wrap == 1)
-        strm->adler = adler32(strm->adler, dictionary, dictLength);
-    s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */
-
-    /* if dictionary would fill window, just replace the history */
-    if (dictLength >= s->w_size) {
-        if (wrap == 0) {            /* already empty otherwise */
-            CLEAR_HASH(s);
-            s->strstart = 0;
-            s->block_start = 0L;
-            s->insert = 0;
-        }
-        dictionary += dictLength - s->w_size;  /* use the tail */
-        dictLength = s->w_size;
-    }
-
-    /* insert dictionary into window and hash */
-    avail = strm->avail_in;
-    next = strm->next_in;
-    strm->avail_in = dictLength;
-    strm->next_in = (Bytef *)dictionary;
-    fill_window(s);
-    while (s->lookahead >= MIN_MATCH) {
-        str = s->strstart;
-        n = s->lookahead - (MIN_MATCH-1);
-        do {
-            UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
-#ifndef FASTEST
-            s->prev[str & s->w_mask] = s->head[s->ins_h];
-#endif
-            s->head[s->ins_h] = (Pos)str;
-            str++;
-        } while (--n);
-        s->strstart = str;
-        s->lookahead = MIN_MATCH-1;
-        fill_window(s);
-    }
-    s->strstart += s->lookahead;
-    s->block_start = (long)s->strstart;
-    s->insert = s->lookahead;
-    s->lookahead = 0;
-    s->match_length = s->prev_length = MIN_MATCH-1;
-    s->match_available = 0;
-    strm->next_in = next;
-    strm->avail_in = avail;
-    s->wrap = wrap;
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateResetKeep (strm)
-    z_streamp strm;
-{
-    deflate_state *s;
-
-    if (strm == Z_NULL || strm->state == Z_NULL ||
-        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {
-        return Z_STREAM_ERROR;
-    }
-
-    strm->total_in = strm->total_out = 0;
-    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
-    strm->data_type = Z_UNKNOWN;
-
-    s = (deflate_state *)strm->state;
-    s->pending = 0;
-    s->pending_out = s->pending_buf;
-
-    if (s->wrap < 0) {
-        s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */
-    }
-    s->status = s->wrap ? INIT_STATE : BUSY_STATE;
-    strm->adler =
-#ifdef GZIP
-        s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
-#endif
-        adler32(0L, Z_NULL, 0);
-    s->last_flush = Z_NO_FLUSH;
-
-    _tr_init(s);
-
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateReset (strm)
-    z_streamp strm;
-{
-    int ret;
-
-    ret = deflateResetKeep(strm);
-    if (ret == Z_OK)
-        lm_init(strm->state);
-    return ret;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateSetHeader (strm, head)
-    z_streamp strm;
-    gz_headerp head;
-{
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    if (strm->state->wrap != 2) return Z_STREAM_ERROR;
-    strm->state->gzhead = head;
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflatePending (strm, pending, bits)
-    unsigned *pending;
-    int *bits;
-    z_streamp strm;
-{
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    if (pending != Z_NULL)
-        *pending = strm->state->pending;
-    if (bits != Z_NULL)
-        *bits = strm->state->bi_valid;
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflatePrime (strm, bits, value)
-    z_streamp strm;
-    int bits;
-    int value;
-{
-    deflate_state *s;
-    int put;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    s = strm->state;
-    if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))
-        return Z_BUF_ERROR;
-    do {
-        put = Buf_size - s->bi_valid;
-        if (put > bits)
-            put = bits;
-        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);
-        s->bi_valid += put;
-        _tr_flush_bits(s);
-        value >>= put;
-        bits -= put;
-    } while (bits);
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateParams(strm, level, strategy)
-    z_streamp strm;
-    int level;
-    int strategy;
-{
-    deflate_state *s;
-    compress_func func;
-    int err = Z_OK;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    s = strm->state;
-
-#ifdef FASTEST
-    if (level != 0) level = 1;
-#else
-    if (level == Z_DEFAULT_COMPRESSION) level = 6;
-#endif
-    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
-        return Z_STREAM_ERROR;
-    }
-    func = configuration_table[s->level].func;
-
-    if ((strategy != s->strategy || func != configuration_table[level].func) &&
-        strm->total_in != 0) {
-        /* Flush the last buffer: */
-        err = deflate(strm, Z_BLOCK);
-    }
-    if (s->level != level) {
-        s->level = level;
-        s->max_lazy_match   = configuration_table[level].max_lazy;
-        s->good_match       = configuration_table[level].good_length;
-        s->nice_match       = configuration_table[level].nice_length;
-        s->max_chain_length = configuration_table[level].max_chain;
-    }
-    s->strategy = strategy;
-    return err;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)
-    z_streamp strm;
-    int good_length;
-    int max_lazy;
-    int nice_length;
-    int max_chain;
-{
-    deflate_state *s;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    s = strm->state;
-    s->good_match = good_length;
-    s->max_lazy_match = max_lazy;
-    s->nice_match = nice_length;
-    s->max_chain_length = max_chain;
-    return Z_OK;
-}
-
-/* =========================================================================
- * For the default windowBits of 15 and memLevel of 8, this function returns
- * a close to exact, as well as small, upper bound on the compressed size.
- * They are coded as constants here for a reason--if the #define's are
- * changed, then this function needs to be changed as well.  The return
- * value for 15 and 8 only works for those exact settings.
- *
- * For any setting other than those defaults for windowBits and memLevel,
- * the value returned is a conservative worst case for the maximum expansion
- * resulting from using fixed blocks instead of stored blocks, which deflate
- * can emit on compressed data for some combinations of the parameters.
- *
- * This function could be more sophisticated to provide closer upper bounds for
- * every combination of windowBits and memLevel.  But even the conservative
- * upper bound of about 14% expansion does not seem onerous for output buffer
- * allocation.
- */
-uLong ZEXPORT deflateBound(strm, sourceLen)
-    z_streamp strm;
-    uLong sourceLen;
-{
-    deflate_state *s;
-    uLong complen, wraplen;
-    Bytef *str;
-
-    /* conservative upper bound for compressed data */
-    complen = sourceLen +
-              ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;
-
-    /* if can't get parameters, return conservative bound plus zlib wrapper */
-    if (strm == Z_NULL || strm->state == Z_NULL)
-        return complen + 6;
-
-    /* compute wrapper length */
-    s = strm->state;
-    switch (s->wrap) {
-    case 0:                                 /* raw deflate */
-        wraplen = 0;
-        break;
-    case 1:                                 /* zlib wrapper */
-        wraplen = 6 + (s->strstart ? 4 : 0);
-        break;
-    case 2:                                 /* gzip wrapper */
-        wraplen = 18;
-        if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */
-            if (s->gzhead->extra != Z_NULL)
-                wraplen += 2 + s->gzhead->extra_len;
-            str = s->gzhead->name;
-            if (str != Z_NULL)
-                do {
-                    wraplen++;
-                } while (*str++);
-            str = s->gzhead->comment;
-            if (str != Z_NULL)
-                do {
-                    wraplen++;
-                } while (*str++);
-            if (s->gzhead->hcrc)
-                wraplen += 2;
-        }
-        break;
-    default:                                /* for compiler happiness */
-        wraplen = 6;
-    }
-
-    /* if not default parameters, return conservative bound */
-    if (s->w_bits != 15 || s->hash_bits != 8 + 7)
-        return complen + wraplen;
-
-    /* default settings: return tight bound for that case */
-    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
-           (sourceLen >> 25) + 13 - 6 + wraplen;
-}
-
-/* =========================================================================
- * Put a short in the pending buffer. The 16-bit value is put in MSB order.
- * IN assertion: the stream state is correct and there is enough room in
- * pending_buf.
- */
-local void putShortMSB (s, b)
-    deflate_state *s;
-    uInt b;
-{
-    put_byte(s, (Byte)(b >> 8));
-    put_byte(s, (Byte)(b & 0xff));
-}
-
-/* =========================================================================
- * Flush as much pending output as possible. All deflate() output goes
- * through this function so some applications may wish to modify it
- * to avoid allocating a large strm->next_out buffer and copying into it.
- * (See also read_buf()).
- */
-local void flush_pending(strm)
-    z_streamp strm;
-{
-    unsigned len;
-    deflate_state *s = strm->state;
-
-    _tr_flush_bits(s);
-    len = s->pending;
-    if (len > strm->avail_out) len = strm->avail_out;
-    if (len == 0) return;
-
-    zmemcpy(strm->next_out, s->pending_out, len);
-    strm->next_out  += len;
-    s->pending_out  += len;
-    strm->total_out += len;
-    strm->avail_out  -= len;
-    s->pending -= len;
-    if (s->pending == 0) {
-        s->pending_out = s->pending_buf;
-    }
-}
-
-/* ========================================================================= */
-int ZEXPORT deflate (strm, flush)
-    z_streamp strm;
-    int flush;
-{
-    int old_flush; /* value of flush param for previous deflate call */
-    deflate_state *s;
-
-    if (strm == Z_NULL || strm->state == Z_NULL ||
-        flush > Z_BLOCK || flush < 0) {
-        return Z_STREAM_ERROR;
-    }
-    s = strm->state;
-
-    if (strm->next_out == Z_NULL ||
-        (strm->next_in == Z_NULL && strm->avail_in != 0) ||
-        (s->status == FINISH_STATE && flush != Z_FINISH)) {
-        ERR_RETURN(strm, Z_STREAM_ERROR);
-    }
-    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
-
-    s->strm = strm; /* just in case */
-    old_flush = s->last_flush;
-    s->last_flush = flush;
-
-    /* Write the header */
-    if (s->status == INIT_STATE) {
-#ifdef GZIP
-        if (s->wrap == 2) {
-            strm->adler = crc32(0L, Z_NULL, 0);
-            put_byte(s, 31);
-            put_byte(s, 139);
-            put_byte(s, 8);
-            if (s->gzhead == Z_NULL) {
-                put_byte(s, 0);
-                put_byte(s, 0);
-                put_byte(s, 0);
-                put_byte(s, 0);
-                put_byte(s, 0);
-                put_byte(s, s->level == 9 ? 2 :
-                            (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
-                             4 : 0));
-                put_byte(s, OS_CODE);
-                s->status = BUSY_STATE;
-            }
-            else {
-                put_byte(s, (s->gzhead->text ? 1 : 0) +
-                            (s->gzhead->hcrc ? 2 : 0) +
-                            (s->gzhead->extra == Z_NULL ? 0 : 4) +
-                            (s->gzhead->name == Z_NULL ? 0 : 8) +
-                            (s->gzhead->comment == Z_NULL ? 0 : 16)
-                        );
-                put_byte(s, (Byte)(s->gzhead->time & 0xff));
-                put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));
-                put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
-                put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
-                put_byte(s, s->level == 9 ? 2 :
-                            (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
-                             4 : 0));
-                put_byte(s, s->gzhead->os & 0xff);
-                if (s->gzhead->extra != Z_NULL) {
-                    put_byte(s, s->gzhead->extra_len & 0xff);
-                    put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
-                }
-                if (s->gzhead->hcrc)
-                    strm->adler = crc32(strm->adler, s->pending_buf,
-                                        s->pending);
-                s->gzindex = 0;
-                s->status = EXTRA_STATE;
-            }
-        }
-        else
-#endif
-        {
-            uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
-            uInt level_flags;
-
-            if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)
-                level_flags = 0;
-            else if (s->level < 6)
-                level_flags = 1;
-            else if (s->level == 6)
-                level_flags = 2;
-            else
-                level_flags = 3;
-            header |= (level_flags << 6);
-            if (s->strstart != 0) header |= PRESET_DICT;
-            header += 31 - (header % 31);
-
-            s->status = BUSY_STATE;
-            putShortMSB(s, header);
-
-            /* Save the adler32 of the preset dictionary: */
-            if (s->strstart != 0) {
-                putShortMSB(s, (uInt)(strm->adler >> 16));
-                putShortMSB(s, (uInt)(strm->adler & 0xffff));
-            }
-            strm->adler = adler32(0L, Z_NULL, 0);
-        }
-    }
-#ifdef GZIP
-    if (s->status == EXTRA_STATE) {
-        if (s->gzhead->extra != Z_NULL) {
-            uInt beg = s->pending;  /* start of bytes to update crc */
-
-            while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {
-                if (s->pending == s->pending_buf_size) {
-                    if (s->gzhead->hcrc && s->pending > beg)
-                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
-                                            s->pending - beg);
-                    flush_pending(strm);
-                    beg = s->pending;
-                    if (s->pending == s->pending_buf_size)
-                        break;
-                }
-                put_byte(s, s->gzhead->extra[s->gzindex]);
-                s->gzindex++;
-            }
-            if (s->gzhead->hcrc && s->pending > beg)
-                strm->adler = crc32(strm->adler, s->pending_buf + beg,
-                                    s->pending - beg);
-            if (s->gzindex == s->gzhead->extra_len) {
-                s->gzindex = 0;
-                s->status = NAME_STATE;
-            }
-        }
-        else
-            s->status = NAME_STATE;
-    }
-    if (s->status == NAME_STATE) {
-        if (s->gzhead->name != Z_NULL) {
-            uInt beg = s->pending;  /* start of bytes to update crc */
-            int val;
-
-            do {
-                if (s->pending == s->pending_buf_size) {
-                    if (s->gzhead->hcrc && s->pending > beg)
-                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
-                                            s->pending - beg);
-                    flush_pending(strm);
-                    beg = s->pending;
-                    if (s->pending == s->pending_buf_size) {
-                        val = 1;
-                        break;
-                    }
-                }
-                val = s->gzhead->name[s->gzindex++];
-                put_byte(s, val);
-            } while (val != 0);
-            if (s->gzhead->hcrc && s->pending > beg)
-                strm->adler = crc32(strm->adler, s->pending_buf + beg,
-                                    s->pending - beg);
-            if (val == 0) {
-                s->gzindex = 0;
-                s->status = COMMENT_STATE;
-            }
-        }
-        else
-            s->status = COMMENT_STATE;
-    }
-    if (s->status == COMMENT_STATE) {
-        if (s->gzhead->comment != Z_NULL) {
-            uInt beg = s->pending;  /* start of bytes to update crc */
-            int val;
-
-            do {
-                if (s->pending == s->pending_buf_size) {
-                    if (s->gzhead->hcrc && s->pending > beg)
-                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
-                                            s->pending - beg);
-                    flush_pending(strm);
-                    beg = s->pending;
-                    if (s->pending == s->pending_buf_size) {
-                        val = 1;
-                        break;
-                    }
-                }
-                val = s->gzhead->comment[s->gzindex++];
-                put_byte(s, val);
-            } while (val != 0);
-            if (s->gzhead->hcrc && s->pending > beg)
-                strm->adler = crc32(strm->adler, s->pending_buf + beg,
-                                    s->pending - beg);
-            if (val == 0)
-                s->status = HCRC_STATE;
-        }
-        else
-            s->status = HCRC_STATE;
-    }
-    if (s->status == HCRC_STATE) {
-        if (s->gzhead->hcrc) {
-            if (s->pending + 2 > s->pending_buf_size)
-                flush_pending(strm);
-            if (s->pending + 2 <= s->pending_buf_size) {
-                put_byte(s, (Byte)(strm->adler & 0xff));
-                put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
-                strm->adler = crc32(0L, Z_NULL, 0);
-                s->status = BUSY_STATE;
-            }
-        }
-        else
-            s->status = BUSY_STATE;
-    }
-#endif
-
-    /* Flush as much pending output as possible */
-    if (s->pending != 0) {
-        flush_pending(strm);
-        if (strm->avail_out == 0) {
-            /* Since avail_out is 0, deflate will be called again with
-             * more output space, but possibly with both pending and
-             * avail_in equal to zero. There won't be anything to do,
-             * but this is not an error situation so make sure we
-             * return OK instead of BUF_ERROR at next call of deflate:
-             */
-            s->last_flush = -1;
-            return Z_OK;
-        }
-
-    /* Make sure there is something to do and avoid duplicate consecutive
-     * flushes. For repeated and useless calls with Z_FINISH, we keep
-     * returning Z_STREAM_END instead of Z_BUF_ERROR.
-     */
-    } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&
-               flush != Z_FINISH) {
-        ERR_RETURN(strm, Z_BUF_ERROR);
-    }
-
-    /* User must not provide more input after the first FINISH: */
-    if (s->status == FINISH_STATE && strm->avail_in != 0) {
-        ERR_RETURN(strm, Z_BUF_ERROR);
-    }
-
-    /* Start a new block or continue the current one.
-     */
-    if (strm->avail_in != 0 || s->lookahead != 0 ||
-        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
-        block_state bstate;
-
-        bstate = s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
-                    (s->strategy == Z_RLE ? deflate_rle(s, flush) :
-                        (*(configuration_table[s->level].func))(s, flush));
-
-        if (bstate == finish_started || bstate == finish_done) {
-            s->status = FINISH_STATE;
-        }
-        if (bstate == need_more || bstate == finish_started) {
-            if (strm->avail_out == 0) {
-                s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
-            }
-            return Z_OK;
-            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
-             * of deflate should use the same flush parameter to make sure
-             * that the flush is complete. So we don't have to output an
-             * empty block here, this will be done at next call. This also
-             * ensures that for a very small output buffer, we emit at most
-             * one empty block.
-             */
-        }
-        if (bstate == block_done) {
-            if (flush == Z_PARTIAL_FLUSH) {
-                _tr_align(s);
-            } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
-                _tr_stored_block(s, (char*)0, 0L, 0);
-                /* For a full flush, this empty block will be recognized
-                 * as a special marker by inflate_sync().
-                 */
-                if (flush == Z_FULL_FLUSH) {
-                    CLEAR_HASH(s);             /* forget history */
-                    if (s->lookahead == 0) {
-                        s->strstart = 0;
-                        s->block_start = 0L;
-                        s->insert = 0;
-                    }
-                }
-            }
-            flush_pending(strm);
-            if (strm->avail_out == 0) {
-              s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
-              return Z_OK;
-            }
-        }
-    }
-    Assert(strm->avail_out > 0, "bug2");
-
-    if (flush != Z_FINISH) return Z_OK;
-    if (s->wrap <= 0) return Z_STREAM_END;
-
-    /* Write the trailer */
-#ifdef GZIP
-    if (s->wrap == 2) {
-        put_byte(s, (Byte)(strm->adler & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 16) & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 24) & 0xff));
-        put_byte(s, (Byte)(strm->total_in & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));
-    }
-    else
-#endif
-    {
-        putShortMSB(s, (uInt)(strm->adler >> 16));
-        putShortMSB(s, (uInt)(strm->adler & 0xffff));
-    }
-    flush_pending(strm);
-    /* If avail_out is zero, the application will call deflate again
-     * to flush the rest.
-     */
-    if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */
-    return s->pending != 0 ? Z_OK : Z_STREAM_END;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateEnd (strm)
-    z_streamp strm;
-{
-    int status;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-
-    status = strm->state->status;
-    if (status != INIT_STATE &&
-        status != EXTRA_STATE &&
-        status != NAME_STATE &&
-        status != COMMENT_STATE &&
-        status != HCRC_STATE &&
-        status != BUSY_STATE &&
-        status != FINISH_STATE) {
-      return Z_STREAM_ERROR;
-    }
-
-    /* Deallocate in reverse order of allocations: */
-    TRY_FREE(strm, strm->state->pending_buf);
-    TRY_FREE(strm, strm->state->head);
-    TRY_FREE(strm, strm->state->prev);
-    TRY_FREE(strm, strm->state->window);
-
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-
-    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
-}
-
-/* =========================================================================
- * Copy the source state to the destination state.
- * To simplify the source, this is not supported for 16-bit MSDOS (which
- * doesn't have enough memory anyway to duplicate compression states).
- */
-int ZEXPORT deflateCopy (dest, source)
-    z_streamp dest;
-    z_streamp source;
-{
-#ifdef MAXSEG_64K
-    return Z_STREAM_ERROR;
-#else
-    deflate_state *ds;
-    deflate_state *ss;
-    ushf *overlay;
-
-
-    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
-        return Z_STREAM_ERROR;
-    }
-
-    ss = source->state;
-
-    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
-
-    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
-    if (ds == Z_NULL) return Z_MEM_ERROR;
-    dest->state = (struct internal_state FAR *) ds;
-    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));
-    ds->strm = dest;
-
-    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
-    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
-    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
-    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
-    ds->pending_buf = (uchf *) overlay;
-
-    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
-        ds->pending_buf == Z_NULL) {
-        deflateEnd (dest);
-        return Z_MEM_ERROR;
-    }
-    /* following zmemcpy do not work for 16-bit MSDOS */
-    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
-    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));
-    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));
-    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
-
-    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
-    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
-    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;
-
-    ds->l_desc.dyn_tree = ds->dyn_ltree;
-    ds->d_desc.dyn_tree = ds->dyn_dtree;
-    ds->bl_desc.dyn_tree = ds->bl_tree;
-
-    return Z_OK;
-#endif /* MAXSEG_64K */
-}
-
-/* ===========================================================================
- * Read a new buffer from the current input stream, update the adler32
- * and total number of bytes read.  All deflate() input goes through
- * this function so some applications may wish to modify it to avoid
- * allocating a large strm->next_in buffer and copying from it.
- * (See also flush_pending()).
- */
-local int read_buf(strm, buf, size)
-    z_streamp strm;
-    Bytef *buf;
-    unsigned size;
-{
-    unsigned len = strm->avail_in;
-
-    if (len > size) len = size;
-    if (len == 0) return 0;
-
-    strm->avail_in  -= len;
-
-    zmemcpy(buf, strm->next_in, len);
-    if (strm->state->wrap == 1) {
-        strm->adler = adler32(strm->adler, buf, len);
-    }
-#ifdef GZIP
-    else if (strm->state->wrap == 2) {
-        strm->adler = crc32(strm->adler, buf, len);
-    }
-#endif
-    strm->next_in  += len;
-    strm->total_in += len;
-
-    return (int)len;
-}
-
-/* ===========================================================================
- * Initialize the "longest match" routines for a new zlib stream
- */
-local void lm_init (s)
-    deflate_state *s;
-{
-    s->window_size = (ulg)2L*s->w_size;
-
-    CLEAR_HASH(s);
-
-    /* Set the default configuration parameters:
-     */
-    s->max_lazy_match   = configuration_table[s->level].max_lazy;
-    s->good_match       = configuration_table[s->level].good_length;
-    s->nice_match       = configuration_table[s->level].nice_length;
-    s->max_chain_length = configuration_table[s->level].max_chain;
-
-    s->strstart = 0;
-    s->block_start = 0L;
-    s->lookahead = 0;
-    s->insert = 0;
-    s->match_length = s->prev_length = MIN_MATCH-1;
-    s->match_available = 0;
-    s->ins_h = 0;
-#ifndef FASTEST
-#ifdef ASMV
-    match_init(); /* initialize the asm code */
-#endif
-#endif
-}
-
-#ifndef FASTEST
-/* ===========================================================================
- * Set match_start to the longest match starting at the given string and
- * return its length. Matches shorter or equal to prev_length are discarded,
- * in which case the result is equal to prev_length and match_start is
- * garbage.
- * IN assertions: cur_match is the head of the hash chain for the current
- *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
- * OUT assertion: the match length is not greater than s->lookahead.
- */
-#ifndef ASMV
-/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
- * match.S. The code will be functionally equivalent.
- */
-local uInt longest_match(s, cur_match)
-    deflate_state *s;
-    IPos cur_match;                             /* current match */
-{
-    unsigned chain_length = s->max_chain_length;/* max hash chain length */
-    register Bytef *scan = s->window + s->strstart; /* current string */
-    register Bytef *match;                       /* matched string */
-    register int len;                           /* length of current match */
-    int best_len = s->prev_length;              /* best match length so far */
-    int nice_match = s->nice_match;             /* stop if match long enough */
-    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
-        s->strstart - (IPos)MAX_DIST(s) : NIL;
-    /* Stop when cur_match becomes <= limit. To simplify the code,
-     * we prevent matches with the string of window index 0.
-     */
-    Posf *prev = s->prev;
-    uInt wmask = s->w_mask;
-
-#ifdef UNALIGNED_OK
-    /* Compare two bytes at a time. Note: this is not always beneficial.
-     * Try with and without -DUNALIGNED_OK to check.
-     */
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
-    register ush scan_start = *(ushf*)scan;
-    register ush scan_end   = *(ushf*)(scan+best_len-1);
-#else
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
-    register Byte scan_end1  = scan[best_len-1];
-    register Byte scan_end   = scan[best_len];
-#endif
-
-    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
-     * It is easy to get rid of this optimization if necessary.
-     */
-    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
-
-    /* Do not waste too much time if we already have a good match: */
-    if (s->prev_length >= s->good_match) {
-        chain_length >>= 2;
-    }
-    /* Do not look for matches beyond the end of the input. This is necessary
-     * to make deflate deterministic.
-     */
-    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
-
-    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
-
-    do {
-        Assert(cur_match < s->strstart, "no future");
-        match = s->window + cur_match;
-
-        /* Skip to next match if the match length cannot increase
-         * or if the match length is less than 2.  Note that the checks below
-         * for insufficient lookahead only occur occasionally for performance
-         * reasons.  Therefore uninitialized memory will be accessed, and
-         * conditional jumps will be made that depend on those values.
-         * However the length of the match is limited to the lookahead, so
-         * the output of deflate is not affected by the uninitialized values.
-         */
-#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
-        /* This code assumes sizeof(unsigned short) == 2. Do not use
-         * UNALIGNED_OK if your compiler uses a different size.
-         */
-        if (*(ushf*)(match+best_len-1) != scan_end ||
-            *(ushf*)match != scan_start) continue;
-
-        /* It is not necessary to compare scan[2] and match[2] since they are
-         * always equal when the other bytes match, given that the hash keys
-         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
-         * strstart+3, +5, ... up to strstart+257. We check for insufficient
-         * lookahead only every 4th comparison; the 128th check will be made
-         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
-         * necessary to put more guard bytes at the end of the window, or
-         * to check more often for insufficient lookahead.
-         */
-        Assert(scan[2] == match[2], "scan[2]?");
-        scan++, match++;
-        do {
-        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 scan < strend);
-        /* The funny "do {}" generates better code on most compilers */
-
-        /* Here, scan <= window+strstart+257 */
-        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
-        if (*scan == *match) scan++;
-
-        len = (MAX_MATCH - 1) - (int)(strend-scan);
-        scan = strend - (MAX_MATCH-1);
-
-#else /* UNALIGNED_OK */
-
-        if (match[best_len]   != scan_end  ||
-            match[best_len-1] != scan_end1 ||
-            *match            != *scan     ||
-            *++match          != scan[1])      continue;
-
-        /* The check at best_len-1 can be removed because it will be made
-         * again later. (This heuristic is not always a win.)
-         * It is not necessary to compare scan[2] and match[2] since they
-         * are always equal when the other bytes match, given that
-         * the hash keys are equal and that HASH_BITS >= 8.
-         */
-        scan += 2, match++;
-        Assert(*scan == *match, "match[2]?");
-
-        /* We check for insufficient lookahead only every 8th comparison;
-         * the 256th check will be made at strstart+258.
-         */
-        do {
-        } while (*++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 scan < strend);
-
-        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
-
-        len = MAX_MATCH - (int)(strend - scan);
-        scan = strend - MAX_MATCH;
-
-#endif /* UNALIGNED_OK */
-
-        if (len > best_len) {
-            s->match_start = cur_match;
-            best_len = len;
-            if (len >= nice_match) break;
-#ifdef UNALIGNED_OK
-            scan_end = *(ushf*)(scan+best_len-1);
-#else
-            scan_end1  = scan[best_len-1];
-            scan_end   = scan[best_len];
-#endif
-        }
-    } while ((cur_match = prev[cur_match & wmask]) > limit
-             && --chain_length != 0);
-
-    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
-    return s->lookahead;
-}
-#endif /* ASMV */
-
-#else /* FASTEST */
-
-/* ---------------------------------------------------------------------------
- * Optimized version for FASTEST only
- */
-local uInt longest_match(s, cur_match)
-    deflate_state *s;
-    IPos cur_match;                             /* current match */
-{
-    register Bytef *scan = s->window + s->strstart; /* current string */
-    register Bytef *match;                       /* matched string */
-    register int len;                           /* length of current match */
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
-
-    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
-     * It is easy to get rid of this optimization if necessary.
-     */
-    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
-
-    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
-
-    Assert(cur_match < s->strstart, "no future");
-
-    match = s->window + cur_match;
-
-    /* Return failure if the match length is less than 2:
-     */
-    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;
-
-    /* The check at best_len-1 can be removed because it will be made
-     * again later. (This heuristic is not always a win.)
-     * It is not necessary to compare scan[2] and match[2] since they
-     * are always equal when the other bytes match, given that
-     * the hash keys are equal and that HASH_BITS >= 8.
-     */
-    scan += 2, match += 2;
-    Assert(*scan == *match, "match[2]?");
-
-    /* We check for insufficient lookahead only every 8th comparison;
-     * the 256th check will be made at strstart+258.
-     */
-    do {
-    } while (*++scan == *++match && *++scan == *++match &&
-             *++scan == *++match && *++scan == *++match &&
-             *++scan == *++match && *++scan == *++match &&
-             *++scan == *++match && *++scan == *++match &&
-             scan < strend);
-
-    Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
-
-    len = MAX_MATCH - (int)(strend - scan);
-
-    if (len < MIN_MATCH) return MIN_MATCH - 1;
-
-    s->match_start = cur_match;
-    return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;
-}
-
-#endif /* FASTEST */
-
-#ifdef DEBUG
-/* ===========================================================================
- * Check that the match at match_start is indeed a match.
- */
-local void check_match(s, start, match, length)
-    deflate_state *s;
-    IPos start, match;
-    int length;
-{
-    /* check that the match is indeed a match */
-    if (zmemcmp(s->window + match,
-                s->window + start, length) != EQUAL) {
-        fprintf(stderr, " start %u, match %u, length %d\n",
-                start, match, length);
-        do {
-            fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
-        } while (--length != 0);
-        z_error("invalid match");
-    }
-    if (z_verbose > 1) {
-        fprintf(stderr,"\\[%d,%d]", start-match, length);
-        do { putc(s->window[start++], stderr); } while (--length != 0);
-    }
-}
-#else
-#  define check_match(s, start, match, length)
-#endif /* DEBUG */
-
-/* ===========================================================================
- * Fill the window when the lookahead becomes insufficient.
- * Updates strstart and lookahead.
- *
- * IN assertion: lookahead < MIN_LOOKAHEAD
- * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
- *    At least one byte has been read, or avail_in == 0; reads are
- *    performed for at least two bytes (required for the zip translate_eol
- *    option -- not supported here).
- */
-local void fill_window(s)
-    deflate_state *s;
-{
-    register unsigned n, m;
-    register Posf *p;
-    unsigned more;    /* Amount of free space at the end of the window. */
-    uInt wsize = s->w_size;
-
-    Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
-
-    do {
-        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
-
-        /* Deal with !@#$% 64K limit: */
-        if (sizeof(int) <= 2) {
-            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
-                more = wsize;
-
-            } else if (more == (unsigned)(-1)) {
-                /* Very unlikely, but possible on 16 bit machine if
-                 * strstart == 0 && lookahead == 1 (input done a byte at time)
-                 */
-                more--;
-            }
-        }
-
-        /* If the window is almost full and there is insufficient lookahead,
-         * move the upper half to the lower one to make room in the upper half.
-         */
-        if (s->strstart >= wsize+MAX_DIST(s)) {
-
-            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);
-            s->match_start -= wsize;
-            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
-            s->block_start -= (long) wsize;
-
-            /* Slide the hash table (could be avoided with 32 bit values
-               at the expense of memory usage). We slide even when level == 0
-               to keep the hash table consistent if we switch back to level > 0
-               later. (Using level 0 permanently is not an optimal usage of
-               zlib, so we don't care about this pathological case.)
-             */
-            n = s->hash_size;
-            p = &s->head[n];
-            do {
-                m = *--p;
-                *p = (Pos)(m >= wsize ? m-wsize : NIL);
-            } while (--n);
-
-            n = wsize;
-#ifndef FASTEST
-            p = &s->prev[n];
-            do {
-                m = *--p;
-                *p = (Pos)(m >= wsize ? m-wsize : NIL);
-                /* If n is not on any hash chain, prev[n] is garbage but
-                 * its value will never be used.
-                 */
-            } while (--n);
-#endif
-            more += wsize;
-        }
-        if (s->strm->avail_in == 0) break;
-
-        /* If there was no sliding:
-         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
-         *    more == window_size - lookahead - strstart
-         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
-         * => more >= window_size - 2*WSIZE + 2
-         * In the BIG_MEM or MMAP case (not yet supported),
-         *   window_size == input_size + MIN_LOOKAHEAD  &&
-         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
-         * Otherwise, window_size == 2*WSIZE so more >= 2.
-         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
-         */
-        Assert(more >= 2, "more < 2");
-
-        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
-        s->lookahead += n;
-
-        /* Initialize the hash value now that we have some input: */
-        if (s->lookahead + s->insert >= MIN_MATCH) {
-            uInt str = s->strstart - s->insert;
-            s->ins_h = s->window[str];
-            UPDATE_HASH(s, s->ins_h, s->window[str + 1]);
-#if MIN_MATCH != 3
-            Call UPDATE_HASH() MIN_MATCH-3 more times
-#endif
-            while (s->insert) {
-                UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
-#ifndef FASTEST
-                s->prev[str & s->w_mask] = s->head[s->ins_h];
-#endif
-                s->head[s->ins_h] = (Pos)str;
-                str++;
-                s->insert--;
-                if (s->lookahead + s->insert < MIN_MATCH)
-                    break;
-            }
-        }
-        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
-         * but this is not important since only literal bytes will be emitted.
-         */
-
-    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
-
-    /* If the WIN_INIT bytes after the end of the current data have never been
-     * written, then zero those bytes in order to avoid memory check reports of
-     * the use of uninitialized (or uninitialised as Julian writes) bytes by
-     * the longest match routines.  Update the high water mark for the next
-     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
-     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
-     */
-    if (s->high_water < s->window_size) {
-        ulg curr = s->strstart + (ulg)(s->lookahead);
-        ulg init;
-
-        if (s->high_water < curr) {
-            /* Previous high water mark below current data -- zero WIN_INIT
-             * bytes or up to end of window, whichever is less.
-             */
-            init = s->window_size - curr;
-            if (init > WIN_INIT)
-                init = WIN_INIT;
-            zmemzero(s->window + curr, (unsigned)init);
-            s->high_water = curr + init;
-        }
-        else if (s->high_water < (ulg)curr + WIN_INIT) {
-            /* High water mark at or above current data, but below current data
-             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
-             * to end of window, whichever is less.
-             */
-            init = (ulg)curr + WIN_INIT - s->high_water;
-            if (init > s->window_size - s->high_water)
-                init = s->window_size - s->high_water;
-            zmemzero(s->window + s->high_water, (unsigned)init);
-            s->high_water += init;
-        }
-    }
-
-    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
-           "not enough room for search");
-}
-
-/* ===========================================================================
- * Flush the current block, with given end-of-file flag.
- * IN assertion: strstart is set to the end of the current match.
- */
-#define FLUSH_BLOCK_ONLY(s, last) { \
-   _tr_flush_block(s, (s->block_start >= 0L ? \
-                   (charf *)&s->window[(unsigned)s->block_start] : \
-                   (charf *)Z_NULL), \
-                (ulg)((long)s->strstart - s->block_start), \
-                (last)); \
-   s->block_start = s->strstart; \
-   flush_pending(s->strm); \
-   Tracev((stderr,"[FLUSH]")); \
-}
-
-/* Same but force premature exit if necessary. */
-#define FLUSH_BLOCK(s, last) { \
-   FLUSH_BLOCK_ONLY(s, last); \
-   if (s->strm->avail_out == 0) return (last) ? finish_started : need_more; \
-}
-
-/* ===========================================================================
- * Copy without compression as much as possible from the input stream, return
- * the current block state.
- * This function does not insert new strings in the dictionary since
- * uncompressible data is probably not useful. This function is used
- * only for the level=0 compression option.
- * NOTE: this function should be optimized to avoid extra copying from
- * window to pending_buf.
- */
-local block_state deflate_stored(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
-     * to pending_buf_size, and each stored block has a 5 byte header:
-     */
-    ulg max_block_size = 0xffff;
-    ulg max_start;
-
-    if (max_block_size > s->pending_buf_size - 5) {
-        max_block_size = s->pending_buf_size - 5;
-    }
-
-    /* Copy as much as possible from input to output: */
-    for (;;) {
-        /* Fill the window as much as possible: */
-        if (s->lookahead <= 1) {
-
-            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
-                   s->block_start >= (long)s->w_size, "slide too late");
-
-            fill_window(s);
-            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;
-
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-        Assert(s->block_start >= 0L, "block gone");
-
-        s->strstart += s->lookahead;
-        s->lookahead = 0;
-
-        /* Emit a stored block if pending_buf will be full: */
-        max_start = s->block_start + max_block_size;
-        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
-            /* strstart == 0 is possible when wraparound on 16-bit machine */
-            s->lookahead = (uInt)(s->strstart - max_start);
-            s->strstart = (uInt)max_start;
-            FLUSH_BLOCK(s, 0);
-        }
-        /* Flush if we may have to slide, otherwise block_start may become
-         * negative and the data will be gone:
-         */
-        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
-            FLUSH_BLOCK(s, 0);
-        }
-    }
-    s->insert = 0;
-    if (flush == Z_FINISH) {
-        FLUSH_BLOCK(s, 1);
-        return finish_done;
-    }
-    if ((long)s->strstart > s->block_start)
-        FLUSH_BLOCK(s, 0);
-    return block_done;
-}
-
-/* ===========================================================================
- * Compress as much as possible from the input stream, return the current
- * block state.
- * This function does not perform lazy evaluation of matches and inserts
- * new strings in the dictionary only for unmatched strings or for short
- * matches. It is used only for the fast compression options.
- */
-local block_state deflate_fast(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    IPos hash_head;       /* head of the hash chain */
-    int bflush;           /* set if current block must be flushed */
-
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the next match, plus MIN_MATCH bytes to insert the
-         * string following the next match.
-         */
-        if (s->lookahead < MIN_LOOKAHEAD) {
-            fill_window(s);
-            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-
-        /* Insert the string window[strstart .. strstart+2] in the
-         * dictionary, and set hash_head to the head of the hash chain:
-         */
-        hash_head = NIL;
-        if (s->lookahead >= MIN_MATCH) {
-            INSERT_STRING(s, s->strstart, hash_head);
-        }
-
-        /* Find the longest match, discarding those <= prev_length.
-         * At this point we have always match_length < MIN_MATCH
-         */
-        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
-            /* To simplify the code, we prevent matches with the string
-             * of window index 0 (in particular we have to avoid a match
-             * of the string with itself at the start of the input file).
-             */
-            s->match_length = longest_match (s, hash_head);
-            /* longest_match() sets match_start */
-        }
-        if (s->match_length >= MIN_MATCH) {
-            check_match(s, s->strstart, s->match_start, s->match_length);
-
-            _tr_tally_dist(s, s->strstart - s->match_start,
-                           s->match_length - MIN_MATCH, bflush);
-
-            s->lookahead -= s->match_length;
-
-            /* Insert new strings in the hash table only if the match length
-             * is not too large. This saves time but degrades compression.
-             */
-#ifndef FASTEST
-            if (s->match_length <= s->max_insert_length &&
-                s->lookahead >= MIN_MATCH) {
-                s->match_length--; /* string at strstart already in table */
-                do {
-                    s->strstart++;
-                    INSERT_STRING(s, s->strstart, hash_head);
-                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
-                     * always MIN_MATCH bytes ahead.
-                     */
-                } while (--s->match_length != 0);
-                s->strstart++;
-            } else
-#endif
-            {
-                s->strstart += s->match_length;
-                s->match_length = 0;
-                s->ins_h = s->window[s->strstart];
-                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
-#if MIN_MATCH != 3
-                Call UPDATE_HASH() MIN_MATCH-3 more times
-#endif
-                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
-                 * matter since it will be recomputed at next deflate call.
-                 */
-            }
-        } else {
-            /* No match, output a literal byte */
-            Tracevv((stderr,"%c", s->window[s->strstart]));
-            _tr_tally_lit (s, s->window[s->strstart], bflush);
-            s->lookahead--;
-            s->strstart++;
-        }
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
-    if (flush == Z_FINISH) {
-        FLUSH_BLOCK(s, 1);
-        return finish_done;
-    }
-    if (s->last_lit)
-        FLUSH_BLOCK(s, 0);
-    return block_done;
-}
-
-#ifndef FASTEST
-/* ===========================================================================
- * Same as above, but achieves better compression. We use a lazy
- * evaluation for matches: a match is finally adopted only if there is
- * no better match at the next window position.
- */
-local block_state deflate_slow(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    IPos hash_head;          /* head of hash chain */
-    int bflush;              /* set if current block must be flushed */
-
-    /* Process the input block. */
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the next match, plus MIN_MATCH bytes to insert the
-         * string following the next match.
-         */
-        if (s->lookahead < MIN_LOOKAHEAD) {
-            fill_window(s);
-            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-
-        /* Insert the string window[strstart .. strstart+2] in the
-         * dictionary, and set hash_head to the head of the hash chain:
-         */
-        hash_head = NIL;
-        if (s->lookahead >= MIN_MATCH) {
-            INSERT_STRING(s, s->strstart, hash_head);
-        }
-
-        /* Find the longest match, discarding those <= prev_length.
-         */
-        s->prev_length = s->match_length, s->prev_match = s->match_start;
-        s->match_length = MIN_MATCH-1;
-
-        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
-            s->strstart - hash_head <= MAX_DIST(s)) {
-            /* To simplify the code, we prevent matches with the string
-             * of window index 0 (in particular we have to avoid a match
-             * of the string with itself at the start of the input file).
-             */
-            s->match_length = longest_match (s, hash_head);
-            /* longest_match() sets match_start */
-
-            if (s->match_length <= 5 && (s->strategy == Z_FILTERED
-#if TOO_FAR <= 32767
-                || (s->match_length == MIN_MATCH &&
-                    s->strstart - s->match_start > TOO_FAR)
-#endif
-                )) {
-
-                /* If prev_match is also MIN_MATCH, match_start is garbage
-                 * but we will ignore the current match anyway.
-                 */
-                s->match_length = MIN_MATCH-1;
-            }
-        }
-        /* If there was a match at the previous step and the current
-         * match is not better, output the previous match:
-         */
-        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
-            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
-            /* Do not insert strings in hash table beyond this. */
-
-            check_match(s, s->strstart-1, s->prev_match, s->prev_length);
-
-            _tr_tally_dist(s, s->strstart -1 - s->prev_match,
-                           s->prev_length - MIN_MATCH, bflush);
-
-            /* Insert in hash table all strings up to the end of the match.
-             * strstart-1 and strstart are already inserted. If there is not
-             * enough lookahead, the last two strings are not inserted in
-             * the hash table.
-             */
-            s->lookahead -= s->prev_length-1;
-            s->prev_length -= 2;
-            do {
-                if (++s->strstart <= max_insert) {
-                    INSERT_STRING(s, s->strstart, hash_head);
-                }
-            } while (--s->prev_length != 0);
-            s->match_available = 0;
-            s->match_length = MIN_MATCH-1;
-            s->strstart++;
-
-            if (bflush) FLUSH_BLOCK(s, 0);
-
-        } else if (s->match_available) {
-            /* If there was no match at the previous position, output a
-             * single literal. If there was a match but the current match
-             * is longer, truncate the previous match to a single literal.
-             */
-            Tracevv((stderr,"%c", s->window[s->strstart-1]));
-            _tr_tally_lit(s, s->window[s->strstart-1], bflush);
-            if (bflush) {
-                FLUSH_BLOCK_ONLY(s, 0);
-            }
-            s->strstart++;
-            s->lookahead--;
-            if (s->strm->avail_out == 0) return need_more;
-        } else {
-            /* There is no previous match to compare with, wait for
-             * the next step to decide.
-             */
-            s->match_available = 1;
-            s->strstart++;
-            s->lookahead--;
-        }
-    }
-    Assert (flush != Z_NO_FLUSH, "no flush?");
-    if (s->match_available) {
-        Tracevv((stderr,"%c", s->window[s->strstart-1]));
-        _tr_tally_lit(s, s->window[s->strstart-1], bflush);
-        s->match_available = 0;
-    }
-    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
-    if (flush == Z_FINISH) {
-        FLUSH_BLOCK(s, 1);
-        return finish_done;
-    }
-    if (s->last_lit)
-        FLUSH_BLOCK(s, 0);
-    return block_done;
-}
-#endif /* FASTEST */
-
-/* ===========================================================================
- * For Z_RLE, simply look for runs of bytes, generate matches only of distance
- * one.  Do not maintain a hash table.  (It will be regenerated if this run of
- * deflate switches away from Z_RLE.)
- */
-local block_state deflate_rle(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    int bflush;             /* set if current block must be flushed */
-    uInt prev;              /* byte at distance one to match */
-    Bytef *scan, *strend;   /* scan goes up to strend for length of run */
-
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the longest run, plus one for the unrolled loop.
-         */
-        if (s->lookahead <= MAX_MATCH) {
-            fill_window(s);
-            if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-
-        /* See how many times the previous byte repeats */
-        s->match_length = 0;
-        if (s->lookahead >= MIN_MATCH && s->strstart > 0) {
-            scan = s->window + s->strstart - 1;
-            prev = *scan;
-            if (prev == *++scan && prev == *++scan && prev == *++scan) {
-                strend = s->window + s->strstart + MAX_MATCH;
-                do {
-                } while (prev == *++scan && prev == *++scan &&
-                         prev == *++scan && prev == *++scan &&
-                         prev == *++scan && prev == *++scan &&
-                         prev == *++scan && prev == *++scan &&
-                         scan < strend);
-                s->match_length = MAX_MATCH - (int)(strend - scan);
-                if (s->match_length > s->lookahead)
-                    s->match_length = s->lookahead;
-            }
-            Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
-        }
-
-        /* Emit match if have run of MIN_MATCH or longer, else emit literal */
-        if (s->match_length >= MIN_MATCH) {
-            check_match(s, s->strstart, s->strstart - 1, s->match_length);
-
-            _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);
-
-            s->lookahead -= s->match_length;
-            s->strstart += s->match_length;
-            s->match_length = 0;
-        } else {
-            /* No match, output a literal byte */
-            Tracevv((stderr,"%c", s->window[s->strstart]));
-            _tr_tally_lit (s, s->window[s->strstart], bflush);
-            s->lookahead--;
-            s->strstart++;
-        }
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    s->insert = 0;
-    if (flush == Z_FINISH) {
-        FLUSH_BLOCK(s, 1);
-        return finish_done;
-    }
-    if (s->last_lit)
-        FLUSH_BLOCK(s, 0);
-    return block_done;
-}
-
-/* ===========================================================================
- * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
- * (It will be regenerated if this run of deflate switches away from Huffman.)
- */
-local block_state deflate_huff(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    int bflush;             /* set if current block must be flushed */
-
-    for (;;) {
-        /* Make sure that we have a literal to write. */
-        if (s->lookahead == 0) {
-            fill_window(s);
-            if (s->lookahead == 0) {
-                if (flush == Z_NO_FLUSH)
-                    return need_more;
-                break;      /* flush the current block */
-            }
-        }
-
-        /* Output a literal byte */
-        s->match_length = 0;
-        Tracevv((stderr,"%c", s->window[s->strstart]));
-        _tr_tally_lit (s, s->window[s->strstart], bflush);
-        s->lookahead--;
-        s->strstart++;
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    s->insert = 0;
-    if (flush == Z_FINISH) {
-        FLUSH_BLOCK(s, 1);
-        return finish_done;
-    }
-    if (s->last_lit)
-        FLUSH_BLOCK(s, 0);
-    return block_done;
-}
diff -Nbaur gcc-4.8.1/zlib/deflate.h gcc-4.8.1-ppc/zlib/deflate.h
--- gcc-4.8.1/zlib/deflate.h	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/deflate.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,346 +0,0 @@
-/* deflate.h -- internal compression state
- * Copyright (C) 1995-2012 Jean-loup Gailly
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* @(#) $Id: deflate.h,v 1.1.1.2 2002/03/11 21:53:23 tromey Exp $ */
-
-#ifndef DEFLATE_H
-#define DEFLATE_H
-
-#include "zutil.h"
-
-/* define NO_GZIP when compiling if you want to disable gzip header and
-   trailer creation by deflate().  NO_GZIP would be used to avoid linking in
-   the crc code when it is not needed.  For shared libraries, gzip encoding
-   should be left enabled. */
-#ifndef NO_GZIP
-#  define GZIP
-#endif
-
-/* ===========================================================================
- * Internal compression state.
- */
-
-#define LENGTH_CODES 29
-/* number of length codes, not counting the special END_BLOCK code */
-
-#define LITERALS  256
-/* number of literal bytes 0..255 */
-
-#define L_CODES (LITERALS+1+LENGTH_CODES)
-/* number of Literal or Length codes, including the END_BLOCK code */
-
-#define D_CODES   30
-/* number of distance codes */
-
-#define BL_CODES  19
-/* number of codes used to transfer the bit lengths */
-
-#define HEAP_SIZE (2*L_CODES+1)
-/* maximum heap size */
-
-#define MAX_BITS 15
-/* All codes must not exceed MAX_BITS bits */
-
-#define Buf_size 16
-/* size of bit buffer in bi_buf */
-
-#define INIT_STATE    42
-#define EXTRA_STATE   69
-#define NAME_STATE    73
-#define COMMENT_STATE 91
-#define HCRC_STATE   103
-#define BUSY_STATE   113
-#define FINISH_STATE 666
-/* Stream status */
-
-
-/* Data structure describing a single value and its code string. */
-typedef struct ct_data_s {
-    union {
-        ush  freq;       /* frequency count */
-        ush  code;       /* bit string */
-    } fc;
-    union {
-        ush  dad;        /* father node in Huffman tree */
-        ush  len;        /* length of bit string */
-    } dl;
-} FAR ct_data;
-
-#define Freq fc.freq
-#define Code fc.code
-#define Dad  dl.dad
-#define Len  dl.len
-
-typedef struct static_tree_desc_s  static_tree_desc;
-
-typedef struct tree_desc_s {
-    ct_data *dyn_tree;           /* the dynamic tree */
-    int     max_code;            /* largest code with non zero frequency */
-    static_tree_desc *stat_desc; /* the corresponding static tree */
-} FAR tree_desc;
-
-typedef ush Pos;
-typedef Pos FAR Posf;
-typedef unsigned IPos;
-
-/* A Pos is an index in the character window. We use short instead of int to
- * save space in the various tables. IPos is used only for parameter passing.
- */
-
-typedef struct internal_state {
-    z_streamp strm;      /* pointer back to this zlib stream */
-    int   status;        /* as the name implies */
-    Bytef *pending_buf;  /* output still pending */
-    ulg   pending_buf_size; /* size of pending_buf */
-    Bytef *pending_out;  /* next pending byte to output to the stream */
-    uInt   pending;      /* nb of bytes in the pending buffer */
-    int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */
-    gz_headerp  gzhead;  /* gzip header information to write */
-    uInt   gzindex;      /* where in extra, name, or comment */
-    Byte  method;        /* STORED (for zip only) or DEFLATED */
-    int   last_flush;    /* value of flush param for previous deflate call */
-
-                /* used by deflate.c: */
-
-    uInt  w_size;        /* LZ77 window size (32K by default) */
-    uInt  w_bits;        /* log2(w_size)  (8..16) */
-    uInt  w_mask;        /* w_size - 1 */
-
-    Bytef *window;
-    /* Sliding window. Input bytes are read into the second half of the window,
-     * and move to the first half later to keep a dictionary of at least wSize
-     * bytes. With this organization, matches are limited to a distance of
-     * wSize-MAX_MATCH bytes, but this ensures that IO is always
-     * performed with a length multiple of the block size. Also, it limits
-     * the window size to 64K, which is quite useful on MSDOS.
-     * To do: use the user input buffer as sliding window.
-     */
-
-    ulg window_size;
-    /* Actual size of window: 2*wSize, except when the user input buffer
-     * is directly used as sliding window.
-     */
-
-    Posf *prev;
-    /* Link to older string with same hash index. To limit the size of this
-     * array to 64K, this link is maintained only for the last 32K strings.
-     * An index in this array is thus a window index modulo 32K.
-     */
-
-    Posf *head; /* Heads of the hash chains or NIL. */
-
-    uInt  ins_h;          /* hash index of string to be inserted */
-    uInt  hash_size;      /* number of elements in hash table */
-    uInt  hash_bits;      /* log2(hash_size) */
-    uInt  hash_mask;      /* hash_size-1 */
-
-    uInt  hash_shift;
-    /* Number of bits by which ins_h must be shifted at each input
-     * step. It must be such that after MIN_MATCH steps, the oldest
-     * byte no longer takes part in the hash key, that is:
-     *   hash_shift * MIN_MATCH >= hash_bits
-     */
-
-    long block_start;
-    /* Window position at the beginning of the current output block. Gets
-     * negative when the window is moved backwards.
-     */
-
-    uInt match_length;           /* length of best match */
-    IPos prev_match;             /* previous match */
-    int match_available;         /* set if previous match exists */
-    uInt strstart;               /* start of string to insert */
-    uInt match_start;            /* start of matching string */
-    uInt lookahead;              /* number of valid bytes ahead in window */
-
-    uInt prev_length;
-    /* Length of the best match at previous step. Matches not greater than this
-     * are discarded. This is used in the lazy match evaluation.
-     */
-
-    uInt max_chain_length;
-    /* To speed up deflation, hash chains are never searched beyond this
-     * length.  A higher limit improves compression ratio but degrades the
-     * speed.
-     */
-
-    uInt max_lazy_match;
-    /* Attempt to find a better match only when the current match is strictly
-     * smaller than this value. This mechanism is used only for compression
-     * levels >= 4.
-     */
-#   define max_insert_length  max_lazy_match
-    /* Insert new strings in the hash table only if the match length is not
-     * greater than this length. This saves time but degrades compression.
-     * max_insert_length is used only for compression levels <= 3.
-     */
-
-    int level;    /* compression level (1..9) */
-    int strategy; /* favor or force Huffman coding*/
-
-    uInt good_match;
-    /* Use a faster search when the previous match is longer than this */
-
-    int nice_match; /* Stop searching when current match exceeds this */
-
-                /* used by trees.c: */
-    /* Didn't use ct_data typedef below to suppress compiler warning */
-    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
-    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
-    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
-
-    struct tree_desc_s l_desc;               /* desc. for literal tree */
-    struct tree_desc_s d_desc;               /* desc. for distance tree */
-    struct tree_desc_s bl_desc;              /* desc. for bit length tree */
-
-    ush bl_count[MAX_BITS+1];
-    /* number of codes at each bit length for an optimal tree */
-
-    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
-    int heap_len;               /* number of elements in the heap */
-    int heap_max;               /* element of largest frequency */
-    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
-     * The same heap array is used to build all trees.
-     */
-
-    uch depth[2*L_CODES+1];
-    /* Depth of each subtree used as tie breaker for trees of equal frequency
-     */
-
-    uchf *l_buf;          /* buffer for literals or lengths */
-
-    uInt  lit_bufsize;
-    /* Size of match buffer for literals/lengths.  There are 4 reasons for
-     * limiting lit_bufsize to 64K:
-     *   - frequencies can be kept in 16 bit counters
-     *   - if compression is not successful for the first block, all input
-     *     data is still in the window so we can still emit a stored block even
-     *     when input comes from standard input.  (This can also be done for
-     *     all blocks if lit_bufsize is not greater than 32K.)
-     *   - if compression is not successful for a file smaller than 64K, we can
-     *     even emit a stored file instead of a stored block (saving 5 bytes).
-     *     This is applicable only for zip (not gzip or zlib).
-     *   - creating new Huffman trees less frequently may not provide fast
-     *     adaptation to changes in the input data statistics. (Take for
-     *     example a binary file with poorly compressible code followed by
-     *     a highly compressible string table.) Smaller buffer sizes give
-     *     fast adaptation but have of course the overhead of transmitting
-     *     trees more frequently.
-     *   - I can't count above 4
-     */
-
-    uInt last_lit;      /* running index in l_buf */
-
-    ushf *d_buf;
-    /* Buffer for distances. To simplify the code, d_buf and l_buf have
-     * the same number of elements. To use different lengths, an extra flag
-     * array would be necessary.
-     */
-
-    ulg opt_len;        /* bit length of current block with optimal trees */
-    ulg static_len;     /* bit length of current block with static trees */
-    uInt matches;       /* number of string matches in current block */
-    uInt insert;        /* bytes at end of window left to insert */
-
-#ifdef DEBUG
-    ulg compressed_len; /* total bit length of compressed file mod 2^32 */
-    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
-#endif
-
-    ush bi_buf;
-    /* Output buffer. bits are inserted starting at the bottom (least
-     * significant bits).
-     */
-    int bi_valid;
-    /* Number of valid bits in bi_buf.  All bits above the last valid bit
-     * are always zero.
-     */
-
-    ulg high_water;
-    /* High water mark offset in window for initialized bytes -- bytes above
-     * this are set to zero in order to avoid memory check warnings when
-     * longest match routines access bytes past the input.  This is then
-     * updated to the new high water mark.
-     */
-
-} FAR deflate_state;
-
-/* Output a byte on the stream.
- * IN assertion: there is enough room in pending_buf.
- */
-#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}
-
-
-#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
-/* Minimum amount of lookahead, except at the end of the input file.
- * See deflate.c for comments about the MIN_MATCH+1.
- */
-
-#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
-/* In order to simplify the code, particularly on 16 bit machines, match
- * distances are limited to MAX_DIST instead of WSIZE.
- */
-
-#define WIN_INIT MAX_MATCH
-/* Number of bytes after end of data in window to initialize in order to avoid
-   memory checker errors from longest match routines */
-
-        /* in trees.c */
-void ZLIB_INTERNAL _tr_init OF((deflate_state *s));
-int ZLIB_INTERNAL _tr_tally OF((deflate_state *s, unsigned dist, unsigned lc));
-void ZLIB_INTERNAL _tr_flush_block OF((deflate_state *s, charf *buf,
-                        ulg stored_len, int last));
-void ZLIB_INTERNAL _tr_flush_bits OF((deflate_state *s));
-void ZLIB_INTERNAL _tr_align OF((deflate_state *s));
-void ZLIB_INTERNAL _tr_stored_block OF((deflate_state *s, charf *buf,
-                        ulg stored_len, int last));
-
-#define d_code(dist) \
-   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
-/* Mapping from a distance to a distance code. dist is the distance - 1 and
- * must not have side effects. _dist_code[256] and _dist_code[257] are never
- * used.
- */
-
-#ifndef DEBUG
-/* Inline versions of _tr_tally for speed: */
-
-#if defined(GEN_TREES_H) || !defined(STDC)
-  extern uch ZLIB_INTERNAL _length_code[];
-  extern uch ZLIB_INTERNAL _dist_code[];
-#else
-  extern const uch ZLIB_INTERNAL _length_code[];
-  extern const uch ZLIB_INTERNAL _dist_code[];
-#endif
-
-# define _tr_tally_lit(s, c, flush) \
-  { uch cc = (c); \
-    s->d_buf[s->last_lit] = 0; \
-    s->l_buf[s->last_lit++] = cc; \
-    s->dyn_ltree[cc].Freq++; \
-    flush = (s->last_lit == s->lit_bufsize-1); \
-   }
-# define _tr_tally_dist(s, distance, length, flush) \
-  { uch len = (length); \
-    ush dist = (distance); \
-    s->d_buf[s->last_lit] = dist; \
-    s->l_buf[s->last_lit++] = len; \
-    dist--; \
-    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
-    s->dyn_dtree[d_code(dist)].Freq++; \
-    flush = (s->last_lit == s->lit_bufsize-1); \
-  }
-#else
-# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
-# define _tr_tally_dist(s, distance, length, flush) \
-              flush = _tr_tally(s, distance, length)
-#endif
-
-#endif /* DEFLATE_H */
diff -Nbaur gcc-4.8.1/zlib/doc/algorithm.txt gcc-4.8.1-ppc/zlib/doc/algorithm.txt
--- gcc-4.8.1/zlib/doc/algorithm.txt	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/doc/algorithm.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,209 +0,0 @@
-1. Compression algorithm (deflate)
-
-The deflation algorithm used by gzip (also zip and zlib) is a variation of
-LZ77 (Lempel-Ziv 1977, see reference below). It finds duplicated strings in
-the input data.  The second occurrence of a string is replaced by a
-pointer to the previous string, in the form of a pair (distance,
-length).  Distances are limited to 32K bytes, and lengths are limited
-to 258 bytes. When a string does not occur anywhere in the previous
-32K bytes, it is emitted as a sequence of literal bytes.  (In this
-description, `string' must be taken as an arbitrary sequence of bytes,
-and is not restricted to printable characters.)
-
-Literals or match lengths are compressed with one Huffman tree, and
-match distances are compressed with another tree. The trees are stored
-in a compact form at the start of each block. The blocks can have any
-size (except that the compressed data for one block must fit in
-available memory). A block is terminated when deflate() determines that
-it would be useful to start another block with fresh trees. (This is
-somewhat similar to the behavior of LZW-based _compress_.)
-
-Duplicated strings are found using a hash table. All input strings of
-length 3 are inserted in the hash table. A hash index is computed for
-the next 3 bytes. If the hash chain for this index is not empty, all
-strings in the chain are compared with the current input string, and
-the longest match is selected.
-
-The hash chains are searched starting with the most recent strings, to
-favor small distances and thus take advantage of the Huffman encoding.
-The hash chains are singly linked. There are no deletions from the
-hash chains, the algorithm simply discards matches that are too old.
-
-To avoid a worst-case situation, very long hash chains are arbitrarily
-truncated at a certain length, determined by a runtime option (level
-parameter of deflateInit). So deflate() does not always find the longest
-possible match but generally finds a match which is long enough.
-
-deflate() also defers the selection of matches with a lazy evaluation
-mechanism. After a match of length N has been found, deflate() searches for
-a longer match at the next input byte. If a longer match is found, the
-previous match is truncated to a length of one (thus producing a single
-literal byte) and the process of lazy evaluation begins again. Otherwise,
-the original match is kept, and the next match search is attempted only N
-steps later.
-
-The lazy match evaluation is also subject to a runtime parameter. If
-the current match is long enough, deflate() reduces the search for a longer
-match, thus speeding up the whole process. If compression ratio is more
-important than speed, deflate() attempts a complete second search even if
-the first match is already long enough.
-
-The lazy match evaluation is not performed for the fastest compression
-modes (level parameter 1 to 3). For these fast modes, new strings
-are inserted in the hash table only when no match was found, or
-when the match is not too long. This degrades the compression ratio
-but saves time since there are both fewer insertions and fewer searches.
-
-
-2. Decompression algorithm (inflate)
-
-2.1 Introduction
-
-The key question is how to represent a Huffman code (or any prefix code) so
-that you can decode fast.  The most important characteristic is that shorter
-codes are much more common than longer codes, so pay attention to decoding the
-short codes fast, and let the long codes take longer to decode.
-
-inflate() sets up a first level table that covers some number of bits of
-input less than the length of longest code.  It gets that many bits from the
-stream, and looks it up in the table.  The table will tell if the next
-code is that many bits or less and how many, and if it is, it will tell
-the value, else it will point to the next level table for which inflate()
-grabs more bits and tries to decode a longer code.
-
-How many bits to make the first lookup is a tradeoff between the time it
-takes to decode and the time it takes to build the table.  If building the
-table took no time (and if you had infinite memory), then there would only
-be a first level table to cover all the way to the longest code.  However,
-building the table ends up taking a lot longer for more bits since short
-codes are replicated many times in such a table.  What inflate() does is
-simply to make the number of bits in the first table a variable, and  then
-to set that variable for the maximum speed.
-
-For inflate, which has 286 possible codes for the literal/length tree, the size
-of the first table is nine bits.  Also the distance trees have 30 possible
-values, and the size of the first table is six bits.  Note that for each of
-those cases, the table ended up one bit longer than the ``average'' code
-length, i.e. the code length of an approximately flat code which would be a
-little more than eight bits for 286 symbols and a little less than five bits
-for 30 symbols.
-
-
-2.2 More details on the inflate table lookup
-
-Ok, you want to know what this cleverly obfuscated inflate tree actually
-looks like.  You are correct that it's not a Huffman tree.  It is simply a
-lookup table for the first, let's say, nine bits of a Huffman symbol.  The
-symbol could be as short as one bit or as long as 15 bits.  If a particular
-symbol is shorter than nine bits, then that symbol's translation is duplicated
-in all those entries that start with that symbol's bits.  For example, if the
-symbol is four bits, then it's duplicated 32 times in a nine-bit table.  If a
-symbol is nine bits long, it appears in the table once.
-
-If the symbol is longer than nine bits, then that entry in the table points
-to another similar table for the remaining bits.  Again, there are duplicated
-entries as needed.  The idea is that most of the time the symbol will be short
-and there will only be one table look up.  (That's whole idea behind data
-compression in the first place.)  For the less frequent long symbols, there
-will be two lookups.  If you had a compression method with really long
-symbols, you could have as many levels of lookups as is efficient.  For
-inflate, two is enough.
-
-So a table entry either points to another table (in which case nine bits in
-the above example are gobbled), or it contains the translation for the symbol
-and the number of bits to gobble.  Then you start again with the next
-ungobbled bit.
-
-You may wonder: why not just have one lookup table for how ever many bits the
-longest symbol is?  The reason is that if you do that, you end up spending
-more time filling in duplicate symbol entries than you do actually decoding.
-At least for deflate's output that generates new trees every several 10's of
-kbytes.  You can imagine that filling in a 2^15 entry table for a 15-bit code
-would take too long if you're only decoding several thousand symbols.  At the
-other extreme, you could make a new table for every bit in the code.  In fact,
-that's essentially a Huffman tree.  But then you spend too much time
-traversing the tree while decoding, even for short symbols.
-
-So the number of bits for the first lookup table is a trade of the time to
-fill out the table vs. the time spent looking at the second level and above of
-the table.
-
-Here is an example, scaled down:
-
-The code being decoded, with 10 symbols, from 1 to 6 bits long:
-
-A: 0
-B: 10
-C: 1100
-D: 11010
-E: 11011
-F: 11100
-G: 11101
-H: 11110
-I: 111110
-J: 111111
-
-Let's make the first table three bits long (eight entries):
-
-000: A,1
-001: A,1
-010: A,1
-011: A,1
-100: B,2
-101: B,2
-110: -> table X (gobble 3 bits)
-111: -> table Y (gobble 3 bits)
-
-Each entry is what the bits decode as and how many bits that is, i.e. how
-many bits to gobble.  Or the entry points to another table, with the number of
-bits to gobble implicit in the size of the table.
-
-Table X is two bits long since the longest code starting with 110 is five bits
-long:
-
-00: C,1
-01: C,1
-10: D,2
-11: E,2
-
-Table Y is three bits long since the longest code starting with 111 is six
-bits long:
-
-000: F,2
-001: F,2
-010: G,2
-011: G,2
-100: H,2
-101: H,2
-110: I,3
-111: J,3
-
-So what we have here are three tables with a total of 20 entries that had to
-be constructed.  That's compared to 64 entries for a single table.  Or
-compared to 16 entries for a Huffman tree (six two entry tables and one four
-entry table).  Assuming that the code ideally represents the probability of
-the symbols, it takes on the average 1.25 lookups per symbol.  That's compared
-to one lookup for the single table, or 1.66 lookups per symbol for the
-Huffman tree.
-
-There, I think that gives you a picture of what's going on.  For inflate, the
-meaning of a particular symbol is often more than just a letter.  It can be a
-byte (a "literal"), or it can be either a length or a distance which
-indicates a base value and a number of bits to fetch after the code that is
-added to the base value.  Or it might be the special end-of-block code.  The
-data structures created in inftrees.c try to encode all that information
-compactly in the tables.
-
-
-Jean-loup Gailly        Mark Adler
-jloup@gzip.org          madler@alumni.caltech.edu
-
-
-References:
-
-[LZ77] Ziv J., Lempel A., ``A Universal Algorithm for Sequential Data
-Compression,'' IEEE Transactions on Information Theory, Vol. 23, No. 3,
-pp. 337-343.
-
-``DEFLATE Compressed Data Format Specification'' available in
-http://tools.ietf.org/html/rfc1951
diff -Nbaur gcc-4.8.1/zlib/doc/rfc1950.txt gcc-4.8.1-ppc/zlib/doc/rfc1950.txt
--- gcc-4.8.1/zlib/doc/rfc1950.txt	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/doc/rfc1950.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,619 +0,0 @@
-
-
-
-
-
-
-Network Working Group                                         P. Deutsch
-Request for Comments: 1950                           Aladdin Enterprises
-Category: Informational                                      J-L. Gailly
-                                                                Info-ZIP
-                                                                May 1996
-
-
-         ZLIB Compressed Data Format Specification version 3.3
-
-Status of This Memo
-
-   This memo provides information for the Internet community.  This memo
-   does not specify an Internet standard of any kind.  Distribution of
-   this memo is unlimited.
-
-IESG Note:
-
-   The IESG takes no position on the validity of any Intellectual
-   Property Rights statements contained in this document.
-
-Notices
-
-   Copyright (c) 1996 L. Peter Deutsch and Jean-Loup Gailly
-
-   Permission is granted to copy and distribute this document for any
-   purpose and without charge, including translations into other
-   languages and incorporation into compilations, provided that the
-   copyright notice and this notice are preserved, and that any
-   substantive changes or deletions from the original are clearly
-   marked.
-
-   A pointer to the latest version of this and related documentation in
-   HTML format can be found at the URL
-   <ftp://ftp.uu.net/graphics/png/documents/zlib/zdoc-index.html>.
-
-Abstract
-
-   This specification defines a lossless compressed data format.  The
-   data can be produced or consumed, even for an arbitrarily long
-   sequentially presented input data stream, using only an a priori
-   bounded amount of intermediate storage.  The format presently uses
-   the DEFLATE compression method but can be easily extended to use
-   other compression methods.  It can be implemented readily in a manner
-   not covered by patents.  This specification also defines the ADLER-32
-   checksum (an extension and improvement of the Fletcher checksum),
-   used for detection of data corruption, and provides an algorithm for
-   computing it.
-
-
-
-
-Deutsch & Gailly             Informational                      [Page 1]
-
-RFC 1950       ZLIB Compressed Data Format Specification        May 1996
-
-
-Table of Contents
-
-   1. Introduction ................................................... 2
-      1.1. Purpose ................................................... 2
-      1.2. Intended audience ......................................... 3
-      1.3. Scope ..................................................... 3
-      1.4. Compliance ................................................ 3
-      1.5.  Definitions of terms and conventions used ................ 3
-      1.6. Changes from previous versions ............................ 3
-   2. Detailed specification ......................................... 3
-      2.1. Overall conventions ....................................... 3
-      2.2. Data format ............................................... 4
-      2.3. Compliance ................................................ 7
-   3. References ..................................................... 7
-   4. Source code .................................................... 8
-   5. Security Considerations ........................................ 8
-   6. Acknowledgements ............................................... 8
-   7. Authors' Addresses ............................................. 8
-   8. Appendix: Rationale ............................................ 9
-   9. Appendix: Sample code ..........................................10
-
-1. Introduction
-
-   1.1. Purpose
-
-      The purpose of this specification is to define a lossless
-      compressed data format that:
-
-          * Is independent of CPU type, operating system, file system,
-            and character set, and hence can be used for interchange;
-
-          * Can be produced or consumed, even for an arbitrarily long
-            sequentially presented input data stream, using only an a
-            priori bounded amount of intermediate storage, and hence can
-            be used in data communications or similar structures such as
-            Unix filters;
-
-          * Can use a number of different compression methods;
-
-          * Can be implemented readily in a manner not covered by
-            patents, and hence can be practiced freely.
-
-      The data format defined by this specification does not attempt to
-      allow random access to compressed data.
-
-
-
-
-
-
-
-Deutsch & Gailly             Informational                      [Page 2]
-
-RFC 1950       ZLIB Compressed Data Format Specification        May 1996
-
-
-   1.2. Intended audience
-
-      This specification is intended for use by implementors of software
-      to compress data into zlib format and/or decompress data from zlib
-      format.
-
-      The text of the specification assumes a basic background in
-      programming at the level of bits and other primitive data
-      representations.
-
-   1.3. Scope
-
-      The specification specifies a compressed data format that can be
-      used for in-memory compression of a sequence of arbitrary bytes.
-
-   1.4. Compliance
-
-      Unless otherwise indicated below, a compliant decompressor must be
-      able to accept and decompress any data set that conforms to all
-      the specifications presented here; a compliant compressor must
-      produce data sets that conform to all the specifications presented
-      here.
-
-   1.5.  Definitions of terms and conventions used
-
-      byte: 8 bits stored or transmitted as a unit (same as an octet).
-      (For this specification, a byte is exactly 8 bits, even on
-      machines which store a character on a number of bits different
-      from 8.) See below, for the numbering of bits within a byte.
-
-   1.6. Changes from previous versions
-
-      Version 3.1 was the first public release of this specification.
-      In version 3.2, some terminology was changed and the Adler-32
-      sample code was rewritten for clarity.  In version 3.3, the
-      support for a preset dictionary was introduced, and the
-      specification was converted to RFC style.
-
-2. Detailed specification
-
-   2.1. Overall conventions
-
-      In the diagrams below, a box like this:
-
-         +---+
-         |   | <-- the vertical bars might be missing
-         +---+
-
-
-
-
-Deutsch & Gailly             Informational                      [Page 3]
-
-RFC 1950       ZLIB Compressed Data Format Specification        May 1996
-
-
-      represents one byte; a box like this:
-
-         +==============+
-         |              |
-         +==============+
-
-      represents a variable number of bytes.
-
-      Bytes stored within a computer do not have a "bit order", since
-      they are always treated as a unit.  However, a byte considered as
-      an integer between 0 and 255 does have a most- and least-
-      significant bit, and since we write numbers with the most-
-      significant digit on the left, we also write bytes with the most-
-      significant bit on the left.  In the diagrams below, we number the
-      bits of a byte so that bit 0 is the least-significant bit, i.e.,
-      the bits are numbered:
-
-         +--------+
-         |76543210|
-         +--------+
-
-      Within a computer, a number may occupy multiple bytes.  All
-      multi-byte numbers in the format described here are stored with
-      the MOST-significant byte first (at the lower memory address).
-      For example, the decimal number 520 is stored as:
-
-             0     1
-         +--------+--------+
-         |00000010|00001000|
-         +--------+--------+
-          ^        ^
-          |        |
-          |        + less significant byte = 8
-          + more significant byte = 2 x 256
-
-   2.2. Data format
-
-      A zlib stream has the following structure:
-
-           0   1
-         +---+---+
-         |CMF|FLG|   (more-->)
-         +---+---+
-
-
-
-
-
-
-
-
-Deutsch & Gailly             Informational                      [Page 4]
-
-RFC 1950       ZLIB Compressed Data Format Specification        May 1996
-
-
-      (if FLG.FDICT set)
-
-           0   1   2   3
-         +---+---+---+---+
-         |     DICTID    |   (more-->)
-         +---+---+---+---+
-
-         +=====================+---+---+---+---+
-         |...compressed data...|    ADLER32    |
-         +=====================+---+---+---+---+
-
-      Any data which may appear after ADLER32 are not part of the zlib
-      stream.
-
-      CMF (Compression Method and flags)
-         This byte is divided into a 4-bit compression method and a 4-
-         bit information field depending on the compression method.
-
-            bits 0 to 3  CM     Compression method
-            bits 4 to 7  CINFO  Compression info
-
-      CM (Compression method)
-         This identifies the compression method used in the file. CM = 8
-         denotes the "deflate" compression method with a window size up
-         to 32K.  This is the method used by gzip and PNG (see
-         references [1] and [2] in Chapter 3, below, for the reference
-         documents).  CM = 15 is reserved.  It might be used in a future
-         version of this specification to indicate the presence of an
-         extra field before the compressed data.
-
-      CINFO (Compression info)
-         For CM = 8, CINFO is the base-2 logarithm of the LZ77 window
-         size, minus eight (CINFO=7 indicates a 32K window size). Values
-         of CINFO above 7 are not allowed in this version of the
-         specification.  CINFO is not defined in this specification for
-         CM not equal to 8.
-
-      FLG (FLaGs)
-         This flag byte is divided as follows:
-
-            bits 0 to 4  FCHECK  (check bits for CMF and FLG)
-            bit  5       FDICT   (preset dictionary)
-            bits 6 to 7  FLEVEL  (compression level)
-
-         The FCHECK value must be such that CMF and FLG, when viewed as
-         a 16-bit unsigned integer stored in MSB order (CMF*256 + FLG),
-         is a multiple of 31.
-
-
-
-
-Deutsch & Gailly             Informational                      [Page 5]
-
-RFC 1950       ZLIB Compressed Data Format Specification        May 1996
-
-
-      FDICT (Preset dictionary)
-         If FDICT is set, a DICT dictionary identifier is present
-         immediately after the FLG byte. The dictionary is a sequence of
-         bytes which are initially fed to the compressor without
-         producing any compressed output. DICT is the Adler-32 checksum
-         of this sequence of bytes (see the definition of ADLER32
-         below).  The decompressor can use this identifier to determine
-         which dictionary has been used by the compressor.
-
-      FLEVEL (Compression level)
-         These flags are available for use by specific compression
-         methods.  The "deflate" method (CM = 8) sets these flags as
-         follows:
-
-            0 - compressor used fastest algorithm
-            1 - compressor used fast algorithm
-            2 - compressor used default algorithm
-            3 - compressor used maximum compression, slowest algorithm
-
-         The information in FLEVEL is not needed for decompression; it
-         is there to indicate if recompression might be worthwhile.
-
-      compressed data
-         For compression method 8, the compressed data is stored in the
-         deflate compressed data format as described in the document
-         "DEFLATE Compressed Data Format Specification" by L. Peter
-         Deutsch. (See reference [3] in Chapter 3, below)
-
-         Other compressed data formats are not specified in this version
-         of the zlib specification.
-
-      ADLER32 (Adler-32 checksum)
-         This contains a checksum value of the uncompressed data
-         (excluding any dictionary data) computed according to Adler-32
-         algorithm. This algorithm is a 32-bit extension and improvement
-         of the Fletcher algorithm, used in the ITU-T X.224 / ISO 8073
-         standard. See references [4] and [5] in Chapter 3, below)
-
-         Adler-32 is composed of two sums accumulated per byte: s1 is
-         the sum of all bytes, s2 is the sum of all s1 values. Both sums
-         are done modulo 65521. s1 is initialized to 1, s2 to zero.  The
-         Adler-32 checksum is stored as s2*65536 + s1 in most-
-         significant-byte first (network) order.
-
-
-
-
-
-
-
-
-Deutsch & Gailly             Informational                      [Page 6]
-
-RFC 1950       ZLIB Compressed Data Format Specification        May 1996
-
-
-   2.3. Compliance
-
-      A compliant compressor must produce streams with correct CMF, FLG
-      and ADLER32, but need not support preset dictionaries.  When the
-      zlib data format is used as part of another standard data format,
-      the compressor may use only preset dictionaries that are specified
-      by this other data format.  If this other format does not use the
-      preset dictionary feature, the compressor must not set the FDICT
-      flag.
-
-      A compliant decompressor must check CMF, FLG, and ADLER32, and
-      provide an error indication if any of these have incorrect values.
-      A compliant decompressor must give an error indication if CM is
-      not one of the values defined in this specification (only the
-      value 8 is permitted in this version), since another value could
-      indicate the presence of new features that would cause subsequent
-      data to be interpreted incorrectly.  A compliant decompressor must
-      give an error indication if FDICT is set and DICTID is not the
-      identifier of a known preset dictionary.  A decompressor may
-      ignore FLEVEL and still be compliant.  When the zlib data format
-      is being used as a part of another standard format, a compliant
-      decompressor must support all the preset dictionaries specified by
-      the other format. When the other format does not use the preset
-      dictionary feature, a compliant decompressor must reject any
-      stream in which the FDICT flag is set.
-
-3. References
-
-   [1] Deutsch, L.P.,"GZIP Compressed Data Format Specification",
-       available in ftp://ftp.uu.net/pub/archiving/zip/doc/
-
-   [2] Thomas Boutell, "PNG (Portable Network Graphics) specification",
-       available in ftp://ftp.uu.net/graphics/png/documents/
-
-   [3] Deutsch, L.P.,"DEFLATE Compressed Data Format Specification",
-       available in ftp://ftp.uu.net/pub/archiving/zip/doc/
-
-   [4] Fletcher, J. G., "An Arithmetic Checksum for Serial
-       Transmissions," IEEE Transactions on Communications, Vol. COM-30,
-       No. 1, January 1982, pp. 247-252.
-
-   [5] ITU-T Recommendation X.224, Annex D, "Checksum Algorithms,"
-       November, 1993, pp. 144, 145. (Available from
-       gopher://info.itu.ch). ITU-T X.244 is also the same as ISO 8073.
-
-
-
-
-
-
-
-Deutsch & Gailly             Informational                      [Page 7]
-
-RFC 1950       ZLIB Compressed Data Format Specification        May 1996
-
-
-4. Source code
-
-   Source code for a C language implementation of a "zlib" compliant
-   library is available at ftp://ftp.uu.net/pub/archiving/zip/zlib/.
-
-5. Security Considerations
-
-   A decoder that fails to check the ADLER32 checksum value may be
-   subject to undetected data corruption.
-
-6. Acknowledgements
-
-   Trademarks cited in this document are the property of their
-   respective owners.
-
-   Jean-Loup Gailly and Mark Adler designed the zlib format and wrote
-   the related software described in this specification.  Glenn
-   Randers-Pehrson converted this document to RFC and HTML format.
-
-7. Authors' Addresses
-
-   L. Peter Deutsch
-   Aladdin Enterprises
-   203 Santa Margarita Ave.
-   Menlo Park, CA 94025
-
-   Phone: (415) 322-0103 (AM only)
-   FAX:   (415) 322-1734
-   EMail: <ghost@aladdin.com>
-
-
-   Jean-Loup Gailly
-
-   EMail: <gzip@prep.ai.mit.edu>
-
-   Questions about the technical content of this specification can be
-   sent by email to
-
-   Jean-Loup Gailly <gzip@prep.ai.mit.edu> and
-   Mark Adler <madler@alumni.caltech.edu>
-
-   Editorial comments on this specification can be sent by email to
-
-   L. Peter Deutsch <ghost@aladdin.com> and
-   Glenn Randers-Pehrson <randeg@alumni.rpi.edu>
-
-
-
-
-
-
-Deutsch & Gailly             Informational                      [Page 8]
-
-RFC 1950       ZLIB Compressed Data Format Specification        May 1996
-
-
-8. Appendix: Rationale
-
-   8.1. Preset dictionaries
-
-      A preset dictionary is specially useful to compress short input
-      sequences. The compressor can take advantage of the dictionary
-      context to encode the input in a more compact manner. The
-      decompressor can be initialized with the appropriate context by
-      virtually decompressing a compressed version of the dictionary
-      without producing any output. However for certain compression
-      algorithms such as the deflate algorithm this operation can be
-      achieved without actually performing any decompression.
-
-      The compressor and the decompressor must use exactly the same
-      dictionary. The dictionary may be fixed or may be chosen among a
-      certain number of predefined dictionaries, according to the kind
-      of input data. The decompressor can determine which dictionary has
-      been chosen by the compressor by checking the dictionary
-      identifier. This document does not specify the contents of
-      predefined dictionaries, since the optimal dictionaries are
-      application specific. Standard data formats using this feature of
-      the zlib specification must precisely define the allowed
-      dictionaries.
-
-   8.2. The Adler-32 algorithm
-
-      The Adler-32 algorithm is much faster than the CRC32 algorithm yet
-      still provides an extremely low probability of undetected errors.
-
-      The modulo on unsigned long accumulators can be delayed for 5552
-      bytes, so the modulo operation time is negligible.  If the bytes
-      are a, b, c, the second sum is 3a + 2b + c + 3, and so is position
-      and order sensitive, unlike the first sum, which is just a
-      checksum.  That 65521 is prime is important to avoid a possible
-      large class of two-byte errors that leave the check unchanged.
-      (The Fletcher checksum uses 255, which is not prime and which also
-      makes the Fletcher check insensitive to single byte changes 0 <->
-      255.)
-
-      The sum s1 is initialized to 1 instead of zero to make the length
-      of the sequence part of s2, so that the length does not have to be
-      checked separately. (Any sequence of zeroes has a Fletcher
-      checksum of zero.)
-
-
-
-
-
-
-
-
-Deutsch & Gailly             Informational                      [Page 9]
-
-RFC 1950       ZLIB Compressed Data Format Specification        May 1996
-
-
-9. Appendix: Sample code
-
-   The following C code computes the Adler-32 checksum of a data buffer.
-   It is written for clarity, not for speed.  The sample code is in the
-   ANSI C programming language. Non C users may find it easier to read
-   with these hints:
-
-      &      Bitwise AND operator.
-      >>     Bitwise right shift operator. When applied to an
-             unsigned quantity, as here, right shift inserts zero bit(s)
-             at the left.
-      <<     Bitwise left shift operator. Left shift inserts zero
-             bit(s) at the right.
-      ++     "n++" increments the variable n.
-      %      modulo operator: a % b is the remainder of a divided by b.
-
-      #define BASE 65521 /* largest prime smaller than 65536 */
-
-      /*
-         Update a running Adler-32 checksum with the bytes buf[0..len-1]
-       and return the updated checksum. The Adler-32 checksum should be
-       initialized to 1.
-
-       Usage example:
-
-         unsigned long adler = 1L;
-
-         while (read_buffer(buffer, length) != EOF) {
-           adler = update_adler32(adler, buffer, length);
-         }
-         if (adler != original_adler) error();
-      */
-      unsigned long update_adler32(unsigned long adler,
-         unsigned char *buf, int len)
-      {
-        unsigned long s1 = adler & 0xffff;
-        unsigned long s2 = (adler >> 16) & 0xffff;
-        int n;
-
-        for (n = 0; n < len; n++) {
-          s1 = (s1 + buf[n]) % BASE;
-          s2 = (s2 + s1)     % BASE;
-        }
-        return (s2 << 16) + s1;
-      }
-
-      /* Return the adler32 of the bytes buf[0..len-1] */
-
-
-
-
-Deutsch & Gailly             Informational                     [Page 10]
-
-RFC 1950       ZLIB Compressed Data Format Specification        May 1996
-
-
-      unsigned long adler32(unsigned char *buf, int len)
-      {
-        return update_adler32(1L, buf, len);
-      }
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Deutsch & Gailly             Informational                     [Page 11]
-
diff -Nbaur gcc-4.8.1/zlib/doc/rfc1951.txt gcc-4.8.1-ppc/zlib/doc/rfc1951.txt
--- gcc-4.8.1/zlib/doc/rfc1951.txt	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/doc/rfc1951.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,955 +0,0 @@
-
-
-
-
-
-
-Network Working Group                                         P. Deutsch
-Request for Comments: 1951                           Aladdin Enterprises
-Category: Informational                                         May 1996
-
-
-        DEFLATE Compressed Data Format Specification version 1.3
-
-Status of This Memo
-
-   This memo provides information for the Internet community.  This memo
-   does not specify an Internet standard of any kind.  Distribution of
-   this memo is unlimited.
-
-IESG Note:
-
-   The IESG takes no position on the validity of any Intellectual
-   Property Rights statements contained in this document.
-
-Notices
-
-   Copyright (c) 1996 L. Peter Deutsch
-
-   Permission is granted to copy and distribute this document for any
-   purpose and without charge, including translations into other
-   languages and incorporation into compilations, provided that the
-   copyright notice and this notice are preserved, and that any
-   substantive changes or deletions from the original are clearly
-   marked.
-
-   A pointer to the latest version of this and related documentation in
-   HTML format can be found at the URL
-   <ftp://ftp.uu.net/graphics/png/documents/zlib/zdoc-index.html>.
-
-Abstract
-
-   This specification defines a lossless compressed data format that
-   compresses data using a combination of the LZ77 algorithm and Huffman
-   coding, with efficiency comparable to the best currently available
-   general-purpose compression methods.  The data can be produced or
-   consumed, even for an arbitrarily long sequentially presented input
-   data stream, using only an a priori bounded amount of intermediate
-   storage.  The format can be implemented readily in a manner not
-   covered by patents.
-
-
-
-
-
-
-
-
-Deutsch                      Informational                      [Page 1]
-
-RFC 1951      DEFLATE Compressed Data Format Specification      May 1996
-
-
-Table of Contents
-
-   1. Introduction ................................................... 2
-      1.1. Purpose ................................................... 2
-      1.2. Intended audience ......................................... 3
-      1.3. Scope ..................................................... 3
-      1.4. Compliance ................................................ 3
-      1.5.  Definitions of terms and conventions used ................ 3
-      1.6. Changes from previous versions ............................ 4
-   2. Compressed representation overview ............................. 4
-   3. Detailed specification ......................................... 5
-      3.1. Overall conventions ....................................... 5
-          3.1.1. Packing into bytes .................................. 5
-      3.2. Compressed block format ................................... 6
-          3.2.1. Synopsis of prefix and Huffman coding ............... 6
-          3.2.2. Use of Huffman coding in the "deflate" format ....... 7
-          3.2.3. Details of block format ............................. 9
-          3.2.4. Non-compressed blocks (BTYPE=00) ................... 11
-          3.2.5. Compressed blocks (length and distance codes) ...... 11
-          3.2.6. Compression with fixed Huffman codes (BTYPE=01) .... 12
-          3.2.7. Compression with dynamic Huffman codes (BTYPE=10) .. 13
-      3.3. Compliance ............................................... 14
-   4. Compression algorithm details ................................. 14
-   5. References .................................................... 16
-   6. Security Considerations ....................................... 16
-   7. Source code ................................................... 16
-   8. Acknowledgements .............................................. 16
-   9. Author's Address .............................................. 17
-
-1. Introduction
-
-   1.1. Purpose
-
-      The purpose of this specification is to define a lossless
-      compressed data format that:
-          * Is independent of CPU type, operating system, file system,
-            and character set, and hence can be used for interchange;
-          * Can be produced or consumed, even for an arbitrarily long
-            sequentially presented input data stream, using only an a
-            priori bounded amount of intermediate storage, and hence
-            can be used in data communications or similar structures
-            such as Unix filters;
-          * Compresses data with efficiency comparable to the best
-            currently available general-purpose compression methods,
-            and in particular considerably better than the "compress"
-            program;
-          * Can be implemented readily in a manner not covered by
-            patents, and hence can be practiced freely;
-
-
-
-Deutsch                      Informational                      [Page 2]
-
-RFC 1951      DEFLATE Compressed Data Format Specification      May 1996
-
-
-          * Is compatible with the file format produced by the current
-            widely used gzip utility, in that conforming decompressors
-            will be able to read data produced by the existing gzip
-            compressor.
-
-      The data format defined by this specification does not attempt to:
-
-          * Allow random access to compressed data;
-          * Compress specialized data (e.g., raster graphics) as well
-            as the best currently available specialized algorithms.
-
-      A simple counting argument shows that no lossless compression
-      algorithm can compress every possible input data set.  For the
-      format defined here, the worst case expansion is 5 bytes per 32K-
-      byte block, i.e., a size increase of 0.015% for large data sets.
-      English text usually compresses by a factor of 2.5 to 3;
-      executable files usually compress somewhat less; graphical data
-      such as raster images may compress much more.
-
-   1.2. Intended audience
-
-      This specification is intended for use by implementors of software
-      to compress data into "deflate" format and/or decompress data from
-      "deflate" format.
-
-      The text of the specification assumes a basic background in
-      programming at the level of bits and other primitive data
-      representations.  Familiarity with the technique of Huffman coding
-      is helpful but not required.
-
-   1.3. Scope
-
-      The specification specifies a method for representing a sequence
-      of bytes as a (usually shorter) sequence of bits, and a method for
-      packing the latter bit sequence into bytes.
-
-   1.4. Compliance
-
-      Unless otherwise indicated below, a compliant decompressor must be
-      able to accept and decompress any data set that conforms to all
-      the specifications presented here; a compliant compressor must
-      produce data sets that conform to all the specifications presented
-      here.
-
-   1.5.  Definitions of terms and conventions used
-
-      Byte: 8 bits stored or transmitted as a unit (same as an octet).
-      For this specification, a byte is exactly 8 bits, even on machines
-
-
-
-Deutsch                      Informational                      [Page 3]
-
-RFC 1951      DEFLATE Compressed Data Format Specification      May 1996
-
-
-      which store a character on a number of bits different from eight.
-      See below, for the numbering of bits within a byte.
-
-      String: a sequence of arbitrary bytes.
-
-   1.6. Changes from previous versions
-
-      There have been no technical changes to the deflate format since
-      version 1.1 of this specification.  In version 1.2, some
-      terminology was changed.  Version 1.3 is a conversion of the
-      specification to RFC style.
-
-2. Compressed representation overview
-
-   A compressed data set consists of a series of blocks, corresponding
-   to successive blocks of input data.  The block sizes are arbitrary,
-   except that non-compressible blocks are limited to 65,535 bytes.
-
-   Each block is compressed using a combination of the LZ77 algorithm
-   and Huffman coding. The Huffman trees for each block are independent
-   of those for previous or subsequent blocks; the LZ77 algorithm may
-   use a reference to a duplicated string occurring in a previous block,
-   up to 32K input bytes before.
-
-   Each block consists of two parts: a pair of Huffman code trees that
-   describe the representation of the compressed data part, and a
-   compressed data part.  (The Huffman trees themselves are compressed
-   using Huffman encoding.)  The compressed data consists of a series of
-   elements of two types: literal bytes (of strings that have not been
-   detected as duplicated within the previous 32K input bytes), and
-   pointers to duplicated strings, where a pointer is represented as a
-   pair <length, backward distance>.  The representation used in the
-   "deflate" format limits distances to 32K bytes and lengths to 258
-   bytes, but does not limit the size of a block, except for
-   uncompressible blocks, which are limited as noted above.
-
-   Each type of value (literals, distances, and lengths) in the
-   compressed data is represented using a Huffman code, using one code
-   tree for literals and lengths and a separate code tree for distances.
-   The code trees for each block appear in a compact form just before
-   the compressed data for that block.
-
-
-
-
-
-
-
-
-
-
-Deutsch                      Informational                      [Page 4]
-
-RFC 1951      DEFLATE Compressed Data Format Specification      May 1996
-
-
-3. Detailed specification
-
-   3.1. Overall conventions In the diagrams below, a box like this:
-
-         +---+
-         |   | <-- the vertical bars might be missing
-         +---+
-
-      represents one byte; a box like this:
-
-         +==============+
-         |              |
-         +==============+
-
-      represents a variable number of bytes.
-
-      Bytes stored within a computer do not have a "bit order", since
-      they are always treated as a unit.  However, a byte considered as
-      an integer between 0 and 255 does have a most- and least-
-      significant bit, and since we write numbers with the most-
-      significant digit on the left, we also write bytes with the most-
-      significant bit on the left.  In the diagrams below, we number the
-      bits of a byte so that bit 0 is the least-significant bit, i.e.,
-      the bits are numbered:
-
-         +--------+
-         |76543210|
-         +--------+
-
-      Within a computer, a number may occupy multiple bytes.  All
-      multi-byte numbers in the format described here are stored with
-      the least-significant byte first (at the lower memory address).
-      For example, the decimal number 520 is stored as:
-
-             0        1
-         +--------+--------+
-         |00001000|00000010|
-         +--------+--------+
-          ^        ^
-          |        |
-          |        + more significant byte = 2 x 256
-          + less significant byte = 8
-
-      3.1.1. Packing into bytes
-
-         This document does not address the issue of the order in which
-         bits of a byte are transmitted on a bit-sequential medium,
-         since the final data format described here is byte- rather than
-
-
-
-Deutsch                      Informational                      [Page 5]
-
-RFC 1951      DEFLATE Compressed Data Format Specification      May 1996
-
-
-         bit-oriented.  However, we describe the compressed block format
-         in below, as a sequence of data elements of various bit
-         lengths, not a sequence of bytes.  We must therefore specify
-         how to pack these data elements into bytes to form the final
-         compressed byte sequence:
-
-             * Data elements are packed into bytes in order of
-               increasing bit number within the byte, i.e., starting
-               with the least-significant bit of the byte.
-             * Data elements other than Huffman codes are packed
-               starting with the least-significant bit of the data
-               element.
-             * Huffman codes are packed starting with the most-
-               significant bit of the code.
-
-         In other words, if one were to print out the compressed data as
-         a sequence of bytes, starting with the first byte at the
-         *right* margin and proceeding to the *left*, with the most-
-         significant bit of each byte on the left as usual, one would be
-         able to parse the result from right to left, with fixed-width
-         elements in the correct MSB-to-LSB order and Huffman codes in
-         bit-reversed order (i.e., with the first bit of the code in the
-         relative LSB position).
-
-   3.2. Compressed block format
-
-      3.2.1. Synopsis of prefix and Huffman coding
-
-         Prefix coding represents symbols from an a priori known
-         alphabet by bit sequences (codes), one code for each symbol, in
-         a manner such that different symbols may be represented by bit
-         sequences of different lengths, but a parser can always parse
-         an encoded string unambiguously symbol-by-symbol.
-
-         We define a prefix code in terms of a binary tree in which the
-         two edges descending from each non-leaf node are labeled 0 and
-         1 and in which the leaf nodes correspond one-for-one with (are
-         labeled with) the symbols of the alphabet; then the code for a
-         symbol is the sequence of 0's and 1's on the edges leading from
-         the root to the leaf labeled with that symbol.  For example:
-
-
-
-
-
-
-
-
-
-
-
-Deutsch                      Informational                      [Page 6]
-
-RFC 1951      DEFLATE Compressed Data Format Specification      May 1996
-
-
-                          /\              Symbol    Code
-                         0  1             ------    ----
-                        /    \                A      00
-                       /\     B               B       1
-                      0  1                    C     011
-                     /    \                   D     010
-                    A     /\
-                         0  1
-                        /    \
-                       D      C
-
-         A parser can decode the next symbol from an encoded input
-         stream by walking down the tree from the root, at each step
-         choosing the edge corresponding to the next input bit.
-
-         Given an alphabet with known symbol frequencies, the Huffman
-         algorithm allows the construction of an optimal prefix code
-         (one which represents strings with those symbol frequencies
-         using the fewest bits of any possible prefix codes for that
-         alphabet).  Such a code is called a Huffman code.  (See
-         reference [1] in Chapter 5, references for additional
-         information on Huffman codes.)
-
-         Note that in the "deflate" format, the Huffman codes for the
-         various alphabets must not exceed certain maximum code lengths.
-         This constraint complicates the algorithm for computing code
-         lengths from symbol frequencies.  Again, see Chapter 5,
-         references for details.
-
-      3.2.2. Use of Huffman coding in the "deflate" format
-
-         The Huffman codes used for each alphabet in the "deflate"
-         format have two additional rules:
-
-             * All codes of a given bit length have lexicographically
-               consecutive values, in the same order as the symbols
-               they represent;
-
-             * Shorter codes lexicographically precede longer codes.
-
-
-
-
-
-
-
-
-
-
-
-
-Deutsch                      Informational                      [Page 7]
-
-RFC 1951      DEFLATE Compressed Data Format Specification      May 1996
-
-
-         We could recode the example above to follow this rule as
-         follows, assuming that the order of the alphabet is ABCD:
-
-            Symbol  Code
-            ------  ----
-            A       10
-            B       0
-            C       110
-            D       111
-
-         I.e., 0 precedes 10 which precedes 11x, and 110 and 111 are
-         lexicographically consecutive.
-
-         Given this rule, we can define the Huffman code for an alphabet
-         just by giving the bit lengths of the codes for each symbol of
-         the alphabet in order; this is sufficient to determine the
-         actual codes.  In our example, the code is completely defined
-         by the sequence of bit lengths (2, 1, 3, 3).  The following
-         algorithm generates the codes as integers, intended to be read
-         from most- to least-significant bit.  The code lengths are
-         initially in tree[I].Len; the codes are produced in
-         tree[I].Code.
-
-         1)  Count the number of codes for each code length.  Let
-             bl_count[N] be the number of codes of length N, N >= 1.
-
-         2)  Find the numerical value of the smallest code for each
-             code length:
-
-                code = 0;
-                bl_count[0] = 0;
-                for (bits = 1; bits <= MAX_BITS; bits++) {
-                    code = (code + bl_count[bits-1]) << 1;
-                    next_code[bits] = code;
-                }
-
-         3)  Assign numerical values to all codes, using consecutive
-             values for all codes of the same length with the base
-             values determined at step 2. Codes that are never used
-             (which have a bit length of zero) must not be assigned a
-             value.
-
-                for (n = 0;  n <= max_code; n++) {
-                    len = tree[n].Len;
-                    if (len != 0) {
-                        tree[n].Code = next_code[len];
-                        next_code[len]++;
-                    }
-
-
-
-Deutsch                      Informational                      [Page 8]
-
-RFC 1951      DEFLATE Compressed Data Format Specification      May 1996
-
-
-                }
-
-         Example:
-
-         Consider the alphabet ABCDEFGH, with bit lengths (3, 3, 3, 3,
-         3, 2, 4, 4).  After step 1, we have:
-
-            N      bl_count[N]
-            -      -----------
-            2      1
-            3      5
-            4      2
-
-         Step 2 computes the following next_code values:
-
-            N      next_code[N]
-            -      ------------
-            1      0
-            2      0
-            3      2
-            4      14
-
-         Step 3 produces the following code values:
-
-            Symbol Length   Code
-            ------ ------   ----
-            A       3        010
-            B       3        011
-            C       3        100
-            D       3        101
-            E       3        110
-            F       2         00
-            G       4       1110
-            H       4       1111
-
-      3.2.3. Details of block format
-
-         Each block of compressed data begins with 3 header bits
-         containing the following data:
-
-            first bit       BFINAL
-            next 2 bits     BTYPE
-
-         Note that the header bits do not necessarily begin on a byte
-         boundary, since a block does not necessarily occupy an integral
-         number of bytes.
-
-
-
-
-
-Deutsch                      Informational                      [Page 9]
-
-RFC 1951      DEFLATE Compressed Data Format Specification      May 1996
-
-
-         BFINAL is set if and only if this is the last block of the data
-         set.
-
-         BTYPE specifies how the data are compressed, as follows:
-
-            00 - no compression
-            01 - compressed with fixed Huffman codes
-            10 - compressed with dynamic Huffman codes
-            11 - reserved (error)
-
-         The only difference between the two compressed cases is how the
-         Huffman codes for the literal/length and distance alphabets are
-         defined.
-
-         In all cases, the decoding algorithm for the actual data is as
-         follows:
-
-            do
-               read block header from input stream.
-               if stored with no compression
-                  skip any remaining bits in current partially
-                     processed byte
-                  read LEN and NLEN (see next section)
-                  copy LEN bytes of data to output
-               otherwise
-                  if compressed with dynamic Huffman codes
-                     read representation of code trees (see
-                        subsection below)
-                  loop (until end of block code recognized)
-                     decode literal/length value from input stream
-                     if value < 256
-                        copy value (literal byte) to output stream
-                     otherwise
-                        if value = end of block (256)
-                           break from loop
-                        otherwise (value = 257..285)
-                           decode distance from input stream
-
-                           move backwards distance bytes in the output
-                           stream, and copy length bytes from this
-                           position to the output stream.
-                  end loop
-            while not last block
-
-         Note that a duplicated string reference may refer to a string
-         in a previous block; i.e., the backward distance may cross one
-         or more block boundaries.  However a distance cannot refer past
-         the beginning of the output stream.  (An application using a
-
-
-
-Deutsch                      Informational                     [Page 10]
-
-RFC 1951      DEFLATE Compressed Data Format Specification      May 1996
-
-
-         preset dictionary might discard part of the output stream; a
-         distance can refer to that part of the output stream anyway)
-         Note also that the referenced string may overlap the current
-         position; for example, if the last 2 bytes decoded have values
-         X and Y, a string reference with <length = 5, distance = 2>
-         adds X,Y,X,Y,X to the output stream.
-
-         We now specify each compression method in turn.
-
-      3.2.4. Non-compressed blocks (BTYPE=00)
-
-         Any bits of input up to the next byte boundary are ignored.
-         The rest of the block consists of the following information:
-
-              0   1   2   3   4...
-            +---+---+---+---+================================+
-            |  LEN  | NLEN  |... LEN bytes of literal data...|
-            +---+---+---+---+================================+
-
-         LEN is the number of data bytes in the block.  NLEN is the
-         one's complement of LEN.
-
-      3.2.5. Compressed blocks (length and distance codes)
-
-         As noted above, encoded data blocks in the "deflate" format
-         consist of sequences of symbols drawn from three conceptually
-         distinct alphabets: either literal bytes, from the alphabet of
-         byte values (0..255), or <length, backward distance> pairs,
-         where the length is drawn from (3..258) and the distance is
-         drawn from (1..32,768).  In fact, the literal and length
-         alphabets are merged into a single alphabet (0..285), where
-         values 0..255 represent literal bytes, the value 256 indicates
-         end-of-block, and values 257..285 represent length codes
-         (possibly in conjunction with extra bits following the symbol
-         code) as follows:
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Deutsch                      Informational                     [Page 11]
-
-RFC 1951      DEFLATE Compressed Data Format Specification      May 1996
-
-
-                 Extra               Extra               Extra
-            Code Bits Length(s) Code Bits Lengths   Code Bits Length(s)
-            ---- ---- ------     ---- ---- -------   ---- ---- -------
-             257   0     3       267   1   15,16     277   4   67-82
-             258   0     4       268   1   17,18     278   4   83-98
-             259   0     5       269   2   19-22     279   4   99-114
-             260   0     6       270   2   23-26     280   4  115-130
-             261   0     7       271   2   27-30     281   5  131-162
-             262   0     8       272   2   31-34     282   5  163-194
-             263   0     9       273   3   35-42     283   5  195-226
-             264   0    10       274   3   43-50     284   5  227-257
-             265   1  11,12      275   3   51-58     285   0    258
-             266   1  13,14      276   3   59-66
-
-         The extra bits should be interpreted as a machine integer
-         stored with the most-significant bit first, e.g., bits 1110
-         represent the value 14.
-
-                  Extra           Extra               Extra
-             Code Bits Dist  Code Bits   Dist     Code Bits Distance
-             ---- ---- ----  ---- ----  ------    ---- ---- --------
-               0   0    1     10   4     33-48    20    9   1025-1536
-               1   0    2     11   4     49-64    21    9   1537-2048
-               2   0    3     12   5     65-96    22   10   2049-3072
-               3   0    4     13   5     97-128   23   10   3073-4096
-               4   1   5,6    14   6    129-192   24   11   4097-6144
-               5   1   7,8    15   6    193-256   25   11   6145-8192
-               6   2   9-12   16   7    257-384   26   12  8193-12288
-               7   2  13-16   17   7    385-512   27   12 12289-16384
-               8   3  17-24   18   8    513-768   28   13 16385-24576
-               9   3  25-32   19   8   769-1024   29   13 24577-32768
-
-      3.2.6. Compression with fixed Huffman codes (BTYPE=01)
-
-         The Huffman codes for the two alphabets are fixed, and are not
-         represented explicitly in the data.  The Huffman code lengths
-         for the literal/length alphabet are:
-
-                   Lit Value    Bits        Codes
-                   ---------    ----        -----
-                     0 - 143     8          00110000 through
-                                            10111111
-                   144 - 255     9          110010000 through
-                                            111111111
-                   256 - 279     7          0000000 through
-                                            0010111
-                   280 - 287     8          11000000 through
-                                            11000111
-
-
-
-Deutsch                      Informational                     [Page 12]
-
-RFC 1951      DEFLATE Compressed Data Format Specification      May 1996
-
-
-         The code lengths are sufficient to generate the actual codes,
-         as described above; we show the codes in the table for added
-         clarity.  Literal/length values 286-287 will never actually
-         occur in the compressed data, but participate in the code
-         construction.
-
-         Distance codes 0-31 are represented by (fixed-length) 5-bit
-         codes, with possible additional bits as shown in the table
-         shown in Paragraph 3.2.5, above.  Note that distance codes 30-
-         31 will never actually occur in the compressed data.
-
-      3.2.7. Compression with dynamic Huffman codes (BTYPE=10)
-
-         The Huffman codes for the two alphabets appear in the block
-         immediately after the header bits and before the actual
-         compressed data, first the literal/length code and then the
-         distance code.  Each code is defined by a sequence of code
-         lengths, as discussed in Paragraph 3.2.2, above.  For even
-         greater compactness, the code length sequences themselves are
-         compressed using a Huffman code.  The alphabet for code lengths
-         is as follows:
-
-               0 - 15: Represent code lengths of 0 - 15
-                   16: Copy the previous code length 3 - 6 times.
-                       The next 2 bits indicate repeat length
-                             (0 = 3, ... , 3 = 6)
-                          Example:  Codes 8, 16 (+2 bits 11),
-                                    16 (+2 bits 10) will expand to
-                                    12 code lengths of 8 (1 + 6 + 5)
-                   17: Repeat a code length of 0 for 3 - 10 times.
-                       (3 bits of length)
-                   18: Repeat a code length of 0 for 11 - 138 times
-                       (7 bits of length)
-
-         A code length of 0 indicates that the corresponding symbol in
-         the literal/length or distance alphabet will not occur in the
-         block, and should not participate in the Huffman code
-         construction algorithm given earlier.  If only one distance
-         code is used, it is encoded using one bit, not zero bits; in
-         this case there is a single code length of one, with one unused
-         code.  One distance code of zero bits means that there are no
-         distance codes used at all (the data is all literals).
-
-         We can now define the format of the block:
-
-               5 Bits: HLIT, # of Literal/Length codes - 257 (257 - 286)
-               5 Bits: HDIST, # of Distance codes - 1        (1 - 32)
-               4 Bits: HCLEN, # of Code Length codes - 4     (4 - 19)
-
-
-
-Deutsch                      Informational                     [Page 13]
-
-RFC 1951      DEFLATE Compressed Data Format Specification      May 1996
-
-
-               (HCLEN + 4) x 3 bits: code lengths for the code length
-                  alphabet given just above, in the order: 16, 17, 18,
-                  0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
-
-                  These code lengths are interpreted as 3-bit integers
-                  (0-7); as above, a code length of 0 means the
-                  corresponding symbol (literal/length or distance code
-                  length) is not used.
-
-               HLIT + 257 code lengths for the literal/length alphabet,
-                  encoded using the code length Huffman code
-
-               HDIST + 1 code lengths for the distance alphabet,
-                  encoded using the code length Huffman code
-
-               The actual compressed data of the block,
-                  encoded using the literal/length and distance Huffman
-                  codes
-
-               The literal/length symbol 256 (end of data),
-                  encoded using the literal/length Huffman code
-
-         The code length repeat codes can cross from HLIT + 257 to the
-         HDIST + 1 code lengths.  In other words, all code lengths form
-         a single sequence of HLIT + HDIST + 258 values.
-
-   3.3. Compliance
-
-      A compressor may limit further the ranges of values specified in
-      the previous section and still be compliant; for example, it may
-      limit the range of backward pointers to some value smaller than
-      32K.  Similarly, a compressor may limit the size of blocks so that
-      a compressible block fits in memory.
-
-      A compliant decompressor must accept the full range of possible
-      values defined in the previous section, and must accept blocks of
-      arbitrary size.
-
-4. Compression algorithm details
-
-   While it is the intent of this document to define the "deflate"
-   compressed data format without reference to any particular
-   compression algorithm, the format is related to the compressed
-   formats produced by LZ77 (Lempel-Ziv 1977, see reference [2] below);
-   since many variations of LZ77 are patented, it is strongly
-   recommended that the implementor of a compressor follow the general
-   algorithm presented here, which is known not to be patented per se.
-   The material in this section is not part of the definition of the
-
-
-
-Deutsch                      Informational                     [Page 14]
-
-RFC 1951      DEFLATE Compressed Data Format Specification      May 1996
-
-
-   specification per se, and a compressor need not follow it in order to
-   be compliant.
-
-   The compressor terminates a block when it determines that starting a
-   new block with fresh trees would be useful, or when the block size
-   fills up the compressor's block buffer.
-
-   The compressor uses a chained hash table to find duplicated strings,
-   using a hash function that operates on 3-byte sequences.  At any
-   given point during compression, let XYZ be the next 3 input bytes to
-   be examined (not necessarily all different, of course).  First, the
-   compressor examines the hash chain for XYZ.  If the chain is empty,
-   the compressor simply writes out X as a literal byte and advances one
-   byte in the input.  If the hash chain is not empty, indicating that
-   the sequence XYZ (or, if we are unlucky, some other 3 bytes with the
-   same hash function value) has occurred recently, the compressor
-   compares all strings on the XYZ hash chain with the actual input data
-   sequence starting at the current point, and selects the longest
-   match.
-
-   The compressor searches the hash chains starting with the most recent
-   strings, to favor small distances and thus take advantage of the
-   Huffman encoding.  The hash chains are singly linked. There are no
-   deletions from the hash chains; the algorithm simply discards matches
-   that are too old.  To avoid a worst-case situation, very long hash
-   chains are arbitrarily truncated at a certain length, determined by a
-   run-time parameter.
-
-   To improve overall compression, the compressor optionally defers the
-   selection of matches ("lazy matching"): after a match of length N has
-   been found, the compressor searches for a longer match starting at
-   the next input byte.  If it finds a longer match, it truncates the
-   previous match to a length of one (thus producing a single literal
-   byte) and then emits the longer match.  Otherwise, it emits the
-   original match, and, as described above, advances N bytes before
-   continuing.
-
-   Run-time parameters also control this "lazy match" procedure.  If
-   compression ratio is most important, the compressor attempts a
-   complete second search regardless of the length of the first match.
-   In the normal case, if the current match is "long enough", the
-   compressor reduces the search for a longer match, thus speeding up
-   the process.  If speed is most important, the compressor inserts new
-   strings in the hash table only when no match was found, or when the
-   match is not "too long".  This degrades the compression ratio but
-   saves time since there are both fewer insertions and fewer searches.
-
-
-
-
-
-Deutsch                      Informational                     [Page 15]
-
-RFC 1951      DEFLATE Compressed Data Format Specification      May 1996
-
-
-5. References
-
-   [1] Huffman, D. A., "A Method for the Construction of Minimum
-       Redundancy Codes", Proceedings of the Institute of Radio
-       Engineers, September 1952, Volume 40, Number 9, pp. 1098-1101.
-
-   [2] Ziv J., Lempel A., "A Universal Algorithm for Sequential Data
-       Compression", IEEE Transactions on Information Theory, Vol. 23,
-       No. 3, pp. 337-343.
-
-   [3] Gailly, J.-L., and Adler, M., ZLIB documentation and sources,
-       available in ftp://ftp.uu.net/pub/archiving/zip/doc/
-
-   [4] Gailly, J.-L., and Adler, M., GZIP documentation and sources,
-       available as gzip-*.tar in ftp://prep.ai.mit.edu/pub/gnu/
-
-   [5] Schwartz, E. S., and Kallick, B. "Generating a canonical prefix
-       encoding." Comm. ACM, 7,3 (Mar. 1964), pp. 166-169.
-
-   [6] Hirschberg and Lelewer, "Efficient decoding of prefix codes,"
-       Comm. ACM, 33,4, April 1990, pp. 449-459.
-
-6. Security Considerations
-
-   Any data compression method involves the reduction of redundancy in
-   the data.  Consequently, any corruption of the data is likely to have
-   severe effects and be difficult to correct.  Uncompressed text, on
-   the other hand, will probably still be readable despite the presence
-   of some corrupted bytes.
-
-   It is recommended that systems using this data format provide some
-   means of validating the integrity of the compressed data.  See
-   reference [3], for example.
-
-7. Source code
-
-   Source code for a C language implementation of a "deflate" compliant
-   compressor and decompressor is available within the zlib package at
-   ftp://ftp.uu.net/pub/archiving/zip/zlib/.
-
-8. Acknowledgements
-
-   Trademarks cited in this document are the property of their
-   respective owners.
-
-   Phil Katz designed the deflate format.  Jean-Loup Gailly and Mark
-   Adler wrote the related software described in this specification.
-   Glenn Randers-Pehrson converted this document to RFC and HTML format.
-
-
-
-Deutsch                      Informational                     [Page 16]
-
-RFC 1951      DEFLATE Compressed Data Format Specification      May 1996
-
-
-9. Author's Address
-
-   L. Peter Deutsch
-   Aladdin Enterprises
-   203 Santa Margarita Ave.
-   Menlo Park, CA 94025
-
-   Phone: (415) 322-0103 (AM only)
-   FAX:   (415) 322-1734
-   EMail: <ghost@aladdin.com>
-
-   Questions about the technical content of this specification can be
-   sent by email to:
-
-   Jean-Loup Gailly <gzip@prep.ai.mit.edu> and
-   Mark Adler <madler@alumni.caltech.edu>
-
-   Editorial comments on this specification can be sent by email to:
-
-   L. Peter Deutsch <ghost@aladdin.com> and
-   Glenn Randers-Pehrson <randeg@alumni.rpi.edu>
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Deutsch                      Informational                     [Page 17]
-
diff -Nbaur gcc-4.8.1/zlib/doc/rfc1952.txt gcc-4.8.1-ppc/zlib/doc/rfc1952.txt
--- gcc-4.8.1/zlib/doc/rfc1952.txt	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/doc/rfc1952.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,675 +0,0 @@
-
-
-
-
-
-
-Network Working Group                                         P. Deutsch
-Request for Comments: 1952                           Aladdin Enterprises
-Category: Informational                                         May 1996
-
-
-               GZIP file format specification version 4.3
-
-Status of This Memo
-
-   This memo provides information for the Internet community.  This memo
-   does not specify an Internet standard of any kind.  Distribution of
-   this memo is unlimited.
-
-IESG Note:
-
-   The IESG takes no position on the validity of any Intellectual
-   Property Rights statements contained in this document.
-
-Notices
-
-   Copyright (c) 1996 L. Peter Deutsch
-
-   Permission is granted to copy and distribute this document for any
-   purpose and without charge, including translations into other
-   languages and incorporation into compilations, provided that the
-   copyright notice and this notice are preserved, and that any
-   substantive changes or deletions from the original are clearly
-   marked.
-
-   A pointer to the latest version of this and related documentation in
-   HTML format can be found at the URL
-   <ftp://ftp.uu.net/graphics/png/documents/zlib/zdoc-index.html>.
-
-Abstract
-
-   This specification defines a lossless compressed data format that is
-   compatible with the widely used GZIP utility.  The format includes a
-   cyclic redundancy check value for detecting data corruption.  The
-   format presently uses the DEFLATE method of compression but can be
-   easily extended to use other compression methods.  The format can be
-   implemented readily in a manner not covered by patents.
-
-
-
-
-
-
-
-
-
-
-Deutsch                      Informational                      [Page 1]
-
-RFC 1952             GZIP File Format Specification             May 1996
-
-
-Table of Contents
-
-   1. Introduction ................................................... 2
-      1.1. Purpose ................................................... 2
-      1.2. Intended audience ......................................... 3
-      1.3. Scope ..................................................... 3
-      1.4. Compliance ................................................ 3
-      1.5. Definitions of terms and conventions used ................. 3
-      1.6. Changes from previous versions ............................ 3
-   2. Detailed specification ......................................... 4
-      2.1. Overall conventions ....................................... 4
-      2.2. File format ............................................... 5
-      2.3. Member format ............................................. 5
-          2.3.1. Member header and trailer ........................... 6
-              2.3.1.1. Extra field ................................... 8
-              2.3.1.2. Compliance .................................... 9
-      3. References .................................................. 9
-      4. Security Considerations .................................... 10
-      5. Acknowledgements ........................................... 10
-      6. Author's Address ........................................... 10
-      7. Appendix: Jean-Loup Gailly's gzip utility .................. 11
-      8. Appendix: Sample CRC Code .................................. 11
-
-1. Introduction
-
-   1.1. Purpose
-
-      The purpose of this specification is to define a lossless
-      compressed data format that:
-
-          * Is independent of CPU type, operating system, file system,
-            and character set, and hence can be used for interchange;
-          * Can compress or decompress a data stream (as opposed to a
-            randomly accessible file) to produce another data stream,
-            using only an a priori bounded amount of intermediate
-            storage, and hence can be used in data communications or
-            similar structures such as Unix filters;
-          * Compresses data with efficiency comparable to the best
-            currently available general-purpose compression methods,
-            and in particular considerably better than the "compress"
-            program;
-          * Can be implemented readily in a manner not covered by
-            patents, and hence can be practiced freely;
-          * Is compatible with the file format produced by the current
-            widely used gzip utility, in that conforming decompressors
-            will be able to read data produced by the existing gzip
-            compressor.
-
-
-
-
-Deutsch                      Informational                      [Page 2]
-
-RFC 1952             GZIP File Format Specification             May 1996
-
-
-      The data format defined by this specification does not attempt to:
-
-          * Provide random access to compressed data;
-          * Compress specialized data (e.g., raster graphics) as well as
-            the best currently available specialized algorithms.
-
-   1.2. Intended audience
-
-      This specification is intended for use by implementors of software
-      to compress data into gzip format and/or decompress data from gzip
-      format.
-
-      The text of the specification assumes a basic background in
-      programming at the level of bits and other primitive data
-      representations.
-
-   1.3. Scope
-
-      The specification specifies a compression method and a file format
-      (the latter assuming only that a file can store a sequence of
-      arbitrary bytes).  It does not specify any particular interface to
-      a file system or anything about character sets or encodings
-      (except for file names and comments, which are optional).
-
-   1.4. Compliance
-
-      Unless otherwise indicated below, a compliant decompressor must be
-      able to accept and decompress any file that conforms to all the
-      specifications presented here; a compliant compressor must produce
-      files that conform to all the specifications presented here.  The
-      material in the appendices is not part of the specification per se
-      and is not relevant to compliance.
-
-   1.5. Definitions of terms and conventions used
-
-      byte: 8 bits stored or transmitted as a unit (same as an octet).
-      (For this specification, a byte is exactly 8 bits, even on
-      machines which store a character on a number of bits different
-      from 8.)  See below for the numbering of bits within a byte.
-
-   1.6. Changes from previous versions
-
-      There have been no technical changes to the gzip format since
-      version 4.1 of this specification.  In version 4.2, some
-      terminology was changed, and the sample CRC code was rewritten for
-      clarity and to eliminate the requirement for the caller to do pre-
-      and post-conditioning.  Version 4.3 is a conversion of the
-      specification to RFC style.
-
-
-
-Deutsch                      Informational                      [Page 3]
-
-RFC 1952             GZIP File Format Specification             May 1996
-
-
-2. Detailed specification
-
-   2.1. Overall conventions
-
-      In the diagrams below, a box like this:
-
-         +---+
-         |   | <-- the vertical bars might be missing
-         +---+
-
-      represents one byte; a box like this:
-
-         +==============+
-         |              |
-         +==============+
-
-      represents a variable number of bytes.
-
-      Bytes stored within a computer do not have a "bit order", since
-      they are always treated as a unit.  However, a byte considered as
-      an integer between 0 and 255 does have a most- and least-
-      significant bit, and since we write numbers with the most-
-      significant digit on the left, we also write bytes with the most-
-      significant bit on the left.  In the diagrams below, we number the
-      bits of a byte so that bit 0 is the least-significant bit, i.e.,
-      the bits are numbered:
-
-         +--------+
-         |76543210|
-         +--------+
-
-      This document does not address the issue of the order in which
-      bits of a byte are transmitted on a bit-sequential medium, since
-      the data format described here is byte- rather than bit-oriented.
-
-      Within a computer, a number may occupy multiple bytes.  All
-      multi-byte numbers in the format described here are stored with
-      the least-significant byte first (at the lower memory address).
-      For example, the decimal number 520 is stored as:
-
-             0        1
-         +--------+--------+
-         |00001000|00000010|
-         +--------+--------+
-          ^        ^
-          |        |
-          |        + more significant byte = 2 x 256
-          + less significant byte = 8
-
-
-
-Deutsch                      Informational                      [Page 4]
-
-RFC 1952             GZIP File Format Specification             May 1996
-
-
-   2.2. File format
-
-      A gzip file consists of a series of "members" (compressed data
-      sets).  The format of each member is specified in the following
-      section.  The members simply appear one after another in the file,
-      with no additional information before, between, or after them.
-
-   2.3. Member format
-
-      Each member has the following structure:
-
-         +---+---+---+---+---+---+---+---+---+---+
-         |ID1|ID2|CM |FLG|     MTIME     |XFL|OS | (more-->)
-         +---+---+---+---+---+---+---+---+---+---+
-
-      (if FLG.FEXTRA set)
-
-         +---+---+=================================+
-         | XLEN  |...XLEN bytes of "extra field"...| (more-->)
-         +---+---+=================================+
-
-      (if FLG.FNAME set)
-
-         +=========================================+
-         |...original file name, zero-terminated...| (more-->)
-         +=========================================+
-
-      (if FLG.FCOMMENT set)
-
-         +===================================+
-         |...file comment, zero-terminated...| (more-->)
-         +===================================+
-
-      (if FLG.FHCRC set)
-
-         +---+---+
-         | CRC16 |
-         +---+---+
-
-         +=======================+
-         |...compressed blocks...| (more-->)
-         +=======================+
-
-           0   1   2   3   4   5   6   7
-         +---+---+---+---+---+---+---+---+
-         |     CRC32     |     ISIZE     |
-         +---+---+---+---+---+---+---+---+
-
-
-
-
-Deutsch                      Informational                      [Page 5]
-
-RFC 1952             GZIP File Format Specification             May 1996
-
-
-      2.3.1. Member header and trailer
-
-         ID1 (IDentification 1)
-         ID2 (IDentification 2)
-            These have the fixed values ID1 = 31 (0x1f, \037), ID2 = 139
-            (0x8b, \213), to identify the file as being in gzip format.
-
-         CM (Compression Method)
-            This identifies the compression method used in the file.  CM
-            = 0-7 are reserved.  CM = 8 denotes the "deflate"
-            compression method, which is the one customarily used by
-            gzip and which is documented elsewhere.
-
-         FLG (FLaGs)
-            This flag byte is divided into individual bits as follows:
-
-               bit 0   FTEXT
-               bit 1   FHCRC
-               bit 2   FEXTRA
-               bit 3   FNAME
-               bit 4   FCOMMENT
-               bit 5   reserved
-               bit 6   reserved
-               bit 7   reserved
-
-            If FTEXT is set, the file is probably ASCII text.  This is
-            an optional indication, which the compressor may set by
-            checking a small amount of the input data to see whether any
-            non-ASCII characters are present.  In case of doubt, FTEXT
-            is cleared, indicating binary data. For systems which have
-            different file formats for ascii text and binary data, the
-            decompressor can use FTEXT to choose the appropriate format.
-            We deliberately do not specify the algorithm used to set
-            this bit, since a compressor always has the option of
-            leaving it cleared and a decompressor always has the option
-            of ignoring it and letting some other program handle issues
-            of data conversion.
-
-            If FHCRC is set, a CRC16 for the gzip header is present,
-            immediately before the compressed data. The CRC16 consists
-            of the two least significant bytes of the CRC32 for all
-            bytes of the gzip header up to and not including the CRC16.
-            [The FHCRC bit was never set by versions of gzip up to
-            1.2.4, even though it was documented with a different
-            meaning in gzip 1.2.4.]
-
-            If FEXTRA is set, optional extra fields are present, as
-            described in a following section.
-
-
-
-Deutsch                      Informational                      [Page 6]
-
-RFC 1952             GZIP File Format Specification             May 1996
-
-
-            If FNAME is set, an original file name is present,
-            terminated by a zero byte.  The name must consist of ISO
-            8859-1 (LATIN-1) characters; on operating systems using
-            EBCDIC or any other character set for file names, the name
-            must be translated to the ISO LATIN-1 character set.  This
-            is the original name of the file being compressed, with any
-            directory components removed, and, if the file being
-            compressed is on a file system with case insensitive names,
-            forced to lower case. There is no original file name if the
-            data was compressed from a source other than a named file;
-            for example, if the source was stdin on a Unix system, there
-            is no file name.
-
-            If FCOMMENT is set, a zero-terminated file comment is
-            present.  This comment is not interpreted; it is only
-            intended for human consumption.  The comment must consist of
-            ISO 8859-1 (LATIN-1) characters.  Line breaks should be
-            denoted by a single line feed character (10 decimal).
-
-            Reserved FLG bits must be zero.
-
-         MTIME (Modification TIME)
-            This gives the most recent modification time of the original
-            file being compressed.  The time is in Unix format, i.e.,
-            seconds since 00:00:00 GMT, Jan.  1, 1970.  (Note that this
-            may cause problems for MS-DOS and other systems that use
-            local rather than Universal time.)  If the compressed data
-            did not come from a file, MTIME is set to the time at which
-            compression started.  MTIME = 0 means no time stamp is
-            available.
-
-         XFL (eXtra FLags)
-            These flags are available for use by specific compression
-            methods.  The "deflate" method (CM = 8) sets these flags as
-            follows:
-
-               XFL = 2 - compressor used maximum compression,
-                         slowest algorithm
-               XFL = 4 - compressor used fastest algorithm
-
-         OS (Operating System)
-            This identifies the type of file system on which compression
-            took place.  This may be useful in determining end-of-line
-            convention for text files.  The currently defined values are
-            as follows:
-
-
-
-
-
-
-Deutsch                      Informational                      [Page 7]
-
-RFC 1952             GZIP File Format Specification             May 1996
-
-
-                 0 - FAT filesystem (MS-DOS, OS/2, NT/Win32)
-                 1 - Amiga
-                 2 - VMS (or OpenVMS)
-                 3 - Unix
-                 4 - VM/CMS
-                 5 - Atari TOS
-                 6 - HPFS filesystem (OS/2, NT)
-                 7 - Macintosh
-                 8 - Z-System
-                 9 - CP/M
-                10 - TOPS-20
-                11 - NTFS filesystem (NT)
-                12 - QDOS
-                13 - Acorn RISCOS
-               255 - unknown
-
-         XLEN (eXtra LENgth)
-            If FLG.FEXTRA is set, this gives the length of the optional
-            extra field.  See below for details.
-
-         CRC32 (CRC-32)
-            This contains a Cyclic Redundancy Check value of the
-            uncompressed data computed according to CRC-32 algorithm
-            used in the ISO 3309 standard and in section 8.1.1.6.2 of
-            ITU-T recommendation V.42.  (See http://www.iso.ch for
-            ordering ISO documents. See gopher://info.itu.ch for an
-            online version of ITU-T V.42.)
-
-         ISIZE (Input SIZE)
-            This contains the size of the original (uncompressed) input
-            data modulo 2^32.
-
-      2.3.1.1. Extra field
-
-         If the FLG.FEXTRA bit is set, an "extra field" is present in
-         the header, with total length XLEN bytes.  It consists of a
-         series of subfields, each of the form:
-
-            +---+---+---+---+==================================+
-            |SI1|SI2|  LEN  |... LEN bytes of subfield data ...|
-            +---+---+---+---+==================================+
-
-         SI1 and SI2 provide a subfield ID, typically two ASCII letters
-         with some mnemonic value.  Jean-Loup Gailly
-         <gzip@prep.ai.mit.edu> is maintaining a registry of subfield
-         IDs; please send him any subfield ID you wish to use.  Subfield
-         IDs with SI2 = 0 are reserved for future use.  The following
-         IDs are currently defined:
-
-
-
-Deutsch                      Informational                      [Page 8]
-
-RFC 1952             GZIP File Format Specification             May 1996
-
-
-            SI1         SI2         Data
-            ----------  ----------  ----
-            0x41 ('A')  0x70 ('P')  Apollo file type information
-
-         LEN gives the length of the subfield data, excluding the 4
-         initial bytes.
-
-      2.3.1.2. Compliance
-
-         A compliant compressor must produce files with correct ID1,
-         ID2, CM, CRC32, and ISIZE, but may set all the other fields in
-         the fixed-length part of the header to default values (255 for
-         OS, 0 for all others).  The compressor must set all reserved
-         bits to zero.
-
-         A compliant decompressor must check ID1, ID2, and CM, and
-         provide an error indication if any of these have incorrect
-         values.  It must examine FEXTRA/XLEN, FNAME, FCOMMENT and FHCRC
-         at least so it can skip over the optional fields if they are
-         present.  It need not examine any other part of the header or
-         trailer; in particular, a decompressor may ignore FTEXT and OS
-         and always produce binary output, and still be compliant.  A
-         compliant decompressor must give an error indication if any
-         reserved bit is non-zero, since such a bit could indicate the
-         presence of a new field that would cause subsequent data to be
-         interpreted incorrectly.
-
-3. References
-
-   [1] "Information Processing - 8-bit single-byte coded graphic
-       character sets - Part 1: Latin alphabet No.1" (ISO 8859-1:1987).
-       The ISO 8859-1 (Latin-1) character set is a superset of 7-bit
-       ASCII. Files defining this character set are available as
-       iso_8859-1.* in ftp://ftp.uu.net/graphics/png/documents/
-
-   [2] ISO 3309
-
-   [3] ITU-T recommendation V.42
-
-   [4] Deutsch, L.P.,"DEFLATE Compressed Data Format Specification",
-       available in ftp://ftp.uu.net/pub/archiving/zip/doc/
-
-   [5] Gailly, J.-L., GZIP documentation, available as gzip-*.tar in
-       ftp://prep.ai.mit.edu/pub/gnu/
-
-   [6] Sarwate, D.V., "Computation of Cyclic Redundancy Checks via Table
-       Look-Up", Communications of the ACM, 31(8), pp.1008-1013.
-
-
-
-
-Deutsch                      Informational                      [Page 9]
-
-RFC 1952             GZIP File Format Specification             May 1996
-
-
-   [7] Schwaderer, W.D., "CRC Calculation", April 85 PC Tech Journal,
-       pp.118-133.
-
-   [8] ftp://ftp.adelaide.edu.au/pub/rocksoft/papers/crc_v3.txt,
-       describing the CRC concept.
-
-4. Security Considerations
-
-   Any data compression method involves the reduction of redundancy in
-   the data.  Consequently, any corruption of the data is likely to have
-   severe effects and be difficult to correct.  Uncompressed text, on
-   the other hand, will probably still be readable despite the presence
-   of some corrupted bytes.
-
-   It is recommended that systems using this data format provide some
-   means of validating the integrity of the compressed data, such as by
-   setting and checking the CRC-32 check value.
-
-5. Acknowledgements
-
-   Trademarks cited in this document are the property of their
-   respective owners.
-
-   Jean-Loup Gailly designed the gzip format and wrote, with Mark Adler,
-   the related software described in this specification.  Glenn
-   Randers-Pehrson converted this document to RFC and HTML format.
-
-6. Author's Address
-
-   L. Peter Deutsch
-   Aladdin Enterprises
-   203 Santa Margarita Ave.
-   Menlo Park, CA 94025
-
-   Phone: (415) 322-0103 (AM only)
-   FAX:   (415) 322-1734
-   EMail: <ghost@aladdin.com>
-
-   Questions about the technical content of this specification can be
-   sent by email to:
-
-   Jean-Loup Gailly <gzip@prep.ai.mit.edu> and
-   Mark Adler <madler@alumni.caltech.edu>
-
-   Editorial comments on this specification can be sent by email to:
-
-   L. Peter Deutsch <ghost@aladdin.com> and
-   Glenn Randers-Pehrson <randeg@alumni.rpi.edu>
-
-
-
-Deutsch                      Informational                     [Page 10]
-
-RFC 1952             GZIP File Format Specification             May 1996
-
-
-7. Appendix: Jean-Loup Gailly's gzip utility
-
-   The most widely used implementation of gzip compression, and the
-   original documentation on which this specification is based, were
-   created by Jean-Loup Gailly <gzip@prep.ai.mit.edu>.  Since this
-   implementation is a de facto standard, we mention some more of its
-   features here.  Again, the material in this section is not part of
-   the specification per se, and implementations need not follow it to
-   be compliant.
-
-   When compressing or decompressing a file, gzip preserves the
-   protection, ownership, and modification time attributes on the local
-   file system, since there is no provision for representing protection
-   attributes in the gzip file format itself.  Since the file format
-   includes a modification time, the gzip decompressor provides a
-   command line switch that assigns the modification time from the file,
-   rather than the local modification time of the compressed input, to
-   the decompressed output.
-
-8. Appendix: Sample CRC Code
-
-   The following sample code represents a practical implementation of
-   the CRC (Cyclic Redundancy Check). (See also ISO 3309 and ITU-T V.42
-   for a formal specification.)
-
-   The sample code is in the ANSI C programming language. Non C users
-   may find it easier to read with these hints:
-
-      &      Bitwise AND operator.
-      ^      Bitwise exclusive-OR operator.
-      >>     Bitwise right shift operator. When applied to an
-             unsigned quantity, as here, right shift inserts zero
-             bit(s) at the left.
-      !      Logical NOT operator.
-      ++     "n++" increments the variable n.
-      0xNNN  0x introduces a hexadecimal (base 16) constant.
-             Suffix L indicates a long value (at least 32 bits).
-
-      /* Table of CRCs of all 8-bit messages. */
-      unsigned long crc_table[256];
-
-      /* Flag: has the table been computed? Initially false. */
-      int crc_table_computed = 0;
-
-      /* Make the table for a fast CRC. */
-      void make_crc_table(void)
-      {
-        unsigned long c;
-
-
-
-Deutsch                      Informational                     [Page 11]
-
-RFC 1952             GZIP File Format Specification             May 1996
-
-
-        int n, k;
-        for (n = 0; n < 256; n++) {
-          c = (unsigned long) n;
-          for (k = 0; k < 8; k++) {
-            if (c & 1) {
-              c = 0xedb88320L ^ (c >> 1);
-            } else {
-              c = c >> 1;
-            }
-          }
-          crc_table[n] = c;
-        }
-        crc_table_computed = 1;
-      }
-
-      /*
-         Update a running crc with the bytes buf[0..len-1] and return
-       the updated crc. The crc should be initialized to zero. Pre- and
-       post-conditioning (one's complement) is performed within this
-       function so it shouldn't be done by the caller. Usage example:
-
-         unsigned long crc = 0L;
-
-         while (read_buffer(buffer, length) != EOF) {
-           crc = update_crc(crc, buffer, length);
-         }
-         if (crc != original_crc) error();
-      */
-      unsigned long update_crc(unsigned long crc,
-                      unsigned char *buf, int len)
-      {
-        unsigned long c = crc ^ 0xffffffffL;
-        int n;
-
-        if (!crc_table_computed)
-          make_crc_table();
-        for (n = 0; n < len; n++) {
-          c = crc_table[(c ^ buf[n]) & 0xff] ^ (c >> 8);
-        }
-        return c ^ 0xffffffffL;
-      }
-
-      /* Return the CRC of the bytes buf[0..len-1]. */
-      unsigned long crc(unsigned char *buf, int len)
-      {
-        return update_crc(0L, buf, len);
-      }
-
-
-
-
-Deutsch                      Informational                     [Page 12]
-
diff -Nbaur gcc-4.8.1/zlib/doc/txtvsbin.txt gcc-4.8.1-ppc/zlib/doc/txtvsbin.txt
--- gcc-4.8.1/zlib/doc/txtvsbin.txt	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/doc/txtvsbin.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,107 +0,0 @@
-A Fast Method for Identifying Plain Text Files
-==============================================
-
-
-Introduction
-------------
-
-Given a file coming from an unknown source, it is sometimes desirable
-to find out whether the format of that file is plain text.  Although
-this may appear like a simple task, a fully accurate detection of the
-file type requires heavy-duty semantic analysis on the file contents.
-It is, however, possible to obtain satisfactory results by employing
-various heuristics.
-
-Previous versions of PKZip and other zip-compatible compression tools
-were using a crude detection scheme: if more than 80% (4/5) of the bytes
-found in a certain buffer are within the range [7..127], the file is
-labeled as plain text, otherwise it is labeled as binary.  A prominent
-limitation of this scheme is the restriction to Latin-based alphabets.
-Other alphabets, like Greek, Cyrillic or Asian, make extensive use of
-the bytes within the range [128..255], and texts using these alphabets
-are most often misidentified by this scheme; in other words, the rate
-of false negatives is sometimes too high, which means that the recall
-is low.  Another weakness of this scheme is a reduced precision, due to
-the false positives that may occur when binary files containing large
-amounts of textual characters are misidentified as plain text.
-
-In this article we propose a new, simple detection scheme that features
-a much increased precision and a near-100% recall.  This scheme is
-designed to work on ASCII, Unicode and other ASCII-derived alphabets,
-and it handles single-byte encodings (ISO-8859, MacRoman, KOI8, etc.)
-and variable-sized encodings (ISO-2022, UTF-8, etc.).  Wider encodings
-(UCS-2/UTF-16 and UCS-4/UTF-32) are not handled, however.
-
-
-The Algorithm
--------------
-
-The algorithm works by dividing the set of bytecodes [0..255] into three
-categories:
-- The white list of textual bytecodes:
-  9 (TAB), 10 (LF), 13 (CR), 32 (SPACE) to 255.
-- The gray list of tolerated bytecodes:
-  7 (BEL), 8 (BS), 11 (VT), 12 (FF), 26 (SUB), 27 (ESC).
-- The black list of undesired, non-textual bytecodes:
-  0 (NUL) to 6, 14 to 31.
-
-If a file contains at least one byte that belongs to the white list and
-no byte that belongs to the black list, then the file is categorized as
-plain text; otherwise, it is categorized as binary.  (The boundary case,
-when the file is empty, automatically falls into the latter category.)
-
-
-Rationale
----------
-
-The idea behind this algorithm relies on two observations.
-
-The first observation is that, although the full range of 7-bit codes
-[0..127] is properly specified by the ASCII standard, most control
-characters in the range [0..31] are not used in practice.  The only
-widely-used, almost universally-portable control codes are 9 (TAB),
-10 (LF) and 13 (CR).  There are a few more control codes that are
-recognized on a reduced range of platforms and text viewers/editors:
-7 (BEL), 8 (BS), 11 (VT), 12 (FF), 26 (SUB) and 27 (ESC); but these
-codes are rarely (if ever) used alone, without being accompanied by
-some printable text.  Even the newer, portable text formats such as
-XML avoid using control characters outside the list mentioned here.
-
-The second observation is that most of the binary files tend to contain
-control characters, especially 0 (NUL).  Even though the older text
-detection schemes observe the presence of non-ASCII codes from the range
-[128..255], the precision rarely has to suffer if this upper range is
-labeled as textual, because the files that are genuinely binary tend to
-contain both control characters and codes from the upper range.  On the
-other hand, the upper range needs to be labeled as textual, because it
-is used by virtually all ASCII extensions.  In particular, this range is
-used for encoding non-Latin scripts.
-
-Since there is no counting involved, other than simply observing the
-presence or the absence of some byte values, the algorithm produces
-consistent results, regardless what alphabet encoding is being used.
-(If counting were involved, it could be possible to obtain different
-results on a text encoded, say, using ISO-8859-16 versus UTF-8.)
-
-There is an extra category of plain text files that are "polluted" with
-one or more black-listed codes, either by mistake or by peculiar design
-considerations.  In such cases, a scheme that tolerates a small fraction
-of black-listed codes would provide an increased recall (i.e. more true
-positives).  This, however, incurs a reduced precision overall, since
-false positives are more likely to appear in binary files that contain
-large chunks of textual data.  Furthermore, "polluted" plain text should
-be regarded as binary by general-purpose text detection schemes, because
-general-purpose text processing algorithms might not be applicable.
-Under this premise, it is safe to say that our detection method provides
-a near-100% recall.
-
-Experiments have been run on many files coming from various platforms
-and applications.  We tried plain text files, system logs, source code,
-formatted office documents, compiled object code, etc.  The results
-confirm the optimistic assumptions about the capabilities of this
-algorithm.
-
-
---
-Cosmin Truta
-Last updated: 2006-May-28
diff -Nbaur gcc-4.8.1/zlib/example.c gcc-4.8.1-ppc/zlib/example.c
--- gcc-4.8.1/zlib/example.c	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/example.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,565 +0,0 @@
-/* example.c -- usage example of the zlib compression library
- * Copyright (C) 1995-2006 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id: example.c,v 1.1.1.2 2002/03/11 21:53:23 tromey Exp $ */
-
-#include "zlib.h"
-#include <stdio.h>
-
-#ifdef STDC
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-
-#if defined(VMS) || defined(RISCOS)
-#  define TESTFILE "foo-gz"
-#else
-#  define TESTFILE "foo.gz"
-#endif
-
-#define CHECK_ERR(err, msg) { \
-    if (err != Z_OK) { \
-        fprintf(stderr, "%s error: %d\n", msg, err); \
-        exit(1); \
-    } \
-}
-
-const char hello[] = "hello, hello!";
-/* "hello world" would be more standard, but the repeated "hello"
- * stresses the compression code better, sorry...
- */
-
-const char dictionary[] = "hello";
-uLong dictId; /* Adler32 value of the dictionary */
-
-void test_compress      OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_gzio          OF((const char *fname,
-                            Byte *uncompr, uLong uncomprLen));
-void test_deflate       OF((Byte *compr, uLong comprLen));
-void test_inflate       OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_large_deflate OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_large_inflate OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_flush         OF((Byte *compr, uLong *comprLen));
-void test_sync          OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_dict_deflate  OF((Byte *compr, uLong comprLen));
-void test_dict_inflate  OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-int  main               OF((int argc, char *argv[]));
-
-/* ===========================================================================
- * Test compress() and uncompress()
- */
-void test_compress(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    uLong len = (uLong)strlen(hello)+1;
-
-    err = compress(compr, &comprLen, (const Bytef*)hello, len);
-    CHECK_ERR(err, "compress");
-
-    strcpy((char*)uncompr, "garbage");
-
-    err = uncompress(uncompr, &uncomprLen, compr, comprLen);
-    CHECK_ERR(err, "uncompress");
-
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad uncompress\n");
-        exit(1);
-    } else {
-        printf("uncompress(): %s\n", (char *)uncompr);
-    }
-}
-
-/* ===========================================================================
- * Test read/write of .gz files
- */
-void test_gzio(fname, uncompr, uncomprLen)
-    const char *fname; /* compressed file name */
-    Byte *uncompr;
-    uLong uncomprLen;
-{
-#ifdef NO_GZCOMPRESS
-    fprintf(stderr, "NO_GZCOMPRESS -- gz* functions cannot compress\n");
-#else
-    int err;
-    int len = (int)strlen(hello)+1;
-    gzFile file;
-    z_off_t pos;
-
-    file = gzopen(fname, "wb");
-    if (file == NULL) {
-        fprintf(stderr, "gzopen error\n");
-        exit(1);
-    }
-    gzputc(file, 'h');
-    if (gzputs(file, "ello") != 4) {
-        fprintf(stderr, "gzputs err: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    if (gzprintf(file, ", %s!", "hello") != 8) {
-        fprintf(stderr, "gzprintf err: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    gzseek(file, 1L, SEEK_CUR); /* add one zero byte */
-    gzclose(file);
-
-    file = gzopen(fname, "rb");
-    if (file == NULL) {
-        fprintf(stderr, "gzopen error\n");
-        exit(1);
-    }
-    strcpy((char*)uncompr, "garbage");
-
-    if (gzread(file, uncompr, (unsigned)uncomprLen) != len) {
-        fprintf(stderr, "gzread err: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad gzread: %s\n", (char*)uncompr);
-        exit(1);
-    } else {
-        printf("gzread(): %s\n", (char*)uncompr);
-    }
-
-    pos = gzseek(file, -8L, SEEK_CUR);
-    if (pos != 6 || gztell(file) != pos) {
-        fprintf(stderr, "gzseek error, pos=%ld, gztell=%ld\n",
-                (long)pos, (long)gztell(file));
-        exit(1);
-    }
-
-    if (gzgetc(file) != ' ') {
-        fprintf(stderr, "gzgetc error\n");
-        exit(1);
-    }
-
-    if (gzungetc(' ', file) != ' ') {
-        fprintf(stderr, "gzungetc error\n");
-        exit(1);
-    }
-
-    gzgets(file, (char*)uncompr, (int)uncomprLen);
-    if (strlen((char*)uncompr) != 7) { /* " hello!" */
-        fprintf(stderr, "gzgets err after gzseek: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    if (strcmp((char*)uncompr, hello + 6)) {
-        fprintf(stderr, "bad gzgets after gzseek\n");
-        exit(1);
-    } else {
-        printf("gzgets() after gzseek: %s\n", (char*)uncompr);
-    }
-
-    gzclose(file);
-#endif
-}
-
-/* ===========================================================================
- * Test deflate() with small buffers
- */
-void test_deflate(compr, comprLen)
-    Byte *compr;
-    uLong comprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-    uLong len = (uLong)strlen(hello)+1;
-
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);
-    CHECK_ERR(err, "deflateInit");
-
-    c_stream.next_in  = (Bytef*)hello;
-    c_stream.next_out = compr;
-
-    while (c_stream.total_in != len && c_stream.total_out < comprLen) {
-        c_stream.avail_in = c_stream.avail_out = 1; /* force small buffers */
-        err = deflate(&c_stream, Z_NO_FLUSH);
-        CHECK_ERR(err, "deflate");
-    }
-    /* Finish the stream, still forcing small buffers: */
-    for (;;) {
-        c_stream.avail_out = 1;
-        err = deflate(&c_stream, Z_FINISH);
-        if (err == Z_STREAM_END) break;
-        CHECK_ERR(err, "deflate");
-    }
-
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-}
-
-/* ===========================================================================
- * Test inflate() with small buffers
- */
-void test_inflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = 0;
-    d_stream.next_out = uncompr;
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    while (d_stream.total_out < uncomprLen && d_stream.total_in < comprLen) {
-        d_stream.avail_in = d_stream.avail_out = 1; /* force small buffers */
-        err = inflate(&d_stream, Z_NO_FLUSH);
-        if (err == Z_STREAM_END) break;
-        CHECK_ERR(err, "inflate");
-    }
-
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad inflate\n");
-        exit(1);
-    } else {
-        printf("inflate(): %s\n", (char *)uncompr);
-    }
-}
-
-/* ===========================================================================
- * Test deflate() with large buffers and dynamic change of compression level
- */
-void test_large_deflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_BEST_SPEED);
-    CHECK_ERR(err, "deflateInit");
-
-    c_stream.next_out = compr;
-    c_stream.avail_out = (uInt)comprLen;
-
-    /* At this point, uncompr is still mostly zeroes, so it should compress
-     * very well:
-     */
-    c_stream.next_in = uncompr;
-    c_stream.avail_in = (uInt)uncomprLen;
-    err = deflate(&c_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "deflate");
-    if (c_stream.avail_in != 0) {
-        fprintf(stderr, "deflate not greedy\n");
-        exit(1);
-    }
-
-    /* Feed in already compressed data and switch to no compression: */
-    deflateParams(&c_stream, Z_NO_COMPRESSION, Z_DEFAULT_STRATEGY);
-    c_stream.next_in = compr;
-    c_stream.avail_in = (uInt)comprLen/2;
-    err = deflate(&c_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "deflate");
-
-    /* Switch back to compressing mode: */
-    deflateParams(&c_stream, Z_BEST_COMPRESSION, Z_FILTERED);
-    c_stream.next_in = uncompr;
-    c_stream.avail_in = (uInt)uncomprLen;
-    err = deflate(&c_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "deflate");
-
-    err = deflate(&c_stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        fprintf(stderr, "deflate should report Z_STREAM_END\n");
-        exit(1);
-    }
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-}
-
-/* ===========================================================================
- * Test inflate() with large buffers
- */
-void test_large_inflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = (uInt)comprLen;
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    for (;;) {
-        d_stream.next_out = uncompr;            /* discard the output */
-        d_stream.avail_out = (uInt)uncomprLen;
-        err = inflate(&d_stream, Z_NO_FLUSH);
-        if (err == Z_STREAM_END) break;
-        CHECK_ERR(err, "large inflate");
-    }
-
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    if (d_stream.total_out != 2*uncomprLen + comprLen/2) {
-        fprintf(stderr, "bad large inflate: %ld\n", d_stream.total_out);
-        exit(1);
-    } else {
-        printf("large_inflate(): OK\n");
-    }
-}
-
-/* ===========================================================================
- * Test deflate() with full flush
- */
-void test_flush(compr, comprLen)
-    Byte *compr;
-    uLong *comprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-    uInt len = (uInt)strlen(hello)+1;
-
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);
-    CHECK_ERR(err, "deflateInit");
-
-    c_stream.next_in  = (Bytef*)hello;
-    c_stream.next_out = compr;
-    c_stream.avail_in = 3;
-    c_stream.avail_out = (uInt)*comprLen;
-    err = deflate(&c_stream, Z_FULL_FLUSH);
-    CHECK_ERR(err, "deflate");
-
-    compr[3]++; /* force an error in first compressed block */
-    c_stream.avail_in = len - 3;
-
-    err = deflate(&c_stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        CHECK_ERR(err, "deflate");
-    }
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-
-    *comprLen = c_stream.total_out;
-}
-
-/* ===========================================================================
- * Test inflateSync()
- */
-void test_sync(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = 2; /* just read the zlib header */
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    d_stream.next_out = uncompr;
-    d_stream.avail_out = (uInt)uncomprLen;
-
-    inflate(&d_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "inflate");
-
-    d_stream.avail_in = (uInt)comprLen-2;   /* read all compressed data */
-    err = inflateSync(&d_stream);           /* but skip the damaged part */
-    CHECK_ERR(err, "inflateSync");
-
-    err = inflate(&d_stream, Z_FINISH);
-    if (err != Z_DATA_ERROR) {
-        fprintf(stderr, "inflate should report DATA_ERROR\n");
-        /* Because of incorrect adler32 */
-        exit(1);
-    }
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    printf("after inflateSync(): hel%s\n", (char *)uncompr);
-}
-
-/* ===========================================================================
- * Test deflate() with preset dictionary
- */
-void test_dict_deflate(compr, comprLen)
-    Byte *compr;
-    uLong comprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_BEST_COMPRESSION);
-    CHECK_ERR(err, "deflateInit");
-
-    err = deflateSetDictionary(&c_stream,
-                               (const Bytef*)dictionary, sizeof(dictionary));
-    CHECK_ERR(err, "deflateSetDictionary");
-
-    dictId = c_stream.adler;
-    c_stream.next_out = compr;
-    c_stream.avail_out = (uInt)comprLen;
-
-    c_stream.next_in = (Bytef*)hello;
-    c_stream.avail_in = (uInt)strlen(hello)+1;
-
-    err = deflate(&c_stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        fprintf(stderr, "deflate should report Z_STREAM_END\n");
-        exit(1);
-    }
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-}
-
-/* ===========================================================================
- * Test inflate() with a preset dictionary
- */
-void test_dict_inflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = (uInt)comprLen;
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    d_stream.next_out = uncompr;
-    d_stream.avail_out = (uInt)uncomprLen;
-
-    for (;;) {
-        err = inflate(&d_stream, Z_NO_FLUSH);
-        if (err == Z_STREAM_END) break;
-        if (err == Z_NEED_DICT) {
-            if (d_stream.adler != dictId) {
-                fprintf(stderr, "unexpected dictionary");
-                exit(1);
-            }
-            err = inflateSetDictionary(&d_stream, (const Bytef*)dictionary,
-                                       sizeof(dictionary));
-        }
-        CHECK_ERR(err, "inflate with dict");
-    }
-
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad inflate with dict\n");
-        exit(1);
-    } else {
-        printf("inflate with dictionary: %s\n", (char *)uncompr);
-    }
-}
-
-/* ===========================================================================
- * Usage:  example [output.gz  [input.gz]]
- */
-
-int main(argc, argv)
-    int argc;
-    char *argv[];
-{
-    Byte *compr, *uncompr;
-    uLong comprLen = 10000*sizeof(int); /* don't overflow on MSDOS */
-    uLong uncomprLen = comprLen;
-    static const char* myVersion = ZLIB_VERSION;
-
-    if (zlibVersion()[0] != myVersion[0]) {
-        fprintf(stderr, "incompatible zlib version\n");
-        exit(1);
-
-    } else if (strcmp(zlibVersion(), ZLIB_VERSION) != 0) {
-        fprintf(stderr, "warning: different zlib version\n");
-    }
-
-    printf("zlib version %s = 0x%04x, compile flags = 0x%lx\n",
-            ZLIB_VERSION, ZLIB_VERNUM, zlibCompileFlags());
-
-    compr    = (Byte*)calloc((uInt)comprLen, 1);
-    uncompr  = (Byte*)calloc((uInt)uncomprLen, 1);
-    /* compr and uncompr are cleared to avoid reading uninitialized
-     * data and to ensure that uncompr compresses well.
-     */
-    if (compr == Z_NULL || uncompr == Z_NULL) {
-        printf("out of memory\n");
-        exit(1);
-    }
-    test_compress(compr, comprLen, uncompr, uncomprLen);
-
-    test_gzio((argc > 1 ? argv[1] : TESTFILE),
-              uncompr, uncomprLen);
-
-    test_deflate(compr, comprLen);
-    test_inflate(compr, comprLen, uncompr, uncomprLen);
-
-    test_large_deflate(compr, comprLen, uncompr, uncomprLen);
-    test_large_inflate(compr, comprLen, uncompr, uncomprLen);
-
-    test_flush(compr, &comprLen);
-    test_sync(compr, comprLen, uncompr, uncomprLen);
-    comprLen = uncomprLen;
-
-    test_dict_deflate(compr, comprLen);
-    test_dict_inflate(compr, comprLen, uncompr, uncomprLen);
-
-    free(compr);
-    free(uncompr);
-
-    return 0;
-}
diff -Nbaur gcc-4.8.1/zlib/examples/enough.c gcc-4.8.1-ppc/zlib/examples/enough.c
--- gcc-4.8.1/zlib/examples/enough.c	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/examples/enough.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,569 +0,0 @@
-/* enough.c -- determine the maximum size of inflate's Huffman code tables over
- * all possible valid and complete Huffman codes, subject to a length limit.
- * Copyright (C) 2007, 2008 Mark Adler
- * Version 1.3  17 February 2008  Mark Adler
- */
-
-/* Version history:
-   1.0   3 Jan 2007  First version (derived from codecount.c version 1.4)
-   1.1   4 Jan 2007  Use faster incremental table usage computation
-                     Prune examine() search on previously visited states
-   1.2   5 Jan 2007  Comments clean up
-                     As inflate does, decrease root for short codes
-                     Refuse cases where inflate would increase root
-   1.3  17 Feb 2008  Add argument for initial root table size
-                     Fix bug for initial root table size == max - 1
-                     Use a macro to compute the history index
- */
-
-/*
-   Examine all possible Huffman codes for a given number of symbols and a
-   maximum code length in bits to determine the maximum table size for zilb's
-   inflate.  Only complete Huffman codes are counted.
-
-   Two codes are considered distinct if the vectors of the number of codes per
-   length are not identical.  So permutations of the symbol assignments result
-   in the same code for the counting, as do permutations of the assignments of
-   the bit values to the codes (i.e. only canonical codes are counted).
-
-   We build a code from shorter to longer lengths, determining how many symbols
-   are coded at each length.  At each step, we have how many symbols remain to
-   be coded, what the last code length used was, and how many bit patterns of
-   that length remain unused. Then we add one to the code length and double the
-   number of unused patterns to graduate to the next code length.  We then
-   assign all portions of the remaining symbols to that code length that
-   preserve the properties of a correct and eventually complete code.  Those
-   properties are: we cannot use more bit patterns than are available; and when
-   all the symbols are used, there are exactly zero possible bit patterns
-   remaining.
-
-   The inflate Huffman decoding algorithm uses two-level lookup tables for
-   speed.  There is a single first-level table to decode codes up to root bits
-   in length (root == 9 in the current inflate implementation).  The table
-   has 1 << root entries and is indexed by the next root bits of input.  Codes
-   shorter than root bits have replicated table entries, so that the correct
-   entry is pointed to regardless of the bits that follow the short code.  If
-   the code is longer than root bits, then the table entry points to a second-
-   level table.  The size of that table is determined by the longest code with
-   that root-bit prefix.  If that longest code has length len, then the table
-   has size 1 << (len - root), to index the remaining bits in that set of
-   codes.  Each subsequent root-bit prefix then has its own sub-table.  The
-   total number of table entries required by the code is calculated
-   incrementally as the number of codes at each bit length is populated.  When
-   all of the codes are shorter than root bits, then root is reduced to the
-   longest code length, resulting in a single, smaller, one-level table.
-
-   The inflate algorithm also provides for small values of root (relative to
-   the log2 of the number of symbols), where the shortest code has more bits
-   than root.  In that case, root is increased to the length of the shortest
-   code.  This program, by design, does not handle that case, so it is verified
-   that the number of symbols is less than 2^(root + 1).
-
-   In order to speed up the examination (by about ten orders of magnitude for
-   the default arguments), the intermediate states in the build-up of a code
-   are remembered and previously visited branches are pruned.  The memory
-   required for this will increase rapidly with the total number of symbols and
-   the maximum code length in bits.  However this is a very small price to pay
-   for the vast speedup.
-
-   First, all of the possible Huffman codes are counted, and reachable
-   intermediate states are noted by a non-zero count in a saved-results array.
-   Second, the intermediate states that lead to (root + 1) bit or longer codes
-   are used to look at all sub-codes from those junctures for their inflate
-   memory usage.  (The amount of memory used is not affected by the number of
-   codes of root bits or less in length.)  Third, the visited states in the
-   construction of those sub-codes and the associated calculation of the table
-   size is recalled in order to avoid recalculating from the same juncture.
-   Beginning the code examination at (root + 1) bit codes, which is enabled by
-   identifying the reachable nodes, accounts for about six of the orders of
-   magnitude of improvement for the default arguments.  About another four
-   orders of magnitude come from not revisiting previous states.  Out of
-   approximately 2x10^16 possible Huffman codes, only about 2x10^6 sub-codes
-   need to be examined to cover all of the possible table memory usage cases
-   for the default arguments of 286 symbols limited to 15-bit codes.
-
-   Note that an unsigned long long type is used for counting.  It is quite easy
-   to exceed the capacity of an eight-byte integer with a large number of
-   symbols and a large maximum code length, so multiple-precision arithmetic
-   would need to replace the unsigned long long arithmetic in that case.  This
-   program will abort if an overflow occurs.  The big_t type identifies where
-   the counting takes place.
-
-   An unsigned long long type is also used for calculating the number of
-   possible codes remaining at the maximum length.  This limits the maximum
-   code length to the number of bits in a long long minus the number of bits
-   needed to represent the symbols in a flat code.  The code_t type identifies
-   where the bit pattern counting takes place.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <assert.h>
-
-#define local static
-
-/* special data types */
-typedef unsigned long long big_t;   /* type for code counting */
-typedef unsigned long long code_t;  /* type for bit pattern counting */
-struct tab {                        /* type for been here check */
-    size_t len;         /* length of bit vector in char's */
-    char *vec;          /* allocated bit vector */
-};
-
-/* The array for saving results, num[], is indexed with this triplet:
-
-      syms: number of symbols remaining to code
-      left: number of available bit patterns at length len
-      len: number of bits in the codes currently being assigned
-
-   Those indices are constrained thusly when saving results:
-
-      syms: 3..totsym (totsym == total symbols to code)
-      left: 2..syms - 1, but only the evens (so syms == 8 -> 2, 4, 6)
-      len: 1..max - 1 (max == maximum code length in bits)
-
-   syms == 2 is not saved since that immediately leads to a single code.  left
-   must be even, since it represents the number of available bit patterns at
-   the current length, which is double the number at the previous length.
-   left ends at syms-1 since left == syms immediately results in a single code.
-   (left > sym is not allowed since that would result in an incomplete code.)
-   len is less than max, since the code completes immediately when len == max.
-
-   The offset into the array is calculated for the three indices with the
-   first one (syms) being outermost, and the last one (len) being innermost.
-   We build the array with length max-1 lists for the len index, with syms-3
-   of those for each symbol.  There are totsym-2 of those, with each one
-   varying in length as a function of sym.  See the calculation of index in
-   count() for the index, and the calculation of size in main() for the size
-   of the array.
-
-   For the deflate example of 286 symbols limited to 15-bit codes, the array
-   has 284,284 entries, taking up 2.17 MB for an 8-byte big_t.  More than
-   half of the space allocated for saved results is actually used -- not all
-   possible triplets are reached in the generation of valid Huffman codes.
- */
-
-/* The array for tracking visited states, done[], is itself indexed identically
-   to the num[] array as described above for the (syms, left, len) triplet.
-   Each element in the array is further indexed by the (mem, rem) doublet,
-   where mem is the amount of inflate table space used so far, and rem is the
-   remaining unused entries in the current inflate sub-table.  Each indexed
-   element is simply one bit indicating whether the state has been visited or
-   not.  Since the ranges for mem and rem are not known a priori, each bit
-   vector is of a variable size, and grows as needed to accommodate the visited
-   states.  mem and rem are used to calculate a single index in a triangular
-   array.  Since the range of mem is expected in the default case to be about
-   ten times larger than the range of rem, the array is skewed to reduce the
-   memory usage, with eight times the range for mem than for rem.  See the
-   calculations for offset and bit in beenhere() for the details.
-
-   For the deflate example of 286 symbols limited to 15-bit codes, the bit
-   vectors grow to total approximately 21 MB, in addition to the 4.3 MB done[]
-   array itself.
- */
-
-/* Globals to avoid propagating constants or constant pointers recursively */
-local int max;          /* maximum allowed bit length for the codes */
-local int root;         /* size of base code table in bits */
-local int large;        /* largest code table so far */
-local size_t size;      /* number of elements in num and done */
-local int *code;        /* number of symbols assigned to each bit length */
-local big_t *num;       /* saved results array for code counting */
-local struct tab *done; /* states already evaluated array */
-
-/* Index function for num[] and done[] */
-#define INDEX(i,j,k) (((size_t)((i-1)>>1)*((i-2)>>1)+(j>>1)-1)*(max-1)+k-1)
-
-/* Free allocated space.  Uses globals code, num, and done. */
-local void cleanup(void)
-{
-    size_t n;
-
-    if (done != NULL) {
-        for (n = 0; n < size; n++)
-            if (done[n].len)
-                free(done[n].vec);
-        free(done);
-    }
-    if (num != NULL)
-        free(num);
-    if (code != NULL)
-        free(code);
-}
-
-/* Return the number of possible Huffman codes using bit patterns of lengths
-   len through max inclusive, coding syms symbols, with left bit patterns of
-   length len unused -- return -1 if there is an overflow in the counting.
-   Keep a record of previous results in num to prevent repeating the same
-   calculation.  Uses the globals max and num. */
-local big_t count(int syms, int len, int left)
-{
-    big_t sum;          /* number of possible codes from this juncture */
-    big_t got;          /* value returned from count() */
-    int least;          /* least number of syms to use at this juncture */
-    int most;           /* most number of syms to use at this juncture */
-    int use;            /* number of bit patterns to use in next call */
-    size_t index;       /* index of this case in *num */
-
-    /* see if only one possible code */
-    if (syms == left)
-        return 1;
-
-    /* note and verify the expected state */
-    assert(syms > left && left > 0 && len < max);
-
-    /* see if we've done this one already */
-    index = INDEX(syms, left, len);
-    got = num[index];
-    if (got)
-        return got;         /* we have -- return the saved result */
-
-    /* we need to use at least this many bit patterns so that the code won't be
-       incomplete at the next length (more bit patterns than symbols) */
-    least = (left << 1) - syms;
-    if (least < 0)
-        least = 0;
-
-    /* we can use at most this many bit patterns, lest there not be enough
-       available for the remaining symbols at the maximum length (if there were
-       no limit to the code length, this would become: most = left - 1) */
-    most = (((code_t)left << (max - len)) - syms) /
-            (((code_t)1 << (max - len)) - 1);
-
-    /* count all possible codes from this juncture and add them up */
-    sum = 0;
-    for (use = least; use <= most; use++) {
-        got = count(syms - use, len + 1, (left - use) << 1);
-        sum += got;
-        if (got == -1 || sum < got)         /* overflow */
-            return -1;
-    }
-
-    /* verify that all recursive calls are productive */
-    assert(sum != 0);
-
-    /* save the result and return it */
-    num[index] = sum;
-    return sum;
-}
-
-/* Return true if we've been here before, set to true if not.  Set a bit in a
-   bit vector to indicate visiting this state.  Each (syms,len,left) state
-   has a variable size bit vector indexed by (mem,rem).  The bit vector is
-   lengthened if needed to allow setting the (mem,rem) bit. */
-local int beenhere(int syms, int len, int left, int mem, int rem)
-{
-    size_t index;       /* index for this state's bit vector */
-    size_t offset;      /* offset in this state's bit vector */
-    int bit;            /* mask for this state's bit */
-    size_t length;      /* length of the bit vector in bytes */
-    char *vector;       /* new or enlarged bit vector */
-
-    /* point to vector for (syms,left,len), bit in vector for (mem,rem) */
-    index = INDEX(syms, left, len);
-    mem -= 1 << root;
-    offset = (mem >> 3) + rem;
-    offset = ((offset * (offset + 1)) >> 1) + rem;
-    bit = 1 << (mem & 7);
-
-    /* see if we've been here */
-    length = done[index].len;
-    if (offset < length && (done[index].vec[offset] & bit) != 0)
-        return 1;       /* done this! */
-
-    /* we haven't been here before -- set the bit to show we have now */
-
-    /* see if we need to lengthen the vector in order to set the bit */
-    if (length <= offset) {
-        /* if we have one already, enlarge it, zero out the appended space */
-        if (length) {
-            do {
-                length <<= 1;
-            } while (length <= offset);
-            vector = realloc(done[index].vec, length);
-            if (vector != NULL)
-                memset(vector + done[index].len, 0, length - done[index].len);
-        }
-
-        /* otherwise we need to make a new vector and zero it out */
-        else {
-            length = 1 << (len - root);
-            while (length <= offset)
-                length <<= 1;
-            vector = calloc(length, sizeof(char));
-        }
-
-        /* in either case, bail if we can't get the memory */
-        if (vector == NULL) {
-            fputs("abort: unable to allocate enough memory\n", stderr);
-            cleanup();
-            exit(1);
-        }
-
-        /* install the new vector */
-        done[index].len = length;
-        done[index].vec = vector;
-    }
-
-    /* set the bit */
-    done[index].vec[offset] |= bit;
-    return 0;
-}
-
-/* Examine all possible codes from the given node (syms, len, left).  Compute
-   the amount of memory required to build inflate's decoding tables, where the
-   number of code structures used so far is mem, and the number remaining in
-   the current sub-table is rem.  Uses the globals max, code, root, large, and
-   done. */
-local void examine(int syms, int len, int left, int mem, int rem)
-{
-    int least;          /* least number of syms to use at this juncture */
-    int most;           /* most number of syms to use at this juncture */
-    int use;            /* number of bit patterns to use in next call */
-
-    /* see if we have a complete code */
-    if (syms == left) {
-        /* set the last code entry */
-        code[len] = left;
-
-        /* complete computation of memory used by this code */
-        while (rem < left) {
-            left -= rem;
-            rem = 1 << (len - root);
-            mem += rem;
-        }
-        assert(rem == left);
-
-        /* if this is a new maximum, show the entries used and the sub-code */
-        if (mem > large) {
-            large = mem;
-            printf("max %d: ", mem);
-            for (use = root + 1; use <= max; use++)
-                if (code[use])
-                    printf("%d[%d] ", code[use], use);
-            putchar('\n');
-            fflush(stdout);
-        }
-
-        /* remove entries as we drop back down in the recursion */
-        code[len] = 0;
-        return;
-    }
-
-    /* prune the tree if we can */
-    if (beenhere(syms, len, left, mem, rem))
-        return;
-
-    /* we need to use at least this many bit patterns so that the code won't be
-       incomplete at the next length (more bit patterns than symbols) */
-    least = (left << 1) - syms;
-    if (least < 0)
-        least = 0;
-
-    /* we can use at most this many bit patterns, lest there not be enough
-       available for the remaining symbols at the maximum length (if there were
-       no limit to the code length, this would become: most = left - 1) */
-    most = (((code_t)left << (max - len)) - syms) /
-            (((code_t)1 << (max - len)) - 1);
-
-    /* occupy least table spaces, creating new sub-tables as needed */
-    use = least;
-    while (rem < use) {
-        use -= rem;
-        rem = 1 << (len - root);
-        mem += rem;
-    }
-    rem -= use;
-
-    /* examine codes from here, updating table space as we go */
-    for (use = least; use <= most; use++) {
-        code[len] = use;
-        examine(syms - use, len + 1, (left - use) << 1,
-                mem + (rem ? 1 << (len - root) : 0), rem << 1);
-        if (rem == 0) {
-            rem = 1 << (len - root);
-            mem += rem;
-        }
-        rem--;
-    }
-
-    /* remove entries as we drop back down in the recursion */
-    code[len] = 0;
-}
-
-/* Look at all sub-codes starting with root + 1 bits.  Look at only the valid
-   intermediate code states (syms, left, len).  For each completed code,
-   calculate the amount of memory required by inflate to build the decoding
-   tables. Find the maximum amount of memory required and show the code that
-   requires that maximum.  Uses the globals max, root, and num. */
-local void enough(int syms)
-{
-    int n;              /* number of remaing symbols for this node */
-    int left;           /* number of unused bit patterns at this length */
-    size_t index;       /* index of this case in *num */
-
-    /* clear code */
-    for (n = 0; n <= max; n++)
-        code[n] = 0;
-
-    /* look at all (root + 1) bit and longer codes */
-    large = 1 << root;              /* base table */
-    if (root < max)                 /* otherwise, there's only a base table */
-        for (n = 3; n <= syms; n++)
-            for (left = 2; left < n; left += 2)
-            {
-                /* look at all reachable (root + 1) bit nodes, and the
-                   resulting codes (complete at root + 2 or more) */
-                index = INDEX(n, left, root + 1);
-                if (root + 1 < max && num[index])       /* reachable node */
-                    examine(n, root + 1, left, 1 << root, 0);
-
-                /* also look at root bit codes with completions at root + 1
-                   bits (not saved in num, since complete), just in case */
-                if (num[index - 1] && n <= left << 1)
-                    examine((n - left) << 1, root + 1, (n - left) << 1,
-                            1 << root, 0);
-            }
-
-    /* done */
-    printf("done: maximum of %d table entries\n", large);
-}
-
-/*
-   Examine and show the total number of possible Huffman codes for a given
-   maximum number of symbols, initial root table size, and maximum code length
-   in bits -- those are the command arguments in that order.  The default
-   values are 286, 9, and 15 respectively, for the deflate literal/length code.
-   The possible codes are counted for each number of coded symbols from two to
-   the maximum.  The counts for each of those and the total number of codes are
-   shown.  The maximum number of inflate table entires is then calculated
-   across all possible codes.  Each new maximum number of table entries and the
-   associated sub-code (starting at root + 1 == 10 bits) is shown.
-
-   To count and examine Huffman codes that are not length-limited, provide a
-   maximum length equal to the number of symbols minus one.
-
-   For the deflate literal/length code, use "enough".  For the deflate distance
-   code, use "enough 30 6".
-
-   This uses the %llu printf format to print big_t numbers, which assumes that
-   big_t is an unsigned long long.  If the big_t type is changed (for example
-   to a multiple precision type), the method of printing will also need to be
-   updated.
- */
-int main(int argc, char **argv)
-{
-    int syms;           /* total number of symbols to code */
-    int n;              /* number of symbols to code for this run */
-    big_t got;          /* return value of count() */
-    big_t sum;          /* accumulated number of codes over n */
-
-    /* set up globals for cleanup() */
-    code = NULL;
-    num = NULL;
-    done = NULL;
-
-    /* get arguments -- default to the deflate literal/length code */
-    syms = 286;
-        root = 9;
-    max = 15;
-    if (argc > 1) {
-        syms = atoi(argv[1]);
-        if (argc > 2) {
-            root = atoi(argv[2]);
-                        if (argc > 3)
-                                max = atoi(argv[3]);
-                }
-    }
-    if (argc > 4 || syms < 2 || root < 1 || max < 1) {
-        fputs("invalid arguments, need: [sym >= 2 [root >= 1 [max >= 1]]]\n",
-                          stderr);
-        return 1;
-    }
-
-    /* if not restricting the code length, the longest is syms - 1 */
-    if (max > syms - 1)
-        max = syms - 1;
-
-    /* determine the number of bits in a code_t */
-    n = 0;
-    while (((code_t)1 << n) != 0)
-        n++;
-
-    /* make sure that the calculation of most will not overflow */
-    if (max > n || syms - 2 >= (((code_t)0 - 1) >> (max - 1))) {
-        fputs("abort: code length too long for internal types\n", stderr);
-        return 1;
-    }
-
-    /* reject impossible code requests */
-    if (syms - 1 > ((code_t)1 << max) - 1) {
-        fprintf(stderr, "%d symbols cannot be coded in %d bits\n",
-                syms, max);
-        return 1;
-    }
-
-    /* allocate code vector */
-    code = calloc(max + 1, sizeof(int));
-    if (code == NULL) {
-        fputs("abort: unable to allocate enough memory\n", stderr);
-        return 1;
-    }
-
-    /* determine size of saved results array, checking for overflows,
-       allocate and clear the array (set all to zero with calloc()) */
-    if (syms == 2)              /* iff max == 1 */
-        num = NULL;             /* won't be saving any results */
-    else {
-        size = syms >> 1;
-        if (size > ((size_t)0 - 1) / (n = (syms - 1) >> 1) ||
-                (size *= n, size > ((size_t)0 - 1) / (n = max - 1)) ||
-                (size *= n, size > ((size_t)0 - 1) / sizeof(big_t)) ||
-                (num = calloc(size, sizeof(big_t))) == NULL) {
-            fputs("abort: unable to allocate enough memory\n", stderr);
-            cleanup();
-            return 1;
-        }
-    }
-
-    /* count possible codes for all numbers of symbols, add up counts */
-    sum = 0;
-    for (n = 2; n <= syms; n++) {
-        got = count(n, 1, 2);
-        sum += got;
-        if (got == -1 || sum < got) {       /* overflow */
-            fputs("abort: can't count that high!\n", stderr);
-            cleanup();
-            return 1;
-        }
-        printf("%llu %d-codes\n", got, n);
-    }
-    printf("%llu total codes for 2 to %d symbols", sum, syms);
-    if (max < syms - 1)
-        printf(" (%d-bit length limit)\n", max);
-    else
-        puts(" (no length limit)");
-
-    /* allocate and clear done array for beenhere() */
-    if (syms == 2)
-        done = NULL;
-    else if (size > ((size_t)0 - 1) / sizeof(struct tab) ||
-             (done = calloc(size, sizeof(struct tab))) == NULL) {
-        fputs("abort: unable to allocate enough memory\n", stderr);
-        cleanup();
-        return 1;
-    }
-
-    /* find and show maximum inflate table usage */
-        if (root > max)                 /* reduce root to max length */
-                root = max;
-    if (syms < ((code_t)1 << (root + 1)))
-        enough(syms);
-    else
-        puts("cannot handle minimum code lengths > root");
-
-    /* done */
-    cleanup();
-    return 0;
-}
diff -Nbaur gcc-4.8.1/zlib/examples/fitblk.c gcc-4.8.1-ppc/zlib/examples/fitblk.c
--- gcc-4.8.1/zlib/examples/fitblk.c	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/examples/fitblk.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,233 +0,0 @@
-/* fitblk.c: example of fitting compressed output to a specified size
-   Not copyrighted -- provided to the public domain
-   Version 1.1  25 November 2004  Mark Adler */
-
-/* Version history:
-   1.0  24 Nov 2004  First version
-   1.1  25 Nov 2004  Change deflateInit2() to deflateInit()
-                     Use fixed-size, stack-allocated raw buffers
-                     Simplify code moving compression to subroutines
-                     Use assert() for internal errors
-                     Add detailed description of approach
- */
-
-/* Approach to just fitting a requested compressed size:
-
-   fitblk performs three compression passes on a portion of the input
-   data in order to determine how much of that input will compress to
-   nearly the requested output block size.  The first pass generates
-   enough deflate blocks to produce output to fill the requested
-   output size plus a specfied excess amount (see the EXCESS define
-   below).  The last deflate block may go quite a bit past that, but
-   is discarded.  The second pass decompresses and recompresses just
-   the compressed data that fit in the requested plus excess sized
-   buffer.  The deflate process is terminated after that amount of
-   input, which is less than the amount consumed on the first pass.
-   The last deflate block of the result will be of a comparable size
-   to the final product, so that the header for that deflate block and
-   the compression ratio for that block will be about the same as in
-   the final product.  The third compression pass decompresses the
-   result of the second step, but only the compressed data up to the
-   requested size minus an amount to allow the compressed stream to
-   complete (see the MARGIN define below).  That will result in a
-   final compressed stream whose length is less than or equal to the
-   requested size.  Assuming sufficient input and a requested size
-   greater than a few hundred bytes, the shortfall will typically be
-   less than ten bytes.
-
-   If the input is short enough that the first compression completes
-   before filling the requested output size, then that compressed
-   stream is return with no recompression.
-
-   EXCESS is chosen to be just greater than the shortfall seen in a
-   two pass approach similar to the above.  That shortfall is due to
-   the last deflate block compressing more efficiently with a smaller
-   header on the second pass.  EXCESS is set to be large enough so
-   that there is enough uncompressed data for the second pass to fill
-   out the requested size, and small enough so that the final deflate
-   block of the second pass will be close in size to the final deflate
-   block of the third and final pass.  MARGIN is chosen to be just
-   large enough to assure that the final compression has enough room
-   to complete in all cases.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <assert.h>
-#include "zlib.h"
-
-#define local static
-
-/* print nastygram and leave */
-local void quit(char *why)
-{
-    fprintf(stderr, "fitblk abort: %s\n", why);
-    exit(1);
-}
-
-#define RAWLEN 4096    /* intermediate uncompressed buffer size */
-
-/* compress from file to def until provided buffer is full or end of
-   input reached; return last deflate() return value, or Z_ERRNO if
-   there was read error on the file */
-local int partcompress(FILE *in, z_streamp def)
-{
-    int ret, flush;
-    unsigned char raw[RAWLEN];
-
-    flush = Z_NO_FLUSH;
-    do {
-        def->avail_in = fread(raw, 1, RAWLEN, in);
-        if (ferror(in))
-            return Z_ERRNO;
-        def->next_in = raw;
-        if (feof(in))
-            flush = Z_FINISH;
-        ret = deflate(def, flush);
-        assert(ret != Z_STREAM_ERROR);
-    } while (def->avail_out != 0 && flush == Z_NO_FLUSH);
-    return ret;
-}
-
-/* recompress from inf's input to def's output; the input for inf and
-   the output for def are set in those structures before calling;
-   return last deflate() return value, or Z_MEM_ERROR if inflate()
-   was not able to allocate enough memory when it needed to */
-local int recompress(z_streamp inf, z_streamp def)
-{
-    int ret, flush;
-    unsigned char raw[RAWLEN];
-
-    flush = Z_NO_FLUSH;
-    do {
-        /* decompress */
-        inf->avail_out = RAWLEN;
-        inf->next_out = raw;
-        ret = inflate(inf, Z_NO_FLUSH);
-        assert(ret != Z_STREAM_ERROR && ret != Z_DATA_ERROR &&
-               ret != Z_NEED_DICT);
-        if (ret == Z_MEM_ERROR)
-            return ret;
-
-        /* compress what was decompresed until done or no room */
-        def->avail_in = RAWLEN - inf->avail_out;
-        def->next_in = raw;
-        if (inf->avail_out != 0)
-            flush = Z_FINISH;
-        ret = deflate(def, flush);
-        assert(ret != Z_STREAM_ERROR);
-    } while (ret != Z_STREAM_END && def->avail_out != 0);
-    return ret;
-}
-
-#define EXCESS 256      /* empirically determined stream overage */
-#define MARGIN 8        /* amount to back off for completion */
-
-/* compress from stdin to fixed-size block on stdout */
-int main(int argc, char **argv)
-{
-    int ret;                /* return code */
-    unsigned size;          /* requested fixed output block size */
-    unsigned have;          /* bytes written by deflate() call */
-    unsigned char *blk;     /* intermediate and final stream */
-    unsigned char *tmp;     /* close to desired size stream */
-    z_stream def, inf;      /* zlib deflate and inflate states */
-
-    /* get requested output size */
-    if (argc != 2)
-        quit("need one argument: size of output block");
-    ret = strtol(argv[1], argv + 1, 10);
-    if (argv[1][0] != 0)
-        quit("argument must be a number");
-    if (ret < 8)            /* 8 is minimum zlib stream size */
-        quit("need positive size of 8 or greater");
-    size = (unsigned)ret;
-
-    /* allocate memory for buffers and compression engine */
-    blk = malloc(size + EXCESS);
-    def.zalloc = Z_NULL;
-    def.zfree = Z_NULL;
-    def.opaque = Z_NULL;
-    ret = deflateInit(&def, Z_DEFAULT_COMPRESSION);
-    if (ret != Z_OK || blk == NULL)
-        quit("out of memory");
-
-    /* compress from stdin until output full, or no more input */
-    def.avail_out = size + EXCESS;
-    def.next_out = blk;
-    ret = partcompress(stdin, &def);
-    if (ret == Z_ERRNO)
-        quit("error reading input");
-
-    /* if it all fit, then size was undersubscribed -- done! */
-    if (ret == Z_STREAM_END && def.avail_out >= EXCESS) {
-        /* write block to stdout */
-        have = size + EXCESS - def.avail_out;
-        if (fwrite(blk, 1, have, stdout) != have || ferror(stdout))
-            quit("error writing output");
-
-        /* clean up and print results to stderr */
-        ret = deflateEnd(&def);
-        assert(ret != Z_STREAM_ERROR);
-        free(blk);
-        fprintf(stderr,
-                "%u bytes unused out of %u requested (all input)\n",
-                size - have, size);
-        return 0;
-    }
-
-    /* it didn't all fit -- set up for recompression */
-    inf.zalloc = Z_NULL;
-    inf.zfree = Z_NULL;
-    inf.opaque = Z_NULL;
-    inf.avail_in = 0;
-    inf.next_in = Z_NULL;
-    ret = inflateInit(&inf);
-    tmp = malloc(size + EXCESS);
-    if (ret != Z_OK || tmp == NULL)
-        quit("out of memory");
-    ret = deflateReset(&def);
-    assert(ret != Z_STREAM_ERROR);
-
-    /* do first recompression close to the right amount */
-    inf.avail_in = size + EXCESS;
-    inf.next_in = blk;
-    def.avail_out = size + EXCESS;
-    def.next_out = tmp;
-    ret = recompress(&inf, &def);
-    if (ret == Z_MEM_ERROR)
-        quit("out of memory");
-
-    /* set up for next reocmpression */
-    ret = inflateReset(&inf);
-    assert(ret != Z_STREAM_ERROR);
-    ret = deflateReset(&def);
-    assert(ret != Z_STREAM_ERROR);
-
-    /* do second and final recompression (third compression) */
-    inf.avail_in = size - MARGIN;   /* assure stream will complete */
-    inf.next_in = tmp;
-    def.avail_out = size;
-    def.next_out = blk;
-    ret = recompress(&inf, &def);
-    if (ret == Z_MEM_ERROR)
-        quit("out of memory");
-    assert(ret == Z_STREAM_END);    /* otherwise MARGIN too small */
-
-    /* done -- write block to stdout */
-    have = size - def.avail_out;
-    if (fwrite(blk, 1, have, stdout) != have || ferror(stdout))
-        quit("error writing output");
-
-    /* clean up and print results to stderr */
-    free(tmp);
-    ret = inflateEnd(&inf);
-    assert(ret != Z_STREAM_ERROR);
-    ret = deflateEnd(&def);
-    assert(ret != Z_STREAM_ERROR);
-    free(blk);
-    fprintf(stderr,
-            "%u bytes unused out of %u requested (%lu input)\n",
-            size - have, size, def.total_in);
-    return 0;
-}
diff -Nbaur gcc-4.8.1/zlib/examples/gun.c gcc-4.8.1-ppc/zlib/examples/gun.c
--- gcc-4.8.1/zlib/examples/gun.c	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/examples/gun.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,701 +0,0 @@
-/* gun.c -- simple gunzip to give an example of the use of inflateBack()
- * Copyright (C) 2003, 2005, 2008, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
-   Version 1.6  17 January 2010  Mark Adler */
-
-/* Version history:
-   1.0  16 Feb 2003  First version for testing of inflateBack()
-   1.1  21 Feb 2005  Decompress concatenated gzip streams
-                     Remove use of "this" variable (C++ keyword)
-                     Fix return value for in()
-                     Improve allocation failure checking
-                     Add typecasting for void * structures
-                     Add -h option for command version and usage
-                     Add a bunch of comments
-   1.2  20 Mar 2005  Add Unix compress (LZW) decompression
-                     Copy file attributes from input file to output file
-   1.3  12 Jun 2005  Add casts for error messages [Oberhumer]
-   1.4   8 Dec 2006  LZW decompression speed improvements
-   1.5   9 Feb 2008  Avoid warning in latest version of gcc
-   1.6  17 Jan 2010  Avoid signed/unsigned comparison warnings
- */
-
-/*
-   gun [ -t ] [ name ... ]
-
-   decompresses the data in the named gzip files.  If no arguments are given,
-   gun will decompress from stdin to stdout.  The names must end in .gz, -gz,
-   .z, -z, _z, or .Z.  The uncompressed data will be written to a file name
-   with the suffix stripped.  On success, the original file is deleted.  On
-   failure, the output file is deleted.  For most failures, the command will
-   continue to process the remaining names on the command line.  A memory
-   allocation failure will abort the command.  If -t is specified, then the
-   listed files or stdin will be tested as gzip files for integrity (without
-   checking for a proper suffix), no output will be written, and no files
-   will be deleted.
-
-   Like gzip, gun allows concatenated gzip streams and will decompress them,
-   writing all of the uncompressed data to the output.  Unlike gzip, gun allows
-   an empty file on input, and will produce no error writing an empty output
-   file.
-
-   gun will also decompress files made by Unix compress, which uses LZW
-   compression.  These files are automatically detected by virtue of their
-   magic header bytes.  Since the end of Unix compress stream is marked by the
-   end-of-file, they cannot be concantenated.  If a Unix compress stream is
-   encountered in an input file, it is the last stream in that file.
-
-   Like gunzip and uncompress, the file attributes of the orignal compressed
-   file are maintained in the final uncompressed file, to the extent that the
-   user permissions allow it.
-
-   On my Mac OS X PowerPC G4, gun is almost twice as fast as gunzip (version
-   1.2.4) is on the same file, when gun is linked with zlib 1.2.2.  Also the
-   LZW decompression provided by gun is about twice as fast as the standard
-   Unix uncompress command.
- */
-
-/* external functions and related types and constants */
-#include <stdio.h>          /* fprintf() */
-#include <stdlib.h>         /* malloc(), free() */
-#include <string.h>         /* strerror(), strcmp(), strlen(), memcpy() */
-#include <errno.h>          /* errno */
-#include <fcntl.h>          /* open() */
-#include <unistd.h>         /* read(), write(), close(), chown(), unlink() */
-#include <sys/types.h>
-#include <sys/stat.h>       /* stat(), chmod() */
-#include <utime.h>          /* utime() */
-#include "zlib.h"           /* inflateBackInit(), inflateBack(), */
-                            /* inflateBackEnd(), crc32() */
-
-/* function declaration */
-#define local static
-
-/* buffer constants */
-#define SIZE 32768U         /* input and output buffer sizes */
-#define PIECE 16384         /* limits i/o chunks for 16-bit int case */
-
-/* structure for infback() to pass to input function in() -- it maintains the
-   input file and a buffer of size SIZE */
-struct ind {
-    int infile;
-    unsigned char *inbuf;
-};
-
-/* Load input buffer, assumed to be empty, and return bytes loaded and a
-   pointer to them.  read() is called until the buffer is full, or until it
-   returns end-of-file or error.  Return 0 on error. */
-local unsigned in(void *in_desc, unsigned char **buf)
-{
-    int ret;
-    unsigned len;
-    unsigned char *next;
-    struct ind *me = (struct ind *)in_desc;
-
-    next = me->inbuf;
-    *buf = next;
-    len = 0;
-    do {
-        ret = PIECE;
-        if ((unsigned)ret > SIZE - len)
-            ret = (int)(SIZE - len);
-        ret = (int)read(me->infile, next, ret);
-        if (ret == -1) {
-            len = 0;
-            break;
-        }
-        next += ret;
-        len += ret;
-    } while (ret != 0 && len < SIZE);
-    return len;
-}
-
-/* structure for infback() to pass to output function out() -- it maintains the
-   output file, a running CRC-32 check on the output and the total number of
-   bytes output, both for checking against the gzip trailer.  (The length in
-   the gzip trailer is stored modulo 2^32, so it's ok if a long is 32 bits and
-   the output is greater than 4 GB.) */
-struct outd {
-    int outfile;
-    int check;                  /* true if checking crc and total */
-    unsigned long crc;
-    unsigned long total;
-};
-
-/* Write output buffer and update the CRC-32 and total bytes written.  write()
-   is called until all of the output is written or an error is encountered.
-   On success out() returns 0.  For a write failure, out() returns 1.  If the
-   output file descriptor is -1, then nothing is written.
- */
-local int out(void *out_desc, unsigned char *buf, unsigned len)
-{
-    int ret;
-    struct outd *me = (struct outd *)out_desc;
-
-    if (me->check) {
-        me->crc = crc32(me->crc, buf, len);
-        me->total += len;
-    }
-    if (me->outfile != -1)
-        do {
-            ret = PIECE;
-            if ((unsigned)ret > len)
-                ret = (int)len;
-            ret = (int)write(me->outfile, buf, ret);
-            if (ret == -1)
-                return 1;
-            buf += ret;
-            len -= ret;
-        } while (len != 0);
-    return 0;
-}
-
-/* next input byte macro for use inside lunpipe() and gunpipe() */
-#define NEXT() (have ? 0 : (have = in(indp, &next)), \
-                last = have ? (have--, (int)(*next++)) : -1)
-
-/* memory for gunpipe() and lunpipe() --
-   the first 256 entries of prefix[] and suffix[] are never used, could
-   have offset the index, but it's faster to waste the memory */
-unsigned char inbuf[SIZE];              /* input buffer */
-unsigned char outbuf[SIZE];             /* output buffer */
-unsigned short prefix[65536];           /* index to LZW prefix string */
-unsigned char suffix[65536];            /* one-character LZW suffix */
-unsigned char match[65280 + 2];         /* buffer for reversed match or gzip
-                                           32K sliding window */
-
-/* throw out what's left in the current bits byte buffer (this is a vestigial
-   aspect of the compressed data format derived from an implementation that
-   made use of a special VAX machine instruction!) */
-#define FLUSHCODE() \
-    do { \
-        left = 0; \
-        rem = 0; \
-        if (chunk > have) { \
-            chunk -= have; \
-            have = 0; \
-            if (NEXT() == -1) \
-                break; \
-            chunk--; \
-            if (chunk > have) { \
-                chunk = have = 0; \
-                break; \
-            } \
-        } \
-        have -= chunk; \
-        next += chunk; \
-        chunk = 0; \
-    } while (0)
-
-/* Decompress a compress (LZW) file from indp to outfile.  The compress magic
-   header (two bytes) has already been read and verified.  There are have bytes
-   of buffered input at next.  strm is used for passing error information back
-   to gunpipe().
-
-   lunpipe() will return Z_OK on success, Z_BUF_ERROR for an unexpected end of
-   file, read error, or write error (a write error indicated by strm->next_in
-   not equal to Z_NULL), or Z_DATA_ERROR for invalid input.
- */
-local int lunpipe(unsigned have, unsigned char *next, struct ind *indp,
-                  int outfile, z_stream *strm)
-{
-    int last;                   /* last byte read by NEXT(), or -1 if EOF */
-    unsigned chunk;             /* bytes left in current chunk */
-    int left;                   /* bits left in rem */
-    unsigned rem;               /* unused bits from input */
-    int bits;                   /* current bits per code */
-    unsigned code;              /* code, table traversal index */
-    unsigned mask;              /* mask for current bits codes */
-    int max;                    /* maximum bits per code for this stream */
-    unsigned flags;             /* compress flags, then block compress flag */
-    unsigned end;               /* last valid entry in prefix/suffix tables */
-    unsigned temp;              /* current code */
-    unsigned prev;              /* previous code */
-    unsigned final;             /* last character written for previous code */
-    unsigned stack;             /* next position for reversed string */
-    unsigned outcnt;            /* bytes in output buffer */
-    struct outd outd;           /* output structure */
-    unsigned char *p;
-
-    /* set up output */
-    outd.outfile = outfile;
-    outd.check = 0;
-
-    /* process remainder of compress header -- a flags byte */
-    flags = NEXT();
-    if (last == -1)
-        return Z_BUF_ERROR;
-    if (flags & 0x60) {
-        strm->msg = (char *)"unknown lzw flags set";
-        return Z_DATA_ERROR;
-    }
-    max = flags & 0x1f;
-    if (max < 9 || max > 16) {
-        strm->msg = (char *)"lzw bits out of range";
-        return Z_DATA_ERROR;
-    }
-    if (max == 9)                           /* 9 doesn't really mean 9 */
-        max = 10;
-    flags &= 0x80;                          /* true if block compress */
-
-    /* clear table */
-    bits = 9;
-    mask = 0x1ff;
-    end = flags ? 256 : 255;
-
-    /* set up: get first 9-bit code, which is the first decompressed byte, but
-       don't create a table entry until the next code */
-    if (NEXT() == -1)                       /* no compressed data is ok */
-        return Z_OK;
-    final = prev = (unsigned)last;          /* low 8 bits of code */
-    if (NEXT() == -1)                       /* missing a bit */
-        return Z_BUF_ERROR;
-    if (last & 1) {                         /* code must be < 256 */
-        strm->msg = (char *)"invalid lzw code";
-        return Z_DATA_ERROR;
-    }
-    rem = (unsigned)last >> 1;              /* remaining 7 bits */
-    left = 7;
-    chunk = bits - 2;                       /* 7 bytes left in this chunk */
-    outbuf[0] = (unsigned char)final;       /* write first decompressed byte */
-    outcnt = 1;
-
-    /* decode codes */
-    stack = 0;
-    for (;;) {
-        /* if the table will be full after this, increment the code size */
-        if (end >= mask && bits < max) {
-            FLUSHCODE();
-            bits++;
-            mask <<= 1;
-            mask++;
-        }
-
-        /* get a code of length bits */
-        if (chunk == 0)                     /* decrement chunk modulo bits */
-            chunk = bits;
-        code = rem;                         /* low bits of code */
-        if (NEXT() == -1) {                 /* EOF is end of compressed data */
-            /* write remaining buffered output */
-            if (outcnt && out(&outd, outbuf, outcnt)) {
-                strm->next_in = outbuf;     /* signal write error */
-                return Z_BUF_ERROR;
-            }
-            return Z_OK;
-        }
-        code += (unsigned)last << left;     /* middle (or high) bits of code */
-        left += 8;
-        chunk--;
-        if (bits > left) {                  /* need more bits */
-            if (NEXT() == -1)               /* can't end in middle of code */
-                return Z_BUF_ERROR;
-            code += (unsigned)last << left; /* high bits of code */
-            left += 8;
-            chunk--;
-        }
-        code &= mask;                       /* mask to current code length */
-        left -= bits;                       /* number of unused bits */
-        rem = (unsigned)last >> (8 - left); /* unused bits from last byte */
-
-        /* process clear code (256) */
-        if (code == 256 && flags) {
-            FLUSHCODE();
-            bits = 9;                       /* initialize bits and mask */
-            mask = 0x1ff;
-            end = 255;                      /* empty table */
-            continue;                       /* get next code */
-        }
-
-        /* special code to reuse last match */
-        temp = code;                        /* save the current code */
-        if (code > end) {
-            /* Be picky on the allowed code here, and make sure that the code
-               we drop through (prev) will be a valid index so that random
-               input does not cause an exception.  The code != end + 1 check is
-               empirically derived, and not checked in the original uncompress
-               code.  If this ever causes a problem, that check could be safely
-               removed.  Leaving this check in greatly improves gun's ability
-               to detect random or corrupted input after a compress header.
-               In any case, the prev > end check must be retained. */
-            if (code != end + 1 || prev > end) {
-                strm->msg = (char *)"invalid lzw code";
-                return Z_DATA_ERROR;
-            }
-            match[stack++] = (unsigned char)final;
-            code = prev;
-        }
-
-        /* walk through linked list to generate output in reverse order */
-        p = match + stack;
-        while (code >= 256) {
-            *p++ = suffix[code];
-            code = prefix[code];
-        }
-        stack = p - match;
-        match[stack++] = (unsigned char)code;
-        final = code;
-
-        /* link new table entry */
-        if (end < mask) {
-            end++;
-            prefix[end] = (unsigned short)prev;
-            suffix[end] = (unsigned char)final;
-        }
-
-        /* set previous code for next iteration */
-        prev = temp;
-
-        /* write output in forward order */
-        while (stack > SIZE - outcnt) {
-            while (outcnt < SIZE)
-                outbuf[outcnt++] = match[--stack];
-            if (out(&outd, outbuf, outcnt)) {
-                strm->next_in = outbuf; /* signal write error */
-                return Z_BUF_ERROR;
-            }
-            outcnt = 0;
-        }
-        p = match + stack;
-        do {
-            outbuf[outcnt++] = *--p;
-        } while (p > match);
-        stack = 0;
-
-        /* loop for next code with final and prev as the last match, rem and
-           left provide the first 0..7 bits of the next code, end is the last
-           valid table entry */
-    }
-}
-
-/* Decompress a gzip file from infile to outfile.  strm is assumed to have been
-   successfully initialized with inflateBackInit().  The input file may consist
-   of a series of gzip streams, in which case all of them will be decompressed
-   to the output file.  If outfile is -1, then the gzip stream(s) integrity is
-   checked and nothing is written.
-
-   The return value is a zlib error code: Z_MEM_ERROR if out of memory,
-   Z_DATA_ERROR if the header or the compressed data is invalid, or if the
-   trailer CRC-32 check or length doesn't match, Z_BUF_ERROR if the input ends
-   prematurely or a write error occurs, or Z_ERRNO if junk (not a another gzip
-   stream) follows a valid gzip stream.
- */
-local int gunpipe(z_stream *strm, int infile, int outfile)
-{
-    int ret, first, last;
-    unsigned have, flags, len;
-    unsigned char *next = NULL;
-    struct ind ind, *indp;
-    struct outd outd;
-
-    /* setup input buffer */
-    ind.infile = infile;
-    ind.inbuf = inbuf;
-    indp = &ind;
-
-    /* decompress concatenated gzip streams */
-    have = 0;                               /* no input data read in yet */
-    first = 1;                              /* looking for first gzip header */
-    strm->next_in = Z_NULL;                 /* so Z_BUF_ERROR means EOF */
-    for (;;) {
-        /* look for the two magic header bytes for a gzip stream */
-        if (NEXT() == -1) {
-            ret = Z_OK;
-            break;                          /* empty gzip stream is ok */
-        }
-        if (last != 31 || (NEXT() != 139 && last != 157)) {
-            strm->msg = (char *)"incorrect header check";
-            ret = first ? Z_DATA_ERROR : Z_ERRNO;
-            break;                          /* not a gzip or compress header */
-        }
-        first = 0;                          /* next non-header is junk */
-
-        /* process a compress (LZW) file -- can't be concatenated after this */
-        if (last == 157) {
-            ret = lunpipe(have, next, indp, outfile, strm);
-            break;
-        }
-
-        /* process remainder of gzip header */
-        ret = Z_BUF_ERROR;
-        if (NEXT() != 8) {                  /* only deflate method allowed */
-            if (last == -1) break;
-            strm->msg = (char *)"unknown compression method";
-            ret = Z_DATA_ERROR;
-            break;
-        }
-        flags = NEXT();                     /* header flags */
-        NEXT();                             /* discard mod time, xflgs, os */
-        NEXT();
-        NEXT();
-        NEXT();
-        NEXT();
-        NEXT();
-        if (last == -1) break;
-        if (flags & 0xe0) {
-            strm->msg = (char *)"unknown header flags set";
-            ret = Z_DATA_ERROR;
-            break;
-        }
-        if (flags & 4) {                    /* extra field */
-            len = NEXT();
-            len += (unsigned)(NEXT()) << 8;
-            if (last == -1) break;
-            while (len > have) {
-                len -= have;
-                have = 0;
-                if (NEXT() == -1) break;
-                len--;
-            }
-            if (last == -1) break;
-            have -= len;
-            next += len;
-        }
-        if (flags & 8)                      /* file name */
-            while (NEXT() != 0 && last != -1)
-                ;
-        if (flags & 16)                     /* comment */
-            while (NEXT() != 0 && last != -1)
-                ;
-        if (flags & 2) {                    /* header crc */
-            NEXT();
-            NEXT();
-        }
-        if (last == -1) break;
-
-        /* set up output */
-        outd.outfile = outfile;
-        outd.check = 1;
-        outd.crc = crc32(0L, Z_NULL, 0);
-        outd.total = 0;
-
-        /* decompress data to output */
-        strm->next_in = next;
-        strm->avail_in = have;
-        ret = inflateBack(strm, in, indp, out, &outd);
-        if (ret != Z_STREAM_END) break;
-        next = strm->next_in;
-        have = strm->avail_in;
-        strm->next_in = Z_NULL;             /* so Z_BUF_ERROR means EOF */
-
-        /* check trailer */
-        ret = Z_BUF_ERROR;
-        if (NEXT() != (int)(outd.crc & 0xff) ||
-            NEXT() != (int)((outd.crc >> 8) & 0xff) ||
-            NEXT() != (int)((outd.crc >> 16) & 0xff) ||
-            NEXT() != (int)((outd.crc >> 24) & 0xff)) {
-            /* crc error */
-            if (last != -1) {
-                strm->msg = (char *)"incorrect data check";
-                ret = Z_DATA_ERROR;
-            }
-            break;
-        }
-        if (NEXT() != (int)(outd.total & 0xff) ||
-            NEXT() != (int)((outd.total >> 8) & 0xff) ||
-            NEXT() != (int)((outd.total >> 16) & 0xff) ||
-            NEXT() != (int)((outd.total >> 24) & 0xff)) {
-            /* length error */
-            if (last != -1) {
-                strm->msg = (char *)"incorrect length check";
-                ret = Z_DATA_ERROR;
-            }
-            break;
-        }
-
-        /* go back and look for another gzip stream */
-    }
-
-    /* clean up and return */
-    return ret;
-}
-
-/* Copy file attributes, from -> to, as best we can.  This is best effort, so
-   no errors are reported.  The mode bits, including suid, sgid, and the sticky
-   bit are copied (if allowed), the owner's user id and group id are copied
-   (again if allowed), and the access and modify times are copied. */
-local void copymeta(char *from, char *to)
-{
-    struct stat was;
-    struct utimbuf when;
-
-    /* get all of from's Unix meta data, return if not a regular file */
-    if (stat(from, &was) != 0 || (was.st_mode & S_IFMT) != S_IFREG)
-        return;
-
-    /* set to's mode bits, ignore errors */
-    (void)chmod(to, was.st_mode & 07777);
-
-    /* copy owner's user and group, ignore errors */
-    (void)chown(to, was.st_uid, was.st_gid);
-
-    /* copy access and modify times, ignore errors */
-    when.actime = was.st_atime;
-    when.modtime = was.st_mtime;
-    (void)utime(to, &when);
-}
-
-/* Decompress the file inname to the file outnname, of if test is true, just
-   decompress without writing and check the gzip trailer for integrity.  If
-   inname is NULL or an empty string, read from stdin.  If outname is NULL or
-   an empty string, write to stdout.  strm is a pre-initialized inflateBack
-   structure.  When appropriate, copy the file attributes from inname to
-   outname.
-
-   gunzip() returns 1 if there is an out-of-memory error or an unexpected
-   return code from gunpipe().  Otherwise it returns 0.
- */
-local int gunzip(z_stream *strm, char *inname, char *outname, int test)
-{
-    int ret;
-    int infile, outfile;
-
-    /* open files */
-    if (inname == NULL || *inname == 0) {
-        inname = "-";
-        infile = 0;     /* stdin */
-    }
-    else {
-        infile = open(inname, O_RDONLY, 0);
-        if (infile == -1) {
-            fprintf(stderr, "gun cannot open %s\n", inname);
-            return 0;
-        }
-    }
-    if (test)
-        outfile = -1;
-    else if (outname == NULL || *outname == 0) {
-        outname = "-";
-        outfile = 1;    /* stdout */
-    }
-    else {
-        outfile = open(outname, O_CREAT | O_TRUNC | O_WRONLY, 0666);
-        if (outfile == -1) {
-            close(infile);
-            fprintf(stderr, "gun cannot create %s\n", outname);
-            return 0;
-        }
-    }
-    errno = 0;
-
-    /* decompress */
-    ret = gunpipe(strm, infile, outfile);
-    if (outfile > 2) close(outfile);
-    if (infile > 2) close(infile);
-
-    /* interpret result */
-    switch (ret) {
-    case Z_OK:
-    case Z_ERRNO:
-        if (infile > 2 && outfile > 2) {
-            copymeta(inname, outname);          /* copy attributes */
-            unlink(inname);
-        }
-        if (ret == Z_ERRNO)
-            fprintf(stderr, "gun warning: trailing garbage ignored in %s\n",
-                    inname);
-        break;
-    case Z_DATA_ERROR:
-        if (outfile > 2) unlink(outname);
-        fprintf(stderr, "gun data error on %s: %s\n", inname, strm->msg);
-        break;
-    case Z_MEM_ERROR:
-        if (outfile > 2) unlink(outname);
-        fprintf(stderr, "gun out of memory error--aborting\n");
-        return 1;
-    case Z_BUF_ERROR:
-        if (outfile > 2) unlink(outname);
-        if (strm->next_in != Z_NULL) {
-            fprintf(stderr, "gun write error on %s: %s\n",
-                    outname, strerror(errno));
-        }
-        else if (errno) {
-            fprintf(stderr, "gun read error on %s: %s\n",
-                    inname, strerror(errno));
-        }
-        else {
-            fprintf(stderr, "gun unexpected end of file on %s\n",
-                    inname);
-        }
-        break;
-    default:
-        if (outfile > 2) unlink(outname);
-        fprintf(stderr, "gun internal error--aborting\n");
-        return 1;
-    }
-    return 0;
-}
-
-/* Process the gun command line arguments.  See the command syntax near the
-   beginning of this source file. */
-int main(int argc, char **argv)
-{
-    int ret, len, test;
-    char *outname;
-    unsigned char *window;
-    z_stream strm;
-
-    /* initialize inflateBack state for repeated use */
-    window = match;                         /* reuse LZW match buffer */
-    strm.zalloc = Z_NULL;
-    strm.zfree = Z_NULL;
-    strm.opaque = Z_NULL;
-    ret = inflateBackInit(&strm, 15, window);
-    if (ret != Z_OK) {
-        fprintf(stderr, "gun out of memory error--aborting\n");
-        return 1;
-    }
-
-    /* decompress each file to the same name with the suffix removed */
-    argc--;
-    argv++;
-    test = 0;
-    if (argc && strcmp(*argv, "-h") == 0) {
-        fprintf(stderr, "gun 1.6 (17 Jan 2010)\n");
-        fprintf(stderr, "Copyright (C) 2003-2010 Mark Adler\n");
-        fprintf(stderr, "usage: gun [-t] [file1.gz [file2.Z ...]]\n");
-        return 0;
-    }
-    if (argc && strcmp(*argv, "-t") == 0) {
-        test = 1;
-        argc--;
-        argv++;
-    }
-    if (argc)
-        do {
-            if (test)
-                outname = NULL;
-            else {
-                len = (int)strlen(*argv);
-                if (strcmp(*argv + len - 3, ".gz") == 0 ||
-                    strcmp(*argv + len - 3, "-gz") == 0)
-                    len -= 3;
-                else if (strcmp(*argv + len - 2, ".z") == 0 ||
-                    strcmp(*argv + len - 2, "-z") == 0 ||
-                    strcmp(*argv + len - 2, "_z") == 0 ||
-                    strcmp(*argv + len - 2, ".Z") == 0)
-                    len -= 2;
-                else {
-                    fprintf(stderr, "gun error: no gz type on %s--skipping\n",
-                            *argv);
-                    continue;
-                }
-                outname = malloc(len + 1);
-                if (outname == NULL) {
-                    fprintf(stderr, "gun out of memory error--aborting\n");
-                    ret = 1;
-                    break;
-                }
-                memcpy(outname, *argv, len);
-                outname[len] = 0;
-            }
-            ret = gunzip(&strm, *argv, outname, test);
-            if (outname != NULL) free(outname);
-            if (ret) break;
-        } while (argv++, --argc);
-    else
-        ret = gunzip(&strm, NULL, NULL, test);
-
-    /* clean up */
-    inflateBackEnd(&strm);
-    return ret;
-}
diff -Nbaur gcc-4.8.1/zlib/examples/gzappend.c gcc-4.8.1-ppc/zlib/examples/gzappend.c
--- gcc-4.8.1/zlib/examples/gzappend.c	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/examples/gzappend.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,500 +0,0 @@
-/* gzappend -- command to append to a gzip file
-
-  Copyright (C) 2003 Mark Adler, all rights reserved
-  version 1.1, 4 Nov 2003
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Mark Adler    madler@alumni.caltech.edu
- */
-
-/*
- * Change history:
- *
- * 1.0  19 Oct 2003     - First version
- * 1.1   4 Nov 2003     - Expand and clarify some comments and notes
- *                      - Add version and copyright to help
- *                      - Send help to stdout instead of stderr
- *                      - Add some preemptive typecasts
- *                      - Add L to constants in lseek() calls
- *                      - Remove some debugging information in error messages
- *                      - Use new data_type definition for zlib 1.2.1
- *                      - Simplfy and unify file operations
- *                      - Finish off gzip file in gztack()
- *                      - Use deflatePrime() instead of adding empty blocks
- *                      - Keep gzip file clean on appended file read errors
- *                      - Use in-place rotate instead of auxiliary buffer
- *                        (Why you ask?  Because it was fun to write!)
- */
-
-/*
-   gzappend takes a gzip file and appends to it, compressing files from the
-   command line or data from stdin.  The gzip file is written to directly, to
-   avoid copying that file, in case it's large.  Note that this results in the
-   unfriendly behavior that if gzappend fails, the gzip file is corrupted.
-
-   This program was written to illustrate the use of the new Z_BLOCK option of
-   zlib 1.2.x's inflate() function.  This option returns from inflate() at each
-   block boundary to facilitate locating and modifying the last block bit at
-   the start of the final deflate block.  Also whether using Z_BLOCK or not,
-   another required feature of zlib 1.2.x is that inflate() now provides the
-   number of unusued bits in the last input byte used.  gzappend will not work
-   with versions of zlib earlier than 1.2.1.
-
-   gzappend first decompresses the gzip file internally, discarding all but
-   the last 32K of uncompressed data, and noting the location of the last block
-   bit and the number of unused bits in the last byte of the compressed data.
-   The gzip trailer containing the CRC-32 and length of the uncompressed data
-   is verified.  This trailer will be later overwritten.
-
-   Then the last block bit is cleared by seeking back in the file and rewriting
-   the byte that contains it.  Seeking forward, the last byte of the compressed
-   data is saved along with the number of unused bits to initialize deflate.
-
-   A deflate process is initialized, using the last 32K of the uncompressed
-   data from the gzip file to initialize the dictionary.  If the total
-   uncompressed data was less than 32K, then all of it is used to initialize
-   the dictionary.  The deflate output bit buffer is also initialized with the
-   last bits from the original deflate stream.  From here on, the data to
-   append is simply compressed using deflate, and written to the gzip file.
-   When that is complete, the new CRC-32 and uncompressed length are written
-   as the trailer of the gzip file.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include "zlib.h"
-
-#define local static
-#define LGCHUNK 14
-#define CHUNK (1U << LGCHUNK)
-#define DSIZE 32768U
-
-/* print an error message and terminate with extreme prejudice */
-local void bye(char *msg1, char *msg2)
-{
-    fprintf(stderr, "gzappend error: %s%s\n", msg1, msg2);
-    exit(1);
-}
-
-/* return the greatest common divisor of a and b using Euclid's algorithm,
-   modified to be fast when one argument much greater than the other, and
-   coded to avoid unnecessary swapping */
-local unsigned gcd(unsigned a, unsigned b)
-{
-    unsigned c;
-
-    while (a && b)
-        if (a > b) {
-            c = b;
-            while (a - c >= c)
-                c <<= 1;
-            a -= c;
-        }
-        else {
-            c = a;
-            while (b - c >= c)
-                c <<= 1;
-            b -= c;
-        }
-    return a + b;
-}
-
-/* rotate list[0..len-1] left by rot positions, in place */
-local void rotate(unsigned char *list, unsigned len, unsigned rot)
-{
-    unsigned char tmp;
-    unsigned cycles;
-    unsigned char *start, *last, *to, *from;
-
-    /* normalize rot and handle degenerate cases */
-    if (len < 2) return;
-    if (rot >= len) rot %= len;
-    if (rot == 0) return;
-
-    /* pointer to last entry in list */
-    last = list + (len - 1);
-
-    /* do simple left shift by one */
-    if (rot == 1) {
-        tmp = *list;
-        memcpy(list, list + 1, len - 1);
-        *last = tmp;
-        return;
-    }
-
-    /* do simple right shift by one */
-    if (rot == len - 1) {
-        tmp = *last;
-        memmove(list + 1, list, len - 1);
-        *list = tmp;
-        return;
-    }
-
-    /* otherwise do rotate as a set of cycles in place */
-    cycles = gcd(len, rot);             /* number of cycles */
-    do {
-        start = from = list + cycles;   /* start index is arbitrary */
-        tmp = *from;                    /* save entry to be overwritten */
-        for (;;) {
-            to = from;                  /* next step in cycle */
-            from += rot;                /* go right rot positions */
-            if (from > last) from -= len;   /* (pointer better not wrap) */
-            if (from == start) break;   /* all but one shifted */
-            *to = *from;                /* shift left */
-        }
-        *to = tmp;                      /* complete the circle */
-    } while (--cycles);
-}
-
-/* structure for gzip file read operations */
-typedef struct {
-    int fd;                     /* file descriptor */
-    int size;                   /* 1 << size is bytes in buf */
-    unsigned left;              /* bytes available at next */
-    unsigned char *buf;         /* buffer */
-    unsigned char *next;        /* next byte in buffer */
-    char *name;                 /* file name for error messages */
-} file;
-
-/* reload buffer */
-local int readin(file *in)
-{
-    int len;
-
-    len = read(in->fd, in->buf, 1 << in->size);
-    if (len == -1) bye("error reading ", in->name);
-    in->left = (unsigned)len;
-    in->next = in->buf;
-    return len;
-}
-
-/* read from file in, exit if end-of-file */
-local int readmore(file *in)
-{
-    if (readin(in) == 0) bye("unexpected end of ", in->name);
-    return 0;
-}
-
-#define read1(in) (in->left == 0 ? readmore(in) : 0, \
-                   in->left--, *(in->next)++)
-
-/* skip over n bytes of in */
-local void skip(file *in, unsigned n)
-{
-    unsigned bypass;
-
-    if (n > in->left) {
-        n -= in->left;
-        bypass = n & ~((1U << in->size) - 1);
-        if (bypass) {
-            if (lseek(in->fd, (off_t)bypass, SEEK_CUR) == -1)
-                bye("seeking ", in->name);
-            n -= bypass;
-        }
-        readmore(in);
-        if (n > in->left)
-            bye("unexpected end of ", in->name);
-    }
-    in->left -= n;
-    in->next += n;
-}
-
-/* read a four-byte unsigned integer, little-endian, from in */
-unsigned long read4(file *in)
-{
-    unsigned long val;
-
-    val = read1(in);
-    val += (unsigned)read1(in) << 8;
-    val += (unsigned long)read1(in) << 16;
-    val += (unsigned long)read1(in) << 24;
-    return val;
-}
-
-/* skip over gzip header */
-local void gzheader(file *in)
-{
-    int flags;
-    unsigned n;
-
-    if (read1(in) != 31 || read1(in) != 139) bye(in->name, " not a gzip file");
-    if (read1(in) != 8) bye("unknown compression method in", in->name);
-    flags = read1(in);
-    if (flags & 0xe0) bye("unknown header flags set in", in->name);
-    skip(in, 6);
-    if (flags & 4) {
-        n = read1(in);
-        n += (unsigned)(read1(in)) << 8;
-        skip(in, n);
-    }
-    if (flags & 8) while (read1(in) != 0) ;
-    if (flags & 16) while (read1(in) != 0) ;
-    if (flags & 2) skip(in, 2);
-}
-
-/* decompress gzip file "name", return strm with a deflate stream ready to
-   continue compression of the data in the gzip file, and return a file
-   descriptor pointing to where to write the compressed data -- the deflate
-   stream is initialized to compress using level "level" */
-local int gzscan(char *name, z_stream *strm, int level)
-{
-    int ret, lastbit, left, full;
-    unsigned have;
-    unsigned long crc, tot;
-    unsigned char *window;
-    off_t lastoff, end;
-    file gz;
-
-    /* open gzip file */
-    gz.name = name;
-    gz.fd = open(name, O_RDWR, 0);
-    if (gz.fd == -1) bye("cannot open ", name);
-    gz.buf = malloc(CHUNK);
-    if (gz.buf == NULL) bye("out of memory", "");
-    gz.size = LGCHUNK;
-    gz.left = 0;
-
-    /* skip gzip header */
-    gzheader(&gz);
-
-    /* prepare to decompress */
-    window = malloc(DSIZE);
-    if (window == NULL) bye("out of memory", "");
-    strm->zalloc = Z_NULL;
-    strm->zfree = Z_NULL;
-    strm->opaque = Z_NULL;
-    ret = inflateInit2(strm, -15);
-    if (ret != Z_OK) bye("out of memory", " or library mismatch");
-
-    /* decompress the deflate stream, saving append information */
-    lastbit = 0;
-    lastoff = lseek(gz.fd, 0L, SEEK_CUR) - gz.left;
-    left = 0;
-    strm->avail_in = gz.left;
-    strm->next_in = gz.next;
-    crc = crc32(0L, Z_NULL, 0);
-    have = full = 0;
-    do {
-        /* if needed, get more input */
-        if (strm->avail_in == 0) {
-            readmore(&gz);
-            strm->avail_in = gz.left;
-            strm->next_in = gz.next;
-        }
-
-        /* set up output to next available section of sliding window */
-        strm->avail_out = DSIZE - have;
-        strm->next_out = window + have;
-
-        /* inflate and check for errors */
-        ret = inflate(strm, Z_BLOCK);
-        if (ret == Z_STREAM_ERROR) bye("internal stream error!", "");
-        if (ret == Z_MEM_ERROR) bye("out of memory", "");
-        if (ret == Z_DATA_ERROR)
-            bye("invalid compressed data--format violated in", name);
-
-        /* update crc and sliding window pointer */
-        crc = crc32(crc, window + have, DSIZE - have - strm->avail_out);
-        if (strm->avail_out)
-            have = DSIZE - strm->avail_out;
-        else {
-            have = 0;
-            full = 1;
-        }
-
-        /* process end of block */
-        if (strm->data_type & 128) {
-            if (strm->data_type & 64)
-                left = strm->data_type & 0x1f;
-            else {
-                lastbit = strm->data_type & 0x1f;
-                lastoff = lseek(gz.fd, 0L, SEEK_CUR) - strm->avail_in;
-            }
-        }
-    } while (ret != Z_STREAM_END);
-    inflateEnd(strm);
-    gz.left = strm->avail_in;
-    gz.next = strm->next_in;
-
-    /* save the location of the end of the compressed data */
-    end = lseek(gz.fd, 0L, SEEK_CUR) - gz.left;
-
-    /* check gzip trailer and save total for deflate */
-    if (crc != read4(&gz))
-        bye("invalid compressed data--crc mismatch in ", name);
-    tot = strm->total_out;
-    if ((tot & 0xffffffffUL) != read4(&gz))
-        bye("invalid compressed data--length mismatch in", name);
-
-    /* if not at end of file, warn */
-    if (gz.left || readin(&gz))
-        fprintf(stderr,
-            "gzappend warning: junk at end of gzip file overwritten\n");
-
-    /* clear last block bit */
-    lseek(gz.fd, lastoff - (lastbit != 0), SEEK_SET);
-    if (read(gz.fd, gz.buf, 1) != 1) bye("reading after seek on ", name);
-    *gz.buf = (unsigned char)(*gz.buf ^ (1 << ((8 - lastbit) & 7)));
-    lseek(gz.fd, -1L, SEEK_CUR);
-    if (write(gz.fd, gz.buf, 1) != 1) bye("writing after seek to ", name);
-
-    /* if window wrapped, build dictionary from window by rotating */
-    if (full) {
-        rotate(window, DSIZE, have);
-        have = DSIZE;
-    }
-
-    /* set up deflate stream with window, crc, total_in, and leftover bits */
-    ret = deflateInit2(strm, level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY);
-    if (ret != Z_OK) bye("out of memory", "");
-    deflateSetDictionary(strm, window, have);
-    strm->adler = crc;
-    strm->total_in = tot;
-    if (left) {
-        lseek(gz.fd, --end, SEEK_SET);
-        if (read(gz.fd, gz.buf, 1) != 1) bye("reading after seek on ", name);
-        deflatePrime(strm, 8 - left, *gz.buf);
-    }
-    lseek(gz.fd, end, SEEK_SET);
-
-    /* clean up and return */
-    free(window);
-    free(gz.buf);
-    return gz.fd;
-}
-
-/* append file "name" to gzip file gd using deflate stream strm -- if last
-   is true, then finish off the deflate stream at the end */
-local void gztack(char *name, int gd, z_stream *strm, int last)
-{
-    int fd, len, ret;
-    unsigned left;
-    unsigned char *in, *out;
-
-    /* open file to compress and append */
-    fd = 0;
-    if (name != NULL) {
-        fd = open(name, O_RDONLY, 0);
-        if (fd == -1)
-            fprintf(stderr, "gzappend warning: %s not found, skipping ...\n",
-                    name);
-    }
-
-    /* allocate buffers */
-    in = fd == -1 ? NULL : malloc(CHUNK);
-    out = malloc(CHUNK);
-    if (out == NULL) bye("out of memory", "");
-
-    /* compress input file and append to gzip file */
-    do {
-        /* get more input */
-        len = fd == -1 ? 0 : read(fd, in, CHUNK);
-        if (len == -1) {
-            fprintf(stderr,
-                    "gzappend warning: error reading %s, skipping rest ...\n",
-                    name);
-            len = 0;
-        }
-        strm->avail_in = (unsigned)len;
-        strm->next_in = in;
-        if (len) strm->adler = crc32(strm->adler, in, (unsigned)len);
-
-        /* compress and write all available output */
-        do {
-            strm->avail_out = CHUNK;
-            strm->next_out = out;
-            ret = deflate(strm, last && len == 0 ? Z_FINISH : Z_NO_FLUSH);
-            left = CHUNK - strm->avail_out;
-            while (left) {
-                len = write(gd, out + CHUNK - strm->avail_out - left, left);
-                if (len == -1) bye("writing gzip file", "");
-                left -= (unsigned)len;
-            }
-        } while (strm->avail_out == 0 && ret != Z_STREAM_END);
-    } while (len != 0);
-
-    /* write trailer after last entry */
-    if (last) {
-        deflateEnd(strm);
-        out[0] = (unsigned char)(strm->adler);
-        out[1] = (unsigned char)(strm->adler >> 8);
-        out[2] = (unsigned char)(strm->adler >> 16);
-        out[3] = (unsigned char)(strm->adler >> 24);
-        out[4] = (unsigned char)(strm->total_in);
-        out[5] = (unsigned char)(strm->total_in >> 8);
-        out[6] = (unsigned char)(strm->total_in >> 16);
-        out[7] = (unsigned char)(strm->total_in >> 24);
-        len = 8;
-        do {
-            ret = write(gd, out + 8 - len, len);
-            if (ret == -1) bye("writing gzip file", "");
-            len -= ret;
-        } while (len);
-        close(gd);
-    }
-
-    /* clean up and return */
-    free(out);
-    if (in != NULL) free(in);
-    if (fd > 0) close(fd);
-}
-
-/* process the compression level option if present, scan the gzip file, and
-   append the specified files, or append the data from stdin if no other file
-   names are provided on the command line -- the gzip file must be writable
-   and seekable */
-int main(int argc, char **argv)
-{
-    int gd, level;
-    z_stream strm;
-
-    /* ignore command name */
-    argv++;
-
-    /* provide usage if no arguments */
-    if (*argv == NULL) {
-        printf("gzappend 1.1 (4 Nov 2003) Copyright (C) 2003 Mark Adler\n");
-        printf(
-            "usage: gzappend [-level] file.gz [ addthis [ andthis ... ]]\n");
-        return 0;
-    }
-
-    /* set compression level */
-    level = Z_DEFAULT_COMPRESSION;
-    if (argv[0][0] == '-') {
-        if (argv[0][1] < '0' || argv[0][1] > '9' || argv[0][2] != 0)
-            bye("invalid compression level", "");
-        level = argv[0][1] - '0';
-        if (*++argv == NULL) bye("no gzip file name after options", "");
-    }
-
-    /* prepare to append to gzip file */
-    gd = gzscan(*argv++, &strm, level);
-
-    /* append files on command line, or from stdin if none */
-    if (*argv == NULL)
-        gztack(NULL, gd, &strm, 1);
-    else
-        do {
-            gztack(*argv, gd, &strm, argv[1] == NULL);
-        } while (*++argv != NULL);
-    return 0;
-}
diff -Nbaur gcc-4.8.1/zlib/examples/gzjoin.c gcc-4.8.1-ppc/zlib/examples/gzjoin.c
--- gcc-4.8.1/zlib/examples/gzjoin.c	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/examples/gzjoin.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,448 +0,0 @@
-/* gzjoin -- command to join gzip files into one gzip file
-
-  Copyright (C) 2004 Mark Adler, all rights reserved
-  version 1.0, 11 Dec 2004
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Mark Adler    madler@alumni.caltech.edu
- */
-
-/*
- * Change history:
- *
- * 1.0  11 Dec 2004     - First version
- * 1.1  12 Jun 2005     - Changed ssize_t to long for portability
- */
-
-/*
-   gzjoin takes one or more gzip files on the command line and writes out a
-   single gzip file that will uncompress to the concatenation of the
-   uncompressed data from the individual gzip files.  gzjoin does this without
-   having to recompress any of the data and without having to calculate a new
-   crc32 for the concatenated uncompressed data.  gzjoin does however have to
-   decompress all of the input data in order to find the bits in the compressed
-   data that need to be modified to concatenate the streams.
-
-   gzjoin does not do an integrity check on the input gzip files other than
-   checking the gzip header and decompressing the compressed data.  They are
-   otherwise assumed to be complete and correct.
-
-   Each joint between gzip files removes at least 18 bytes of previous trailer
-   and subsequent header, and inserts an average of about three bytes to the
-   compressed data in order to connect the streams.  The output gzip file
-   has a minimal ten-byte gzip header with no file name or modification time.
-
-   This program was written to illustrate the use of the Z_BLOCK option of
-   inflate() and the crc32_combine() function.  gzjoin will not compile with
-   versions of zlib earlier than 1.2.3.
- */
-
-#include <stdio.h>      /* fputs(), fprintf(), fwrite(), putc() */
-#include <stdlib.h>     /* exit(), malloc(), free() */
-#include <fcntl.h>      /* open() */
-#include <unistd.h>     /* close(), read(), lseek() */
-#include "zlib.h"
-    /* crc32(), crc32_combine(), inflateInit2(), inflate(), inflateEnd() */
-
-#define local static
-
-/* exit with an error (return a value to allow use in an expression) */
-local int bail(char *why1, char *why2)
-{
-    fprintf(stderr, "gzjoin error: %s%s, output incomplete\n", why1, why2);
-    exit(1);
-    return 0;
-}
-
-/* -- simple buffered file input with access to the buffer -- */
-
-#define CHUNK 32768         /* must be a power of two and fit in unsigned */
-
-/* bin buffered input file type */
-typedef struct {
-    char *name;             /* name of file for error messages */
-    int fd;                 /* file descriptor */
-    unsigned left;          /* bytes remaining at next */
-    unsigned char *next;    /* next byte to read */
-    unsigned char *buf;     /* allocated buffer of length CHUNK */
-} bin;
-
-/* close a buffered file and free allocated memory */
-local void bclose(bin *in)
-{
-    if (in != NULL) {
-        if (in->fd != -1)
-            close(in->fd);
-        if (in->buf != NULL)
-            free(in->buf);
-        free(in);
-    }
-}
-
-/* open a buffered file for input, return a pointer to type bin, or NULL on
-   failure */
-local bin *bopen(char *name)
-{
-    bin *in;
-
-    in = malloc(sizeof(bin));
-    if (in == NULL)
-        return NULL;
-    in->buf = malloc(CHUNK);
-    in->fd = open(name, O_RDONLY, 0);
-    if (in->buf == NULL || in->fd == -1) {
-        bclose(in);
-        return NULL;
-    }
-    in->left = 0;
-    in->next = in->buf;
-    in->name = name;
-    return in;
-}
-
-/* load buffer from file, return -1 on read error, 0 or 1 on success, with
-   1 indicating that end-of-file was reached */
-local int bload(bin *in)
-{
-    long len;
-
-    if (in == NULL)
-        return -1;
-    if (in->left != 0)
-        return 0;
-    in->next = in->buf;
-    do {
-        len = (long)read(in->fd, in->buf + in->left, CHUNK - in->left);
-        if (len < 0)
-            return -1;
-        in->left += (unsigned)len;
-    } while (len != 0 && in->left < CHUNK);
-    return len == 0 ? 1 : 0;
-}
-
-/* get a byte from the file, bail if end of file */
-#define bget(in) (in->left ? 0 : bload(in), \
-                  in->left ? (in->left--, *(in->next)++) : \
-                    bail("unexpected end of file on ", in->name))
-
-/* get a four-byte little-endian unsigned integer from file */
-local unsigned long bget4(bin *in)
-{
-    unsigned long val;
-
-    val = bget(in);
-    val += (unsigned long)(bget(in)) << 8;
-    val += (unsigned long)(bget(in)) << 16;
-    val += (unsigned long)(bget(in)) << 24;
-    return val;
-}
-
-/* skip bytes in file */
-local void bskip(bin *in, unsigned skip)
-{
-    /* check pointer */
-    if (in == NULL)
-        return;
-
-    /* easy case -- skip bytes in buffer */
-    if (skip <= in->left) {
-        in->left -= skip;
-        in->next += skip;
-        return;
-    }
-
-    /* skip what's in buffer, discard buffer contents */
-    skip -= in->left;
-    in->left = 0;
-
-    /* seek past multiples of CHUNK bytes */
-    if (skip > CHUNK) {
-        unsigned left;
-
-        left = skip & (CHUNK - 1);
-        if (left == 0) {
-            /* exact number of chunks: seek all the way minus one byte to check
-               for end-of-file with a read */
-            lseek(in->fd, skip - 1, SEEK_CUR);
-            if (read(in->fd, in->buf, 1) != 1)
-                bail("unexpected end of file on ", in->name);
-            return;
-        }
-
-        /* skip the integral chunks, update skip with remainder */
-        lseek(in->fd, skip - left, SEEK_CUR);
-        skip = left;
-    }
-
-    /* read more input and skip remainder */
-    bload(in);
-    if (skip > in->left)
-        bail("unexpected end of file on ", in->name);
-    in->left -= skip;
-    in->next += skip;
-}
-
-/* -- end of buffered input functions -- */
-
-/* skip the gzip header from file in */
-local void gzhead(bin *in)
-{
-    int flags;
-
-    /* verify gzip magic header and compression method */
-    if (bget(in) != 0x1f || bget(in) != 0x8b || bget(in) != 8)
-        bail(in->name, " is not a valid gzip file");
-
-    /* get and verify flags */
-    flags = bget(in);
-    if ((flags & 0xe0) != 0)
-        bail("unknown reserved bits set in ", in->name);
-
-    /* skip modification time, extra flags, and os */
-    bskip(in, 6);
-
-    /* skip extra field if present */
-    if (flags & 4) {
-        unsigned len;
-
-        len = bget(in);
-        len += (unsigned)(bget(in)) << 8;
-        bskip(in, len);
-    }
-
-    /* skip file name if present */
-    if (flags & 8)
-        while (bget(in) != 0)
-            ;
-
-    /* skip comment if present */
-    if (flags & 16)
-        while (bget(in) != 0)
-            ;
-
-    /* skip header crc if present */
-    if (flags & 2)
-        bskip(in, 2);
-}
-
-/* write a four-byte little-endian unsigned integer to out */
-local void put4(unsigned long val, FILE *out)
-{
-    putc(val & 0xff, out);
-    putc((val >> 8) & 0xff, out);
-    putc((val >> 16) & 0xff, out);
-    putc((val >> 24) & 0xff, out);
-}
-
-/* Load up zlib stream from buffered input, bail if end of file */
-local void zpull(z_streamp strm, bin *in)
-{
-    if (in->left == 0)
-        bload(in);
-    if (in->left == 0)
-        bail("unexpected end of file on ", in->name);
-    strm->avail_in = in->left;
-    strm->next_in = in->next;
-}
-
-/* Write header for gzip file to out and initialize trailer. */
-local void gzinit(unsigned long *crc, unsigned long *tot, FILE *out)
-{
-    fwrite("\x1f\x8b\x08\0\0\0\0\0\0\xff", 1, 10, out);
-    *crc = crc32(0L, Z_NULL, 0);
-    *tot = 0;
-}
-
-/* Copy the compressed data from name, zeroing the last block bit of the last
-   block if clr is true, and adding empty blocks as needed to get to a byte
-   boundary.  If clr is false, then the last block becomes the last block of
-   the output, and the gzip trailer is written.  crc and tot maintains the
-   crc and length (modulo 2^32) of the output for the trailer.  The resulting
-   gzip file is written to out.  gzinit() must be called before the first call
-   of gzcopy() to write the gzip header and to initialize crc and tot. */
-local void gzcopy(char *name, int clr, unsigned long *crc, unsigned long *tot,
-                  FILE *out)
-{
-    int ret;                /* return value from zlib functions */
-    int pos;                /* where the "last block" bit is in byte */
-    int last;               /* true if processing the last block */
-    bin *in;                /* buffered input file */
-    unsigned char *start;   /* start of compressed data in buffer */
-    unsigned char *junk;    /* buffer for uncompressed data -- discarded */
-    z_off_t len;            /* length of uncompressed data (support > 4 GB) */
-    z_stream strm;          /* zlib inflate stream */
-
-    /* open gzip file and skip header */
-    in = bopen(name);
-    if (in == NULL)
-        bail("could not open ", name);
-    gzhead(in);
-
-    /* allocate buffer for uncompressed data and initialize raw inflate
-       stream */
-    junk = malloc(CHUNK);
-    strm.zalloc = Z_NULL;
-    strm.zfree = Z_NULL;
-    strm.opaque = Z_NULL;
-    strm.avail_in = 0;
-    strm.next_in = Z_NULL;
-    ret = inflateInit2(&strm, -15);
-    if (junk == NULL || ret != Z_OK)
-        bail("out of memory", "");
-
-    /* inflate and copy compressed data, clear last-block bit if requested */
-    len = 0;
-    zpull(&strm, in);
-    start = strm.next_in;
-    last = start[0] & 1;
-    if (last && clr)
-        start[0] &= ~1;
-    strm.avail_out = 0;
-    for (;;) {
-        /* if input used and output done, write used input and get more */
-        if (strm.avail_in == 0 && strm.avail_out != 0) {
-            fwrite(start, 1, strm.next_in - start, out);
-            start = in->buf;
-            in->left = 0;
-            zpull(&strm, in);
-        }
-
-        /* decompress -- return early when end-of-block reached */
-        strm.avail_out = CHUNK;
-        strm.next_out = junk;
-        ret = inflate(&strm, Z_BLOCK);
-        switch (ret) {
-        case Z_MEM_ERROR:
-            bail("out of memory", "");
-        case Z_DATA_ERROR:
-            bail("invalid compressed data in ", in->name);
-        }
-
-        /* update length of uncompressed data */
-        len += CHUNK - strm.avail_out;
-
-        /* check for block boundary (only get this when block copied out) */
-        if (strm.data_type & 128) {
-            /* if that was the last block, then done */
-            if (last)
-                break;
-
-            /* number of unused bits in last byte */
-            pos = strm.data_type & 7;
-
-            /* find the next last-block bit */
-            if (pos != 0) {
-                /* next last-block bit is in last used byte */
-                pos = 0x100 >> pos;
-                last = strm.next_in[-1] & pos;
-                if (last && clr)
-                    strm.next_in[-1] &= ~pos;
-            }
-            else {
-                /* next last-block bit is in next unused byte */
-                if (strm.avail_in == 0) {
-                    /* don't have that byte yet -- get it */
-                    fwrite(start, 1, strm.next_in - start, out);
-                    start = in->buf;
-                    in->left = 0;
-                    zpull(&strm, in);
-                }
-                last = strm.next_in[0] & 1;
-                if (last && clr)
-                    strm.next_in[0] &= ~1;
-            }
-        }
-    }
-
-    /* update buffer with unused input */
-    in->left = strm.avail_in;
-    in->next = strm.next_in;
-
-    /* copy used input, write empty blocks to get to byte boundary */
-    pos = strm.data_type & 7;
-    fwrite(start, 1, in->next - start - 1, out);
-    last = in->next[-1];
-    if (pos == 0 || !clr)
-        /* already at byte boundary, or last file: write last byte */
-        putc(last, out);
-    else {
-        /* append empty blocks to last byte */
-        last &= ((0x100 >> pos) - 1);       /* assure unused bits are zero */
-        if (pos & 1) {
-            /* odd -- append an empty stored block */
-            putc(last, out);
-            if (pos == 1)
-                putc(0, out);               /* two more bits in block header */
-            fwrite("\0\0\xff\xff", 1, 4, out);
-        }
-        else {
-            /* even -- append 1, 2, or 3 empty fixed blocks */
-            switch (pos) {
-            case 6:
-                putc(last | 8, out);
-                last = 0;
-            case 4:
-                putc(last | 0x20, out);
-                last = 0;
-            case 2:
-                putc(last | 0x80, out);
-                putc(0, out);
-            }
-        }
-    }
-
-    /* update crc and tot */
-    *crc = crc32_combine(*crc, bget4(in), len);
-    *tot += (unsigned long)len;
-
-    /* clean up */
-    inflateEnd(&strm);
-    free(junk);
-    bclose(in);
-
-    /* write trailer if this is the last gzip file */
-    if (!clr) {
-        put4(*crc, out);
-        put4(*tot, out);
-    }
-}
-
-/* join the gzip files on the command line, write result to stdout */
-int main(int argc, char **argv)
-{
-    unsigned long crc, tot;     /* running crc and total uncompressed length */
-
-    /* skip command name */
-    argc--;
-    argv++;
-
-    /* show usage if no arguments */
-    if (argc == 0) {
-        fputs("gzjoin usage: gzjoin f1.gz [f2.gz [f3.gz ...]] > fjoin.gz\n",
-              stderr);
-        return 0;
-    }
-
-    /* join gzip files on command line and write to stdout */
-    gzinit(&crc, &tot, stdout);
-    while (argc--)
-        gzcopy(*argv++, argc, &crc, &tot, stdout);
-
-    /* done */
-    return 0;
-}
diff -Nbaur gcc-4.8.1/zlib/examples/gzlog.c gcc-4.8.1-ppc/zlib/examples/gzlog.c
--- gcc-4.8.1/zlib/examples/gzlog.c	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/examples/gzlog.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1058 +0,0 @@
-/*
- * gzlog.c
- * Copyright (C) 2004, 2008 Mark Adler, all rights reserved
- * For conditions of distribution and use, see copyright notice in gzlog.h
- * version 2.0, 25 Apr 2008
- */
-
-/*
-   gzlog provides a mechanism for frequently appending short strings to a gzip
-   file that is efficient both in execution time and compression ratio.  The
-   strategy is to write the short strings in an uncompressed form to the end of
-   the gzip file, only compressing when the amount of uncompressed data has
-   reached a given threshold.
-
-   gzlog also provides protection against interruptions in the process due to
-   system crashes.  The status of the operation is recorded in an extra field
-   in the gzip file, and is only updated once the gzip file is brought to a
-   valid state.  The last data to be appended or compressed is saved in an
-   auxiliary file, so that if the operation is interrupted, it can be completed
-   the next time an append operation is attempted.
-
-   gzlog maintains another auxiliary file with the last 32K of data from the
-   compressed portion, which is preloaded for the compression of the subsequent
-   data.  This minimizes the impact to the compression ratio of appending.
- */
-
-/*
-   Operations Concept:
-
-   Files (log name "foo"):
-   foo.gz -- gzip file with the complete log
-   foo.add -- last message to append or last data to compress
-   foo.dict -- dictionary of the last 32K of data for next compression
-   foo.temp -- temporary dictionary file for compression after this one
-   foo.lock -- lock file for reading and writing the other files
-   foo.repairs -- log file for log file recovery operations (not compressed)
-
-   gzip file structure:
-   - fixed-length (no file name) header with extra field (see below)
-   - compressed data ending initially with empty stored block
-   - uncompressed data filling out originally empty stored block and
-     subsequent stored blocks as needed (16K max each)
-   - gzip trailer
-   - no junk at end (no other gzip streams)
-
-   When appending data, the information in the first three items above plus the
-   foo.add file are sufficient to recover an interrupted append operation.  The
-   extra field has the necessary information to restore the start of the last
-   stored block and determine where to append the data in the foo.add file, as
-   well as the crc and length of the gzip data before the append operation.
-
-   The foo.add file is created before the gzip file is marked for append, and
-   deleted after the gzip file is marked as complete.  So if the append
-   operation is interrupted, the data to add will still be there.  If due to
-   some external force, the foo.add file gets deleted between when the append
-   operation was interrupted and when recovery is attempted, the gzip file will
-   still be restored, but without the appended data.
-
-   When compressing data, the information in the first two items above plus the
-   foo.add file are sufficient to recover an interrupted compress operation.
-   The extra field has the necessary information to find the end of the
-   compressed data, and contains both the crc and length of just the compressed
-   data and of the complete set of data including the contents of the foo.add
-   file.
-
-   Again, the foo.add file is maintained during the compress operation in case
-   of an interruption.  If in the unlikely event the foo.add file with the data
-   to be compressed is missing due to some external force, a gzip file with
-   just the previous compressed data will be reconstructed.  In this case, all
-   of the data that was to be compressed is lost (approximately one megabyte).
-   This will not occur if all that happened was an interruption of the compress
-   operation.
-
-   The third state that is marked is the replacement of the old dictionary with
-   the new dictionary after a compress operation.  Once compression is
-   complete, the gzip file is marked as being in the replace state.  This
-   completes the gzip file, so an interrupt after being so marked does not
-   result in recompression.  Then the dictionary file is replaced, and the gzip
-   file is marked as completed.  This state prevents the possibility of
-   restarting compression with the wrong dictionary file.
-
-   All three operations are wrapped by a lock/unlock procedure.  In order to
-   gain exclusive access to the log files, first a foo.lock file must be
-   exclusively created.  When all operations are complete, the lock is
-   released by deleting the foo.lock file.  If when attempting to create the
-   lock file, it already exists and the modify time of the lock file is more
-   than five minutes old (set by the PATIENCE define below), then the old
-   lock file is considered stale and deleted, and the exclusive creation of
-   the lock file is retried.  To assure that there are no false assessments
-   of the staleness of the lock file, the operations periodically touch the
-   lock file to update the modified date.
-
-   Following is the definition of the extra field with all of the information
-   required to enable the above append and compress operations and their
-   recovery if interrupted.  Multi-byte values are stored little endian
-   (consistent with the gzip format).  File pointers are eight bytes long.
-   The crc's and lengths for the gzip trailer are four bytes long.  (Note that
-   the length at the end of a gzip file is used for error checking only, and
-   for large files is actually the length modulo 2^32.)  The stored block
-   length is two bytes long.  The gzip extra field two-byte identification is
-   "ap" for append.  It is assumed that writing the extra field to the file is
-   an "atomic" operation.  That is, either all of the extra field is written
-   to the file, or none of it is, if the operation is interrupted right at the
-   point of updating the extra field.  This is a reasonable assumption, since
-   the extra field is within the first 52 bytes of the file, which is smaller
-   than any expected block size for a mass storage device (usually 512 bytes or
-   larger).
-
-   Extra field (35 bytes):
-   - Pointer to first stored block length -- this points to the two-byte length
-     of the first stored block, which is followed by the two-byte, one's
-     complement of that length.  The stored block length is preceded by the
-     three-bit header of the stored block, which is the actual start of the
-     stored block in the deflate format.  See the bit offset field below.
-   - Pointer to the last stored block length.  This is the same as above, but
-     for the last stored block of the uncompressed data in the gzip file.
-     Initially this is the same as the first stored block length pointer.
-     When the stored block gets to 16K (see the MAX_STORE define), then a new
-     stored block as added, at which point the last stored block length pointer
-     is different from the first stored block length pointer.  When they are
-     different, the first bit of the last stored block header is eight bits, or
-     one byte back from the block length.
-   - Compressed data crc and length.  This is the crc and length of the data
-     that is in the compressed portion of the deflate stream.  These are used
-     only in the event that the foo.add file containing the data to compress is
-     lost after a compress operation is interrupted.
-   - Total data crc and length.  This is the crc and length of all of the data
-     stored in the gzip file, compressed and uncompressed.  It is used to
-     reconstruct the gzip trailer when compressing, as well as when recovering
-     interrupted operations.
-   - Final stored block length.  This is used to quickly find where to append,
-     and allows the restoration of the original final stored block state when
-     an append operation is interrupted.
-   - First stored block start as the number of bits back from the final stored
-     block first length byte.  This value is in the range of 3..10, and is
-     stored as the low three bits of the final byte of the extra field after
-     subtracting three (0..7).  This allows the last-block bit of the stored
-     block header to be updated when a new stored block is added, for the case
-     when the first stored block and the last stored block are the same.  (When
-     they are different, the numbers of bits back is known to be eight.)  This
-     also allows for new compressed data to be appended to the old compressed
-     data in the compress operation, overwriting the previous first stored
-     block, or for the compressed data to be terminated and a valid gzip file
-     reconstructed on the off chance that a compression operation was
-     interrupted and the data to compress in the foo.add file was deleted.
-   - The operation in process.  This is the next two bits in the last byte (the
-     bits under the mask 0x18).  The are interpreted as 0: nothing in process,
-     1: append in process, 2: compress in process, 3: replace in process.
-   - The top three bits of the last byte in the extra field are reserved and
-     are currently set to zero.
-
-   Main procedure:
-   - Exclusively create the foo.lock file using the O_CREAT and O_EXCL modes of
-     the system open() call.  If the modify time of an existing lock file is
-     more than PATIENCE seconds old, then the lock file is deleted and the
-     exclusive create is retried.
-   - Load the extra field from the foo.gz file, and see if an operation was in
-     progress but not completed.  If so, apply the recovery procedure below.
-   - Perform the append procedure with the provided data.
-   - If the uncompressed data in the foo.gz file is 1MB or more, apply the
-     compress procedure.
-   - Delete the foo.lock file.
-
-   Append procedure:
-   - Put what to append in the foo.add file so that the operation can be
-     restarted if this procedure is interrupted.
-   - Mark the foo.gz extra field with the append operation in progress.
-   + Restore the original last-block bit and stored block length of the last
-     stored block from the information in the extra field, in case a previous
-     append operation was interrupted.
-   - Append the provided data to the last stored block, creating new stored
-     blocks as needed and updating the stored blocks last-block bits and
-     lengths.
-   - Update the crc and length with the new data, and write the gzip trailer.
-   - Write over the extra field (with a single write operation) with the new
-     pointers, lengths, and crc's, and mark the gzip file as not in process.
-     Though there is still a foo.add file, it will be ignored since nothing
-     is in process.  If a foo.add file is leftover from a previously
-     completed operation, it is truncated when writing new data to it.
-   - Delete the foo.add file.
-
-   Compress and replace procedures:
-   - Read all of the uncompressed data in the stored blocks in foo.gz and write
-     it to foo.add.  Also write foo.temp with the last 32K of that data to
-     provide a dictionary for the next invocation of this procedure.
-   - Rewrite the extra field marking foo.gz with a compression in process.
-   * If there is no data provided to compress (due to a missing foo.add file
-     when recovering), reconstruct and truncate the foo.gz file to contain
-     only the previous compressed data and proceed to the step after the next
-     one.  Otherwise ...
-   - Compress the data with the dictionary in foo.dict, and write to the
-     foo.gz file starting at the bit immediately following the last previously
-     compressed block.  If there is no foo.dict, proceed anyway with the
-     compression at slightly reduced efficiency.  (For the foo.dict file to be
-     missing requires some external failure beyond simply the interruption of
-     a compress operation.)  During this process, the foo.lock file is
-     periodically touched to assure that that file is not considered stale by
-     another process before we're done.  The deflation is terminated with a
-     non-last empty static block (10 bits long), that is then located and
-     written over by a last-bit-set empty stored block.
-   - Append the crc and length of the data in the gzip file (previously
-     calculated during the append operations).
-   - Write over the extra field with the updated stored block offsets, bits
-     back, crc's, and lengths, and mark foo.gz as in process for a replacement
-     of the dictionary.
-   @ Delete the foo.add file.
-   - Replace foo.dict with foo.temp.
-   - Write over the extra field, marking foo.gz as complete.
-
-   Recovery procedure:
-   - If not a replace recovery, read in the foo.add file, and provide that data
-     to the appropriate recovery below.  If there is no foo.add file, provide
-     a zero data length to the recovery.  In that case, the append recovery
-     restores the foo.gz to the previous compressed + uncompressed data state.
-     For the the compress recovery, a missing foo.add file results in foo.gz
-     being restored to the previous compressed-only data state.
-   - Append recovery:
-     - Pick up append at + step above
-   - Compress recovery:
-     - Pick up compress at * step above
-   - Replace recovery:
-     - Pick up compress at @ step above
-   - Log the repair with a date stamp in foo.repairs
- */
-
-#include <sys/types.h>
-#include <stdio.h>      /* rename, fopen, fprintf, fclose */
-#include <stdlib.h>     /* malloc, free */
-#include <string.h>     /* strlen, strrchr, strcpy, strncpy, strcmp */
-#include <fcntl.h>      /* open */
-#include <unistd.h>     /* lseek, read, write, close, unlink, sleep, */
-                        /* ftruncate, fsync */
-#include <errno.h>      /* errno */
-#include <time.h>       /* time, ctime */
-#include <sys/stat.h>   /* stat */
-#include <sys/time.h>   /* utimes */
-#include "zlib.h"       /* crc32 */
-
-#include "gzlog.h"      /* header for external access */
-
-#define local static
-typedef unsigned int uint;
-typedef unsigned long ulong;
-
-/* Macro for debugging to deterministically force recovery operations */
-#ifdef DEBUG
-    #include <setjmp.h>         /* longjmp */
-    jmp_buf gzlog_jump;         /* where to go back to */
-    int gzlog_bail = 0;         /* which point to bail at (1..8) */
-    int gzlog_count = -1;       /* number of times through to wait */
-#   define BAIL(n) do { if (n == gzlog_bail && gzlog_count-- == 0) \
-                            longjmp(gzlog_jump, gzlog_bail); } while (0)
-#else
-#   define BAIL(n)
-#endif
-
-/* how old the lock file can be in seconds before considering it stale */
-#define PATIENCE 300
-
-/* maximum stored block size in Kbytes -- must be in 1..63 */
-#define MAX_STORE 16
-
-/* number of stored Kbytes to trigger compression (must be >= 32 to allow
-   dictionary construction, and <= 204 * MAX_STORE, in order for >> 10 to
-   discard the stored block headers contribution of five bytes each) */
-#define TRIGGER 1024
-
-/* size of a deflate dictionary (this cannot be changed) */
-#define DICT 32768U
-
-/* values for the operation (2 bits) */
-#define NO_OP 0
-#define APPEND_OP 1
-#define COMPRESS_OP 2
-#define REPLACE_OP 3
-
-/* macros to extract little-endian integers from an unsigned byte buffer */
-#define PULL2(p) ((p)[0]+((uint)((p)[1])<<8))
-#define PULL4(p) (PULL2(p)+((ulong)PULL2(p+2)<<16))
-#define PULL8(p) (PULL4(p)+((off_t)PULL4(p+4)<<32))
-
-/* macros to store integers into a byte buffer in little-endian order */
-#define PUT2(p,a) do {(p)[0]=a;(p)[1]=(a)>>8;} while(0)
-#define PUT4(p,a) do {PUT2(p,a);PUT2(p+2,a>>16);} while(0)
-#define PUT8(p,a) do {PUT4(p,a);PUT4(p+4,a>>32);} while(0)
-
-/* internal structure for log information */
-#define LOGID "\106\035\172"    /* should be three non-zero characters */
-struct log {
-    char id[4];     /* contains LOGID to detect inadvertent overwrites */
-    int fd;         /* file descriptor for .gz file, opened read/write */
-    char *path;     /* allocated path, e.g. "/var/log/foo" or "foo" */
-    char *end;      /* end of path, for appending suffices such as ".gz" */
-    off_t first;    /* offset of first stored block first length byte */
-    int back;       /* location of first block id in bits back from first */
-    uint stored;    /* bytes currently in last stored block */
-    off_t last;     /* offset of last stored block first length byte */
-    ulong ccrc;     /* crc of compressed data */
-    ulong clen;     /* length (modulo 2^32) of compressed data */
-    ulong tcrc;     /* crc of total data */
-    ulong tlen;     /* length (modulo 2^32) of total data */
-    time_t lock;    /* last modify time of our lock file */
-};
-
-/* gzip header for gzlog */
-local unsigned char log_gzhead[] = {
-    0x1f, 0x8b,                 /* magic gzip id */
-    8,                          /* compression method is deflate */
-    4,                          /* there is an extra field (no file name) */
-    0, 0, 0, 0,                 /* no modification time provided */
-    0, 0xff,                    /* no extra flags, no OS specified */
-    39, 0, 'a', 'p', 35, 0      /* extra field with "ap" subfield */
-                                /* 35 is EXTRA, 39 is EXTRA + 4 */
-};
-
-#define HEAD sizeof(log_gzhead)     /* should be 16 */
-
-/* initial gzip extra field content (52 == HEAD + EXTRA + 1) */
-local unsigned char log_gzext[] = {
-    52, 0, 0, 0, 0, 0, 0, 0,    /* offset of first stored block length */
-    52, 0, 0, 0, 0, 0, 0, 0,    /* offset of last stored block length */
-    0, 0, 0, 0, 0, 0, 0, 0,     /* compressed data crc and length */
-    0, 0, 0, 0, 0, 0, 0, 0,     /* total data crc and length */
-    0, 0,                       /* final stored block data length */
-    5                           /* op is NO_OP, last bit 8 bits back */
-};
-
-#define EXTRA sizeof(log_gzext)     /* should be 35 */
-
-/* initial gzip data and trailer */
-local unsigned char log_gzbody[] = {
-    1, 0, 0, 0xff, 0xff,        /* empty stored block (last) */
-    0, 0, 0, 0,                 /* crc */
-    0, 0, 0, 0                  /* uncompressed length */
-};
-
-#define BODY sizeof(log_gzbody)
-
-/* Exclusively create foo.lock in order to negotiate exclusive access to the
-   foo.* files.  If the modify time of an existing lock file is greater than
-   PATIENCE seconds in the past, then consider the lock file to have been
-   abandoned, delete it, and try the exclusive create again.  Save the lock
-   file modify time for verification of ownership.  Return 0 on success, or -1
-   on failure, usually due to an access restriction or invalid path.  Note that
-   if stat() or unlink() fails, it may be due to another process noticing the
-   abandoned lock file a smidge sooner and deleting it, so those are not
-   flagged as an error. */
-local int log_lock(struct log *log)
-{
-    int fd;
-    struct stat st;
-
-    strcpy(log->end, ".lock");
-    while ((fd = open(log->path, O_CREAT | O_EXCL, 0644)) < 0) {
-        if (errno != EEXIST)
-            return -1;
-        if (stat(log->path, &st) == 0 && time(NULL) - st.st_mtime > PATIENCE) {
-            unlink(log->path);
-            continue;
-        }
-        sleep(2);       /* relinquish the CPU for two seconds while waiting */
-    }
-    close(fd);
-    if (stat(log->path, &st) == 0)
-        log->lock = st.st_mtime;
-    return 0;
-}
-
-/* Update the modify time of the lock file to now, in order to prevent another
-   task from thinking that the lock is stale.  Save the lock file modify time
-   for verification of ownership. */
-local void log_touch(struct log *log)
-{
-    struct stat st;
-
-    strcpy(log->end, ".lock");
-    utimes(log->path, NULL);
-    if (stat(log->path, &st) == 0)
-        log->lock = st.st_mtime;
-}
-
-/* Check the log file modify time against what is expected.  Return true if
-   this is not our lock.  If it is our lock, touch it to keep it. */
-local int log_check(struct log *log)
-{
-    struct stat st;
-
-    strcpy(log->end, ".lock");
-    if (stat(log->path, &st) || st.st_mtime != log->lock)
-        return 1;
-    log_touch(log);
-    return 0;
-}
-
-/* Unlock a previously acquired lock, but only if it's ours. */
-local void log_unlock(struct log *log)
-{
-    if (log_check(log))
-        return;
-    strcpy(log->end, ".lock");
-    unlink(log->path);
-    log->lock = 0;
-}
-
-/* Check the gzip header and read in the extra field, filling in the values in
-   the log structure.  Return op on success or -1 if the gzip header was not as
-   expected.  op is the current operation in progress last written to the extra
-   field.  This assumes that the gzip file has already been opened, with the
-   file descriptor log->fd. */
-local int log_head(struct log *log)
-{
-    int op;
-    unsigned char buf[HEAD + EXTRA];
-
-    if (lseek(log->fd, 0, SEEK_SET) < 0 ||
-        read(log->fd, buf, HEAD + EXTRA) != HEAD + EXTRA ||
-        memcmp(buf, log_gzhead, HEAD)) {
-        return -1;
-    }
-    log->first = PULL8(buf + HEAD);
-    log->last = PULL8(buf + HEAD + 8);
-    log->ccrc = PULL4(buf + HEAD + 16);
-    log->clen = PULL4(buf + HEAD + 20);
-    log->tcrc = PULL4(buf + HEAD + 24);
-    log->tlen = PULL4(buf + HEAD + 28);
-    log->stored = PULL2(buf + HEAD + 32);
-    log->back = 3 + (buf[HEAD + 34] & 7);
-    op = (buf[HEAD + 34] >> 3) & 3;
-    return op;
-}
-
-/* Write over the extra field contents, marking the operation as op.  Use fsync
-   to assure that the device is written to, and in the requested order.  This
-   operation, and only this operation, is assumed to be atomic in order to
-   assure that the log is recoverable in the event of an interruption at any
-   point in the process.  Return -1 if the write to foo.gz failed. */
-local int log_mark(struct log *log, int op)
-{
-    int ret;
-    unsigned char ext[EXTRA];
-
-    PUT8(ext, log->first);
-    PUT8(ext + 8, log->last);
-    PUT4(ext + 16, log->ccrc);
-    PUT4(ext + 20, log->clen);
-    PUT4(ext + 24, log->tcrc);
-    PUT4(ext + 28, log->tlen);
-    PUT2(ext + 32, log->stored);
-    ext[34] = log->back - 3 + (op << 3);
-    fsync(log->fd);
-    ret = lseek(log->fd, HEAD, SEEK_SET) < 0 ||
-          write(log->fd, ext, EXTRA) != EXTRA ? -1 : 0;
-    fsync(log->fd);
-    return ret;
-}
-
-/* Rewrite the last block header bits and subsequent zero bits to get to a byte
-   boundary, setting the last block bit if last is true, and then write the
-   remainder of the stored block header (length and one's complement).  Leave
-   the file pointer after the end of the last stored block data.  Return -1 if
-   there is a read or write failure on the foo.gz file */
-local int log_last(struct log *log, int last)
-{
-    int back, len, mask;
-    unsigned char buf[6];
-
-    /* determine the locations of the bytes and bits to modify */
-    back = log->last == log->first ? log->back : 8;
-    len = back > 8 ? 2 : 1;                 /* bytes back from log->last */
-    mask = 0x80 >> ((back - 1) & 7);        /* mask for block last-bit */
-
-    /* get the byte to modify (one or two back) into buf[0] -- don't need to
-       read the byte if the last-bit is eight bits back, since in that case
-       the entire byte will be modified */
-    buf[0] = 0;
-    if (back != 8 && (lseek(log->fd, log->last - len, SEEK_SET) < 0 ||
-                      read(log->fd, buf, 1) != 1))
-        return -1;
-
-    /* change the last-bit of the last stored block as requested -- note
-       that all bits above the last-bit are set to zero, per the type bits
-       of a stored block being 00 and per the convention that the bits to
-       bring the stream to a byte boundary are also zeros */
-    buf[1] = 0;
-    buf[2 - len] = (*buf & (mask - 1)) + (last ? mask : 0);
-
-    /* write the modified stored block header and lengths, move the file
-       pointer to after the last stored block data */
-    PUT2(buf + 2, log->stored);
-    PUT2(buf + 4, log->stored ^ 0xffff);
-    return lseek(log->fd, log->last - len, SEEK_SET) < 0 ||
-           write(log->fd, buf + 2 - len, len + 4) != len + 4 ||
-           lseek(log->fd, log->stored, SEEK_CUR) < 0 ? -1 : 0;
-}
-
-/* Append len bytes from data to the locked and open log file.  len may be zero
-   if recovering and no .add file was found.  In that case, the previous state
-   of the foo.gz file is restored.  The data is appended uncompressed in
-   deflate stored blocks.  Return -1 if there was an error reading or writing
-   the foo.gz file. */
-local int log_append(struct log *log, unsigned char *data, size_t len)
-{
-    uint put;
-    off_t end;
-    unsigned char buf[8];
-
-    /* set the last block last-bit and length, in case recovering an
-       interrupted append, then position the file pointer to append to the
-       block */
-    if (log_last(log, 1))
-        return -1;
-
-    /* append, adding stored blocks and updating the offset of the last stored
-       block as needed, and update the total crc and length */
-    while (len) {
-        /* append as much as we can to the last block */
-        put = (MAX_STORE << 10) - log->stored;
-        if (put > len)
-            put = (uint)len;
-        if (put) {
-            if (write(log->fd, data, put) != put)
-                return -1;
-            BAIL(1);
-            log->tcrc = crc32(log->tcrc, data, put);
-            log->tlen += put;
-            log->stored += put;
-            data += put;
-            len -= put;
-        }
-
-        /* if we need to, add a new empty stored block */
-        if (len) {
-            /* mark current block as not last */
-            if (log_last(log, 0))
-                return -1;
-
-            /* point to new, empty stored block */
-            log->last += 4 + log->stored + 1;
-            log->stored = 0;
-        }
-
-        /* mark last block as last, update its length */
-        if (log_last(log, 1))
-            return -1;
-        BAIL(2);
-    }
-
-    /* write the new crc and length trailer, and truncate just in case (could
-       be recovering from partial append with a missing foo.add file) */
-    PUT4(buf, log->tcrc);
-    PUT4(buf + 4, log->tlen);
-    if (write(log->fd, buf, 8) != 8 ||
-        (end = lseek(log->fd, 0, SEEK_CUR)) < 0 || ftruncate(log->fd, end))
-        return -1;
-
-    /* write the extra field, marking the log file as done, delete .add file */
-    if (log_mark(log, NO_OP))
-        return -1;
-    strcpy(log->end, ".add");
-    unlink(log->path);          /* ignore error, since may not exist */
-    return 0;
-}
-
-/* Replace the foo.dict file with the foo.temp file.  Also delete the foo.add
-   file, since the compress operation may have been interrupted before that was
-   done.  Returns 1 if memory could not be allocated, or -1 if reading or
-   writing foo.gz fails, or if the rename fails for some reason other than
-   foo.temp not existing.  foo.temp not existing is a permitted error, since
-   the replace operation may have been interrupted after the rename is done,
-   but before foo.gz is marked as complete. */
-local int log_replace(struct log *log)
-{
-    int ret;
-    char *dest;
-
-    /* delete foo.add file */
-    strcpy(log->end, ".add");
-    unlink(log->path);         /* ignore error, since may not exist */
-    BAIL(3);
-
-    /* rename foo.name to foo.dict, replacing foo.dict if it exists */
-    strcpy(log->end, ".dict");
-    dest = malloc(strlen(log->path) + 1);
-    if (dest == NULL)
-        return -2;
-    strcpy(dest, log->path);
-    strcpy(log->end, ".temp");
-    ret = rename(log->path, dest);
-    free(dest);
-    if (ret && errno != ENOENT)
-        return -1;
-    BAIL(4);
-
-    /* mark the foo.gz file as done */
-    return log_mark(log, NO_OP);
-}
-
-/* Compress the len bytes at data and append the compressed data to the
-   foo.gz deflate data immediately after the previous compressed data.  This
-   overwrites the previous uncompressed data, which was stored in foo.add
-   and is the data provided in data[0..len-1].  If this operation is
-   interrupted, it picks up at the start of this routine, with the foo.add
-   file read in again.  If there is no data to compress (len == 0), then we
-   simply terminate the foo.gz file after the previously compressed data,
-   appending a final empty stored block and the gzip trailer.  Return -1 if
-   reading or writing the log.gz file failed, or -2 if there was a memory
-   allocation failure. */
-local int log_compress(struct log *log, unsigned char *data, size_t len)
-{
-    int fd;
-    uint got, max;
-    ssize_t dict;
-    off_t end;
-    z_stream strm;
-    unsigned char buf[DICT];
-
-    /* compress and append compressed data */
-    if (len) {
-        /* set up for deflate, allocating memory */
-        strm.zalloc = Z_NULL;
-        strm.zfree = Z_NULL;
-        strm.opaque = Z_NULL;
-        if (deflateInit2(&strm, Z_DEFAULT_COMPRESSION, Z_DEFLATED, -15, 8,
-                         Z_DEFAULT_STRATEGY) != Z_OK)
-            return -2;
-
-        /* read in dictionary (last 32K of data that was compressed) */
-        strcpy(log->end, ".dict");
-        fd = open(log->path, O_RDONLY, 0);
-        if (fd >= 0) {
-            dict = read(fd, buf, DICT);
-            close(fd);
-            if (dict < 0) {
-                deflateEnd(&strm);
-                return -1;
-            }
-            if (dict)
-                deflateSetDictionary(&strm, buf, (uint)dict);
-        }
-        log_touch(log);
-
-        /* prime deflate with last bits of previous block, position write
-           pointer to write those bits and overwrite what follows */
-        if (lseek(log->fd, log->first - (log->back > 8 ? 2 : 1),
-                SEEK_SET) < 0 ||
-            read(log->fd, buf, 1) != 1 || lseek(log->fd, -1, SEEK_CUR) < 0) {
-            deflateEnd(&strm);
-            return -1;
-        }
-        deflatePrime(&strm, (8 - log->back) & 7, *buf);
-
-        /* compress, finishing with a partial non-last empty static block */
-        strm.next_in = data;
-        max = (((uint)0 - 1) >> 1) + 1; /* in case int smaller than size_t */
-        do {
-            strm.avail_in = len > max ? max : (uint)len;
-            len -= strm.avail_in;
-            do {
-                strm.avail_out = DICT;
-                strm.next_out = buf;
-                deflate(&strm, len ? Z_NO_FLUSH : Z_PARTIAL_FLUSH);
-                got = DICT - strm.avail_out;
-                if (got && write(log->fd, buf, got) != got) {
-                    deflateEnd(&strm);
-                    return -1;
-                }
-                log_touch(log);
-            } while (strm.avail_out == 0);
-        } while (len);
-        deflateEnd(&strm);
-        BAIL(5);
-
-        /* find start of empty static block -- scanning backwards the first one
-           bit is the second bit of the block, if the last byte is zero, then
-           we know the byte before that has a one in the top bit, since an
-           empty static block is ten bits long */
-        if ((log->first = lseek(log->fd, -1, SEEK_CUR)) < 0 ||
-            read(log->fd, buf, 1) != 1)
-            return -1;
-        log->first++;
-        if (*buf) {
-            log->back = 1;
-            while ((*buf & ((uint)1 << (8 - log->back++))) == 0)
-                ;       /* guaranteed to terminate, since *buf != 0 */
-        }
-        else
-            log->back = 10;
-
-        /* update compressed crc and length */
-        log->ccrc = log->tcrc;
-        log->clen = log->tlen;
-    }
-    else {
-        /* no data to compress -- fix up existing gzip stream */
-        log->tcrc = log->ccrc;
-        log->tlen = log->clen;
-    }
-
-    /* complete and truncate gzip stream */
-    log->last = log->first;
-    log->stored = 0;
-    PUT4(buf, log->tcrc);
-    PUT4(buf + 4, log->tlen);
-    if (log_last(log, 1) || write(log->fd, buf, 8) != 8 ||
-        (end = lseek(log->fd, 0, SEEK_CUR)) < 0 || ftruncate(log->fd, end))
-        return -1;
-    BAIL(6);
-
-    /* mark as being in the replace operation */
-    if (log_mark(log, REPLACE_OP))
-        return -1;
-
-    /* execute the replace operation and mark the file as done */
-    return log_replace(log);
-}
-
-/* log a repair record to the .repairs file */
-local void log_log(struct log *log, int op, char *record)
-{
-    time_t now;
-    FILE *rec;
-
-    now = time(NULL);
-    strcpy(log->end, ".repairs");
-    rec = fopen(log->path, "a");
-    if (rec == NULL)
-        return;
-    fprintf(rec, "%.24s %s recovery: %s\n", ctime(&now), op == APPEND_OP ?
-            "append" : (op == COMPRESS_OP ? "compress" : "replace"), record);
-    fclose(rec);
-    return;
-}
-
-/* Recover the interrupted operation op.  First read foo.add for recovering an
-   append or compress operation.  Return -1 if there was an error reading or
-   writing foo.gz or reading an existing foo.add, or -2 if there was a memory
-   allocation failure. */
-local int log_recover(struct log *log, int op)
-{
-    int fd, ret = 0;
-    unsigned char *data = NULL;
-    size_t len = 0;
-    struct stat st;
-
-    /* log recovery */
-    log_log(log, op, "start");
-
-    /* load foo.add file if expected and present */
-    if (op == APPEND_OP || op == COMPRESS_OP) {
-        strcpy(log->end, ".add");
-        if (stat(log->path, &st) == 0 && st.st_size) {
-            len = (size_t)(st.st_size);
-            if (len != st.st_size || (data = malloc(st.st_size)) == NULL) {
-                log_log(log, op, "allocation failure");
-                return -2;
-            }
-            if ((fd = open(log->path, O_RDONLY, 0)) < 0) {
-                log_log(log, op, ".add file read failure");
-                return -1;
-            }
-            ret = read(fd, data, len) != len;
-            close(fd);
-            if (ret) {
-                log_log(log, op, ".add file read failure");
-                return -1;
-            }
-            log_log(log, op, "loaded .add file");
-        }
-        else
-            log_log(log, op, "missing .add file!");
-    }
-
-    /* recover the interrupted operation */
-    switch (op) {
-    case APPEND_OP:
-        ret = log_append(log, data, len);
-        break;
-    case COMPRESS_OP:
-        ret = log_compress(log, data, len);
-        break;
-    case REPLACE_OP:
-        ret = log_replace(log);
-    }
-
-    /* log status */
-    log_log(log, op, ret ? "failure" : "complete");
-
-    /* clean up */
-    if (data != NULL)
-        free(data);
-    return ret;
-}
-
-/* Close the foo.gz file (if open) and release the lock. */
-local void log_close(struct log *log)
-{
-    if (log->fd >= 0)
-        close(log->fd);
-    log->fd = -1;
-    log_unlock(log);
-}
-
-/* Open foo.gz, verify the header, and load the extra field contents, after
-   first creating the foo.lock file to gain exclusive access to the foo.*
-   files.  If foo.gz does not exist or is empty, then write the initial header,
-   extra, and body content of an empty foo.gz log file.  If there is an error
-   creating the lock file due to access restrictions, or an error reading or
-   writing the foo.gz file, or if the foo.gz file is not a proper log file for
-   this object (e.g. not a gzip file or does not contain the expected extra
-   field), then return true.  If there is an error, the lock is released.
-   Otherwise, the lock is left in place. */
-local int log_open(struct log *log)
-{
-    int op;
-
-    /* release open file resource if left over -- can occur if lock lost
-       between gzlog_open() and gzlog_write() */
-    if (log->fd >= 0)
-        close(log->fd);
-    log->fd = -1;
-
-    /* negotiate exclusive access */
-    if (log_lock(log) < 0)
-        return -1;
-
-    /* open the log file, foo.gz */
-    strcpy(log->end, ".gz");
-    log->fd = open(log->path, O_RDWR | O_CREAT, 0644);
-    if (log->fd < 0) {
-        log_close(log);
-        return -1;
-    }
-
-    /* if new, initialize foo.gz with an empty log, delete old dictionary */
-    if (lseek(log->fd, 0, SEEK_END) == 0) {
-        if (write(log->fd, log_gzhead, HEAD) != HEAD ||
-            write(log->fd, log_gzext, EXTRA) != EXTRA ||
-            write(log->fd, log_gzbody, BODY) != BODY) {
-            log_close(log);
-            return -1;
-        }
-        strcpy(log->end, ".dict");
-        unlink(log->path);
-    }
-
-    /* verify log file and load extra field information */
-    if ((op = log_head(log)) < 0) {
-        log_close(log);
-        return -1;
-    }
-
-    /* check for interrupted process and if so, recover */
-    if (op != NO_OP && log_recover(log, op)) {
-        log_close(log);
-        return -1;
-    }
-
-    /* touch the lock file to prevent another process from grabbing it */
-    log_touch(log);
-    return 0;
-}
-
-/* See gzlog.h for the description of the external methods below */
-gzlog *gzlog_open(char *path)
-{
-    size_t n;
-    struct log *log;
-
-    /* check arguments */
-    if (path == NULL || *path == 0)
-        return NULL;
-
-    /* allocate and initialize log structure */
-    log = malloc(sizeof(struct log));
-    if (log == NULL)
-        return NULL;
-    strcpy(log->id, LOGID);
-    log->fd = -1;
-
-    /* save path and end of path for name construction */
-    n = strlen(path);
-    log->path = malloc(n + 9);              /* allow for ".repairs" */
-    if (log->path == NULL) {
-        free(log);
-        return NULL;
-    }
-    strcpy(log->path, path);
-    log->end = log->path + n;
-
-    /* gain exclusive access and verify log file -- may perform a
-       recovery operation if needed */
-    if (log_open(log)) {
-        free(log->path);
-        free(log);
-        return NULL;
-    }
-
-    /* return pointer to log structure */
-    return log;
-}
-
-/* gzlog_compress() return values:
-    0: all good
-   -1: file i/o error (usually access issue)
-   -2: memory allocation failure
-   -3: invalid log pointer argument */
-int gzlog_compress(gzlog *logd)
-{
-    int fd, ret;
-    uint block;
-    size_t len, next;
-    unsigned char *data, buf[5];
-    struct log *log = logd;
-
-    /* check arguments */
-    if (log == NULL || strcmp(log->id, LOGID) || len < 0)
-        return -3;
-
-    /* see if we lost the lock -- if so get it again and reload the extra
-       field information (it probably changed), recover last operation if
-       necessary */
-    if (log_check(log) && log_open(log))
-        return -1;
-
-    /* create space for uncompressed data */
-    len = ((size_t)(log->last - log->first) & ~(((size_t)1 << 10) - 1)) +
-          log->stored;
-    if ((data = malloc(len)) == NULL)
-        return -2;
-
-    /* do statement here is just a cheap trick for error handling */
-    do {
-        /* read in the uncompressed data */
-        if (lseek(log->fd, log->first - 1, SEEK_SET) < 0)
-            break;
-        next = 0;
-        while (next < len) {
-            if (read(log->fd, buf, 5) != 5)
-                break;
-            block = PULL2(buf + 1);
-            if (next + block > len ||
-                read(log->fd, (char *)data + next, block) != block)
-                break;
-            next += block;
-        }
-        if (lseek(log->fd, 0, SEEK_CUR) != log->last + 4 + log->stored)
-            break;
-        log_touch(log);
-
-        /* write the uncompressed data to the .add file */
-        strcpy(log->end, ".add");
-        fd = open(log->path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
-        if (fd < 0)
-            break;
-        ret = write(fd, data, len) != len;
-        if (ret | close(fd))
-            break;
-        log_touch(log);
-
-        /* write the dictionary for the next compress to the .temp file */
-        strcpy(log->end, ".temp");
-        fd = open(log->path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
-        if (fd < 0)
-            break;
-        next = DICT > len ? len : DICT;
-        ret = write(fd, (char *)data + len - next, next) != next;
-        if (ret | close(fd))
-            break;
-        log_touch(log);
-
-        /* roll back to compressed data, mark the compress in progress */
-        log->last = log->first;
-        log->stored = 0;
-        if (log_mark(log, COMPRESS_OP))
-            break;
-        BAIL(7);
-
-        /* compress and append the data (clears mark) */
-        ret = log_compress(log, data, len);
-        free(data);
-        return ret;
-    } while (0);
-
-    /* broke out of do above on i/o error */
-    free(data);
-    return -1;
-}
-
-/* gzlog_write() return values:
-    0: all good
-   -1: file i/o error (usually access issue)
-   -2: memory allocation failure
-   -3: invalid log pointer argument */
-int gzlog_write(gzlog *logd, void *data, size_t len)
-{
-    int fd, ret;
-    struct log *log = logd;
-
-    /* check arguments */
-    if (log == NULL || strcmp(log->id, LOGID) || len < 0)
-        return -3;
-    if (data == NULL || len == 0)
-        return 0;
-
-    /* see if we lost the lock -- if so get it again and reload the extra
-       field information (it probably changed), recover last operation if
-       necessary */
-    if (log_check(log) && log_open(log))
-        return -1;
-
-    /* create and write .add file */
-    strcpy(log->end, ".add");
-    fd = open(log->path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
-    if (fd < 0)
-        return -1;
-    ret = write(fd, data, len) != len;
-    if (ret | close(fd))
-        return -1;
-    log_touch(log);
-
-    /* mark log file with append in progress */
-    if (log_mark(log, APPEND_OP))
-        return -1;
-    BAIL(8);
-
-    /* append data (clears mark) */
-    if (log_append(log, data, len))
-        return -1;
-
-    /* check to see if it's time to compress -- if not, then done */
-    if (((log->last - log->first) >> 10) + (log->stored >> 10) < TRIGGER)
-        return 0;
-
-    /* time to compress */
-    return gzlog_compress(log);
-}
-
-/* gzlog_close() return values:
-    0: ok
-   -3: invalid log pointer argument */
-int gzlog_close(gzlog *logd)
-{
-    struct log *log = logd;
-
-    /* check arguments */
-    if (log == NULL || strcmp(log->id, LOGID))
-        return -3;
-
-    /* close the log file and release the lock */
-    log_close(log);
-
-    /* free structure and return */
-    if (log->path != NULL)
-        free(log->path);
-    strcpy(log->id, "bad");
-    free(log);
-    return 0;
-}
diff -Nbaur gcc-4.8.1/zlib/examples/gzlog.h gcc-4.8.1-ppc/zlib/examples/gzlog.h
--- gcc-4.8.1/zlib/examples/gzlog.h	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/examples/gzlog.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,89 +0,0 @@
-/* gzlog.h
-  Copyright (C) 2004, 2008 Mark Adler, all rights reserved
-  version 2.0, 25 Apr 2008
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Mark Adler    madler@alumni.caltech.edu
- */
-
-/* Version History:
-   1.0  26 Nov 2004  First version
-   2.0  25 Apr 2008  Complete redesign for recovery of interrupted operations
-                     Interface changed slightly in that now path is a prefix
-                     Compression now occurs as needed during gzlog_write()
-                     gzlog_write() now always leaves the log file as valid gzip
- */
-
-/*
-   The gzlog object allows writing short messages to a gzipped log file,
-   opening the log file locked for small bursts, and then closing it.  The log
-   object works by appending stored (uncompressed) data to the gzip file until
-   1 MB has been accumulated.  At that time, the stored data is compressed, and
-   replaces the uncompressed data in the file.  The log file is truncated to
-   its new size at that time.  After each write operation, the log file is a
-   valid gzip file that can decompressed to recover what was written.
-
-   The gzlog operations can be interupted at any point due to an application or
-   system crash, and the log file will be recovered the next time the log is
-   opened with gzlog_open().
- */
-
-#ifndef GZLOG_H
-#define GZLOG_H
-
-/* gzlog object type */
-typedef void gzlog;
-
-/* Open a gzlog object, creating the log file if it does not exist.  Return
-   NULL on error.  Note that gzlog_open() could take a while to complete if it
-   has to wait to verify that a lock is stale (possibly for five minutes), or
-   if there is significant contention with other instantiations of this object
-   when locking the resource.  path is the prefix of the file names created by
-   this object.  If path is "foo", then the log file will be "foo.gz", and
-   other auxiliary files will be created and destroyed during the process:
-   "foo.dict" for a compression dictionary, "foo.temp" for a temporary (next)
-   dictionary, "foo.add" for data being added or compressed, "foo.lock" for the
-   lock file, and "foo.repairs" to log recovery operations performed due to
-   interrupted gzlog operations.  A gzlog_open() followed by a gzlog_close()
-   will recover a previously interrupted operation, if any. */
-gzlog *gzlog_open(char *path);
-
-/* Write to a gzlog object.  Return zero on success, -1 if there is a file i/o
-   error on any of the gzlog files (this should not happen if gzlog_open()
-   succeeded, unless the device has run out of space or leftover auxiliary
-   files have permissions or ownership that prevent their use), -2 if there is
-   a memory allocation failure, or -3 if the log argument is invalid (e.g. if
-   it was not created by gzlog_open()).  This function will write data to the
-   file uncompressed, until 1 MB has been accumulated, at which time that data
-   will be compressed.  The log file will be a valid gzip file upon successful
-   return. */
-int gzlog_write(gzlog *log, void *data, size_t len);
-
-/* Force compression of any uncompressed data in the log.  This should be used
-   sparingly, if at all.  The main application would be when a log file will
-   not be appended to again.  If this is used to compress frequently while
-   appending, it will both significantly increase the execution time and
-   reduce the compression ratio.  The return codes are the same as for
-   gzlog_write(). */
-int gzlog_compress(gzlog *log);
-
-/* Close a gzlog object.  Return zero on success, -3 if the log argument is
-   invalid.  The log object is freed, and so cannot be referenced again. */
-int gzlog_close(gzlog *log);
-
-#endif
diff -Nbaur gcc-4.8.1/zlib/examples/README.examples gcc-4.8.1-ppc/zlib/examples/README.examples
--- gcc-4.8.1/zlib/examples/README.examples	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/examples/README.examples	1970-01-01 01:00:00.000000000 +0100
@@ -1,49 +0,0 @@
-This directory contains examples of the use of zlib and other relevant
-programs and documentation.
-
-enough.c
-    calculation and justification of ENOUGH parameter in inftrees.h
-    - calculates the maximum table space used in inflate tree
-      construction over all possible Huffman codes
-
-fitblk.c
-    compress just enough input to nearly fill a requested output size
-    - zlib isn't designed to do this, but fitblk does it anyway
-
-gun.c
-    uncompress a gzip file
-    - illustrates the use of inflateBack() for high speed file-to-file
-      decompression using call-back functions
-    - is approximately twice as fast as gzip -d
-    - also provides Unix uncompress functionality, again twice as fast
-
-gzappend.c
-    append to a gzip file
-    - illustrates the use of the Z_BLOCK flush parameter for inflate()
-    - illustrates the use of deflatePrime() to start at any bit
-
-gzjoin.c
-    join gzip files without recalculating the crc or recompressing
-    - illustrates the use of the Z_BLOCK flush parameter for inflate()
-    - illustrates the use of crc32_combine()
-
-gzlog.c
-gzlog.h
-    efficiently and robustly maintain a message log file in gzip format
-    - illustrates use of raw deflate, Z_PARTIAL_FLUSH, deflatePrime(),
-      and deflateSetDictionary()
-    - illustrates use of a gzip header extra field
-
-zlib_how.html
-    painfully comprehensive description of zpipe.c (see below)
-    - describes in excruciating detail the use of deflate() and inflate()
-
-zpipe.c
-    reads and writes zlib streams from stdin to stdout
-    - illustrates the proper use of deflate() and inflate()
-    - deeply commented in zlib_how.html (see above)
-
-zran.c
-    index a zlib or gzip stream and randomly access it
-    - illustrates the use of Z_BLOCK, inflatePrime(), and
-      inflateSetDictionary() to provide random access
diff -Nbaur gcc-4.8.1/zlib/examples/zlib_how.html gcc-4.8.1-ppc/zlib/examples/zlib_how.html
--- gcc-4.8.1/zlib/examples/zlib_how.html	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/examples/zlib_how.html	1970-01-01 01:00:00.000000000 +0100
@@ -1,545 +0,0 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
-  "http://www.w3.org/TR/REC-html40/loose.dtd">
-<html>
-<head>
-<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
-<title>zlib Usage Example</title>
-<!--  Copyright (c) 2004, 2005 Mark Adler.  -->
-</head>
-<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#00A000">
-<h2 align="center"> zlib Usage Example </h2>
-We often get questions about how the <tt>deflate()</tt> and <tt>inflate()</tt> functions should be used.
-Users wonder when they should provide more input, when they should use more output,
-what to do with a <tt>Z_BUF_ERROR</tt>, how to make sure the process terminates properly, and
-so on.  So for those who have read <tt>zlib.h</tt> (a few times), and
-would like further edification, below is an annotated example in C of simple routines to compress and decompress
-from an input file to an output file using <tt>deflate()</tt> and <tt>inflate()</tt> respectively.  The
-annotations are interspersed between lines of the code.  So please read between the lines.
-We hope this helps explain some of the intricacies of <em>zlib</em>.
-<p>
-Without further adieu, here is the program <a href="zpipe.c"><tt>zpipe.c</tt></a>:
-<pre><b>
-/* zpipe.c: example of proper use of zlib's inflate() and deflate()
-   Not copyrighted -- provided to the public domain
-   Version 1.4  11 December 2005  Mark Adler */
-
-/* Version history:
-   1.0  30 Oct 2004  First version
-   1.1   8 Nov 2004  Add void casting for unused return values
-                     Use switch statement for inflate() return values
-   1.2   9 Nov 2004  Add assertions to document zlib guarantees
-   1.3   6 Apr 2005  Remove incorrect assertion in inf()
-   1.4  11 Dec 2005  Add hack to avoid MSDOS end-of-line conversions
-                     Avoid some compiler warnings for input and output buffers
- */
-</b></pre><!-- -->
-We now include the header files for the required definitions.  From
-<tt>stdio.h</tt> we use <tt>fopen()</tt>, <tt>fread()</tt>, <tt>fwrite()</tt>,
-<tt>feof()</tt>, <tt>ferror()</tt>, and <tt>fclose()</tt> for file i/o, and
-<tt>fputs()</tt> for error messages.  From <tt>string.h</tt> we use
-<tt>strcmp()</tt> for command line argument processing.
-From <tt>assert.h</tt> we use the <tt>assert()</tt> macro.
-From <tt>zlib.h</tt>
-we use the basic compression functions <tt>deflateInit()</tt>,
-<tt>deflate()</tt>, and <tt>deflateEnd()</tt>, and the basic decompression
-functions <tt>inflateInit()</tt>, <tt>inflate()</tt>, and
-<tt>inflateEnd()</tt>.
-<pre><b>
-#include &lt;stdio.h&gt;
-#include &lt;string.h&gt;
-#include &lt;assert.h&gt;
-#include "zlib.h"
-</b></pre><!-- -->
-This is an ugly hack required to avoid corruption of the input and output data on
-Windows/MS-DOS systems.  Without this, those systems would assume that the input and output
-files are text, and try to convert the end-of-line characters from one standard to
-another.  That would corrupt binary data, and in particular would render the compressed data unusable.
-This sets the input and output to binary which suppresses the end-of-line conversions.
-<tt>SET_BINARY_MODE()</tt> will be used later on <tt>stdin</tt> and <tt>stdout</tt>, at the beginning of <tt>main()</tt>.
-<pre><b>
-#if defined(MSDOS) || defined(OS2) || defined(WIN32) || defined(__CYGWIN__)
-#  include &lt;fcntl.h&gt;
-#  include &lt;io.h&gt;
-#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
-#else
-#  define SET_BINARY_MODE(file)
-#endif
-</b></pre><!-- -->
-<tt>CHUNK</tt> is simply the buffer size for feeding data to and pulling data
-from the <em>zlib</em> routines.  Larger buffer sizes would be more efficient,
-especially for <tt>inflate()</tt>.  If the memory is available, buffers sizes
-on the order of 128K or 256K bytes should be used.
-<pre><b>
-#define CHUNK 16384
-</b></pre><!-- -->
-The <tt>def()</tt> routine compresses data from an input file to an output file.  The output data
-will be in the <em>zlib</em> format, which is different from the <em>gzip</em> or <em>zip</em>
-formats.  The <em>zlib</em> format has a very small header of only two bytes to identify it as
-a <em>zlib</em> stream and to provide decoding information, and a four-byte trailer with a fast
-check value to verify the integrity of the uncompressed data after decoding.
-<pre><b>
-/* Compress from file source to file dest until EOF on source.
-   def() returns Z_OK on success, Z_MEM_ERROR if memory could not be
-   allocated for processing, Z_STREAM_ERROR if an invalid compression
-   level is supplied, Z_VERSION_ERROR if the version of zlib.h and the
-   version of the library linked do not match, or Z_ERRNO if there is
-   an error reading or writing the files. */
-int def(FILE *source, FILE *dest, int level)
-{
-</b></pre>
-Here are the local variables for <tt>def()</tt>.  <tt>ret</tt> will be used for <em>zlib</em>
-return codes.  <tt>flush</tt> will keep track of the current flushing state for <tt>deflate()</tt>,
-which is either no flushing, or flush to completion after the end of the input file is reached.
-<tt>have</tt> is the amount of data returned from <tt>deflate()</tt>.  The <tt>strm</tt> structure
-is used to pass information to and from the <em>zlib</em> routines, and to maintain the
-<tt>deflate()</tt> state.  <tt>in</tt> and <tt>out</tt> are the input and output buffers for
-<tt>deflate()</tt>.
-<pre><b>
-    int ret, flush;
-    unsigned have;
-    z_stream strm;
-    unsigned char in[CHUNK];
-    unsigned char out[CHUNK];
-</b></pre><!-- -->
-The first thing we do is to initialize the <em>zlib</em> state for compression using
-<tt>deflateInit()</tt>.  This must be done before the first use of <tt>deflate()</tt>.
-The <tt>zalloc</tt>, <tt>zfree</tt>, and <tt>opaque</tt> fields in the <tt>strm</tt>
-structure must be initialized before calling <tt>deflateInit()</tt>.  Here they are
-set to the <em>zlib</em> constant <tt>Z_NULL</tt> to request that <em>zlib</em> use
-the default memory allocation routines.  An application may also choose to provide
-custom memory allocation routines here.  <tt>deflateInit()</tt> will allocate on the
-order of 256K bytes for the internal state.
-(See <a href="zlib_tech.html"><em>zlib Technical Details</em></a>.)
-<p>
-<tt>deflateInit()</tt> is called with a pointer to the structure to be initialized and
-the compression level, which is an integer in the range of -1 to 9.  Lower compression
-levels result in faster execution, but less compression.  Higher levels result in
-greater compression, but slower execution.  The <em>zlib</em> constant Z_DEFAULT_COMPRESSION,
-equal to -1,
-provides a good compromise between compression and speed and is equivalent to level 6.
-Level 0 actually does no compression at all, and in fact expands the data slightly to produce
-the <em>zlib</em> format (it is not a byte-for-byte copy of the input).
-More advanced applications of <em>zlib</em>
-may use <tt>deflateInit2()</tt> here instead.  Such an application may want to reduce how
-much memory will be used, at some price in compression.  Or it may need to request a
-<em>gzip</em> header and trailer instead of a <em>zlib</em> header and trailer, or raw
-encoding with no header or trailer at all.
-<p>
-We must check the return value of <tt>deflateInit()</tt> against the <em>zlib</em> constant
-<tt>Z_OK</tt> to make sure that it was able to
-allocate memory for the internal state, and that the provided arguments were valid.
-<tt>deflateInit()</tt> will also check that the version of <em>zlib</em> that the <tt>zlib.h</tt>
-file came from matches the version of <em>zlib</em> actually linked with the program.  This
-is especially important for environments in which <em>zlib</em> is a shared library.
-<p>
-Note that an application can initialize multiple, independent <em>zlib</em> streams, which can
-operate in parallel.  The state information maintained in the structure allows the <em>zlib</em>
-routines to be reentrant.
-<pre><b>
-    /* allocate deflate state */
-    strm.zalloc = Z_NULL;
-    strm.zfree = Z_NULL;
-    strm.opaque = Z_NULL;
-    ret = deflateInit(&amp;strm, level);
-    if (ret != Z_OK)
-        return ret;
-</b></pre><!-- -->
-With the pleasantries out of the way, now we can get down to business.  The outer <tt>do</tt>-loop
-reads all of the input file and exits at the bottom of the loop once end-of-file is reached.
-This loop contains the only call of <tt>deflate()</tt>.  So we must make sure that all of the
-input data has been processed and that all of the output data has been generated and consumed
-before we fall out of the loop at the bottom.
-<pre><b>
-    /* compress until end of file */
-    do {
-</b></pre>
-We start off by reading data from the input file.  The number of bytes read is put directly
-into <tt>avail_in</tt>, and a pointer to those bytes is put into <tt>next_in</tt>.  We also
-check to see if end-of-file on the input has been reached.  If we are at the end of file, then <tt>flush</tt> is set to the
-<em>zlib</em> constant <tt>Z_FINISH</tt>, which is later passed to <tt>deflate()</tt> to
-indicate that this is the last chunk of input data to compress.  We need to use <tt>feof()</tt>
-to check for end-of-file as opposed to seeing if fewer than <tt>CHUNK</tt> bytes have been read.  The
-reason is that if the input file length is an exact multiple of <tt>CHUNK</tt>, we will miss
-the fact that we got to the end-of-file, and not know to tell <tt>deflate()</tt> to finish
-up the compressed stream.  If we are not yet at the end of the input, then the <em>zlib</em>
-constant <tt>Z_NO_FLUSH</tt> will be passed to <tt>deflate</tt> to indicate that we are still
-in the middle of the uncompressed data.
-<p>
-If there is an error in reading from the input file, the process is aborted with
-<tt>deflateEnd()</tt> being called to free the allocated <em>zlib</em> state before returning
-the error.  We wouldn't want a memory leak, now would we?  <tt>deflateEnd()</tt> can be called
-at any time after the state has been initialized.  Once that's done, <tt>deflateInit()</tt> (or
-<tt>deflateInit2()</tt>) would have to be called to start a new compression process.  There is
-no point here in checking the <tt>deflateEnd()</tt> return code.  The deallocation can't fail.
-<pre><b>
-        strm.avail_in = fread(in, 1, CHUNK, source);
-        if (ferror(source)) {
-            (void)deflateEnd(&amp;strm);
-            return Z_ERRNO;
-        }
-        flush = feof(source) ? Z_FINISH : Z_NO_FLUSH;
-        strm.next_in = in;
-</b></pre><!-- -->
-The inner <tt>do</tt>-loop passes our chunk of input data to <tt>deflate()</tt>, and then
-keeps calling <tt>deflate()</tt> until it is done producing output.  Once there is no more
-new output, <tt>deflate()</tt> is guaranteed to have consumed all of the input, i.e.,
-<tt>avail_in</tt> will be zero.
-<pre><b>
-        /* run deflate() on input until output buffer not full, finish
-           compression if all of source has been read in */
-        do {
-</b></pre>
-Output space is provided to <tt>deflate()</tt> by setting <tt>avail_out</tt> to the number
-of available output bytes and <tt>next_out</tt> to a pointer to that space.
-<pre><b>
-            strm.avail_out = CHUNK;
-            strm.next_out = out;
-</b></pre>
-Now we call the compression engine itself, <tt>deflate()</tt>.  It takes as many of the
-<tt>avail_in</tt> bytes at <tt>next_in</tt> as it can process, and writes as many as
-<tt>avail_out</tt> bytes to <tt>next_out</tt>.  Those counters and pointers are then
-updated past the input data consumed and the output data written.  It is the amount of
-output space available that may limit how much input is consumed.
-Hence the inner loop to make sure that
-all of the input is consumed by providing more output space each time.  Since <tt>avail_in</tt>
-and <tt>next_in</tt> are updated by <tt>deflate()</tt>, we don't have to mess with those
-between <tt>deflate()</tt> calls until it's all used up.
-<p>
-The parameters to <tt>deflate()</tt> are a pointer to the <tt>strm</tt> structure containing
-the input and output information and the internal compression engine state, and a parameter
-indicating whether and how to flush data to the output.  Normally <tt>deflate</tt> will consume
-several K bytes of input data before producing any output (except for the header), in order
-to accumulate statistics on the data for optimum compression.  It will then put out a burst of
-compressed data, and proceed to consume more input before the next burst.  Eventually,
-<tt>deflate()</tt>
-must be told to terminate the stream, complete the compression with provided input data, and
-write out the trailer check value.  <tt>deflate()</tt> will continue to compress normally as long
-as the flush parameter is <tt>Z_NO_FLUSH</tt>.  Once the <tt>Z_FINISH</tt> parameter is provided,
-<tt>deflate()</tt> will begin to complete the compressed output stream.  However depending on how
-much output space is provided, <tt>deflate()</tt> may have to be called several times until it
-has provided the complete compressed stream, even after it has consumed all of the input.  The flush
-parameter must continue to be <tt>Z_FINISH</tt> for those subsequent calls.
-<p>
-There are other values of the flush parameter that are used in more advanced applications.  You can
-force <tt>deflate()</tt> to produce a burst of output that encodes all of the input data provided
-so far, even if it wouldn't have otherwise, for example to control data latency on a link with
-compressed data.  You can also ask that <tt>deflate()</tt> do that as well as erase any history up to
-that point so that what follows can be decompressed independently, for example for random access
-applications.  Both requests will degrade compression by an amount depending on how often such
-requests are made.
-<p>
-<tt>deflate()</tt> has a return value that can indicate errors, yet we do not check it here.  Why
-not?  Well, it turns out that <tt>deflate()</tt> can do no wrong here.  Let's go through
-<tt>deflate()</tt>'s return values and dispense with them one by one.  The possible values are
-<tt>Z_OK</tt>, <tt>Z_STREAM_END</tt>, <tt>Z_STREAM_ERROR</tt>, or <tt>Z_BUF_ERROR</tt>.  <tt>Z_OK</tt>
-is, well, ok.  <tt>Z_STREAM_END</tt> is also ok and will be returned for the last call of
-<tt>deflate()</tt>.  This is already guaranteed by calling <tt>deflate()</tt> with <tt>Z_FINISH</tt>
-until it has no more output.  <tt>Z_STREAM_ERROR</tt> is only possible if the stream is not
-initialized properly, but we did initialize it properly.  There is no harm in checking for
-<tt>Z_STREAM_ERROR</tt> here, for example to check for the possibility that some
-other part of the application inadvertently clobbered the memory containing the <em>zlib</em> state.
-<tt>Z_BUF_ERROR</tt> will be explained further below, but
-suffice it to say that this is simply an indication that <tt>deflate()</tt> could not consume
-more input or produce more output.  <tt>deflate()</tt> can be called again with more output space
-or more available input, which it will be in this code.
-<pre><b>
-            ret = deflate(&amp;strm, flush);    /* no bad return value */
-            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */
-</b></pre>
-Now we compute how much output <tt>deflate()</tt> provided on the last call, which is the
-difference between how much space was provided before the call, and how much output space
-is still available after the call.  Then that data, if any, is written to the output file.
-We can then reuse the output buffer for the next call of <tt>deflate()</tt>.  Again if there
-is a file i/o error, we call <tt>deflateEnd()</tt> before returning to avoid a memory leak.
-<pre><b>
-            have = CHUNK - strm.avail_out;
-            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {
-                (void)deflateEnd(&amp;strm);
-                return Z_ERRNO;
-            }
-</b></pre>
-The inner <tt>do</tt>-loop is repeated until the last <tt>deflate()</tt> call fails to fill the
-provided output buffer.  Then we know that <tt>deflate()</tt> has done as much as it can with
-the provided input, and that all of that input has been consumed.  We can then fall out of this
-loop and reuse the input buffer.
-<p>
-The way we tell that <tt>deflate()</tt> has no more output is by seeing that it did not fill
-the output buffer, leaving <tt>avail_out</tt> greater than zero.  However suppose that
-<tt>deflate()</tt> has no more output, but just so happened to exactly fill the output buffer!
-<tt>avail_out</tt> is zero, and we can't tell that <tt>deflate()</tt> has done all it can.
-As far as we know, <tt>deflate()</tt>
-has more output for us.  So we call it again.  But now <tt>deflate()</tt> produces no output
-at all, and <tt>avail_out</tt> remains unchanged as <tt>CHUNK</tt>.  That <tt>deflate()</tt> call
-wasn't able to do anything, either consume input or produce output, and so it returns
-<tt>Z_BUF_ERROR</tt>.  (See, I told you I'd cover this later.)  However this is not a problem at
-all.  Now we finally have the desired indication that <tt>deflate()</tt> is really done,
-and so we drop out of the inner loop to provide more input to <tt>deflate()</tt>.
-<p>
-With <tt>flush</tt> set to <tt>Z_FINISH</tt>, this final set of <tt>deflate()</tt> calls will
-complete the output stream.  Once that is done, subsequent calls of <tt>deflate()</tt> would return
-<tt>Z_STREAM_ERROR</tt> if the flush parameter is not <tt>Z_FINISH</tt>, and do no more processing
-until the state is reinitialized.
-<p>
-Some applications of <em>zlib</em> have two loops that call <tt>deflate()</tt>
-instead of the single inner loop we have here.  The first loop would call
-without flushing and feed all of the data to <tt>deflate()</tt>.  The second loop would call
-<tt>deflate()</tt> with no more
-data and the <tt>Z_FINISH</tt> parameter to complete the process.  As you can see from this
-example, that can be avoided by simply keeping track of the current flush state.
-<pre><b>
-        } while (strm.avail_out == 0);
-        assert(strm.avail_in == 0);     /* all input will be used */
-</b></pre><!-- -->
-Now we check to see if we have already processed all of the input file.  That information was
-saved in the <tt>flush</tt> variable, so we see if that was set to <tt>Z_FINISH</tt>.  If so,
-then we're done and we fall out of the outer loop.  We're guaranteed to get <tt>Z_STREAM_END</tt>
-from the last <tt>deflate()</tt> call, since we ran it until the last chunk of input was
-consumed and all of the output was generated.
-<pre><b>
-        /* done when last data in file processed */
-    } while (flush != Z_FINISH);
-    assert(ret == Z_STREAM_END);        /* stream will be complete */
-</b></pre><!-- -->
-The process is complete, but we still need to deallocate the state to avoid a memory leak
-(or rather more like a memory hemorrhage if you didn't do this).  Then
-finally we can return with a happy return value.
-<pre><b>
-    /* clean up and return */
-    (void)deflateEnd(&amp;strm);
-    return Z_OK;
-}
-</b></pre><!-- -->
-Now we do the same thing for decompression in the <tt>inf()</tt> routine. <tt>inf()</tt>
-decompresses what is hopefully a valid <em>zlib</em> stream from the input file and writes the
-uncompressed data to the output file.  Much of the discussion above for <tt>def()</tt>
-applies to <tt>inf()</tt> as well, so the discussion here will focus on the differences between
-the two.
-<pre><b>
-/* Decompress from file source to file dest until stream ends or EOF.
-   inf() returns Z_OK on success, Z_MEM_ERROR if memory could not be
-   allocated for processing, Z_DATA_ERROR if the deflate data is
-   invalid or incomplete, Z_VERSION_ERROR if the version of zlib.h and
-   the version of the library linked do not match, or Z_ERRNO if there
-   is an error reading or writing the files. */
-int inf(FILE *source, FILE *dest)
-{
-</b></pre>
-The local variables have the same functionality as they do for <tt>def()</tt>.  The
-only difference is that there is no <tt>flush</tt> variable, since <tt>inflate()</tt>
-can tell from the <em>zlib</em> stream itself when the stream is complete.
-<pre><b>
-    int ret;
-    unsigned have;
-    z_stream strm;
-    unsigned char in[CHUNK];
-    unsigned char out[CHUNK];
-</b></pre><!-- -->
-The initialization of the state is the same, except that there is no compression level,
-of course, and two more elements of the structure are initialized.  <tt>avail_in</tt>
-and <tt>next_in</tt> must be initialized before calling <tt>inflateInit()</tt>.  This
-is because the application has the option to provide the start of the zlib stream in
-order for <tt>inflateInit()</tt> to have access to information about the compression
-method to aid in memory allocation.  In the current implementation of <em>zlib</em>
-(up through versions 1.2.x), the method-dependent memory allocations are deferred to the first call of
-<tt>inflate()</tt> anyway.  However those fields must be initialized since later versions
-of <em>zlib</em> that provide more compression methods may take advantage of this interface.
-In any case, no decompression is performed by <tt>inflateInit()</tt>, so the
-<tt>avail_out</tt> and <tt>next_out</tt> fields do not need to be initialized before calling.
-<p>
-Here <tt>avail_in</tt> is set to zero and <tt>next_in</tt> is set to <tt>Z_NULL</tt> to
-indicate that no input data is being provided.
-<pre><b>
-    /* allocate inflate state */
-    strm.zalloc = Z_NULL;
-    strm.zfree = Z_NULL;
-    strm.opaque = Z_NULL;
-    strm.avail_in = 0;
-    strm.next_in = Z_NULL;
-    ret = inflateInit(&amp;strm);
-    if (ret != Z_OK)
-        return ret;
-</b></pre><!-- -->
-The outer <tt>do</tt>-loop decompresses input until <tt>inflate()</tt> indicates
-that it has reached the end of the compressed data and has produced all of the uncompressed
-output.  This is in contrast to <tt>def()</tt> which processes all of the input file.
-If end-of-file is reached before the compressed data self-terminates, then the compressed
-data is incomplete and an error is returned.
-<pre><b>
-    /* decompress until deflate stream ends or end of file */
-    do {
-</b></pre>
-We read input data and set the <tt>strm</tt> structure accordingly.  If we've reached the
-end of the input file, then we leave the outer loop and report an error, since the
-compressed data is incomplete.  Note that we may read more data than is eventually consumed
-by <tt>inflate()</tt>, if the input file continues past the <em>zlib</em> stream.
-For applications where <em>zlib</em> streams are embedded in other data, this routine would
-need to be modified to return the unused data, or at least indicate how much of the input
-data was not used, so the application would know where to pick up after the <em>zlib</em> stream.
-<pre><b>
-        strm.avail_in = fread(in, 1, CHUNK, source);
-        if (ferror(source)) {
-            (void)inflateEnd(&amp;strm);
-            return Z_ERRNO;
-        }
-        if (strm.avail_in == 0)
-            break;
-        strm.next_in = in;
-</b></pre><!-- -->
-The inner <tt>do</tt>-loop has the same function it did in <tt>def()</tt>, which is to
-keep calling <tt>inflate()</tt> until has generated all of the output it can with the
-provided input.
-<pre><b>
-        /* run inflate() on input until output buffer not full */
-        do {
-</b></pre>
-Just like in <tt>def()</tt>, the same output space is provided for each call of <tt>inflate()</tt>.
-<pre><b>
-            strm.avail_out = CHUNK;
-            strm.next_out = out;
-</b></pre>
-Now we run the decompression engine itself.  There is no need to adjust the flush parameter, since
-the <em>zlib</em> format is self-terminating. The main difference here is that there are
-return values that we need to pay attention to.  <tt>Z_DATA_ERROR</tt>
-indicates that <tt>inflate()</tt> detected an error in the <em>zlib</em> compressed data format,
-which means that either the data is not a <em>zlib</em> stream to begin with, or that the data was
-corrupted somewhere along the way since it was compressed.  The other error to be processed is
-<tt>Z_MEM_ERROR</tt>, which can occur since memory allocation is deferred until <tt>inflate()</tt>
-needs it, unlike <tt>deflate()</tt>, whose memory is allocated at the start by <tt>deflateInit()</tt>.
-<p>
-Advanced applications may use
-<tt>deflateSetDictionary()</tt> to prime <tt>deflate()</tt> with a set of likely data to improve the
-first 32K or so of compression.  This is noted in the <em>zlib</em> header, so <tt>inflate()</tt>
-requests that that dictionary be provided before it can start to decompress.  Without the dictionary,
-correct decompression is not possible.  For this routine, we have no idea what the dictionary is,
-so the <tt>Z_NEED_DICT</tt> indication is converted to a <tt>Z_DATA_ERROR</tt>.
-<p>
-<tt>inflate()</tt> can also return <tt>Z_STREAM_ERROR</tt>, which should not be possible here,
-but could be checked for as noted above for <tt>def()</tt>.  <tt>Z_BUF_ERROR</tt> does not need to be
-checked for here, for the same reasons noted for <tt>def()</tt>.  <tt>Z_STREAM_END</tt> will be
-checked for later.
-<pre><b>
-            ret = inflate(&amp;strm, Z_NO_FLUSH);
-            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */
-            switch (ret) {
-            case Z_NEED_DICT:
-                ret = Z_DATA_ERROR;     /* and fall through */
-            case Z_DATA_ERROR:
-            case Z_MEM_ERROR:
-                (void)inflateEnd(&amp;strm);
-                return ret;
-            }
-</b></pre>
-The output of <tt>inflate()</tt> is handled identically to that of <tt>deflate()</tt>.
-<pre><b>
-            have = CHUNK - strm.avail_out;
-            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {
-                (void)inflateEnd(&amp;strm);
-                return Z_ERRNO;
-            }
-</b></pre>
-The inner <tt>do</tt>-loop ends when <tt>inflate()</tt> has no more output as indicated
-by not filling the output buffer, just as for <tt>deflate()</tt>.  In this case, we cannot
-assert that <tt>strm.avail_in</tt> will be zero, since the deflate stream may end before the file
-does.
-<pre><b>
-        } while (strm.avail_out == 0);
-</b></pre><!-- -->
-The outer <tt>do</tt>-loop ends when <tt>inflate()</tt> reports that it has reached the
-end of the input <em>zlib</em> stream, has completed the decompression and integrity
-check, and has provided all of the output.  This is indicated by the <tt>inflate()</tt>
-return value <tt>Z_STREAM_END</tt>.  The inner loop is guaranteed to leave <tt>ret</tt>
-equal to <tt>Z_STREAM_END</tt> if the last chunk of the input file read contained the end
-of the <em>zlib</em> stream.  So if the return value is not <tt>Z_STREAM_END</tt>, the
-loop continues to read more input.
-<pre><b>
-        /* done when inflate() says it's done */
-    } while (ret != Z_STREAM_END);
-</b></pre><!-- -->
-At this point, decompression successfully completed, or we broke out of the loop due to no
-more data being available from the input file.  If the last <tt>inflate()</tt> return value
-is not <tt>Z_STREAM_END</tt>, then the <em>zlib</em> stream was incomplete and a data error
-is returned.  Otherwise, we return with a happy return value.  Of course, <tt>inflateEnd()</tt>
-is called first to avoid a memory leak.
-<pre><b>
-    /* clean up and return */
-    (void)inflateEnd(&amp;strm);
-    return ret == Z_STREAM_END ? Z_OK : Z_DATA_ERROR;
-}
-</b></pre><!-- -->
-That ends the routines that directly use <em>zlib</em>.  The following routines make this
-a command-line program by running data through the above routines from <tt>stdin</tt> to
-<tt>stdout</tt>, and handling any errors reported by <tt>def()</tt> or <tt>inf()</tt>.
-<p>
-<tt>zerr()</tt> is used to interpret the possible error codes from <tt>def()</tt>
-and <tt>inf()</tt>, as detailed in their comments above, and print out an error message.
-Note that these are only a subset of the possible return values from <tt>deflate()</tt>
-and <tt>inflate()</tt>.
-<pre><b>
-/* report a zlib or i/o error */
-void zerr(int ret)
-{
-    fputs("zpipe: ", stderr);
-    switch (ret) {
-    case Z_ERRNO:
-        if (ferror(stdin))
-            fputs("error reading stdin\n", stderr);
-        if (ferror(stdout))
-            fputs("error writing stdout\n", stderr);
-        break;
-    case Z_STREAM_ERROR:
-        fputs("invalid compression level\n", stderr);
-        break;
-    case Z_DATA_ERROR:
-        fputs("invalid or incomplete deflate data\n", stderr);
-        break;
-    case Z_MEM_ERROR:
-        fputs("out of memory\n", stderr);
-        break;
-    case Z_VERSION_ERROR:
-        fputs("zlib version mismatch!\n", stderr);
-    }
-}
-</b></pre><!-- -->
-Here is the <tt>main()</tt> routine used to test <tt>def()</tt> and <tt>inf()</tt>.  The
-<tt>zpipe</tt> command is simply a compression pipe from <tt>stdin</tt> to <tt>stdout</tt>, if
-no arguments are given, or it is a decompression pipe if <tt>zpipe -d</tt> is used.  If any other
-arguments are provided, no compression or decompression is performed.  Instead a usage
-message is displayed.  Examples are <tt>zpipe < foo.txt > foo.txt.z</tt> to compress, and
-<tt>zpipe -d < foo.txt.z > foo.txt</tt> to decompress.
-<pre><b>
-/* compress or decompress from stdin to stdout */
-int main(int argc, char **argv)
-{
-    int ret;
-
-    /* avoid end-of-line conversions */
-    SET_BINARY_MODE(stdin);
-    SET_BINARY_MODE(stdout);
-
-    /* do compression if no arguments */
-    if (argc == 1) {
-        ret = def(stdin, stdout, Z_DEFAULT_COMPRESSION);
-        if (ret != Z_OK)
-            zerr(ret);
-        return ret;
-    }
-
-    /* do decompression if -d specified */
-    else if (argc == 2 &amp;&amp; strcmp(argv[1], "-d") == 0) {
-        ret = inf(stdin, stdout);
-        if (ret != Z_OK)
-            zerr(ret);
-        return ret;
-    }
-
-    /* otherwise, report usage */
-    else {
-        fputs("zpipe usage: zpipe [-d] &lt; source &gt; dest\n", stderr);
-        return 1;
-    }
-}
-</b></pre>
-<hr>
-<i>Copyright (c) 2004, 2005 by Mark Adler<br>Last modified 11 December 2005</i>
-</body>
-</html>
diff -Nbaur gcc-4.8.1/zlib/examples/zpipe.c gcc-4.8.1-ppc/zlib/examples/zpipe.c
--- gcc-4.8.1/zlib/examples/zpipe.c	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/examples/zpipe.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,205 +0,0 @@
-/* zpipe.c: example of proper use of zlib's inflate() and deflate()
-   Not copyrighted -- provided to the public domain
-   Version 1.4  11 December 2005  Mark Adler */
-
-/* Version history:
-   1.0  30 Oct 2004  First version
-   1.1   8 Nov 2004  Add void casting for unused return values
-                     Use switch statement for inflate() return values
-   1.2   9 Nov 2004  Add assertions to document zlib guarantees
-   1.3   6 Apr 2005  Remove incorrect assertion in inf()
-   1.4  11 Dec 2005  Add hack to avoid MSDOS end-of-line conversions
-                     Avoid some compiler warnings for input and output buffers
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <assert.h>
-#include "zlib.h"
-
-#if defined(MSDOS) || defined(OS2) || defined(WIN32) || defined(__CYGWIN__)
-#  include <fcntl.h>
-#  include <io.h>
-#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
-#else
-#  define SET_BINARY_MODE(file)
-#endif
-
-#define CHUNK 16384
-
-/* Compress from file source to file dest until EOF on source.
-   def() returns Z_OK on success, Z_MEM_ERROR if memory could not be
-   allocated for processing, Z_STREAM_ERROR if an invalid compression
-   level is supplied, Z_VERSION_ERROR if the version of zlib.h and the
-   version of the library linked do not match, or Z_ERRNO if there is
-   an error reading or writing the files. */
-int def(FILE *source, FILE *dest, int level)
-{
-    int ret, flush;
-    unsigned have;
-    z_stream strm;
-    unsigned char in[CHUNK];
-    unsigned char out[CHUNK];
-
-    /* allocate deflate state */
-    strm.zalloc = Z_NULL;
-    strm.zfree = Z_NULL;
-    strm.opaque = Z_NULL;
-    ret = deflateInit(&strm, level);
-    if (ret != Z_OK)
-        return ret;
-
-    /* compress until end of file */
-    do {
-        strm.avail_in = fread(in, 1, CHUNK, source);
-        if (ferror(source)) {
-            (void)deflateEnd(&strm);
-            return Z_ERRNO;
-        }
-        flush = feof(source) ? Z_FINISH : Z_NO_FLUSH;
-        strm.next_in = in;
-
-        /* run deflate() on input until output buffer not full, finish
-           compression if all of source has been read in */
-        do {
-            strm.avail_out = CHUNK;
-            strm.next_out = out;
-            ret = deflate(&strm, flush);    /* no bad return value */
-            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */
-            have = CHUNK - strm.avail_out;
-            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {
-                (void)deflateEnd(&strm);
-                return Z_ERRNO;
-            }
-        } while (strm.avail_out == 0);
-        assert(strm.avail_in == 0);     /* all input will be used */
-
-        /* done when last data in file processed */
-    } while (flush != Z_FINISH);
-    assert(ret == Z_STREAM_END);        /* stream will be complete */
-
-    /* clean up and return */
-    (void)deflateEnd(&strm);
-    return Z_OK;
-}
-
-/* Decompress from file source to file dest until stream ends or EOF.
-   inf() returns Z_OK on success, Z_MEM_ERROR if memory could not be
-   allocated for processing, Z_DATA_ERROR if the deflate data is
-   invalid or incomplete, Z_VERSION_ERROR if the version of zlib.h and
-   the version of the library linked do not match, or Z_ERRNO if there
-   is an error reading or writing the files. */
-int inf(FILE *source, FILE *dest)
-{
-    int ret;
-    unsigned have;
-    z_stream strm;
-    unsigned char in[CHUNK];
-    unsigned char out[CHUNK];
-
-    /* allocate inflate state */
-    strm.zalloc = Z_NULL;
-    strm.zfree = Z_NULL;
-    strm.opaque = Z_NULL;
-    strm.avail_in = 0;
-    strm.next_in = Z_NULL;
-    ret = inflateInit(&strm);
-    if (ret != Z_OK)
-        return ret;
-
-    /* decompress until deflate stream ends or end of file */
-    do {
-        strm.avail_in = fread(in, 1, CHUNK, source);
-        if (ferror(source)) {
-            (void)inflateEnd(&strm);
-            return Z_ERRNO;
-        }
-        if (strm.avail_in == 0)
-            break;
-        strm.next_in = in;
-
-        /* run inflate() on input until output buffer not full */
-        do {
-            strm.avail_out = CHUNK;
-            strm.next_out = out;
-            ret = inflate(&strm, Z_NO_FLUSH);
-            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */
-            switch (ret) {
-            case Z_NEED_DICT:
-                ret = Z_DATA_ERROR;     /* and fall through */
-            case Z_DATA_ERROR:
-            case Z_MEM_ERROR:
-                (void)inflateEnd(&strm);
-                return ret;
-            }
-            have = CHUNK - strm.avail_out;
-            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {
-                (void)inflateEnd(&strm);
-                return Z_ERRNO;
-            }
-        } while (strm.avail_out == 0);
-
-        /* done when inflate() says it's done */
-    } while (ret != Z_STREAM_END);
-
-    /* clean up and return */
-    (void)inflateEnd(&strm);
-    return ret == Z_STREAM_END ? Z_OK : Z_DATA_ERROR;
-}
-
-/* report a zlib or i/o error */
-void zerr(int ret)
-{
-    fputs("zpipe: ", stderr);
-    switch (ret) {
-    case Z_ERRNO:
-        if (ferror(stdin))
-            fputs("error reading stdin\n", stderr);
-        if (ferror(stdout))
-            fputs("error writing stdout\n", stderr);
-        break;
-    case Z_STREAM_ERROR:
-        fputs("invalid compression level\n", stderr);
-        break;
-    case Z_DATA_ERROR:
-        fputs("invalid or incomplete deflate data\n", stderr);
-        break;
-    case Z_MEM_ERROR:
-        fputs("out of memory\n", stderr);
-        break;
-    case Z_VERSION_ERROR:
-        fputs("zlib version mismatch!\n", stderr);
-    }
-}
-
-/* compress or decompress from stdin to stdout */
-int main(int argc, char **argv)
-{
-    int ret;
-
-    /* avoid end-of-line conversions */
-    SET_BINARY_MODE(stdin);
-    SET_BINARY_MODE(stdout);
-
-    /* do compression if no arguments */
-    if (argc == 1) {
-        ret = def(stdin, stdout, Z_DEFAULT_COMPRESSION);
-        if (ret != Z_OK)
-            zerr(ret);
-        return ret;
-    }
-
-    /* do decompression if -d specified */
-    else if (argc == 2 && strcmp(argv[1], "-d") == 0) {
-        ret = inf(stdin, stdout);
-        if (ret != Z_OK)
-            zerr(ret);
-        return ret;
-    }
-
-    /* otherwise, report usage */
-    else {
-        fputs("zpipe usage: zpipe [-d] < source > dest\n", stderr);
-        return 1;
-    }
-}
diff -Nbaur gcc-4.8.1/zlib/examples/zran.c gcc-4.8.1-ppc/zlib/examples/zran.c
--- gcc-4.8.1/zlib/examples/zran.c	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/examples/zran.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,404 +0,0 @@
-/* zran.c -- example of zlib/gzip stream indexing and random access
- * Copyright (C) 2005 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
-   Version 1.0  29 May 2005  Mark Adler */
-
-/* Illustrate the use of Z_BLOCK, inflatePrime(), and inflateSetDictionary()
-   for random access of a compressed file.  A file containing a zlib or gzip
-   stream is provided on the command line.  The compressed stream is decoded in
-   its entirety, and an index built with access points about every SPAN bytes
-   in the uncompressed output.  The compressed file is left open, and can then
-   be read randomly, having to decompress on the average SPAN/2 uncompressed
-   bytes before getting to the desired block of data.
-
-   An access point can be created at the start of any deflate block, by saving
-   the starting file offset and bit of that block, and the 32K bytes of
-   uncompressed data that precede that block.  Also the uncompressed offset of
-   that block is saved to provide a referece for locating a desired starting
-   point in the uncompressed stream.  build_index() works by decompressing the
-   input zlib or gzip stream a block at a time, and at the end of each block
-   deciding if enough uncompressed data has gone by to justify the creation of
-   a new access point.  If so, that point is saved in a data structure that
-   grows as needed to accommodate the points.
-
-   To use the index, an offset in the uncompressed data is provided, for which
-   the latest accees point at or preceding that offset is located in the index.
-   The input file is positioned to the specified location in the index, and if
-   necessary the first few bits of the compressed data is read from the file.
-   inflate is initialized with those bits and the 32K of uncompressed data, and
-   the decompression then proceeds until the desired offset in the file is
-   reached.  Then the decompression continues to read the desired uncompressed
-   data from the file.
-
-   Another approach would be to generate the index on demand.  In that case,
-   requests for random access reads from the compressed data would try to use
-   the index, but if a read far enough past the end of the index is required,
-   then further index entries would be generated and added.
-
-   There is some fair bit of overhead to starting inflation for the random
-   access, mainly copying the 32K byte dictionary.  So if small pieces of the
-   file are being accessed, it would make sense to implement a cache to hold
-   some lookahead and avoid many calls to extract() for small lengths.
-
-   Another way to build an index would be to use inflateCopy().  That would
-   not be constrained to have access points at block boundaries, but requires
-   more memory per access point, and also cannot be saved to file due to the
-   use of pointers in the state.  The approach here allows for storage of the
-   index in a file.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "zlib.h"
-
-#define local static
-
-#define SPAN 1048576L       /* desired distance between access points */
-#define WINSIZE 32768U      /* sliding window size */
-#define CHUNK 16384         /* file input buffer size */
-
-/* access point entry */
-struct point {
-    off_t out;          /* corresponding offset in uncompressed data */
-    off_t in;           /* offset in input file of first full byte */
-    int bits;           /* number of bits (1-7) from byte at in - 1, or 0 */
-    unsigned char window[WINSIZE];  /* preceding 32K of uncompressed data */
-};
-
-/* access point list */
-struct access {
-    int have;           /* number of list entries filled in */
-    int size;           /* number of list entries allocated */
-    struct point *list; /* allocated list */
-};
-
-/* Deallocate an index built by build_index() */
-local void free_index(struct access *index)
-{
-    if (index != NULL) {
-        free(index->list);
-        free(index);
-    }
-}
-
-/* Add an entry to the access point list.  If out of memory, deallocate the
-   existing list and return NULL. */
-local struct access *addpoint(struct access *index, int bits,
-    off_t in, off_t out, unsigned left, unsigned char *window)
-{
-    struct point *next;
-
-    /* if list is empty, create it (start with eight points) */
-    if (index == NULL) {
-        index = malloc(sizeof(struct access));
-        if (index == NULL) return NULL;
-        index->list = malloc(sizeof(struct point) << 3);
-        if (index->list == NULL) {
-            free(index);
-            return NULL;
-        }
-        index->size = 8;
-        index->have = 0;
-    }
-
-    /* if list is full, make it bigger */
-    else if (index->have == index->size) {
-        index->size <<= 1;
-        next = realloc(index->list, sizeof(struct point) * index->size);
-        if (next == NULL) {
-            free_index(index);
-            return NULL;
-        }
-        index->list = next;
-    }
-
-    /* fill in entry and increment how many we have */
-    next = index->list + index->have;
-    next->bits = bits;
-    next->in = in;
-    next->out = out;
-    if (left)
-        memcpy(next->window, window + WINSIZE - left, left);
-    if (left < WINSIZE)
-        memcpy(next->window + left, window, WINSIZE - left);
-    index->have++;
-
-    /* return list, possibly reallocated */
-    return index;
-}
-
-/* Make one entire pass through the compressed stream and build an index, with
-   access points about every span bytes of uncompressed output -- span is
-   chosen to balance the speed of random access against the memory requirements
-   of the list, about 32K bytes per access point.  Note that data after the end
-   of the first zlib or gzip stream in the file is ignored.  build_index()
-   returns the number of access points on success (>= 1), Z_MEM_ERROR for out
-   of memory, Z_DATA_ERROR for an error in the input file, or Z_ERRNO for a
-   file read error.  On success, *built points to the resulting index. */
-local int build_index(FILE *in, off_t span, struct access **built)
-{
-    int ret;
-    off_t totin, totout;        /* our own total counters to avoid 4GB limit */
-    off_t last;                 /* totout value of last access point */
-    struct access *index;       /* access points being generated */
-    z_stream strm;
-    unsigned char input[CHUNK];
-    unsigned char window[WINSIZE];
-
-    /* initialize inflate */
-    strm.zalloc = Z_NULL;
-    strm.zfree = Z_NULL;
-    strm.opaque = Z_NULL;
-    strm.avail_in = 0;
-    strm.next_in = Z_NULL;
-    ret = inflateInit2(&strm, 47);      /* automatic zlib or gzip decoding */
-    if (ret != Z_OK)
-        return ret;
-
-    /* inflate the input, maintain a sliding window, and build an index -- this
-       also validates the integrity of the compressed data using the check
-       information at the end of the gzip or zlib stream */
-    totin = totout = last = 0;
-    index = NULL;               /* will be allocated by first addpoint() */
-    strm.avail_out = 0;
-    do {
-        /* get some compressed data from input file */
-        strm.avail_in = fread(input, 1, CHUNK, in);
-        if (ferror(in)) {
-            ret = Z_ERRNO;
-            goto build_index_error;
-        }
-        if (strm.avail_in == 0) {
-            ret = Z_DATA_ERROR;
-            goto build_index_error;
-        }
-        strm.next_in = input;
-
-        /* process all of that, or until end of stream */
-        do {
-            /* reset sliding window if necessary */
-            if (strm.avail_out == 0) {
-                strm.avail_out = WINSIZE;
-                strm.next_out = window;
-            }
-
-            /* inflate until out of input, output, or at end of block --
-               update the total input and output counters */
-            totin += strm.avail_in;
-            totout += strm.avail_out;
-            ret = inflate(&strm, Z_BLOCK);      /* return at end of block */
-            totin -= strm.avail_in;
-            totout -= strm.avail_out;
-            if (ret == Z_NEED_DICT)
-                ret = Z_DATA_ERROR;
-            if (ret == Z_MEM_ERROR || ret == Z_DATA_ERROR)
-                goto build_index_error;
-            if (ret == Z_STREAM_END)
-                break;
-
-            /* if at end of block, consider adding an index entry (note that if
-               data_type indicates an end-of-block, then all of the
-               uncompressed data from that block has been delivered, and none
-               of the compressed data after that block has been consumed,
-               except for up to seven bits) -- the totout == 0 provides an
-               entry point after the zlib or gzip header, and assures that the
-               index always has at least one access point; we avoid creating an
-               access point after the last block by checking bit 6 of data_type
-             */
-            if ((strm.data_type & 128) && !(strm.data_type & 64) &&
-                (totout == 0 || totout - last > span)) {
-                index = addpoint(index, strm.data_type & 7, totin,
-                                 totout, strm.avail_out, window);
-                if (index == NULL) {
-                    ret = Z_MEM_ERROR;
-                    goto build_index_error;
-                }
-                last = totout;
-            }
-        } while (strm.avail_in != 0);
-    } while (ret != Z_STREAM_END);
-
-    /* clean up and return index (release unused entries in list) */
-    (void)inflateEnd(&strm);
-    index = realloc(index, sizeof(struct point) * index->have);
-    index->size = index->have;
-    *built = index;
-    return index->size;
-
-    /* return error */
-  build_index_error:
-    (void)inflateEnd(&strm);
-    if (index != NULL)
-        free_index(index);
-    return ret;
-}
-
-/* Use the index to read len bytes from offset into buf, return bytes read or
-   negative for error (Z_DATA_ERROR or Z_MEM_ERROR).  If data is requested past
-   the end of the uncompressed data, then extract() will return a value less
-   than len, indicating how much as actually read into buf.  This function
-   should not return a data error unless the file was modified since the index
-   was generated.  extract() may also return Z_ERRNO if there is an error on
-   reading or seeking the input file. */
-local int extract(FILE *in, struct access *index, off_t offset,
-                  unsigned char *buf, int len)
-{
-    int ret, skip;
-    z_stream strm;
-    struct point *here;
-    unsigned char input[CHUNK];
-    unsigned char discard[WINSIZE];
-
-    /* proceed only if something reasonable to do */
-    if (len < 0)
-        return 0;
-
-    /* find where in stream to start */
-    here = index->list;
-    ret = index->have;
-    while (--ret && here[1].out <= offset)
-        here++;
-
-    /* initialize file and inflate state to start there */
-    strm.zalloc = Z_NULL;
-    strm.zfree = Z_NULL;
-    strm.opaque = Z_NULL;
-    strm.avail_in = 0;
-    strm.next_in = Z_NULL;
-    ret = inflateInit2(&strm, -15);         /* raw inflate */
-    if (ret != Z_OK)
-        return ret;
-    ret = fseeko(in, here->in - (here->bits ? 1 : 0), SEEK_SET);
-    if (ret == -1)
-        goto extract_ret;
-    if (here->bits) {
-        ret = getc(in);
-        if (ret == -1) {
-            ret = ferror(in) ? Z_ERRNO : Z_DATA_ERROR;
-            goto extract_ret;
-        }
-        (void)inflatePrime(&strm, here->bits, ret >> (8 - here->bits));
-    }
-    (void)inflateSetDictionary(&strm, here->window, WINSIZE);
-
-    /* skip uncompressed bytes until offset reached, then satisfy request */
-    offset -= here->out;
-    strm.avail_in = 0;
-    skip = 1;                               /* while skipping to offset */
-    do {
-        /* define where to put uncompressed data, and how much */
-        if (offset == 0 && skip) {          /* at offset now */
-            strm.avail_out = len;
-            strm.next_out = buf;
-            skip = 0;                       /* only do this once */
-        }
-        if (offset > WINSIZE) {             /* skip WINSIZE bytes */
-            strm.avail_out = WINSIZE;
-            strm.next_out = discard;
-            offset -= WINSIZE;
-        }
-        else if (offset != 0) {             /* last skip */
-            strm.avail_out = (unsigned)offset;
-            strm.next_out = discard;
-            offset = 0;
-        }
-
-        /* uncompress until avail_out filled, or end of stream */
-        do {
-            if (strm.avail_in == 0) {
-                strm.avail_in = fread(input, 1, CHUNK, in);
-                if (ferror(in)) {
-                    ret = Z_ERRNO;
-                    goto extract_ret;
-                }
-                if (strm.avail_in == 0) {
-                    ret = Z_DATA_ERROR;
-                    goto extract_ret;
-                }
-                strm.next_in = input;
-            }
-            ret = inflate(&strm, Z_NO_FLUSH);       /* normal inflate */
-            if (ret == Z_NEED_DICT)
-                ret = Z_DATA_ERROR;
-            if (ret == Z_MEM_ERROR || ret == Z_DATA_ERROR)
-                goto extract_ret;
-            if (ret == Z_STREAM_END)
-                break;
-        } while (strm.avail_out != 0);
-
-        /* if reach end of stream, then don't keep trying to get more */
-        if (ret == Z_STREAM_END)
-            break;
-
-        /* do until offset reached and requested data read, or stream ends */
-    } while (skip);
-
-    /* compute number of uncompressed bytes read after offset */
-    ret = skip ? 0 : len - strm.avail_out;
-
-    /* clean up and return bytes read or error */
-  extract_ret:
-    (void)inflateEnd(&strm);
-    return ret;
-}
-
-/* Demonstrate the use of build_index() and extract() by processing the file
-   provided on the command line, and the extracting 16K from about 2/3rds of
-   the way through the uncompressed output, and writing that to stdout. */
-int main(int argc, char **argv)
-{
-    int len;
-    off_t offset;
-    FILE *in;
-    struct access *index = NULL;
-    unsigned char buf[CHUNK];
-
-    /* open input file */
-    if (argc != 2) {
-        fprintf(stderr, "usage: zran file.gz\n");
-        return 1;
-    }
-    in = fopen(argv[1], "rb");
-    if (in == NULL) {
-        fprintf(stderr, "zran: could not open %s for reading\n", argv[1]);
-        return 1;
-    }
-
-    /* build index */
-    len = build_index(in, SPAN, &index);
-    if (len < 0) {
-        fclose(in);
-        switch (len) {
-        case Z_MEM_ERROR:
-            fprintf(stderr, "zran: out of memory\n");
-            break;
-        case Z_DATA_ERROR:
-            fprintf(stderr, "zran: compressed data error in %s\n", argv[1]);
-            break;
-        case Z_ERRNO:
-            fprintf(stderr, "zran: read error on %s\n", argv[1]);
-            break;
-        default:
-            fprintf(stderr, "zran: error %d while building index\n", len);
-        }
-        return 1;
-    }
-    fprintf(stderr, "zran: built index with %d access points\n", len);
-
-    /* use index by reading some bytes from an arbitrary offset */
-    offset = (index->list[index->have - 1].out << 1) / 3;
-    len = extract(in, index, offset, buf, CHUNK);
-    if (len < 0)
-        fprintf(stderr, "zran: extraction failed: %s error\n",
-                len == Z_MEM_ERROR ? "out of memory" : "input corrupted");
-    else {
-        fwrite(buf, 1, len, stdout);
-        fprintf(stderr, "zran: extracted %d bytes at %llu\n", len, offset);
-    }
-
-    /* clean up and exit */
-    free_index(index);
-    fclose(in);
-    return 0;
-}
diff -Nbaur gcc-4.8.1/zlib/FAQ gcc-4.8.1-ppc/zlib/FAQ
--- gcc-4.8.1/zlib/FAQ	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/FAQ	1970-01-01 01:00:00.000000000 +0100
@@ -1,368 +0,0 @@
-
-                Frequently Asked Questions about zlib
-
-
-If your question is not there, please check the zlib home page
-http://zlib.net/ which may have more recent information.
-The lastest zlib FAQ is at http://zlib.net/zlib_faq.html
-
-
- 1. Is zlib Y2K-compliant?
-
-    Yes. zlib doesn't handle dates.
-
- 2. Where can I get a Windows DLL version?
-
-    The zlib sources can be compiled without change to produce a DLL.  See the
-    file win32/DLL_FAQ.txt in the zlib distribution.  Pointers to the
-    precompiled DLL are found in the zlib web site at http://zlib.net/ .
-
- 3. Where can I get a Visual Basic interface to zlib?
-
-    See
-        * http://marknelson.us/1997/01/01/zlib-engine/
-        * win32/DLL_FAQ.txt in the zlib distribution
-
- 4. compress() returns Z_BUF_ERROR.
-
-    Make sure that before the call of compress(), the length of the compressed
-    buffer is equal to the available size of the compressed buffer and not
-    zero.  For Visual Basic, check that this parameter is passed by reference
-    ("as any"), not by value ("as long").
-
- 5. deflate() or inflate() returns Z_BUF_ERROR.
-
-    Before making the call, make sure that avail_in and avail_out are not zero.
-    When setting the parameter flush equal to Z_FINISH, also make sure that
-    avail_out is big enough to allow processing all pending input.  Note that a
-    Z_BUF_ERROR is not fatal--another call to deflate() or inflate() can be
-    made with more input or output space.  A Z_BUF_ERROR may in fact be
-    unavoidable depending on how the functions are used, since it is not
-    possible to tell whether or not there is more output pending when
-    strm.avail_out returns with zero.  See http://zlib.net/zlib_how.html for a
-    heavily annotated example.
-
- 6. Where's the zlib documentation (man pages, etc.)?
-
-    It's in zlib.h .  Examples of zlib usage are in the files test/example.c
-    and test/minigzip.c, with more in examples/ .
-
- 7. Why don't you use GNU autoconf or libtool or ...?
-
-    Because we would like to keep zlib as a very small and simple package.
-    zlib is rather portable and doesn't need much configuration.
-
- 8. I found a bug in zlib.
-
-    Most of the time, such problems are due to an incorrect usage of zlib.
-    Please try to reproduce the problem with a small program and send the
-    corresponding source to us at zlib@gzip.org .  Do not send multi-megabyte
-    data files without prior agreement.
-
- 9. Why do I get "undefined reference to gzputc"?
-
-    If "make test" produces something like
-
-       example.o(.text+0x154): undefined reference to `gzputc'
-
-    check that you don't have old files libz.* in /usr/lib, /usr/local/lib or
-    /usr/X11R6/lib. Remove any old versions, then do "make install".
-
-10. I need a Delphi interface to zlib.
-
-    See the contrib/delphi directory in the zlib distribution.
-
-11. Can zlib handle .zip archives?
-
-    Not by itself, no.  See the directory contrib/minizip in the zlib
-    distribution.
-
-12. Can zlib handle .Z files?
-
-    No, sorry.  You have to spawn an uncompress or gunzip subprocess, or adapt
-    the code of uncompress on your own.
-
-13. How can I make a Unix shared library?
-
-    By default a shared (and a static) library is built for Unix.  So:
-
-    make distclean
-    ./configure
-    make
-
-14. How do I install a shared zlib library on Unix?
-
-    After the above, then:
-
-    make install
-
-    However, many flavors of Unix come with a shared zlib already installed.
-    Before going to the trouble of compiling a shared version of zlib and
-    trying to install it, you may want to check if it's already there!  If you
-    can #include <zlib.h>, it's there.  The -lz option will probably link to
-    it.  You can check the version at the top of zlib.h or with the
-    ZLIB_VERSION symbol defined in zlib.h .
-
-15. I have a question about OttoPDF.
-
-    We are not the authors of OttoPDF. The real author is on the OttoPDF web
-    site: Joel Hainley, jhainley@myndkryme.com.
-
-16. Can zlib decode Flate data in an Adobe PDF file?
-
-    Yes. See http://www.pdflib.com/ . To modify PDF forms, see
-    http://sourceforge.net/projects/acroformtool/ .
-
-17. Why am I getting this "register_frame_info not found" error on Solaris?
-
-    After installing zlib 1.1.4 on Solaris 2.6, running applications using zlib
-    generates an error such as:
-
-        ld.so.1: rpm: fatal: relocation error: file /usr/local/lib/libz.so:
-        symbol __register_frame_info: referenced symbol not found
-
-    The symbol __register_frame_info is not part of zlib, it is generated by
-    the C compiler (cc or gcc).  You must recompile applications using zlib
-    which have this problem.  This problem is specific to Solaris.  See
-    http://www.sunfreeware.com for Solaris versions of zlib and applications
-    using zlib.
-
-18. Why does gzip give an error on a file I make with compress/deflate?
-
-    The compress and deflate functions produce data in the zlib format, which
-    is different and incompatible with the gzip format.  The gz* functions in
-    zlib on the other hand use the gzip format.  Both the zlib and gzip formats
-    use the same compressed data format internally, but have different headers
-    and trailers around the compressed data.
-
-19. Ok, so why are there two different formats?
-
-    The gzip format was designed to retain the directory information about a
-    single file, such as the name and last modification date.  The zlib format
-    on the other hand was designed for in-memory and communication channel
-    applications, and has a much more compact header and trailer and uses a
-    faster integrity check than gzip.
-
-20. Well that's nice, but how do I make a gzip file in memory?
-
-    You can request that deflate write the gzip format instead of the zlib
-    format using deflateInit2().  You can also request that inflate decode the
-    gzip format using inflateInit2().  Read zlib.h for more details.
-
-21. Is zlib thread-safe?
-
-    Yes.  However any library routines that zlib uses and any application-
-    provided memory allocation routines must also be thread-safe.  zlib's gz*
-    functions use stdio library routines, and most of zlib's functions use the
-    library memory allocation routines by default.  zlib's *Init* functions
-    allow for the application to provide custom memory allocation routines.
-
-    Of course, you should only operate on any given zlib or gzip stream from a
-    single thread at a time.
-
-22. Can I use zlib in my commercial application?
-
-    Yes.  Please read the license in zlib.h.
-
-23. Is zlib under the GNU license?
-
-    No.  Please read the license in zlib.h.
-
-24. The license says that altered source versions must be "plainly marked". So
-    what exactly do I need to do to meet that requirement?
-
-    You need to change the ZLIB_VERSION and ZLIB_VERNUM #defines in zlib.h.  In
-    particular, the final version number needs to be changed to "f", and an
-    identification string should be appended to ZLIB_VERSION.  Version numbers
-    x.x.x.f are reserved for modifications to zlib by others than the zlib
-    maintainers.  For example, if the version of the base zlib you are altering
-    is "1.2.3.4", then in zlib.h you should change ZLIB_VERNUM to 0x123f, and
-    ZLIB_VERSION to something like "1.2.3.f-zachary-mods-v3".  You can also
-    update the version strings in deflate.c and inftrees.c.
-
-    For altered source distributions, you should also note the origin and
-    nature of the changes in zlib.h, as well as in ChangeLog and README, along
-    with the dates of the alterations.  The origin should include at least your
-    name (or your company's name), and an email address to contact for help or
-    issues with the library.
-
-    Note that distributing a compiled zlib library along with zlib.h and
-    zconf.h is also a source distribution, and so you should change
-    ZLIB_VERSION and ZLIB_VERNUM and note the origin and nature of the changes
-    in zlib.h as you would for a full source distribution.
-
-25. Will zlib work on a big-endian or little-endian architecture, and can I
-    exchange compressed data between them?
-
-    Yes and yes.
-
-26. Will zlib work on a 64-bit machine?
-
-    Yes.  It has been tested on 64-bit machines, and has no dependence on any
-    data types being limited to 32-bits in length.  If you have any
-    difficulties, please provide a complete problem report to zlib@gzip.org
-
-27. Will zlib decompress data from the PKWare Data Compression Library?
-
-    No.  The PKWare DCL uses a completely different compressed data format than
-    does PKZIP and zlib.  However, you can look in zlib's contrib/blast
-    directory for a possible solution to your problem.
-
-28. Can I access data randomly in a compressed stream?
-
-    No, not without some preparation.  If when compressing you periodically use
-    Z_FULL_FLUSH, carefully write all the pending data at those points, and
-    keep an index of those locations, then you can start decompression at those
-    points.  You have to be careful to not use Z_FULL_FLUSH too often, since it
-    can significantly degrade compression.  Alternatively, you can scan a
-    deflate stream once to generate an index, and then use that index for
-    random access.  See examples/zran.c .
-
-29. Does zlib work on MVS, OS/390, CICS, etc.?
-
-    It has in the past, but we have not heard of any recent evidence.  There
-    were working ports of zlib 1.1.4 to MVS, but those links no longer work.
-    If you know of recent, successful applications of zlib on these operating
-    systems, please let us know.  Thanks.
-
-30. Is there some simpler, easier to read version of inflate I can look at to
-    understand the deflate format?
-
-    First off, you should read RFC 1951.  Second, yes.  Look in zlib's
-    contrib/puff directory.
-
-31. Does zlib infringe on any patents?
-
-    As far as we know, no.  In fact, that was originally the whole point behind
-    zlib.  Look here for some more information:
-
-    http://www.gzip.org/#faq11
-
-32. Can zlib work with greater than 4 GB of data?
-
-    Yes.  inflate() and deflate() will process any amount of data correctly.
-    Each call of inflate() or deflate() is limited to input and output chunks
-    of the maximum value that can be stored in the compiler's "unsigned int"
-    type, but there is no limit to the number of chunks.  Note however that the
-    strm.total_in and strm_total_out counters may be limited to 4 GB.  These
-    counters are provided as a convenience and are not used internally by
-    inflate() or deflate().  The application can easily set up its own counters
-    updated after each call of inflate() or deflate() to count beyond 4 GB.
-    compress() and uncompress() may be limited to 4 GB, since they operate in a
-    single call.  gzseek() and gztell() may be limited to 4 GB depending on how
-    zlib is compiled.  See the zlibCompileFlags() function in zlib.h.
-
-    The word "may" appears several times above since there is a 4 GB limit only
-    if the compiler's "long" type is 32 bits.  If the compiler's "long" type is
-    64 bits, then the limit is 16 exabytes.
-
-33. Does zlib have any security vulnerabilities?
-
-    The only one that we are aware of is potentially in gzprintf().  If zlib is
-    compiled to use sprintf() or vsprintf(), then there is no protection
-    against a buffer overflow of an 8K string space (or other value as set by
-    gzbuffer()), other than the caller of gzprintf() assuring that the output
-    will not exceed 8K.  On the other hand, if zlib is compiled to use
-    snprintf() or vsnprintf(), which should normally be the case, then there is
-    no vulnerability.  The ./configure script will display warnings if an
-    insecure variation of sprintf() will be used by gzprintf().  Also the
-    zlibCompileFlags() function will return information on what variant of
-    sprintf() is used by gzprintf().
-
-    If you don't have snprintf() or vsnprintf() and would like one, you can
-    find a portable implementation here:
-
-        http://www.ijs.si/software/snprintf/
-
-    Note that you should be using the most recent version of zlib.  Versions
-    1.1.3 and before were subject to a double-free vulnerability, and versions
-    1.2.1 and 1.2.2 were subject to an access exception when decompressing
-    invalid compressed data.
-
-34. Is there a Java version of zlib?
-
-    Probably what you want is to use zlib in Java. zlib is already included
-    as part of the Java SDK in the java.util.zip package. If you really want
-    a version of zlib written in the Java language, look on the zlib home
-    page for links: http://zlib.net/ .
-
-35. I get this or that compiler or source-code scanner warning when I crank it
-    up to maximally-pedantic. Can't you guys write proper code?
-
-    Many years ago, we gave up attempting to avoid warnings on every compiler
-    in the universe.  It just got to be a waste of time, and some compilers
-    were downright silly as well as contradicted each other.  So now, we simply
-    make sure that the code always works.
-
-36. Valgrind (or some similar memory access checker) says that deflate is
-    performing a conditional jump that depends on an uninitialized value.
-    Isn't that a bug?
-
-    No.  That is intentional for performance reasons, and the output of deflate
-    is not affected.  This only started showing up recently since zlib 1.2.x
-    uses malloc() by default for allocations, whereas earlier versions used
-    calloc(), which zeros out the allocated memory.  Even though the code was
-    correct, versions 1.2.4 and later was changed to not stimulate these
-    checkers.
-
-37. Will zlib read the (insert any ancient or arcane format here) compressed
-    data format?
-
-    Probably not. Look in the comp.compression FAQ for pointers to various
-    formats and associated software.
-
-38. How can I encrypt/decrypt zip files with zlib?
-
-    zlib doesn't support encryption.  The original PKZIP encryption is very
-    weak and can be broken with freely available programs.  To get strong
-    encryption, use GnuPG, http://www.gnupg.org/ , which already includes zlib
-    compression.  For PKZIP compatible "encryption", look at
-    http://www.info-zip.org/
-
-39. What's the difference between the "gzip" and "deflate" HTTP 1.1 encodings?
-
-    "gzip" is the gzip format, and "deflate" is the zlib format.  They should
-    probably have called the second one "zlib" instead to avoid confusion with
-    the raw deflate compressed data format.  While the HTTP 1.1 RFC 2616
-    correctly points to the zlib specification in RFC 1950 for the "deflate"
-    transfer encoding, there have been reports of servers and browsers that
-    incorrectly produce or expect raw deflate data per the deflate
-    specification in RFC 1951, most notably Microsoft.  So even though the
-    "deflate" transfer encoding using the zlib format would be the more
-    efficient approach (and in fact exactly what the zlib format was designed
-    for), using the "gzip" transfer encoding is probably more reliable due to
-    an unfortunate choice of name on the part of the HTTP 1.1 authors.
-
-    Bottom line: use the gzip format for HTTP 1.1 encoding.
-
-40. Does zlib support the new "Deflate64" format introduced by PKWare?
-
-    No.  PKWare has apparently decided to keep that format proprietary, since
-    they have not documented it as they have previous compression formats.  In
-    any case, the compression improvements are so modest compared to other more
-    modern approaches, that it's not worth the effort to implement.
-
-41. I'm having a problem with the zip functions in zlib, can you help?
-
-    There are no zip functions in zlib.  You are probably using minizip by
-    Giles Vollant, which is found in the contrib directory of zlib.  It is not
-    part of zlib.  In fact none of the stuff in contrib is part of zlib.  The
-    files in there are not supported by the zlib authors.  You need to contact
-    the authors of the respective contribution for help.
-
-42. The match.asm code in contrib is under the GNU General Public License.
-    Since it's part of zlib, doesn't that mean that all of zlib falls under the
-    GNU GPL?
-
-    No.  The files in contrib are not part of zlib.  They were contributed by
-    other authors and are provided as a convenience to the user within the zlib
-    distribution.  Each item in contrib has its own license.
-
-43. Is zlib subject to export controls?  What is its ECCN?
-
-    zlib is not subject to export controls, and so is classified as EAR99.
-
-44. Can you please sign these lengthy legal documents and fax them back to us
-    so that we can use your software in our product?
-
-    No. Go away. Shoo.
diff -Nbaur gcc-4.8.1/zlib/gzclose.c gcc-4.8.1-ppc/zlib/gzclose.c
--- gcc-4.8.1/zlib/gzclose.c	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/gzclose.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-/* gzclose.c -- zlib gzclose() function
- * Copyright (C) 2004, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "gzguts.h"
-
-/* gzclose() is in a separate file so that it is linked in only if it is used.
-   That way the other gzclose functions can be used instead to avoid linking in
-   unneeded compression or decompression routines. */
-int ZEXPORT gzclose(file)
-    gzFile file;
-{
-#ifndef NO_GZCOMPRESS
-    gz_statep state;
-
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-
-    return state->mode == GZ_READ ? gzclose_r(file) : gzclose_w(file);
-#else
-    return gzclose_r(file);
-#endif
-}
diff -Nbaur gcc-4.8.1/zlib/gzguts.h gcc-4.8.1-ppc/zlib/gzguts.h
--- gcc-4.8.1/zlib/gzguts.h	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/gzguts.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,193 +0,0 @@
-/* gzguts.h -- zlib internal header definitions for gz* operations
- * Copyright (C) 2004, 2005, 2010, 2011, 2012 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#ifdef _LARGEFILE64_SOURCE
-#  ifndef _LARGEFILE_SOURCE
-#    define _LARGEFILE_SOURCE 1
-#  endif
-#  ifdef _FILE_OFFSET_BITS
-#    undef _FILE_OFFSET_BITS
-#  endif
-#endif
-
-#ifdef HAVE_HIDDEN
-#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
-#else
-#  define ZLIB_INTERNAL
-#endif
-
-#include <stdio.h>
-#include "zlib.h"
-#ifdef STDC
-#  include <string.h>
-#  include <stdlib.h>
-#  include <limits.h>
-#endif
-#include <fcntl.h>
-
-#ifdef _WIN32
-#  include <stddef.h>
-#endif
-
-#if defined(__TURBOC__) || defined(_MSC_VER) || defined(_WIN32)
-#  include <io.h>
-#endif
-
-#ifdef NO_DEFLATE       /* for compatibility with old definition */
-#  define NO_GZCOMPRESS
-#endif
-
-#if defined(STDC99) || (defined(__TURBOC__) && __TURBOC__ >= 0x550)
-#  ifndef HAVE_VSNPRINTF
-#    define HAVE_VSNPRINTF
-#  endif
-#endif
-
-#if defined(__CYGWIN__)
-#  ifndef HAVE_VSNPRINTF
-#    define HAVE_VSNPRINTF
-#  endif
-#endif
-
-#if defined(MSDOS) && defined(__BORLANDC__) && (BORLANDC > 0x410)
-#  ifndef HAVE_VSNPRINTF
-#    define HAVE_VSNPRINTF
-#  endif
-#endif
-
-#ifndef HAVE_VSNPRINTF
-#  ifdef MSDOS
-/* vsnprintf may exist on some MS-DOS compilers (DJGPP?),
- but for now we just assume it doesn't. */
-#    define NO_vsnprintf
-#  endif
-#  ifdef __TURBOC__
-#    define NO_vsnprintf
-#  endif
-#  ifdef WIN32
-/* In Win32, vsnprintf is available as the "non-ANSI" _vsnprintf. */
-#    if !defined(vsnprintf) && !defined(NO_vsnprintf)
-#      if !defined(_MSC_VER) || ( defined(_MSC_VER) && _MSC_VER < 1500 )
-#         define vsnprintf _vsnprintf
-#      endif
-#    endif
-#  endif
-#  ifdef __SASC
-#    define NO_vsnprintf
-#  endif
-#  ifdef VMS
-#    define NO_vsnprintf
-#  endif
-#  ifdef __OS400__
-#    define NO_vsnprintf
-#  endif
-#  ifdef __MVS__
-#    define NO_vsnprintf
-#  endif
-#endif
-
-#ifndef local
-#  define local static
-#endif
-/* compile with -Dlocal if your debugger can't find static symbols */
-
-/* gz* functions always use library allocation functions */
-#ifndef STDC
-  extern voidp  malloc OF((uInt size));
-  extern void   free   OF((voidpf ptr));
-#endif
-
-/* get errno and strerror definition */
-#if defined UNDER_CE
-#  include <windows.h>
-#  define zstrerror() gz_strwinerror((DWORD)GetLastError())
-#else
-#  ifndef NO_STRERROR
-#    include <errno.h>
-#    define zstrerror() strerror(errno)
-#  else
-#    define zstrerror() "stdio error (consult errno)"
-#  endif
-#endif
-
-/* provide prototypes for these when building zlib without LFS */
-#if !defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0
-    ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-    ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
-    ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
-    ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
-#endif
-
-/* default memLevel */
-#if MAX_MEM_LEVEL >= 8
-#  define DEF_MEM_LEVEL 8
-#else
-#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#endif
-
-/* default i/o buffer size -- double this for output when reading */
-#define GZBUFSIZE 8192
-
-/* gzip modes, also provide a little integrity check on the passed structure */
-#define GZ_NONE 0
-#define GZ_READ 7247
-#define GZ_WRITE 31153
-#define GZ_APPEND 1     /* mode set to GZ_WRITE after the file is opened */
-
-/* values for gz_state how */
-#define LOOK 0      /* look for a gzip header */
-#define COPY 1      /* copy input directly */
-#define GZIP 2      /* decompress a gzip stream */
-
-/* internal gzip file state data structure */
-typedef struct {
-        /* exposed contents for gzgetc() macro */
-    struct gzFile_s x;      /* "x" for exposed */
-                            /* x.have: number of bytes available at x.next */
-                            /* x.next: next output data to deliver or write */
-                            /* x.pos: current position in uncompressed data */
-        /* used for both reading and writing */
-    int mode;               /* see gzip modes above */
-    int fd;                 /* file descriptor */
-    char *path;             /* path or fd for error messages */
-    unsigned size;          /* buffer size, zero if not allocated yet */
-    unsigned want;          /* requested buffer size, default is GZBUFSIZE */
-    unsigned char *in;      /* input buffer */
-    unsigned char *out;     /* output buffer (double-sized when reading) */
-    int direct;             /* 0 if processing gzip, 1 if transparent */
-        /* just for reading */
-    int how;                /* 0: get header, 1: copy, 2: decompress */
-    z_off64_t start;        /* where the gzip data started, for rewinding */
-    int eof;                /* true if end of input file reached */
-    int past;               /* true if read requested past end */
-        /* just for writing */
-    int level;              /* compression level */
-    int strategy;           /* compression strategy */
-        /* seek request */
-    z_off64_t skip;         /* amount to skip (already rewound if backwards) */
-    int seek;               /* true if seek request pending */
-        /* error information */
-    int err;                /* error code */
-    char *msg;              /* error message */
-        /* zlib inflate or deflate stream */
-    z_stream strm;          /* stream structure in-place (not a pointer) */
-} gz_state;
-typedef gz_state FAR *gz_statep;
-
-/* shared functions */
-void ZLIB_INTERNAL gz_error OF((gz_statep, int, const char *));
-#if defined UNDER_CE
-char ZLIB_INTERNAL *gz_strwinerror OF((DWORD error));
-#endif
-
-/* GT_OFF(x), where x is an unsigned value, is true if x > maximum z_off64_t
-   value -- needed when comparing unsigned to z_off64_t, which is signed
-   (possible z_off64_t types off_t, off64_t, and long are all signed) */
-#ifdef INT_MAX
-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > INT_MAX)
-#else
-unsigned ZLIB_INTERNAL gz_intmax OF((void));
-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())
-#endif
diff -Nbaur gcc-4.8.1/zlib/gzlib.c gcc-4.8.1-ppc/zlib/gzlib.c
--- gcc-4.8.1/zlib/gzlib.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/gzlib.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,620 +0,0 @@
-/* gzlib.c -- zlib functions common to reading and writing gzip files
- * Copyright (C) 2004, 2010, 2011, 2012 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "gzguts.h"
-
-#if defined(_WIN32) && !defined(__BORLANDC__)
-#  define LSEEK _lseeki64
-#else
-#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
-#  define LSEEK lseek64
-#else
-#  define LSEEK lseek
-#endif
-#endif
-
-/* Local functions */
-local void gz_reset OF((gz_statep));
-local gzFile gz_open OF((const void *, int, const char *));
-
-#if defined UNDER_CE
-
-/* Map the Windows error number in ERROR to a locale-dependent error message
-   string and return a pointer to it.  Typically, the values for ERROR come
-   from GetLastError.
-
-   The string pointed to shall not be modified by the application, but may be
-   overwritten by a subsequent call to gz_strwinerror
-
-   The gz_strwinerror function does not change the current setting of
-   GetLastError. */
-char ZLIB_INTERNAL *gz_strwinerror (error)
-     DWORD error;
-{
-    static char buf[1024];
-
-    wchar_t *msgbuf;
-    DWORD lasterr = GetLastError();
-    DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
-        | FORMAT_MESSAGE_ALLOCATE_BUFFER,
-        NULL,
-        error,
-        0, /* Default language */
-        (LPVOID)&msgbuf,
-        0,
-        NULL);
-    if (chars != 0) {
-        /* If there is an \r\n appended, zap it.  */
-        if (chars >= 2
-            && msgbuf[chars - 2] == '\r' && msgbuf[chars - 1] == '\n') {
-            chars -= 2;
-            msgbuf[chars] = 0;
-        }
-
-        if (chars > sizeof (buf) - 1) {
-            chars = sizeof (buf) - 1;
-            msgbuf[chars] = 0;
-        }
-
-        wcstombs(buf, msgbuf, chars + 1);
-        LocalFree(msgbuf);
-    }
-    else {
-        sprintf(buf, "unknown win32 error (%ld)", error);
-    }
-
-    SetLastError(lasterr);
-    return buf;
-}
-
-#endif /* UNDER_CE */
-
-/* Reset gzip file state */
-local void gz_reset(state)
-    gz_statep state;
-{
-    state->x.have = 0;              /* no output data available */
-    if (state->mode == GZ_READ) {   /* for reading ... */
-        state->eof = 0;             /* not at end of file */
-        state->past = 0;            /* have not read past end yet */
-        state->how = LOOK;          /* look for gzip header */
-    }
-    state->seek = 0;                /* no seek request pending */
-    gz_error(state, Z_OK, NULL);    /* clear error */
-    state->x.pos = 0;               /* no uncompressed data yet */
-    state->strm.avail_in = 0;       /* no input data yet */
-}
-
-/* Open a gzip file either by name or file descriptor. */
-local gzFile gz_open(path, fd, mode)
-    const void *path;
-    int fd;
-    const char *mode;
-{
-    gz_statep state;
-    size_t len;
-    int oflag;
-#ifdef O_CLOEXEC
-    int cloexec = 0;
-#endif
-#ifdef O_EXCL
-    int exclusive = 0;
-#endif
-
-    /* check input */
-    if (path == NULL)
-        return NULL;
-
-    /* allocate gzFile structure to return */
-    state = malloc(sizeof(gz_state));
-    if (state == NULL)
-        return NULL;
-    state->size = 0;            /* no buffers allocated yet */
-    state->want = GZBUFSIZE;    /* requested buffer size */
-    state->msg = NULL;          /* no error message yet */
-
-    /* interpret mode */
-    state->mode = GZ_NONE;
-    state->level = Z_DEFAULT_COMPRESSION;
-    state->strategy = Z_DEFAULT_STRATEGY;
-    state->direct = 0;
-    while (*mode) {
-        if (*mode >= '0' && *mode <= '9')
-            state->level = *mode - '0';
-        else
-            switch (*mode) {
-            case 'r':
-                state->mode = GZ_READ;
-                break;
-#ifndef NO_GZCOMPRESS
-            case 'w':
-                state->mode = GZ_WRITE;
-                break;
-            case 'a':
-                state->mode = GZ_APPEND;
-                break;
-#endif
-            case '+':       /* can't read and write at the same time */
-                free(state);
-                return NULL;
-            case 'b':       /* ignore -- will request binary anyway */
-                break;
-#ifdef O_CLOEXEC
-            case 'e':
-                cloexec = 1;
-                break;
-#endif
-#ifdef O_EXCL
-            case 'x':
-                exclusive = 1;
-                break;
-#endif
-            case 'f':
-                state->strategy = Z_FILTERED;
-                break;
-            case 'h':
-                state->strategy = Z_HUFFMAN_ONLY;
-                break;
-            case 'R':
-                state->strategy = Z_RLE;
-                break;
-            case 'F':
-                state->strategy = Z_FIXED;
-            case 'T':
-                state->direct = 1;
-            default:        /* could consider as an error, but just ignore */
-                ;
-            }
-        mode++;
-    }
-
-    /* must provide an "r", "w", or "a" */
-    if (state->mode == GZ_NONE) {
-        free(state);
-        return NULL;
-    }
-
-    /* can't force transparent read */
-    if (state->mode == GZ_READ) {
-        if (state->direct) {
-            free(state);
-            return NULL;
-        }
-        state->direct = 1;      /* for empty file */
-    }
-
-    /* save the path name for error messages */
-#ifdef _WIN32
-    if (fd == -2) {
-        len = wcstombs(NULL, path, 0);
-        if (len == (size_t)-1)
-            len = 0;
-    }
-    else
-#endif
-        len = strlen(path);
-    state->path = malloc(len + 1);
-    if (state->path == NULL) {
-        free(state);
-        return NULL;
-    }
-#ifdef _WIN32
-    if (fd == -2)
-        if (len)
-            wcstombs(state->path, path, len + 1);
-        else
-            *(state->path) = 0;
-    else
-#endif
-        strcpy(state->path, path);
-
-    /* compute the flags for open() */
-    oflag =
-#ifdef O_LARGEFILE
-        O_LARGEFILE |
-#endif
-#ifdef O_BINARY
-        O_BINARY |
-#endif
-#ifdef O_CLOEXEC
-        (cloexec ? O_CLOEXEC : 0) |
-#endif
-        (state->mode == GZ_READ ?
-         O_RDONLY :
-         (O_WRONLY | O_CREAT |
-#ifdef O_EXCL
-          (exclusive ? O_EXCL : 0) |
-#endif
-          (state->mode == GZ_WRITE ?
-           O_TRUNC :
-           O_APPEND)));
-
-    /* open the file with the appropriate flags (or just use fd) */
-    state->fd = fd > -1 ? fd : (
-#ifdef _WIN32
-        fd == -2 ? _wopen(path, oflag, 0666) :
-#endif
-        open(path, oflag, 0666));
-    if (state->fd == -1) {
-        free(state->path);
-        free(state);
-        return NULL;
-    }
-    if (state->mode == GZ_APPEND)
-        state->mode = GZ_WRITE;         /* simplify later checks */
-
-    /* save the current position for rewinding (only if reading) */
-    if (state->mode == GZ_READ) {
-        state->start = LSEEK(state->fd, 0, SEEK_CUR);
-        if (state->start == -1) state->start = 0;
-    }
-
-    /* initialize stream */
-    gz_reset(state);
-
-    /* return stream */
-    return (gzFile)state;
-}
-
-/* -- see zlib.h -- */
-gzFile ZEXPORT gzopen(path, mode)
-    const char *path;
-    const char *mode;
-{
-    return gz_open(path, -1, mode);
-}
-
-/* -- see zlib.h -- */
-gzFile ZEXPORT gzopen64(path, mode)
-    const char *path;
-    const char *mode;
-{
-    return gz_open(path, -1, mode);
-}
-
-/* -- see zlib.h -- */
-gzFile ZEXPORT gzdopen(fd, mode)
-    int fd;
-    const char *mode;
-{
-    char *path;         /* identifier for error messages */
-    gzFile gz;
-
-    if (fd == -1 || (path = malloc(7 + 3 * sizeof(int))) == NULL)
-        return NULL;
-    sprintf(path, "<fd:%d>", fd);   /* for debugging */
-    gz = gz_open(path, fd, mode);
-    free(path);
-    return gz;
-}
-
-/* -- see zlib.h -- */
-#ifdef _WIN32
-gzFile ZEXPORT gzopen_w(path, mode)
-    const wchar_t *path;
-    const char *mode;
-{
-    return gz_open(path, -2, mode);
-}
-#endif
-
-/* -- see zlib.h -- */
-int ZEXPORT gzbuffer(file, size)
-    gzFile file;
-    unsigned size;
-{
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return -1;
-
-    /* make sure we haven't already allocated memory */
-    if (state->size != 0)
-        return -1;
-
-    /* check and set requested size */
-    if (size < 2)
-        size = 2;               /* need two bytes to check magic header */
-    state->want = size;
-    return 0;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzrewind(file)
-    gzFile file;
-{
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-
-    /* check that we're reading and that there's no error */
-    if (state->mode != GZ_READ ||
-            (state->err != Z_OK && state->err != Z_BUF_ERROR))
-        return -1;
-
-    /* back up and start over */
-    if (LSEEK(state->fd, state->start, SEEK_SET) == -1)
-        return -1;
-    gz_reset(state);
-    return 0;
-}
-
-/* -- see zlib.h -- */
-z_off64_t ZEXPORT gzseek64(file, offset, whence)
-    gzFile file;
-    z_off64_t offset;
-    int whence;
-{
-    unsigned n;
-    z_off64_t ret;
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return -1;
-
-    /* check that there's no error */
-    if (state->err != Z_OK && state->err != Z_BUF_ERROR)
-        return -1;
-
-    /* can only seek from start or relative to current position */
-    if (whence != SEEK_SET && whence != SEEK_CUR)
-        return -1;
-
-    /* normalize offset to a SEEK_CUR specification */
-    if (whence == SEEK_SET)
-        offset -= state->x.pos;
-    else if (state->seek)
-        offset += state->skip;
-    state->seek = 0;
-
-    /* if within raw area while reading, just go there */
-    if (state->mode == GZ_READ && state->how == COPY &&
-            state->x.pos + offset >= 0) {
-        ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);
-        if (ret == -1)
-            return -1;
-        state->x.have = 0;
-        state->eof = 0;
-        state->past = 0;
-        state->seek = 0;
-        gz_error(state, Z_OK, NULL);
-        state->strm.avail_in = 0;
-        state->x.pos += offset;
-        return state->x.pos;
-    }
-
-    /* calculate skip amount, rewinding if needed for back seek when reading */
-    if (offset < 0) {
-        if (state->mode != GZ_READ)         /* writing -- can't go backwards */
-            return -1;
-        offset += state->x.pos;
-        if (offset < 0)                     /* before start of file! */
-            return -1;
-        if (gzrewind(file) == -1)           /* rewind, then skip to offset */
-            return -1;
-    }
-
-    /* if reading, skip what's in output buffer (one less gzgetc() check) */
-    if (state->mode == GZ_READ) {
-        n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?
-            (unsigned)offset : state->x.have;
-        state->x.have -= n;
-        state->x.next += n;
-        state->x.pos += n;
-        offset -= n;
-    }
-
-    /* request skip (if not zero) */
-    if (offset) {
-        state->seek = 1;
-        state->skip = offset;
-    }
-    return state->x.pos + offset;
-}
-
-/* -- see zlib.h -- */
-z_off_t ZEXPORT gzseek(file, offset, whence)
-    gzFile file;
-    z_off_t offset;
-    int whence;
-{
-    z_off64_t ret;
-
-    ret = gzseek64(file, (z_off64_t)offset, whence);
-    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
-}
-
-/* -- see zlib.h -- */
-z_off64_t ZEXPORT gztell64(file)
-    gzFile file;
-{
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return -1;
-
-    /* return position */
-    return state->x.pos + (state->seek ? state->skip : 0);
-}
-
-/* -- see zlib.h -- */
-z_off_t ZEXPORT gztell(file)
-    gzFile file;
-{
-    z_off64_t ret;
-
-    ret = gztell64(file);
-    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
-}
-
-/* -- see zlib.h -- */
-z_off64_t ZEXPORT gzoffset64(file)
-    gzFile file;
-{
-    z_off64_t offset;
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return -1;
-
-    /* compute and return effective offset in file */
-    offset = LSEEK(state->fd, 0, SEEK_CUR);
-    if (offset == -1)
-        return -1;
-    if (state->mode == GZ_READ)             /* reading */
-        offset -= state->strm.avail_in;     /* don't count buffered input */
-    return offset;
-}
-
-/* -- see zlib.h -- */
-z_off_t ZEXPORT gzoffset(file)
-    gzFile file;
-{
-    z_off64_t ret;
-
-    ret = gzoffset64(file);
-    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzeof(file)
-    gzFile file;
-{
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return 0;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return 0;
-
-    /* return end-of-file state */
-    return state->mode == GZ_READ ? state->past : 0;
-}
-
-/* -- see zlib.h -- */
-const char * ZEXPORT gzerror(file, errnum)
-    gzFile file;
-    int *errnum;
-{
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return NULL;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return NULL;
-
-    /* return error information */
-    if (errnum != NULL)
-        *errnum = state->err;
-    return state->msg == NULL ? "" : state->msg;
-}
-
-/* -- see zlib.h -- */
-void ZEXPORT gzclearerr(file)
-    gzFile file;
-{
-    gz_statep state;
-
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return;
-
-    /* clear error and end-of-file */
-    if (state->mode == GZ_READ) {
-        state->eof = 0;
-        state->past = 0;
-    }
-    gz_error(state, Z_OK, NULL);
-}
-
-/* Create an error message in allocated memory and set state->err and
-   state->msg accordingly.  Free any previous error message already there.  Do
-   not try to free or allocate space if the error is Z_MEM_ERROR (out of
-   memory).  Simply save the error message as a static string.  If there is an
-   allocation failure constructing the error message, then convert the error to
-   out of memory. */
-void ZLIB_INTERNAL gz_error(state, err, msg)
-    gz_statep state;
-    int err;
-    const char *msg;
-{
-    /* free previously allocated message and clear */
-    if (state->msg != NULL) {
-        if (state->err != Z_MEM_ERROR)
-            free(state->msg);
-        state->msg = NULL;
-    }
-
-    /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
-    if (err != Z_OK && err != Z_BUF_ERROR)
-        state->x.have = 0;
-
-    /* set error code, and if no message, then done */
-    state->err = err;
-    if (msg == NULL)
-        return;
-
-    /* for an out of memory error, save as static string */
-    if (err == Z_MEM_ERROR) {
-        state->msg = (char *)msg;
-        return;
-    }
-
-    /* construct error message with path */
-    if ((state->msg = malloc(strlen(state->path) + strlen(msg) + 3)) == NULL) {
-        state->err = Z_MEM_ERROR;
-        state->msg = (char *)"out of memory";
-        return;
-    }
-    strcpy(state->msg, state->path);
-    strcat(state->msg, ": ");
-    strcat(state->msg, msg);
-    return;
-}
-
-#ifndef INT_MAX
-/* portably return maximum value for an int (when limits.h presumed not
-   available) -- we need to do this to cover cases where 2's complement not
-   used, since C standard permits 1's complement and sign-bit representations,
-   otherwise we could just use ((unsigned)-1) >> 1 */
-unsigned ZLIB_INTERNAL gz_intmax()
-{
-    unsigned p, q;
-
-    p = 1;
-    do {
-        q = p;
-        p <<= 1;
-        p++;
-    } while (p > q);
-    return q >> 1;
-}
-#endif
diff -Nbaur gcc-4.8.1/zlib/gzread.c gcc-4.8.1-ppc/zlib/gzread.c
--- gcc-4.8.1/zlib/gzread.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/gzread.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,589 +0,0 @@
-/* gzread.c -- zlib functions for reading gzip files
- * Copyright (C) 2004, 2005, 2010, 2011, 2012 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "gzguts.h"
-
-/* Local functions */
-local int gz_load OF((gz_statep, unsigned char *, unsigned, unsigned *));
-local int gz_avail OF((gz_statep));
-local int gz_look OF((gz_statep));
-local int gz_decomp OF((gz_statep));
-local int gz_fetch OF((gz_statep));
-local int gz_skip OF((gz_statep, z_off64_t));
-
-/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
-   state->fd, and update state->eof, state->err, and state->msg as appropriate.
-   This function needs to loop on read(), since read() is not guaranteed to
-   read the number of bytes requested, depending on the type of descriptor. */
-local int gz_load(state, buf, len, have)
-    gz_statep state;
-    unsigned char *buf;
-    unsigned len;
-    unsigned *have;
-{
-    int ret;
-
-    *have = 0;
-    do {
-        ret = read(state->fd, buf + *have, len - *have);
-        if (ret <= 0)
-            break;
-        *have += ret;
-    } while (*have < len);
-    if (ret < 0) {
-        gz_error(state, Z_ERRNO, zstrerror());
-        return -1;
-    }
-    if (ret == 0)
-        state->eof = 1;
-    return 0;
-}
-
-/* Load up input buffer and set eof flag if last data loaded -- return -1 on
-   error, 0 otherwise.  Note that the eof flag is set when the end of the input
-   file is reached, even though there may be unused data in the buffer.  Once
-   that data has been used, no more attempts will be made to read the file.
-   If strm->avail_in != 0, then the current data is moved to the beginning of
-   the input buffer, and then the remainder of the buffer is loaded with the
-   available data from the input file. */
-local int gz_avail(state)
-    gz_statep state;
-{
-    unsigned got;
-    z_streamp strm = &(state->strm);
-
-    if (state->err != Z_OK && state->err != Z_BUF_ERROR)
-        return -1;
-    if (state->eof == 0) {
-        if (strm->avail_in) {       /* copy what's there to the start */
-            unsigned char *p = state->in, *q = strm->next_in;
-            unsigned n = strm->avail_in;
-            do {
-                *p++ = *q++;
-            } while (--n);
-        }
-        if (gz_load(state, state->in + strm->avail_in,
-                    state->size - strm->avail_in, &got) == -1)
-            return -1;
-        strm->avail_in += got;
-        strm->next_in = state->in;
-    }
-    return 0;
-}
-
-/* Look for gzip header, set up for inflate or copy.  state->x.have must be 0.
-   If this is the first time in, allocate required memory.  state->how will be
-   left unchanged if there is no more input data available, will be set to COPY
-   if there is no gzip header and direct copying will be performed, or it will
-   be set to GZIP for decompression.  If direct copying, then leftover input
-   data from the input buffer will be copied to the output buffer.  In that
-   case, all further file reads will be directly to either the output buffer or
-   a user buffer.  If decompressing, the inflate state will be initialized.
-   gz_look() will return 0 on success or -1 on failure. */
-local int gz_look(state)
-    gz_statep state;
-{
-    z_streamp strm = &(state->strm);
-
-    /* allocate read buffers and inflate memory */
-    if (state->size == 0) {
-        /* allocate buffers */
-        state->in = malloc(state->want);
-        state->out = malloc(state->want << 1);
-        if (state->in == NULL || state->out == NULL) {
-            if (state->out != NULL)
-                free(state->out);
-            if (state->in != NULL)
-                free(state->in);
-            gz_error(state, Z_MEM_ERROR, "out of memory");
-            return -1;
-        }
-        state->size = state->want;
-
-        /* allocate inflate memory */
-        state->strm.zalloc = Z_NULL;
-        state->strm.zfree = Z_NULL;
-        state->strm.opaque = Z_NULL;
-        state->strm.avail_in = 0;
-        state->strm.next_in = Z_NULL;
-        if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */
-            free(state->out);
-            free(state->in);
-            state->size = 0;
-            gz_error(state, Z_MEM_ERROR, "out of memory");
-            return -1;
-        }
-    }
-
-    /* get at least the magic bytes in the input buffer */
-    if (strm->avail_in < 2) {
-        if (gz_avail(state) == -1)
-            return -1;
-        if (strm->avail_in == 0)
-            return 0;
-    }
-
-    /* look for gzip magic bytes -- if there, do gzip decoding (note: there is
-       a logical dilemma here when considering the case of a partially written
-       gzip file, to wit, if a single 31 byte is written, then we cannot tell
-       whether this is a single-byte file, or just a partially written gzip
-       file -- for here we assume that if a gzip file is being written, then
-       the header will be written in a single operation, so that reading a
-       single byte is sufficient indication that it is not a gzip file) */
-    if (strm->avail_in > 1 &&
-            strm->next_in[0] == 31 && strm->next_in[1] == 139) {
-        inflateReset(strm);
-        state->how = GZIP;
-        state->direct = 0;
-        return 0;
-    }
-
-    /* no gzip header -- if we were decoding gzip before, then this is trailing
-       garbage.  Ignore the trailing garbage and finish. */
-    if (state->direct == 0) {
-        strm->avail_in = 0;
-        state->eof = 1;
-        state->x.have = 0;
-        return 0;
-    }
-
-    /* doing raw i/o, copy any leftover input to output -- this assumes that
-       the output buffer is larger than the input buffer, which also assures
-       space for gzungetc() */
-    state->x.next = state->out;
-    if (strm->avail_in) {
-        memcpy(state->x.next, strm->next_in, strm->avail_in);
-        state->x.have = strm->avail_in;
-        strm->avail_in = 0;
-    }
-    state->how = COPY;
-    state->direct = 1;
-    return 0;
-}
-
-/* Decompress from input to the provided next_out and avail_out in the state.
-   On return, state->x.have and state->x.next point to the just decompressed
-   data.  If the gzip stream completes, state->how is reset to LOOK to look for
-   the next gzip stream or raw data, once state->x.have is depleted.  Returns 0
-   on success, -1 on failure. */
-local int gz_decomp(state)
-    gz_statep state;
-{
-    int ret = Z_OK;
-    unsigned had;
-    z_streamp strm = &(state->strm);
-
-    /* fill output buffer up to end of deflate stream */
-    had = strm->avail_out;
-    do {
-        /* get more input for inflate() */
-        if (strm->avail_in == 0 && gz_avail(state) == -1)
-            return -1;
-        if (strm->avail_in == 0) {
-            gz_error(state, Z_BUF_ERROR, "unexpected end of file");
-            break;
-        }
-
-        /* decompress and handle errors */
-        ret = inflate(strm, Z_NO_FLUSH);
-        if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {
-            gz_error(state, Z_STREAM_ERROR,
-                     "internal error: inflate stream corrupt");
-            return -1;
-        }
-        if (ret == Z_MEM_ERROR) {
-            gz_error(state, Z_MEM_ERROR, "out of memory");
-            return -1;
-        }
-        if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */
-            gz_error(state, Z_DATA_ERROR,
-                     strm->msg == NULL ? "compressed data error" : strm->msg);
-            return -1;
-        }
-    } while (strm->avail_out && ret != Z_STREAM_END);
-
-    /* update available output */
-    state->x.have = had - strm->avail_out;
-    state->x.next = strm->next_out - state->x.have;
-
-    /* if the gzip stream completed successfully, look for another */
-    if (ret == Z_STREAM_END)
-        state->how = LOOK;
-
-    /* good decompression */
-    return 0;
-}
-
-/* Fetch data and put it in the output buffer.  Assumes state->x.have is 0.
-   Data is either copied from the input file or decompressed from the input
-   file depending on state->how.  If state->how is LOOK, then a gzip header is
-   looked for to determine whether to copy or decompress.  Returns -1 on error,
-   otherwise 0.  gz_fetch() will leave state->how as COPY or GZIP unless the
-   end of the input file has been reached and all data has been processed.  */
-local int gz_fetch(state)
-    gz_statep state;
-{
-    z_streamp strm = &(state->strm);
-
-    do {
-        switch(state->how) {
-        case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */
-            if (gz_look(state) == -1)
-                return -1;
-            if (state->how == LOOK)
-                return 0;
-            break;
-        case COPY:      /* -> COPY */
-            if (gz_load(state, state->out, state->size << 1, &(state->x.have))
-                    == -1)
-                return -1;
-            state->x.next = state->out;
-            return 0;
-        case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */
-            strm->avail_out = state->size << 1;
-            strm->next_out = state->out;
-            if (gz_decomp(state) == -1)
-                return -1;
-        }
-    } while (state->x.have == 0 && (!state->eof || strm->avail_in));
-    return 0;
-}
-
-/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
-local int gz_skip(state, len)
-    gz_statep state;
-    z_off64_t len;
-{
-    unsigned n;
-
-    /* skip over len bytes or reach end-of-file, whichever comes first */
-    while (len)
-        /* skip over whatever is in output buffer */
-        if (state->x.have) {
-            n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?
-                (unsigned)len : state->x.have;
-            state->x.have -= n;
-            state->x.next += n;
-            state->x.pos += n;
-            len -= n;
-        }
-
-        /* output buffer empty -- return if we're at the end of the input */
-        else if (state->eof && state->strm.avail_in == 0)
-            break;
-
-        /* need more data to skip -- load up output buffer */
-        else {
-            /* get more output, looking for header if required */
-            if (gz_fetch(state) == -1)
-                return -1;
-        }
-    return 0;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzread(file, buf, len)
-    gzFile file;
-    voidp buf;
-    unsigned len;
-{
-    unsigned got, n;
-    gz_statep state;
-    z_streamp strm;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-
-    /* check that we're reading and that there's no (serious) error */
-    if (state->mode != GZ_READ ||
-            (state->err != Z_OK && state->err != Z_BUF_ERROR))
-        return -1;
-
-    /* since an int is returned, make sure len fits in one, otherwise return
-       with an error (this avoids the flaw in the interface) */
-    if ((int)len < 0) {
-        gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");
-        return -1;
-    }
-
-    /* if len is zero, avoid unnecessary operations */
-    if (len == 0)
-        return 0;
-
-    /* process a skip request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_skip(state, state->skip) == -1)
-            return -1;
-    }
-
-    /* get len bytes to buf, or less than len if at the end */
-    got = 0;
-    do {
-        /* first just try copying data from the output buffer */
-        if (state->x.have) {
-            n = state->x.have > len ? len : state->x.have;
-            memcpy(buf, state->x.next, n);
-            state->x.next += n;
-            state->x.have -= n;
-        }
-
-        /* output buffer empty -- return if we're at the end of the input */
-        else if (state->eof && strm->avail_in == 0) {
-            state->past = 1;        /* tried to read past end */
-            break;
-        }
-
-        /* need output data -- for small len or new stream load up our output
-           buffer */
-        else if (state->how == LOOK || len < (state->size << 1)) {
-            /* get more output, looking for header if required */
-            if (gz_fetch(state) == -1)
-                return -1;
-            continue;       /* no progress yet -- go back to copy above */
-            /* the copy above assures that we will leave with space in the
-               output buffer, allowing at least one gzungetc() to succeed */
-        }
-
-        /* large len -- read directly into user buffer */
-        else if (state->how == COPY) {      /* read directly */
-            if (gz_load(state, buf, len, &n) == -1)
-                return -1;
-        }
-
-        /* large len -- decompress directly into user buffer */
-        else {  /* state->how == GZIP */
-            strm->avail_out = len;
-            strm->next_out = buf;
-            if (gz_decomp(state) == -1)
-                return -1;
-            n = state->x.have;
-            state->x.have = 0;
-        }
-
-        /* update progress */
-        len -= n;
-        buf = (char *)buf + n;
-        got += n;
-        state->x.pos += n;
-    } while (len);
-
-    /* return number of bytes read into user buffer (will fit in int) */
-    return (int)got;
-}
-
-/* -- see zlib.h -- */
-#undef gzgetc
-int ZEXPORT gzgetc(file)
-    gzFile file;
-{
-    int ret;
-    unsigned char buf[1];
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-
-    /* check that we're reading and that there's no (serious) error */
-    if (state->mode != GZ_READ ||
-        (state->err != Z_OK && state->err != Z_BUF_ERROR))
-        return -1;
-
-    /* try output buffer (no need to check for skip request) */
-    if (state->x.have) {
-        state->x.have--;
-        state->x.pos++;
-        return *(state->x.next)++;
-    }
-
-    /* nothing there -- try gzread() */
-    ret = gzread(file, buf, 1);
-    return ret < 1 ? -1 : buf[0];
-}
-
-int ZEXPORT gzgetc_(file)
-gzFile file;
-{
-    return gzgetc(file);
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzungetc(c, file)
-    int c;
-    gzFile file;
-{
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-
-    /* check that we're reading and that there's no (serious) error */
-    if (state->mode != GZ_READ ||
-        (state->err != Z_OK && state->err != Z_BUF_ERROR))
-        return -1;
-
-    /* process a skip request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_skip(state, state->skip) == -1)
-            return -1;
-    }
-
-    /* can't push EOF */
-    if (c < 0)
-        return -1;
-
-    /* if output buffer empty, put byte at end (allows more pushing) */
-    if (state->x.have == 0) {
-        state->x.have = 1;
-        state->x.next = state->out + (state->size << 1) - 1;
-        state->x.next[0] = c;
-        state->x.pos--;
-        state->past = 0;
-        return c;
-    }
-
-    /* if no room, give up (must have already done a gzungetc()) */
-    if (state->x.have == (state->size << 1)) {
-        gz_error(state, Z_DATA_ERROR, "out of room to push characters");
-        return -1;
-    }
-
-    /* slide output data if needed and insert byte before existing data */
-    if (state->x.next == state->out) {
-        unsigned char *src = state->out + state->x.have;
-        unsigned char *dest = state->out + (state->size << 1);
-        while (src > state->out)
-            *--dest = *--src;
-        state->x.next = dest;
-    }
-    state->x.have++;
-    state->x.next--;
-    state->x.next[0] = c;
-    state->x.pos--;
-    state->past = 0;
-    return c;
-}
-
-/* -- see zlib.h -- */
-char * ZEXPORT gzgets(file, buf, len)
-    gzFile file;
-    char *buf;
-    int len;
-{
-    unsigned left, n;
-    char *str;
-    unsigned char *eol;
-    gz_statep state;
-
-    /* check parameters and get internal structure */
-    if (file == NULL || buf == NULL || len < 1)
-        return NULL;
-    state = (gz_statep)file;
-
-    /* check that we're reading and that there's no (serious) error */
-    if (state->mode != GZ_READ ||
-        (state->err != Z_OK && state->err != Z_BUF_ERROR))
-        return NULL;
-
-    /* process a skip request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_skip(state, state->skip) == -1)
-            return NULL;
-    }
-
-    /* copy output bytes up to new line or len - 1, whichever comes first --
-       append a terminating zero to the string (we don't check for a zero in
-       the contents, let the user worry about that) */
-    str = buf;
-    left = (unsigned)len - 1;
-    if (left) do {
-        /* assure that something is in the output buffer */
-        if (state->x.have == 0 && gz_fetch(state) == -1)
-            return NULL;                /* error */
-        if (state->x.have == 0) {       /* end of file */
-            state->past = 1;            /* read past end */
-            break;                      /* return what we have */
-        }
-
-        /* look for end-of-line in current output buffer */
-        n = state->x.have > left ? left : state->x.have;
-        eol = memchr(state->x.next, '\n', n);
-        if (eol != NULL)
-            n = (unsigned)(eol - state->x.next) + 1;
-
-        /* copy through end-of-line, or remainder if not found */
-        memcpy(buf, state->x.next, n);
-        state->x.have -= n;
-        state->x.next += n;
-        state->x.pos += n;
-        left -= n;
-        buf += n;
-    } while (left && eol == NULL);
-
-    /* return terminated string, or if nothing, end of file */
-    if (buf == str)
-        return NULL;
-    buf[0] = 0;
-    return str;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzdirect(file)
-    gzFile file;
-{
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return 0;
-    state = (gz_statep)file;
-
-    /* if the state is not known, but we can find out, then do so (this is
-       mainly for right after a gzopen() or gzdopen()) */
-    if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)
-        (void)gz_look(state);
-
-    /* return 1 if transparent, 0 if processing a gzip stream */
-    return state->direct;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzclose_r(file)
-    gzFile file;
-{
-    int ret, err;
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-
-    /* check that we're reading */
-    if (state->mode != GZ_READ)
-        return Z_STREAM_ERROR;
-
-    /* free memory and close file */
-    if (state->size) {
-        inflateEnd(&(state->strm));
-        free(state->out);
-        free(state->in);
-    }
-    err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;
-    gz_error(state, Z_OK, NULL);
-    free(state->path);
-    ret = close(state->fd);
-    free(state);
-    return ret ? Z_ERRNO : err;
-}
diff -Nbaur gcc-4.8.1/zlib/gzwrite.c gcc-4.8.1-ppc/zlib/gzwrite.c
--- gcc-4.8.1/zlib/gzwrite.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/gzwrite.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,565 +0,0 @@
-/* gzwrite.c -- zlib functions for writing gzip files
- * Copyright (C) 2004, 2005, 2010, 2011, 2012 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "gzguts.h"
-
-/* Local functions */
-local int gz_init OF((gz_statep));
-local int gz_comp OF((gz_statep, int));
-local int gz_zero OF((gz_statep, z_off64_t));
-
-/* Initialize state for writing a gzip file.  Mark initialization by setting
-   state->size to non-zero.  Return -1 on failure or 0 on success. */
-local int gz_init(state)
-    gz_statep state;
-{
-    int ret;
-    z_streamp strm = &(state->strm);
-
-    /* allocate input buffer */
-    state->in = malloc(state->want);
-    if (state->in == NULL) {
-        gz_error(state, Z_MEM_ERROR, "out of memory");
-        return -1;
-    }
-
-    /* only need output buffer and deflate state if compressing */
-    if (!state->direct) {
-        /* allocate output buffer */
-        state->out = malloc(state->want);
-        if (state->out == NULL) {
-            free(state->in);
-            gz_error(state, Z_MEM_ERROR, "out of memory");
-            return -1;
-        }
-
-        /* allocate deflate memory, set up for gzip compression */
-        strm->zalloc = Z_NULL;
-        strm->zfree = Z_NULL;
-        strm->opaque = Z_NULL;
-        ret = deflateInit2(strm, state->level, Z_DEFLATED,
-                           MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);
-        if (ret != Z_OK) {
-            free(state->out);
-            free(state->in);
-            gz_error(state, Z_MEM_ERROR, "out of memory");
-            return -1;
-        }
-    }
-
-    /* mark state as initialized */
-    state->size = state->want;
-
-    /* initialize write buffer if compressing */
-    if (!state->direct) {
-        strm->avail_out = state->size;
-        strm->next_out = state->out;
-        state->x.next = strm->next_out;
-    }
-    return 0;
-}
-
-/* Compress whatever is at avail_in and next_in and write to the output file.
-   Return -1 if there is an error writing to the output file, otherwise 0.
-   flush is assumed to be a valid deflate() flush value.  If flush is Z_FINISH,
-   then the deflate() state is reset to start a new gzip stream.  If gz->direct
-   is true, then simply write to the output file without compressing, and
-   ignore flush. */
-local int gz_comp(state, flush)
-    gz_statep state;
-    int flush;
-{
-    int ret, got;
-    unsigned have;
-    z_streamp strm = &(state->strm);
-
-    /* allocate memory if this is the first time through */
-    if (state->size == 0 && gz_init(state) == -1)
-        return -1;
-
-    /* write directly if requested */
-    if (state->direct) {
-        got = write(state->fd, strm->next_in, strm->avail_in);
-        if (got < 0 || (unsigned)got != strm->avail_in) {
-            gz_error(state, Z_ERRNO, zstrerror());
-            return -1;
-        }
-        strm->avail_in = 0;
-        return 0;
-    }
-
-    /* run deflate() on provided input until it produces no more output */
-    ret = Z_OK;
-    do {
-        /* write out current buffer contents if full, or if flushing, but if
-           doing Z_FINISH then don't write until we get to Z_STREAM_END */
-        if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
-            (flush != Z_FINISH || ret == Z_STREAM_END))) {
-            have = (unsigned)(strm->next_out - state->x.next);
-            if (have && ((got = write(state->fd, state->x.next, have)) < 0 ||
-                         (unsigned)got != have)) {
-                gz_error(state, Z_ERRNO, zstrerror());
-                return -1;
-            }
-            if (strm->avail_out == 0) {
-                strm->avail_out = state->size;
-                strm->next_out = state->out;
-            }
-            state->x.next = strm->next_out;
-        }
-
-        /* compress */
-        have = strm->avail_out;
-        ret = deflate(strm, flush);
-        if (ret == Z_STREAM_ERROR) {
-            gz_error(state, Z_STREAM_ERROR,
-                      "internal error: deflate stream corrupt");
-            return -1;
-        }
-        have -= strm->avail_out;
-    } while (have);
-
-    /* if that completed a deflate stream, allow another to start */
-    if (flush == Z_FINISH)
-        deflateReset(strm);
-
-    /* all done, no errors */
-    return 0;
-}
-
-/* Compress len zeros to output.  Return -1 on error, 0 on success. */
-local int gz_zero(state, len)
-    gz_statep state;
-    z_off64_t len;
-{
-    int first;
-    unsigned n;
-    z_streamp strm = &(state->strm);
-
-    /* consume whatever's left in the input buffer */
-    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
-        return -1;
-
-    /* compress len zeros (len guaranteed > 0) */
-    first = 1;
-    while (len) {
-        n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
-            (unsigned)len : state->size;
-        if (first) {
-            memset(state->in, 0, n);
-            first = 0;
-        }
-        strm->avail_in = n;
-        strm->next_in = state->in;
-        state->x.pos += n;
-        if (gz_comp(state, Z_NO_FLUSH) == -1)
-            return -1;
-        len -= n;
-    }
-    return 0;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzwrite(file, buf, len)
-    gzFile file;
-    voidpc buf;
-    unsigned len;
-{
-    unsigned put = len;
-    unsigned n;
-    gz_statep state;
-    z_streamp strm;
-
-    /* get internal structure */
-    if (file == NULL)
-        return 0;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return 0;
-
-    /* since an int is returned, make sure len fits in one, otherwise return
-       with an error (this avoids the flaw in the interface) */
-    if ((int)len < 0) {
-        gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");
-        return 0;
-    }
-
-    /* if len is zero, avoid unnecessary operations */
-    if (len == 0)
-        return 0;
-
-    /* allocate memory if this is the first time through */
-    if (state->size == 0 && gz_init(state) == -1)
-        return 0;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return 0;
-    }
-
-    /* for small len, copy to input buffer, otherwise compress directly */
-    if (len < state->size) {
-        /* copy to input buffer, compress when full */
-        do {
-            if (strm->avail_in == 0)
-                strm->next_in = state->in;
-            n = state->size - strm->avail_in;
-            if (n > len)
-                n = len;
-            memcpy(strm->next_in + strm->avail_in, buf, n);
-            strm->avail_in += n;
-            state->x.pos += n;
-            buf = (char *)buf + n;
-            len -= n;
-            if (len && gz_comp(state, Z_NO_FLUSH) == -1)
-                return 0;
-        } while (len);
-    }
-    else {
-        /* consume whatever's left in the input buffer */
-        if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
-            return 0;
-
-        /* directly compress user buffer to file */
-        strm->avail_in = len;
-        strm->next_in = (voidp)buf;
-        state->x.pos += len;
-        if (gz_comp(state, Z_NO_FLUSH) == -1)
-            return 0;
-    }
-
-    /* input was all buffered or compressed (put will fit in int) */
-    return (int)put;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzputc(file, c)
-    gzFile file;
-    int c;
-{
-    unsigned char buf[1];
-    gz_statep state;
-    z_streamp strm;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return -1;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return -1;
-    }
-
-    /* try writing to input buffer for speed (state->size == 0 if buffer not
-       initialized) */
-    if (strm->avail_in < state->size) {
-        if (strm->avail_in == 0)
-            strm->next_in = state->in;
-        strm->next_in[strm->avail_in++] = c;
-        state->x.pos++;
-        return c & 0xff;
-    }
-
-    /* no room in buffer or not initialized, use gz_write() */
-    buf[0] = c;
-    if (gzwrite(file, buf, 1) != 1)
-        return -1;
-    return c & 0xff;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzputs(file, str)
-    gzFile file;
-    const char *str;
-{
-    int ret;
-    unsigned len;
-
-    /* write string */
-    len = (unsigned)strlen(str);
-    ret = gzwrite(file, str, len);
-    return ret == 0 && len != 0 ? -1 : ret;
-}
-
-#if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#include <stdarg.h>
-
-/* -- see zlib.h -- */
-int ZEXPORTVA gzprintf (gzFile file, const char *format, ...)
-{
-    int size, len;
-    gz_statep state;
-    z_streamp strm;
-    va_list va;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return 0;
-
-    /* make sure we have some buffer space */
-    if (state->size == 0 && gz_init(state) == -1)
-        return 0;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return 0;
-    }
-
-    /* consume whatever's left in the input buffer */
-    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
-        return 0;
-
-    /* do the printf() into the input buffer, put length in len */
-    size = (int)(state->size);
-    state->in[size - 1] = 0;
-    va_start(va, format);
-#ifdef NO_vsnprintf
-#  ifdef HAS_vsprintf_void
-    (void)vsprintf((char *)(state->in), format, va);
-    va_end(va);
-    for (len = 0; len < size; len++)
-        if (state->in[len] == 0) break;
-#  else
-    len = vsprintf((char *)(state->in), format, va);
-    va_end(va);
-#  endif
-#else
-#  ifdef HAS_vsnprintf_void
-    (void)vsnprintf((char *)(state->in), size, format, va);
-    va_end(va);
-    len = strlen((char *)(state->in));
-#  else
-    len = vsnprintf((char *)(state->in), size, format, va);
-    va_end(va);
-#  endif
-#endif
-
-    /* check that printf() results fit in buffer */
-    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)
-        return 0;
-
-    /* update buffer and position, defer compression until needed */
-    strm->avail_in = (unsigned)len;
-    strm->next_in = state->in;
-    state->x.pos += len;
-    return len;
-}
-
-#else /* !STDC && !Z_HAVE_STDARG_H */
-
-/* -- see zlib.h -- */
-int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
-                       a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
-    gzFile file;
-    const char *format;
-    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
-        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
-{
-    int size, len;
-    gz_statep state;
-    z_streamp strm;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-
-    /* check that can really pass pointer in ints */
-    if (sizeof(int) != sizeof(void *))
-        return 0;
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return 0;
-
-    /* make sure we have some buffer space */
-    if (state->size == 0 && gz_init(state) == -1)
-        return 0;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return 0;
-    }
-
-    /* consume whatever's left in the input buffer */
-    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
-        return 0;
-
-    /* do the printf() into the input buffer, put length in len */
-    size = (int)(state->size);
-    state->in[size - 1] = 0;
-#ifdef NO_snprintf
-#  ifdef HAS_sprintf_void
-    sprintf((char *)(state->in), format, a1, a2, a3, a4, a5, a6, a7, a8,
-            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
-    for (len = 0; len < size; len++)
-        if (state->in[len] == 0) break;
-#  else
-    len = sprintf((char *)(state->in), format, a1, a2, a3, a4, a5, a6, a7, a8,
-                  a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
-#  endif
-#else
-#  ifdef HAS_snprintf_void
-    snprintf((char *)(state->in), size, format, a1, a2, a3, a4, a5, a6, a7, a8,
-             a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
-    len = strlen((char *)(state->in));
-#  else
-    len = snprintf((char *)(state->in), size, format, a1, a2, a3, a4, a5, a6,
-                   a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18,
-                   a19, a20);
-#  endif
-#endif
-
-    /* check that printf() results fit in buffer */
-    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)
-        return 0;
-
-    /* update buffer and position, defer compression until needed */
-    strm->avail_in = (unsigned)len;
-    strm->next_in = state->in;
-    state->x.pos += len;
-    return len;
-}
-
-#endif
-
-/* -- see zlib.h -- */
-int ZEXPORT gzflush(file, flush)
-    gzFile file;
-    int flush;
-{
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return Z_STREAM_ERROR;
-
-    /* check flush parameter */
-    if (flush < 0 || flush > Z_FINISH)
-        return Z_STREAM_ERROR;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return -1;
-    }
-
-    /* compress remaining data with requested flush */
-    gz_comp(state, flush);
-    return state->err;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzsetparams(file, level, strategy)
-    gzFile file;
-    int level;
-    int strategy;
-{
-    gz_statep state;
-    z_streamp strm;
-
-    /* get internal structure */
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return Z_STREAM_ERROR;
-
-    /* if no change is requested, then do nothing */
-    if (level == state->level && strategy == state->strategy)
-        return Z_OK;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return -1;
-    }
-
-    /* change compression parameters for subsequent input */
-    if (state->size) {
-        /* flush previous input with previous parameters before changing */
-        if (strm->avail_in && gz_comp(state, Z_PARTIAL_FLUSH) == -1)
-            return state->err;
-        deflateParams(strm, level, strategy);
-    }
-    state->level = level;
-    state->strategy = strategy;
-    return Z_OK;
-}
-
-/* -- see zlib.h -- */
-int ZEXPORT gzclose_w(file)
-    gzFile file;
-{
-    int ret = Z_OK;
-    gz_statep state;
-
-    /* get internal structure */
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-
-    /* check that we're writing */
-    if (state->mode != GZ_WRITE)
-        return Z_STREAM_ERROR;
-
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            ret = state->err;
-    }
-
-    /* flush, free memory, and close file */
-    if (state->size) {
-        if (gz_comp(state, Z_FINISH) == -1)
-            ret = state->err;
-        if (!state->direct) {
-            (void)deflateEnd(&(state->strm));
-            free(state->out);
-        }
-        free(state->in);
-    }
-    gz_error(state, Z_OK, NULL);
-    free(state->path);
-    if (close(state->fd) == -1)
-        ret = Z_ERRNO;
-    free(state);
-    return ret;
-}
diff -Nbaur gcc-4.8.1/zlib/INDEX gcc-4.8.1-ppc/zlib/INDEX
--- gcc-4.8.1/zlib/INDEX	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/INDEX	1970-01-01 01:00:00.000000000 +0100
@@ -1,68 +0,0 @@
-CMakeLists.txt  cmake build file
-ChangeLog       history of changes
-FAQ             Frequently Asked Questions about zlib
-INDEX           this file
-Makefile        dummy Makefile that tells you to ./configure
-Makefile.in     template for Unix Makefile
-README          guess what
-configure       configure script for Unix
-make_vms.com    makefile for VMS
-test/example.c  zlib usages examples for build testing
-test/minigzip.c minimal gzip-like functionality for build testing
-test/infcover.c inf*.c code coverage for build coverage testing
-treebuild.xml   XML description of source file dependencies
-zconf.h.cmakein zconf.h template for cmake
-zconf.h.in      zconf.h template for configure
-zlib.3          Man page for zlib
-zlib.3.pdf      Man page in PDF format
-zlib.map        Linux symbol information
-zlib.pc.in      Template for pkg-config descriptor
-zlib.pc.cmakein zlib.pc template for cmake
-zlib2ansi       perl script to convert source files for C++ compilation
-
-amiga/          makefiles for Amiga SAS C
-as400/          makefiles for AS/400
-doc/            documentation for formats and algorithms
-msdos/          makefiles for MSDOS
-nintendods/     makefile for Nintendo DS
-old/            makefiles for various architectures and zlib documentation
-                files that have not yet been updated for zlib 1.2.x
-qnx/            makefiles for QNX
-watcom/         makefiles for OpenWatcom
-win32/          makefiles for Windows
-
-                zlib public header files (required for library use):
-zconf.h
-zlib.h
-
-                private source files used to build the zlib library:
-adler32.c
-compress.c
-crc32.c
-crc32.h
-deflate.c
-deflate.h
-gzclose.c
-gzguts.h
-gzlib.c
-gzread.c
-gzwrite.c
-infback.c
-inffast.c
-inffast.h
-inffixed.h
-inflate.c
-inflate.h
-inftrees.c
-inftrees.h
-trees.c
-trees.h
-uncompr.c
-zutil.c
-zutil.h
-
-                source files for sample programs
-See examples/README.examples
-
-                unsupported contributions by third parties
-See contrib/README.contrib
diff -Nbaur gcc-4.8.1/zlib/infback.c gcc-4.8.1-ppc/zlib/infback.c
--- gcc-4.8.1/zlib/infback.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/infback.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,640 +0,0 @@
-/* infback.c -- inflate using a call-back interface
- * Copyright (C) 1995-2011 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
-   This code is largely copied from inflate.c.  Normally either infback.o or
-   inflate.o would be linked into an application--not both.  The interface
-   with inffast.c is retained so that optimized assembler-coded versions of
-   inflate_fast() can be used with either inflate.c or infback.c.
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-
-/* function prototypes */
-local void fixedtables OF((struct inflate_state FAR *state));
-
-/*
-   strm provides memory allocation functions in zalloc and zfree, or
-   Z_NULL to use the library memory allocation functions.
-
-   windowBits is in the range 8..15, and window is a user-supplied
-   window and output buffer that is 2**windowBits bytes.
- */
-int ZEXPORT inflateBackInit_(strm, windowBits, window, version, stream_size)
-z_streamp strm;
-int windowBits;
-unsigned char FAR *window;
-const char *version;
-int stream_size;
-{
-    struct inflate_state FAR *state;
-
-    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
-        stream_size != (int)(sizeof(z_stream)))
-        return Z_VERSION_ERROR;
-    if (strm == Z_NULL || window == Z_NULL ||
-        windowBits < 8 || windowBits > 15)
-        return Z_STREAM_ERROR;
-    strm->msg = Z_NULL;                 /* in case we return an error */
-    if (strm->zalloc == (alloc_func)0) {
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-#endif
-    }
-    if (strm->zfree == (free_func)0)
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-    strm->zfree = zcfree;
-#endif
-    state = (struct inflate_state FAR *)ZALLOC(strm, 1,
-                                               sizeof(struct inflate_state));
-    if (state == Z_NULL) return Z_MEM_ERROR;
-    Tracev((stderr, "inflate: allocated\n"));
-    strm->state = (struct internal_state FAR *)state;
-    state->dmax = 32768U;
-    state->wbits = windowBits;
-    state->wsize = 1U << windowBits;
-    state->window = window;
-    state->wnext = 0;
-    state->whave = 0;
-    return Z_OK;
-}
-
-/*
-   Return state with length and distance decoding tables and index sizes set to
-   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
-   If BUILDFIXED is defined, then instead this routine builds the tables the
-   first time it's called, and returns those tables the first time and
-   thereafter.  This reduces the size of the code by about 2K bytes, in
-   exchange for a little execution time.  However, BUILDFIXED should not be
-   used for threaded applications, since the rewriting of the tables and virgin
-   may not be thread-safe.
- */
-local void fixedtables(state)
-struct inflate_state FAR *state;
-{
-#ifdef BUILDFIXED
-    static int virgin = 1;
-    static code *lenfix, *distfix;
-    static code fixed[544];
-
-    /* build fixed huffman tables if first call (may not be thread safe) */
-    if (virgin) {
-        unsigned sym, bits;
-        static code *next;
-
-        /* literal/length table */
-        sym = 0;
-        while (sym < 144) state->lens[sym++] = 8;
-        while (sym < 256) state->lens[sym++] = 9;
-        while (sym < 280) state->lens[sym++] = 7;
-        while (sym < 288) state->lens[sym++] = 8;
-        next = fixed;
-        lenfix = next;
-        bits = 9;
-        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
-
-        /* distance table */
-        sym = 0;
-        while (sym < 32) state->lens[sym++] = 5;
-        distfix = next;
-        bits = 5;
-        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
-
-        /* do this just once */
-        virgin = 0;
-    }
-#else /* !BUILDFIXED */
-#   include "inffixed.h"
-#endif /* BUILDFIXED */
-    state->lencode = lenfix;
-    state->lenbits = 9;
-    state->distcode = distfix;
-    state->distbits = 5;
-}
-
-/* Macros for inflateBack(): */
-
-/* Load returned state from inflate_fast() */
-#define LOAD() \
-    do { \
-        put = strm->next_out; \
-        left = strm->avail_out; \
-        next = strm->next_in; \
-        have = strm->avail_in; \
-        hold = state->hold; \
-        bits = state->bits; \
-    } while (0)
-
-/* Set state from registers for inflate_fast() */
-#define RESTORE() \
-    do { \
-        strm->next_out = put; \
-        strm->avail_out = left; \
-        strm->next_in = next; \
-        strm->avail_in = have; \
-        state->hold = hold; \
-        state->bits = bits; \
-    } while (0)
-
-/* Clear the input bit accumulator */
-#define INITBITS() \
-    do { \
-        hold = 0; \
-        bits = 0; \
-    } while (0)
-
-/* Assure that some input is available.  If input is requested, but denied,
-   then return a Z_BUF_ERROR from inflateBack(). */
-#define PULL() \
-    do { \
-        if (have == 0) { \
-            have = in(in_desc, &next); \
-            if (have == 0) { \
-                next = Z_NULL; \
-                ret = Z_BUF_ERROR; \
-                goto inf_leave; \
-            } \
-        } \
-    } while (0)
-
-/* Get a byte of input into the bit accumulator, or return from inflateBack()
-   with an error if there is no input available. */
-#define PULLBYTE() \
-    do { \
-        PULL(); \
-        have--; \
-        hold += (unsigned long)(*next++) << bits; \
-        bits += 8; \
-    } while (0)
-
-/* Assure that there are at least n bits in the bit accumulator.  If there is
-   not enough available input to do that, then return from inflateBack() with
-   an error. */
-#define NEEDBITS(n) \
-    do { \
-        while (bits < (unsigned)(n)) \
-            PULLBYTE(); \
-    } while (0)
-
-/* Return the low n bits of the bit accumulator (n < 16) */
-#define BITS(n) \
-    ((unsigned)hold & ((1U << (n)) - 1))
-
-/* Remove n bits from the bit accumulator */
-#define DROPBITS(n) \
-    do { \
-        hold >>= (n); \
-        bits -= (unsigned)(n); \
-    } while (0)
-
-/* Remove zero to seven bits as needed to go to a byte boundary */
-#define BYTEBITS() \
-    do { \
-        hold >>= bits & 7; \
-        bits -= bits & 7; \
-    } while (0)
-
-/* Assure that some output space is available, by writing out the window
-   if it's full.  If the write fails, return from inflateBack() with a
-   Z_BUF_ERROR. */
-#define ROOM() \
-    do { \
-        if (left == 0) { \
-            put = state->window; \
-            left = state->wsize; \
-            state->whave = left; \
-            if (out(out_desc, put, left)) { \
-                ret = Z_BUF_ERROR; \
-                goto inf_leave; \
-            } \
-        } \
-    } while (0)
-
-/*
-   strm provides the memory allocation functions and window buffer on input,
-   and provides information on the unused input on return.  For Z_DATA_ERROR
-   returns, strm will also provide an error message.
-
-   in() and out() are the call-back input and output functions.  When
-   inflateBack() needs more input, it calls in().  When inflateBack() has
-   filled the window with output, or when it completes with data in the
-   window, it calls out() to write out the data.  The application must not
-   change the provided input until in() is called again or inflateBack()
-   returns.  The application must not change the window/output buffer until
-   inflateBack() returns.
-
-   in() and out() are called with a descriptor parameter provided in the
-   inflateBack() call.  This parameter can be a structure that provides the
-   information required to do the read or write, as well as accumulated
-   information on the input and output such as totals and check values.
-
-   in() should return zero on failure.  out() should return non-zero on
-   failure.  If either in() or out() fails, than inflateBack() returns a
-   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it
-   was in() or out() that caused in the error.  Otherwise,  inflateBack()
-   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
-   error, or Z_MEM_ERROR if it could not allocate memory for the state.
-   inflateBack() can also return Z_STREAM_ERROR if the input parameters
-   are not correct, i.e. strm is Z_NULL or the state was not initialized.
- */
-int ZEXPORT inflateBack(strm, in, in_desc, out, out_desc)
-z_streamp strm;
-in_func in;
-void FAR *in_desc;
-out_func out;
-void FAR *out_desc;
-{
-    struct inflate_state FAR *state;
-    unsigned char FAR *next;    /* next input */
-    unsigned char FAR *put;     /* next output */
-    unsigned have, left;        /* available input and output */
-    unsigned long hold;         /* bit buffer */
-    unsigned bits;              /* bits in bit buffer */
-    unsigned copy;              /* number of stored or match bytes to copy */
-    unsigned char FAR *from;    /* where to copy match bytes from */
-    code here;                  /* current decoding table entry */
-    code last;                  /* parent table entry */
-    unsigned len;               /* length to copy for repeats, bits to drop */
-    int ret;                    /* return code */
-    static const unsigned short order[19] = /* permutation of code lengths */
-        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-
-    /* Check that the strm exists and that the state was initialized */
-    if (strm == Z_NULL || strm->state == Z_NULL)
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-
-    /* Reset the state */
-    strm->msg = Z_NULL;
-    state->mode = TYPE;
-    state->last = 0;
-    state->whave = 0;
-    next = strm->next_in;
-    have = next != Z_NULL ? strm->avail_in : 0;
-    hold = 0;
-    bits = 0;
-    put = state->window;
-    left = state->wsize;
-
-    /* Inflate until end of block marked as last */
-    for (;;)
-        switch (state->mode) {
-        case TYPE:
-            /* determine and dispatch block type */
-            if (state->last) {
-                BYTEBITS();
-                state->mode = DONE;
-                break;
-            }
-            NEEDBITS(3);
-            state->last = BITS(1);
-            DROPBITS(1);
-            switch (BITS(2)) {
-            case 0:                             /* stored block */
-                Tracev((stderr, "inflate:     stored block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = STORED;
-                break;
-            case 1:                             /* fixed block */
-                fixedtables(state);
-                Tracev((stderr, "inflate:     fixed codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = LEN;              /* decode codes */
-                break;
-            case 2:                             /* dynamic block */
-                Tracev((stderr, "inflate:     dynamic codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = TABLE;
-                break;
-            case 3:
-                strm->msg = (char *)"invalid block type";
-                state->mode = BAD;
-            }
-            DROPBITS(2);
-            break;
-
-        case STORED:
-            /* get and verify stored block length */
-            BYTEBITS();                         /* go to byte boundary */
-            NEEDBITS(32);
-            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
-                strm->msg = (char *)"invalid stored block lengths";
-                state->mode = BAD;
-                break;
-            }
-            state->length = (unsigned)hold & 0xffff;
-            Tracev((stderr, "inflate:       stored length %u\n",
-                    state->length));
-            INITBITS();
-
-            /* copy stored block from input to output */
-            while (state->length != 0) {
-                copy = state->length;
-                PULL();
-                ROOM();
-                if (copy > have) copy = have;
-                if (copy > left) copy = left;
-                zmemcpy(put, next, copy);
-                have -= copy;
-                next += copy;
-                left -= copy;
-                put += copy;
-                state->length -= copy;
-            }
-            Tracev((stderr, "inflate:       stored end\n"));
-            state->mode = TYPE;
-            break;
-
-        case TABLE:
-            /* get dynamic table entries descriptor */
-            NEEDBITS(14);
-            state->nlen = BITS(5) + 257;
-            DROPBITS(5);
-            state->ndist = BITS(5) + 1;
-            DROPBITS(5);
-            state->ncode = BITS(4) + 4;
-            DROPBITS(4);
-#ifndef PKZIP_BUG_WORKAROUND
-            if (state->nlen > 286 || state->ndist > 30) {
-                strm->msg = (char *)"too many length or distance symbols";
-                state->mode = BAD;
-                break;
-            }
-#endif
-            Tracev((stderr, "inflate:       table sizes ok\n"));
-
-            /* get code length code lengths (not a typo) */
-            state->have = 0;
-            while (state->have < state->ncode) {
-                NEEDBITS(3);
-                state->lens[order[state->have++]] = (unsigned short)BITS(3);
-                DROPBITS(3);
-            }
-            while (state->have < 19)
-                state->lens[order[state->have++]] = 0;
-            state->next = state->codes;
-            state->lencode = (code const FAR *)(state->next);
-            state->lenbits = 7;
-            ret = inflate_table(CODES, state->lens, 19, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid code lengths set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       code lengths ok\n"));
-
-            /* get length and distance code code lengths */
-            state->have = 0;
-            while (state->have < state->nlen + state->ndist) {
-                for (;;) {
-                    here = state->lencode[BITS(state->lenbits)];
-                    if ((unsigned)(here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                if (here.val < 16) {
-                    DROPBITS(here.bits);
-                    state->lens[state->have++] = here.val;
-                }
-                else {
-                    if (here.val == 16) {
-                        NEEDBITS(here.bits + 2);
-                        DROPBITS(here.bits);
-                        if (state->have == 0) {
-                            strm->msg = (char *)"invalid bit length repeat";
-                            state->mode = BAD;
-                            break;
-                        }
-                        len = (unsigned)(state->lens[state->have - 1]);
-                        copy = 3 + BITS(2);
-                        DROPBITS(2);
-                    }
-                    else if (here.val == 17) {
-                        NEEDBITS(here.bits + 3);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 3 + BITS(3);
-                        DROPBITS(3);
-                    }
-                    else {
-                        NEEDBITS(here.bits + 7);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 11 + BITS(7);
-                        DROPBITS(7);
-                    }
-                    if (state->have + copy > state->nlen + state->ndist) {
-                        strm->msg = (char *)"invalid bit length repeat";
-                        state->mode = BAD;
-                        break;
-                    }
-                    while (copy--)
-                        state->lens[state->have++] = (unsigned short)len;
-                }
-            }
-
-            /* handle error breaks in while */
-            if (state->mode == BAD) break;
-
-            /* check for end-of-block code (better have one) */
-            if (state->lens[256] == 0) {
-                strm->msg = (char *)"invalid code -- missing end-of-block";
-                state->mode = BAD;
-                break;
-            }
-
-            /* build code tables -- note: do not change the lenbits or distbits
-               values here (9 and 6) without reading the comments in inftrees.h
-               concerning the ENOUGH constants, which depend on those values */
-            state->next = state->codes;
-            state->lencode = (code const FAR *)(state->next);
-            state->lenbits = 9;
-            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid literal/lengths set";
-                state->mode = BAD;
-                break;
-            }
-            state->distcode = (code const FAR *)(state->next);
-            state->distbits = 6;
-            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
-                            &(state->next), &(state->distbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid distances set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       codes ok\n"));
-            state->mode = LEN;
-
-        case LEN:
-            /* use inflate_fast() if we have enough input and output */
-            if (have >= 6 && left >= 258) {
-                RESTORE();
-                if (state->whave < state->wsize)
-                    state->whave = state->wsize - left;
-                inflate_fast(strm, state->wsize);
-                LOAD();
-                break;
-            }
-
-            /* get a literal, length, or end-of-block code */
-            for (;;) {
-                here = state->lencode[BITS(state->lenbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if (here.op && (here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = state->lencode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-            }
-            DROPBITS(here.bits);
-            state->length = (unsigned)here.val;
-
-            /* process literal */
-            if (here.op == 0) {
-                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
-                        "inflate:         literal '%c'\n" :
-                        "inflate:         literal 0x%02x\n", here.val));
-                ROOM();
-                *put++ = (unsigned char)(state->length);
-                left--;
-                state->mode = LEN;
-                break;
-            }
-
-            /* process end of block */
-            if (here.op & 32) {
-                Tracevv((stderr, "inflate:         end of block\n"));
-                state->mode = TYPE;
-                break;
-            }
-
-            /* invalid code */
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid literal/length code";
-                state->mode = BAD;
-                break;
-            }
-
-            /* length code -- get extra bits, if any */
-            state->extra = (unsigned)(here.op) & 15;
-            if (state->extra != 0) {
-                NEEDBITS(state->extra);
-                state->length += BITS(state->extra);
-                DROPBITS(state->extra);
-            }
-            Tracevv((stderr, "inflate:         length %u\n", state->length));
-
-            /* get distance code */
-            for (;;) {
-                here = state->distcode[BITS(state->distbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if ((here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = state->distcode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-            }
-            DROPBITS(here.bits);
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid distance code";
-                state->mode = BAD;
-                break;
-            }
-            state->offset = (unsigned)here.val;
-
-            /* get distance extra bits, if any */
-            state->extra = (unsigned)(here.op) & 15;
-            if (state->extra != 0) {
-                NEEDBITS(state->extra);
-                state->offset += BITS(state->extra);
-                DROPBITS(state->extra);
-            }
-            if (state->offset > state->wsize - (state->whave < state->wsize ?
-                                                left : 0)) {
-                strm->msg = (char *)"invalid distance too far back";
-                state->mode = BAD;
-                break;
-            }
-            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
-
-            /* copy match from window to output */
-            do {
-                ROOM();
-                copy = state->wsize - state->offset;
-                if (copy < left) {
-                    from = put + copy;
-                    copy = left - copy;
-                }
-                else {
-                    from = put - state->offset;
-                    copy = left;
-                }
-                if (copy > state->length) copy = state->length;
-                state->length -= copy;
-                left -= copy;
-                do {
-                    *put++ = *from++;
-                } while (--copy);
-            } while (state->length != 0);
-            break;
-
-        case DONE:
-            /* inflate stream terminated properly -- write leftover output */
-            ret = Z_STREAM_END;
-            if (left < state->wsize) {
-                if (out(out_desc, state->window, state->wsize - left))
-                    ret = Z_BUF_ERROR;
-            }
-            goto inf_leave;
-
-        case BAD:
-            ret = Z_DATA_ERROR;
-            goto inf_leave;
-
-        default:                /* can't happen, but makes compilers happy */
-            ret = Z_STREAM_ERROR;
-            goto inf_leave;
-        }
-
-    /* Return unused input */
-  inf_leave:
-    strm->next_in = next;
-    strm->avail_in = have;
-    return ret;
-}
-
-int ZEXPORT inflateBackEnd(strm)
-z_streamp strm;
-{
-    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
-        return Z_STREAM_ERROR;
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-    Tracev((stderr, "inflate: end\n"));
-    return Z_OK;
-}
diff -Nbaur gcc-4.8.1/zlib/inffast.c gcc-4.8.1-ppc/zlib/inffast.c
--- gcc-4.8.1/zlib/inffast.c	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/inffast.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,340 +0,0 @@
-/* inffast.c -- fast decoding
- * Copyright (C) 1995-2008, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-
-#ifndef ASMINF
-
-/* Allow machine dependent optimization for post-increment or pre-increment.
-   Based on testing to date,
-   Pre-increment preferred for:
-   - PowerPC G3 (Adler)
-   - MIPS R5000 (Randers-Pehrson)
-   Post-increment preferred for:
-   - none
-   No measurable difference:
-   - Pentium III (Anderson)
-   - M68060 (Nikl)
- */
-#ifdef POSTINC
-#  define OFF 0
-#  define PUP(a) *(a)++
-#else
-#  define OFF 1
-#  define PUP(a) *++(a)
-#endif
-
-/*
-   Decode literal, length, and distance codes and write out the resulting
-   literal and match bytes until either not enough input or output is
-   available, an end-of-block is encountered, or a data error is encountered.
-   When large enough input and output buffers are supplied to inflate(), for
-   example, a 16K input buffer and a 64K output buffer, more than 95% of the
-   inflate execution time is spent in this routine.
-
-   Entry assumptions:
-
-        state->mode == LEN
-        strm->avail_in >= 6
-        strm->avail_out >= 258
-        start >= strm->avail_out
-        state->bits < 8
-
-   On return, state->mode is one of:
-
-        LEN -- ran out of enough output space or enough available input
-        TYPE -- reached end of block code, inflate() to interpret next block
-        BAD -- error in block data
-
-   Notes:
-
-    - The maximum input bits used by a length/distance pair is 15 bits for the
-      length code, 5 bits for the length extra, 15 bits for the distance code,
-      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
-      Therefore if strm->avail_in >= 6, then there is enough input to avoid
-      checking for available input while decoding.
-
-    - The maximum bytes that a single length/distance pair can output is 258
-      bytes, which is the maximum length that can be coded.  inflate_fast()
-      requires strm->avail_out >= 258 for each loop to avoid checking for
-      output space.
- */
-void ZLIB_INTERNAL inflate_fast(strm, start)
-z_streamp strm;
-unsigned start;         /* inflate()'s starting value for strm->avail_out */
-{
-    struct inflate_state FAR *state;
-    unsigned char FAR *in;      /* local strm->next_in */
-    unsigned char FAR *last;    /* while in < last, enough input available */
-    unsigned char FAR *out;     /* local strm->next_out */
-    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
-    unsigned char FAR *end;     /* while out < end, enough space available */
-#ifdef INFLATE_STRICT
-    unsigned dmax;              /* maximum distance from zlib header */
-#endif
-    unsigned wsize;             /* window size or zero if not using window */
-    unsigned whave;             /* valid bytes in the window */
-    unsigned wnext;             /* window write index */
-    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
-    unsigned long hold;         /* local strm->hold */
-    unsigned bits;              /* local strm->bits */
-    code const FAR *lcode;      /* local strm->lencode */
-    code const FAR *dcode;      /* local strm->distcode */
-    unsigned lmask;             /* mask for first level of length codes */
-    unsigned dmask;             /* mask for first level of distance codes */
-    code here;                  /* retrieved table entry */
-    unsigned op;                /* code bits, operation, extra bits, or */
-                                /*  window position, window bytes to copy */
-    unsigned len;               /* match length, unused bytes */
-    unsigned dist;              /* match distance */
-    unsigned char FAR *from;    /* where to copy match from */
-
-    /* copy state to local variables */
-    state = (struct inflate_state FAR *)strm->state;
-    in = strm->next_in - OFF;
-    last = in + (strm->avail_in - 5);
-    out = strm->next_out - OFF;
-    beg = out - (start - strm->avail_out);
-    end = out + (strm->avail_out - 257);
-#ifdef INFLATE_STRICT
-    dmax = state->dmax;
-#endif
-    wsize = state->wsize;
-    whave = state->whave;
-    wnext = state->wnext;
-    window = state->window;
-    hold = state->hold;
-    bits = state->bits;
-    lcode = state->lencode;
-    dcode = state->distcode;
-    lmask = (1U << state->lenbits) - 1;
-    dmask = (1U << state->distbits) - 1;
-
-    /* decode literals and length/distances until end-of-block or not enough
-       input data or output space */
-    do {
-        if (bits < 15) {
-            hold += (unsigned long)(PUP(in)) << bits;
-            bits += 8;
-            hold += (unsigned long)(PUP(in)) << bits;
-            bits += 8;
-        }
-        here = lcode[hold & lmask];
-      dolen:
-        op = (unsigned)(here.bits);
-        hold >>= op;
-        bits -= op;
-        op = (unsigned)(here.op);
-        if (op == 0) {                          /* literal */
-            Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
-                    "inflate:         literal '%c'\n" :
-                    "inflate:         literal 0x%02x\n", here.val));
-            PUP(out) = (unsigned char)(here.val);
-        }
-        else if (op & 16) {                     /* length base */
-            len = (unsigned)(here.val);
-            op &= 15;                           /* number of extra bits */
-            if (op) {
-                if (bits < op) {
-                    hold += (unsigned long)(PUP(in)) << bits;
-                    bits += 8;
-                }
-                len += (unsigned)hold & ((1U << op) - 1);
-                hold >>= op;
-                bits -= op;
-            }
-            Tracevv((stderr, "inflate:         length %u\n", len));
-            if (bits < 15) {
-                hold += (unsigned long)(PUP(in)) << bits;
-                bits += 8;
-                hold += (unsigned long)(PUP(in)) << bits;
-                bits += 8;
-            }
-            here = dcode[hold & dmask];
-          dodist:
-            op = (unsigned)(here.bits);
-            hold >>= op;
-            bits -= op;
-            op = (unsigned)(here.op);
-            if (op & 16) {                      /* distance base */
-                dist = (unsigned)(here.val);
-                op &= 15;                       /* number of extra bits */
-                if (bits < op) {
-                    hold += (unsigned long)(PUP(in)) << bits;
-                    bits += 8;
-                    if (bits < op) {
-                        hold += (unsigned long)(PUP(in)) << bits;
-                        bits += 8;
-                    }
-                }
-                dist += (unsigned)hold & ((1U << op) - 1);
-#ifdef INFLATE_STRICT
-                if (dist > dmax) {
-                    strm->msg = (char *)"invalid distance too far back";
-                    state->mode = BAD;
-                    break;
-                }
-#endif
-                hold >>= op;
-                bits -= op;
-                Tracevv((stderr, "inflate:         distance %u\n", dist));
-                op = (unsigned)(out - beg);     /* max distance in output */
-                if (dist > op) {                /* see if copy from window */
-                    op = dist - op;             /* distance back in window */
-                    if (op > whave) {
-                        if (state->sane) {
-                            strm->msg =
-                                (char *)"invalid distance too far back";
-                            state->mode = BAD;
-                            break;
-                        }
-#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-                        if (len <= op - whave) {
-                            do {
-                                PUP(out) = 0;
-                            } while (--len);
-                            continue;
-                        }
-                        len -= op - whave;
-                        do {
-                            PUP(out) = 0;
-                        } while (--op > whave);
-                        if (op == 0) {
-                            from = out - dist;
-                            do {
-                                PUP(out) = PUP(from);
-                            } while (--len);
-                            continue;
-                        }
-#endif
-                    }
-                    from = window - OFF;
-                    if (wnext == 0) {           /* very common case */
-                        from += wsize - op;
-                        if (op < len) {         /* some from window */
-                            len -= op;
-                            do {
-                                PUP(out) = PUP(from);
-                            } while (--op);
-                            from = out - dist;  /* rest from output */
-                        }
-                    }
-                    else if (wnext < op) {      /* wrap around window */
-                        from += wsize + wnext - op;
-                        op -= wnext;
-                        if (op < len) {         /* some from end of window */
-                            len -= op;
-                            do {
-                                PUP(out) = PUP(from);
-                            } while (--op);
-                            from = window - OFF;
-                            if (wnext < len) {  /* some from start of window */
-                                op = wnext;
-                                len -= op;
-                                do {
-                                    PUP(out) = PUP(from);
-                                } while (--op);
-                                from = out - dist;      /* rest from output */
-                            }
-                        }
-                    }
-                    else {                      /* contiguous in window */
-                        from += wnext - op;
-                        if (op < len) {         /* some from window */
-                            len -= op;
-                            do {
-                                PUP(out) = PUP(from);
-                            } while (--op);
-                            from = out - dist;  /* rest from output */
-                        }
-                    }
-                    while (len > 2) {
-                        PUP(out) = PUP(from);
-                        PUP(out) = PUP(from);
-                        PUP(out) = PUP(from);
-                        len -= 3;
-                    }
-                    if (len) {
-                        PUP(out) = PUP(from);
-                        if (len > 1)
-                            PUP(out) = PUP(from);
-                    }
-                }
-                else {
-                    from = out - dist;          /* copy direct from output */
-                    do {                        /* minimum length is three */
-                        PUP(out) = PUP(from);
-                        PUP(out) = PUP(from);
-                        PUP(out) = PUP(from);
-                        len -= 3;
-                    } while (len > 2);
-                    if (len) {
-                        PUP(out) = PUP(from);
-                        if (len > 1)
-                            PUP(out) = PUP(from);
-                    }
-                }
-            }
-            else if ((op & 64) == 0) {          /* 2nd level distance code */
-                here = dcode[here.val + (hold & ((1U << op) - 1))];
-                goto dodist;
-            }
-            else {
-                strm->msg = (char *)"invalid distance code";
-                state->mode = BAD;
-                break;
-            }
-        }
-        else if ((op & 64) == 0) {              /* 2nd level length code */
-            here = lcode[here.val + (hold & ((1U << op) - 1))];
-            goto dolen;
-        }
-        else if (op & 32) {                     /* end-of-block */
-            Tracevv((stderr, "inflate:         end of block\n"));
-            state->mode = TYPE;
-            break;
-        }
-        else {
-            strm->msg = (char *)"invalid literal/length code";
-            state->mode = BAD;
-            break;
-        }
-    } while (in < last && out < end);
-
-    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
-    len = bits >> 3;
-    in -= len;
-    bits -= len << 3;
-    hold &= (1U << bits) - 1;
-
-    /* update state and return */
-    strm->next_in = in + OFF;
-    strm->next_out = out + OFF;
-    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
-    strm->avail_out = (unsigned)(out < end ?
-                                 257 + (end - out) : 257 - (out - end));
-    state->hold = hold;
-    state->bits = bits;
-    return;
-}
-
-/*
-   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
-   - Using bit fields for code structure
-   - Different op definition to avoid & for extra bits (do & for table bits)
-   - Three separate decoding do-loops for direct, window, and wnext == 0
-   - Special case for distance > 1 copies to do overlapped load and store copy
-   - Explicit branch predictions (based on measured branch probabilities)
-   - Deferring match copy and interspersed it with decoding subsequent codes
-   - Swapping literal/length else
-   - Swapping window/direct else
-   - Larger unrolled copy loops (three is about right)
-   - Moving len -= 3 statement into middle of loop
- */
-
-#endif /* !ASMINF */
diff -Nbaur gcc-4.8.1/zlib/inffast.h gcc-4.8.1-ppc/zlib/inffast.h
--- gcc-4.8.1/zlib/inffast.h	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/inffast.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
-/* inffast.h -- header to use inffast.c
- * Copyright (C) 1995-2003, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-void ZLIB_INTERNAL inflate_fast OF((z_streamp strm, unsigned start));
diff -Nbaur gcc-4.8.1/zlib/inffixed.h gcc-4.8.1-ppc/zlib/inffixed.h
--- gcc-4.8.1/zlib/inffixed.h	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/inffixed.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,94 +0,0 @@
-    /* inffixed.h -- table for decoding fixed codes
-     * Generated automatically by makefixed().
-     */
-
-    /* WARNING: this file should *not* be used by applications.
-       It is part of the implementation of this library and is
-       subject to change. Applications should only use zlib.h.
-     */
-
-    static const code lenfix[512] = {
-        {96,7,0},{0,8,80},{0,8,16},{20,8,115},{18,7,31},{0,8,112},{0,8,48},
-        {0,9,192},{16,7,10},{0,8,96},{0,8,32},{0,9,160},{0,8,0},{0,8,128},
-        {0,8,64},{0,9,224},{16,7,6},{0,8,88},{0,8,24},{0,9,144},{19,7,59},
-        {0,8,120},{0,8,56},{0,9,208},{17,7,17},{0,8,104},{0,8,40},{0,9,176},
-        {0,8,8},{0,8,136},{0,8,72},{0,9,240},{16,7,4},{0,8,84},{0,8,20},
-        {21,8,227},{19,7,43},{0,8,116},{0,8,52},{0,9,200},{17,7,13},{0,8,100},
-        {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},{16,7,8},
-        {0,8,92},{0,8,28},{0,9,152},{20,7,83},{0,8,124},{0,8,60},{0,9,216},
-        {18,7,23},{0,8,108},{0,8,44},{0,9,184},{0,8,12},{0,8,140},{0,8,76},
-        {0,9,248},{16,7,3},{0,8,82},{0,8,18},{21,8,163},{19,7,35},{0,8,114},
-        {0,8,50},{0,9,196},{17,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},
-        {0,8,130},{0,8,66},{0,9,228},{16,7,7},{0,8,90},{0,8,26},{0,9,148},
-        {20,7,67},{0,8,122},{0,8,58},{0,9,212},{18,7,19},{0,8,106},{0,8,42},
-        {0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},{16,7,5},{0,8,86},
-        {0,8,22},{64,8,0},{19,7,51},{0,8,118},{0,8,54},{0,9,204},{17,7,15},
-        {0,8,102},{0,8,38},{0,9,172},{0,8,6},{0,8,134},{0,8,70},{0,9,236},
-        {16,7,9},{0,8,94},{0,8,30},{0,9,156},{20,7,99},{0,8,126},{0,8,62},
-        {0,9,220},{18,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},
-        {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{21,8,131},{18,7,31},
-        {0,8,113},{0,8,49},{0,9,194},{16,7,10},{0,8,97},{0,8,33},{0,9,162},
-        {0,8,1},{0,8,129},{0,8,65},{0,9,226},{16,7,6},{0,8,89},{0,8,25},
-        {0,9,146},{19,7,59},{0,8,121},{0,8,57},{0,9,210},{17,7,17},{0,8,105},
-        {0,8,41},{0,9,178},{0,8,9},{0,8,137},{0,8,73},{0,9,242},{16,7,4},
-        {0,8,85},{0,8,21},{16,8,258},{19,7,43},{0,8,117},{0,8,53},{0,9,202},
-        {17,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},{0,8,69},
-        {0,9,234},{16,7,8},{0,8,93},{0,8,29},{0,9,154},{20,7,83},{0,8,125},
-        {0,8,61},{0,9,218},{18,7,23},{0,8,109},{0,8,45},{0,9,186},{0,8,13},
-        {0,8,141},{0,8,77},{0,9,250},{16,7,3},{0,8,83},{0,8,19},{21,8,195},
-        {19,7,35},{0,8,115},{0,8,51},{0,9,198},{17,7,11},{0,8,99},{0,8,35},
-        {0,9,166},{0,8,3},{0,8,131},{0,8,67},{0,9,230},{16,7,7},{0,8,91},
-        {0,8,27},{0,9,150},{20,7,67},{0,8,123},{0,8,59},{0,9,214},{18,7,19},
-        {0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},{0,8,75},{0,9,246},
-        {16,7,5},{0,8,87},{0,8,23},{64,8,0},{19,7,51},{0,8,119},{0,8,55},
-        {0,9,206},{17,7,15},{0,8,103},{0,8,39},{0,9,174},{0,8,7},{0,8,135},
-        {0,8,71},{0,9,238},{16,7,9},{0,8,95},{0,8,31},{0,9,158},{20,7,99},
-        {0,8,127},{0,8,63},{0,9,222},{18,7,27},{0,8,111},{0,8,47},{0,9,190},
-        {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},{0,8,16},
-        {20,8,115},{18,7,31},{0,8,112},{0,8,48},{0,9,193},{16,7,10},{0,8,96},
-        {0,8,32},{0,9,161},{0,8,0},{0,8,128},{0,8,64},{0,9,225},{16,7,6},
-        {0,8,88},{0,8,24},{0,9,145},{19,7,59},{0,8,120},{0,8,56},{0,9,209},
-        {17,7,17},{0,8,104},{0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},
-        {0,9,241},{16,7,4},{0,8,84},{0,8,20},{21,8,227},{19,7,43},{0,8,116},
-        {0,8,52},{0,9,201},{17,7,13},{0,8,100},{0,8,36},{0,9,169},{0,8,4},
-        {0,8,132},{0,8,68},{0,9,233},{16,7,8},{0,8,92},{0,8,28},{0,9,153},
-        {20,7,83},{0,8,124},{0,8,60},{0,9,217},{18,7,23},{0,8,108},{0,8,44},
-        {0,9,185},{0,8,12},{0,8,140},{0,8,76},{0,9,249},{16,7,3},{0,8,82},
-        {0,8,18},{21,8,163},{19,7,35},{0,8,114},{0,8,50},{0,9,197},{17,7,11},
-        {0,8,98},{0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},
-        {16,7,7},{0,8,90},{0,8,26},{0,9,149},{20,7,67},{0,8,122},{0,8,58},
-        {0,9,213},{18,7,19},{0,8,106},{0,8,42},{0,9,181},{0,8,10},{0,8,138},
-        {0,8,74},{0,9,245},{16,7,5},{0,8,86},{0,8,22},{64,8,0},{19,7,51},
-        {0,8,118},{0,8,54},{0,9,205},{17,7,15},{0,8,102},{0,8,38},{0,9,173},
-        {0,8,6},{0,8,134},{0,8,70},{0,9,237},{16,7,9},{0,8,94},{0,8,30},
-        {0,9,157},{20,7,99},{0,8,126},{0,8,62},{0,9,221},{18,7,27},{0,8,110},
-        {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},{96,7,0},
-        {0,8,81},{0,8,17},{21,8,131},{18,7,31},{0,8,113},{0,8,49},{0,9,195},
-        {16,7,10},{0,8,97},{0,8,33},{0,9,163},{0,8,1},{0,8,129},{0,8,65},
-        {0,9,227},{16,7,6},{0,8,89},{0,8,25},{0,9,147},{19,7,59},{0,8,121},
-        {0,8,57},{0,9,211},{17,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},
-        {0,8,137},{0,8,73},{0,9,243},{16,7,4},{0,8,85},{0,8,21},{16,8,258},
-        {19,7,43},{0,8,117},{0,8,53},{0,9,203},{17,7,13},{0,8,101},{0,8,37},
-        {0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},{16,7,8},{0,8,93},
-        {0,8,29},{0,9,155},{20,7,83},{0,8,125},{0,8,61},{0,9,219},{18,7,23},
-        {0,8,109},{0,8,45},{0,9,187},{0,8,13},{0,8,141},{0,8,77},{0,9,251},
-        {16,7,3},{0,8,83},{0,8,19},{21,8,195},{19,7,35},{0,8,115},{0,8,51},
-        {0,9,199},{17,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},
-        {0,8,67},{0,9,231},{16,7,7},{0,8,91},{0,8,27},{0,9,151},{20,7,67},
-        {0,8,123},{0,8,59},{0,9,215},{18,7,19},{0,8,107},{0,8,43},{0,9,183},
-        {0,8,11},{0,8,139},{0,8,75},{0,9,247},{16,7,5},{0,8,87},{0,8,23},
-        {64,8,0},{19,7,51},{0,8,119},{0,8,55},{0,9,207},{17,7,15},{0,8,103},
-        {0,8,39},{0,9,175},{0,8,7},{0,8,135},{0,8,71},{0,9,239},{16,7,9},
-        {0,8,95},{0,8,31},{0,9,159},{20,7,99},{0,8,127},{0,8,63},{0,9,223},
-        {18,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},{0,8,79},
-        {0,9,255}
-    };
-
-    static const code distfix[32] = {
-        {16,5,1},{23,5,257},{19,5,17},{27,5,4097},{17,5,5},{25,5,1025},
-        {21,5,65},{29,5,16385},{16,5,3},{24,5,513},{20,5,33},{28,5,8193},
-        {18,5,9},{26,5,2049},{22,5,129},{64,5,0},{16,5,2},{23,5,385},
-        {19,5,25},{27,5,6145},{17,5,7},{25,5,1537},{21,5,97},{29,5,24577},
-        {16,5,4},{24,5,769},{20,5,49},{28,5,12289},{18,5,13},{26,5,3073},
-        {22,5,193},{64,5,0}
-    };
diff -Nbaur gcc-4.8.1/zlib/inflate.c gcc-4.8.1-ppc/zlib/inflate.c
--- gcc-4.8.1/zlib/inflate.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/inflate.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1496 +0,0 @@
-/* inflate.c -- zlib decompression
- * Copyright (C) 1995-2012 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- * Change history:
- *
- * 1.2.beta0    24 Nov 2002
- * - First version -- complete rewrite of inflate to simplify code, avoid
- *   creation of window when not needed, minimize use of window when it is
- *   needed, make inffast.c even faster, implement gzip decoding, and to
- *   improve code readability and style over the previous zlib inflate code
- *
- * 1.2.beta1    25 Nov 2002
- * - Use pointers for available input and output checking in inffast.c
- * - Remove input and output counters in inffast.c
- * - Change inffast.c entry and loop from avail_in >= 7 to >= 6
- * - Remove unnecessary second byte pull from length extra in inffast.c
- * - Unroll direct copy to three copies per loop in inffast.c
- *
- * 1.2.beta2    4 Dec 2002
- * - Change external routine names to reduce potential conflicts
- * - Correct filename to inffixed.h for fixed tables in inflate.c
- * - Make hbuf[] unsigned char to match parameter type in inflate.c
- * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)
- *   to avoid negation problem on Alphas (64 bit) in inflate.c
- *
- * 1.2.beta3    22 Dec 2002
- * - Add comments on state->bits assertion in inffast.c
- * - Add comments on op field in inftrees.h
- * - Fix bug in reuse of allocated window after inflateReset()
- * - Remove bit fields--back to byte structure for speed
- * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
- * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
- * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
- * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
- * - Use local copies of stream next and avail values, as well as local bit
- *   buffer and bit count in inflate()--for speed when inflate_fast() not used
- *
- * 1.2.beta4    1 Jan 2003
- * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
- * - Move a comment on output buffer sizes from inffast.c to inflate.c
- * - Add comments in inffast.c to introduce the inflate_fast() routine
- * - Rearrange window copies in inflate_fast() for speed and simplification
- * - Unroll last copy for window match in inflate_fast()
- * - Use local copies of window variables in inflate_fast() for speed
- * - Pull out common wnext == 0 case for speed in inflate_fast()
- * - Make op and len in inflate_fast() unsigned for consistency
- * - Add FAR to lcode and dcode declarations in inflate_fast()
- * - Simplified bad distance check in inflate_fast()
- * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
- *   source file infback.c to provide a call-back interface to inflate for
- *   programs like gzip and unzip -- uses window as output buffer to avoid
- *   window copying
- *
- * 1.2.beta5    1 Jan 2003
- * - Improved inflateBack() interface to allow the caller to provide initial
- *   input in strm.
- * - Fixed stored blocks bug in inflateBack()
- *
- * 1.2.beta6    4 Jan 2003
- * - Added comments in inffast.c on effectiveness of POSTINC
- * - Typecasting all around to reduce compiler warnings
- * - Changed loops from while (1) or do {} while (1) to for (;;), again to
- *   make compilers happy
- * - Changed type of window in inflateBackInit() to unsigned char *
- *
- * 1.2.beta7    27 Jan 2003
- * - Changed many types to unsigned or unsigned short to avoid warnings
- * - Added inflateCopy() function
- *
- * 1.2.0        9 Mar 2003
- * - Changed inflateBack() interface to provide separate opaque descriptors
- *   for the in() and out() functions
- * - Changed inflateBack() argument and in_func typedef to swap the length
- *   and buffer address return values for the input function
- * - Check next_in and next_out for Z_NULL on entry to inflate()
- *
- * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-
-#ifdef MAKEFIXED
-#  ifndef BUILDFIXED
-#    define BUILDFIXED
-#  endif
-#endif
-
-/* function prototypes */
-local void fixedtables OF((struct inflate_state FAR *state));
-local int updatewindow OF((z_streamp strm, unsigned out));
-#ifdef BUILDFIXED
-   void makefixed OF((void));
-#endif
-local unsigned syncsearch OF((unsigned FAR *have, unsigned char FAR *buf,
-                              unsigned len));
-
-int ZEXPORT inflateResetKeep(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    strm->total_in = strm->total_out = state->total = 0;
-    strm->msg = Z_NULL;
-    if (state->wrap)        /* to support ill-conceived Java test suite */
-        strm->adler = state->wrap & 1;
-    state->mode = HEAD;
-    state->last = 0;
-    state->havedict = 0;
-    state->dmax = 32768U;
-    state->head = Z_NULL;
-    state->hold = 0;
-    state->bits = 0;
-    state->lencode = state->distcode = state->next = state->codes;
-    state->sane = 1;
-    state->back = -1;
-    Tracev((stderr, "inflate: reset\n"));
-    return Z_OK;
-}
-
-int ZEXPORT inflateReset(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    state->wsize = 0;
-    state->whave = 0;
-    state->wnext = 0;
-    return inflateResetKeep(strm);
-}
-
-int ZEXPORT inflateReset2(strm, windowBits)
-z_streamp strm;
-int windowBits;
-{
-    int wrap;
-    struct inflate_state FAR *state;
-
-    /* get the state */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-
-    /* extract wrap request from windowBits parameter */
-    if (windowBits < 0) {
-        wrap = 0;
-        windowBits = -windowBits;
-    }
-    else {
-        wrap = (windowBits >> 4) + 1;
-#ifdef GUNZIP
-        if (windowBits < 48)
-            windowBits &= 15;
-#endif
-    }
-
-    /* set number of window bits, free window if different */
-    if (windowBits && (windowBits < 8 || windowBits > 15))
-        return Z_STREAM_ERROR;
-    if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {
-        ZFREE(strm, state->window);
-        state->window = Z_NULL;
-    }
-
-    /* update state and reset the rest of it */
-    state->wrap = wrap;
-    state->wbits = (unsigned)windowBits;
-    return inflateReset(strm);
-}
-
-int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
-z_streamp strm;
-int windowBits;
-const char *version;
-int stream_size;
-{
-    int ret;
-    struct inflate_state FAR *state;
-
-    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
-        stream_size != (int)(sizeof(z_stream)))
-        return Z_VERSION_ERROR;
-    if (strm == Z_NULL) return Z_STREAM_ERROR;
-    strm->msg = Z_NULL;                 /* in case we return an error */
-    if (strm->zalloc == (alloc_func)0) {
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-#endif
-    }
-    if (strm->zfree == (free_func)0)
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zfree = zcfree;
-#endif
-    state = (struct inflate_state FAR *)
-            ZALLOC(strm, 1, sizeof(struct inflate_state));
-    if (state == Z_NULL) return Z_MEM_ERROR;
-    Tracev((stderr, "inflate: allocated\n"));
-    strm->state = (struct internal_state FAR *)state;
-    state->window = Z_NULL;
-    ret = inflateReset2(strm, windowBits);
-    if (ret != Z_OK) {
-        ZFREE(strm, state);
-        strm->state = Z_NULL;
-    }
-    return ret;
-}
-
-int ZEXPORT inflateInit_(strm, version, stream_size)
-z_streamp strm;
-const char *version;
-int stream_size;
-{
-    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
-}
-
-int ZEXPORT inflatePrime(strm, bits, value)
-z_streamp strm;
-int bits;
-int value;
-{
-    struct inflate_state FAR *state;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (bits < 0) {
-        state->hold = 0;
-        state->bits = 0;
-        return Z_OK;
-    }
-    if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;
-    value &= (1L << bits) - 1;
-    state->hold += value << state->bits;
-    state->bits += bits;
-    return Z_OK;
-}
-
-/*
-   Return state with length and distance decoding tables and index sizes set to
-   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
-   If BUILDFIXED is defined, then instead this routine builds the tables the
-   first time it's called, and returns those tables the first time and
-   thereafter.  This reduces the size of the code by about 2K bytes, in
-   exchange for a little execution time.  However, BUILDFIXED should not be
-   used for threaded applications, since the rewriting of the tables and virgin
-   may not be thread-safe.
- */
-local void fixedtables(state)
-struct inflate_state FAR *state;
-{
-#ifdef BUILDFIXED
-    static int virgin = 1;
-    static code *lenfix, *distfix;
-    static code fixed[544];
-
-    /* build fixed huffman tables if first call (may not be thread safe) */
-    if (virgin) {
-        unsigned sym, bits;
-        static code *next;
-
-        /* literal/length table */
-        sym = 0;
-        while (sym < 144) state->lens[sym++] = 8;
-        while (sym < 256) state->lens[sym++] = 9;
-        while (sym < 280) state->lens[sym++] = 7;
-        while (sym < 288) state->lens[sym++] = 8;
-        next = fixed;
-        lenfix = next;
-        bits = 9;
-        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
-
-        /* distance table */
-        sym = 0;
-        while (sym < 32) state->lens[sym++] = 5;
-        distfix = next;
-        bits = 5;
-        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
-
-        /* do this just once */
-        virgin = 0;
-    }
-#else /* !BUILDFIXED */
-#   include "inffixed.h"
-#endif /* BUILDFIXED */
-    state->lencode = lenfix;
-    state->lenbits = 9;
-    state->distcode = distfix;
-    state->distbits = 5;
-}
-
-#ifdef MAKEFIXED
-#include <stdio.h>
-
-/*
-   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
-   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
-   those tables to stdout, which would be piped to inffixed.h.  A small program
-   can simply call makefixed to do this:
-
-    void makefixed(void);
-
-    int main(void)
-    {
-        makefixed();
-        return 0;
-    }
-
-   Then that can be linked with zlib built with MAKEFIXED defined and run:
-
-    a.out > inffixed.h
- */
-void makefixed()
-{
-    unsigned low, size;
-    struct inflate_state state;
-
-    fixedtables(&state);
-    puts("    /* inffixed.h -- table for decoding fixed codes");
-    puts("     * Generated automatically by makefixed().");
-    puts("     */");
-    puts("");
-    puts("    /* WARNING: this file should *not* be used by applications.");
-    puts("       It is part of the implementation of this library and is");
-    puts("       subject to change. Applications should only use zlib.h.");
-    puts("     */");
-    puts("");
-    size = 1U << 9;
-    printf("    static const code lenfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 7) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", (low & 127) == 99 ? 64 : state.lencode[low].op,
-               state.lencode[low].bits, state.lencode[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-    size = 1U << 5;
-    printf("\n    static const code distfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 6) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", state.distcode[low].op, state.distcode[low].bits,
-               state.distcode[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-}
-#endif /* MAKEFIXED */
-
-/*
-   Update the window with the last wsize (normally 32K) bytes written before
-   returning.  If window does not exist yet, create it.  This is only called
-   when a window is already in use, or when output has been written during this
-   inflate call, but the end of the deflate stream has not been reached yet.
-   It is also called to create a window for dictionary data when a dictionary
-   is loaded.
-
-   Providing output buffers larger than 32K to inflate() should provide a speed
-   advantage, since only the last 32K of output is copied to the sliding window
-   upon return from inflate(), and since all distances after the first 32K of
-   output will fall in the output data, making match copies simpler and faster.
-   The advantage may be dependent on the size of the processor's data caches.
- */
-local int updatewindow(strm, out)
-z_streamp strm;
-unsigned out;
-{
-    struct inflate_state FAR *state;
-    unsigned copy, dist;
-
-    state = (struct inflate_state FAR *)strm->state;
-
-    /* if it hasn't been done already, allocate space for the window */
-    if (state->window == Z_NULL) {
-        state->window = (unsigned char FAR *)
-                        ZALLOC(strm, 1U << state->wbits,
-                               sizeof(unsigned char));
-        if (state->window == Z_NULL) return 1;
-    }
-
-    /* if window not in use yet, initialize */
-    if (state->wsize == 0) {
-        state->wsize = 1U << state->wbits;
-        state->wnext = 0;
-        state->whave = 0;
-    }
-
-    /* copy state->wsize or less output bytes into the circular window */
-    copy = out - strm->avail_out;
-    if (copy >= state->wsize) {
-        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
-        state->wnext = 0;
-        state->whave = state->wsize;
-    }
-    else {
-        dist = state->wsize - state->wnext;
-        if (dist > copy) dist = copy;
-        zmemcpy(state->window + state->wnext, strm->next_out - copy, dist);
-        copy -= dist;
-        if (copy) {
-            zmemcpy(state->window, strm->next_out - copy, copy);
-            state->wnext = copy;
-            state->whave = state->wsize;
-        }
-        else {
-            state->wnext += dist;
-            if (state->wnext == state->wsize) state->wnext = 0;
-            if (state->whave < state->wsize) state->whave += dist;
-        }
-    }
-    return 0;
-}
-
-/* Macros for inflate(): */
-
-/* check function to use adler32() for zlib or crc32() for gzip */
-#ifdef GUNZIP
-#  define UPDATE(check, buf, len) \
-    (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
-#else
-#  define UPDATE(check, buf, len) adler32(check, buf, len)
-#endif
-
-/* check macros for header crc */
-#ifdef GUNZIP
-#  define CRC2(check, word) \
-    do { \
-        hbuf[0] = (unsigned char)(word); \
-        hbuf[1] = (unsigned char)((word) >> 8); \
-        check = crc32(check, hbuf, 2); \
-    } while (0)
-
-#  define CRC4(check, word) \
-    do { \
-        hbuf[0] = (unsigned char)(word); \
-        hbuf[1] = (unsigned char)((word) >> 8); \
-        hbuf[2] = (unsigned char)((word) >> 16); \
-        hbuf[3] = (unsigned char)((word) >> 24); \
-        check = crc32(check, hbuf, 4); \
-    } while (0)
-#endif
-
-/* Load registers with state in inflate() for speed */
-#define LOAD() \
-    do { \
-        put = strm->next_out; \
-        left = strm->avail_out; \
-        next = strm->next_in; \
-        have = strm->avail_in; \
-        hold = state->hold; \
-        bits = state->bits; \
-    } while (0)
-
-/* Restore state from registers in inflate() */
-#define RESTORE() \
-    do { \
-        strm->next_out = put; \
-        strm->avail_out = left; \
-        strm->next_in = next; \
-        strm->avail_in = have; \
-        state->hold = hold; \
-        state->bits = bits; \
-    } while (0)
-
-/* Clear the input bit accumulator */
-#define INITBITS() \
-    do { \
-        hold = 0; \
-        bits = 0; \
-    } while (0)
-
-/* Get a byte of input into the bit accumulator, or return from inflate()
-   if there is no input available. */
-#define PULLBYTE() \
-    do { \
-        if (have == 0) goto inf_leave; \
-        have--; \
-        hold += (unsigned long)(*next++) << bits; \
-        bits += 8; \
-    } while (0)
-
-/* Assure that there are at least n bits in the bit accumulator.  If there is
-   not enough available input to do that, then return from inflate(). */
-#define NEEDBITS(n) \
-    do { \
-        while (bits < (unsigned)(n)) \
-            PULLBYTE(); \
-    } while (0)
-
-/* Return the low n bits of the bit accumulator (n < 16) */
-#define BITS(n) \
-    ((unsigned)hold & ((1U << (n)) - 1))
-
-/* Remove n bits from the bit accumulator */
-#define DROPBITS(n) \
-    do { \
-        hold >>= (n); \
-        bits -= (unsigned)(n); \
-    } while (0)
-
-/* Remove zero to seven bits as needed to go to a byte boundary */
-#define BYTEBITS() \
-    do { \
-        hold >>= bits & 7; \
-        bits -= bits & 7; \
-    } while (0)
-
-/*
-   inflate() uses a state machine to process as much input data and generate as
-   much output data as possible before returning.  The state machine is
-   structured roughly as follows:
-
-    for (;;) switch (state) {
-    ...
-    case STATEn:
-        if (not enough input data or output space to make progress)
-            return;
-        ... make progress ...
-        state = STATEm;
-        break;
-    ...
-    }
-
-   so when inflate() is called again, the same case is attempted again, and
-   if the appropriate resources are provided, the machine proceeds to the
-   next state.  The NEEDBITS() macro is usually the way the state evaluates
-   whether it can proceed or should return.  NEEDBITS() does the return if
-   the requested bits are not available.  The typical use of the BITS macros
-   is:
-
-        NEEDBITS(n);
-        ... do something with BITS(n) ...
-        DROPBITS(n);
-
-   where NEEDBITS(n) either returns from inflate() if there isn't enough
-   input left to load n bits into the accumulator, or it continues.  BITS(n)
-   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
-   the low n bits off the accumulator.  INITBITS() clears the accumulator
-   and sets the number of available bits to zero.  BYTEBITS() discards just
-   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
-   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.
-
-   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
-   if there is no input available.  The decoding of variable length codes uses
-   PULLBYTE() directly in order to pull just enough bytes to decode the next
-   code, and no more.
-
-   Some states loop until they get enough input, making sure that enough
-   state information is maintained to continue the loop where it left off
-   if NEEDBITS() returns in the loop.  For example, want, need, and keep
-   would all have to actually be part of the saved state in case NEEDBITS()
-   returns:
-
-    case STATEw:
-        while (want < need) {
-            NEEDBITS(n);
-            keep[want++] = BITS(n);
-            DROPBITS(n);
-        }
-        state = STATEx;
-    case STATEx:
-
-   As shown above, if the next state is also the next case, then the break
-   is omitted.
-
-   A state may also return if there is not enough output space available to
-   complete that state.  Those states are copying stored data, writing a
-   literal byte, and copying a matching string.
-
-   When returning, a "goto inf_leave" is used to update the total counters,
-   update the check value, and determine whether any progress has been made
-   during that inflate() call in order to return the proper return code.
-   Progress is defined as a change in either strm->avail_in or strm->avail_out.
-   When there is a window, goto inf_leave will update the window with the last
-   output written.  If a goto inf_leave occurs in the middle of decompression
-   and there is no window currently, goto inf_leave will create one and copy
-   output to the window for the next call of inflate().
-
-   In this implementation, the flush parameter of inflate() only affects the
-   return code (per zlib.h).  inflate() always writes as much as possible to
-   strm->next_out, given the space available and the provided input--the effect
-   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
-   the allocation of and copying into a sliding window until necessary, which
-   provides the effect documented in zlib.h for Z_FINISH when the entire input
-   stream available.  So the only thing the flush parameter actually does is:
-   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
-   will return Z_BUF_ERROR if it has not reached the end of the stream.
- */
-
-int ZEXPORT inflate(strm, flush)
-z_streamp strm;
-int flush;
-{
-    struct inflate_state FAR *state;
-    unsigned char FAR *next;    /* next input */
-    unsigned char FAR *put;     /* next output */
-    unsigned have, left;        /* available input and output */
-    unsigned long hold;         /* bit buffer */
-    unsigned bits;              /* bits in bit buffer */
-    unsigned in, out;           /* save starting available input and output */
-    unsigned copy;              /* number of stored or match bytes to copy */
-    unsigned char FAR *from;    /* where to copy match bytes from */
-    code here;                  /* current decoding table entry */
-    code last;                  /* parent table entry */
-    unsigned len;               /* length to copy for repeats, bits to drop */
-    int ret;                    /* return code */
-#ifdef GUNZIP
-    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
-#endif
-    static const unsigned short order[19] = /* permutation of code lengths */
-        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-
-    if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
-        (strm->next_in == Z_NULL && strm->avail_in != 0))
-        return Z_STREAM_ERROR;
-
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
-    LOAD();
-    in = have;
-    out = left;
-    ret = Z_OK;
-    for (;;)
-        switch (state->mode) {
-        case HEAD:
-            if (state->wrap == 0) {
-                state->mode = TYPEDO;
-                break;
-            }
-            NEEDBITS(16);
-#ifdef GUNZIP
-            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
-                state->check = crc32(0L, Z_NULL, 0);
-                CRC2(state->check, hold);
-                INITBITS();
-                state->mode = FLAGS;
-                break;
-            }
-            state->flags = 0;           /* expect zlib header */
-            if (state->head != Z_NULL)
-                state->head->done = -1;
-            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
-#else
-            if (
-#endif
-                ((BITS(8) << 8) + (hold >> 8)) % 31) {
-                strm->msg = (char *)"incorrect header check";
-                state->mode = BAD;
-                break;
-            }
-            if (BITS(4) != Z_DEFLATED) {
-                strm->msg = (char *)"unknown compression method";
-                state->mode = BAD;
-                break;
-            }
-            DROPBITS(4);
-            len = BITS(4) + 8;
-            if (state->wbits == 0)
-                state->wbits = len;
-            else if (len > state->wbits) {
-                strm->msg = (char *)"invalid window size";
-                state->mode = BAD;
-                break;
-            }
-            state->dmax = 1U << len;
-            Tracev((stderr, "inflate:   zlib header ok\n"));
-            strm->adler = state->check = adler32(0L, Z_NULL, 0);
-            state->mode = hold & 0x200 ? DICTID : TYPE;
-            INITBITS();
-            break;
-#ifdef GUNZIP
-        case FLAGS:
-            NEEDBITS(16);
-            state->flags = (int)(hold);
-            if ((state->flags & 0xff) != Z_DEFLATED) {
-                strm->msg = (char *)"unknown compression method";
-                state->mode = BAD;
-                break;
-            }
-            if (state->flags & 0xe000) {
-                strm->msg = (char *)"unknown header flags set";
-                state->mode = BAD;
-                break;
-            }
-            if (state->head != Z_NULL)
-                state->head->text = (int)((hold >> 8) & 1);
-            if (state->flags & 0x0200) CRC2(state->check, hold);
-            INITBITS();
-            state->mode = TIME;
-        case TIME:
-            NEEDBITS(32);
-            if (state->head != Z_NULL)
-                state->head->time = hold;
-            if (state->flags & 0x0200) CRC4(state->check, hold);
-            INITBITS();
-            state->mode = OS;
-        case OS:
-            NEEDBITS(16);
-            if (state->head != Z_NULL) {
-                state->head->xflags = (int)(hold & 0xff);
-                state->head->os = (int)(hold >> 8);
-            }
-            if (state->flags & 0x0200) CRC2(state->check, hold);
-            INITBITS();
-            state->mode = EXLEN;
-        case EXLEN:
-            if (state->flags & 0x0400) {
-                NEEDBITS(16);
-                state->length = (unsigned)(hold);
-                if (state->head != Z_NULL)
-                    state->head->extra_len = (unsigned)hold;
-                if (state->flags & 0x0200) CRC2(state->check, hold);
-                INITBITS();
-            }
-            else if (state->head != Z_NULL)
-                state->head->extra = Z_NULL;
-            state->mode = EXTRA;
-        case EXTRA:
-            if (state->flags & 0x0400) {
-                copy = state->length;
-                if (copy > have) copy = have;
-                if (copy) {
-                    if (state->head != Z_NULL &&
-                        state->head->extra != Z_NULL) {
-                        len = state->head->extra_len - state->length;
-                        zmemcpy(state->head->extra + len, next,
-                                len + copy > state->head->extra_max ?
-                                state->head->extra_max - len : copy);
-                    }
-                    if (state->flags & 0x0200)
-                        state->check = crc32(state->check, next, copy);
-                    have -= copy;
-                    next += copy;
-                    state->length -= copy;
-                }
-                if (state->length) goto inf_leave;
-            }
-            state->length = 0;
-            state->mode = NAME;
-        case NAME:
-            if (state->flags & 0x0800) {
-                if (have == 0) goto inf_leave;
-                copy = 0;
-                do {
-                    len = (unsigned)(next[copy++]);
-                    if (state->head != Z_NULL &&
-                            state->head->name != Z_NULL &&
-                            state->length < state->head->name_max)
-                        state->head->name[state->length++] = len;
-                } while (len && copy < have);
-                if (state->flags & 0x0200)
-                    state->check = crc32(state->check, next, copy);
-                have -= copy;
-                next += copy;
-                if (len) goto inf_leave;
-            }
-            else if (state->head != Z_NULL)
-                state->head->name = Z_NULL;
-            state->length = 0;
-            state->mode = COMMENT;
-        case COMMENT:
-            if (state->flags & 0x1000) {
-                if (have == 0) goto inf_leave;
-                copy = 0;
-                do {
-                    len = (unsigned)(next[copy++]);
-                    if (state->head != Z_NULL &&
-                            state->head->comment != Z_NULL &&
-                            state->length < state->head->comm_max)
-                        state->head->comment[state->length++] = len;
-                } while (len && copy < have);
-                if (state->flags & 0x0200)
-                    state->check = crc32(state->check, next, copy);
-                have -= copy;
-                next += copy;
-                if (len) goto inf_leave;
-            }
-            else if (state->head != Z_NULL)
-                state->head->comment = Z_NULL;
-            state->mode = HCRC;
-        case HCRC:
-            if (state->flags & 0x0200) {
-                NEEDBITS(16);
-                if (hold != (state->check & 0xffff)) {
-                    strm->msg = (char *)"header crc mismatch";
-                    state->mode = BAD;
-                    break;
-                }
-                INITBITS();
-            }
-            if (state->head != Z_NULL) {
-                state->head->hcrc = (int)((state->flags >> 9) & 1);
-                state->head->done = 1;
-            }
-            strm->adler = state->check = crc32(0L, Z_NULL, 0);
-            state->mode = TYPE;
-            break;
-#endif
-        case DICTID:
-            NEEDBITS(32);
-            strm->adler = state->check = ZSWAP32(hold);
-            INITBITS();
-            state->mode = DICT;
-        case DICT:
-            if (state->havedict == 0) {
-                RESTORE();
-                return Z_NEED_DICT;
-            }
-            strm->adler = state->check = adler32(0L, Z_NULL, 0);
-            state->mode = TYPE;
-        case TYPE:
-            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
-        case TYPEDO:
-            if (state->last) {
-                BYTEBITS();
-                state->mode = CHECK;
-                break;
-            }
-            NEEDBITS(3);
-            state->last = BITS(1);
-            DROPBITS(1);
-            switch (BITS(2)) {
-            case 0:                             /* stored block */
-                Tracev((stderr, "inflate:     stored block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = STORED;
-                break;
-            case 1:                             /* fixed block */
-                fixedtables(state);
-                Tracev((stderr, "inflate:     fixed codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = LEN_;             /* decode codes */
-                if (flush == Z_TREES) {
-                    DROPBITS(2);
-                    goto inf_leave;
-                }
-                break;
-            case 2:                             /* dynamic block */
-                Tracev((stderr, "inflate:     dynamic codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = TABLE;
-                break;
-            case 3:
-                strm->msg = (char *)"invalid block type";
-                state->mode = BAD;
-            }
-            DROPBITS(2);
-            break;
-        case STORED:
-            BYTEBITS();                         /* go to byte boundary */
-            NEEDBITS(32);
-            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
-                strm->msg = (char *)"invalid stored block lengths";
-                state->mode = BAD;
-                break;
-            }
-            state->length = (unsigned)hold & 0xffff;
-            Tracev((stderr, "inflate:       stored length %u\n",
-                    state->length));
-            INITBITS();
-            state->mode = COPY_;
-            if (flush == Z_TREES) goto inf_leave;
-        case COPY_:
-            state->mode = COPY;
-        case COPY:
-            copy = state->length;
-            if (copy) {
-                if (copy > have) copy = have;
-                if (copy > left) copy = left;
-                if (copy == 0) goto inf_leave;
-                zmemcpy(put, next, copy);
-                have -= copy;
-                next += copy;
-                left -= copy;
-                put += copy;
-                state->length -= copy;
-                break;
-            }
-            Tracev((stderr, "inflate:       stored end\n"));
-            state->mode = TYPE;
-            break;
-        case TABLE:
-            NEEDBITS(14);
-            state->nlen = BITS(5) + 257;
-            DROPBITS(5);
-            state->ndist = BITS(5) + 1;
-            DROPBITS(5);
-            state->ncode = BITS(4) + 4;
-            DROPBITS(4);
-#ifndef PKZIP_BUG_WORKAROUND
-            if (state->nlen > 286 || state->ndist > 30) {
-                strm->msg = (char *)"too many length or distance symbols";
-                state->mode = BAD;
-                break;
-            }
-#endif
-            Tracev((stderr, "inflate:       table sizes ok\n"));
-            state->have = 0;
-            state->mode = LENLENS;
-        case LENLENS:
-            while (state->have < state->ncode) {
-                NEEDBITS(3);
-                state->lens[order[state->have++]] = (unsigned short)BITS(3);
-                DROPBITS(3);
-            }
-            while (state->have < 19)
-                state->lens[order[state->have++]] = 0;
-            state->next = state->codes;
-            state->lencode = (code const FAR *)(state->next);
-            state->lenbits = 7;
-            ret = inflate_table(CODES, state->lens, 19, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid code lengths set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       code lengths ok\n"));
-            state->have = 0;
-            state->mode = CODELENS;
-        case CODELENS:
-            while (state->have < state->nlen + state->ndist) {
-                for (;;) {
-                    here = state->lencode[BITS(state->lenbits)];
-                    if ((unsigned)(here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                if (here.val < 16) {
-                    DROPBITS(here.bits);
-                    state->lens[state->have++] = here.val;
-                }
-                else {
-                    if (here.val == 16) {
-                        NEEDBITS(here.bits + 2);
-                        DROPBITS(here.bits);
-                        if (state->have == 0) {
-                            strm->msg = (char *)"invalid bit length repeat";
-                            state->mode = BAD;
-                            break;
-                        }
-                        len = state->lens[state->have - 1];
-                        copy = 3 + BITS(2);
-                        DROPBITS(2);
-                    }
-                    else if (here.val == 17) {
-                        NEEDBITS(here.bits + 3);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 3 + BITS(3);
-                        DROPBITS(3);
-                    }
-                    else {
-                        NEEDBITS(here.bits + 7);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 11 + BITS(7);
-                        DROPBITS(7);
-                    }
-                    if (state->have + copy > state->nlen + state->ndist) {
-                        strm->msg = (char *)"invalid bit length repeat";
-                        state->mode = BAD;
-                        break;
-                    }
-                    while (copy--)
-                        state->lens[state->have++] = (unsigned short)len;
-                }
-            }
-
-            /* handle error breaks in while */
-            if (state->mode == BAD) break;
-
-            /* check for end-of-block code (better have one) */
-            if (state->lens[256] == 0) {
-                strm->msg = (char *)"invalid code -- missing end-of-block";
-                state->mode = BAD;
-                break;
-            }
-
-            /* build code tables -- note: do not change the lenbits or distbits
-               values here (9 and 6) without reading the comments in inftrees.h
-               concerning the ENOUGH constants, which depend on those values */
-            state->next = state->codes;
-            state->lencode = (code const FAR *)(state->next);
-            state->lenbits = 9;
-            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid literal/lengths set";
-                state->mode = BAD;
-                break;
-            }
-            state->distcode = (code const FAR *)(state->next);
-            state->distbits = 6;
-            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
-                            &(state->next), &(state->distbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid distances set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       codes ok\n"));
-            state->mode = LEN_;
-            if (flush == Z_TREES) goto inf_leave;
-        case LEN_:
-            state->mode = LEN;
-        case LEN:
-            if (have >= 6 && left >= 258) {
-                RESTORE();
-                inflate_fast(strm, out);
-                LOAD();
-                if (state->mode == TYPE)
-                    state->back = -1;
-                break;
-            }
-            state->back = 0;
-            for (;;) {
-                here = state->lencode[BITS(state->lenbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if (here.op && (here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = state->lencode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-                state->back += last.bits;
-            }
-            DROPBITS(here.bits);
-            state->back += here.bits;
-            state->length = (unsigned)here.val;
-            if ((int)(here.op) == 0) {
-                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
-                        "inflate:         literal '%c'\n" :
-                        "inflate:         literal 0x%02x\n", here.val));
-                state->mode = LIT;
-                break;
-            }
-            if (here.op & 32) {
-                Tracevv((stderr, "inflate:         end of block\n"));
-                state->back = -1;
-                state->mode = TYPE;
-                break;
-            }
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid literal/length code";
-                state->mode = BAD;
-                break;
-            }
-            state->extra = (unsigned)(here.op) & 15;
-            state->mode = LENEXT;
-        case LENEXT:
-            if (state->extra) {
-                NEEDBITS(state->extra);
-                state->length += BITS(state->extra);
-                DROPBITS(state->extra);
-                state->back += state->extra;
-            }
-            Tracevv((stderr, "inflate:         length %u\n", state->length));
-            state->was = state->length;
-            state->mode = DIST;
-        case DIST:
-            for (;;) {
-                here = state->distcode[BITS(state->distbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if ((here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = state->distcode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-                state->back += last.bits;
-            }
-            DROPBITS(here.bits);
-            state->back += here.bits;
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid distance code";
-                state->mode = BAD;
-                break;
-            }
-            state->offset = (unsigned)here.val;
-            state->extra = (unsigned)(here.op) & 15;
-            state->mode = DISTEXT;
-        case DISTEXT:
-            if (state->extra) {
-                NEEDBITS(state->extra);
-                state->offset += BITS(state->extra);
-                DROPBITS(state->extra);
-                state->back += state->extra;
-            }
-#ifdef INFLATE_STRICT
-            if (state->offset > state->dmax) {
-                strm->msg = (char *)"invalid distance too far back";
-                state->mode = BAD;
-                break;
-            }
-#endif
-            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
-            state->mode = MATCH;
-        case MATCH:
-            if (left == 0) goto inf_leave;
-            copy = out - left;
-            if (state->offset > copy) {         /* copy from window */
-                copy = state->offset - copy;
-                if (copy > state->whave) {
-                    if (state->sane) {
-                        strm->msg = (char *)"invalid distance too far back";
-                        state->mode = BAD;
-                        break;
-                    }
-#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-                    Trace((stderr, "inflate.c too far\n"));
-                    copy -= state->whave;
-                    if (copy > state->length) copy = state->length;
-                    if (copy > left) copy = left;
-                    left -= copy;
-                    state->length -= copy;
-                    do {
-                        *put++ = 0;
-                    } while (--copy);
-                    if (state->length == 0) state->mode = LEN;
-                    break;
-#endif
-                }
-                if (copy > state->wnext) {
-                    copy -= state->wnext;
-                    from = state->window + (state->wsize - copy);
-                }
-                else
-                    from = state->window + (state->wnext - copy);
-                if (copy > state->length) copy = state->length;
-            }
-            else {                              /* copy from output */
-                from = put - state->offset;
-                copy = state->length;
-            }
-            if (copy > left) copy = left;
-            left -= copy;
-            state->length -= copy;
-            do {
-                *put++ = *from++;
-            } while (--copy);
-            if (state->length == 0) state->mode = LEN;
-            break;
-        case LIT:
-            if (left == 0) goto inf_leave;
-            *put++ = (unsigned char)(state->length);
-            left--;
-            state->mode = LEN;
-            break;
-        case CHECK:
-            if (state->wrap) {
-                NEEDBITS(32);
-                out -= left;
-                strm->total_out += out;
-                state->total += out;
-                if (out)
-                    strm->adler = state->check =
-                        UPDATE(state->check, put - out, out);
-                out = left;
-                if ((
-#ifdef GUNZIP
-                     state->flags ? hold :
-#endif
-                     ZSWAP32(hold)) != state->check) {
-                    strm->msg = (char *)"incorrect data check";
-                    state->mode = BAD;
-                    break;
-                }
-                INITBITS();
-                Tracev((stderr, "inflate:   check matches trailer\n"));
-            }
-#ifdef GUNZIP
-            state->mode = LENGTH;
-        case LENGTH:
-            if (state->wrap && state->flags) {
-                NEEDBITS(32);
-                if (hold != (state->total & 0xffffffffUL)) {
-                    strm->msg = (char *)"incorrect length check";
-                    state->mode = BAD;
-                    break;
-                }
-                INITBITS();
-                Tracev((stderr, "inflate:   length matches trailer\n"));
-            }
-#endif
-            state->mode = DONE;
-        case DONE:
-            ret = Z_STREAM_END;
-            goto inf_leave;
-        case BAD:
-            ret = Z_DATA_ERROR;
-            goto inf_leave;
-        case MEM:
-            return Z_MEM_ERROR;
-        case SYNC:
-        default:
-            return Z_STREAM_ERROR;
-        }
-
-    /*
-       Return from inflate(), updating the total counts and the check value.
-       If there was no progress during the inflate() call, return a buffer
-       error.  Call updatewindow() to create and/or update the window state.
-       Note: a memory error from inflate() is non-recoverable.
-     */
-  inf_leave:
-    RESTORE();
-    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
-            (state->mode < CHECK || flush != Z_FINISH)))
-        if (updatewindow(strm, out)) {
-            state->mode = MEM;
-            return Z_MEM_ERROR;
-        }
-    in -= strm->avail_in;
-    out -= strm->avail_out;
-    strm->total_in += in;
-    strm->total_out += out;
-    state->total += out;
-    if (state->wrap && out)
-        strm->adler = state->check =
-            UPDATE(state->check, strm->next_out - out, out);
-    strm->data_type = state->bits + (state->last ? 64 : 0) +
-                      (state->mode == TYPE ? 128 : 0) +
-                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
-    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
-        ret = Z_BUF_ERROR;
-    return ret;
-}
-
-int ZEXPORT inflateEnd(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->window != Z_NULL) ZFREE(strm, state->window);
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-    Tracev((stderr, "inflate: end\n"));
-    return Z_OK;
-}
-
-int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
-z_streamp strm;
-const Bytef *dictionary;
-uInt dictLength;
-{
-    struct inflate_state FAR *state;
-    unsigned long dictid;
-    unsigned char *next;
-    unsigned avail;
-    int ret;
-
-    /* check state */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->wrap != 0 && state->mode != DICT)
-        return Z_STREAM_ERROR;
-
-    /* check for correct dictionary identifier */
-    if (state->mode == DICT) {
-        dictid = adler32(0L, Z_NULL, 0);
-        dictid = adler32(dictid, dictionary, dictLength);
-        if (dictid != state->check)
-            return Z_DATA_ERROR;
-    }
-
-    /* copy dictionary to window using updatewindow(), which will amend the
-       existing dictionary if appropriate */
-    next = strm->next_out;
-    avail = strm->avail_out;
-    strm->next_out = (Bytef *)dictionary + dictLength;
-    strm->avail_out = 0;
-    ret = updatewindow(strm, dictLength);
-    strm->avail_out = avail;
-    strm->next_out = next;
-    if (ret) {
-        state->mode = MEM;
-        return Z_MEM_ERROR;
-    }
-    state->havedict = 1;
-    Tracev((stderr, "inflate:   dictionary set\n"));
-    return Z_OK;
-}
-
-int ZEXPORT inflateGetHeader(strm, head)
-z_streamp strm;
-gz_headerp head;
-{
-    struct inflate_state FAR *state;
-
-    /* check state */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;
-
-    /* save header structure */
-    state->head = head;
-    head->done = 0;
-    return Z_OK;
-}
-
-/*
-   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
-   or when out of input.  When called, *have is the number of pattern bytes
-   found in order so far, in 0..3.  On return *have is updated to the new
-   state.  If on return *have equals four, then the pattern was found and the
-   return value is how many bytes were read including the last byte of the
-   pattern.  If *have is less than four, then the pattern has not been found
-   yet and the return value is len.  In the latter case, syncsearch() can be
-   called again with more data and the *have state.  *have is initialized to
-   zero for the first call.
- */
-local unsigned syncsearch(have, buf, len)
-unsigned FAR *have;
-unsigned char FAR *buf;
-unsigned len;
-{
-    unsigned got;
-    unsigned next;
-
-    got = *have;
-    next = 0;
-    while (next < len && got < 4) {
-        if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))
-            got++;
-        else if (buf[next])
-            got = 0;
-        else
-            got = 4 - got;
-        next++;
-    }
-    *have = got;
-    return next;
-}
-
-int ZEXPORT inflateSync(strm)
-z_streamp strm;
-{
-    unsigned len;               /* number of bytes to look at or looked at */
-    unsigned long in, out;      /* temporary to save total_in and total_out */
-    unsigned char buf[4];       /* to restore bit buffer to byte string */
-    struct inflate_state FAR *state;
-
-    /* check parameters */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;
-
-    /* if first time, start search in bit buffer */
-    if (state->mode != SYNC) {
-        state->mode = SYNC;
-        state->hold <<= state->bits & 7;
-        state->bits -= state->bits & 7;
-        len = 0;
-        while (state->bits >= 8) {
-            buf[len++] = (unsigned char)(state->hold);
-            state->hold >>= 8;
-            state->bits -= 8;
-        }
-        state->have = 0;
-        syncsearch(&(state->have), buf, len);
-    }
-
-    /* search available input */
-    len = syncsearch(&(state->have), strm->next_in, strm->avail_in);
-    strm->avail_in -= len;
-    strm->next_in += len;
-    strm->total_in += len;
-
-    /* return no joy or set up to restart inflate() on a new block */
-    if (state->have != 4) return Z_DATA_ERROR;
-    in = strm->total_in;  out = strm->total_out;
-    inflateReset(strm);
-    strm->total_in = in;  strm->total_out = out;
-    state->mode = TYPE;
-    return Z_OK;
-}
-
-/*
-   Returns true if inflate is currently at the end of a block generated by
-   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
-   implementation to provide an additional safety check. PPP uses
-   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
-   block. When decompressing, PPP checks that at the end of input packet,
-   inflate is waiting for these length bytes.
- */
-int ZEXPORT inflateSyncPoint(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    return state->mode == STORED && state->bits == 0;
-}
-
-int ZEXPORT inflateCopy(dest, source)
-z_streamp dest;
-z_streamp source;
-{
-    struct inflate_state FAR *state;
-    struct inflate_state FAR *copy;
-    unsigned char FAR *window;
-    unsigned wsize;
-
-    /* check input */
-    if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
-        source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)source->state;
-
-    /* allocate space */
-    copy = (struct inflate_state FAR *)
-           ZALLOC(source, 1, sizeof(struct inflate_state));
-    if (copy == Z_NULL) return Z_MEM_ERROR;
-    window = Z_NULL;
-    if (state->window != Z_NULL) {
-        window = (unsigned char FAR *)
-                 ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
-        if (window == Z_NULL) {
-            ZFREE(source, copy);
-            return Z_MEM_ERROR;
-        }
-    }
-
-    /* copy state */
-    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
-    zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));
-    if (state->lencode >= state->codes &&
-        state->lencode <= state->codes + ENOUGH - 1) {
-        copy->lencode = copy->codes + (state->lencode - state->codes);
-        copy->distcode = copy->codes + (state->distcode - state->codes);
-    }
-    copy->next = copy->codes + (state->next - state->codes);
-    if (window != Z_NULL) {
-        wsize = 1U << state->wbits;
-        zmemcpy(window, state->window, wsize);
-    }
-    copy->window = window;
-    dest->state = (struct internal_state FAR *)copy;
-    return Z_OK;
-}
-
-int ZEXPORT inflateUndermine(strm, subvert)
-z_streamp strm;
-int subvert;
-{
-    struct inflate_state FAR *state;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    state->sane = !subvert;
-#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-    return Z_OK;
-#else
-    state->sane = 1;
-    return Z_DATA_ERROR;
-#endif
-}
-
-long ZEXPORT inflateMark(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;
-    state = (struct inflate_state FAR *)strm->state;
-    return ((long)(state->back) << 16) +
-        (state->mode == COPY ? state->length :
-            (state->mode == MATCH ? state->was - state->length : 0));
-}
diff -Nbaur gcc-4.8.1/zlib/inflate.h gcc-4.8.1-ppc/zlib/inflate.h
--- gcc-4.8.1/zlib/inflate.h	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/inflate.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,122 +0,0 @@
-/* inflate.h -- internal inflate state definition
- * Copyright (C) 1995-2009 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* define NO_GZIP when compiling if you want to disable gzip header and
-   trailer decoding by inflate().  NO_GZIP would be used to avoid linking in
-   the crc code when it is not needed.  For shared libraries, gzip decoding
-   should be left enabled. */
-#ifndef NO_GZIP
-#  define GUNZIP
-#endif
-
-/* Possible inflate modes between inflate() calls */
-typedef enum {
-    HEAD,       /* i: waiting for magic header */
-    FLAGS,      /* i: waiting for method and flags (gzip) */
-    TIME,       /* i: waiting for modification time (gzip) */
-    OS,         /* i: waiting for extra flags and operating system (gzip) */
-    EXLEN,      /* i: waiting for extra length (gzip) */
-    EXTRA,      /* i: waiting for extra bytes (gzip) */
-    NAME,       /* i: waiting for end of file name (gzip) */
-    COMMENT,    /* i: waiting for end of comment (gzip) */
-    HCRC,       /* i: waiting for header crc (gzip) */
-    DICTID,     /* i: waiting for dictionary check value */
-    DICT,       /* waiting for inflateSetDictionary() call */
-        TYPE,       /* i: waiting for type bits, including last-flag bit */
-        TYPEDO,     /* i: same, but skip check to exit inflate on new block */
-        STORED,     /* i: waiting for stored size (length and complement) */
-        COPY_,      /* i/o: same as COPY below, but only first time in */
-        COPY,       /* i/o: waiting for input or output to copy stored block */
-        TABLE,      /* i: waiting for dynamic block table lengths */
-        LENLENS,    /* i: waiting for code length code lengths */
-        CODELENS,   /* i: waiting for length/lit and distance code lengths */
-            LEN_,       /* i: same as LEN below, but only first time in */
-            LEN,        /* i: waiting for length/lit/eob code */
-            LENEXT,     /* i: waiting for length extra bits */
-            DIST,       /* i: waiting for distance code */
-            DISTEXT,    /* i: waiting for distance extra bits */
-            MATCH,      /* o: waiting for output space to copy string */
-            LIT,        /* o: waiting for output space to write literal */
-    CHECK,      /* i: waiting for 32-bit check value */
-    LENGTH,     /* i: waiting for 32-bit length (gzip) */
-    DONE,       /* finished check, done -- remain here until reset */
-    BAD,        /* got a data error -- remain here until reset */
-    MEM,        /* got an inflate() memory error -- remain here until reset */
-    SYNC        /* looking for synchronization bytes to restart inflate() */
-} inflate_mode;
-
-/*
-    State transitions between above modes -
-
-    (most modes can go to BAD or MEM on error -- not shown for clarity)
-
-    Process header:
-        HEAD -> (gzip) or (zlib) or (raw)
-        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME -> COMMENT ->
-                  HCRC -> TYPE
-        (zlib) -> DICTID or TYPE
-        DICTID -> DICT -> TYPE
-        (raw) -> TYPEDO
-    Read deflate blocks:
-            TYPE -> TYPEDO -> STORED or TABLE or LEN_ or CHECK
-            STORED -> COPY_ -> COPY -> TYPE
-            TABLE -> LENLENS -> CODELENS -> LEN_
-            LEN_ -> LEN
-    Read deflate codes in fixed or dynamic block:
-                LEN -> LENEXT or LIT or TYPE
-                LENEXT -> DIST -> DISTEXT -> MATCH -> LEN
-                LIT -> LEN
-    Process trailer:
-        CHECK -> LENGTH -> DONE
- */
-
-/* state maintained between inflate() calls.  Approximately 10K bytes. */
-struct inflate_state {
-    inflate_mode mode;          /* current inflate mode */
-    int last;                   /* true if processing last block */
-    int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip */
-    int havedict;               /* true if dictionary provided */
-    int flags;                  /* gzip header method and flags (0 if zlib) */
-    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */
-    unsigned long check;        /* protected copy of check value */
-    unsigned long total;        /* protected copy of output count */
-    gz_headerp head;            /* where to save gzip header information */
-        /* sliding window */
-    unsigned wbits;             /* log base 2 of requested window size */
-    unsigned wsize;             /* window size or zero if not using window */
-    unsigned whave;             /* valid bytes in the window */
-    unsigned wnext;             /* window write index */
-    unsigned char FAR *window;  /* allocated sliding window, if needed */
-        /* bit accumulator */
-    unsigned long hold;         /* input bit accumulator */
-    unsigned bits;              /* number of bits in "in" */
-        /* for string and stored block copying */
-    unsigned length;            /* literal or length of data to copy */
-    unsigned offset;            /* distance back to copy string from */
-        /* for table and code decoding */
-    unsigned extra;             /* extra bits needed */
-        /* fixed and dynamic code tables */
-    code const FAR *lencode;    /* starting table for length/literal codes */
-    code const FAR *distcode;   /* starting table for distance codes */
-    unsigned lenbits;           /* index bits for lencode */
-    unsigned distbits;          /* index bits for distcode */
-        /* dynamic table building */
-    unsigned ncode;             /* number of code length code lengths */
-    unsigned nlen;              /* number of length code lengths */
-    unsigned ndist;             /* number of distance code lengths */
-    unsigned have;              /* number of code lengths in lens[] */
-    code FAR *next;             /* next available space in codes[] */
-    unsigned short lens[320];   /* temporary storage for code lengths */
-    unsigned short work[288];   /* work area for code table building */
-    code codes[ENOUGH];         /* space for code tables */
-    int sane;                   /* if false, allow invalid distance too far */
-    int back;                   /* bits back of last unprocessed length/lit */
-    unsigned was;               /* initial length of match */
-};
diff -Nbaur gcc-4.8.1/zlib/inftrees.c gcc-4.8.1-ppc/zlib/inftrees.c
--- gcc-4.8.1/zlib/inftrees.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/inftrees.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,306 +0,0 @@
-/* inftrees.c -- generate Huffman trees for efficient decoding
- * Copyright (C) 1995-2012 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-
-#define MAXBITS 15
-
-const char inflate_copyright[] =
-   " inflate 1.2.7 Copyright 1995-2012 Mark Adler ";
-/*
-  If you use the zlib library in a product, an acknowledgment is welcome
-  in the documentation of your product. If for some reason you cannot
-  include such an acknowledgment, I would appreciate that you keep this
-  copyright string in the executable of your product.
- */
-
-/*
-   Build a set of tables to decode the provided canonical Huffman code.
-   The code lengths are lens[0..codes-1].  The result starts at *table,
-   whose indices are 0..2^bits-1.  work is a writable array of at least
-   lens shorts, which is used as a work area.  type is the type of code
-   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
-   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
-   on return points to the next available entry's address.  bits is the
-   requested root table index bits, and on return it is the actual root
-   table index bits.  It will differ if the request is greater than the
-   longest code or if it is less than the shortest code.
- */
-int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)
-codetype type;
-unsigned short FAR *lens;
-unsigned codes;
-code FAR * FAR *table;
-unsigned FAR *bits;
-unsigned short FAR *work;
-{
-    unsigned len;               /* a code's length in bits */
-    unsigned sym;               /* index of code symbols */
-    unsigned min, max;          /* minimum and maximum code lengths */
-    unsigned root;              /* number of index bits for root table */
-    unsigned curr;              /* number of index bits for current table */
-    unsigned drop;              /* code bits to drop for sub-table */
-    int left;                   /* number of prefix codes available */
-    unsigned used;              /* code entries in table used */
-    unsigned huff;              /* Huffman code */
-    unsigned incr;              /* for incrementing code, index */
-    unsigned fill;              /* index for replicating entries */
-    unsigned low;               /* low bits for current root entry */
-    unsigned mask;              /* mask for low root bits */
-    code here;                  /* table entry for duplication */
-    code FAR *next;             /* next available space in table */
-    const unsigned short FAR *base;     /* base value table to use */
-    const unsigned short FAR *extra;    /* extra bits table to use */
-    int end;                    /* use base and extra for symbol > end */
-    unsigned short count[MAXBITS+1];    /* number of codes of each length */
-    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
-    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
-        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
-        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
-    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
-        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
-        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 78, 68};
-    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
-        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
-        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
-        8193, 12289, 16385, 24577, 0, 0};
-    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
-        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
-        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
-        28, 28, 29, 29, 64, 64};
-
-    /*
-       Process a set of code lengths to create a canonical Huffman code.  The
-       code lengths are lens[0..codes-1].  Each length corresponds to the
-       symbols 0..codes-1.  The Huffman code is generated by first sorting the
-       symbols by length from short to long, and retaining the symbol order
-       for codes with equal lengths.  Then the code starts with all zero bits
-       for the first code of the shortest length, and the codes are integer
-       increments for the same length, and zeros are appended as the length
-       increases.  For the deflate format, these bits are stored backwards
-       from their more natural integer increment ordering, and so when the
-       decoding tables are built in the large loop below, the integer codes
-       are incremented backwards.
-
-       This routine assumes, but does not check, that all of the entries in
-       lens[] are in the range 0..MAXBITS.  The caller must assure this.
-       1..MAXBITS is interpreted as that code length.  zero means that that
-       symbol does not occur in this code.
-
-       The codes are sorted by computing a count of codes for each length,
-       creating from that a table of starting indices for each length in the
-       sorted table, and then entering the symbols in order in the sorted
-       table.  The sorted table is work[], with that space being provided by
-       the caller.
-
-       The length counts are used for other purposes as well, i.e. finding
-       the minimum and maximum length codes, determining if there are any
-       codes at all, checking for a valid set of lengths, and looking ahead
-       at length counts to determine sub-table sizes when building the
-       decoding tables.
-     */
-
-    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
-    for (len = 0; len <= MAXBITS; len++)
-        count[len] = 0;
-    for (sym = 0; sym < codes; sym++)
-        count[lens[sym]]++;
-
-    /* bound code lengths, force root to be within code lengths */
-    root = *bits;
-    for (max = MAXBITS; max >= 1; max--)
-        if (count[max] != 0) break;
-    if (root > max) root = max;
-    if (max == 0) {                     /* no symbols to code at all */
-        here.op = (unsigned char)64;    /* invalid code marker */
-        here.bits = (unsigned char)1;
-        here.val = (unsigned short)0;
-        *(*table)++ = here;             /* make a table to force an error */
-        *(*table)++ = here;
-        *bits = 1;
-        return 0;     /* no symbols, but wait for decoding to report error */
-    }
-    for (min = 1; min < max; min++)
-        if (count[min] != 0) break;
-    if (root < min) root = min;
-
-    /* check for an over-subscribed or incomplete set of lengths */
-    left = 1;
-    for (len = 1; len <= MAXBITS; len++) {
-        left <<= 1;
-        left -= count[len];
-        if (left < 0) return -1;        /* over-subscribed */
-    }
-    if (left > 0 && (type == CODES || max != 1))
-        return -1;                      /* incomplete set */
-
-    /* generate offsets into symbol table for each length for sorting */
-    offs[1] = 0;
-    for (len = 1; len < MAXBITS; len++)
-        offs[len + 1] = offs[len] + count[len];
-
-    /* sort symbols by length, by symbol order within each length */
-    for (sym = 0; sym < codes; sym++)
-        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
-
-    /*
-       Create and fill in decoding tables.  In this loop, the table being
-       filled is at next and has curr index bits.  The code being used is huff
-       with length len.  That code is converted to an index by dropping drop
-       bits off of the bottom.  For codes where len is less than drop + curr,
-       those top drop + curr - len bits are incremented through all values to
-       fill the table with replicated entries.
-
-       root is the number of index bits for the root table.  When len exceeds
-       root, sub-tables are created pointed to by the root entry with an index
-       of the low root bits of huff.  This is saved in low to check for when a
-       new sub-table should be started.  drop is zero when the root table is
-       being filled, and drop is root when sub-tables are being filled.
-
-       When a new sub-table is needed, it is necessary to look ahead in the
-       code lengths to determine what size sub-table is needed.  The length
-       counts are used for this, and so count[] is decremented as codes are
-       entered in the tables.
-
-       used keeps track of how many table entries have been allocated from the
-       provided *table space.  It is checked for LENS and DIST tables against
-       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
-       the initial root table size constants.  See the comments in inftrees.h
-       for more information.
-
-       sym increments through all symbols, and the loop terminates when
-       all codes of length max, i.e. all codes, have been processed.  This
-       routine permits incomplete codes, so another loop after this one fills
-       in the rest of the decoding tables with invalid code markers.
-     */
-
-    /* set up for code type */
-    switch (type) {
-    case CODES:
-        base = extra = work;    /* dummy value--not used */
-        end = 19;
-        break;
-    case LENS:
-        base = lbase;
-        base -= 257;
-        extra = lext;
-        extra -= 257;
-        end = 256;
-        break;
-    default:            /* DISTS */
-        base = dbase;
-        extra = dext;
-        end = -1;
-    }
-
-    /* initialize state for loop */
-    huff = 0;                   /* starting code */
-    sym = 0;                    /* starting code symbol */
-    len = min;                  /* starting code length */
-    next = *table;              /* current table to fill in */
-    curr = root;                /* current table index bits */
-    drop = 0;                   /* current bits to drop from code for index */
-    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
-    used = 1U << root;          /* use root table entries */
-    mask = used - 1;            /* mask for comparing low */
-
-    /* check available table space */
-    if ((type == LENS && used >= ENOUGH_LENS) ||
-        (type == DISTS && used >= ENOUGH_DISTS))
-        return 1;
-
-    /* process all codes and make table entries */
-    for (;;) {
-        /* create table entry */
-        here.bits = (unsigned char)(len - drop);
-        if ((int)(work[sym]) < end) {
-            here.op = (unsigned char)0;
-            here.val = work[sym];
-        }
-        else if ((int)(work[sym]) > end) {
-            here.op = (unsigned char)(extra[work[sym]]);
-            here.val = base[work[sym]];
-        }
-        else {
-            here.op = (unsigned char)(32 + 64);         /* end of block */
-            here.val = 0;
-        }
-
-        /* replicate for those indices with low len bits equal to huff */
-        incr = 1U << (len - drop);
-        fill = 1U << curr;
-        min = fill;                 /* save offset to next table */
-        do {
-            fill -= incr;
-            next[(huff >> drop) + fill] = here;
-        } while (fill != 0);
-
-        /* backwards increment the len-bit code huff */
-        incr = 1U << (len - 1);
-        while (huff & incr)
-            incr >>= 1;
-        if (incr != 0) {
-            huff &= incr - 1;
-            huff += incr;
-        }
-        else
-            huff = 0;
-
-        /* go to next symbol, update count, len */
-        sym++;
-        if (--(count[len]) == 0) {
-            if (len == max) break;
-            len = lens[work[sym]];
-        }
-
-        /* create new sub-table if needed */
-        if (len > root && (huff & mask) != low) {
-            /* if first time, transition to sub-tables */
-            if (drop == 0)
-                drop = root;
-
-            /* increment past last table */
-            next += min;            /* here min is 1 << curr */
-
-            /* determine length of next table */
-            curr = len - drop;
-            left = (int)(1 << curr);
-            while (curr + drop < max) {
-                left -= count[curr + drop];
-                if (left <= 0) break;
-                curr++;
-                left <<= 1;
-            }
-
-            /* check for enough space */
-            used += 1U << curr;
-            if ((type == LENS && used >= ENOUGH_LENS) ||
-                (type == DISTS && used >= ENOUGH_DISTS))
-                return 1;
-
-            /* point entry in root table to sub-table */
-            low = huff & mask;
-            (*table)[low].op = (unsigned char)curr;
-            (*table)[low].bits = (unsigned char)root;
-            (*table)[low].val = (unsigned short)(next - *table);
-        }
-    }
-
-    /* fill in remaining table entry if code is incomplete (guaranteed to have
-       at most one remaining entry, since if the code is incomplete, the
-       maximum code length that was allowed to get this far is one bit) */
-    if (huff != 0) {
-        here.op = (unsigned char)64;            /* invalid code marker */
-        here.bits = (unsigned char)(len - drop);
-        here.val = (unsigned short)0;
-        next[huff] = here;
-    }
-
-    /* set return parameters */
-    *table += used;
-    *bits = root;
-    return 0;
-}
diff -Nbaur gcc-4.8.1/zlib/inftrees.h gcc-4.8.1-ppc/zlib/inftrees.h
--- gcc-4.8.1/zlib/inftrees.h	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/inftrees.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,62 +0,0 @@
-/* inftrees.h -- header to use inftrees.c
- * Copyright (C) 1995-2005, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* Structure for decoding tables.  Each entry provides either the
-   information needed to do the operation requested by the code that
-   indexed that table entry, or it provides a pointer to another
-   table that indexes more bits of the code.  op indicates whether
-   the entry is a pointer to another table, a literal, a length or
-   distance, an end-of-block, or an invalid code.  For a table
-   pointer, the low four bits of op is the number of index bits of
-   that table.  For a length or distance, the low four bits of op
-   is the number of extra bits to get after the code.  bits is
-   the number of bits in this code or part of the code to drop off
-   of the bit buffer.  val is the actual byte to output in the case
-   of a literal, the base length or distance, or the offset from
-   the current table to the next table.  Each entry is four bytes. */
-typedef struct {
-    unsigned char op;           /* operation, extra bits, table bits */
-    unsigned char bits;         /* bits in this part of the code */
-    unsigned short val;         /* offset in table or code value */
-} code;
-
-/* op values as set by inflate_table():
-    00000000 - literal
-    0000tttt - table link, tttt != 0 is the number of table index bits
-    0001eeee - length or distance, eeee is the number of extra bits
-    01100000 - end of block
-    01000000 - invalid code
- */
-
-/* Maximum size of the dynamic table.  The maximum number of code structures is
-   1444, which is the sum of 852 for literal/length codes and 592 for distance
-   codes.  These values were found by exhaustive searches using the program
-   examples/enough.c found in the zlib distribtution.  The arguments to that
-   program are the number of symbols, the initial root table size, and the
-   maximum bit length of a code.  "enough 286 9 15" for literal/length codes
-   returns returns 852, and "enough 30 6 15" for distance codes returns 592.
-   The initial root table size (9 or 6) is found in the fifth argument of the
-   inflate_table() calls in inflate.c and infback.c.  If the root table size is
-   changed, then these maximum sizes would be need to be recalculated and
-   updated. */
-#define ENOUGH_LENS 852
-#define ENOUGH_DISTS 592
-#define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)
-
-/* Type of code to build for inflate_table() */
-typedef enum {
-    CODES,
-    LENS,
-    DISTS
-} codetype;
-
-int ZLIB_INTERNAL inflate_table OF((codetype type, unsigned short FAR *lens,
-                             unsigned codes, code FAR * FAR *table,
-                             unsigned FAR *bits, unsigned short FAR *work));
diff -Nbaur gcc-4.8.1/zlib/Makefile.am gcc-4.8.1-ppc/zlib/Makefile.am
--- gcc-4.8.1/zlib/Makefile.am	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/Makefile.am	1970-01-01 01:00:00.000000000 +0100
@@ -1,61 +0,0 @@
-## Process this file with automake to create Makefile.in.
-
-AUTOMAKE_OPTIONS = 1.8 cygnus
-
-ACLOCAL_AMFLAGS = -I .. -I ../config
-
-ZLIB_SOURCES = adler32.c compress.c crc32.c crc32.h deflate.c \
-deflate.h gzguts.h gzread.c gzclose.c gzwrite.c gzlib.c \
-infback.c inffast.c inffast.h inffixed.h inflate.c \
-inflate.h inftrees.c inftrees.h trees.c trees.h uncompr.c zconf.h \
-zconf.h.in zlib.h zutil.c zutil.h
-
-if TARGET_LIBRARY
-noinst_LTLIBRARIES = libzgcj_convenience.la
-libzgcj_convenience_la_SOURCES = $(ZLIB_SOURCES)
-else
-toolexeclib_LIBRARIES = libz.a
-libz_a_SOURCES = $(ZLIB_SOURCES)
-libz_a_CFLAGS = $(AM_CFLAGS)
-endif
-
-# Work around what appears to be a GNU make bug handling MAKEFLAGS
-# values defined in terms of make variables, as is the case for CC and
-# friends when we are called from the top level Makefile.
-AM_MAKEFLAGS = \
-	"AR_FLAGS=$(AR_FLAGS)" \
-	"CC_FOR_BUILD=$(CC_FOR_BUILD)" \
-	"CFLAGS=$(CFLAGS)" \
-	"CXXFLAGS=$(CXXFLAGS)" \
-	"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)" \
-	"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)" \
-	"INSTALL=$(INSTALL)" \
-	"INSTALL_DATA=$(INSTALL_DATA)" \
-	"INSTALL_PROGRAM=$(INSTALL_PROGRAM)" \
-	"INSTALL_SCRIPT=$(INSTALL_SCRIPT)" \
-	"LDFLAGS=$(LDFLAGS)" \
-	"LIBCFLAGS=$(LIBCFLAGS)" \
-	"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)" \
-	"MAKE=$(MAKE)" \
-	"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)" \
-	"PICFLAG=$(PICFLAG)" \
-	"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)" \
-	"SHELL=$(SHELL)" \
-	"EXPECT=$(EXPECT)" \
-	"RUNTEST=$(RUNTEST)" \
-	"RUNTESTFLAGS=$(RUNTESTFLAGS)" \
-	"exec_prefix=$(exec_prefix)" \
-	"infodir=$(infodir)" \
-	"libdir=$(libdir)" \
-	"prefix=$(prefix)" \
-	"tooldir=$(tooldir)" \
-	"AR=$(AR)" \
-	"AS=$(AS)" \
-	"CC=$(CC)" \
-	"CXX=$(CXX)" \
-	"LD=$(LD)" \
-	"LIBCFLAGS=$(LIBCFLAGS)" \
-	"NM=$(NM)" \
-	"PICFLAG=$(PICFLAG)" \
-	"RANLIB=$(RANLIB)" \
-	"DESTDIR=$(DESTDIR)"
diff -Nbaur gcc-4.8.1/zlib/Makefile.in gcc-4.8.1-ppc/zlib/Makefile.in
--- gcc-4.8.1/zlib/Makefile.in	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/Makefile.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,696 +0,0 @@
-# Makefile.in generated by automake 1.11.1 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
-# Inc.
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-@SET_MAKE@
-
-
-VPATH = @srcdir@
-pkgdatadir = $(datadir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkglibexecdir = $(libexecdir)/@PACKAGE@
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-target_triplet = @target@
-subdir = .
-DIST_COMMON = README ChangeLog $(srcdir)/Makefile.in \
-	$(srcdir)/Makefile.am $(top_srcdir)/configure \
-	$(am__configure_deps) $(srcdir)/../mkinstalldirs
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/../config/depstand.m4 \
-	$(top_srcdir)/../config/lead-dot.m4 \
-	$(top_srcdir)/../config/multi.m4 \
-	$(top_srcdir)/../config/override.m4 \
-	$(top_srcdir)/../ltoptions.m4 $(top_srcdir)/../ltsugar.m4 \
-	$(top_srcdir)/../ltversion.m4 $(top_srcdir)/../lt~obsolete.m4 \
-	$(top_srcdir)/acinclude.m4 \
-	$(top_srcdir)/../config/no-executables.m4 \
-	$(top_srcdir)/../libtool.m4 $(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
- configure.lineno config.status.lineno
-CONFIG_CLEAN_FILES =
-CONFIG_CLEAN_VPATH_FILES =
-am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
-am__vpath_adj = case $$p in \
-    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
-    *) f=$$p;; \
-  esac;
-am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
-am__install_max = 40
-am__nobase_strip_setup = \
-  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
-am__nobase_strip = \
-  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
-am__nobase_list = $(am__nobase_strip_setup); \
-  for p in $$list; do echo "$$p $$p"; done | \
-  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
-  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
-    if (++n[$$2] == $(am__install_max)) \
-      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
-    END { for (dir in files) print dir, files[dir] }'
-am__base_list = \
-  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
-  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
-am__installdirs = "$(DESTDIR)$(toolexeclibdir)"
-LIBRARIES = $(toolexeclib_LIBRARIES)
-ARFLAGS = cru
-libz_a_AR = $(AR) $(ARFLAGS)
-libz_a_LIBADD =
-am__objects_1 = libz_a-adler32.$(OBJEXT) libz_a-compress.$(OBJEXT) \
-	libz_a-crc32.$(OBJEXT) libz_a-deflate.$(OBJEXT) \
-	libz_a-gzread.$(OBJEXT) libz_a-gzclose.$(OBJEXT) \
-	libz_a-gzwrite.$(OBJEXT) libz_a-gzlib.$(OBJEXT) \
-	libz_a-infback.$(OBJEXT) libz_a-inffast.$(OBJEXT) \
-	libz_a-inflate.$(OBJEXT) libz_a-inftrees.$(OBJEXT) \
-	libz_a-trees.$(OBJEXT) libz_a-uncompr.$(OBJEXT) \
-	libz_a-zutil.$(OBJEXT)
-@TARGET_LIBRARY_FALSE@am_libz_a_OBJECTS = $(am__objects_1)
-libz_a_OBJECTS = $(am_libz_a_OBJECTS)
-LTLIBRARIES = $(noinst_LTLIBRARIES)
-libzgcj_convenience_la_LIBADD =
-am__objects_2 = adler32.lo compress.lo crc32.lo deflate.lo gzread.lo \
-	gzclose.lo gzwrite.lo gzlib.lo infback.lo inffast.lo \
-	inflate.lo inftrees.lo trees.lo uncompr.lo zutil.lo
-@TARGET_LIBRARY_TRUE@am_libzgcj_convenience_la_OBJECTS =  \
-@TARGET_LIBRARY_TRUE@	$(am__objects_2)
-libzgcj_convenience_la_OBJECTS = $(am_libzgcj_convenience_la_OBJECTS)
-@TARGET_LIBRARY_TRUE@am_libzgcj_convenience_la_rpath =
-DEFAULT_INCLUDES = -I.@am__isrc@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
-	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
-	$(LDFLAGS) -o $@
-SOURCES = $(libz_a_SOURCES) $(libzgcj_convenience_la_SOURCES)
-MULTISRCTOP = 
-MULTIBUILDTOP = 
-MULTIDIRS = 
-MULTISUBDIR = 
-MULTIDO = true
-MULTICLEAN = true
-ETAGS = etags
-CTAGS = ctags
-ACLOCAL = @ACLOCAL@
-AMTAR = @AMTAR@
-AR = @AR@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFLAGS = @CFLAGS@
-COMPPATH = @COMPPATH@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-DSYMUTIL = @DSYMUTIL@
-DUMPBIN = @DUMPBIN@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-EXEEXT = @EXEEXT@
-FGREP = @FGREP@
-GREP = @GREP@
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-LD = @LD@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LIPO = @LIPO@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-MAINT = @MAINT@
-MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
-NM = @NM@
-NMEDIT = @NMEDIT@
-OBJDUMP = @OBJDUMP@
-OBJEXT = @OBJEXT@
-OTOOL = @OTOOL@
-OTOOL64 = @OTOOL64@
-PACKAGE = @PACKAGE@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_URL = @PACKAGE_URL@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-RANLIB = @RANLIB@
-SED = @SED@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-STRIP = @STRIP@
-VERSION = @VERSION@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-builddir = @builddir@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-mkinstalldirs = @mkinstalldirs@
-multi_basedir = @multi_basedir@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
-sysconfdir = @sysconfdir@
-target = @target@
-target_alias = @target_alias@
-target_all = @target_all@
-target_cpu = @target_cpu@
-target_os = @target_os@
-target_vendor = @target_vendor@
-toolexecdir = @toolexecdir@
-toolexeclibdir = @toolexeclibdir@
-top_build_prefix = @top_build_prefix@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
-AUTOMAKE_OPTIONS = 1.8 cygnus
-ACLOCAL_AMFLAGS = -I .. -I ../config
-ZLIB_SOURCES = adler32.c compress.c crc32.c crc32.h deflate.c \
-deflate.h gzguts.h gzread.c gzclose.c gzwrite.c gzlib.c \
-infback.c inffast.c inffast.h inffixed.h inflate.c \
-inflate.h inftrees.c inftrees.h trees.c trees.h uncompr.c zconf.h \
-zconf.h.in zlib.h zutil.c zutil.h
-
-@TARGET_LIBRARY_TRUE@noinst_LTLIBRARIES = libzgcj_convenience.la
-@TARGET_LIBRARY_TRUE@libzgcj_convenience_la_SOURCES = $(ZLIB_SOURCES)
-@TARGET_LIBRARY_FALSE@toolexeclib_LIBRARIES = libz.a
-@TARGET_LIBRARY_FALSE@libz_a_SOURCES = $(ZLIB_SOURCES)
-@TARGET_LIBRARY_FALSE@libz_a_CFLAGS = $(AM_CFLAGS)
-
-# Work around what appears to be a GNU make bug handling MAKEFLAGS
-# values defined in terms of make variables, as is the case for CC and
-# friends when we are called from the top level Makefile.
-AM_MAKEFLAGS = \
-	"AR_FLAGS=$(AR_FLAGS)" \
-	"CC_FOR_BUILD=$(CC_FOR_BUILD)" \
-	"CFLAGS=$(CFLAGS)" \
-	"CXXFLAGS=$(CXXFLAGS)" \
-	"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)" \
-	"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)" \
-	"INSTALL=$(INSTALL)" \
-	"INSTALL_DATA=$(INSTALL_DATA)" \
-	"INSTALL_PROGRAM=$(INSTALL_PROGRAM)" \
-	"INSTALL_SCRIPT=$(INSTALL_SCRIPT)" \
-	"LDFLAGS=$(LDFLAGS)" \
-	"LIBCFLAGS=$(LIBCFLAGS)" \
-	"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)" \
-	"MAKE=$(MAKE)" \
-	"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)" \
-	"PICFLAG=$(PICFLAG)" \
-	"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)" \
-	"SHELL=$(SHELL)" \
-	"EXPECT=$(EXPECT)" \
-	"RUNTEST=$(RUNTEST)" \
-	"RUNTESTFLAGS=$(RUNTESTFLAGS)" \
-	"exec_prefix=$(exec_prefix)" \
-	"infodir=$(infodir)" \
-	"libdir=$(libdir)" \
-	"prefix=$(prefix)" \
-	"tooldir=$(tooldir)" \
-	"AR=$(AR)" \
-	"AS=$(AS)" \
-	"CC=$(CC)" \
-	"CXX=$(CXX)" \
-	"LD=$(LD)" \
-	"LIBCFLAGS=$(LIBCFLAGS)" \
-	"NM=$(NM)" \
-	"PICFLAG=$(PICFLAG)" \
-	"RANLIB=$(RANLIB)" \
-	"DESTDIR=$(DESTDIR)"
-
-all: all-am
-
-.SUFFIXES:
-.SUFFIXES: .c .lo .o .obj
-am--refresh:
-	@:
-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \
-	      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \
-		&& exit 0; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \
-	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --foreign Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    echo ' $(SHELL) ./config.status'; \
-	    $(SHELL) ./config.status;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	$(SHELL) ./config.status --recheck
-
-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
-	$(am__cd) $(srcdir) && $(AUTOCONF)
-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
-	$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
-$(am__aclocal_m4_deps):
-install-toolexeclibLIBRARIES: $(toolexeclib_LIBRARIES)
-	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibdir)"
-	@list='$(toolexeclib_LIBRARIES)'; test -n "$(toolexeclibdir)" || list=; \
-	list2=; for p in $$list; do \
-	  if test -f $$p; then \
-	    list2="$$list2 $$p"; \
-	  else :; fi; \
-	done; \
-	test -z "$$list2" || { \
-	  echo " $(INSTALL_DATA) $$list2 '$(DESTDIR)$(toolexeclibdir)'"; \
-	  $(INSTALL_DATA) $$list2 "$(DESTDIR)$(toolexeclibdir)" || exit $$?; }
-	@$(POST_INSTALL)
-	@list='$(toolexeclib_LIBRARIES)'; test -n "$(toolexeclibdir)" || list=; \
-	for p in $$list; do \
-	  if test -f $$p; then \
-	    $(am__strip_dir) \
-	    echo " ( cd '$(DESTDIR)$(toolexeclibdir)' && $(RANLIB) $$f )"; \
-	    ( cd "$(DESTDIR)$(toolexeclibdir)" && $(RANLIB) $$f ) || exit $$?; \
-	  else :; fi; \
-	done
-
-uninstall-toolexeclibLIBRARIES:
-	@$(NORMAL_UNINSTALL)
-	@list='$(toolexeclib_LIBRARIES)'; test -n "$(toolexeclibdir)" || list=; \
-	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibdir)' && rm -f "$$files" )"; \
-	cd "$(DESTDIR)$(toolexeclibdir)" && rm -f $$files
-
-clean-toolexeclibLIBRARIES:
-	-test -z "$(toolexeclib_LIBRARIES)" || rm -f $(toolexeclib_LIBRARIES)
-libz.a: $(libz_a_OBJECTS) $(libz_a_DEPENDENCIES) 
-	-rm -f libz.a
-	$(libz_a_AR) libz.a $(libz_a_OBJECTS) $(libz_a_LIBADD)
-	$(RANLIB) libz.a
-
-clean-noinstLTLIBRARIES:
-	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
-	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
-	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
-	  test "$$dir" != "$$p" || dir=.; \
-	  echo "rm -f \"$${dir}/so_locations\""; \
-	  rm -f "$${dir}/so_locations"; \
-	done
-libzgcj_convenience.la: $(libzgcj_convenience_la_OBJECTS) $(libzgcj_convenience_la_DEPENDENCIES) 
-	$(LINK) $(am_libzgcj_convenience_la_rpath) $(libzgcj_convenience_la_OBJECTS) $(libzgcj_convenience_la_LIBADD) $(LIBS)
-
-mostlyclean-compile:
-	-rm -f *.$(OBJEXT)
-
-distclean-compile:
-	-rm -f *.tab.c
-
-.c.o:
-	$(COMPILE) -c $<
-
-.c.obj:
-	$(COMPILE) -c `$(CYGPATH_W) '$<'`
-
-.c.lo:
-	$(LTCOMPILE) -c -o $@ $<
-
-libz_a-adler32.o: adler32.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-adler32.o `test -f 'adler32.c' || echo '$(srcdir)/'`adler32.c
-
-libz_a-adler32.obj: adler32.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-adler32.obj `if test -f 'adler32.c'; then $(CYGPATH_W) 'adler32.c'; else $(CYGPATH_W) '$(srcdir)/adler32.c'; fi`
-
-libz_a-compress.o: compress.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-compress.o `test -f 'compress.c' || echo '$(srcdir)/'`compress.c
-
-libz_a-compress.obj: compress.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-compress.obj `if test -f 'compress.c'; then $(CYGPATH_W) 'compress.c'; else $(CYGPATH_W) '$(srcdir)/compress.c'; fi`
-
-libz_a-crc32.o: crc32.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-crc32.o `test -f 'crc32.c' || echo '$(srcdir)/'`crc32.c
-
-libz_a-crc32.obj: crc32.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-crc32.obj `if test -f 'crc32.c'; then $(CYGPATH_W) 'crc32.c'; else $(CYGPATH_W) '$(srcdir)/crc32.c'; fi`
-
-libz_a-deflate.o: deflate.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-deflate.o `test -f 'deflate.c' || echo '$(srcdir)/'`deflate.c
-
-libz_a-deflate.obj: deflate.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-deflate.obj `if test -f 'deflate.c'; then $(CYGPATH_W) 'deflate.c'; else $(CYGPATH_W) '$(srcdir)/deflate.c'; fi`
-
-libz_a-gzread.o: gzread.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-gzread.o `test -f 'gzread.c' || echo '$(srcdir)/'`gzread.c
-
-libz_a-gzread.obj: gzread.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-gzread.obj `if test -f 'gzread.c'; then $(CYGPATH_W) 'gzread.c'; else $(CYGPATH_W) '$(srcdir)/gzread.c'; fi`
-
-libz_a-gzclose.o: gzclose.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-gzclose.o `test -f 'gzclose.c' || echo '$(srcdir)/'`gzclose.c
-
-libz_a-gzclose.obj: gzclose.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-gzclose.obj `if test -f 'gzclose.c'; then $(CYGPATH_W) 'gzclose.c'; else $(CYGPATH_W) '$(srcdir)/gzclose.c'; fi`
-
-libz_a-gzwrite.o: gzwrite.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-gzwrite.o `test -f 'gzwrite.c' || echo '$(srcdir)/'`gzwrite.c
-
-libz_a-gzwrite.obj: gzwrite.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-gzwrite.obj `if test -f 'gzwrite.c'; then $(CYGPATH_W) 'gzwrite.c'; else $(CYGPATH_W) '$(srcdir)/gzwrite.c'; fi`
-
-libz_a-gzlib.o: gzlib.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-gzlib.o `test -f 'gzlib.c' || echo '$(srcdir)/'`gzlib.c
-
-libz_a-gzlib.obj: gzlib.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-gzlib.obj `if test -f 'gzlib.c'; then $(CYGPATH_W) 'gzlib.c'; else $(CYGPATH_W) '$(srcdir)/gzlib.c'; fi`
-
-libz_a-infback.o: infback.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-infback.o `test -f 'infback.c' || echo '$(srcdir)/'`infback.c
-
-libz_a-infback.obj: infback.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-infback.obj `if test -f 'infback.c'; then $(CYGPATH_W) 'infback.c'; else $(CYGPATH_W) '$(srcdir)/infback.c'; fi`
-
-libz_a-inffast.o: inffast.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inffast.o `test -f 'inffast.c' || echo '$(srcdir)/'`inffast.c
-
-libz_a-inffast.obj: inffast.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inffast.obj `if test -f 'inffast.c'; then $(CYGPATH_W) 'inffast.c'; else $(CYGPATH_W) '$(srcdir)/inffast.c'; fi`
-
-libz_a-inflate.o: inflate.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inflate.o `test -f 'inflate.c' || echo '$(srcdir)/'`inflate.c
-
-libz_a-inflate.obj: inflate.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inflate.obj `if test -f 'inflate.c'; then $(CYGPATH_W) 'inflate.c'; else $(CYGPATH_W) '$(srcdir)/inflate.c'; fi`
-
-libz_a-inftrees.o: inftrees.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inftrees.o `test -f 'inftrees.c' || echo '$(srcdir)/'`inftrees.c
-
-libz_a-inftrees.obj: inftrees.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inftrees.obj `if test -f 'inftrees.c'; then $(CYGPATH_W) 'inftrees.c'; else $(CYGPATH_W) '$(srcdir)/inftrees.c'; fi`
-
-libz_a-trees.o: trees.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-trees.o `test -f 'trees.c' || echo '$(srcdir)/'`trees.c
-
-libz_a-trees.obj: trees.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-trees.obj `if test -f 'trees.c'; then $(CYGPATH_W) 'trees.c'; else $(CYGPATH_W) '$(srcdir)/trees.c'; fi`
-
-libz_a-uncompr.o: uncompr.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-uncompr.o `test -f 'uncompr.c' || echo '$(srcdir)/'`uncompr.c
-
-libz_a-uncompr.obj: uncompr.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-uncompr.obj `if test -f 'uncompr.c'; then $(CYGPATH_W) 'uncompr.c'; else $(CYGPATH_W) '$(srcdir)/uncompr.c'; fi`
-
-libz_a-zutil.o: zutil.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-zutil.o `test -f 'zutil.c' || echo '$(srcdir)/'`zutil.c
-
-libz_a-zutil.obj: zutil.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-zutil.obj `if test -f 'zutil.c'; then $(CYGPATH_W) 'zutil.c'; else $(CYGPATH_W) '$(srcdir)/zutil.c'; fi`
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-distclean-libtool:
-	-rm -f libtool config.lt
-
-# GNU Make needs to see an explicit $(MAKE) variable in the command it
-# runs to enable its job server during parallel builds.  Hence the
-# comments below.
-all-multi:
-	$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)
-install-multi:
-	$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)
-
-mostlyclean-multi:
-	$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)
-clean-multi:
-	$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)
-distclean-multi:
-	$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)
-maintainer-clean-multi:
-	$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
-
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	set x; \
-	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	shift; \
-	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  if test $$# -gt 0; then \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      "$$@" $$unique; \
-	  else \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      $$unique; \
-	  fi; \
-	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	test -z "$(CTAGS_ARGS)$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && $(am__cd) $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) "$$here"
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-check-am:
-check: check-am
-all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) all-multi
-installdirs:
-	for dir in "$(DESTDIR)$(toolexeclibdir)"; do \
-	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
-	done
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am clean-multi
-
-clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
-	clean-toolexeclibLIBRARIES mostlyclean-am
-
-distclean: distclean-am distclean-multi
-	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
-	-rm -f Makefile
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-libtool distclean-tags
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-html-am:
-
-info: info-am
-
-info-am:
-
-install-data-am:
-
-install-dvi: install-dvi-am
-
-install-dvi-am:
-
-install-exec-am: install-multi install-toolexeclibLIBRARIES
-
-install-html: install-html-am
-
-install-html-am:
-
-install-info: install-info-am
-
-install-info-am:
-
-install-man:
-
-install-pdf: install-pdf-am
-
-install-pdf-am:
-
-install-ps: install-ps-am
-
-install-ps-am:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am maintainer-clean-multi
-	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
-	-rm -rf $(top_srcdir)/autom4te.cache
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am mostlyclean-multi
-
-mostlyclean-am: mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am: uninstall-toolexeclibLIBRARIES
-
-.MAKE: all-multi clean-multi distclean-multi install-am install-multi \
-	install-strip maintainer-clean-multi mostlyclean-multi
-
-.PHONY: CTAGS GTAGS all all-am all-multi am--refresh check check-am \
-	clean clean-generic clean-libtool clean-multi \
-	clean-noinstLTLIBRARIES clean-toolexeclibLIBRARIES ctags \
-	distclean distclean-compile distclean-generic \
-	distclean-libtool distclean-multi distclean-tags dvi dvi-am \
-	html html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-multi install-pdf \
-	install-pdf-am install-ps install-ps-am install-strip \
-	install-toolexeclibLIBRARIES installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	maintainer-clean-multi mostlyclean mostlyclean-compile \
-	mostlyclean-generic mostlyclean-libtool mostlyclean-multi pdf \
-	pdf-am ps ps-am tags uninstall uninstall-am \
-	uninstall-toolexeclibLIBRARIES
-
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
diff -Nbaur gcc-4.8.1/zlib/make_vms.com gcc-4.8.1-ppc/zlib/make_vms.com
--- gcc-4.8.1/zlib/make_vms.com	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/make_vms.com	1970-01-01 01:00:00.000000000 +0100
@@ -1,867 +0,0 @@
-$! make libz under VMS written by
-$! Martin P.J. Zinser
-$!
-$! In case of problems with the install you might contact me at
-$! zinser@zinser.no-ip.info(preferred) or
-$! martin.zinser@eurexchange.com (work)
-$!
-$! Make procedure history for Zlib
-$!
-$!------------------------------------------------------------------------------
-$! Version history
-$! 0.01 20060120 First version to receive a number
-$! 0.02 20061008 Adapt to new Makefile.in
-$! 0.03 20091224 Add support for large file check
-$! 0.04 20100110 Add new gzclose, gzlib, gzread, gzwrite
-$! 0.05 20100221 Exchange zlibdefs.h by zconf.h.in
-$! 0.06 20120111 Fix missing amiss_err, update zconf_h.in, fix new exmples
-$!               subdir path, update module search in makefile.in
-$! 0.07 20120115 Triggered by work done by Alexey Chupahin completly redesigned
-$!               shared image creation
-$! 0.08 20120219 Make it work on VAX again, pre-load missing symbols to shared
-$!               image
-$! 0.09 20120305 SMS.  P1 sets builder ("MMK", "MMS", " " (built-in)).
-$!               "" -> automatic, preference: MMK, MMS, built-in.
-$!
-$ on error then goto err_exit
-$!
-$ true  = 1
-$ false = 0
-$ tmpnam = "temp_" + f$getjpi("","pid")
-$ tt = tmpnam + ".txt"
-$ tc = tmpnam + ".c"
-$ th = tmpnam + ".h"
-$ define/nolog tconfig 'th'
-$ its_decc = false
-$ its_vaxc = false
-$ its_gnuc = false
-$ s_case   = False
-$!
-$! Setup variables holding "config" information
-$!
-$ Make    = "''p1'"
-$ name     = "Zlib"
-$ version  = "?.?.?"
-$ v_string = "ZLIB_VERSION"
-$ v_file   = "zlib.h"
-$ ccopt   = "/include = []"
-$ lopts   = ""
-$ dnsrl   = ""
-$ aconf_in_file = "zconf.h.in#zconf.h_in#zconf_h.in"
-$ conf_check_string = ""
-$ linkonly = false
-$ optfile  = name + ".opt"
-$ mapfile  = name + ".map"
-$ libdefs  = ""
-$ vax      = f$getsyi("HW_MODEL").lt.1024
-$ axp      = f$getsyi("HW_MODEL").ge.1024 .and. f$getsyi("HW_MODEL").lt.4096
-$ ia64     = f$getsyi("HW_MODEL").ge.4096
-$!
-$! 2012-03-05 SMS.
-$! Why is this needed?  And if it is needed, why not simply ".not. vax"?
-$!
-$!!! if axp .or. ia64 then  set proc/parse=extended
-$!
-$ whoami = f$parse(f$environment("Procedure"),,,,"NO_CONCEAL")
-$ mydef  = F$parse(whoami,,,"DEVICE")
-$ mydir  = f$parse(whoami,,,"DIRECTORY") - "]["
-$ myproc = f$parse(whoami,,,"Name") + f$parse(whoami,,,"type")
-$!
-$! Check for MMK/MMS
-$!
-$ if (Make .eqs. "")
-$ then
-$   If F$Search ("Sys$System:MMS.EXE") .nes. "" Then Make = "MMS"
-$   If F$Type (MMK) .eqs. "STRING" Then Make = "MMK"
-$ else
-$   Make = f$edit( Make, "trim")
-$ endif
-$!
-$ gosub find_version
-$!
-$  open/write topt tmp.opt
-$  open/write optf 'optfile'
-$!
-$ gosub check_opts
-$!
-$! Look for the compiler used
-$!
-$ gosub check_compiler
-$ close topt
-$ close optf
-$!
-$ if its_decc
-$ then
-$   ccopt = "/prefix=all" + ccopt
-$   if f$trnlnm("SYS") .eqs. ""
-$   then
-$     if axp
-$     then
-$       define sys sys$library:
-$     else
-$       ccopt = "/decc" + ccopt
-$       define sys decc$library_include:
-$     endif
-$   endif
-$!
-$! 2012-03-05 SMS.
-$! Why /NAMES = AS_IS?  Why not simply ".not. vax"?  And why not on VAX?
-$!
-$   if axp .or. ia64
-$   then
-$       ccopt = ccopt + "/name=as_is/opt=(inline=speed)"
-$       s_case = true
-$   endif
-$ endif
-$ if its_vaxc .or. its_gnuc
-$ then
-$    if f$trnlnm("SYS").eqs."" then define sys sys$library:
-$ endif
-$!
-$! Build a fake configure input header
-$!
-$ open/write conf_hin config.hin
-$ write conf_hin "#undef _LARGEFILE64_SOURCE"
-$ close conf_hin
-$!
-$!
-$ i = 0
-$FIND_ACONF:
-$ fname = f$element(i,"#",aconf_in_file)
-$ if fname .eqs. "#" then goto AMISS_ERR
-$ if f$search(fname) .eqs. ""
-$ then
-$   i = i + 1
-$   goto find_aconf
-$ endif
-$ open/read/err=aconf_err aconf_in 'fname'
-$ open/write aconf zconf.h
-$ACONF_LOOP:
-$ read/end_of_file=aconf_exit aconf_in line
-$ work = f$edit(line, "compress,trim")
-$ if f$extract(0,6,work) .nes. "#undef"
-$ then
-$   if f$extract(0,12,work) .nes. "#cmakedefine"
-$   then
-$       write aconf line
-$   endif
-$ else
-$   cdef = f$element(1," ",work)
-$   gosub check_config
-$ endif
-$ goto aconf_loop
-$ACONF_EXIT:
-$ write aconf ""
-$ write aconf "/* VMS specifics added by make_vms.com: */"
-$ write aconf "#define VMS 1"
-$ write aconf "#include <unistd.h>"
-$ write aconf "#include <unixio.h>"
-$ write aconf "#ifdef _LARGEFILE"
-$ write aconf "# define off64_t __off64_t"
-$ write aconf "# define fopen64 fopen"
-$ write aconf "# define fseeko64 fseeko"
-$ write aconf "# define lseek64 lseek"
-$ write aconf "# define ftello64 ftell"
-$ write aconf "#endif"
-$ write aconf "#if !defined( __VAX) && (__CRTL_VER >= 70312000)"
-$ write aconf "# define HAVE_VSNPRINTF"
-$ write aconf "#endif"
-$ close aconf_in
-$ close aconf
-$ if f$search("''th'") .nes. "" then delete 'th';*
-$! Build the thing plain or with mms
-$!
-$ write sys$output "Compiling Zlib sources ..."
-$ if make.eqs.""
-$ then
-$   if (f$search( "example.obj;*") .nes. "") then delete example.obj;*
-$   if (f$search( "minigzip.obj;*") .nes. "") then delete minigzip.obj;*
-$   CALL MAKE adler32.OBJ "CC ''CCOPT' adler32" -
-                adler32.c zlib.h zconf.h
-$   CALL MAKE compress.OBJ "CC ''CCOPT' compress" -
-                compress.c zlib.h zconf.h
-$   CALL MAKE crc32.OBJ "CC ''CCOPT' crc32" -
-                crc32.c zlib.h zconf.h
-$   CALL MAKE deflate.OBJ "CC ''CCOPT' deflate" -
-                deflate.c deflate.h zutil.h zlib.h zconf.h
-$   CALL MAKE gzclose.OBJ "CC ''CCOPT' gzclose" -
-                gzclose.c zutil.h zlib.h zconf.h
-$   CALL MAKE gzlib.OBJ "CC ''CCOPT' gzlib" -
-                gzlib.c zutil.h zlib.h zconf.h
-$   CALL MAKE gzread.OBJ "CC ''CCOPT' gzread" -
-                gzread.c zutil.h zlib.h zconf.h
-$   CALL MAKE gzwrite.OBJ "CC ''CCOPT' gzwrite" -
-                gzwrite.c zutil.h zlib.h zconf.h
-$   CALL MAKE infback.OBJ "CC ''CCOPT' infback" -
-                infback.c zutil.h inftrees.h inflate.h inffast.h inffixed.h
-$   CALL MAKE inffast.OBJ "CC ''CCOPT' inffast" -
-                inffast.c zutil.h zlib.h zconf.h inffast.h
-$   CALL MAKE inflate.OBJ "CC ''CCOPT' inflate" -
-                inflate.c zutil.h zlib.h zconf.h infblock.h
-$   CALL MAKE inftrees.OBJ "CC ''CCOPT' inftrees" -
-                inftrees.c zutil.h zlib.h zconf.h inftrees.h
-$   CALL MAKE trees.OBJ "CC ''CCOPT' trees" -
-                trees.c deflate.h zutil.h zlib.h zconf.h
-$   CALL MAKE uncompr.OBJ "CC ''CCOPT' uncompr" -
-                uncompr.c zlib.h zconf.h
-$   CALL MAKE zutil.OBJ "CC ''CCOPT' zutil" -
-                zutil.c zutil.h zlib.h zconf.h
-$   write sys$output "Building Zlib ..."
-$   CALL MAKE libz.OLB "lib/crea libz.olb *.obj" *.OBJ
-$   write sys$output "Building example..."
-$   CALL MAKE example.OBJ "CC ''CCOPT' [.test]example" -
-                [.test]example.c zlib.h zconf.h
-$   call make example.exe "LINK example,libz.olb/lib" example.obj libz.olb
-$   write sys$output "Building minigzip..."
-$   CALL MAKE minigzip.OBJ "CC ''CCOPT' [.test]minigzip" -
-              [.test]minigzip.c zlib.h zconf.h
-$   call make minigzip.exe -
-              "LINK minigzip,libz.olb/lib" -
-              minigzip.obj libz.olb
-$ else
-$   gosub crea_mms
-$   write sys$output "Make ''name' ''version' with ''Make' "
-$   'make'
-$ endif
-$!
-$! Create shareable image
-$!
-$ gosub crea_olist
-$ write sys$output "Creating libzshr.exe"
-$ call map_2_shopt 'mapfile' 'optfile'
-$ LINK_'lopts'/SHARE=libzshr.exe modules.opt/opt,'optfile'/opt
-$ write sys$output "Zlib build completed"
-$ delete/nolog tmp.opt;*
-$ exit
-$AMISS_ERR:
-$ write sys$output "No source for config.hin found."
-$ write sys$output "Tried any of ''aconf_in_file'"
-$ goto err_exit
-$CC_ERR:
-$ write sys$output "C compiler required to build ''name'"
-$ goto err_exit
-$ERR_EXIT:
-$ set message/facil/ident/sever/text
-$ close/nolog optf
-$ close/nolog topt
-$ close/nolog aconf_in
-$ close/nolog aconf
-$ close/nolog out
-$ close/nolog min
-$ close/nolog mod
-$ close/nolog h_in
-$ write sys$output "Exiting..."
-$ exit 2
-$!
-$!
-$MAKE: SUBROUTINE   !SUBROUTINE TO CHECK DEPENDENCIES
-$ V = 'F$Verify(0)
-$! P1 = What we are trying to make
-$! P2 = Command to make it
-$! P3 - P8  What it depends on
-$
-$ If F$Search(P1) .Eqs. "" Then Goto Makeit
-$ Time = F$CvTime(F$File(P1,"RDT"))
-$arg=3
-$Loop:
-$       Argument = P'arg
-$       If Argument .Eqs. "" Then Goto Exit
-$       El=0
-$Loop2:
-$       File = F$Element(El," ",Argument)
-$       If File .Eqs. " " Then Goto Endl
-$       AFile = ""
-$Loop3:
-$       OFile = AFile
-$       AFile = F$Search(File)
-$       If AFile .Eqs. "" .Or. AFile .Eqs. OFile Then Goto NextEl
-$       If F$CvTime(F$File(AFile,"RDT")) .Ges. Time Then Goto Makeit
-$       Goto Loop3
-$NextEL:
-$       El = El + 1
-$       Goto Loop2
-$EndL:
-$ arg=arg+1
-$ If arg .Le. 8 Then Goto Loop
-$ Goto Exit
-$
-$Makeit:
-$ VV=F$VERIFY(0)
-$ write sys$output P2
-$ 'P2
-$ VV='F$Verify(VV)
-$Exit:
-$ If V Then Set Verify
-$ENDSUBROUTINE
-$!------------------------------------------------------------------------------
-$!
-$! Check command line options and set symbols accordingly
-$!
-$!------------------------------------------------------------------------------
-$! Version history
-$! 0.01 20041206 First version to receive a number
-$! 0.02 20060126 Add new "HELP" target
-$ CHECK_OPTS:
-$ i = 1
-$ OPT_LOOP:
-$ if i .lt. 9
-$ then
-$   cparm = f$edit(p'i',"upcase")
-$!
-$! Check if parameter actually contains something
-$!
-$   if f$edit(cparm,"trim") .nes. ""
-$   then
-$     if cparm .eqs. "DEBUG"
-$     then
-$       ccopt = ccopt + "/noopt/deb"
-$       lopts = lopts + "/deb"
-$     endif
-$     if f$locate("CCOPT=",cparm) .lt. f$length(cparm)
-$     then
-$       start = f$locate("=",cparm) + 1
-$       len   = f$length(cparm) - start
-$       ccopt = ccopt + f$extract(start,len,cparm)
-$       if f$locate("AS_IS",f$edit(ccopt,"UPCASE")) .lt. f$length(ccopt) -
-          then s_case = true
-$     endif
-$     if cparm .eqs. "LINK" then linkonly = true
-$     if f$locate("LOPTS=",cparm) .lt. f$length(cparm)
-$     then
-$       start = f$locate("=",cparm) + 1
-$       len   = f$length(cparm) - start
-$       lopts = lopts + f$extract(start,len,cparm)
-$     endif
-$     if f$locate("CC=",cparm) .lt. f$length(cparm)
-$     then
-$       start  = f$locate("=",cparm) + 1
-$       len    = f$length(cparm) - start
-$       cc_com = f$extract(start,len,cparm)
-        if (cc_com .nes. "DECC") .and. -
-           (cc_com .nes. "VAXC") .and. -
-           (cc_com .nes. "GNUC")
-$       then
-$         write sys$output "Unsupported compiler choice ''cc_com' ignored"
-$         write sys$output "Use DECC, VAXC, or GNUC instead"
-$       else
-$         if cc_com .eqs. "DECC" then its_decc = true
-$         if cc_com .eqs. "VAXC" then its_vaxc = true
-$         if cc_com .eqs. "GNUC" then its_gnuc = true
-$       endif
-$     endif
-$     if f$locate("MAKE=",cparm) .lt. f$length(cparm)
-$     then
-$       start  = f$locate("=",cparm) + 1
-$       len    = f$length(cparm) - start
-$       mmks = f$extract(start,len,cparm)
-$       if (mmks .eqs. "MMK") .or. (mmks .eqs. "MMS")
-$       then
-$         make = mmks
-$       else
-$         write sys$output "Unsupported make choice ''mmks' ignored"
-$         write sys$output "Use MMK or MMS instead"
-$       endif
-$     endif
-$     if cparm .eqs. "HELP" then gosub bhelp
-$   endif
-$   i = i + 1
-$   goto opt_loop
-$ endif
-$ return
-$!------------------------------------------------------------------------------
-$!
-$! Look for the compiler used
-$!
-$! Version history
-$! 0.01 20040223 First version to receive a number
-$! 0.02 20040229 Save/set value of decc$no_rooted_search_lists
-$! 0.03 20060202 Extend handling of GNU C
-$! 0.04 20090402 Compaq -> hp
-$CHECK_COMPILER:
-$ if (.not. (its_decc .or. its_vaxc .or. its_gnuc))
-$ then
-$   its_decc = (f$search("SYS$SYSTEM:DECC$COMPILER.EXE") .nes. "")
-$   its_vaxc = .not. its_decc .and. (F$Search("SYS$System:VAXC.Exe") .nes. "")
-$   its_gnuc = .not. (its_decc .or. its_vaxc) .and. (f$trnlnm("gnu_cc") .nes. "")
-$ endif
-$!
-$! Exit if no compiler available
-$!
-$ if (.not. (its_decc .or. its_vaxc .or. its_gnuc))
-$ then goto CC_ERR
-$ else
-$   if its_decc
-$   then
-$     write sys$output "CC compiler check ... hp C"
-$     if f$trnlnm("decc$no_rooted_search_lists") .nes. ""
-$     then
-$       dnrsl = f$trnlnm("decc$no_rooted_search_lists")
-$     endif
-$     define/nolog decc$no_rooted_search_lists 1
-$   else
-$     if its_vaxc then write sys$output "CC compiler check ... VAX C"
-$     if its_gnuc
-$     then
-$         write sys$output "CC compiler check ... GNU C"
-$         if f$trnlnm(topt) then write topt "gnu_cc:[000000]gcclib.olb/lib"
-$         if f$trnlnm(optf) then write optf "gnu_cc:[000000]gcclib.olb/lib"
-$         cc = "gcc"
-$     endif
-$     if f$trnlnm(topt) then write topt "sys$share:vaxcrtl.exe/share"
-$     if f$trnlnm(optf) then write optf "sys$share:vaxcrtl.exe/share"
-$   endif
-$ endif
-$ return
-$!------------------------------------------------------------------------------
-$!
-$! If MMS/MMK are available dump out the descrip.mms if required
-$!
-$CREA_MMS:
-$ write sys$output "Creating descrip.mms..."
-$ create descrip.mms
-$ open/append out descrip.mms
-$ copy sys$input: out
-$ deck
-# descrip.mms: MMS description file for building zlib on VMS
-# written by Martin P.J. Zinser
-# <zinser@zinser.no-ip.info or martin.zinser@eurexchange.com>
-
-OBJS = adler32.obj, compress.obj, crc32.obj, gzclose.obj, gzlib.obj\
-       gzread.obj, gzwrite.obj, uncompr.obj, infback.obj\
-       deflate.obj, trees.obj, zutil.obj, inflate.obj, \
-       inftrees.obj, inffast.obj
-
-$ eod
-$ write out "CFLAGS=", ccopt
-$ write out "LOPTS=", lopts
-$ write out "all : example.exe minigzip.exe libz.olb"
-$ copy sys$input: out
-$ deck
-        @ write sys$output " Example applications available"
-
-libz.olb : libz.olb($(OBJS))
-	@ write sys$output " libz available"
-
-example.exe : example.obj libz.olb
-              link $(LOPTS) example,libz.olb/lib
-
-minigzip.exe : minigzip.obj libz.olb
-              link $(LOPTS) minigzip,libz.olb/lib
-
-clean :
-	delete *.obj;*,libz.olb;*,*.opt;*,*.exe;*
-
-
-# Other dependencies.
-adler32.obj  : adler32.c zutil.h zlib.h zconf.h
-compress.obj : compress.c zlib.h zconf.h
-crc32.obj    : crc32.c zutil.h zlib.h zconf.h
-deflate.obj  : deflate.c deflate.h zutil.h zlib.h zconf.h
-example.obj  : [.test]example.c zlib.h zconf.h
-gzclose.obj  : gzclose.c zutil.h zlib.h zconf.h
-gzlib.obj    : gzlib.c zutil.h zlib.h zconf.h
-gzread.obj   : gzread.c zutil.h zlib.h zconf.h
-gzwrite.obj  : gzwrite.c zutil.h zlib.h zconf.h
-inffast.obj  : inffast.c zutil.h zlib.h zconf.h inftrees.h inffast.h
-inflate.obj  : inflate.c zutil.h zlib.h zconf.h
-inftrees.obj : inftrees.c zutil.h zlib.h zconf.h inftrees.h
-minigzip.obj : [.test]minigzip.c zlib.h zconf.h
-trees.obj    : trees.c deflate.h zutil.h zlib.h zconf.h
-uncompr.obj  : uncompr.c zlib.h zconf.h
-zutil.obj    : zutil.c zutil.h zlib.h zconf.h
-infback.obj  : infback.c zutil.h inftrees.h inflate.h inffast.h inffixed.h
-$ eod
-$ close out
-$ return
-$!------------------------------------------------------------------------------
-$!
-$! Read list of core library sources from makefile.in and create options
-$! needed to build shareable image
-$!
-$CREA_OLIST:
-$ open/read min makefile.in
-$ open/write mod modules.opt
-$ src_check_list = "OBJZ =#OBJG ="
-$MRLOOP:
-$ read/end=mrdone min rec
-$ i = 0
-$SRC_CHECK_LOOP:
-$ src_check = f$element(i, "#", src_check_list)
-$ i = i+1
-$ if src_check .eqs. "#" then goto mrloop
-$ if (f$extract(0,6,rec) .nes. src_check) then goto src_check_loop
-$ rec = rec - src_check
-$ gosub extra_filnam
-$ if (f$element(1,"\",rec) .eqs. "\") then goto mrloop
-$MRSLOOP:
-$ read/end=mrdone min rec
-$ gosub extra_filnam
-$ if (f$element(1,"\",rec) .nes. "\") then goto mrsloop
-$MRDONE:
-$ close min
-$ close mod
-$ return
-$!------------------------------------------------------------------------------
-$!
-$! Take record extracted in crea_olist and split it into single filenames
-$!
-$EXTRA_FILNAM:
-$ myrec = f$edit(rec - "\", "trim,compress")
-$ i = 0
-$FELOOP:
-$ srcfil = f$element(i," ", myrec)
-$ if (srcfil .nes. " ")
-$ then
-$   write mod f$parse(srcfil,,,"NAME"), ".obj"
-$   i = i + 1
-$   goto feloop
-$ endif
-$ return
-$!------------------------------------------------------------------------------
-$!
-$! Find current Zlib version number
-$!
-$FIND_VERSION:
-$ open/read h_in 'v_file'
-$hloop:
-$ read/end=hdone h_in rec
-$ rec = f$edit(rec,"TRIM")
-$ if (f$extract(0,1,rec) .nes. "#") then goto hloop
-$ rec = f$edit(rec - "#", "TRIM")
-$ if f$element(0," ",rec) .nes. "define" then goto hloop
-$ if f$element(1," ",rec) .eqs. v_string
-$ then
-$   version = 'f$element(2," ",rec)'
-$   goto hdone
-$ endif
-$ goto hloop
-$hdone:
-$ close h_in
-$ return
-$!------------------------------------------------------------------------------
-$!
-$CHECK_CONFIG:
-$!
-$ in_ldef = f$locate(cdef,libdefs)
-$ if (in_ldef .lt. f$length(libdefs))
-$ then
-$   write aconf "#define ''cdef' 1"
-$   libdefs = f$extract(0,in_ldef,libdefs) + -
-              f$extract(in_ldef + f$length(cdef) + 1, -
-                        f$length(libdefs) - in_ldef - f$length(cdef) - 1, -
-                        libdefs)
-$ else
-$   if (f$type('cdef') .eqs. "INTEGER")
-$   then
-$     write aconf "#define ''cdef' ", 'cdef'
-$   else
-$     if (f$type('cdef') .eqs. "STRING")
-$     then
-$       write aconf "#define ''cdef' ", """", '''cdef'', """"
-$     else
-$       gosub check_cc_def
-$     endif
-$   endif
-$ endif
-$ return
-$!------------------------------------------------------------------------------
-$!
-$! Check if this is a define relating to the properties of the C/C++
-$! compiler
-$!
-$ CHECK_CC_DEF:
-$ if (cdef .eqs. "_LARGEFILE64_SOURCE")
-$ then
-$   copy sys$input: 'tc'
-$   deck
-#include "tconfig"
-#define _LARGEFILE
-#include <stdio.h>
-
-int main(){
-FILE *fp;
-  fp = fopen("temp.txt","r");
-  fseeko(fp,1,SEEK_SET);
-  fclose(fp);
-}
-
-$   eod
-$   test_inv = false
-$   comm_h = false
-$   gosub cc_prop_check
-$   return
-$ endif
-$ write aconf "/* ", line, " */"
-$ return
-$!------------------------------------------------------------------------------
-$!
-$! Check for properties of C/C++ compiler
-$!
-$! Version history
-$! 0.01 20031020 First version to receive a number
-$! 0.02 20031022 Added logic for defines with value
-$! 0.03 20040309 Make sure local config file gets not deleted
-$! 0.04 20041230 Also write include for configure run
-$! 0.05 20050103 Add processing of "comment defines"
-$CC_PROP_CHECK:
-$ cc_prop = true
-$ is_need = false
-$ is_need = (f$extract(0,4,cdef) .eqs. "NEED") .or. (test_inv .eq. true)
-$ if f$search(th) .eqs. "" then create 'th'
-$ set message/nofac/noident/nosever/notext
-$ on error then continue
-$ cc 'tmpnam'
-$ if .not. ($status)  then cc_prop = false
-$ on error then continue
-$! The headers might lie about the capabilities of the RTL
-$ link 'tmpnam',tmp.opt/opt
-$ if .not. ($status)  then cc_prop = false
-$ set message/fac/ident/sever/text
-$ on error then goto err_exit
-$ delete/nolog 'tmpnam'.*;*/exclude='th'
-$ if (cc_prop .and. .not. is_need) .or. -
-     (.not. cc_prop .and. is_need)
-$ then
-$   write sys$output "Checking for ''cdef'... yes"
-$   if f$type('cdef_val'_yes) .nes. ""
-$   then
-$     if f$type('cdef_val'_yes) .eqs. "INTEGER" -
-         then call write_config f$fao("#define !AS !UL",cdef,'cdef_val'_yes)
-$     if f$type('cdef_val'_yes) .eqs. "STRING" -
-         then call write_config f$fao("#define !AS !AS",cdef,'cdef_val'_yes)
-$   else
-$     call write_config f$fao("#define !AS 1",cdef)
-$   endif
-$   if (cdef .eqs. "HAVE_FSEEKO") .or. (cdef .eqs. "_LARGE_FILES") .or. -
-       (cdef .eqs. "_LARGEFILE64_SOURCE") then -
-      call write_config f$string("#define _LARGEFILE 1")
-$ else
-$   write sys$output "Checking for ''cdef'... no"
-$   if (comm_h)
-$   then
-      call write_config f$fao("/* !AS */",line)
-$   else
-$     if f$type('cdef_val'_no) .nes. ""
-$     then
-$       if f$type('cdef_val'_no) .eqs. "INTEGER" -
-           then call write_config f$fao("#define !AS !UL",cdef,'cdef_val'_no)
-$       if f$type('cdef_val'_no) .eqs. "STRING" -
-           then call write_config f$fao("#define !AS !AS",cdef,'cdef_val'_no)
-$     else
-$       call write_config f$fao("#undef !AS",cdef)
-$     endif
-$   endif
-$ endif
-$ return
-$!------------------------------------------------------------------------------
-$!
-$! Check for properties of C/C++ compiler with multiple result values
-$!
-$! Version history
-$! 0.01 20040127 First version
-$! 0.02 20050103 Reconcile changes from cc_prop up to version 0.05
-$CC_MPROP_CHECK:
-$ cc_prop = true
-$ i    = 1
-$ idel = 1
-$ MT_LOOP:
-$ if f$type(result_'i') .eqs. "STRING"
-$ then
-$   set message/nofac/noident/nosever/notext
-$   on error then continue
-$   cc 'tmpnam'_'i'
-$   if .not. ($status)  then cc_prop = false
-$   on error then continue
-$! The headers might lie about the capabilities of the RTL
-$   link 'tmpnam'_'i',tmp.opt/opt
-$   if .not. ($status)  then cc_prop = false
-$   set message/fac/ident/sever/text
-$   on error then goto err_exit
-$   delete/nolog 'tmpnam'_'i'.*;*
-$   if (cc_prop)
-$   then
-$     write sys$output "Checking for ''cdef'... ", mdef_'i'
-$     if f$type(mdef_'i') .eqs. "INTEGER" -
-         then call write_config f$fao("#define !AS !UL",cdef,mdef_'i')
-$     if f$type('cdef_val'_yes) .eqs. "STRING" -
-         then call write_config f$fao("#define !AS !AS",cdef,mdef_'i')
-$     goto msym_clean
-$   else
-$     i = i + 1
-$     goto mt_loop
-$   endif
-$ endif
-$ write sys$output "Checking for ''cdef'... no"
-$ call write_config f$fao("#undef !AS",cdef)
-$ MSYM_CLEAN:
-$ if (idel .le. msym_max)
-$ then
-$   delete/sym mdef_'idel'
-$   idel = idel + 1
-$   goto msym_clean
-$ endif
-$ return
-$!------------------------------------------------------------------------------
-$!
-$! Write configuration to both permanent and temporary config file
-$!
-$! Version history
-$! 0.01 20031029 First version to receive a number
-$!
-$WRITE_CONFIG: SUBROUTINE
-$  write aconf 'p1'
-$  open/append confh 'th'
-$  write confh 'p1'
-$  close confh
-$ENDSUBROUTINE
-$!------------------------------------------------------------------------------
-$!
-$! Analyze the project map file and create the symbol vector for a shareable
-$! image from it
-$!
-$! Version history
-$! 0.01 20120128 First version
-$! 0.02 20120226 Add pre-load logic
-$!
-$ MAP_2_SHOPT: Subroutine
-$!
-$ SAY := "WRITE_ SYS$OUTPUT"
-$!
-$ IF F$SEARCH("''P1'") .EQS. ""
-$ THEN
-$    SAY "MAP_2_SHOPT-E-NOSUCHFILE:  Error, inputfile ''p1' not available"
-$    goto exit_m2s
-$ ENDIF
-$ IF "''P2'" .EQS. ""
-$ THEN
-$    SAY "MAP_2_SHOPT:  Error, no output file provided"
-$    goto exit_m2s
-$ ENDIF
-$!
-$ module1 = "deflate#deflateEnd#deflateInit_#deflateParams#deflateSetDictionary"
-$ module2 = "gzclose#gzerror#gzgetc#gzgets#gzopen#gzprintf#gzputc#gzputs#gzread"
-$ module3 = "gzseek#gztell#inflate#inflateEnd#inflateInit_#inflateSetDictionary"
-$ module4 = "inflateSync#uncompress#zlibVersion#compress"
-$ open/read map 'p1
-$ if axp .or. ia64
-$ then
-$     open/write aopt a.opt
-$     open/write bopt b.opt
-$     write aopt " CASE_SENSITIVE=YES"
-$     write bopt "SYMBOL_VECTOR= (-"
-$     mod_sym_num = 1
-$ MOD_SYM_LOOP:
-$     if f$type(module'mod_sym_num') .nes. ""
-$     then
-$         mod_in = 0
-$ MOD_SYM_IN:
-$         shared_proc = f$element(mod_in, "#", module'mod_sym_num')
-$         if shared_proc .nes. "#"
-$         then
-$             write aopt f$fao(" symbol_vector=(!AS/!AS=PROCEDURE)",-
-        		       f$edit(shared_proc,"upcase"),shared_proc)
-$             write bopt f$fao("!AS=PROCEDURE,-",shared_proc)
-$             mod_in = mod_in + 1
-$             goto mod_sym_in
-$         endif
-$         mod_sym_num = mod_sym_num + 1
-$         goto mod_sym_loop
-$     endif
-$MAP_LOOP:
-$     read/end=map_end map line
-$     if (f$locate("{",line).lt. f$length(line)) .or. -
-         (f$locate("global:", line) .lt. f$length(line))
-$     then
-$         proc = true
-$         goto map_loop
-$     endif
-$     if f$locate("}",line).lt. f$length(line) then proc = false
-$     if f$locate("local:", line) .lt. f$length(line) then proc = false
-$     if proc
-$     then
-$         shared_proc = f$edit(line,"collapse")
-$         chop_semi = f$locate(";", shared_proc)
-$         if chop_semi .lt. f$length(shared_proc) then -
-              shared_proc = f$extract(0, chop_semi, shared_proc)
-$         write aopt f$fao(" symbol_vector=(!AS/!AS=PROCEDURE)",-
-        			 f$edit(shared_proc,"upcase"),shared_proc)
-$         write bopt f$fao("!AS=PROCEDURE,-",shared_proc)
-$     endif
-$     goto map_loop
-$MAP_END:
-$     close/nolog aopt
-$     close/nolog bopt
-$     open/append libopt 'p2'
-$     open/read aopt a.opt
-$     open/read bopt b.opt
-$ALOOP:
-$     read/end=aloop_end aopt line
-$     write libopt line
-$     goto aloop
-$ALOOP_END:
-$     close/nolog aopt
-$     sv = ""
-$BLOOP:
-$     read/end=bloop_end bopt svn
-$     if (svn.nes."")
-$     then
-$        if (sv.nes."") then write libopt sv
-$        sv = svn
-$     endif
-$     goto bloop
-$BLOOP_END:
-$     write libopt f$extract(0,f$length(sv)-2,sv), "-"
-$     write libopt ")"
-$     close/nolog bopt
-$     delete/nolog/noconf a.opt;*,b.opt;*
-$ else
-$     if vax
-$     then
-$     open/append libopt 'p2'
-$     mod_sym_num = 1
-$ VMOD_SYM_LOOP:
-$     if f$type(module'mod_sym_num') .nes. ""
-$     then
-$         mod_in = 0
-$ VMOD_SYM_IN:
-$         shared_proc = f$element(mod_in, "#", module'mod_sym_num')
-$         if shared_proc .nes. "#"
-$         then
-$     	      write libopt f$fao("UNIVERSAL=!AS",-
-      	  			     f$edit(shared_proc,"upcase"))
-$             mod_in = mod_in + 1
-$             goto vmod_sym_in
-$         endif
-$         mod_sym_num = mod_sym_num + 1
-$         goto vmod_sym_loop
-$     endif
-$VMAP_LOOP:
-$     	  read/end=vmap_end map line
-$     	  if (f$locate("{",line).lt. f$length(line)) .or. -
-   	      (f$locate("global:", line) .lt. f$length(line))
-$     	  then
-$     	      proc = true
-$     	      goto vmap_loop
-$     	  endif
-$     	  if f$locate("}",line).lt. f$length(line) then proc = false
-$     	  if f$locate("local:", line) .lt. f$length(line) then proc = false
-$     	  if proc
-$     	  then
-$     	      shared_proc = f$edit(line,"collapse")
-$     	      chop_semi = f$locate(";", shared_proc)
-$     	      if chop_semi .lt. f$length(shared_proc) then -
-      	  	  shared_proc = f$extract(0, chop_semi, shared_proc)
-$     	      write libopt f$fao("UNIVERSAL=!AS",-
-      	  			     f$edit(shared_proc,"upcase"))
-$     	  endif
-$     	  goto vmap_loop
-$VMAP_END:
-$     else
-$         write sys$output "Unknown Architecture (Not VAX, AXP, or IA64)"
-$         write sys$output "No options file created"
-$     endif
-$ endif
-$ EXIT_M2S:
-$ close/nolog map
-$ close/nolog libopt
-$ endsubroutine
diff -Nbaur gcc-4.8.1/zlib/minigzip.c gcc-4.8.1-ppc/zlib/minigzip.c
--- gcc-4.8.1/zlib/minigzip.c	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/minigzip.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,440 +0,0 @@
-/* minigzip.c -- simulate gzip using the zlib compression library
- * Copyright (C) 1995-2006, 2010 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- * minigzip is a minimal implementation of the gzip utility. This is
- * only an example of using zlib and isn't meant to replace the
- * full-featured gzip. No attempt is made to deal with file systems
- * limiting names to 14 or 8+3 characters, etc... Error checking is
- * very limited. So use minigzip only for testing; use gzip for the
- * real thing. On MSDOS, use only on file names without extension
- * or in pipe mode.
- */
-
-/* @(#) $Id: minigzip.c,v 1.1.1.2 2002/03/11 21:53:26 tromey Exp $ */
-
-#include "zlib.h"
-#include <stdio.h>
-
-#ifdef STDC
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-
-#ifdef USE_MMAP
-#  include <sys/types.h>
-#  include <sys/mman.h>
-#  include <sys/stat.h>
-#endif
-
-#if defined(MSDOS) || defined(OS2) || defined(WIN32) || defined(__CYGWIN__)
-#  include <fcntl.h>
-#  include <io.h>
-#  ifdef UNDER_CE
-#    include <stdlib.h>
-#  endif
-#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
-#else
-#  define SET_BINARY_MODE(file)
-#endif
-
-#ifdef VMS
-#  define unlink delete
-#  define GZ_SUFFIX "-gz"
-#endif
-#ifdef RISCOS
-#  define unlink remove
-#  define GZ_SUFFIX "-gz"
-#  define fileno(file) file->__file
-#endif
-#if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
-#  include <unix.h> /* for fileno */
-#endif
-
-#if !defined(Z_HAVE_UNISTD_H) && !defined(_LARGEFILE64_SOURCE)
-#ifndef WIN32 /* unlink already in stdio.h for WIN32 */
-  extern int unlink OF((const char *));
-#endif
-#endif
-
-#if defined(UNDER_CE)
-#  include <windows.h>
-#  define perror(s) pwinerror(s)
-
-/* Map the Windows error number in ERROR to a locale-dependent error
-   message string and return a pointer to it.  Typically, the values
-   for ERROR come from GetLastError.
-
-   The string pointed to shall not be modified by the application,
-   but may be overwritten by a subsequent call to strwinerror
-
-   The strwinerror function does not change the current setting
-   of GetLastError.  */
-
-static char *strwinerror (error)
-     DWORD error;
-{
-    static char buf[1024];
-
-    wchar_t *msgbuf;
-    DWORD lasterr = GetLastError();
-    DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
-        | FORMAT_MESSAGE_ALLOCATE_BUFFER,
-        NULL,
-        error,
-        0, /* Default language */
-        (LPVOID)&msgbuf,
-        0,
-        NULL);
-    if (chars != 0) {
-        /* If there is an \r\n appended, zap it.  */
-        if (chars >= 2
-            && msgbuf[chars - 2] == '\r' && msgbuf[chars - 1] == '\n') {
-            chars -= 2;
-            msgbuf[chars] = 0;
-        }
-
-        if (chars > sizeof (buf) - 1) {
-            chars = sizeof (buf) - 1;
-            msgbuf[chars] = 0;
-        }
-
-        wcstombs(buf, msgbuf, chars + 1);
-        LocalFree(msgbuf);
-    }
-    else {
-        sprintf(buf, "unknown win32 error (%ld)", error);
-    }
-
-    SetLastError(lasterr);
-    return buf;
-}
-
-static void pwinerror (s)
-    const char *s;
-{
-    if (s && *s)
-        fprintf(stderr, "%s: %s\n", s, strwinerror(GetLastError ()));
-    else
-        fprintf(stderr, "%s\n", strwinerror(GetLastError ()));
-}
-
-#endif /* UNDER_CE */
-
-#ifndef GZ_SUFFIX
-#  define GZ_SUFFIX ".gz"
-#endif
-#define SUFFIX_LEN (sizeof(GZ_SUFFIX)-1)
-
-#define BUFLEN      16384
-#define MAX_NAME_LEN 1024
-
-#ifdef MAXSEG_64K
-#  define local static
-   /* Needed for systems with limitation on stack size. */
-#else
-#  define local
-#endif
-
-char *prog;
-
-void error            OF((const char *msg));
-void gz_compress      OF((FILE   *in, gzFile out));
-#ifdef USE_MMAP
-int  gz_compress_mmap OF((FILE   *in, gzFile out));
-#endif
-void gz_uncompress    OF((gzFile in, FILE   *out));
-void file_compress    OF((char  *file, char *mode));
-void file_uncompress  OF((char  *file));
-int  main             OF((int argc, char *argv[]));
-
-/* ===========================================================================
- * Display error message and exit
- */
-void error(msg)
-    const char *msg;
-{
-    fprintf(stderr, "%s: %s\n", prog, msg);
-    exit(1);
-}
-
-/* ===========================================================================
- * Compress input to output then close both files.
- */
-
-void gz_compress(in, out)
-    FILE   *in;
-    gzFile out;
-{
-    local char buf[BUFLEN];
-    int len;
-    int err;
-
-#ifdef USE_MMAP
-    /* Try first compressing with mmap. If mmap fails (minigzip used in a
-     * pipe), use the normal fread loop.
-     */
-    if (gz_compress_mmap(in, out) == Z_OK) return;
-#endif
-    for (;;) {
-        len = (int)fread(buf, 1, sizeof(buf), in);
-        if (ferror(in)) {
-            perror("fread");
-            exit(1);
-        }
-        if (len == 0) break;
-
-        if (gzwrite(out, buf, (unsigned)len) != len) error(gzerror(out, &err));
-    }
-    fclose(in);
-    if (gzclose(out) != Z_OK) error("failed gzclose");
-}
-
-#ifdef USE_MMAP /* MMAP version, Miguel Albrecht <malbrech@eso.org> */
-
-/* Try compressing the input file at once using mmap. Return Z_OK if
- * if success, Z_ERRNO otherwise.
- */
-int gz_compress_mmap(in, out)
-    FILE   *in;
-    gzFile out;
-{
-    int len;
-    int err;
-    int ifd = fileno(in);
-    caddr_t buf;    /* mmap'ed buffer for the entire input file */
-    off_t buf_len;  /* length of the input file */
-    struct stat sb;
-
-    /* Determine the size of the file, needed for mmap: */
-    if (fstat(ifd, &sb) < 0) return Z_ERRNO;
-    buf_len = sb.st_size;
-    if (buf_len <= 0) return Z_ERRNO;
-
-    /* Now do the actual mmap: */
-    buf = mmap((caddr_t) 0, buf_len, PROT_READ, MAP_SHARED, ifd, (off_t)0);
-    if (buf == (caddr_t)(-1)) return Z_ERRNO;
-
-    /* Compress the whole file at once: */
-    len = gzwrite(out, (char *)buf, (unsigned)buf_len);
-
-    if (len != (int)buf_len) error(gzerror(out, &err));
-
-    munmap(buf, buf_len);
-    fclose(in);
-    if (gzclose(out) != Z_OK) error("failed gzclose");
-    return Z_OK;
-}
-#endif /* USE_MMAP */
-
-/* ===========================================================================
- * Uncompress input to output then close both files.
- */
-void gz_uncompress(in, out)
-    gzFile in;
-    FILE   *out;
-{
-    local char buf[BUFLEN];
-    int len;
-    int err;
-
-    for (;;) {
-        len = gzread(in, buf, sizeof(buf));
-        if (len < 0) error (gzerror(in, &err));
-        if (len == 0) break;
-
-        if ((int)fwrite(buf, 1, (unsigned)len, out) != len) {
-            error("failed fwrite");
-        }
-    }
-    if (fclose(out)) error("failed fclose");
-
-    if (gzclose(in) != Z_OK) error("failed gzclose");
-}
-
-
-/* ===========================================================================
- * Compress the given file: create a corresponding .gz file and remove the
- * original.
- */
-void file_compress(file, mode)
-    char  *file;
-    char  *mode;
-{
-    local char outfile[MAX_NAME_LEN];
-    FILE  *in;
-    gzFile out;
-
-    if (strlen(file) + strlen(GZ_SUFFIX) >= sizeof(outfile)) {
-        fprintf(stderr, "%s: filename too long\n", prog);
-        exit(1);
-    }
-
-    strcpy(outfile, file);
-    strcat(outfile, GZ_SUFFIX);
-
-    in = fopen(file, "rb");
-    if (in == NULL) {
-        perror(file);
-        exit(1);
-    }
-    out = gzopen(outfile, mode);
-    if (out == NULL) {
-        fprintf(stderr, "%s: can't gzopen %s\n", prog, outfile);
-        exit(1);
-    }
-    gz_compress(in, out);
-
-    unlink(file);
-}
-
-
-/* ===========================================================================
- * Uncompress the given file and remove the original.
- */
-void file_uncompress(file)
-    char  *file;
-{
-    local char buf[MAX_NAME_LEN];
-    char *infile, *outfile;
-    FILE  *out;
-    gzFile in;
-    size_t len = strlen(file);
-
-    if (len + strlen(GZ_SUFFIX) >= sizeof(buf)) {
-        fprintf(stderr, "%s: filename too long\n", prog);
-        exit(1);
-    }
-
-    strcpy(buf, file);
-
-    if (len > SUFFIX_LEN && strcmp(file+len-SUFFIX_LEN, GZ_SUFFIX) == 0) {
-        infile = file;
-        outfile = buf;
-        outfile[len-3] = '\0';
-    } else {
-        outfile = file;
-        infile = buf;
-        strcat(infile, GZ_SUFFIX);
-    }
-    in = gzopen(infile, "rb");
-    if (in == NULL) {
-        fprintf(stderr, "%s: can't gzopen %s\n", prog, infile);
-        exit(1);
-    }
-    out = fopen(outfile, "wb");
-    if (out == NULL) {
-        perror(file);
-        exit(1);
-    }
-
-    gz_uncompress(in, out);
-
-    unlink(infile);
-}
-
-
-/* ===========================================================================
- * Usage:  minigzip [-c] [-d] [-f] [-h] [-r] [-1 to -9] [files...]
- *   -c : write to standard output
- *   -d : decompress
- *   -f : compress with Z_FILTERED
- *   -h : compress with Z_HUFFMAN_ONLY
- *   -r : compress with Z_RLE
- *   -1 to -9 : compression level
- */
-
-int main(argc, argv)
-    int argc;
-    char *argv[];
-{
-    int copyout = 0;
-    int uncompr = 0;
-    gzFile file;
-    char *bname, outmode[20];
-
-    strcpy(outmode, "wb6 ");
-
-    prog = argv[0];
-    bname = strrchr(argv[0], '/');
-    if (bname)
-      bname++;
-    else
-      bname = argv[0];
-    argc--, argv++;
-
-    if (!strcmp(bname, "gunzip"))
-      uncompr = 1;
-    else if (!strcmp(bname, "zcat"))
-      copyout = uncompr = 1;
-
-    while (argc > 0) {
-      if (strcmp(*argv, "-c") == 0)
-        copyout = 1;
-      else if (strcmp(*argv, "-d") == 0)
-        uncompr = 1;
-      else if (strcmp(*argv, "-f") == 0)
-        outmode[3] = 'f';
-      else if (strcmp(*argv, "-h") == 0)
-        outmode[3] = 'h';
-      else if (strcmp(*argv, "-r") == 0)
-        outmode[3] = 'R';
-      else if ((*argv)[0] == '-' && (*argv)[1] >= '1' && (*argv)[1] <= '9' &&
-               (*argv)[2] == 0)
-        outmode[2] = (*argv)[1];
-      else
-        break;
-      argc--, argv++;
-    }
-    if (outmode[3] == ' ')
-        outmode[3] = 0;
-    if (argc == 0) {
-        SET_BINARY_MODE(stdin);
-        SET_BINARY_MODE(stdout);
-        if (uncompr) {
-            file = gzdopen(fileno(stdin), "rb");
-            if (file == NULL) error("can't gzdopen stdin");
-            gz_uncompress(file, stdout);
-        } else {
-            file = gzdopen(fileno(stdout), outmode);
-            if (file == NULL) error("can't gzdopen stdout");
-            gz_compress(stdin, file);
-        }
-    } else {
-        if (copyout) {
-            SET_BINARY_MODE(stdout);
-        }
-        do {
-            if (uncompr) {
-                if (copyout) {
-                    file = gzopen(*argv, "rb");
-                    if (file == NULL)
-                        fprintf(stderr, "%s: can't gzopen %s\n", prog, *argv);
-                    else
-                        gz_uncompress(file, stdout);
-                } else {
-                    file_uncompress(*argv);
-                }
-            } else {
-                if (copyout) {
-                    FILE * in = fopen(*argv, "rb");
-
-                    if (in == NULL) {
-                        perror(*argv);
-                    } else {
-                        file = gzdopen(fileno(stdout), outmode);
-                        if (file == NULL) error("can't gzdopen stdout");
-
-                        gz_compress(in, file);
-                    }
-
-                } else {
-                    file_compress(*argv, outmode);
-                }
-            }
-        } while (argv++, --argc);
-    }
-    return 0;
-}
diff -Nbaur gcc-4.8.1/zlib/msdos/Makefile.bor gcc-4.8.1-ppc/zlib/msdos/Makefile.bor
--- gcc-4.8.1/zlib/msdos/Makefile.bor	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/msdos/Makefile.bor	1970-01-01 01:00:00.000000000 +0100
@@ -1,115 +0,0 @@
-# Makefile for zlib
-# Borland C++
-# Last updated: 15-Mar-2003
-
-# To use, do "make -fmakefile.bor"
-# To compile in small model, set below: MODEL=s
-
-# WARNING: the small model is supported but only for small values of
-# MAX_WBITS and MAX_MEM_LEVEL. For example:
-#    -DMAX_WBITS=11 -DDEF_WBITS=11 -DMAX_MEM_LEVEL=3
-# If you wish to reduce the memory requirements (default 256K for big
-# objects plus a few K), you can add to the LOC macro below:
-#   -DMAX_MEM_LEVEL=7 -DMAX_WBITS=14
-# See zconf.h for details about the memory requirements.
-
-# ------------ Turbo C++, Borland C++ ------------
-
-#    Optional nonstandard preprocessor flags (e.g. -DMAX_MEM_LEVEL=7)
-#    should be added to the environment via "set LOCAL_ZLIB=-DFOO" or added
-#    to the declaration of LOC here:
-LOC = $(LOCAL_ZLIB)
-
-# type for CPU required: 0: 8086, 1: 80186, 2: 80286, 3: 80386, etc.
-CPU_TYP = 0
-
-# memory model: one of s, m, c, l (small, medium, compact, large)
-MODEL=l
-
-# replace bcc with tcc for Turbo C++ 1.0, with bcc32 for the 32 bit version
-CC=bcc
-LD=bcc
-AR=tlib
-
-# compiler flags
-# replace "-O2" by "-O -G -a -d" for Turbo C++ 1.0
-CFLAGS=-O2 -Z -m$(MODEL) $(LOC)
-
-LDFLAGS=-m$(MODEL) -f-
-
-
-# variables
-ZLIB_LIB = zlib_$(MODEL).lib
-
-OBJ1 = adler32.obj compress.obj crc32.obj deflate.obj gzclose.obj gzlib.obj gzread.obj
-OBJ2 = gzwrite.obj infback.obj inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj
-OBJP1 = +adler32.obj+compress.obj+crc32.obj+deflate.obj+gzclose.obj+gzlib.obj+gzread.obj
-OBJP2 = +gzwrite.obj+infback.obj+inffast.obj+inflate.obj+inftrees.obj+trees.obj+uncompr.obj+zutil.obj
-
-
-# targets
-all: $(ZLIB_LIB) example.exe minigzip.exe
-
-.c.obj:
-	$(CC) -c $(CFLAGS) $*.c
-
-adler32.obj: adler32.c zlib.h zconf.h
-
-compress.obj: compress.c zlib.h zconf.h
-
-crc32.obj: crc32.c zlib.h zconf.h crc32.h
-
-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h
-
-gzclose.obj: gzclose.c zlib.h zconf.h gzguts.h
-
-gzlib.obj: gzlib.c zlib.h zconf.h gzguts.h
-
-gzread.obj: gzread.c zlib.h zconf.h gzguts.h
-
-gzwrite.obj: gzwrite.c zlib.h zconf.h gzguts.h
-
-infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h
-
-inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h
-
-trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h
-
-uncompr.obj: uncompr.c zlib.h zconf.h
-
-zutil.obj: zutil.c zutil.h zlib.h zconf.h
-
-example.obj: test/example.c zlib.h zconf.h
-
-minigzip.obj: test/minigzip.c zlib.h zconf.h
-
-
-# the command line is cut to fit in the MS-DOS 128 byte limit:
-$(ZLIB_LIB): $(OBJ1) $(OBJ2)
-	-del $(ZLIB_LIB)
-	$(AR) $(ZLIB_LIB) $(OBJP1)
-	$(AR) $(ZLIB_LIB) $(OBJP2)
-
-example.exe: example.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) example.obj $(ZLIB_LIB)
-
-minigzip.exe: minigzip.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) minigzip.obj $(ZLIB_LIB)
-
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d
-
-clean:
-	-del *.obj
-	-del *.lib
-	-del *.exe
-	-del zlib_*.bak
-	-del foo.gz
diff -Nbaur gcc-4.8.1/zlib/msdos/Makefile.dj2 gcc-4.8.1-ppc/zlib/msdos/Makefile.dj2
--- gcc-4.8.1/zlib/msdos/Makefile.dj2	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/msdos/Makefile.dj2	1970-01-01 01:00:00.000000000 +0100
@@ -1,104 +0,0 @@
-# Makefile for zlib.  Modified for djgpp v2.0 by F. J. Donahoe, 3/15/96.
-# Copyright (C) 1995-1998 Jean-loup Gailly.
-# For conditions of distribution and use, see copyright notice in zlib.h
-
-# To compile, or to compile and test, type:
-#
-#   make -fmakefile.dj2;  make test -fmakefile.dj2
-#
-# To install libz.a, zconf.h and zlib.h in the djgpp directories, type:
-#
-#    make install -fmakefile.dj2
-#
-# after first defining LIBRARY_PATH and INCLUDE_PATH in djgpp.env as
-# in the sample below if the pattern of the DJGPP distribution is to
-# be followed.  Remember that, while <sp>'es around <=> are ignored in
-# makefiles, they are *not* in batch files or in djgpp.env.
-# - - - - -
-# [make]
-# INCLUDE_PATH=%\>;INCLUDE_PATH%%\DJDIR%\include
-# LIBRARY_PATH=%\>;LIBRARY_PATH%%\DJDIR%\lib
-# BUTT=-m486
-# - - - - -
-# Alternately, these variables may be defined below, overriding the values
-# in djgpp.env, as
-# INCLUDE_PATH=c:\usr\include
-# LIBRARY_PATH=c:\usr\lib
-
-CC=gcc
-
-#CFLAGS=-MMD -O
-#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7
-#CFLAGS=-MMD -g -DDEBUG
-CFLAGS=-MMD -O3 $(BUTT) -Wall -Wwrite-strings -Wpointer-arith -Wconversion \
-             -Wstrict-prototypes -Wmissing-prototypes
-
-# If cp.exe is available, replace "copy /Y" with "cp -fp" .
-CP=copy /Y
-# If gnu install.exe is available, replace $(CP) with ginstall.
-INSTALL=$(CP)
-# The default value of RM is "rm -f."  If "rm.exe" is found, comment out:
-RM=del
-LDLIBS=-L. -lz
-LD=$(CC) -s -o
-LDSHARED=$(CC)
-
-INCL=zlib.h zconf.h
-LIBS=libz.a
-
-AR=ar rcs
-
-prefix=/usr/local
-exec_prefix = $(prefix)
-
-OBJS = adler32.o compress.o crc32.o gzclose.o gzlib.o gzread.o gzwrite.o \
-       uncompr.o deflate.o trees.o zutil.o inflate.o infback.o inftrees.o inffast.o
-
-OBJA =
-# to use the asm code: make OBJA=match.o
-
-TEST_OBJS = example.o minigzip.o
-
-all: example.exe minigzip.exe
-
-check: test
-test: all
-	./example
-	echo hello world | .\minigzip | .\minigzip -d
-
-%.o : %.c
-	$(CC) $(CFLAGS) -c $< -o $@
-
-libz.a: $(OBJS) $(OBJA)
-	$(AR) $@ $(OBJS) $(OBJA)
-
-%.exe : %.o $(LIBS)
-	$(LD) $@ $< $(LDLIBS)
-
-# INCLUDE_PATH and LIBRARY_PATH were set for [make] in djgpp.env .
-
-.PHONY : uninstall clean
-
-install: $(INCL) $(LIBS)
-	-@if not exist $(INCLUDE_PATH)\nul mkdir $(INCLUDE_PATH)
-	-@if not exist $(LIBRARY_PATH)\nul mkdir $(LIBRARY_PATH)
-	$(INSTALL) zlib.h $(INCLUDE_PATH)
-	$(INSTALL) zconf.h $(INCLUDE_PATH)
-	$(INSTALL) libz.a $(LIBRARY_PATH)
-
-uninstall:
-	$(RM) $(INCLUDE_PATH)\zlib.h
-	$(RM) $(INCLUDE_PATH)\zconf.h
-	$(RM) $(LIBRARY_PATH)\libz.a
-
-clean:
-	$(RM) *.d
-	$(RM) *.o
-	$(RM) *.exe
-	$(RM) libz.a
-	$(RM) foo.gz
-
-DEPS := $(wildcard *.d)
-ifneq ($(DEPS),)
-include $(DEPS)
-endif
diff -Nbaur gcc-4.8.1/zlib/msdos/Makefile.emx gcc-4.8.1-ppc/zlib/msdos/Makefile.emx
--- gcc-4.8.1/zlib/msdos/Makefile.emx	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/msdos/Makefile.emx	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-# Makefile for zlib.  Modified for emx 0.9c by Chr. Spieler, 6/17/98.
-# Copyright (C) 1995-1998 Jean-loup Gailly.
-# For conditions of distribution and use, see copyright notice in zlib.h
-
-# To compile, or to compile and test, type:
-#
-#   make -fmakefile.emx;  make test -fmakefile.emx
-#
-
-CC=gcc
-
-#CFLAGS=-MMD -O
-#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7
-#CFLAGS=-MMD -g -DDEBUG
-CFLAGS=-MMD -O3 $(BUTT) -Wall -Wwrite-strings -Wpointer-arith -Wconversion \
-             -Wstrict-prototypes -Wmissing-prototypes
-
-# If cp.exe is available, replace "copy /Y" with "cp -fp" .
-CP=copy /Y
-# If gnu install.exe is available, replace $(CP) with ginstall.
-INSTALL=$(CP)
-# The default value of RM is "rm -f."  If "rm.exe" is found, comment out:
-RM=del
-LDLIBS=-L. -lzlib
-LD=$(CC) -s -o
-LDSHARED=$(CC)
-
-INCL=zlib.h zconf.h
-LIBS=zlib.a
-
-AR=ar rcs
-
-prefix=/usr/local
-exec_prefix = $(prefix)
-
-OBJS = adler32.o compress.o crc32.o gzclose.o gzlib.o gzread.o gzwrite.o \
-       uncompr.o deflate.o trees.o zutil.o inflate.o infback.o inftrees.o inffast.o
-
-TEST_OBJS = example.o minigzip.o
-
-all: example.exe minigzip.exe
-
-test: all
-	./example
-	echo hello world | .\minigzip | .\minigzip -d
-
-%.o : %.c
-	$(CC) $(CFLAGS) -c $< -o $@
-
-zlib.a: $(OBJS)
-	$(AR) $@ $(OBJS)
-
-%.exe : %.o $(LIBS)
-	$(LD) $@ $< $(LDLIBS)
-
-
-.PHONY : clean
-
-clean:
-	$(RM) *.d
-	$(RM) *.o
-	$(RM) *.exe
-	$(RM) zlib.a
-	$(RM) foo.gz
-
-DEPS := $(wildcard *.d)
-ifneq ($(DEPS),)
-include $(DEPS)
-endif
diff -Nbaur gcc-4.8.1/zlib/msdos/Makefile.msc gcc-4.8.1-ppc/zlib/msdos/Makefile.msc
--- gcc-4.8.1/zlib/msdos/Makefile.msc	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/msdos/Makefile.msc	1970-01-01 01:00:00.000000000 +0100
@@ -1,112 +0,0 @@
-# Makefile for zlib
-# Microsoft C 5.1 or later
-# Last updated: 19-Mar-2003
-
-# To use, do "make makefile.msc"
-# To compile in small model, set below: MODEL=S
-
-# If you wish to reduce the memory requirements (default 256K for big
-# objects plus a few K), you can add to the LOC macro below:
-#   -DMAX_MEM_LEVEL=7 -DMAX_WBITS=14
-# See zconf.h for details about the memory requirements.
-
-# ------------- Microsoft C 5.1 and later -------------
-
-#    Optional nonstandard preprocessor flags (e.g. -DMAX_MEM_LEVEL=7)
-#    should be added to the environment via "set LOCAL_ZLIB=-DFOO" or added
-#    to the declaration of LOC here:
-LOC = $(LOCAL_ZLIB)
-
-# Type for CPU required: 0: 8086, 1: 80186, 2: 80286, 3: 80386, etc.
-CPU_TYP = 0
-
-# Memory model: one of S, M, C, L (small, medium, compact, large)
-MODEL=L
-
-CC=cl
-CFLAGS=-nologo -A$(MODEL) -G$(CPU_TYP) -W3 -Oait -Gs $(LOC)
-#-Ox generates bad code with MSC 5.1
-LIB_CFLAGS=-Zl $(CFLAGS)
-
-LD=link
-LDFLAGS=/noi/e/st:0x1500/noe/farcall/packcode
-# "/farcall/packcode" are only useful for `large code' memory models
-# but should be a "no-op" for small code models.
-
-
-# variables
-ZLIB_LIB = zlib_$(MODEL).lib
-
-OBJ1 = adler32.obj compress.obj crc32.obj deflate.obj gzclose.obj gzlib.obj gzread.obj
-OBJ2 = gzwrite.obj infback.obj inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj
-
-
-# targets
-all:  $(ZLIB_LIB) example.exe minigzip.exe
-
-.c.obj:
-	$(CC) -c $(LIB_CFLAGS) $*.c
-
-adler32.obj: adler32.c zlib.h zconf.h
-
-compress.obj: compress.c zlib.h zconf.h
-
-crc32.obj: crc32.c zlib.h zconf.h crc32.h
-
-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h
-
-gzclose.obj: gzclose.c zlib.h zconf.h gzguts.h
-
-gzlib.obj: gzlib.c zlib.h zconf.h gzguts.h
-
-gzread.obj: gzread.c zlib.h zconf.h gzguts.h
-
-gzwrite.obj: gzwrite.c zlib.h zconf.h gzguts.h
-
-infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h
-
-inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h
-
-trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h
-
-uncompr.obj: uncompr.c zlib.h zconf.h
-
-zutil.obj: zutil.c zutil.h zlib.h zconf.h
-
-example.obj: test/example.c zlib.h zconf.h
-	$(CC) -c $(CFLAGS) $*.c
-
-minigzip.obj: test/minigzip.c zlib.h zconf.h
-	$(CC) -c $(CFLAGS) $*.c
-
-
-# the command line is cut to fit in the MS-DOS 128 byte limit:
-$(ZLIB_LIB): $(OBJ1) $(OBJ2)
-	if exist $(ZLIB_LIB) del $(ZLIB_LIB)
-	lib $(ZLIB_LIB) $(OBJ1);
-	lib $(ZLIB_LIB) $(OBJ2);
-
-example.exe: example.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) example.obj,,,$(ZLIB_LIB);
-
-minigzip.exe: minigzip.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) minigzip.obj,,,$(ZLIB_LIB);
-
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d
-
-clean:
-	-del *.obj
-	-del *.lib
-	-del *.exe
-	-del *.map
-	-del zlib_*.bak
-	-del foo.gz
diff -Nbaur gcc-4.8.1/zlib/msdos/Makefile.tc gcc-4.8.1-ppc/zlib/msdos/Makefile.tc
--- gcc-4.8.1/zlib/msdos/Makefile.tc	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/msdos/Makefile.tc	1970-01-01 01:00:00.000000000 +0100
@@ -1,100 +0,0 @@
-# Makefile for zlib
-# Turbo C 2.01, Turbo C++ 1.01
-# Last updated: 15-Mar-2003
-
-# To use, do "make -fmakefile.tc"
-# To compile in small model, set below: MODEL=s
-
-# WARNING: the small model is supported but only for small values of
-# MAX_WBITS and MAX_MEM_LEVEL. For example:
-#    -DMAX_WBITS=11 -DMAX_MEM_LEVEL=3
-# If you wish to reduce the memory requirements (default 256K for big
-# objects plus a few K), you can add to CFLAGS below:
-#   -DMAX_MEM_LEVEL=7 -DMAX_WBITS=14
-# See zconf.h for details about the memory requirements.
-
-# ------------ Turbo C 2.01, Turbo C++ 1.01 ------------
-MODEL=l
-CC=tcc
-LD=tcc
-AR=tlib
-# CFLAGS=-O2 -G -Z -m$(MODEL) -DMAX_WBITS=11 -DMAX_MEM_LEVEL=3
-CFLAGS=-O2 -G -Z -m$(MODEL)
-LDFLAGS=-m$(MODEL) -f-
-
-
-# variables
-ZLIB_LIB = zlib_$(MODEL).lib
-
-OBJ1 = adler32.obj compress.obj crc32.obj deflate.obj gzclose.obj gzlib.obj gzread.obj
-OBJ2 = gzwrite.obj infback.obj inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj
-OBJP1 = +adler32.obj+compress.obj+crc32.obj+deflate.obj+gzclose.obj+gzlib.obj+gzread.obj
-OBJP2 = +gzwrite.obj+infback.obj+inffast.obj+inflate.obj+inftrees.obj+trees.obj+uncompr.obj+zutil.obj
-
-
-# targets
-all: $(ZLIB_LIB) example.exe minigzip.exe
-
-.c.obj:
-	$(CC) -c $(CFLAGS) $*.c
-
-adler32.obj: adler32.c zlib.h zconf.h
-
-compress.obj: compress.c zlib.h zconf.h
-
-crc32.obj: crc32.c zlib.h zconf.h crc32.h
-
-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h
-
-gzclose.obj: gzclose.c zlib.h zconf.h gzguts.h
-
-gzlib.obj: gzlib.c zlib.h zconf.h gzguts.h
-
-gzread.obj: gzread.c zlib.h zconf.h gzguts.h
-
-gzwrite.obj: gzwrite.c zlib.h zconf.h gzguts.h
-
-infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h
-
-inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h
-
-trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h
-
-uncompr.obj: uncompr.c zlib.h zconf.h
-
-zutil.obj: zutil.c zutil.h zlib.h zconf.h
-
-example.obj: test/example.c zlib.h zconf.h
-
-minigzip.obj: test/minigzip.c zlib.h zconf.h
-
-
-# the command line is cut to fit in the MS-DOS 128 byte limit:
-$(ZLIB_LIB): $(OBJ1) $(OBJ2)
-	-del $(ZLIB_LIB)
-	$(AR) $(ZLIB_LIB) $(OBJP1)
-	$(AR) $(ZLIB_LIB) $(OBJP2)
-
-example.exe: example.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) example.obj $(ZLIB_LIB)
-
-minigzip.exe: minigzip.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) minigzip.obj $(ZLIB_LIB)
-
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d
-
-clean:
-	-del *.obj
-	-del *.lib
-	-del *.exe
-	-del zlib_*.bak
-	-del foo.gz
diff -Nbaur gcc-4.8.1/zlib/nintendods/Makefile gcc-4.8.1-ppc/zlib/nintendods/Makefile
--- gcc-4.8.1/zlib/nintendods/Makefile	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/nintendods/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,126 +0,0 @@
-#---------------------------------------------------------------------------------
-.SUFFIXES:
-#---------------------------------------------------------------------------------
-
-ifeq ($(strip $(DEVKITARM)),)
-$(error "Please set DEVKITARM in your environment. export DEVKITARM=<path to>devkitARM")
-endif
-
-include $(DEVKITARM)/ds_rules
-
-#---------------------------------------------------------------------------------
-# TARGET is the name of the output
-# BUILD is the directory where object files & intermediate files will be placed
-# SOURCES is a list of directories containing source code
-# DATA is a list of directories containing data files
-# INCLUDES is a list of directories containing header files
-#---------------------------------------------------------------------------------
-TARGET		:=	$(shell basename $(CURDIR))
-BUILD		:=	build
-SOURCES		:=	../../
-DATA		:=	data
-INCLUDES	:=	include
-
-#---------------------------------------------------------------------------------
-# options for code generation
-#---------------------------------------------------------------------------------
-ARCH	:=	-mthumb -mthumb-interwork
-
-CFLAGS	:=	-Wall -O2\
-		-march=armv5te -mtune=arm946e-s \
-		-fomit-frame-pointer -ffast-math \
-		$(ARCH)
-
-CFLAGS	+=	$(INCLUDE) -DARM9
-CXXFLAGS	:= $(CFLAGS) -fno-rtti -fno-exceptions
-
-ASFLAGS	:=	$(ARCH) -march=armv5te -mtune=arm946e-s
-LDFLAGS	=	-specs=ds_arm9.specs -g $(ARCH) -Wl,-Map,$(notdir $*.map)
-
-#---------------------------------------------------------------------------------
-# list of directories containing libraries, this must be the top level containing
-# include and lib
-#---------------------------------------------------------------------------------
-LIBDIRS	:=	$(LIBNDS)
-
-#---------------------------------------------------------------------------------
-# no real need to edit anything past this point unless you need to add additional
-# rules for different file extensions
-#---------------------------------------------------------------------------------
-ifneq ($(BUILD),$(notdir $(CURDIR)))
-#---------------------------------------------------------------------------------
-
-export OUTPUT	:=	$(CURDIR)/lib/libz.a
-
-export VPATH	:=	$(foreach dir,$(SOURCES),$(CURDIR)/$(dir)) \
-			$(foreach dir,$(DATA),$(CURDIR)/$(dir))
-
-export DEPSDIR	:=	$(CURDIR)/$(BUILD)
-
-CFILES		:=	$(foreach dir,$(SOURCES),$(notdir $(wildcard $(dir)/*.c)))
-CPPFILES	:=	$(foreach dir,$(SOURCES),$(notdir $(wildcard $(dir)/*.cpp)))
-SFILES		:=	$(foreach dir,$(SOURCES),$(notdir $(wildcard $(dir)/*.s)))
-BINFILES	:=	$(foreach dir,$(DATA),$(notdir $(wildcard $(dir)/*.*)))
-
-#---------------------------------------------------------------------------------
-# use CXX for linking C++ projects, CC for standard C
-#---------------------------------------------------------------------------------
-ifeq ($(strip $(CPPFILES)),)
-#---------------------------------------------------------------------------------
-	export LD	:=	$(CC)
-#---------------------------------------------------------------------------------
-else
-#---------------------------------------------------------------------------------
-	export LD	:=	$(CXX)
-#---------------------------------------------------------------------------------
-endif
-#---------------------------------------------------------------------------------
-
-export OFILES	:=	$(addsuffix .o,$(BINFILES)) \
-			$(CPPFILES:.cpp=.o) $(CFILES:.c=.o) $(SFILES:.s=.o)
-
-export INCLUDE	:=	$(foreach dir,$(INCLUDES),-I$(CURDIR)/$(dir)) \
-			$(foreach dir,$(LIBDIRS),-I$(dir)/include) \
-			-I$(CURDIR)/$(BUILD)
-
-.PHONY: $(BUILD) clean all
-
-#---------------------------------------------------------------------------------
-all: $(BUILD)
-	@[ -d $@ ] || mkdir -p include
-	@cp ../../*.h include
-
-lib:
-	@[ -d $@ ] || mkdir -p $@
-	
-$(BUILD): lib
-	@[ -d $@ ] || mkdir -p $@
-	@$(MAKE) --no-print-directory -C $(BUILD) -f $(CURDIR)/Makefile
-
-#---------------------------------------------------------------------------------
-clean:
-	@echo clean ...
-	@rm -fr $(BUILD) lib
-
-#---------------------------------------------------------------------------------
-else
-
-DEPENDS	:=	$(OFILES:.o=.d)
-
-#---------------------------------------------------------------------------------
-# main targets
-#---------------------------------------------------------------------------------
-$(OUTPUT)	:	$(OFILES)
-
-#---------------------------------------------------------------------------------
-%.bin.o	:	%.bin
-#---------------------------------------------------------------------------------
-	@echo $(notdir $<)
-	@$(bin2o)
-
-
--include $(DEPENDS)
-
-#---------------------------------------------------------------------------------------
-endif
-#---------------------------------------------------------------------------------------
diff -Nbaur gcc-4.8.1/zlib/nintendods/README gcc-4.8.1-ppc/zlib/nintendods/README
--- gcc-4.8.1/zlib/nintendods/README	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/nintendods/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-This Makefile requires devkitARM (http://www.devkitpro.org/category/devkitarm/) and works inside "contrib/nds". It is based on a devkitARM template.
-
-Eduardo Costa <eduardo.m.costa@gmail.com>
-January 3, 2009
-
diff -Nbaur gcc-4.8.1/zlib/old/descrip.mms gcc-4.8.1-ppc/zlib/old/descrip.mms
--- gcc-4.8.1/zlib/old/descrip.mms	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/old/descrip.mms	1970-01-01 01:00:00.000000000 +0100
@@ -1,48 +0,0 @@
-# descrip.mms: MMS description file for building zlib on VMS
-# written by Martin P.J. Zinser <m.zinser@gsi.de>
-
-cc_defs =
-c_deb =
-
-.ifdef __DECC__
-pref = /prefix=all
-.endif
-
-OBJS = adler32.obj, compress.obj, crc32.obj, gzio.obj, uncompr.obj,\
-       deflate.obj, trees.obj, zutil.obj, inflate.obj, infblock.obj,\
-       inftrees.obj, infcodes.obj, infutil.obj, inffast.obj
-
-CFLAGS= $(C_DEB) $(CC_DEFS) $(PREF)
-
-all : example.exe minigzip.exe
-        @ write sys$output " Example applications available"
-libz.olb : libz.olb($(OBJS))
-	@ write sys$output " libz available"
-
-example.exe : example.obj libz.olb
-              link example,libz.olb/lib
-
-minigzip.exe : minigzip.obj libz.olb
-              link minigzip,libz.olb/lib,x11vms:xvmsutils.olb/lib
-
-clean :
-	delete *.obj;*,libz.olb;*
-
-
-# Other dependencies.
-adler32.obj : zutil.h zlib.h zconf.h
-compress.obj : zlib.h zconf.h
-crc32.obj : zutil.h zlib.h zconf.h
-deflate.obj : deflate.h zutil.h zlib.h zconf.h
-example.obj : zlib.h zconf.h
-gzio.obj : zutil.h zlib.h zconf.h
-infblock.obj : zutil.h zlib.h zconf.h infblock.h inftrees.h infcodes.h infutil.h
-infcodes.obj : zutil.h zlib.h zconf.h inftrees.h infutil.h infcodes.h inffast.h
-inffast.obj : zutil.h zlib.h zconf.h inftrees.h infutil.h inffast.h
-inflate.obj : zutil.h zlib.h zconf.h infblock.h
-inftrees.obj : zutil.h zlib.h zconf.h inftrees.h
-infutil.obj : zutil.h zlib.h zconf.h inftrees.h infutil.h
-minigzip.obj : zlib.h zconf.h
-trees.obj : deflate.h zutil.h zlib.h zconf.h
-uncompr.obj : zlib.h zconf.h
-zutil.obj : zutil.h zlib.h zconf.h
diff -Nbaur gcc-4.8.1/zlib/old/Makefile.emx gcc-4.8.1-ppc/zlib/old/Makefile.emx
--- gcc-4.8.1/zlib/old/Makefile.emx	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/old/Makefile.emx	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-# Makefile for zlib.  Modified for emx/rsxnt by Chr. Spieler, 6/16/98.
-# Copyright (C) 1995-1998 Jean-loup Gailly.
-# For conditions of distribution and use, see copyright notice in zlib.h
-
-# To compile, or to compile and test, type:
-#
-#   make -fmakefile.emx;  make test -fmakefile.emx
-#
-
-CC=gcc -Zwin32
-
-#CFLAGS=-MMD -O
-#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7
-#CFLAGS=-MMD -g -DDEBUG
-CFLAGS=-MMD -O3 $(BUTT) -Wall -Wwrite-strings -Wpointer-arith -Wconversion \
-             -Wstrict-prototypes -Wmissing-prototypes
-
-# If cp.exe is available, replace "copy /Y" with "cp -fp" .
-CP=copy /Y
-# If gnu install.exe is available, replace $(CP) with ginstall.
-INSTALL=$(CP)
-# The default value of RM is "rm -f."  If "rm.exe" is found, comment out:
-RM=del
-LDLIBS=-L. -lzlib
-LD=$(CC) -s -o
-LDSHARED=$(CC)
-
-INCL=zlib.h zconf.h
-LIBS=zlib.a
-
-AR=ar rcs
-
-prefix=/usr/local
-exec_prefix = $(prefix)
-
-OBJS = adler32.o compress.o crc32.o deflate.o gzclose.o gzlib.o gzread.o \
-       gzwrite.o infback.o inffast.o inflate.o inftrees.o trees.o uncompr.o zutil.o
-
-TEST_OBJS = example.o minigzip.o
-
-all: example.exe minigzip.exe
-
-test: all
-	./example
-	echo hello world | .\minigzip | .\minigzip -d
-
-%.o : %.c
-	$(CC) $(CFLAGS) -c $< -o $@
-
-zlib.a: $(OBJS)
-	$(AR) $@ $(OBJS)
-
-%.exe : %.o $(LIBS)
-	$(LD) $@ $< $(LDLIBS)
-
-
-.PHONY : clean
-
-clean:
-	$(RM) *.d
-	$(RM) *.o
-	$(RM) *.exe
-	$(RM) zlib.a
-	$(RM) foo.gz
-
-DEPS := $(wildcard *.d)
-ifneq ($(DEPS),)
-include $(DEPS)
-endif
diff -Nbaur gcc-4.8.1/zlib/old/Makefile.riscos gcc-4.8.1-ppc/zlib/old/Makefile.riscos
--- gcc-4.8.1/zlib/old/Makefile.riscos	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/old/Makefile.riscos	1970-01-01 01:00:00.000000000 +0100
@@ -1,151 +0,0 @@
-# Project:   zlib_1_03
-# Patched for zlib 1.1.2 rw@shadow.org.uk 19980430
-# test works out-of-the-box, installs `somewhere' on demand
-
-# Toolflags:
-CCflags = -c -depend !Depend -IC: -g -throwback  -DRISCOS  -fah
-C++flags = -c -depend !Depend -IC: -throwback
-Linkflags = -aif -c++ -o $@
-ObjAsmflags = -throwback -NoCache -depend !Depend
-CMHGflags =
-LibFileflags = -c -l -o $@
-Squeezeflags = -o $@
-
-# change the line below to where _you_ want the library installed.
-libdest = lib:zlib
-
-# Final targets:
-@.lib:   @.o.adler32 @.o.compress @.o.crc32 @.o.deflate @.o.gzio \
-        @.o.infblock @.o.infcodes @.o.inffast @.o.inflate @.o.inftrees @.o.infutil @.o.trees \
-        @.o.uncompr @.o.zutil
-        LibFile $(LibFileflags) @.o.adler32 @.o.compress @.o.crc32 @.o.deflate \
-        @.o.gzio @.o.infblock @.o.infcodes @.o.inffast @.o.inflate @.o.inftrees @.o.infutil \
-        @.o.trees @.o.uncompr @.o.zutil
-test:   @.minigzip @.example @.lib
-	@copy @.lib @.libc  A~C~DF~L~N~P~Q~RS~TV
-	@echo running tests: hang on.
-	@/@.minigzip -f -9 libc
-	@/@.minigzip -d libc-gz
-	@/@.minigzip -f -1 libc
-	@/@.minigzip -d libc-gz
-	@/@.minigzip -h -9 libc
-	@/@.minigzip -d libc-gz
-	@/@.minigzip -h -1 libc
-	@/@.minigzip -d libc-gz
-	@/@.minigzip -9 libc
-	@/@.minigzip -d libc-gz
-	@/@.minigzip -1 libc
-	@/@.minigzip -d libc-gz
-	@diff @.lib @.libc
-	@echo that should have reported '@.lib and @.libc identical' if you have diff.
-	@/@.example @.fred @.fred
-	@echo that will have given lots of hello!'s.
-
-@.minigzip:   @.o.minigzip @.lib C:o.Stubs
-        Link $(Linkflags) @.o.minigzip @.lib C:o.Stubs
-@.example:   @.o.example @.lib C:o.Stubs
-        Link $(Linkflags) @.o.example @.lib C:o.Stubs
-
-install: @.lib
-	cdir $(libdest)
-	cdir $(libdest).h
-	@copy @.h.zlib $(libdest).h.zlib A~C~DF~L~N~P~Q~RS~TV
-	@copy @.h.zconf $(libdest).h.zconf A~C~DF~L~N~P~Q~RS~TV
-	@copy @.lib $(libdest).lib  A~C~DF~L~N~P~Q~RS~TV
-	@echo okay, installed zlib in $(libdest)
-
-clean:; remove @.minigzip
-	remove @.example
-	remove @.libc
-	-wipe @.o.* F~r~cV
-	remove @.fred
-
-# User-editable dependencies:
-.c.o:
-        cc $(ccflags) -o $@ $<
-
-# Static dependencies:
-
-# Dynamic dependencies:
-o.example:	c.example
-o.example:	h.zlib
-o.example:	h.zconf
-o.minigzip:	c.minigzip
-o.minigzip:	h.zlib
-o.minigzip:	h.zconf
-o.adler32:	c.adler32
-o.adler32:	h.zlib
-o.adler32:	h.zconf
-o.compress:	c.compress
-o.compress:	h.zlib
-o.compress:	h.zconf
-o.crc32:	c.crc32
-o.crc32:	h.zlib
-o.crc32:	h.zconf
-o.deflate:	c.deflate
-o.deflate:	h.deflate
-o.deflate:	h.zutil
-o.deflate:	h.zlib
-o.deflate:	h.zconf
-o.gzio:	c.gzio
-o.gzio:	h.zutil
-o.gzio:	h.zlib
-o.gzio:	h.zconf
-o.infblock:	c.infblock
-o.infblock:	h.zutil
-o.infblock:	h.zlib
-o.infblock:	h.zconf
-o.infblock:	h.infblock
-o.infblock:	h.inftrees
-o.infblock:	h.infcodes
-o.infblock:	h.infutil
-o.infcodes:	c.infcodes
-o.infcodes:	h.zutil
-o.infcodes:	h.zlib
-o.infcodes:	h.zconf
-o.infcodes:	h.inftrees
-o.infcodes:	h.infblock
-o.infcodes:	h.infcodes
-o.infcodes:	h.infutil
-o.infcodes:	h.inffast
-o.inffast:	c.inffast
-o.inffast:	h.zutil
-o.inffast:	h.zlib
-o.inffast:	h.zconf
-o.inffast:	h.inftrees
-o.inffast:	h.infblock
-o.inffast:	h.infcodes
-o.inffast:	h.infutil
-o.inffast:	h.inffast
-o.inflate:	c.inflate
-o.inflate:	h.zutil
-o.inflate:	h.zlib
-o.inflate:	h.zconf
-o.inflate:	h.infblock
-o.inftrees:	c.inftrees
-o.inftrees:	h.zutil
-o.inftrees:	h.zlib
-o.inftrees:	h.zconf
-o.inftrees:	h.inftrees
-o.inftrees:	h.inffixed
-o.infutil:	c.infutil
-o.infutil:	h.zutil
-o.infutil:	h.zlib
-o.infutil:	h.zconf
-o.infutil:	h.infblock
-o.infutil:	h.inftrees
-o.infutil:	h.infcodes
-o.infutil:	h.infutil
-o.trees:	c.trees
-o.trees:	h.deflate
-o.trees:	h.zutil
-o.trees:	h.zlib
-o.trees:	h.zconf
-o.trees:	h.trees
-o.uncompr:	c.uncompr
-o.uncompr:	h.zlib
-o.uncompr:	h.zconf
-o.zutil:	c.zutil
-o.zutil:	h.zutil
-o.zutil:	h.zlib
-o.zutil:	h.zconf
diff -Nbaur gcc-4.8.1/zlib/old/os2/Makefile.os2 gcc-4.8.1-ppc/zlib/old/os2/Makefile.os2
--- gcc-4.8.1/zlib/old/os2/Makefile.os2	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/old/os2/Makefile.os2	1970-01-01 01:00:00.000000000 +0100
@@ -1,136 +0,0 @@
-# Makefile for zlib under OS/2 using GCC (PGCC)
-# For conditions of distribution and use, see copyright notice in zlib.h
-
-# To compile and test, type:
-#   cp Makefile.os2 ..
-#   cd ..
-#   make -f Makefile.os2 test
-
-# This makefile will build a static library z.lib, a shared library
-# z.dll and a import library zdll.lib. You can use either z.lib or
-# zdll.lib by specifying either -lz or -lzdll on gcc's command line
-
-CC=gcc -Zomf -s
-
-CFLAGS=-O6 -Wall
-#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7
-#CFLAGS=-g -DDEBUG
-#CFLAGS=-O3 -Wall -Wwrite-strings -Wpointer-arith -Wconversion \
-#           -Wstrict-prototypes -Wmissing-prototypes
-
-#################### BUG WARNING: #####################
-## infcodes.c hits a bug in pgcc-1.0, so you have to use either
-## -O# where # <= 4 or one of (-fno-ommit-frame-pointer or -fno-force-mem)
-## This bug is reportedly fixed in pgcc >1.0, but this was not tested
-CFLAGS+=-fno-force-mem
-
-LDFLAGS=-s -L. -lzdll -Zcrtdll
-LDSHARED=$(CC) -s -Zomf -Zdll -Zcrtdll
-
-VER=1.1.0
-ZLIB=z.lib
-SHAREDLIB=z.dll
-SHAREDLIBIMP=zdll.lib
-LIBS=$(ZLIB) $(SHAREDLIB) $(SHAREDLIBIMP)
-
-AR=emxomfar cr
-IMPLIB=emximp
-RANLIB=echo
-TAR=tar
-SHELL=bash
-
-prefix=/usr/local
-exec_prefix = $(prefix)
-
-OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \
-       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o
-
-TEST_OBJS = example.o minigzip.o
-
-DISTFILES = README INDEX ChangeLog configure Make*[a-z0-9] *.[ch] descrip.mms \
-  algorithm.txt zlib.3 msdos/Make*[a-z0-9] msdos/zlib.def msdos/zlib.rc \
-  nt/Makefile.nt nt/zlib.dnt  contrib/README.contrib contrib/*.txt \
-  contrib/asm386/*.asm contrib/asm386/*.c \
-  contrib/asm386/*.bat contrib/asm386/zlibvc.d?? contrib/iostream/*.cpp \
-  contrib/iostream/*.h  contrib/iostream2/*.h contrib/iostream2/*.cpp \
-  contrib/untgz/Makefile contrib/untgz/*.c contrib/untgz/*.w32
-
-all: example.exe minigzip.exe
-
-test: all
-	@LD_LIBRARY_PATH=.:$(LD_LIBRARY_PATH) ; export LD_LIBRARY_PATH; \
-	echo hello world | ./minigzip | ./minigzip -d || \
-	  echo '		*** minigzip test FAILED ***' ; \
-	if ./example; then \
-	  echo '		*** zlib test OK ***'; \
-	else \
-	  echo '		*** zlib test FAILED ***'; \
-	fi
-
-$(ZLIB): $(OBJS)
-	$(AR) $@ $(OBJS)
-	-@ ($(RANLIB) $@ || true) >/dev/null 2>&1
-
-$(SHAREDLIB): $(OBJS) os2/z.def
-	$(LDSHARED) -o $@ $^
-
-$(SHAREDLIBIMP): os2/z.def
-	$(IMPLIB) -o $@ $^
-
-example.exe: example.o $(LIBS)
-	$(CC) $(CFLAGS) -o $@ example.o $(LDFLAGS)
-
-minigzip.exe: minigzip.o $(LIBS)
-	$(CC) $(CFLAGS) -o $@ minigzip.o $(LDFLAGS)
-
-clean:
-	rm -f *.o *~ example minigzip libz.a libz.so* foo.gz
-
-distclean:	clean
-
-zip:
-	mv Makefile Makefile~; cp -p Makefile.in Makefile
-	rm -f test.c ztest*.c
-	v=`sed -n -e 's/\.//g' -e '/VERSION "/s/.*"\(.*\)".*/\1/p' < zlib.h`;\
-	zip -ul9 zlib$$v $(DISTFILES)
-	mv Makefile~ Makefile
-
-dist:
-	mv Makefile Makefile~; cp -p Makefile.in Makefile
-	rm -f test.c ztest*.c
-	d=zlib-`sed -n '/VERSION "/s/.*"\(.*\)".*/\1/p' < zlib.h`;\
-	rm -f $$d.tar.gz; \
-	if test ! -d ../$$d; then rm -f ../$$d; ln -s `pwd` ../$$d; fi; \
-	files=""; \
-	for f in $(DISTFILES); do files="$$files $$d/$$f"; done; \
-	cd ..; \
-	GZIP=-9 $(TAR) chofz $$d/$$d.tar.gz $$files; \
-	if test ! -d $$d; then rm -f $$d; fi
-	mv Makefile~ Makefile
-
-tags:
-	etags *.[ch]
-
-depend:
-	makedepend -- $(CFLAGS) -- *.[ch]
-
-# DO NOT DELETE THIS LINE -- make depend depends on it.
-
-adler32.o: zlib.h zconf.h
-compress.o: zlib.h zconf.h
-crc32.o: zlib.h zconf.h
-deflate.o: deflate.h zutil.h zlib.h zconf.h
-example.o: zlib.h zconf.h
-gzio.o: zutil.h zlib.h zconf.h
-infblock.o: infblock.h inftrees.h infcodes.h infutil.h zutil.h zlib.h zconf.h
-infcodes.o: zutil.h zlib.h zconf.h
-infcodes.o: inftrees.h infblock.h infcodes.h infutil.h inffast.h
-inffast.o: zutil.h zlib.h zconf.h inftrees.h
-inffast.o: infblock.h infcodes.h infutil.h inffast.h
-inflate.o: zutil.h zlib.h zconf.h infblock.h
-inftrees.o: zutil.h zlib.h zconf.h inftrees.h
-infutil.o: zutil.h zlib.h zconf.h infblock.h inftrees.h infcodes.h infutil.h
-minigzip.o: zlib.h zconf.h
-trees.o: deflate.h zutil.h zlib.h zconf.h trees.h
-uncompr.o: zlib.h zconf.h
-zutil.o: zutil.h zlib.h zconf.h
diff -Nbaur gcc-4.8.1/zlib/old/os2/zlib.def gcc-4.8.1-ppc/zlib/old/os2/zlib.def
--- gcc-4.8.1/zlib/old/os2/zlib.def	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/old/os2/zlib.def	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-;
-; Slightly modified version of ../nt/zlib.dnt :-)
-;
-
-LIBRARY		Z
-DESCRIPTION	"Zlib compression library for OS/2"
-CODE		PRELOAD MOVEABLE DISCARDABLE
-DATA		PRELOAD MOVEABLE MULTIPLE
-
-EXPORTS
-    adler32
-    compress
-    crc32
-    deflate
-    deflateCopy
-    deflateEnd
-    deflateInit2_
-    deflateInit_
-    deflateParams
-    deflateReset
-    deflateSetDictionary
-    gzclose
-    gzdopen
-    gzerror
-    gzflush
-    gzopen
-    gzread
-    gzwrite
-    inflate
-    inflateEnd
-    inflateInit2_
-    inflateInit_
-    inflateReset
-    inflateSetDictionary
-    inflateSync
-    uncompress
-    zlibVersion
-    gzprintf
-    gzputc
-    gzgetc
-    gzseek
-    gzrewind
-    gztell
-    gzeof
-    gzsetparams
-    zError
-    inflateSyncPoint
-    get_crc_table
-    compress2
-    gzputs
-    gzgets
diff -Nbaur gcc-4.8.1/zlib/old/README gcc-4.8.1-ppc/zlib/old/README
--- gcc-4.8.1/zlib/old/README	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/old/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-This directory contains files that have not been updated for zlib 1.2.x
-
-(Volunteers are encouraged to help clean this up.  Thanks.)
diff -Nbaur gcc-4.8.1/zlib/old/visual-basic.txt gcc-4.8.1-ppc/zlib/old/visual-basic.txt
--- gcc-4.8.1/zlib/old/visual-basic.txt	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/old/visual-basic.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,160 +0,0 @@
-See below some functions declarations for Visual Basic.
-
-Frequently Asked Question:
-
-Q: Each time I use the compress function I get the -5 error (not enough
-   room in the output buffer).
-
-A: Make sure that the length of the compressed buffer is passed by
-   reference ("as any"), not by value ("as long"). Also check that
-   before the call of compress this length is equal to the total size of
-   the compressed buffer and not zero.
-
-
-From: "Jon Caruana" <jon-net@usa.net>
-Subject: Re: How to port zlib declares to vb?
-Date: Mon, 28 Oct 1996 18:33:03 -0600
-
-Got the answer! (I haven't had time to check this but it's what I got, and
-looks correct):
-
-He has the following routines working:
-        compress
-        uncompress
-        gzopen
-        gzwrite
-        gzread
-        gzclose
-
-Declares follow: (Quoted from Carlos Rios <c_rios@sonda.cl>, in Vb4 form)
-
-#If Win16 Then   'Use Win16 calls.
-Declare Function compress Lib "ZLIB.DLL" (ByVal compr As
-        String, comprLen As Any, ByVal buf As String, ByVal buflen
-        As Long) As Integer
-Declare Function uncompress Lib "ZLIB.DLL" (ByVal uncompr
-        As String, uncomprLen As Any, ByVal compr As String, ByVal
-        lcompr As Long) As Integer
-Declare Function gzopen Lib "ZLIB.DLL" (ByVal filePath As
-        String, ByVal mode As String) As Long
-Declare Function gzread Lib "ZLIB.DLL" (ByVal file As
-        Long, ByVal uncompr As String, ByVal uncomprLen As Integer)
-        As Integer
-Declare Function gzwrite Lib "ZLIB.DLL" (ByVal file As
-        Long, ByVal uncompr As String, ByVal uncomprLen As Integer)
-        As Integer
-Declare Function gzclose Lib "ZLIB.DLL" (ByVal file As
-        Long) As Integer
-#Else
-Declare Function compress Lib "ZLIB32.DLL"
-        (ByVal compr As String, comprLen As Any, ByVal buf As
-        String, ByVal buflen As Long) As Integer
-Declare Function uncompress Lib "ZLIB32.DLL"
-        (ByVal uncompr As String, uncomprLen As Any, ByVal compr As
-        String, ByVal lcompr As Long) As Long
-Declare Function gzopen Lib "ZLIB32.DLL"
-        (ByVal file As String, ByVal mode As String) As Long
-Declare Function gzread Lib "ZLIB32.DLL"
-        (ByVal file As Long, ByVal uncompr As String, ByVal
-        uncomprLen As Long) As Long
-Declare Function gzwrite Lib "ZLIB32.DLL"
-        (ByVal file As Long, ByVal uncompr As String, ByVal
-        uncomprLen As Long) As Long
-Declare Function gzclose Lib "ZLIB32.DLL"
-        (ByVal file As Long) As Long
-#End If
-
--Jon Caruana
-jon-net@usa.net
-Microsoft Sitebuilder Network Level 1 Member - HTML Writer's Guild Member
-
-
-Here is another example from Michael <michael_borgsys@hotmail.com> that he
-says conforms to the VB guidelines, and that solves the problem of not
-knowing the uncompressed size by storing it at the end of the file:
-
-'Calling the functions:
-'bracket meaning: <parameter> [optional] {Range of possible values}
-'Call subCompressFile(<path with filename to compress> [, <path with
-filename to write to>, [level of compression {1..9}]])
-'Call subUncompressFile(<path with filename to compress>)
-
-Option Explicit
-Private lngpvtPcnSml As Long 'Stores value for 'lngPercentSmaller'
-Private Const SUCCESS As Long = 0
-Private Const strFilExt As String = ".cpr"
-Private Declare Function lngfncCpr Lib "zlib.dll" Alias "compress2" (ByRef
-dest As Any, ByRef destLen As Any, ByRef src As Any, ByVal srcLen As Long,
-ByVal level As Integer) As Long
-Private Declare Function lngfncUcp Lib "zlib.dll" Alias "uncompress" (ByRef
-dest As Any, ByRef destLen As Any, ByRef src As Any, ByVal srcLen As Long)
-As Long
-
-Public Sub subCompressFile(ByVal strargOriFilPth As String, Optional ByVal
-strargCprFilPth As String, Optional ByVal intLvl As Integer = 9)
-    Dim strCprPth As String
-    Dim lngOriSiz As Long
-    Dim lngCprSiz As Long
-    Dim bytaryOri() As Byte
-    Dim bytaryCpr() As Byte
-    lngOriSiz = FileLen(strargOriFilPth)
-    ReDim bytaryOri(lngOriSiz - 1)
-    Open strargOriFilPth For Binary Access Read As #1
-        Get #1, , bytaryOri()
-    Close #1
-    strCprPth = IIf(strargCprFilPth = "", strargOriFilPth, strargCprFilPth)
-'Select file path and name
-    strCprPth = strCprPth & IIf(Right(strCprPth, Len(strFilExt)) =
-strFilExt, "", strFilExt) 'Add file extension if not exists
-    lngCprSiz = (lngOriSiz * 1.01) + 12 'Compression needs temporary a bit
-more space then original file size
-    ReDim bytaryCpr(lngCprSiz - 1)
-    If lngfncCpr(bytaryCpr(0), lngCprSiz, bytaryOri(0), lngOriSiz, intLvl) =
-SUCCESS Then
-        lngpvtPcnSml = (1# - (lngCprSiz / lngOriSiz)) * 100
-        ReDim Preserve bytaryCpr(lngCprSiz - 1)
-        Open strCprPth For Binary Access Write As #1
-            Put #1, , bytaryCpr()
-            Put #1, , lngOriSiz 'Add the the original size value to the end
-(last 4 bytes)
-        Close #1
-    Else
-        MsgBox "Compression error"
-    End If
-    Erase bytaryCpr
-    Erase bytaryOri
-End Sub
-
-Public Sub subUncompressFile(ByVal strargFilPth As String)
-    Dim bytaryCpr() As Byte
-    Dim bytaryOri() As Byte
-    Dim lngOriSiz As Long
-    Dim lngCprSiz As Long
-    Dim strOriPth As String
-    lngCprSiz = FileLen(strargFilPth)
-    ReDim bytaryCpr(lngCprSiz - 1)
-    Open strargFilPth For Binary Access Read As #1
-        Get #1, , bytaryCpr()
-    Close #1
-    'Read the original file size value:
-    lngOriSiz = bytaryCpr(lngCprSiz - 1) * (2 ^ 24) _
-              + bytaryCpr(lngCprSiz - 2) * (2 ^ 16) _
-              + bytaryCpr(lngCprSiz - 3) * (2 ^ 8) _
-              + bytaryCpr(lngCprSiz - 4)
-    ReDim Preserve bytaryCpr(lngCprSiz - 5) 'Cut of the original size value
-    ReDim bytaryOri(lngOriSiz - 1)
-    If lngfncUcp(bytaryOri(0), lngOriSiz, bytaryCpr(0), lngCprSiz) = SUCCESS
-Then
-        strOriPth = Left(strargFilPth, Len(strargFilPth) - Len(strFilExt))
-        Open strOriPth For Binary Access Write As #1
-            Put #1, , bytaryOri()
-        Close #1
-    Else
-        MsgBox "Uncompression error"
-    End If
-    Erase bytaryCpr
-    Erase bytaryOri
-End Sub
-Public Property Get lngPercentSmaller() As Long
-    lngPercentSmaller = lngpvtPcnSml
-End Property
diff -Nbaur gcc-4.8.1/zlib/qnx/package.qpg gcc-4.8.1-ppc/zlib/qnx/package.qpg
--- gcc-4.8.1/zlib/qnx/package.qpg	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/qnx/package.qpg	1970-01-01 01:00:00.000000000 +0100
@@ -1,141 +0,0 @@
-<QPG:Generation>
-   <QPG:Options>
-      <QPG:User unattended="no" verbosity="2" listfiles="yes"/>
-      <QPG:Defaults type="qnx_package"/>
-      <QPG:Source></QPG:Source>
-      <QPG:Release number="+"/>
-      <QPG:Build></QPG:Build>
-      <QPG:FileSorting strip="yes"/>
-      <QPG:Package targets="combine"/>
-      <QPG:Repository generate="yes"/>
-      <QPG:FinalDir></QPG:FinalDir>
-      <QPG:Cleanup></QPG:Cleanup>
-   </QPG:Options>
-
-   <QPG:Responsible>
-      <QPG:Company></QPG:Company>
-      <QPG:Department></QPG:Department>
-      <QPG:Group></QPG:Group>
-      <QPG:Team></QPG:Team>
-      <QPG:Employee></QPG:Employee>
-      <QPG:EmailAddress></QPG:EmailAddress>
-   </QPG:Responsible>
-
-   <QPG:Values>
-      <QPG:Files>
-         <QPG:Add file="../zconf.h" install="/opt/include/" user="root:sys" permission="644"/>
-         <QPG:Add file="../zlib.h" install="/opt/include/" user="root:sys" permission="644"/>
-         <QPG:Add file="../libz.so.1.2.7" install="/opt/lib/" user="root:bin" permission="644"/>
-         <QPG:Add file="libz.so" install="/opt/lib/" component="dev" filetype="symlink" linkto="libz.so.1.2.7"/>
-         <QPG:Add file="libz.so.1" install="/opt/lib/" filetype="symlink" linkto="libz.so.1.2.7"/>
-         <QPG:Add file="../libz.so.1.2.7" install="/opt/lib/" component="slib"/>
-      </QPG:Files>
-
-      <QPG:PackageFilter>
-         <QPM:PackageManifest>
-            <QPM:PackageDescription>
-               <QPM:PackageType>Library</QPM:PackageType>
-               <QPM:PackageReleaseNotes></QPM:PackageReleaseNotes>
-               <QPM:PackageReleaseUrgency>Medium</QPM:PackageReleaseUrgency>
-               <QPM:PackageRepository></QPM:PackageRepository>
-               <QPM:FileVersion>2.0</QPM:FileVersion>
-            </QPM:PackageDescription>
-
-            <QPM:ProductDescription>
-               <QPM:ProductName>zlib</QPM:ProductName>
-               <QPM:ProductIdentifier>zlib</QPM:ProductIdentifier>
-               <QPM:ProductEmail>alain.bonnefoy@icbt.com</QPM:ProductEmail>
-               <QPM:VendorName>Public</QPM:VendorName>
-               <QPM:VendorInstallName>public</QPM:VendorInstallName>
-               <QPM:VendorURL>www.gzip.org/zlib</QPM:VendorURL>
-               <QPM:VendorEmbedURL></QPM:VendorEmbedURL>
-               <QPM:VendorEmail></QPM:VendorEmail>
-               <QPM:AuthorName>Jean-Loup Gailly,Mark Adler</QPM:AuthorName>
-               <QPM:AuthorURL>www.gzip.org/zlib</QPM:AuthorURL>
-               <QPM:AuthorEmbedURL></QPM:AuthorEmbedURL>
-               <QPM:AuthorEmail>zlib@gzip.org</QPM:AuthorEmail>
-               <QPM:ProductIconSmall></QPM:ProductIconSmall>
-               <QPM:ProductIconLarge></QPM:ProductIconLarge>
-               <QPM:ProductDescriptionShort>A massively spiffy yet delicately unobtrusive compression library.</QPM:ProductDescriptionShort>
-               <QPM:ProductDescriptionLong>zlib is designed to be a free, general-purpose, legally unencumbered, lossless data compression library for use on virtually any computer hardware and operating system.</QPM:ProductDescriptionLong>
-               <QPM:ProductDescriptionURL>http://www.gzip.org/zlib</QPM:ProductDescriptionURL>
-               <QPM:ProductDescriptionEmbedURL></QPM:ProductDescriptionEmbedURL>
-            </QPM:ProductDescription>
-
-            <QPM:ReleaseDescription>
-               <QPM:ReleaseVersion>1.2.7</QPM:ReleaseVersion>
-               <QPM:ReleaseUrgency>Medium</QPM:ReleaseUrgency>
-               <QPM:ReleaseStability>Stable</QPM:ReleaseStability>
-               <QPM:ReleaseNoteMinor></QPM:ReleaseNoteMinor>
-               <QPM:ReleaseNoteMajor></QPM:ReleaseNoteMajor>
-               <QPM:ExcludeCountries>
-                  <QPM:Country></QPM:Country>
-               </QPM:ExcludeCountries>
-
-               <QPM:ReleaseCopyright>No License</QPM:ReleaseCopyright>
-            </QPM:ReleaseDescription>
-
-            <QPM:ContentDescription>
-               <QPM:ContentTopic xmlmultiple="true">Software Development/Libraries and Extensions/C Libraries</QPM:ContentTopic>
-               <QPM:ContentKeyword>zlib,compression</QPM:ContentKeyword>
-               <QPM:TargetOS>qnx6</QPM:TargetOS>
-               <QPM:HostOS>qnx6</QPM:HostOS>
-               <QPM:DisplayEnvironment xmlmultiple="true">None</QPM:DisplayEnvironment>
-               <QPM:TargetAudience xmlmultiple="true">Developer</QPM:TargetAudience>
-            </QPM:ContentDescription>
-         </QPM:PackageManifest>
-      </QPG:PackageFilter>
-
-      <QPG:PackageFilter proc="none" target="none">
-         <QPM:PackageManifest>
-            <QPM:ProductInstallationDependencies>
-               <QPM:ProductRequirements></QPM:ProductRequirements>
-            </QPM:ProductInstallationDependencies>
-
-            <QPM:ProductInstallationProcedure>
-               <QPM:Script xmlmultiple="true">
-                  <QPM:ScriptName></QPM:ScriptName>
-                  <QPM:ScriptType>Install</QPM:ScriptType>
-                  <QPM:ScriptTiming>Post</QPM:ScriptTiming>
-                  <QPM:ScriptBlocking>No</QPM:ScriptBlocking>
-                  <QPM:ScriptResult>Ignore</QPM:ScriptResult>
-                  <QPM:ShortDescription></QPM:ShortDescription>
-                  <QPM:UseBinaries>No</QPM:UseBinaries>
-                  <QPM:Priority>Optional</QPM:Priority>
-               </QPM:Script>
-            </QPM:ProductInstallationProcedure>
-         </QPM:PackageManifest>
-
-         <QPM:Launch>
-         </QPM:Launch>
-      </QPG:PackageFilter>
-
-      <QPG:PackageFilter type="core" component="none">
-         <QPM:PackageManifest>
-            <QPM:ProductInstallationProcedure>
-	       <QPM:OrderDependency xmlmultiple="true">
-	          <QPM:Order>InstallOver</QPM:Order>
-	          <QPM:Product>zlib</QPM:Product>
-	       </QPM:OrderDependency>
-            </QPM:ProductInstallationProcedure>
-         </QPM:PackageManifest>
-
-         <QPM:Launch>
-         </QPM:Launch>
-      </QPG:PackageFilter>
-
-      <QPG:PackageFilter type="core" component="dev">
-         <QPM:PackageManifest>
-            <QPM:ProductInstallationProcedure>
-	       <QPM:OrderDependency xmlmultiple="true">
-	          <QPM:Order>InstallOver</QPM:Order>
-	          <QPM:Product>zlib-dev</QPM:Product>
-	       </QPM:OrderDependency>
-            </QPM:ProductInstallationProcedure>
-         </QPM:PackageManifest>
-
-         <QPM:Launch>
-         </QPM:Launch>
-      </QPG:PackageFilter>
-   </QPG:Values>
-</QPG:Generation>
diff -Nbaur gcc-4.8.1/zlib/README gcc-4.8.1-ppc/zlib/README
--- gcc-4.8.1/zlib/README	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,118 +0,0 @@
-This directory contains the zlib package, which is not part of GCC but
-shipped with GCC as convenience.
-
-ZLIB DATA COMPRESSION LIBRARY
-
-zlib 1.2.7 is a general purpose data compression library.  All the code is
-thread safe.  The data format used by the zlib library is described by RFCs
-(Request for Comments) 1950 to 1952 in the files
-http://tools.ietf.org/html/rfc1950 (zlib format), rfc1951 (deflate format) and
-rfc1952 (gzip format).
-
-All functions of the compression library are documented in the file zlib.h
-(volunteer to write man pages welcome, contact zlib@gzip.org).  A usage example
-of the library is given in the file test/example.c which also tests that
-the library is working correctly.  Another example is given in the file
-test/minigzip.c.  The compression library itself is composed of all source
-files in the root directory.
-
-To compile all files and run the test program, follow the instructions given at
-the top of Makefile.in.  In short "./configure; make test", and if that goes
-well, "make install" should work for most flavors of Unix.  For Windows, use
-one of the special makefiles in win32/ or contrib/vstudio/ .  For VMS, use
-make_vms.com.
-
-Questions about zlib should be sent to <zlib@gzip.org>, or to Gilles Vollant
-<info@winimage.com> for the Windows DLL version.  The zlib home page is
-http://zlib.net/ .  Before reporting a problem, please check this site to
-verify that you have the latest version of zlib; otherwise get the latest
-version and check whether the problem still exists or not.
-
-PLEASE read the zlib FAQ http://zlib.net/zlib_faq.html before asking for help.
-
-Mark Nelson <markn@ieee.org> wrote an article about zlib for the Jan.  1997
-issue of Dr.  Dobb's Journal; a copy of the article is available at
-http://marknelson.us/1997/01/01/zlib-engine/ .
-
-The changes made in version 1.2.7 are documented in the file ChangeLog.
-
-Unsupported third party contributions are provided in directory contrib/ .
-
-zlib is available in Java using the java.util.zip package, documented at
-http://java.sun.com/developer/technicalArticles/Programming/compression/ .
-
-A Perl interface to zlib written by Paul Marquess <pmqs@cpan.org> is available
-at CPAN (Comprehensive Perl Archive Network) sites, including
-http://search.cpan.org/~pmqs/IO-Compress-Zlib/ .
-
-A Python interface to zlib written by A.M. Kuchling <amk@amk.ca> is
-available in Python 1.5 and later versions, see
-http://docs.python.org/library/zlib.html .
-
-zlib is built into tcl: http://wiki.tcl.tk/4610 .
-
-An experimental package to read and write files in .zip format, written on top
-of zlib by Gilles Vollant <info@winimage.com>, is available in the
-contrib/minizip directory of zlib.
-
-
-Notes for some targets:
-
-- For Windows DLL versions, please see win32/DLL_FAQ.txt
-
-- For 64-bit Irix, deflate.c must be compiled without any optimization. With
-  -O, one libpng test fails. The test works in 32 bit mode (with the -n32
-  compiler flag). The compiler bug has been reported to SGI.
-
-- zlib doesn't work with gcc 2.6.3 on a DEC 3000/300LX under OSF/1 2.1 it works
-  when compiled with cc.
-
-- On Digital Unix 4.0D (formely OSF/1) on AlphaServer, the cc option -std1 is
-  necessary to get gzprintf working correctly. This is done by configure.
-
-- zlib doesn't work on HP-UX 9.05 with some versions of /bin/cc. It works with
-  other compilers. Use "make test" to check your compiler.
-
-- gzdopen is not supported on RISCOS or BEOS.
-
-- For PalmOs, see http://palmzlib.sourceforge.net/
-
-
-Acknowledgments:
-
-  The deflate format used by zlib was defined by Phil Katz.  The deflate and
-  zlib specifications were written by L.  Peter Deutsch.  Thanks to all the
-  people who reported problems and suggested various improvements in zlib; they
-  are too numerous to cite here.
-
-Copyright notice:
-
- (C) 1995-2012 Jean-loup Gailly and Mark Adler
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Jean-loup Gailly        Mark Adler
-  jloup@gzip.org          madler@alumni.caltech.edu
-
-If you use the zlib library in a product, we would appreciate *not* receiving
-lengthy legal documents to sign.  The sources are provided for free but without
-warranty of any kind.  The library has been entirely written by Jean-loup
-Gailly and Mark Adler; it does not include third-party code.
-
-If you redistribute modified sources, we would appreciate that you include in
-the file ChangeLog history information documenting your changes.  Please read
-the FAQ for more information on the distribution of modified source versions.
diff -Nbaur gcc-4.8.1/zlib/test/example.c gcc-4.8.1-ppc/zlib/test/example.c
--- gcc-4.8.1/zlib/test/example.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/test/example.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,601 +0,0 @@
-/* example.c -- usage example of the zlib compression library
- * Copyright (C) 1995-2006, 2011 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#include "zlib.h"
-#include <stdio.h>
-
-#ifdef STDC
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-
-#if defined(VMS) || defined(RISCOS)
-#  define TESTFILE "foo-gz"
-#else
-#  define TESTFILE "foo.gz"
-#endif
-
-#define CHECK_ERR(err, msg) { \
-    if (err != Z_OK) { \
-        fprintf(stderr, "%s error: %d\n", msg, err); \
-        exit(1); \
-    } \
-}
-
-const char hello[] = "hello, hello!";
-/* "hello world" would be more standard, but the repeated "hello"
- * stresses the compression code better, sorry...
- */
-
-const char dictionary[] = "hello";
-uLong dictId; /* Adler32 value of the dictionary */
-
-void test_deflate       OF((Byte *compr, uLong comprLen));
-void test_inflate       OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_large_deflate OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_large_inflate OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_flush         OF((Byte *compr, uLong *comprLen));
-void test_sync          OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_dict_deflate  OF((Byte *compr, uLong comprLen));
-void test_dict_inflate  OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-int  main               OF((int argc, char *argv[]));
-
-
-#ifdef Z_SOLO
-
-void *myalloc OF((void *, unsigned, unsigned));
-void myfree OF((void *, void *));
-
-void *myalloc(q, n, m)
-    void *q;
-    unsigned n, m;
-{
-    q = Z_NULL;
-    return calloc(n, m);
-}
-
-void myfree(void *q, void *p)
-{
-    q = Z_NULL;
-    free(p);
-}
-
-static alloc_func zalloc = myalloc;
-static free_func zfree = myfree;
-
-#else /* !Z_SOLO */
-
-static alloc_func zalloc = (alloc_func)0;
-static free_func zfree = (free_func)0;
-
-void test_compress      OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_gzio          OF((const char *fname,
-                            Byte *uncompr, uLong uncomprLen));
-
-/* ===========================================================================
- * Test compress() and uncompress()
- */
-void test_compress(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    uLong len = (uLong)strlen(hello)+1;
-
-    err = compress(compr, &comprLen, (const Bytef*)hello, len);
-    CHECK_ERR(err, "compress");
-
-    strcpy((char*)uncompr, "garbage");
-
-    err = uncompress(uncompr, &uncomprLen, compr, comprLen);
-    CHECK_ERR(err, "uncompress");
-
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad uncompress\n");
-        exit(1);
-    } else {
-        printf("uncompress(): %s\n", (char *)uncompr);
-    }
-}
-
-/* ===========================================================================
- * Test read/write of .gz files
- */
-void test_gzio(fname, uncompr, uncomprLen)
-    const char *fname; /* compressed file name */
-    Byte *uncompr;
-    uLong uncomprLen;
-{
-#ifdef NO_GZCOMPRESS
-    fprintf(stderr, "NO_GZCOMPRESS -- gz* functions cannot compress\n");
-#else
-    int err;
-    int len = (int)strlen(hello)+1;
-    gzFile file;
-    z_off_t pos;
-
-    file = gzopen(fname, "wb");
-    if (file == NULL) {
-        fprintf(stderr, "gzopen error\n");
-        exit(1);
-    }
-    gzputc(file, 'h');
-    if (gzputs(file, "ello") != 4) {
-        fprintf(stderr, "gzputs err: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    if (gzprintf(file, ", %s!", "hello") != 8) {
-        fprintf(stderr, "gzprintf err: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    gzseek(file, 1L, SEEK_CUR); /* add one zero byte */
-    gzclose(file);
-
-    file = gzopen(fname, "rb");
-    if (file == NULL) {
-        fprintf(stderr, "gzopen error\n");
-        exit(1);
-    }
-    strcpy((char*)uncompr, "garbage");
-
-    if (gzread(file, uncompr, (unsigned)uncomprLen) != len) {
-        fprintf(stderr, "gzread err: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad gzread: %s\n", (char*)uncompr);
-        exit(1);
-    } else {
-        printf("gzread(): %s\n", (char*)uncompr);
-    }
-
-    pos = gzseek(file, -8L, SEEK_CUR);
-    if (pos != 6 || gztell(file) != pos) {
-        fprintf(stderr, "gzseek error, pos=%ld, gztell=%ld\n",
-                (long)pos, (long)gztell(file));
-        exit(1);
-    }
-
-    if (gzgetc(file) != ' ') {
-        fprintf(stderr, "gzgetc error\n");
-        exit(1);
-    }
-
-    if (gzungetc(' ', file) != ' ') {
-        fprintf(stderr, "gzungetc error\n");
-        exit(1);
-    }
-
-    gzgets(file, (char*)uncompr, (int)uncomprLen);
-    if (strlen((char*)uncompr) != 7) { /* " hello!" */
-        fprintf(stderr, "gzgets err after gzseek: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    if (strcmp((char*)uncompr, hello + 6)) {
-        fprintf(stderr, "bad gzgets after gzseek\n");
-        exit(1);
-    } else {
-        printf("gzgets() after gzseek: %s\n", (char*)uncompr);
-    }
-
-    gzclose(file);
-#endif
-}
-
-#endif /* Z_SOLO */
-
-/* ===========================================================================
- * Test deflate() with small buffers
- */
-void test_deflate(compr, comprLen)
-    Byte *compr;
-    uLong comprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-    uLong len = (uLong)strlen(hello)+1;
-
-    c_stream.zalloc = zalloc;
-    c_stream.zfree = zfree;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);
-    CHECK_ERR(err, "deflateInit");
-
-    c_stream.next_in  = (Bytef*)hello;
-    c_stream.next_out = compr;
-
-    while (c_stream.total_in != len && c_stream.total_out < comprLen) {
-        c_stream.avail_in = c_stream.avail_out = 1; /* force small buffers */
-        err = deflate(&c_stream, Z_NO_FLUSH);
-        CHECK_ERR(err, "deflate");
-    }
-    /* Finish the stream, still forcing small buffers: */
-    for (;;) {
-        c_stream.avail_out = 1;
-        err = deflate(&c_stream, Z_FINISH);
-        if (err == Z_STREAM_END) break;
-        CHECK_ERR(err, "deflate");
-    }
-
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-}
-
-/* ===========================================================================
- * Test inflate() with small buffers
- */
-void test_inflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = zalloc;
-    d_stream.zfree = zfree;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = 0;
-    d_stream.next_out = uncompr;
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    while (d_stream.total_out < uncomprLen && d_stream.total_in < comprLen) {
-        d_stream.avail_in = d_stream.avail_out = 1; /* force small buffers */
-        err = inflate(&d_stream, Z_NO_FLUSH);
-        if (err == Z_STREAM_END) break;
-        CHECK_ERR(err, "inflate");
-    }
-
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad inflate\n");
-        exit(1);
-    } else {
-        printf("inflate(): %s\n", (char *)uncompr);
-    }
-}
-
-/* ===========================================================================
- * Test deflate() with large buffers and dynamic change of compression level
- */
-void test_large_deflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-
-    c_stream.zalloc = zalloc;
-    c_stream.zfree = zfree;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_BEST_SPEED);
-    CHECK_ERR(err, "deflateInit");
-
-    c_stream.next_out = compr;
-    c_stream.avail_out = (uInt)comprLen;
-
-    /* At this point, uncompr is still mostly zeroes, so it should compress
-     * very well:
-     */
-    c_stream.next_in = uncompr;
-    c_stream.avail_in = (uInt)uncomprLen;
-    err = deflate(&c_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "deflate");
-    if (c_stream.avail_in != 0) {
-        fprintf(stderr, "deflate not greedy\n");
-        exit(1);
-    }
-
-    /* Feed in already compressed data and switch to no compression: */
-    deflateParams(&c_stream, Z_NO_COMPRESSION, Z_DEFAULT_STRATEGY);
-    c_stream.next_in = compr;
-    c_stream.avail_in = (uInt)comprLen/2;
-    err = deflate(&c_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "deflate");
-
-    /* Switch back to compressing mode: */
-    deflateParams(&c_stream, Z_BEST_COMPRESSION, Z_FILTERED);
-    c_stream.next_in = uncompr;
-    c_stream.avail_in = (uInt)uncomprLen;
-    err = deflate(&c_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "deflate");
-
-    err = deflate(&c_stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        fprintf(stderr, "deflate should report Z_STREAM_END\n");
-        exit(1);
-    }
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-}
-
-/* ===========================================================================
- * Test inflate() with large buffers
- */
-void test_large_inflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = zalloc;
-    d_stream.zfree = zfree;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = (uInt)comprLen;
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    for (;;) {
-        d_stream.next_out = uncompr;            /* discard the output */
-        d_stream.avail_out = (uInt)uncomprLen;
-        err = inflate(&d_stream, Z_NO_FLUSH);
-        if (err == Z_STREAM_END) break;
-        CHECK_ERR(err, "large inflate");
-    }
-
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    if (d_stream.total_out != 2*uncomprLen + comprLen/2) {
-        fprintf(stderr, "bad large inflate: %ld\n", d_stream.total_out);
-        exit(1);
-    } else {
-        printf("large_inflate(): OK\n");
-    }
-}
-
-/* ===========================================================================
- * Test deflate() with full flush
- */
-void test_flush(compr, comprLen)
-    Byte *compr;
-    uLong *comprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-    uInt len = (uInt)strlen(hello)+1;
-
-    c_stream.zalloc = zalloc;
-    c_stream.zfree = zfree;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);
-    CHECK_ERR(err, "deflateInit");
-
-    c_stream.next_in  = (Bytef*)hello;
-    c_stream.next_out = compr;
-    c_stream.avail_in = 3;
-    c_stream.avail_out = (uInt)*comprLen;
-    err = deflate(&c_stream, Z_FULL_FLUSH);
-    CHECK_ERR(err, "deflate");
-
-    compr[3]++; /* force an error in first compressed block */
-    c_stream.avail_in = len - 3;
-
-    err = deflate(&c_stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        CHECK_ERR(err, "deflate");
-    }
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-
-    *comprLen = c_stream.total_out;
-}
-
-/* ===========================================================================
- * Test inflateSync()
- */
-void test_sync(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = zalloc;
-    d_stream.zfree = zfree;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = 2; /* just read the zlib header */
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    d_stream.next_out = uncompr;
-    d_stream.avail_out = (uInt)uncomprLen;
-
-    inflate(&d_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "inflate");
-
-    d_stream.avail_in = (uInt)comprLen-2;   /* read all compressed data */
-    err = inflateSync(&d_stream);           /* but skip the damaged part */
-    CHECK_ERR(err, "inflateSync");
-
-    err = inflate(&d_stream, Z_FINISH);
-    if (err != Z_DATA_ERROR) {
-        fprintf(stderr, "inflate should report DATA_ERROR\n");
-        /* Because of incorrect adler32 */
-        exit(1);
-    }
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    printf("after inflateSync(): hel%s\n", (char *)uncompr);
-}
-
-/* ===========================================================================
- * Test deflate() with preset dictionary
- */
-void test_dict_deflate(compr, comprLen)
-    Byte *compr;
-    uLong comprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-
-    c_stream.zalloc = zalloc;
-    c_stream.zfree = zfree;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_BEST_COMPRESSION);
-    CHECK_ERR(err, "deflateInit");
-
-    err = deflateSetDictionary(&c_stream,
-                (const Bytef*)dictionary, (int)sizeof(dictionary));
-    CHECK_ERR(err, "deflateSetDictionary");
-
-    dictId = c_stream.adler;
-    c_stream.next_out = compr;
-    c_stream.avail_out = (uInt)comprLen;
-
-    c_stream.next_in = (Bytef*)hello;
-    c_stream.avail_in = (uInt)strlen(hello)+1;
-
-    err = deflate(&c_stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        fprintf(stderr, "deflate should report Z_STREAM_END\n");
-        exit(1);
-    }
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-}
-
-/* ===========================================================================
- * Test inflate() with a preset dictionary
- */
-void test_dict_inflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = zalloc;
-    d_stream.zfree = zfree;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = (uInt)comprLen;
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    d_stream.next_out = uncompr;
-    d_stream.avail_out = (uInt)uncomprLen;
-
-    for (;;) {
-        err = inflate(&d_stream, Z_NO_FLUSH);
-        if (err == Z_STREAM_END) break;
-        if (err == Z_NEED_DICT) {
-            if (d_stream.adler != dictId) {
-                fprintf(stderr, "unexpected dictionary");
-                exit(1);
-            }
-            err = inflateSetDictionary(&d_stream, (const Bytef*)dictionary,
-                                       (int)sizeof(dictionary));
-        }
-        CHECK_ERR(err, "inflate with dict");
-    }
-
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad inflate with dict\n");
-        exit(1);
-    } else {
-        printf("inflate with dictionary: %s\n", (char *)uncompr);
-    }
-}
-
-/* ===========================================================================
- * Usage:  example [output.gz  [input.gz]]
- */
-
-int main(argc, argv)
-    int argc;
-    char *argv[];
-{
-    Byte *compr, *uncompr;
-    uLong comprLen = 10000*sizeof(int); /* don't overflow on MSDOS */
-    uLong uncomprLen = comprLen;
-    static const char* myVersion = ZLIB_VERSION;
-
-    if (zlibVersion()[0] != myVersion[0]) {
-        fprintf(stderr, "incompatible zlib version\n");
-        exit(1);
-
-    } else if (strcmp(zlibVersion(), ZLIB_VERSION) != 0) {
-        fprintf(stderr, "warning: different zlib version\n");
-    }
-
-    printf("zlib version %s = 0x%04x, compile flags = 0x%lx\n",
-            ZLIB_VERSION, ZLIB_VERNUM, zlibCompileFlags());
-
-    compr    = (Byte*)calloc((uInt)comprLen, 1);
-    uncompr  = (Byte*)calloc((uInt)uncomprLen, 1);
-    /* compr and uncompr are cleared to avoid reading uninitialized
-     * data and to ensure that uncompr compresses well.
-     */
-    if (compr == Z_NULL || uncompr == Z_NULL) {
-        printf("out of memory\n");
-        exit(1);
-    }
-
-#ifdef Z_SOLO
-    argc = strlen(argv[0]);
-#else
-    test_compress(compr, comprLen, uncompr, uncomprLen);
-
-    test_gzio((argc > 1 ? argv[1] : TESTFILE),
-              uncompr, uncomprLen);
-#endif
-
-    test_deflate(compr, comprLen);
-    test_inflate(compr, comprLen, uncompr, uncomprLen);
-
-    test_large_deflate(compr, comprLen, uncompr, uncomprLen);
-    test_large_inflate(compr, comprLen, uncompr, uncomprLen);
-
-    test_flush(compr, &comprLen);
-    test_sync(compr, comprLen, uncompr, uncomprLen);
-    comprLen = uncomprLen;
-
-    test_dict_deflate(compr, comprLen);
-    test_dict_inflate(compr, comprLen, uncompr, uncomprLen);
-
-    free(compr);
-    free(uncompr);
-
-    return 0;
-}
diff -Nbaur gcc-4.8.1/zlib/test/infcover.c gcc-4.8.1-ppc/zlib/test/infcover.c
--- gcc-4.8.1/zlib/test/infcover.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/test/infcover.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,671 +0,0 @@
-/* infcover.c -- test zlib's inflate routines with full code coverage
- * Copyright (C) 2011 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* to use, do: ./configure --cover && make cover */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <assert.h>
-#include "zlib.h"
-
-/* get definition of internal structure so we can mess with it (see pull()),
-   and so we can call inflate_trees() (see cover5()) */
-#define ZLIB_INTERNAL
-#include "inftrees.h"
-#include "inflate.h"
-
-#define local static
-
-/* -- memory tracking routines -- */
-
-/*
-   These memory tracking routines are provided to zlib and track all of zlib's
-   allocations and deallocations, check for LIFO operations, keep a current
-   and high water mark of total bytes requested, optionally set a limit on the
-   total memory that can be allocated, and when done check for memory leaks.
-
-   They are used as follows:
-
-   z_stream strm;
-   mem_setup(&strm)         initializes the memory tracking and sets the
-                            zalloc, zfree, and opaque members of strm to use
-                            memory tracking for all zlib operations on strm
-   mem_limit(&strm, limit)  sets a limit on the total bytes requested -- a
-                            request that exceeds this limit will result in an
-                            allocation failure (returns NULL) -- setting the
-                            limit to zero means no limit, which is the default
-                            after mem_setup()
-   mem_used(&strm, "msg")   prints to stderr "msg" and the total bytes used
-   mem_high(&strm, "msg")   prints to stderr "msg" and the high water mark
-   mem_done(&strm, "msg")   ends memory tracking, releases all allocations
-                            for the tracking as well as leaked zlib blocks, if
-                            any.  If there was anything unusual, such as leaked
-                            blocks, non-FIFO frees, or frees of addresses not
-                            allocated, then "msg" and information about the
-                            problem is printed to stderr.  If everything is
-                            normal, nothing is printed. mem_done resets the
-                            strm members to Z_NULL to use the default memory
-                            allocation routines on the next zlib initialization
-                            using strm.
- */
-
-/* these items are strung together in a linked list, one for each allocation */
-struct mem_item {
-    void *ptr;                  /* pointer to allocated memory */
-    size_t size;                /* requested size of allocation */
-    struct mem_item *next;      /* pointer to next item in list, or NULL */
-};
-
-/* this structure is at the root of the linked list, and tracks statistics */
-struct mem_zone {
-    struct mem_item *first;     /* pointer to first item in list, or NULL */
-    size_t total, highwater;    /* total allocations, and largest total */
-    size_t limit;               /* memory allocation limit, or 0 if no limit */
-    int notlifo, rogue;         /* counts of non-LIFO frees and rogue frees */
-};
-
-/* memory allocation routine to pass to zlib */
-local void *mem_alloc(void *mem, unsigned count, unsigned size)
-{
-    void *ptr;
-    struct mem_item *item;
-    struct mem_zone *zone = mem;
-    size_t len = count * (size_t)size;
-
-    /* induced allocation failure */
-    if (zone == NULL || (zone->limit && zone->total + len > zone->limit))
-        return NULL;
-
-    /* perform allocation using the standard library, fill memory with a
-       non-zero value to make sure that the code isn't depending on zeros */
-    ptr = malloc(len);
-    if (ptr == NULL)
-        return NULL;
-    memset(ptr, 0xa5, len);
-
-    /* create a new item for the list */
-    item = malloc(sizeof(struct mem_item));
-    if (item == NULL) {
-        free(ptr);
-        return NULL;
-    }
-    item->ptr = ptr;
-    item->size = len;
-
-    /* insert item at the beginning of the list */
-    item->next = zone->first;
-    zone->first = item;
-
-    /* update the statistics */
-    zone->total += item->size;
-    if (zone->total > zone->highwater)
-        zone->highwater = zone->total;
-
-    /* return the allocated memory */
-    return ptr;
-}
-
-/* memory free routine to pass to zlib */
-local void mem_free(void *mem, void *ptr)
-{
-    struct mem_item *item, *next;
-    struct mem_zone *zone = mem;
-
-    /* if no zone, just do a free */
-    if (zone == NULL) {
-        free(ptr);
-        return;
-    }
-
-    /* point next to the item that matches ptr, or NULL if not found -- remove
-       the item from the linked list if found */
-    next = zone->first;
-    if (next) {
-        if (next->ptr == ptr)
-            zone->first = next->next;   /* first one is it, remove from list */
-        else {
-            do {                        /* search the linked list */
-                item = next;
-                next = item->next;
-            } while (next != NULL && next->ptr != ptr);
-            if (next) {                 /* if found, remove from linked list */
-                item->next = next->next;
-                zone->notlifo++;        /* not a LIFO free */
-            }
-
-        }
-    }
-
-    /* if found, update the statistics and free the item */
-    if (next) {
-        zone->total -= next->size;
-        free(next);
-    }
-
-    /* if not found, update the rogue count */
-    else
-        zone->rogue++;
-
-    /* in any case, do the requested free with the standard library function */
-    free(ptr);
-}
-
-/* set up a controlled memory allocation space for monitoring, set the stream
-   parameters to the controlled routines, with opaque pointing to the space */
-local void mem_setup(z_stream *strm)
-{
-    struct mem_zone *zone;
-
-    zone = malloc(sizeof(struct mem_zone));
-    assert(zone != NULL);
-    zone->first = NULL;
-    zone->total = 0;
-    zone->highwater = 0;
-    zone->limit = 0;
-    zone->notlifo = 0;
-    zone->rogue = 0;
-    strm->opaque = zone;
-    strm->zalloc = mem_alloc;
-    strm->zfree = mem_free;
-}
-
-/* set a limit on the total memory allocation, or 0 to remove the limit */
-local void mem_limit(z_stream *strm, size_t limit)
-{
-    struct mem_zone *zone = strm->opaque;
-
-    zone->limit = limit;
-}
-
-/* show the current total requested allocations in bytes */
-local void mem_used(z_stream *strm, char *prefix)
-{
-    struct mem_zone *zone = strm->opaque;
-
-    fprintf(stderr, "%s: %lu allocated\n", prefix, zone->total);
-}
-
-/* show the high water allocation in bytes */
-local void mem_high(z_stream *strm, char *prefix)
-{
-    struct mem_zone *zone = strm->opaque;
-
-    fprintf(stderr, "%s: %lu high water mark\n", prefix, zone->highwater);
-}
-
-/* release the memory allocation zone -- if there are any surprises, notify */
-local void mem_done(z_stream *strm, char *prefix)
-{
-    int count = 0;
-    struct mem_item *item, *next;
-    struct mem_zone *zone = strm->opaque;
-
-    /* show high water mark */
-    mem_high(strm, prefix);
-
-    /* free leftover allocations and item structures, if any */
-    item = zone->first;
-    while (item != NULL) {
-        free(item->ptr);
-        next = item->next;
-        free(item);
-        item = next;
-        count++;
-    }
-
-    /* issue alerts about anything unexpected */
-    if (count || zone->total)
-        fprintf(stderr, "** %s: %lu bytes in %d blocks not freed\n",
-                prefix, zone->total, count);
-    if (zone->notlifo)
-        fprintf(stderr, "** %s: %d frees not LIFO\n", prefix, zone->notlifo);
-    if (zone->rogue)
-        fprintf(stderr, "** %s: %d frees not recognized\n",
-                prefix, zone->rogue);
-
-    /* free the zone and delete from the stream */
-    free(zone);
-    strm->opaque = Z_NULL;
-    strm->zalloc = Z_NULL;
-    strm->zfree = Z_NULL;
-}
-
-/* -- inflate test routines -- */
-
-/* Decode a hexadecimal string, set *len to length, in[] to the bytes.  This
-   decodes liberally, in that hex digits can be adjacent, in which case two in
-   a row writes a byte.  Or they can delimited by any non-hex character, where
-   the delimiters are ignored except when a single hex digit is followed by a
-   delimiter in which case that single digit writes a byte.  The returned
-   data is allocated and must eventually be freed.  NULL is returned if out of
-   memory.  If the length is not needed, then len can be NULL. */
-local unsigned char *h2b(const char *hex, unsigned *len)
-{
-    unsigned char *in;
-    unsigned next, val;
-
-    in = malloc((strlen(hex) + 1) >> 1);
-    if (in == NULL)
-        return NULL;
-    next = 0;
-    val = 1;
-    do {
-        if (*hex >= '0' && *hex <= '9')
-            val = (val << 4) + *hex - '0';
-        else if (*hex >= 'A' && *hex <= 'F')
-            val = (val << 4) + *hex - 'A' + 10;
-        else if (*hex >= 'a' && *hex <= 'f')
-            val = (val << 4) + *hex - 'a' + 10;
-        else if (val != 1 && val < 32)  /* one digit followed by delimiter */
-            val += 240;                 /* make it look like two digits */
-        if (val > 255) {                /* have two digits */
-            in[next++] = val & 0xff;    /* save the decoded byte */
-            val = 1;                    /* start over */
-        }
-    } while (*hex++);       /* go through the loop with the terminating null */
-    if (len != NULL)
-        *len = next;
-    in = reallocf(in, next);
-    return in;
-}
-
-/* generic inflate() run, where hex is the hexadecimal input data, what is the
-   text to include in an error message, step is how much input data to feed
-   inflate() on each call, or zero to feed it all, win is the window bits
-   parameter to inflateInit2(), len is the size of the output buffer, and err
-   is the error code expected from the first inflate() call (the second
-   inflate() call is expected to return Z_STREAM_END).  If win is 47, then
-   header information is collected with inflateGetHeader().  If a zlib stream
-   is looking for a dictionary, then an empty dictionary is provided.
-   inflate() is run until all of the input data is consumed. */
-local void inf(char *hex, char *what, unsigned step, int win, unsigned len,
-               int err)
-{
-    int ret;
-    unsigned have;
-    unsigned char *in, *out;
-    z_stream strm, copy;
-    gz_header head;
-
-    mem_setup(&strm);
-    strm.avail_in = 0;
-    strm.next_in = Z_NULL;
-    ret = inflateInit2(&strm, win);
-    if (ret != Z_OK) {
-        mem_done(&strm, what);
-        return;
-    }
-    out = malloc(len);                          assert(out != NULL);
-    if (win == 47) {
-        head.extra = out;
-        head.extra_max = len;
-        head.name = out;
-        head.name_max = len;
-        head.comment = out;
-        head.comm_max = len;
-        ret = inflateGetHeader(&strm, &head);   assert(ret == Z_OK);
-    }
-    in = h2b(hex, &have);                       assert(in != NULL);
-    if (step == 0 || step > have)
-        step = have;
-    strm.avail_in = step;
-    have -= step;
-    strm.next_in = in;
-    do {
-        strm.avail_out = len;
-        strm.next_out = out;
-        ret = inflate(&strm, Z_NO_FLUSH);       assert(err == 9 || ret == err);
-        if (ret != Z_OK && ret != Z_BUF_ERROR && ret != Z_NEED_DICT)
-            break;
-        if (ret == Z_NEED_DICT) {
-            ret = inflateSetDictionary(&strm, in, 1);
-                                                assert(ret == Z_DATA_ERROR);
-            mem_limit(&strm, 1);
-            ret = inflateSetDictionary(&strm, out, 0);
-                                                assert(ret == Z_MEM_ERROR);
-            mem_limit(&strm, 0);
-            ((struct inflate_state *)strm.state)->mode = DICT;
-            ret = inflateSetDictionary(&strm, out, 0);
-                                                assert(ret == Z_OK);
-            ret = inflate(&strm, Z_NO_FLUSH);   assert(ret == Z_BUF_ERROR);
-        }
-        ret = inflateCopy(&copy, &strm);        assert(ret == Z_OK);
-        ret = inflateEnd(&copy);                assert(ret == Z_OK);
-        err = 9;                        /* don't care next time around */
-        have += strm.avail_in;
-        strm.avail_in = step > have ? have : step;
-        have -= strm.avail_in;
-    } while (strm.avail_in);
-    free(in);
-    free(out);
-    ret = inflateReset2(&strm, -8);             assert(ret == Z_OK);
-    ret = inflateEnd(&strm);                    assert(ret == Z_OK);
-    mem_done(&strm, what);
-}
-
-/* cover all of the lines in inflate.c up to inflate() */
-local void cover_support(void)
-{
-    int ret;
-    z_stream strm;
-
-    mem_setup(&strm);
-    strm.avail_in = 0;
-    strm.next_in = Z_NULL;
-    ret = inflateInit(&strm);                   assert(ret == Z_OK);
-    mem_used(&strm, "inflate init");
-    ret = inflatePrime(&strm, 5, 31);           assert(ret == Z_OK);
-    ret = inflatePrime(&strm, -1, 0);           assert(ret == Z_OK);
-    ret = inflateSetDictionary(&strm, Z_NULL, 0);
-                                                assert(ret == Z_STREAM_ERROR);
-    ret = inflateEnd(&strm);                    assert(ret == Z_OK);
-    mem_done(&strm, "prime");
-
-    inf("63 0", "force window allocation", 0, -15, 1, Z_OK);
-    inf("63 18 5", "force window replacement", 0, -8, 259, Z_OK);
-    inf("63 18 68 30 d0 0 0", "force split window update", 4, -8, 259, Z_OK);
-    inf("3 0", "use fixed blocks", 0, -15, 1, Z_STREAM_END);
-    inf("", "bad window size", 0, 1, 0, Z_STREAM_ERROR);
-
-    mem_setup(&strm);
-    strm.avail_in = 0;
-    strm.next_in = Z_NULL;
-    ret = inflateInit_(&strm, ZLIB_VERSION - 1, (int)sizeof(z_stream));
-                                                assert(ret == Z_VERSION_ERROR);
-    mem_done(&strm, "wrong version");
-
-    strm.avail_in = 0;
-    strm.next_in = Z_NULL;
-    ret = inflateInit(&strm);                   assert(ret == Z_OK);
-    ret = inflateEnd(&strm);                    assert(ret == Z_OK);
-    fputs("inflate built-in memory routines\n", stderr);
-}
-
-/* cover all inflate() header and trailer cases and code after inflate() */
-local void cover_wrap(void)
-{
-    int ret;
-    z_stream strm, copy;
-    unsigned char dict[257];
-
-    ret = inflate(Z_NULL, 0);                   assert(ret == Z_STREAM_ERROR);
-    ret = inflateEnd(Z_NULL);                   assert(ret == Z_STREAM_ERROR);
-    ret = inflateCopy(Z_NULL, Z_NULL);          assert(ret == Z_STREAM_ERROR);
-    fputs("inflate bad parameters\n", stderr);
-
-    inf("1f 8b 0 0", "bad gzip method", 0, 31, 0, Z_DATA_ERROR);
-    inf("1f 8b 8 80", "bad gzip flags", 0, 31, 0, Z_DATA_ERROR);
-    inf("77 85", "bad zlib method", 0, 15, 0, Z_DATA_ERROR);
-    inf("8 99", "set window size from header", 0, 0, 0, Z_OK);
-    inf("78 9c", "bad zlib window size", 0, 8, 0, Z_DATA_ERROR);
-    inf("78 9c 63 0 0 0 1 0 1", "check adler32", 0, 15, 1, Z_STREAM_END);
-    inf("1f 8b 8 1e 0 0 0 0 0 0 1 0 0 0 0 0 0", "bad header crc", 0, 47, 1,
-        Z_DATA_ERROR);
-    inf("1f 8b 8 2 0 0 0 0 0 0 1d 26 3 0 0 0 0 0 0 0 0 0", "check gzip length",
-        0, 47, 0, Z_STREAM_END);
-    inf("78 90", "bad zlib header check", 0, 47, 0, Z_DATA_ERROR);
-    inf("8 b8 0 0 0 1", "need dictionary", 0, 8, 0, Z_NEED_DICT);
-    inf("78 9c 63 0", "compute adler32", 0, 15, 1, Z_OK);
-
-    mem_setup(&strm);
-    strm.avail_in = 0;
-    strm.next_in = Z_NULL;
-    ret = inflateInit2(&strm, -8);
-    strm.avail_in = 2;
-    strm.next_in = (void *)"\x63";
-    strm.avail_out = 1;
-    strm.next_out = (void *)&ret;
-    mem_limit(&strm, 1);
-    ret = inflate(&strm, Z_NO_FLUSH);           assert(ret == Z_MEM_ERROR);
-    ret = inflate(&strm, Z_NO_FLUSH);           assert(ret == Z_MEM_ERROR);
-    mem_limit(&strm, 0);
-    memset(dict, 0, 257);
-    ret = inflateSetDictionary(&strm, dict, 257);
-                                                assert(ret == Z_OK);
-    mem_limit(&strm, (sizeof(struct inflate_state) << 1) + 256);
-    ret = inflatePrime(&strm, 16, 0);           assert(ret == Z_OK);
-    strm.avail_in = 2;
-    strm.next_in = (void *)"\x80";
-    ret = inflateSync(&strm);                   assert(ret == Z_DATA_ERROR);
-    ret = inflate(&strm, Z_NO_FLUSH);           assert(ret == Z_STREAM_ERROR);
-    strm.avail_in = 4;
-    strm.next_in = (void *)"\0\0\xff\xff";
-    ret = inflateSync(&strm);                   assert(ret == Z_OK);
-    (void)inflateSyncPoint(&strm);
-    ret = inflateCopy(&copy, &strm);            assert(ret == Z_MEM_ERROR);
-    mem_limit(&strm, 0);
-    ret = inflateUndermine(&strm, 1);           assert(ret == Z_DATA_ERROR);
-    (void)inflateMark(&strm);
-    ret = inflateEnd(&strm);                    assert(ret == Z_OK);
-    mem_done(&strm, "miscellaneous, force memory errors");
-}
-
-/* input and output functions for inflateBack() */
-local unsigned pull(void *desc, unsigned char **buf)
-{
-    static unsigned int next = 0;
-    static unsigned char dat[] = {0x63, 0, 2, 0};
-    struct inflate_state *state;
-
-    if (desc == Z_NULL) {
-        next = 0;
-        return 0;   /* no input (already provided at next_in) */
-    }
-    state = (void *)((z_stream *)desc)->state;
-    if (state != Z_NULL)
-        state->mode = SYNC;     /* force an otherwise impossible situation */
-    return next < sizeof(dat) ? (*buf = dat + next++, 1) : 0;
-}
-
-local int push(void *desc, unsigned char *buf, unsigned len)
-{
-    buf += len;
-    return desc != Z_NULL;      /* force error if desc not null */
-}
-
-/* cover inflateBack() up to common deflate data cases and after those */
-local void cover_back(void)
-{
-    int ret;
-    z_stream strm;
-    unsigned char win[32768];
-
-    ret = inflateBackInit_(Z_NULL, 0, win, 0, 0);
-                                                assert(ret == Z_VERSION_ERROR);
-    ret = inflateBackInit(Z_NULL, 0, win);      assert(ret == Z_STREAM_ERROR);
-    ret = inflateBack(Z_NULL, Z_NULL, Z_NULL, Z_NULL, Z_NULL);
-                                                assert(ret == Z_STREAM_ERROR);
-    ret = inflateBackEnd(Z_NULL);               assert(ret == Z_STREAM_ERROR);
-    fputs("inflateBack bad parameters\n", stderr);
-
-    mem_setup(&strm);
-    ret = inflateBackInit(&strm, 15, win);      assert(ret == Z_OK);
-    strm.avail_in = 2;
-    strm.next_in = (void *)"\x03";
-    ret = inflateBack(&strm, pull, Z_NULL, push, Z_NULL);
-                                                assert(ret == Z_STREAM_END);
-        /* force output error */
-    strm.avail_in = 3;
-    strm.next_in = (void *)"\x63\x00";
-    ret = inflateBack(&strm, pull, Z_NULL, push, &strm);
-                                                assert(ret == Z_BUF_ERROR);
-        /* force mode error by mucking with state */
-    ret = inflateBack(&strm, pull, &strm, push, Z_NULL);
-                                                assert(ret == Z_STREAM_ERROR);
-    ret = inflateBackEnd(&strm);                assert(ret == Z_OK);
-    mem_done(&strm, "inflateBack bad state");
-
-    ret = inflateBackInit(&strm, 15, win);      assert(ret == Z_OK);
-    ret = inflateBackEnd(&strm);                assert(ret == Z_OK);
-    fputs("inflateBack built-in memory routines\n", stderr);
-}
-
-/* do a raw inflate of data in hexadecimal with both inflate and inflateBack */
-local int try(char *hex, char *id, int err)
-{
-    int ret;
-    unsigned len, size;
-    unsigned char *in, *out, *win;
-    char *prefix;
-    z_stream strm;
-
-    /* convert to hex */
-    in = h2b(hex, &len);
-    assert(in != NULL);
-
-    /* allocate work areas */
-    size = len << 3;
-    out = malloc(size);
-    assert(out != NULL);
-    win = malloc(32768);
-    assert(win != NULL);
-    prefix = malloc(strlen(id) + 6);
-    assert(prefix != NULL);
-
-    /* first with inflate */
-    strcpy(prefix, id);
-    strcat(prefix, "-late");
-    mem_setup(&strm);
-    strm.avail_in = 0;
-    strm.next_in = Z_NULL;
-    ret = inflateInit2(&strm, err < 0 ? 47 : -15);
-    assert(ret == Z_OK);
-    strm.avail_in = len;
-    strm.next_in = in;
-    do {
-        strm.avail_out = size;
-        strm.next_out = out;
-        ret = inflate(&strm, Z_TREES);
-        assert(ret != Z_STREAM_ERROR && ret != Z_MEM_ERROR);
-        if (ret == Z_DATA_ERROR || ret == Z_NEED_DICT)
-            break;
-    } while (strm.avail_in || strm.avail_out == 0);
-    if (err) {
-        assert(ret == Z_DATA_ERROR);
-        assert(strcmp(id, strm.msg) == 0);
-    }
-    inflateEnd(&strm);
-    mem_done(&strm, prefix);
-
-    /* then with inflateBack */
-    if (err >= 0) {
-        strcpy(prefix, id);
-        strcat(prefix, "-back");
-        mem_setup(&strm);
-        ret = inflateBackInit(&strm, 15, win);
-        assert(ret == Z_OK);
-        strm.avail_in = len;
-        strm.next_in = in;
-        ret = inflateBack(&strm, pull, Z_NULL, push, Z_NULL);
-        assert(ret != Z_STREAM_ERROR);
-        if (err) {
-            assert(ret == Z_DATA_ERROR);
-            assert(strcmp(id, strm.msg) == 0);
-        }
-        inflateBackEnd(&strm);
-        mem_done(&strm, prefix);
-    }
-
-    /* clean up */
-    free(prefix);
-    free(win);
-    free(out);
-    free(in);
-    return ret;
-}
-
-/* cover deflate data cases in both inflate() and inflateBack() */
-local void cover_inflate(void)
-{
-    try("0 0 0 0 0", "invalid stored block lengths", 1);
-    try("3 0", "fixed", 0);
-    try("6", "invalid block type", 1);
-    try("1 1 0 fe ff 0", "stored", 0);
-    try("fc 0 0", "too many length or distance symbols", 1);
-    try("4 0 fe ff", "invalid code lengths set", 1);
-    try("4 0 24 49 0", "invalid bit length repeat", 1);
-    try("4 0 24 e9 ff ff", "invalid bit length repeat", 1);
-    try("4 0 24 e9 ff 6d", "invalid code -- missing end-of-block", 1);
-    try("4 80 49 92 24 49 92 24 71 ff ff 93 11 0",
-        "invalid literal/lengths set", 1);
-    try("4 80 49 92 24 49 92 24 f b4 ff ff c3 84", "invalid distances set", 1);
-    try("4 c0 81 8 0 0 0 0 20 7f eb b 0 0", "invalid literal/length code", 1);
-    try("2 7e ff ff", "invalid distance code", 1);
-    try("c c0 81 0 0 0 0 0 90 ff 6b 4 0", "invalid distance too far back", 1);
-
-    /* also trailer mismatch just in inflate() */
-    try("1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 1", "incorrect data check", -1);
-    try("1f 8b 8 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 1",
-        "incorrect length check", -1);
-    try("5 c0 21 d 0 0 0 80 b0 fe 6d 2f 91 6c", "pull 17", 0);
-    try("5 e0 81 91 24 cb b2 2c 49 e2 f 2e 8b 9a 47 56 9f fb fe ec d2 ff 1f",
-        "long code", 0);
-    try("ed c0 1 1 0 0 0 40 20 ff 57 1b 42 2c 4f", "length extra", 0);
-    try("ed cf c1 b1 2c 47 10 c4 30 fa 6f 35 1d 1 82 59 3d fb be 2e 2a fc f c",
-        "long distance and extra", 0);
-    try("ed c0 81 0 0 0 0 80 a0 fd a9 17 a9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
-        "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6", "window end", 0);
-    inf("2 8 20 80 0 3 0", "inflate_fast TYPE return", 0, -15, 258,
-        Z_STREAM_END);
-    inf("63 18 5 40 c 0", "window wrap", 3, -8, 300, Z_OK);
-}
-
-/* cover remaining lines in inftrees.c */
-local void cover_trees(void)
-{
-    int ret;
-    unsigned bits;
-    unsigned short lens[16], work[16];
-    code *next, table[ENOUGH_DISTS];
-
-    /* we need to call inflate_table() directly in order to manifest not-
-       enough errors, since zlib insures that enough is always enough */
-    for (bits = 0; bits < 15; bits++)
-        lens[bits] = (unsigned short)(bits + 1);
-    lens[15] = 15;
-    next = table;
-    bits = 15;
-    ret = inflate_table(DISTS, lens, 16, &next, &bits, work);
-                                                assert(ret == 1);
-    next = table;
-    bits = 1;
-    ret = inflate_table(DISTS, lens, 16, &next, &bits, work);
-                                                assert(ret == 1);
-    fputs("inflate_table not enough errors\n", stderr);
-}
-
-/* cover remaining inffast.c decoding and window copying */
-local void cover_fast(void)
-{
-    inf("e5 e0 81 ad 6d cb b2 2c c9 01 1e 59 63 ae 7d ee fb 4d fd b5 35 41 68"
-        " ff 7f 0f 0 0 0", "fast length extra bits", 0, -8, 258, Z_DATA_ERROR);
-    inf("25 fd 81 b5 6d 59 b6 6a 49 ea af 35 6 34 eb 8c b9 f6 b9 1e ef 67 49"
-        " 50 fe ff ff 3f 0 0", "fast distance extra bits", 0, -8, 258,
-        Z_DATA_ERROR);
-    inf("3 7e 0 0 0 0 0", "fast invalid distance code", 0, -8, 258,
-        Z_DATA_ERROR);
-    inf("1b 7 0 0 0 0 0", "fast invalid literal/length code", 0, -8, 258,
-        Z_DATA_ERROR);
-    inf("d c7 1 ae eb 38 c 4 41 a0 87 72 de df fb 1f b8 36 b1 38 5d ff ff 0",
-        "fast 2nd level codes and too far back", 0, -8, 258, Z_DATA_ERROR);
-    inf("63 18 5 8c 10 8 0 0 0 0", "very common case", 0, -8, 259, Z_OK);
-    inf("63 60 60 18 c9 0 8 18 18 18 26 c0 28 0 29 0 0 0",
-        "contiguous and wrap around window", 6, -8, 259, Z_OK);
-    inf("63 0 3 0 0 0 0 0", "copy direct from output", 0, -8, 259,
-        Z_STREAM_END);
-}
-
-int main(void)
-{
-    fprintf(stderr, "%s\n", zlibVersion());
-    cover_support();
-    cover_wrap();
-    cover_back();
-    cover_inflate();
-    cover_trees();
-    cover_fast();
-    return 0;
-}
diff -Nbaur gcc-4.8.1/zlib/test/minigzip.c gcc-4.8.1-ppc/zlib/test/minigzip.c
--- gcc-4.8.1/zlib/test/minigzip.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/test/minigzip.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,631 +0,0 @@
-/* minigzip.c -- simulate gzip using the zlib compression library
- * Copyright (C) 1995-2006, 2010, 2011 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- * minigzip is a minimal implementation of the gzip utility. This is
- * only an example of using zlib and isn't meant to replace the
- * full-featured gzip. No attempt is made to deal with file systems
- * limiting names to 14 or 8+3 characters, etc... Error checking is
- * very limited. So use minigzip only for testing; use gzip for the
- * real thing. On MSDOS, use only on file names without extension
- * or in pipe mode.
- */
-
-/* @(#) $Id$ */
-
-#include "zlib.h"
-#include <stdio.h>
-
-#ifdef STDC
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-
-#ifdef USE_MMAP
-#  include <sys/types.h>
-#  include <sys/mman.h>
-#  include <sys/stat.h>
-#endif
-
-#if defined(MSDOS) || defined(OS2) || defined(WIN32) || defined(__CYGWIN__)
-#  include <fcntl.h>
-#  include <io.h>
-#  ifdef UNDER_CE
-#    include <stdlib.h>
-#  endif
-#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
-#else
-#  define SET_BINARY_MODE(file)
-#endif
-
-#ifdef VMS
-#  define unlink delete
-#  define GZ_SUFFIX "-gz"
-#endif
-#ifdef RISCOS
-#  define unlink remove
-#  define GZ_SUFFIX "-gz"
-#  define fileno(file) file->__file
-#endif
-#if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
-#  include <unix.h> /* for fileno */
-#endif
-
-#if !defined(Z_HAVE_UNISTD_H) && !defined(_LARGEFILE64_SOURCE)
-#ifndef WIN32 /* unlink already in stdio.h for WIN32 */
-  extern int unlink OF((const char *));
-#endif
-#endif
-
-#if defined(UNDER_CE)
-#  include <windows.h>
-#  define perror(s) pwinerror(s)
-
-/* Map the Windows error number in ERROR to a locale-dependent error
-   message string and return a pointer to it.  Typically, the values
-   for ERROR come from GetLastError.
-
-   The string pointed to shall not be modified by the application,
-   but may be overwritten by a subsequent call to strwinerror
-
-   The strwinerror function does not change the current setting
-   of GetLastError.  */
-
-static char *strwinerror (error)
-     DWORD error;
-{
-    static char buf[1024];
-
-    wchar_t *msgbuf;
-    DWORD lasterr = GetLastError();
-    DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
-        | FORMAT_MESSAGE_ALLOCATE_BUFFER,
-        NULL,
-        error,
-        0, /* Default language */
-        (LPVOID)&msgbuf,
-        0,
-        NULL);
-    if (chars != 0) {
-        /* If there is an \r\n appended, zap it.  */
-        if (chars >= 2
-            && msgbuf[chars - 2] == '\r' && msgbuf[chars - 1] == '\n') {
-            chars -= 2;
-            msgbuf[chars] = 0;
-        }
-
-        if (chars > sizeof (buf) - 1) {
-            chars = sizeof (buf) - 1;
-            msgbuf[chars] = 0;
-        }
-
-        wcstombs(buf, msgbuf, chars + 1);
-        LocalFree(msgbuf);
-    }
-    else {
-        sprintf(buf, "unknown win32 error (%ld)", error);
-    }
-
-    SetLastError(lasterr);
-    return buf;
-}
-
-static void pwinerror (s)
-    const char *s;
-{
-    if (s && *s)
-        fprintf(stderr, "%s: %s\n", s, strwinerror(GetLastError ()));
-    else
-        fprintf(stderr, "%s\n", strwinerror(GetLastError ()));
-}
-
-#endif /* UNDER_CE */
-
-#ifndef GZ_SUFFIX
-#  define GZ_SUFFIX ".gz"
-#endif
-#define SUFFIX_LEN (sizeof(GZ_SUFFIX)-1)
-
-#define BUFLEN      16384
-#define MAX_NAME_LEN 1024
-
-#ifdef MAXSEG_64K
-#  define local static
-   /* Needed for systems with limitation on stack size. */
-#else
-#  define local
-#endif
-
-#ifdef Z_SOLO
-/* for Z_SOLO, create simplified gz* functions using deflate and inflate */
-
-#if defined(Z_HAVE_UNISTD_H) || defined(Z_LARGE)
-#  include <unistd.h>       /* for unlink() */
-#endif
-
-void *myalloc OF((void *, unsigned, unsigned));
-void myfree OF((void *, void *));
-
-void *myalloc(q, n, m)
-    void *q;
-    unsigned n, m;
-{
-    q = Z_NULL;
-    return calloc(n, m);
-}
-
-void myfree(q, p)
-    void *q, *p;
-{
-    q = Z_NULL;
-    free(p);
-}
-
-typedef struct gzFile_s {
-    FILE *file;
-    int write;
-    int err;
-    char *msg;
-    z_stream strm;
-} *gzFile;
-
-gzFile gzopen OF((const char *, const char *));
-gzFile gzdopen OF((int, const char *));
-gzFile gz_open OF((const char *, int, const char *));
-
-gzFile gzopen(path, mode)
-const char *path;
-const char *mode;
-{
-    return gz_open(path, -1, mode);
-}
-
-gzFile gzdopen(fd, mode)
-int fd;
-const char *mode;
-{
-    return gz_open(NULL, fd, mode);
-}
-
-gzFile gz_open(path, fd, mode)
-    const char *path;
-    int fd;
-    const char *mode;
-{
-    gzFile gz;
-    int ret;
-
-    gz = malloc(sizeof(struct gzFile_s));
-    if (gz == NULL)
-        return NULL;
-    gz->write = strchr(mode, 'w') != NULL;
-    gz->strm.zalloc = myalloc;
-    gz->strm.zfree = myfree;
-    gz->strm.opaque = Z_NULL;
-    if (gz->write)
-        ret = deflateInit2(&(gz->strm), -1, 8, 15 + 16, 8, 0);
-    else {
-        gz->strm.next_in = 0;
-        gz->strm.avail_in = Z_NULL;
-        ret = inflateInit2(&(gz->strm), 15 + 16);
-    }
-    if (ret != Z_OK) {
-        free(gz);
-        return NULL;
-    }
-    gz->file = path == NULL ? fdopen(fd, gz->write ? "wb" : "rb") :
-                              fopen(path, gz->write ? "wb" : "rb");
-    if (gz->file == NULL) {
-        gz->write ? deflateEnd(&(gz->strm)) : inflateEnd(&(gz->strm));
-        free(gz);
-        return NULL;
-    }
-    gz->err = 0;
-    gz->msg = "";
-    return gz;
-}
-
-int gzwrite OF((gzFile, const void *, unsigned));
-
-int gzwrite(gz, buf, len)
-    gzFile gz;
-    const void *buf;
-    unsigned len;
-{
-    z_stream *strm;
-    unsigned char out[BUFLEN];
-
-    if (gz == NULL || !gz->write)
-        return 0;
-    strm = &(gz->strm);
-    strm->next_in = (void *)buf;
-    strm->avail_in = len;
-    do {
-        strm->next_out = out;
-        strm->avail_out = BUFLEN;
-        (void)deflate(strm, Z_NO_FLUSH);
-        fwrite(out, 1, BUFLEN - strm->avail_out, gz->file);
-    } while (strm->avail_out == 0);
-    return len;
-}
-
-int gzread OF((gzFile, void *, unsigned));
-
-int gzread(gz, buf, len)
-    gzFile gz;
-    void *buf;
-    unsigned len;
-{
-    int ret;
-    unsigned got;
-    unsigned char in[1];
-    z_stream *strm;
-
-    if (gz == NULL || gz->write)
-        return 0;
-    if (gz->err)
-        return 0;
-    strm = &(gz->strm);
-    strm->next_out = (void *)buf;
-    strm->avail_out = len;
-    do {
-        got = fread(in, 1, 1, gz->file);
-        if (got == 0)
-            break;
-        strm->next_in = in;
-        strm->avail_in = 1;
-        ret = inflate(strm, Z_NO_FLUSH);
-        if (ret == Z_DATA_ERROR) {
-            gz->err = Z_DATA_ERROR;
-            gz->msg = strm->msg;
-            return 0;
-        }
-        if (ret == Z_STREAM_END)
-            inflateReset(strm);
-    } while (strm->avail_out);
-    return len - strm->avail_out;
-}
-
-int gzclose OF((gzFile));
-
-int gzclose(gz)
-    gzFile gz;
-{
-    z_stream *strm;
-    unsigned char out[BUFLEN];
-
-    if (gz == NULL)
-        return Z_STREAM_ERROR;
-    strm = &(gz->strm);
-    if (gz->write) {
-        strm->next_in = Z_NULL;
-        strm->avail_in = 0;
-        do {
-            strm->next_out = out;
-            strm->avail_out = BUFLEN;
-            (void)deflate(strm, Z_FINISH);
-            fwrite(out, 1, BUFLEN - strm->avail_out, gz->file);
-        } while (strm->avail_out == 0);
-        deflateEnd(strm);
-    }
-    else
-        inflateEnd(strm);
-    fclose(gz->file);
-    free(gz);
-    return Z_OK;
-}
-
-const char *gzerror OF((gzFile, int *));
-
-const char *gzerror(gz, err)
-    gzFile gz;
-    int *err;
-{
-    *err = gz->err;
-    return gz->msg;
-}
-
-#endif
-
-char *prog;
-
-void error            OF((const char *msg));
-void gz_compress      OF((FILE   *in, gzFile out));
-#ifdef USE_MMAP
-int  gz_compress_mmap OF((FILE   *in, gzFile out));
-#endif
-void gz_uncompress    OF((gzFile in, FILE   *out));
-void file_compress    OF((char  *file, char *mode));
-void file_uncompress  OF((char  *file));
-int  main             OF((int argc, char *argv[]));
-
-/* ===========================================================================
- * Display error message and exit
- */
-void error(msg)
-    const char *msg;
-{
-    fprintf(stderr, "%s: %s\n", prog, msg);
-    exit(1);
-}
-
-/* ===========================================================================
- * Compress input to output then close both files.
- */
-
-void gz_compress(in, out)
-    FILE   *in;
-    gzFile out;
-{
-    local char buf[BUFLEN];
-    int len;
-    int err;
-
-#ifdef USE_MMAP
-    /* Try first compressing with mmap. If mmap fails (minigzip used in a
-     * pipe), use the normal fread loop.
-     */
-    if (gz_compress_mmap(in, out) == Z_OK) return;
-#endif
-    for (;;) {
-        len = (int)fread(buf, 1, sizeof(buf), in);
-        if (ferror(in)) {
-            perror("fread");
-            exit(1);
-        }
-        if (len == 0) break;
-
-        if (gzwrite(out, buf, (unsigned)len) != len) error(gzerror(out, &err));
-    }
-    fclose(in);
-    if (gzclose(out) != Z_OK) error("failed gzclose");
-}
-
-#ifdef USE_MMAP /* MMAP version, Miguel Albrecht <malbrech@eso.org> */
-
-/* Try compressing the input file at once using mmap. Return Z_OK if
- * if success, Z_ERRNO otherwise.
- */
-int gz_compress_mmap(in, out)
-    FILE   *in;
-    gzFile out;
-{
-    int len;
-    int err;
-    int ifd = fileno(in);
-    caddr_t buf;    /* mmap'ed buffer for the entire input file */
-    off_t buf_len;  /* length of the input file */
-    struct stat sb;
-
-    /* Determine the size of the file, needed for mmap: */
-    if (fstat(ifd, &sb) < 0) return Z_ERRNO;
-    buf_len = sb.st_size;
-    if (buf_len <= 0) return Z_ERRNO;
-
-    /* Now do the actual mmap: */
-    buf = mmap((caddr_t) 0, buf_len, PROT_READ, MAP_SHARED, ifd, (off_t)0);
-    if (buf == (caddr_t)(-1)) return Z_ERRNO;
-
-    /* Compress the whole file at once: */
-    len = gzwrite(out, (char *)buf, (unsigned)buf_len);
-
-    if (len != (int)buf_len) error(gzerror(out, &err));
-
-    munmap(buf, buf_len);
-    fclose(in);
-    if (gzclose(out) != Z_OK) error("failed gzclose");
-    return Z_OK;
-}
-#endif /* USE_MMAP */
-
-/* ===========================================================================
- * Uncompress input to output then close both files.
- */
-void gz_uncompress(in, out)
-    gzFile in;
-    FILE   *out;
-{
-    local char buf[BUFLEN];
-    int len;
-    int err;
-
-    for (;;) {
-        len = gzread(in, buf, sizeof(buf));
-        if (len < 0) error (gzerror(in, &err));
-        if (len == 0) break;
-
-        if ((int)fwrite(buf, 1, (unsigned)len, out) != len) {
-            error("failed fwrite");
-        }
-    }
-    if (fclose(out)) error("failed fclose");
-
-    if (gzclose(in) != Z_OK) error("failed gzclose");
-}
-
-
-/* ===========================================================================
- * Compress the given file: create a corresponding .gz file and remove the
- * original.
- */
-void file_compress(file, mode)
-    char  *file;
-    char  *mode;
-{
-    local char outfile[MAX_NAME_LEN];
-    FILE  *in;
-    gzFile out;
-
-    if (strlen(file) + strlen(GZ_SUFFIX) >= sizeof(outfile)) {
-        fprintf(stderr, "%s: filename too long\n", prog);
-        exit(1);
-    }
-
-    strcpy(outfile, file);
-    strcat(outfile, GZ_SUFFIX);
-
-    in = fopen(file, "rb");
-    if (in == NULL) {
-        perror(file);
-        exit(1);
-    }
-    out = gzopen(outfile, mode);
-    if (out == NULL) {
-        fprintf(stderr, "%s: can't gzopen %s\n", prog, outfile);
-        exit(1);
-    }
-    gz_compress(in, out);
-
-    unlink(file);
-}
-
-
-/* ===========================================================================
- * Uncompress the given file and remove the original.
- */
-void file_uncompress(file)
-    char  *file;
-{
-    local char buf[MAX_NAME_LEN];
-    char *infile, *outfile;
-    FILE  *out;
-    gzFile in;
-    size_t len = strlen(file);
-
-    if (len + strlen(GZ_SUFFIX) >= sizeof(buf)) {
-        fprintf(stderr, "%s: filename too long\n", prog);
-        exit(1);
-    }
-
-    strcpy(buf, file);
-
-    if (len > SUFFIX_LEN && strcmp(file+len-SUFFIX_LEN, GZ_SUFFIX) == 0) {
-        infile = file;
-        outfile = buf;
-        outfile[len-3] = '\0';
-    } else {
-        outfile = file;
-        infile = buf;
-        strcat(infile, GZ_SUFFIX);
-    }
-    in = gzopen(infile, "rb");
-    if (in == NULL) {
-        fprintf(stderr, "%s: can't gzopen %s\n", prog, infile);
-        exit(1);
-    }
-    out = fopen(outfile, "wb");
-    if (out == NULL) {
-        perror(file);
-        exit(1);
-    }
-
-    gz_uncompress(in, out);
-
-    unlink(infile);
-}
-
-
-/* ===========================================================================
- * Usage:  minigzip [-c] [-d] [-f] [-h] [-r] [-1 to -9] [files...]
- *   -c : write to standard output
- *   -d : decompress
- *   -f : compress with Z_FILTERED
- *   -h : compress with Z_HUFFMAN_ONLY
- *   -r : compress with Z_RLE
- *   -1 to -9 : compression level
- */
-
-int main(argc, argv)
-    int argc;
-    char *argv[];
-{
-    int copyout = 0;
-    int uncompr = 0;
-    gzFile file;
-    char *bname, outmode[20];
-
-    strcpy(outmode, "wb6 ");
-
-    prog = argv[0];
-    bname = strrchr(argv[0], '/');
-    if (bname)
-      bname++;
-    else
-      bname = argv[0];
-    argc--, argv++;
-
-    if (!strcmp(bname, "gunzip"))
-      uncompr = 1;
-    else if (!strcmp(bname, "zcat"))
-      copyout = uncompr = 1;
-
-    while (argc > 0) {
-      if (strcmp(*argv, "-c") == 0)
-        copyout = 1;
-      else if (strcmp(*argv, "-d") == 0)
-        uncompr = 1;
-      else if (strcmp(*argv, "-f") == 0)
-        outmode[3] = 'f';
-      else if (strcmp(*argv, "-h") == 0)
-        outmode[3] = 'h';
-      else if (strcmp(*argv, "-r") == 0)
-        outmode[3] = 'R';
-      else if ((*argv)[0] == '-' && (*argv)[1] >= '1' && (*argv)[1] <= '9' &&
-               (*argv)[2] == 0)
-        outmode[2] = (*argv)[1];
-      else
-        break;
-      argc--, argv++;
-    }
-    if (outmode[3] == ' ')
-        outmode[3] = 0;
-    if (argc == 0) {
-        SET_BINARY_MODE(stdin);
-        SET_BINARY_MODE(stdout);
-        if (uncompr) {
-            file = gzdopen(fileno(stdin), "rb");
-            if (file == NULL) error("can't gzdopen stdin");
-            gz_uncompress(file, stdout);
-        } else {
-            file = gzdopen(fileno(stdout), outmode);
-            if (file == NULL) error("can't gzdopen stdout");
-            gz_compress(stdin, file);
-        }
-    } else {
-        if (copyout) {
-            SET_BINARY_MODE(stdout);
-        }
-        do {
-            if (uncompr) {
-                if (copyout) {
-                    file = gzopen(*argv, "rb");
-                    if (file == NULL)
-                        fprintf(stderr, "%s: can't gzopen %s\n", prog, *argv);
-                    else
-                        gz_uncompress(file, stdout);
-                } else {
-                    file_uncompress(*argv);
-                }
-            } else {
-                if (copyout) {
-                    FILE * in = fopen(*argv, "rb");
-
-                    if (in == NULL) {
-                        perror(*argv);
-                    } else {
-                        file = gzdopen(fileno(stdout), outmode);
-                        if (file == NULL) error("can't gzdopen stdout");
-
-                        gz_compress(in, file);
-                    }
-
-                } else {
-                    file_compress(*argv, outmode);
-                }
-            }
-        } while (argv++, --argc);
-    }
-    return 0;
-}
diff -Nbaur gcc-4.8.1/zlib/treebuild.xml gcc-4.8.1-ppc/zlib/treebuild.xml
--- gcc-4.8.1/zlib/treebuild.xml	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/treebuild.xml	1970-01-01 01:00:00.000000000 +0100
@@ -1,116 +0,0 @@
-<?xml version="1.0" ?>
-<package name="zlib" version="1.2.7">
-    <library name="zlib" dlversion="1.2.7" dlname="z">
-	<property name="description"> zip compression library </property>
-	<property name="include-target-dir" value="$(@PACKAGE/install-includedir)" />
-
-	<!-- fixme: not implemented yet -->
-	<property name="compiler/c/inline" value="yes" />
-
-	<include-file name="zlib.h" scope="public" mode="644" />
-	<include-file name="zconf.h" scope="public" mode="644" />
-
-	<source name="adler32.c">
-	    <depend name="zlib.h" />
-	    <depend name="zconf.h" />
-	</source>
-	<source name="compress.c">
-	    <depend name="zlib.h" />
-	    <depend name="zconf.h" />
-	</source>
-	<source name="crc32.c">
-	    <depend name="zlib.h" />
-	    <depend name="zconf.h" />
-	    <depend name="crc32.h" />
-	</source>
-	<source name="gzclose.c">
-	    <depend name="zlib.h" />
-	    <depend name="zconf.h" />
-	    <depend name="gzguts.h" />
-	</source>
-	<source name="gzlib.c">
-	    <depend name="zlib.h" />
-	    <depend name="zconf.h" />
-	    <depend name="gzguts.h" />
-	</source>
-	<source name="gzread.c">
-	    <depend name="zlib.h" />
-	    <depend name="zconf.h" />
-	    <depend name="gzguts.h" />
-	</source>
-	<source name="gzwrite.c">
-	    <depend name="zlib.h" />
-	    <depend name="zconf.h" />
-	    <depend name="gzguts.h" />
-	</source>
-	<source name="uncompr.c">
-	    <depend name="zlib.h" />
-	    <depend name="zconf.h" />
-	</source>
-	<source name="deflate.c">
-	    <depend name="zlib.h" />
-	    <depend name="zconf.h" />
-	    <depend name="zutil.h" />
-	    <depend name="deflate.h" />
-	</source>
-	<source name="trees.c">
-	    <depend name="zlib.h" />
-	    <depend name="zconf.h" />
-	    <depend name="zutil.h" />
-	    <depend name="deflate.h" />
-	    <depend name="trees.h" />
-	</source>
-	<source name="zutil.c">
-	    <depend name="zlib.h" />
-	    <depend name="zconf.h" />
-	    <depend name="zutil.h" />
-	</source>
-	<source name="inflate.c">
-	    <depend name="zlib.h" />
-	    <depend name="zconf.h" />
-	    <depend name="zutil.h" />
-	    <depend name="inftrees.h" />
-	    <depend name="inflate.h" />
-	    <depend name="inffast.h" />
-	</source>
-	<source name="infback.c">
-	    <depend name="zlib.h" />
-	    <depend name="zconf.h" />
-	    <depend name="zutil.h" />
-	    <depend name="inftrees.h" />
-	    <depend name="inflate.h" />
-	    <depend name="inffast.h" />
-	</source>
-	<source name="inftrees.c">
-	    <depend name="zlib.h" />
-	    <depend name="zconf.h" />
-	    <depend name="zutil.h" />
-	    <depend name="inftrees.h" />
-	</source>
-	<source name="inffast.c">
-	    <depend name="zlib.h" />
-	    <depend name="zconf.h" />
-	    <depend name="zutil.h" />
-	    <depend name="inftrees.h" />
-	    <depend name="inflate.h" />
-	    <depend name="inffast.h" />
-	</source>
-    </library>
-</package>
-
-<!--
-CFLAGS=-O
-#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7
-#CFLAGS=-g -DDEBUG
-#CFLAGS=-O3 -Wall -Wwrite-strings -Wpointer-arith -Wconversion \
-#           -Wstrict-prototypes -Wmissing-prototypes
-
-# OBJA =
-# to use the asm code: make OBJA=match.o
-#
-match.o: match.S
-	$(CPP) match.S > _match.s
-	$(CC) -c _match.s
-	mv _match.o match.o
-	rm -f _match.s
--->
diff -Nbaur gcc-4.8.1/zlib/trees.c gcc-4.8.1-ppc/zlib/trees.c
--- gcc-4.8.1/zlib/trees.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/trees.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1224 +0,0 @@
-/* trees.c -- output deflated data using Huffman coding
- * Copyright (C) 1995-2012 Jean-loup Gailly
- * detect_data_type() function provided freely by Cosmin Truta, 2006
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- *  ALGORITHM
- *
- *      The "deflation" process uses several Huffman trees. The more
- *      common source values are represented by shorter bit sequences.
- *
- *      Each code tree is stored in a compressed form which is itself
- * a Huffman encoding of the lengths of all the code strings (in
- * ascending order by source values).  The actual code strings are
- * reconstructed from the lengths in the inflate process, as described
- * in the deflate specification.
- *
- *  REFERENCES
- *
- *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
- *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
- *
- *      Storer, James A.
- *          Data Compression:  Methods and Theory, pp. 49-50.
- *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
- *
- *      Sedgewick, R.
- *          Algorithms, p290.
- *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
- */
-
-/* @(#) $Id: trees.c,v 1.1.1.2 2002/03/11 21:53:27 tromey Exp $ */
-
-/* #define GEN_TREES_H */
-
-#include "deflate.h"
-
-#ifdef DEBUG
-#  include <ctype.h>
-#endif
-
-/* ===========================================================================
- * Constants
- */
-
-#define MAX_BL_BITS 7
-/* Bit length codes must not exceed MAX_BL_BITS bits */
-
-#define END_BLOCK 256
-/* end of block literal code */
-
-#define REP_3_6      16
-/* repeat previous bit length 3-6 times (2 bits of repeat count) */
-
-#define REPZ_3_10    17
-/* repeat a zero length 3-10 times  (3 bits of repeat count) */
-
-#define REPZ_11_138  18
-/* repeat a zero length 11-138 times  (7 bits of repeat count) */
-
-local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
-   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
-
-local const int extra_dbits[D_CODES] /* extra bits for each distance code */
-   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
-
-local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
-   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
-
-local const uch bl_order[BL_CODES]
-   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
-/* The lengths of the bit length codes are sent in order of decreasing
- * probability, to avoid transmitting the lengths for unused bit length codes.
- */
-
-/* ===========================================================================
- * Local data. These are initialized only once.
- */
-
-#define DIST_CODE_LEN  512 /* see definition of array dist_code below */
-
-#if defined(GEN_TREES_H) || !defined(STDC)
-/* non ANSI compilers may not accept trees.h */
-
-local ct_data static_ltree[L_CODES+2];
-/* The static literal tree. Since the bit lengths are imposed, there is no
- * need for the L_CODES extra codes used during heap construction. However
- * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
- * below).
- */
-
-local ct_data static_dtree[D_CODES];
-/* The static distance tree. (Actually a trivial tree since all codes use
- * 5 bits.)
- */
-
-uch _dist_code[DIST_CODE_LEN];
-/* Distance codes. The first 256 values correspond to the distances
- * 3 .. 258, the last 256 values correspond to the top 8 bits of
- * the 15 bit distances.
- */
-
-uch _length_code[MAX_MATCH-MIN_MATCH+1];
-/* length code for each normalized match length (0 == MIN_MATCH) */
-
-local int base_length[LENGTH_CODES];
-/* First normalized length for each code (0 = MIN_MATCH) */
-
-local int base_dist[D_CODES];
-/* First normalized distance for each code (0 = distance of 1) */
-
-#else
-#  include "trees.h"
-#endif /* GEN_TREES_H */
-
-struct static_tree_desc_s {
-    const ct_data *static_tree;  /* static tree or NULL */
-    const intf *extra_bits;      /* extra bits for each code or NULL */
-    int     extra_base;          /* base index for extra_bits */
-    int     elems;               /* max number of elements in the tree */
-    int     max_length;          /* max bit length for the codes */
-};
-
-local static_tree_desc  static_l_desc =
-{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
-
-local static_tree_desc  static_d_desc =
-{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
-
-local static_tree_desc  static_bl_desc =
-{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
-
-/* ===========================================================================
- * Local (static) routines in this file.
- */
-
-local void tr_static_init OF((void));
-local void init_block     OF((deflate_state *s));
-local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
-local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
-local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
-local void build_tree     OF((deflate_state *s, tree_desc *desc));
-local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
-local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
-local int  build_bl_tree  OF((deflate_state *s));
-local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
-                              int blcodes));
-local void compress_block OF((deflate_state *s, ct_data *ltree,
-                              ct_data *dtree));
-local int  detect_data_type OF((deflate_state *s));
-local unsigned bi_reverse OF((unsigned value, int length));
-local void bi_windup      OF((deflate_state *s));
-local void bi_flush       OF((deflate_state *s));
-local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
-                              int header));
-
-#ifdef GEN_TREES_H
-local void gen_trees_header OF((void));
-#endif
-
-#ifndef DEBUG
-#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
-   /* Send a code of the given tree. c and tree must not have side effects */
-
-#else /* DEBUG */
-#  define send_code(s, c, tree) \
-     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
-       send_bits(s, tree[c].Code, tree[c].Len); }
-#endif
-
-/* ===========================================================================
- * Output a short LSB first on the stream.
- * IN assertion: there is enough room in pendingBuf.
- */
-#define put_short(s, w) { \
-    put_byte(s, (uch)((w) & 0xff)); \
-    put_byte(s, (uch)((ush)(w) >> 8)); \
-}
-
-/* ===========================================================================
- * Send a value on a given number of bits.
- * IN assertion: length <= 16 and value fits in length bits.
- */
-#ifdef DEBUG
-local void send_bits      OF((deflate_state *s, int value, int length));
-
-local void send_bits(s, value, length)
-    deflate_state *s;
-    int value;  /* value to send */
-    int length; /* number of bits */
-{
-    Tracevv((stderr," l %2d v %4x ", length, value));
-    Assert(length > 0 && length <= 15, "invalid length");
-    s->bits_sent += (ulg)length;
-
-    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
-     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
-     * unused bits in value.
-     */
-    if (s->bi_valid > (int)Buf_size - length) {
-        s->bi_buf |= (ush)value << s->bi_valid;
-        put_short(s, s->bi_buf);
-        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
-        s->bi_valid += length - Buf_size;
-    } else {
-        s->bi_buf |= (ush)value << s->bi_valid;
-        s->bi_valid += length;
-    }
-}
-#else /* !DEBUG */
-
-#define send_bits(s, value, length) \
-{ int len = length;\
-  if (s->bi_valid > (int)Buf_size - len) {\
-    int val = value;\
-    s->bi_buf |= (ush)val << s->bi_valid;\
-    put_short(s, s->bi_buf);\
-    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
-    s->bi_valid += len - Buf_size;\
-  } else {\
-    s->bi_buf |= (ush)(value) << s->bi_valid;\
-    s->bi_valid += len;\
-  }\
-}
-#endif /* DEBUG */
-
-
-/* the arguments must not have side effects */
-
-/* ===========================================================================
- * Initialize the various 'constant' tables.
- */
-local void tr_static_init()
-{
-#if defined(GEN_TREES_H) || !defined(STDC)
-    static int static_init_done = 0;
-    int n;        /* iterates over tree elements */
-    int bits;     /* bit counter */
-    int length;   /* length value */
-    int code;     /* code value */
-    int dist;     /* distance index */
-    ush bl_count[MAX_BITS+1];
-    /* number of codes at each bit length for an optimal tree */
-
-    if (static_init_done) return;
-
-    /* For some embedded targets, global variables are not initialized: */
-#ifdef NO_INIT_GLOBAL_POINTERS
-    static_l_desc.static_tree = static_ltree;
-    static_l_desc.extra_bits = extra_lbits;
-    static_d_desc.static_tree = static_dtree;
-    static_d_desc.extra_bits = extra_dbits;
-    static_bl_desc.extra_bits = extra_blbits;
-#endif
-
-    /* Initialize the mapping length (0..255) -> length code (0..28) */
-    length = 0;
-    for (code = 0; code < LENGTH_CODES-1; code++) {
-        base_length[code] = length;
-        for (n = 0; n < (1<<extra_lbits[code]); n++) {
-            _length_code[length++] = (uch)code;
-        }
-    }
-    Assert (length == 256, "tr_static_init: length != 256");
-    /* Note that the length 255 (match length 258) can be represented
-     * in two different ways: code 284 + 5 bits or code 285, so we
-     * overwrite length_code[255] to use the best encoding:
-     */
-    _length_code[length-1] = (uch)code;
-
-    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
-    dist = 0;
-    for (code = 0 ; code < 16; code++) {
-        base_dist[code] = dist;
-        for (n = 0; n < (1<<extra_dbits[code]); n++) {
-            _dist_code[dist++] = (uch)code;
-        }
-    }
-    Assert (dist == 256, "tr_static_init: dist != 256");
-    dist >>= 7; /* from now on, all distances are divided by 128 */
-    for ( ; code < D_CODES; code++) {
-        base_dist[code] = dist << 7;
-        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
-            _dist_code[256 + dist++] = (uch)code;
-        }
-    }
-    Assert (dist == 256, "tr_static_init: 256+dist != 512");
-
-    /* Construct the codes of the static literal tree */
-    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
-    n = 0;
-    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
-    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
-    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
-    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
-    /* Codes 286 and 287 do not exist, but we must include them in the
-     * tree construction to get a canonical Huffman tree (longest code
-     * all ones)
-     */
-    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
-
-    /* The static distance tree is trivial: */
-    for (n = 0; n < D_CODES; n++) {
-        static_dtree[n].Len = 5;
-        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
-    }
-    static_init_done = 1;
-
-#  ifdef GEN_TREES_H
-    gen_trees_header();
-#  endif
-#endif /* defined(GEN_TREES_H) || !defined(STDC) */
-}
-
-/* ===========================================================================
- * Genererate the file trees.h describing the static trees.
- */
-#ifdef GEN_TREES_H
-#  ifndef DEBUG
-#    include <stdio.h>
-#  endif
-
-#  define SEPARATOR(i, last, width) \
-      ((i) == (last)? "\n};\n\n" :    \
-       ((i) % (width) == (width)-1 ? ",\n" : ", "))
-
-void gen_trees_header()
-{
-    FILE *header = fopen("trees.h", "w");
-    int i;
-
-    Assert (header != NULL, "Can't open trees.h");
-    fprintf(header,
-            "/* header created automatically with -DGEN_TREES_H */\n\n");
-
-    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
-    for (i = 0; i < L_CODES+2; i++) {
-        fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
-                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
-    }
-
-    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
-    for (i = 0; i < D_CODES; i++) {
-        fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
-                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
-    }
-
-    fprintf(header, "const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n");
-    for (i = 0; i < DIST_CODE_LEN; i++) {
-        fprintf(header, "%2u%s", _dist_code[i],
-                SEPARATOR(i, DIST_CODE_LEN-1, 20));
-    }
-
-    fprintf(header,
-        "const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
-    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
-        fprintf(header, "%2u%s", _length_code[i],
-                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
-    }
-
-    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
-    for (i = 0; i < LENGTH_CODES; i++) {
-        fprintf(header, "%1u%s", base_length[i],
-                SEPARATOR(i, LENGTH_CODES-1, 20));
-    }
-
-    fprintf(header, "local const int base_dist[D_CODES] = {\n");
-    for (i = 0; i < D_CODES; i++) {
-        fprintf(header, "%5u%s", base_dist[i],
-                SEPARATOR(i, D_CODES-1, 10));
-    }
-
-    fclose(header);
-}
-#endif /* GEN_TREES_H */
-
-/* ===========================================================================
- * Initialize the tree data structures for a new zlib stream.
- */
-void ZLIB_INTERNAL _tr_init(s)
-    deflate_state *s;
-{
-    tr_static_init();
-
-    s->l_desc.dyn_tree = s->dyn_ltree;
-    s->l_desc.stat_desc = &static_l_desc;
-
-    s->d_desc.dyn_tree = s->dyn_dtree;
-    s->d_desc.stat_desc = &static_d_desc;
-
-    s->bl_desc.dyn_tree = s->bl_tree;
-    s->bl_desc.stat_desc = &static_bl_desc;
-
-    s->bi_buf = 0;
-    s->bi_valid = 0;
-#ifdef DEBUG
-    s->compressed_len = 0L;
-    s->bits_sent = 0L;
-#endif
-
-    /* Initialize the first block of the first file: */
-    init_block(s);
-}
-
-/* ===========================================================================
- * Initialize a new block.
- */
-local void init_block(s)
-    deflate_state *s;
-{
-    int n; /* iterates over tree elements */
-
-    /* Initialize the trees. */
-    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
-    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
-    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
-
-    s->dyn_ltree[END_BLOCK].Freq = 1;
-    s->opt_len = s->static_len = 0L;
-    s->last_lit = s->matches = 0;
-}
-
-#define SMALLEST 1
-/* Index within the heap array of least frequent node in the Huffman tree */
-
-
-/* ===========================================================================
- * Remove the smallest element from the heap and recreate the heap with
- * one less element. Updates heap and heap_len.
- */
-#define pqremove(s, tree, top) \
-{\
-    top = s->heap[SMALLEST]; \
-    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
-    pqdownheap(s, tree, SMALLEST); \
-}
-
-/* ===========================================================================
- * Compares to subtrees, using the tree depth as tie breaker when
- * the subtrees have equal frequency. This minimizes the worst case length.
- */
-#define smaller(tree, n, m, depth) \
-   (tree[n].Freq < tree[m].Freq || \
-   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
-
-/* ===========================================================================
- * Restore the heap property by moving down the tree starting at node k,
- * exchanging a node with the smallest of its two sons if necessary, stopping
- * when the heap property is re-established (each father smaller than its
- * two sons).
- */
-local void pqdownheap(s, tree, k)
-    deflate_state *s;
-    ct_data *tree;  /* the tree to restore */
-    int k;               /* node to move down */
-{
-    int v = s->heap[k];
-    int j = k << 1;  /* left son of k */
-    while (j <= s->heap_len) {
-        /* Set j to the smallest of the two sons: */
-        if (j < s->heap_len &&
-            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
-            j++;
-        }
-        /* Exit if v is smaller than both sons */
-        if (smaller(tree, v, s->heap[j], s->depth)) break;
-
-        /* Exchange v with the smallest son */
-        s->heap[k] = s->heap[j];  k = j;
-
-        /* And continue down the tree, setting j to the left son of k */
-        j <<= 1;
-    }
-    s->heap[k] = v;
-}
-
-/* ===========================================================================
- * Compute the optimal bit lengths for a tree and update the total bit length
- * for the current block.
- * IN assertion: the fields freq and dad are set, heap[heap_max] and
- *    above are the tree nodes sorted by increasing frequency.
- * OUT assertions: the field len is set to the optimal bit length, the
- *     array bl_count contains the frequencies for each bit length.
- *     The length opt_len is updated; static_len is also updated if stree is
- *     not null.
- */
-local void gen_bitlen(s, desc)
-    deflate_state *s;
-    tree_desc *desc;    /* the tree descriptor */
-{
-    ct_data *tree        = desc->dyn_tree;
-    int max_code         = desc->max_code;
-    const ct_data *stree = desc->stat_desc->static_tree;
-    const intf *extra    = desc->stat_desc->extra_bits;
-    int base             = desc->stat_desc->extra_base;
-    int max_length       = desc->stat_desc->max_length;
-    int h;              /* heap index */
-    int n, m;           /* iterate over the tree elements */
-    int bits;           /* bit length */
-    int xbits;          /* extra bits */
-    ush f;              /* frequency */
-    int overflow = 0;   /* number of elements with bit length too large */
-
-    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
-
-    /* In a first pass, compute the optimal bit lengths (which may
-     * overflow in the case of the bit length tree).
-     */
-    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
-
-    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
-        n = s->heap[h];
-        bits = tree[tree[n].Dad].Len + 1;
-        if (bits > max_length) bits = max_length, overflow++;
-        tree[n].Len = (ush)bits;
-        /* We overwrite tree[n].Dad which is no longer needed */
-
-        if (n > max_code) continue; /* not a leaf node */
-
-        s->bl_count[bits]++;
-        xbits = 0;
-        if (n >= base) xbits = extra[n-base];
-        f = tree[n].Freq;
-        s->opt_len += (ulg)f * (bits + xbits);
-        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
-    }
-    if (overflow == 0) return;
-
-    Trace((stderr,"\nbit length overflow\n"));
-    /* This happens for example on obj2 and pic of the Calgary corpus */
-
-    /* Find the first bit length which could increase: */
-    do {
-        bits = max_length-1;
-        while (s->bl_count[bits] == 0) bits--;
-        s->bl_count[bits]--;      /* move one leaf down the tree */
-        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
-        s->bl_count[max_length]--;
-        /* The brother of the overflow item also moves one step up,
-         * but this does not affect bl_count[max_length]
-         */
-        overflow -= 2;
-    } while (overflow > 0);
-
-    /* Now recompute all bit lengths, scanning in increasing frequency.
-     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
-     * lengths instead of fixing only the wrong ones. This idea is taken
-     * from 'ar' written by Haruhiko Okumura.)
-     */
-    for (bits = max_length; bits != 0; bits--) {
-        n = s->bl_count[bits];
-        while (n != 0) {
-            m = s->heap[--h];
-            if (m > max_code) continue;
-            if ((unsigned) tree[m].Len != (unsigned) bits) {
-                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
-                s->opt_len += ((long)bits - (long)tree[m].Len)
-                              *(long)tree[m].Freq;
-                tree[m].Len = (ush)bits;
-            }
-            n--;
-        }
-    }
-}
-
-/* ===========================================================================
- * Generate the codes for a given tree and bit counts (which need not be
- * optimal).
- * IN assertion: the array bl_count contains the bit length statistics for
- * the given tree and the field len is set for all tree elements.
- * OUT assertion: the field code is set for all tree elements of non
- *     zero code length.
- */
-local void gen_codes (tree, max_code, bl_count)
-    ct_data *tree;             /* the tree to decorate */
-    int max_code;              /* largest code with non zero frequency */
-    ushf *bl_count;            /* number of codes at each bit length */
-{
-    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
-    ush code = 0;              /* running code value */
-    int bits;                  /* bit index */
-    int n;                     /* code index */
-
-    /* The distribution counts are first used to generate the code values
-     * without bit reversal.
-     */
-    for (bits = 1; bits <= MAX_BITS; bits++) {
-        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
-    }
-    /* Check that the bit counts in bl_count are consistent. The last code
-     * must be all ones.
-     */
-    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
-            "inconsistent bit counts");
-    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
-
-    for (n = 0;  n <= max_code; n++) {
-        int len = tree[n].Len;
-        if (len == 0) continue;
-        /* Now reverse the bits */
-        tree[n].Code = bi_reverse(next_code[len]++, len);
-
-        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
-             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
-    }
-}
-
-/* ===========================================================================
- * Construct one Huffman tree and assigns the code bit strings and lengths.
- * Update the total bit length for the current block.
- * IN assertion: the field freq is set for all tree elements.
- * OUT assertions: the fields len and code are set to the optimal bit length
- *     and corresponding code. The length opt_len is updated; static_len is
- *     also updated if stree is not null. The field max_code is set.
- */
-local void build_tree(s, desc)
-    deflate_state *s;
-    tree_desc *desc; /* the tree descriptor */
-{
-    ct_data *tree         = desc->dyn_tree;
-    const ct_data *stree  = desc->stat_desc->static_tree;
-    int elems             = desc->stat_desc->elems;
-    int n, m;          /* iterate over heap elements */
-    int max_code = -1; /* largest code with non zero frequency */
-    int node;          /* new node being created */
-
-    /* Construct the initial heap, with least frequent element in
-     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
-     * heap[0] is not used.
-     */
-    s->heap_len = 0, s->heap_max = HEAP_SIZE;
-
-    for (n = 0; n < elems; n++) {
-        if (tree[n].Freq != 0) {
-            s->heap[++(s->heap_len)] = max_code = n;
-            s->depth[n] = 0;
-        } else {
-            tree[n].Len = 0;
-        }
-    }
-
-    /* The pkzip format requires that at least one distance code exists,
-     * and that at least one bit should be sent even if there is only one
-     * possible code. So to avoid special checks later on we force at least
-     * two codes of non zero frequency.
-     */
-    while (s->heap_len < 2) {
-        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
-        tree[node].Freq = 1;
-        s->depth[node] = 0;
-        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
-        /* node is 0 or 1 so it does not have extra bits */
-    }
-    desc->max_code = max_code;
-
-    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
-     * establish sub-heaps of increasing lengths:
-     */
-    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
-
-    /* Construct the Huffman tree by repeatedly combining the least two
-     * frequent nodes.
-     */
-    node = elems;              /* next internal node of the tree */
-    do {
-        pqremove(s, tree, n);  /* n = node of least frequency */
-        m = s->heap[SMALLEST]; /* m = node of next least frequency */
-
-        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
-        s->heap[--(s->heap_max)] = m;
-
-        /* Create a new node father of n and m */
-        tree[node].Freq = tree[n].Freq + tree[m].Freq;
-        s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
-                                s->depth[n] : s->depth[m]) + 1);
-        tree[n].Dad = tree[m].Dad = (ush)node;
-#ifdef DUMP_BL_TREE
-        if (tree == s->bl_tree) {
-            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
-                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
-        }
-#endif
-        /* and insert the new node in the heap */
-        s->heap[SMALLEST] = node++;
-        pqdownheap(s, tree, SMALLEST);
-
-    } while (s->heap_len >= 2);
-
-    s->heap[--(s->heap_max)] = s->heap[SMALLEST];
-
-    /* At this point, the fields freq and dad are set. We can now
-     * generate the bit lengths.
-     */
-    gen_bitlen(s, (tree_desc *)desc);
-
-    /* The field len is now set, we can generate the bit codes */
-    gen_codes ((ct_data *)tree, max_code, s->bl_count);
-}
-
-/* ===========================================================================
- * Scan a literal or distance tree to determine the frequencies of the codes
- * in the bit length tree.
- */
-local void scan_tree (s, tree, max_code)
-    deflate_state *s;
-    ct_data *tree;   /* the tree to be scanned */
-    int max_code;    /* and its largest code of non zero frequency */
-{
-    int n;                     /* iterates over all tree elements */
-    int prevlen = -1;          /* last emitted length */
-    int curlen;                /* length of current code */
-    int nextlen = tree[0].Len; /* length of next code */
-    int count = 0;             /* repeat count of the current code */
-    int max_count = 7;         /* max repeat count */
-    int min_count = 4;         /* min repeat count */
-
-    if (nextlen == 0) max_count = 138, min_count = 3;
-    tree[max_code+1].Len = (ush)0xffff; /* guard */
-
-    for (n = 0; n <= max_code; n++) {
-        curlen = nextlen; nextlen = tree[n+1].Len;
-        if (++count < max_count && curlen == nextlen) {
-            continue;
-        } else if (count < min_count) {
-            s->bl_tree[curlen].Freq += count;
-        } else if (curlen != 0) {
-            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
-            s->bl_tree[REP_3_6].Freq++;
-        } else if (count <= 10) {
-            s->bl_tree[REPZ_3_10].Freq++;
-        } else {
-            s->bl_tree[REPZ_11_138].Freq++;
-        }
-        count = 0; prevlen = curlen;
-        if (nextlen == 0) {
-            max_count = 138, min_count = 3;
-        } else if (curlen == nextlen) {
-            max_count = 6, min_count = 3;
-        } else {
-            max_count = 7, min_count = 4;
-        }
-    }
-}
-
-/* ===========================================================================
- * Send a literal or distance tree in compressed form, using the codes in
- * bl_tree.
- */
-local void send_tree (s, tree, max_code)
-    deflate_state *s;
-    ct_data *tree; /* the tree to be scanned */
-    int max_code;       /* and its largest code of non zero frequency */
-{
-    int n;                     /* iterates over all tree elements */
-    int prevlen = -1;          /* last emitted length */
-    int curlen;                /* length of current code */
-    int nextlen = tree[0].Len; /* length of next code */
-    int count = 0;             /* repeat count of the current code */
-    int max_count = 7;         /* max repeat count */
-    int min_count = 4;         /* min repeat count */
-
-    /* tree[max_code+1].Len = -1; */  /* guard already set */
-    if (nextlen == 0) max_count = 138, min_count = 3;
-
-    for (n = 0; n <= max_code; n++) {
-        curlen = nextlen; nextlen = tree[n+1].Len;
-        if (++count < max_count && curlen == nextlen) {
-            continue;
-        } else if (count < min_count) {
-            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
-
-        } else if (curlen != 0) {
-            if (curlen != prevlen) {
-                send_code(s, curlen, s->bl_tree); count--;
-            }
-            Assert(count >= 3 && count <= 6, " 3_6?");
-            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);
-
-        } else if (count <= 10) {
-            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);
-
-        } else {
-            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
-        }
-        count = 0; prevlen = curlen;
-        if (nextlen == 0) {
-            max_count = 138, min_count = 3;
-        } else if (curlen == nextlen) {
-            max_count = 6, min_count = 3;
-        } else {
-            max_count = 7, min_count = 4;
-        }
-    }
-}
-
-/* ===========================================================================
- * Construct the Huffman tree for the bit lengths and return the index in
- * bl_order of the last bit length code to send.
- */
-local int build_bl_tree(s)
-    deflate_state *s;
-{
-    int max_blindex;  /* index of last bit length code of non zero freq */
-
-    /* Determine the bit length frequencies for literal and distance trees */
-    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
-    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
-
-    /* Build the bit length tree: */
-    build_tree(s, (tree_desc *)(&(s->bl_desc)));
-    /* opt_len now includes the length of the tree representations, except
-     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
-     */
-
-    /* Determine the number of bit length codes to send. The pkzip format
-     * requires that at least 4 bit length codes be sent. (appnote.txt says
-     * 3 but the actual value used is 4.)
-     */
-    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
-        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
-    }
-    /* Update opt_len to include the bit length tree and counts */
-    s->opt_len += 3*(max_blindex+1) + 5+5+4;
-    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
-            s->opt_len, s->static_len));
-
-    return max_blindex;
-}
-
-/* ===========================================================================
- * Send the header for a block using dynamic Huffman trees: the counts, the
- * lengths of the bit length codes, the literal tree and the distance tree.
- * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
- */
-local void send_all_trees(s, lcodes, dcodes, blcodes)
-    deflate_state *s;
-    int lcodes, dcodes, blcodes; /* number of codes for each tree */
-{
-    int rank;                    /* index in bl_order */
-
-    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
-    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
-            "too many codes");
-    Tracev((stderr, "\nbl counts: "));
-    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
-    send_bits(s, dcodes-1,   5);
-    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
-    for (rank = 0; rank < blcodes; rank++) {
-        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
-        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
-    }
-    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
-
-    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
-    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
-
-    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
-    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
-}
-
-/* ===========================================================================
- * Send a stored block
- */
-void ZLIB_INTERNAL _tr_stored_block(s, buf, stored_len, last)
-    deflate_state *s;
-    charf *buf;       /* input block */
-    ulg stored_len;   /* length of input block */
-    int last;         /* one if this is the last block for a file */
-{
-    send_bits(s, (STORED_BLOCK<<1)+last, 3);    /* send block type */
-#ifdef DEBUG
-    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
-    s->compressed_len += (stored_len + 4) << 3;
-#endif
-    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
-}
-
-/* ===========================================================================
- * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)
- */
-void ZLIB_INTERNAL _tr_flush_bits(s)
-    deflate_state *s;
-{
-    bi_flush(s);
-}
-
-/* ===========================================================================
- * Send one empty static block to give enough lookahead for inflate.
- * This takes 10 bits, of which 7 may remain in the bit buffer.
- */
-void ZLIB_INTERNAL _tr_align(s)
-    deflate_state *s;
-{
-    send_bits(s, STATIC_TREES<<1, 3);
-    send_code(s, END_BLOCK, static_ltree);
-#ifdef DEBUG
-    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
-#endif
-    bi_flush(s);
-}
-
-/* ===========================================================================
- * Determine the best encoding for the current block: dynamic trees, static
- * trees or store, and output the encoded block to the zip file.
- */
-void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)
-    deflate_state *s;
-    charf *buf;       /* input block, or NULL if too old */
-    ulg stored_len;   /* length of input block */
-    int last;         /* one if this is the last block for a file */
-{
-    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
-    int max_blindex = 0;  /* index of last bit length code of non zero freq */
-
-    /* Build the Huffman trees unless a stored block is forced */
-    if (s->level > 0) {
-
-        /* Check if the file is binary or text */
-        if (s->strm->data_type == Z_UNKNOWN)
-            s->strm->data_type = detect_data_type(s);
-
-        /* Construct the literal and distance trees */
-        build_tree(s, (tree_desc *)(&(s->l_desc)));
-        Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
-                s->static_len));
-
-        build_tree(s, (tree_desc *)(&(s->d_desc)));
-        Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
-                s->static_len));
-        /* At this point, opt_len and static_len are the total bit lengths of
-         * the compressed block data, excluding the tree representations.
-         */
-
-        /* Build the bit length tree for the above two trees, and get the index
-         * in bl_order of the last bit length code to send.
-         */
-        max_blindex = build_bl_tree(s);
-
-        /* Determine the best encoding. Compute the block lengths in bytes. */
-        opt_lenb = (s->opt_len+3+7)>>3;
-        static_lenb = (s->static_len+3+7)>>3;
-
-        Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
-                opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
-                s->last_lit));
-
-        if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
-
-    } else {
-        Assert(buf != (char*)0, "lost buf");
-        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
-    }
-
-#ifdef FORCE_STORED
-    if (buf != (char*)0) { /* force stored block */
-#else
-    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
-                       /* 4: two words for the lengths */
-#endif
-        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
-         * Otherwise we can't have processed more than WSIZE input bytes since
-         * the last block flush, because compression would have been
-         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
-         * transform a block into a stored block.
-         */
-        _tr_stored_block(s, buf, stored_len, last);
-
-#ifdef FORCE_STATIC
-    } else if (static_lenb >= 0) { /* force static trees */
-#else
-    } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {
-#endif
-        send_bits(s, (STATIC_TREES<<1)+last, 3);
-        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
-#ifdef DEBUG
-        s->compressed_len += 3 + s->static_len;
-#endif
-    } else {
-        send_bits(s, (DYN_TREES<<1)+last, 3);
-        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
-                       max_blindex+1);
-        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
-#ifdef DEBUG
-        s->compressed_len += 3 + s->opt_len;
-#endif
-    }
-    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
-    /* The above check is made mod 2^32, for files larger than 512 MB
-     * and uLong implemented on 32 bits.
-     */
-    init_block(s);
-
-    if (last) {
-        bi_windup(s);
-#ifdef DEBUG
-        s->compressed_len += 7;  /* align on byte boundary */
-#endif
-    }
-    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
-           s->compressed_len-7*last));
-}
-
-/* ===========================================================================
- * Save the match info and tally the frequency counts. Return true if
- * the current block must be flushed.
- */
-int ZLIB_INTERNAL _tr_tally (s, dist, lc)
-    deflate_state *s;
-    unsigned dist;  /* distance of matched string */
-    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
-{
-    s->d_buf[s->last_lit] = (ush)dist;
-    s->l_buf[s->last_lit++] = (uch)lc;
-    if (dist == 0) {
-        /* lc is the unmatched char */
-        s->dyn_ltree[lc].Freq++;
-    } else {
-        s->matches++;
-        /* Here, lc is the match length - MIN_MATCH */
-        dist--;             /* dist = match distance - 1 */
-        Assert((ush)dist < (ush)MAX_DIST(s) &&
-               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
-               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
-
-        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
-        s->dyn_dtree[d_code(dist)].Freq++;
-    }
-
-#ifdef TRUNCATE_BLOCK
-    /* Try to guess if it is profitable to stop the current block here */
-    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
-        /* Compute an upper bound for the compressed length */
-        ulg out_length = (ulg)s->last_lit*8L;
-        ulg in_length = (ulg)((long)s->strstart - s->block_start);
-        int dcode;
-        for (dcode = 0; dcode < D_CODES; dcode++) {
-            out_length += (ulg)s->dyn_dtree[dcode].Freq *
-                (5L+extra_dbits[dcode]);
-        }
-        out_length >>= 3;
-        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
-               s->last_lit, in_length, out_length,
-               100L - out_length*100L/in_length));
-        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
-    }
-#endif
-    return (s->last_lit == s->lit_bufsize-1);
-    /* We avoid equality with lit_bufsize because of wraparound at 64K
-     * on 16 bit machines and because stored blocks are restricted to
-     * 64K-1 bytes.
-     */
-}
-
-/* ===========================================================================
- * Send the block data compressed using the given Huffman trees
- */
-local void compress_block(s, ltree, dtree)
-    deflate_state *s;
-    ct_data *ltree; /* literal tree */
-    ct_data *dtree; /* distance tree */
-{
-    unsigned dist;      /* distance of matched string */
-    int lc;             /* match length or unmatched char (if dist == 0) */
-    unsigned lx = 0;    /* running index in l_buf */
-    unsigned code;      /* the code to send */
-    int extra;          /* number of extra bits to send */
-
-    if (s->last_lit != 0) do {
-        dist = s->d_buf[lx];
-        lc = s->l_buf[lx++];
-        if (dist == 0) {
-            send_code(s, lc, ltree); /* send a literal byte */
-            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
-        } else {
-            /* Here, lc is the match length - MIN_MATCH */
-            code = _length_code[lc];
-            send_code(s, code+LITERALS+1, ltree); /* send the length code */
-            extra = extra_lbits[code];
-            if (extra != 0) {
-                lc -= base_length[code];
-                send_bits(s, lc, extra);       /* send the extra length bits */
-            }
-            dist--; /* dist is now the match distance - 1 */
-            code = d_code(dist);
-            Assert (code < D_CODES, "bad d_code");
-
-            send_code(s, code, dtree);       /* send the distance code */
-            extra = extra_dbits[code];
-            if (extra != 0) {
-                dist -= base_dist[code];
-                send_bits(s, dist, extra);   /* send the extra distance bits */
-            }
-        } /* literal or match pair ? */
-
-        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
-        Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
-               "pendingBuf overflow");
-
-    } while (lx < s->last_lit);
-
-    send_code(s, END_BLOCK, ltree);
-}
-
-/* ===========================================================================
- * Check if the data type is TEXT or BINARY, using the following algorithm:
- * - TEXT if the two conditions below are satisfied:
- *    a) There are no non-portable control characters belonging to the
- *       "black list" (0..6, 14..25, 28..31).
- *    b) There is at least one printable character belonging to the
- *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
- * - BINARY otherwise.
- * - The following partially-portable control characters form a
- *   "gray list" that is ignored in this detection algorithm:
- *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
- * IN assertion: the fields Freq of dyn_ltree are set.
- */
-local int detect_data_type(s)
-    deflate_state *s;
-{
-    /* black_mask is the bit mask of black-listed bytes
-     * set bits 0..6, 14..25, and 28..31
-     * 0xf3ffc07f = binary 11110011111111111100000001111111
-     */
-    unsigned long black_mask = 0xf3ffc07fUL;
-    int n;
-
-    /* Check for non-textual ("black-listed") bytes. */
-    for (n = 0; n <= 31; n++, black_mask >>= 1)
-        if ((black_mask & 1) && (s->dyn_ltree[n].Freq != 0))
-            return Z_BINARY;
-
-    /* Check for textual ("white-listed") bytes. */
-    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
-            || s->dyn_ltree[13].Freq != 0)
-        return Z_TEXT;
-    for (n = 32; n < LITERALS; n++)
-        if (s->dyn_ltree[n].Freq != 0)
-            return Z_TEXT;
-
-    /* There are no "black-listed" or "white-listed" bytes:
-     * this stream either is empty or has tolerated ("gray-listed") bytes only.
-     */
-    return Z_BINARY;
-}
-
-/* ===========================================================================
- * Reverse the first len bits of a code, using straightforward code (a faster
- * method would use a table)
- * IN assertion: 1 <= len <= 15
- */
-local unsigned bi_reverse(code, len)
-    unsigned code; /* the value to invert */
-    int len;       /* its bit length */
-{
-    register unsigned res = 0;
-    do {
-        res |= code & 1;
-        code >>= 1, res <<= 1;
-    } while (--len > 0);
-    return res >> 1;
-}
-
-/* ===========================================================================
- * Flush the bit buffer, keeping at most 7 bits in it.
- */
-local void bi_flush(s)
-    deflate_state *s;
-{
-    if (s->bi_valid == 16) {
-        put_short(s, s->bi_buf);
-        s->bi_buf = 0;
-        s->bi_valid = 0;
-    } else if (s->bi_valid >= 8) {
-        put_byte(s, (Byte)s->bi_buf);
-        s->bi_buf >>= 8;
-        s->bi_valid -= 8;
-    }
-}
-
-/* ===========================================================================
- * Flush the bit buffer and align the output on a byte boundary
- */
-local void bi_windup(s)
-    deflate_state *s;
-{
-    if (s->bi_valid > 8) {
-        put_short(s, s->bi_buf);
-    } else if (s->bi_valid > 0) {
-        put_byte(s, (Byte)s->bi_buf);
-    }
-    s->bi_buf = 0;
-    s->bi_valid = 0;
-#ifdef DEBUG
-    s->bits_sent = (s->bits_sent+7) & ~7;
-#endif
-}
-
-/* ===========================================================================
- * Copy a stored block, storing first the length and its
- * one's complement if requested.
- */
-local void copy_block(s, buf, len, header)
-    deflate_state *s;
-    charf    *buf;    /* the input data */
-    unsigned len;     /* its length */
-    int      header;  /* true if block header must be written */
-{
-    bi_windup(s);        /* align on byte boundary */
-
-    if (header) {
-        put_short(s, (ush)len);
-        put_short(s, (ush)~len);
-#ifdef DEBUG
-        s->bits_sent += 2*16;
-#endif
-    }
-#ifdef DEBUG
-    s->bits_sent += (ulg)len<<3;
-#endif
-    while (len--) {
-        put_byte(s, *buf++);
-    }
-}
diff -Nbaur gcc-4.8.1/zlib/trees.h gcc-4.8.1-ppc/zlib/trees.h
--- gcc-4.8.1/zlib/trees.h	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/trees.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,128 +0,0 @@
-/* header created automatically with -DGEN_TREES_H */
-
-local const ct_data static_ltree[L_CODES+2] = {
-{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
-{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
-{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
-{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
-{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
-{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
-{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
-{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
-{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
-{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
-{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
-{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
-{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
-{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
-{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
-{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
-{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
-{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
-{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
-{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
-{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
-{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
-{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
-{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
-{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
-{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
-{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
-{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
-{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
-{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
-{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
-{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
-{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
-{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
-{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
-{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
-{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
-{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
-{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
-{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
-{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
-{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
-{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
-{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
-{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
-{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
-{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
-{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
-{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
-{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
-{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
-{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
-{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
-{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
-{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
-{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
-{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
-{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
-};
-
-local const ct_data static_dtree[D_CODES] = {
-{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
-{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
-{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
-{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
-{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
-{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
-};
-
-const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {
- 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
- 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
-10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
-11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
-12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
-13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
-18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
-23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
-};
-
-const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {
- 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
-13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
-17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
-19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
-21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
-22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
-23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
-};
-
-local const int base_length[LENGTH_CODES] = {
-0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
-64, 80, 96, 112, 128, 160, 192, 224, 0
-};
-
-local const int base_dist[D_CODES] = {
-    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
-   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
- 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
-};
-
diff -Nbaur gcc-4.8.1/zlib/uncompr.c gcc-4.8.1-ppc/zlib/uncompr.c
--- gcc-4.8.1/zlib/uncompr.c	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/uncompr.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,59 +0,0 @@
-/* uncompr.c -- decompress a memory buffer
- * Copyright (C) 1995-2003, 2010 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id: uncompr.c,v 1.1.1.2 2002/03/11 21:53:27 tromey Exp $ */
-
-#define ZLIB_INTERNAL
-#include "zlib.h"
-
-/* ===========================================================================
-     Decompresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer. Upon entry, destLen is the total
-   size of the destination buffer, which must be large enough to hold the
-   entire uncompressed data. (The size of the uncompressed data must have
-   been saved previously by the compressor and transmitted to the decompressor
-   by some mechanism outside the scope of this compression library.)
-   Upon exit, destLen is the actual size of the compressed buffer.
-
-     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer, or Z_DATA_ERROR if the input data was corrupted.
-*/
-int ZEXPORT uncompress (dest, destLen, source, sourceLen)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-{
-    z_stream stream;
-    int err;
-
-    stream.next_in = (Bytef*)source;
-    stream.avail_in = (uInt)sourceLen;
-    /* Check for source > 64K on 16-bit machine: */
-    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
-
-    stream.next_out = dest;
-    stream.avail_out = (uInt)*destLen;
-    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
-
-    stream.zalloc = (alloc_func)0;
-    stream.zfree = (free_func)0;
-
-    err = inflateInit(&stream);
-    if (err != Z_OK) return err;
-
-    err = inflate(&stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        inflateEnd(&stream);
-        if (err == Z_NEED_DICT || (err == Z_BUF_ERROR && stream.avail_in == 0))
-            return Z_DATA_ERROR;
-        return err;
-    }
-    *destLen = stream.total_out;
-
-    err = inflateEnd(&stream);
-    return err;
-}
diff -Nbaur gcc-4.8.1/zlib/watcom/watcom_f.mak gcc-4.8.1-ppc/zlib/watcom/watcom_f.mak
--- gcc-4.8.1/zlib/watcom/watcom_f.mak	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/watcom/watcom_f.mak	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-# Makefile for zlib
-# OpenWatcom flat model
-# Last updated: 28-Dec-2005
-
-# To use, do "wmake -f watcom_f.mak"
-
-C_SOURCE =  adler32.c  compress.c crc32.c   deflate.c    &
-	    gzclose.c  gzlib.c    gzread.c  gzwrite.c    &
-            infback.c  inffast.c  inflate.c inftrees.c   &
-            trees.c    uncompr.c  zutil.c
-
-OBJS =      adler32.obj  compress.obj crc32.obj   deflate.obj    &
-	    gzclose.obj  gzlib.obj    gzread.obj  gzwrite.obj    &
-            infback.obj  inffast.obj  inflate.obj inftrees.obj   &
-            trees.obj    uncompr.obj  zutil.obj
-
-CC       = wcc386
-LINKER   = wcl386
-CFLAGS   = -zq -mf -3r -fp3 -s -bt=dos -oilrtfm -fr=nul -wx
-ZLIB_LIB = zlib_f.lib
-
-.C.OBJ:
-        $(CC) $(CFLAGS) $[@
-
-all: $(ZLIB_LIB) example.exe minigzip.exe
-
-$(ZLIB_LIB): $(OBJS)
-	wlib -b -c $(ZLIB_LIB) -+adler32.obj  -+compress.obj -+crc32.obj
-	wlib -b -c $(ZLIB_LIB) -+gzclose.obj  -+gzlib.obj    -+gzread.obj   -+gzwrite.obj
-        wlib -b -c $(ZLIB_LIB) -+deflate.obj  -+infback.obj
-        wlib -b -c $(ZLIB_LIB) -+inffast.obj  -+inflate.obj  -+inftrees.obj
-        wlib -b -c $(ZLIB_LIB) -+trees.obj    -+uncompr.obj  -+zutil.obj
-
-example.exe: $(ZLIB_LIB) example.obj
-	$(LINKER) -ldos32a -fe=example.exe example.obj $(ZLIB_LIB)
-
-minigzip.exe: $(ZLIB_LIB) minigzip.obj
-	$(LINKER) -ldos32a -fe=minigzip.exe minigzip.obj $(ZLIB_LIB)
-
-clean: .SYMBOLIC
-          del *.obj
-          del $(ZLIB_LIB)
-          @echo Cleaning done
diff -Nbaur gcc-4.8.1/zlib/watcom/watcom_l.mak gcc-4.8.1-ppc/zlib/watcom/watcom_l.mak
--- gcc-4.8.1/zlib/watcom/watcom_l.mak	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/watcom/watcom_l.mak	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-# Makefile for zlib
-# OpenWatcom large model
-# Last updated: 28-Dec-2005
-
-# To use, do "wmake -f watcom_l.mak"
-
-C_SOURCE =  adler32.c  compress.c crc32.c   deflate.c    &
-	    gzclose.c  gzlib.c    gzread.c  gzwrite.c    &
-            infback.c  inffast.c  inflate.c inftrees.c   &
-            trees.c    uncompr.c  zutil.c
-
-OBJS =      adler32.obj  compress.obj crc32.obj   deflate.obj    &
-	    gzclose.obj  gzlib.obj    gzread.obj  gzwrite.obj    &
-            infback.obj  inffast.obj  inflate.obj inftrees.obj   &
-            trees.obj    uncompr.obj  zutil.obj
-
-CC       = wcc
-LINKER   = wcl
-CFLAGS   = -zq -ml -s -bt=dos -oilrtfm -fr=nul -wx
-ZLIB_LIB = zlib_l.lib
-
-.C.OBJ:
-        $(CC) $(CFLAGS) $[@
-
-all: $(ZLIB_LIB) example.exe minigzip.exe
-
-$(ZLIB_LIB): $(OBJS)
-	wlib -b -c $(ZLIB_LIB) -+adler32.obj  -+compress.obj -+crc32.obj
-	wlib -b -c $(ZLIB_LIB) -+gzclose.obj  -+gzlib.obj    -+gzread.obj   -+gzwrite.obj
-        wlib -b -c $(ZLIB_LIB) -+deflate.obj  -+infback.obj
-        wlib -b -c $(ZLIB_LIB) -+inffast.obj  -+inflate.obj  -+inftrees.obj
-        wlib -b -c $(ZLIB_LIB) -+trees.obj    -+uncompr.obj  -+zutil.obj
-
-example.exe: $(ZLIB_LIB) example.obj
-	$(LINKER) -fe=example.exe example.obj $(ZLIB_LIB)
-
-minigzip.exe: $(ZLIB_LIB) minigzip.obj
-	$(LINKER) -fe=minigzip.exe minigzip.obj $(ZLIB_LIB)
-
-clean: .SYMBOLIC
-          del *.obj
-          del $(ZLIB_LIB)
-          @echo Cleaning done
diff -Nbaur gcc-4.8.1/zlib/win32/DLL_FAQ.txt gcc-4.8.1-ppc/zlib/win32/DLL_FAQ.txt
--- gcc-4.8.1/zlib/win32/DLL_FAQ.txt	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/win32/DLL_FAQ.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,397 +0,0 @@
-
-            Frequently Asked Questions about ZLIB1.DLL
-
-
-This document describes the design, the rationale, and the usage
-of the official DLL build of zlib, named ZLIB1.DLL.  If you have
-general questions about zlib, you should see the file "FAQ" found
-in the zlib distribution, or at the following location:
-  http://www.gzip.org/zlib/zlib_faq.html
-
-
- 1. What is ZLIB1.DLL, and how can I get it?
-
-  - ZLIB1.DLL is the official build of zlib as a DLL.
-    (Please remark the character '1' in the name.)
-
-    Pointers to a precompiled ZLIB1.DLL can be found in the zlib
-    web site at:
-      http://www.zlib.net/
-
-    Applications that link to ZLIB1.DLL can rely on the following
-    specification:
-
-    * The exported symbols are exclusively defined in the source
-      files "zlib.h" and "zlib.def", found in an official zlib
-      source distribution.
-    * The symbols are exported by name, not by ordinal.
-    * The exported names are undecorated.
-    * The calling convention of functions is "C" (CDECL).
-    * The ZLIB1.DLL binary is linked to MSVCRT.DLL.
-
-    The archive in which ZLIB1.DLL is bundled contains compiled
-    test programs that must run with a valid build of ZLIB1.DLL.
-    It is recommended to download the prebuilt DLL from the zlib
-    web site, instead of building it yourself, to avoid potential
-    incompatibilities that could be introduced by your compiler
-    and build settings.  If you do build the DLL yourself, please
-    make sure that it complies with all the above requirements,
-    and it runs with the precompiled test programs, bundled with
-    the original ZLIB1.DLL distribution.
-
-    If, for any reason, you need to build an incompatible DLL,
-    please use a different file name.
-
-
- 2. Why did you change the name of the DLL to ZLIB1.DLL?
-    What happened to the old ZLIB.DLL?
-
-  - The old ZLIB.DLL, built from zlib-1.1.4 or earlier, required
-    compilation settings that were incompatible to those used by
-    a static build.  The DLL settings were supposed to be enabled
-    by defining the macro ZLIB_DLL, before including "zlib.h".
-    Incorrect handling of this macro was silently accepted at
-    build time, resulting in two major problems:
-
-    * ZLIB_DLL was missing from the old makefile.  When building
-      the DLL, not all people added it to the build options.  In
-      consequence, incompatible incarnations of ZLIB.DLL started
-      to circulate around the net.
-
-    * When switching from using the static library to using the
-      DLL, applications had to define the ZLIB_DLL macro and
-      to recompile all the sources that contained calls to zlib
-      functions.  Failure to do so resulted in creating binaries
-      that were unable to run with the official ZLIB.DLL build.
-
-    The only possible solution that we could foresee was to make
-    a binary-incompatible change in the DLL interface, in order to
-    remove the dependency on the ZLIB_DLL macro, and to release
-    the new DLL under a different name.
-
-    We chose the name ZLIB1.DLL, where '1' indicates the major
-    zlib version number.  We hope that we will not have to break
-    the binary compatibility again, at least not as long as the
-    zlib-1.x series will last.
-
-    There is still a ZLIB_DLL macro, that can trigger a more
-    efficient build and use of the DLL, but compatibility no
-    longer dependents on it.
-
-
- 3. Can I build ZLIB.DLL from the new zlib sources, and replace
-    an old ZLIB.DLL, that was built from zlib-1.1.4 or earlier?
-
-  - In principle, you can do it by assigning calling convention
-    keywords to the macros ZEXPORT and ZEXPORTVA.  In practice,
-    it depends on what you mean by "an old ZLIB.DLL", because the
-    old DLL exists in several mutually-incompatible versions.
-    You have to find out first what kind of calling convention is
-    being used in your particular ZLIB.DLL build, and to use the
-    same one in the new build.  If you don't know what this is all
-    about, you might be better off if you would just leave the old
-    DLL intact.
-
-
- 4. Can I compile my application using the new zlib interface, and
-    link it to an old ZLIB.DLL, that was built from zlib-1.1.4 or
-    earlier?
-
-  - The official answer is "no"; the real answer depends again on
-    what kind of ZLIB.DLL you have.  Even if you are lucky, this
-    course of action is unreliable.
-
-    If you rebuild your application and you intend to use a newer
-    version of zlib (post- 1.1.4), it is strongly recommended to
-    link it to the new ZLIB1.DLL.
-
-
- 5. Why are the zlib symbols exported by name, and not by ordinal?
-
-  - Although exporting symbols by ordinal is a little faster, it
-    is risky.  Any single glitch in the maintenance or use of the
-    DEF file that contains the ordinals can result in incompatible
-    builds and frustrating crashes.  Simply put, the benefits of
-    exporting symbols by ordinal do not justify the risks.
-
-    Technically, it should be possible to maintain ordinals in
-    the DEF file, and still export the symbols by name.  Ordinals
-    exist in every DLL, and even if the dynamic linking performed
-    at the DLL startup is searching for names, ordinals serve as
-    hints, for a faster name lookup.  However, if the DEF file
-    contains ordinals, the Microsoft linker automatically builds
-    an implib that will cause the executables linked to it to use
-    those ordinals, and not the names.  It is interesting to
-    notice that the GNU linker for Win32 does not suffer from this
-    problem.
-
-    It is possible to avoid the DEF file if the exported symbols
-    are accompanied by a "__declspec(dllexport)" attribute in the
-    source files.  You can do this in zlib by predefining the
-    ZLIB_DLL macro.
-
-
- 6. I see that the ZLIB1.DLL functions use the "C" (CDECL) calling
-    convention.  Why not use the STDCALL convention?
-    STDCALL is the standard convention in Win32, and I need it in
-    my Visual Basic project!
-
-    (For readability, we use CDECL to refer to the convention
-     triggered by the "__cdecl" keyword, STDCALL to refer to
-     the convention triggered by "__stdcall", and FASTCALL to
-     refer to the convention triggered by "__fastcall".)
-
-  - Most of the native Windows API functions (without varargs) use
-    indeed the WINAPI convention (which translates to STDCALL in
-    Win32), but the standard C functions use CDECL.  If a user
-    application is intrinsically tied to the Windows API (e.g.
-    it calls native Windows API functions such as CreateFile()),
-    sometimes it makes sense to decorate its own functions with
-    WINAPI.  But if ANSI C or POSIX portability is a goal (e.g.
-    it calls standard C functions such as fopen()), it is not a
-    sound decision to request the inclusion of <windows.h>, or to
-    use non-ANSI constructs, for the sole purpose to make the user
-    functions STDCALL-able.
-
-    The functionality offered by zlib is not in the category of
-    "Windows functionality", but is more like "C functionality".
-
-    Technically, STDCALL is not bad; in fact, it is slightly
-    faster than CDECL, and it works with variable-argument
-    functions, just like CDECL.  It is unfortunate that, in spite
-    of using STDCALL in the Windows API, it is not the default
-    convention used by the C compilers that run under Windows.
-    The roots of the problem reside deep inside the unsafety of
-    the K&R-style function prototypes, where the argument types
-    are not specified; but that is another story for another day.
-
-    The remaining fact is that CDECL is the default convention.
-    Even if an explicit convention is hard-coded into the function
-    prototypes inside C headers, problems may appear.  The
-    necessity to expose the convention in users' callbacks is one
-    of these problems.
-
-    The calling convention issues are also important when using
-    zlib in other programming languages.  Some of them, like Ada
-    (GNAT) and Fortran (GNU G77), have C bindings implemented
-    initially on Unix, and relying on the C calling convention.
-    On the other hand, the pre- .NET versions of Microsoft Visual
-    Basic require STDCALL, while Borland Delphi prefers, although
-    it does not require, FASTCALL.
-
-    In fairness to all possible uses of zlib outside the C
-    programming language, we choose the default "C" convention.
-    Anyone interested in different bindings or conventions is
-    encouraged to maintain specialized projects.  The "contrib/"
-    directory from the zlib distribution already holds a couple
-    of foreign bindings, such as Ada, C++, and Delphi.
-
-
- 7. I need a DLL for my Visual Basic project.  What can I do?
-
-  - Define the ZLIB_WINAPI macro before including "zlib.h", when
-    building both the DLL and the user application (except that
-    you don't need to define anything when using the DLL in Visual
-    Basic).  The ZLIB_WINAPI macro will switch on the WINAPI
-    (STDCALL) convention.  The name of this DLL must be different
-    than the official ZLIB1.DLL.
-
-    Gilles Vollant has contributed a build named ZLIBWAPI.DLL,
-    with the ZLIB_WINAPI macro turned on, and with the minizip
-    functionality built in.  For more information, please read
-    the notes inside "contrib/vstudio/readme.txt", found in the
-    zlib distribution.
-
-
- 8. I need to use zlib in my Microsoft .NET project.  What can I
-    do?
-
-  - Henrik Ravn has contributed a .NET wrapper around zlib.  Look
-    into contrib/dotzlib/, inside the zlib distribution.
-
-
- 9. If my application uses ZLIB1.DLL, should I link it to
-    MSVCRT.DLL?  Why?
-
-  - It is not required, but it is recommended to link your
-    application to MSVCRT.DLL, if it uses ZLIB1.DLL.
-
-    The executables (.EXE, .DLL, etc.) that are involved in the
-    same process and are using the C run-time library (i.e. they
-    are calling standard C functions), must link to the same
-    library.  There are several libraries in the Win32 system:
-    CRTDLL.DLL, MSVCRT.DLL, the static C libraries, etc.
-    Since ZLIB1.DLL is linked to MSVCRT.DLL, the executables that
-    depend on it should also be linked to MSVCRT.DLL.
-
-
-10. Why are you saying that ZLIB1.DLL and my application should
-    be linked to the same C run-time (CRT) library?  I linked my
-    application and my DLLs to different C libraries (e.g. my
-    application to a static library, and my DLLs to MSVCRT.DLL),
-    and everything works fine.
-
-  - If a user library invokes only pure Win32 API (accessible via
-    <windows.h> and the related headers), its DLL build will work
-    in any context.  But if this library invokes standard C API,
-    things get more complicated.
-
-    There is a single Win32 library in a Win32 system.  Every
-    function in this library resides in a single DLL module, that
-    is safe to call from anywhere.  On the other hand, there are
-    multiple versions of the C library, and each of them has its
-    own separate internal state.  Standalone executables and user
-    DLLs that call standard C functions must link to a C run-time
-    (CRT) library, be it static or shared (DLL).  Intermixing
-    occurs when an executable (not necessarily standalone) and a
-    DLL are linked to different CRTs, and both are running in the
-    same process.
-
-    Intermixing multiple CRTs is possible, as long as their
-    internal states are kept intact.  The Microsoft Knowledge Base
-    articles KB94248 "HOWTO: Use the C Run-Time" and KB140584
-    "HOWTO: Link with the Correct C Run-Time (CRT) Library"
-    mention the potential problems raised by intermixing.
-
-    If intermixing works for you, it's because your application
-    and DLLs are avoiding the corruption of each of the CRTs'
-    internal states, maybe by careful design, or maybe by fortune.
-
-    Also note that linking ZLIB1.DLL to non-Microsoft CRTs, such
-    as those provided by Borland, raises similar problems.
-
-
-11. Why are you linking ZLIB1.DLL to MSVCRT.DLL?
-
-  - MSVCRT.DLL exists on every Windows 95 with a new service pack
-    installed, or with Microsoft Internet Explorer 4 or later, and
-    on all other Windows 4.x or later (Windows 98, Windows NT 4,
-    or later).  It is freely distributable; if not present in the
-    system, it can be downloaded from Microsoft or from other
-    software provider for free.
-
-    The fact that MSVCRT.DLL does not exist on a virgin Windows 95
-    is not so problematic.  Windows 95 is scarcely found nowadays,
-    Microsoft ended its support a long time ago, and many recent
-    applications from various vendors, including Microsoft, do not
-    even run on it.  Furthermore, no serious user should run
-    Windows 95 without a proper update installed.
-
-
-12. Why are you not linking ZLIB1.DLL to
-    <<my favorite C run-time library>> ?
-
-  - We considered and abandoned the following alternatives:
-
-    * Linking ZLIB1.DLL to a static C library (LIBC.LIB, or
-      LIBCMT.LIB) is not a good option.  People are using the DLL
-      mainly to save disk space.  If you are linking your program
-      to a static C library, you may as well consider linking zlib
-      in statically, too.
-
-    * Linking ZLIB1.DLL to CRTDLL.DLL looks appealing, because
-      CRTDLL.DLL is present on every Win32 installation.
-      Unfortunately, it has a series of problems: it does not
-      work properly with Microsoft's C++ libraries, it does not
-      provide support for 64-bit file offsets, (and so on...),
-      and Microsoft discontinued its support a long time ago.
-
-    * Linking ZLIB1.DLL to MSVCR70.DLL or MSVCR71.DLL, supplied
-      with the Microsoft .NET platform, and Visual C++ 7.0/7.1,
-      raises problems related to the status of ZLIB1.DLL as a
-      system component.  According to the Microsoft Knowledge Base
-      article KB326922 "INFO: Redistribution of the Shared C
-      Runtime Component in Visual C++ .NET", MSVCR70.DLL and
-      MSVCR71.DLL are not supposed to function as system DLLs,
-      because they may clash with MSVCRT.DLL.  Instead, the
-      application's installer is supposed to put these DLLs
-      (if needed) in the application's private directory.
-      If ZLIB1.DLL depends on a non-system runtime, it cannot
-      function as a redistributable system component.
-
-    * Linking ZLIB1.DLL to non-Microsoft runtimes, such as
-      Borland's, or Cygwin's, raises problems related to the
-      reliable presence of these runtimes on Win32 systems.
-      It's easier to let the DLL build of zlib up to the people
-      who distribute these runtimes, and who may proceed as
-      explained in the answer to Question 14.
-
-
-13. If ZLIB1.DLL cannot be linked to MSVCR70.DLL or MSVCR71.DLL,
-    how can I build/use ZLIB1.DLL in Microsoft Visual C++ 7.0
-    (Visual Studio .NET) or newer?
-
-  - Due to the problems explained in the Microsoft Knowledge Base
-    article KB326922 (see the previous answer), the C runtime that
-    comes with the VC7 environment is no longer considered a
-    system component.  That is, it should not be assumed that this
-    runtime exists, or may be installed in a system directory.
-    Since ZLIB1.DLL is supposed to be a system component, it may
-    not depend on a non-system component.
-
-    In order to link ZLIB1.DLL and your application to MSVCRT.DLL
-    in VC7, you need the library of Visual C++ 6.0 or older.  If
-    you don't have this library at hand, it's probably best not to
-    use ZLIB1.DLL.
-
-    We are hoping that, in the future, Microsoft will provide a
-    way to build applications linked to a proper system runtime,
-    from the Visual C++ environment.  Until then, you have a
-    couple of alternatives, such as linking zlib in statically.
-    If your application requires dynamic linking, you may proceed
-    as explained in the answer to Question 14.
-
-
-14. I need to link my own DLL build to a CRT different than
-    MSVCRT.DLL.  What can I do?
-
-  - Feel free to rebuild the DLL from the zlib sources, and link
-    it the way you want.  You should, however, clearly state that
-    your build is unofficial.  You should give it a different file
-    name, and/or install it in a private directory that can be
-    accessed by your application only, and is not visible to the
-    others (i.e. it's neither in the PATH, nor in the SYSTEM or
-    SYSTEM32 directories).  Otherwise, your build may clash with
-    applications that link to the official build.
-
-    For example, in Cygwin, zlib is linked to the Cygwin runtime
-    CYGWIN1.DLL, and it is distributed under the name CYGZ.DLL.
-
-
-15. May I include additional pieces of code that I find useful,
-    link them in ZLIB1.DLL, and export them?
-
-  - No.  A legitimate build of ZLIB1.DLL must not include code
-    that does not originate from the official zlib source code.
-    But you can make your own private DLL build, under a different
-    file name, as suggested in the previous answer.
-
-    For example, zlib is a part of the VCL library, distributed
-    with Borland Delphi and C++ Builder.  The DLL build of VCL
-    is a redistributable file, named VCLxx.DLL.
-
-
-16. May I remove some functionality out of ZLIB1.DLL, by enabling
-    macros like NO_GZCOMPRESS or NO_GZIP at compile time?
-
-  - No.  A legitimate build of ZLIB1.DLL must provide the complete
-    zlib functionality, as implemented in the official zlib source
-    code.  But you can make your own private DLL build, under a
-    different file name, as suggested in the previous answer.
-
-
-17. I made my own ZLIB1.DLL build.  Can I test it for compliance?
-
-  - We prefer that you download the official DLL from the zlib
-    web site.  If you need something peculiar from this DLL, you
-    can send your suggestion to the zlib mailing list.
-
-    However, in case you do rebuild the DLL yourself, you can run
-    it with the test programs found in the DLL distribution.
-    Running these test programs is not a guarantee of compliance,
-    but a failure can imply a detected problem.
-
-**
-
-This document is written and maintained by
-Cosmin Truta <cosmint@cs.ubbcluj.ro>
diff -Nbaur gcc-4.8.1/zlib/win32/Makefile.bor gcc-4.8.1-ppc/zlib/win32/Makefile.bor
--- gcc-4.8.1/zlib/win32/Makefile.bor	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/win32/Makefile.bor	1970-01-01 01:00:00.000000000 +0100
@@ -1,110 +0,0 @@
-# Makefile for zlib
-# Borland C++ for Win32
-#
-# Usage:
-#  make -f win32/Makefile.bor
-#  make -f win32/Makefile.bor LOCAL_ZLIB=-DASMV OBJA=match.obj OBJPA=+match.obj
-
-# ------------ Borland C++ ------------
-
-# Optional nonstandard preprocessor flags (e.g. -DMAX_MEM_LEVEL=7)
-# should be added to the environment via "set LOCAL_ZLIB=-DFOO" or
-# added to the declaration of LOC here:
-LOC = $(LOCAL_ZLIB)
-
-CC = bcc32
-AS = bcc32
-LD = bcc32
-AR = tlib
-CFLAGS  = -a -d -k- -O2 $(LOC)
-ASFLAGS = $(LOC)
-LDFLAGS = $(LOC)
-
-
-# variables
-ZLIB_LIB = zlib.lib
-
-OBJ1 = adler32.obj compress.obj crc32.obj deflate.obj gzclose.obj gzlib.obj gzread.obj
-OBJ2 = gzwrite.obj infback.obj inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj
-#OBJA =
-OBJP1 = +adler32.obj+compress.obj+crc32.obj+deflate.obj+gzclose.obj+gzlib.obj+gzread.obj
-OBJP2 = +gzwrite.obj+infback.obj+inffast.obj+inflate.obj+inftrees.obj+trees.obj+uncompr.obj+zutil.obj
-#OBJPA=
-
-
-# targets
-all: $(ZLIB_LIB) example.exe minigzip.exe
-
-.c.obj:
-	$(CC) -c $(CFLAGS) $<
-
-.asm.obj:
-	$(AS) -c $(ASFLAGS) $<
-
-adler32.obj: adler32.c zlib.h zconf.h
-
-compress.obj: compress.c zlib.h zconf.h
-
-crc32.obj: crc32.c zlib.h zconf.h crc32.h
-
-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h
-
-gzclose.obj: gzclose.c zlib.h zconf.h gzguts.h
-
-gzlib.obj: gzlib.c zlib.h zconf.h gzguts.h
-
-gzread.obj: gzread.c zlib.h zconf.h gzguts.h
-
-gzwrite.obj: gzwrite.c zlib.h zconf.h gzguts.h
-
-infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h
-
-inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h
-
-trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h
-
-uncompr.obj: uncompr.c zlib.h zconf.h
-
-zutil.obj: zutil.c zutil.h zlib.h zconf.h
-
-example.obj: test/example.c zlib.h zconf.h
-
-minigzip.obj: test/minigzip.c zlib.h zconf.h
-
-
-# For the sake of the old Borland make,
-# the command line is cut to fit in the MS-DOS 128 byte limit:
-$(ZLIB_LIB): $(OBJ1) $(OBJ2) $(OBJA)
-	-del $(ZLIB_LIB)
-	$(AR) $(ZLIB_LIB) $(OBJP1)
-	$(AR) $(ZLIB_LIB) $(OBJP2)
-	$(AR) $(ZLIB_LIB) $(OBJPA)
-
-
-# testing
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d
-
-example.exe: example.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) example.obj $(ZLIB_LIB)
-
-minigzip.exe: minigzip.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) minigzip.obj $(ZLIB_LIB)
-
-
-# cleanup
-clean:
-	-del $(ZLIB_LIB)
-	-del *.obj
-	-del *.exe
-	-del *.tds
-	-del zlib.bak
-	-del foo.gz
diff -Nbaur gcc-4.8.1/zlib/win32/Makefile.gcc gcc-4.8.1-ppc/zlib/win32/Makefile.gcc
--- gcc-4.8.1/zlib/win32/Makefile.gcc	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/win32/Makefile.gcc	1970-01-01 01:00:00.000000000 +0100
@@ -1,182 +0,0 @@
-# Makefile for zlib, derived from Makefile.dj2.
-# Modified for mingw32 by C. Spieler, 6/16/98.
-# Updated for zlib 1.2.x by Christian Spieler and Cosmin Truta, Mar-2003.
-# Last updated: Mar 2012.
-# Tested under Cygwin and MinGW.
-
-# Copyright (C) 1995-2003 Jean-loup Gailly.
-# For conditions of distribution and use, see copyright notice in zlib.h
-
-# To compile, or to compile and test, type from the top level zlib directory:
-#
-#   make -fwin32/Makefile.gcc;  make test testdll -fwin32/Makefile.gcc
-#
-# To use the asm code, type:
-#   cp contrib/asm?86/match.S ./match.S
-#   make LOC=-DASMV OBJA=match.o -fwin32/Makefile.gcc
-#
-# To install libz.a, zconf.h and zlib.h in the system directories, type:
-#
-#   make install -fwin32/Makefile.gcc
-#
-# BINARY_PATH, INCLUDE_PATH and LIBRARY_PATH must be set.
-#
-# To install the shared lib, append SHARED_MODE=1 to the make command :
-#
-#   make install -fwin32/Makefile.gcc SHARED_MODE=1
-
-# Note:
-# If the platform is *not* MinGW (e.g. it is Cygwin or UWIN),
-# the DLL name should be changed from "zlib1.dll".
-
-STATICLIB = libz.a
-SHAREDLIB = zlib1.dll
-IMPLIB    = libz.dll.a
-
-#
-# Set to 1 if shared object needs to be installed
-#
-SHARED_MODE=0
-
-#LOC = -DASMV
-#LOC = -DDEBUG -g
-
-PREFIX =
-CC = $(PREFIX)gcc
-CFLAGS = $(LOC) -O3 -Wall
-
-AS = $(CC)
-ASFLAGS = $(LOC) -Wall
-
-LD = $(CC)
-LDFLAGS = $(LOC)
-
-AR = $(PREFIX)ar
-ARFLAGS = rcs
-
-RC = $(PREFIX)windres
-RCFLAGS = --define GCC_WINDRES
-
-STRIP = $(PREFIX)strip
-
-CP = cp -fp
-# If GNU install is available, replace $(CP) with install.
-INSTALL = $(CP)
-RM = rm -f
-
-prefix ?= /usr/local
-exec_prefix = $(prefix)
-
-OBJS = adler32.o compress.o crc32.o deflate.o gzclose.o gzlib.o gzread.o \
-       gzwrite.o infback.o inffast.o inflate.o inftrees.o trees.o uncompr.o zutil.o
-OBJA =
-
-all: $(STATICLIB) $(SHAREDLIB) $(IMPLIB) example.exe minigzip.exe example_d.exe minigzip_d.exe
-
-test: example.exe minigzip.exe
-	./example
-	echo hello world | ./minigzip | ./minigzip -d
-
-testdll: example_d.exe minigzip_d.exe
-	./example_d
-	echo hello world | ./minigzip_d | ./minigzip_d -d
-
-.c.o:
-	$(CC) $(CFLAGS) -c -o $@ $<
-
-.S.o:
-	$(AS) $(ASFLAGS) -c -o $@ $<
-
-$(STATICLIB): $(OBJS) $(OBJA)
-	$(AR) $(ARFLAGS) $@ $(OBJS) $(OBJA)
-
-$(IMPLIB): $(SHAREDLIB)
-
-$(SHAREDLIB): win32/zlib.def $(OBJS) $(OBJA) zlibrc.o
-	$(CC) -shared -Wl,--out-implib,$(IMPLIB) $(LDFLAGS) \
-	-o $@ win32/zlib.def $(OBJS) $(OBJA) zlibrc.o
-	$(STRIP) $@
-
-example.exe: example.o $(STATICLIB)
-	$(LD) $(LDFLAGS) -o $@ example.o $(STATICLIB)
-	$(STRIP) $@
-
-minigzip.exe: minigzip.o $(STATICLIB)
-	$(LD) $(LDFLAGS) -o $@ minigzip.o $(STATICLIB)
-	$(STRIP) $@
-
-example_d.exe: example.o $(IMPLIB)
-	$(LD) $(LDFLAGS) -o $@ example.o $(IMPLIB)
-	$(STRIP) $@
-
-minigzip_d.exe: minigzip.o $(IMPLIB)
-	$(LD) $(LDFLAGS) -o $@ minigzip.o $(IMPLIB)
-	$(STRIP) $@
-
-example.o: test/example.c zlib.h zconf.h
-	$(CC) $(CFLAGS) -I. -c -o $@ test/example.c
-
-minigzip.o: test/minigzip.c zlib.h zconf.h
-	$(CC) $(CFLAGS) -I. -c -o $@ test/minigzip.c
-
-zlibrc.o: win32/zlib1.rc
-	$(RC) $(RCFLAGS) -o $@ win32/zlib1.rc
-
-.PHONY: install uninstall clean
-
-install: zlib.h zconf.h $(STATICLIB) $(IMPLIB)
-	@if test -z "$(DESTDIR)$(INCLUDE_PATH)" -o -z "$(DESTDIR)$(LIBRARY_PATH)" -o -z "$(DESTDIR)$(BINARY_PATH)"; then \
-		echo INCLUDE_PATH, LIBRARY_PATH, and BINARY_PATH must be specified; \
-		exit 1; \
-	fi
-	-@mkdir -p '$(DESTDIR)$(INCLUDE_PATH)'
-	-@mkdir -p '$(DESTDIR)$(LIBRARY_PATH)' '$(DESTDIR)$(LIBRARY_PATH)'/pkgconfig
-	-if [ "$(SHARED_MODE)" = "1" ]; then \
-		mkdir -p '$(DESTDIR)$(BINARY_PATH)'; \
-		$(INSTALL) $(SHAREDLIB) '$(DESTDIR)$(BINARY_PATH)'; \
-		$(INSTALL) $(IMPLIB) '$(DESTDIR)$(LIBRARY_PATH)'; \
-	fi
-	-$(INSTALL) zlib.h '$(DESTDIR)$(INCLUDE_PATH)'
-	-$(INSTALL) zconf.h '$(DESTDIR)$(INCLUDE_PATH)'
-	-$(INSTALL) $(STATICLIB) '$(DESTDIR)$(LIBRARY_PATH)'
-	sed \
-		-e 's|@prefix@|${prefix}|g' \
-		-e 's|@exec_prefix@|${exec_prefix}|g' \
-		-e 's|@libdir@|$(LIBRARY_PATH)|g' \
-		-e 's|@sharedlibdir@|$(LIBRARY_PATH)|g' \
-		-e 's|@includedir@|$(INCLUDE_PATH)|g' \
-		-e 's|@VERSION@|'`sed -n -e '/VERSION "/s/.*"\(.*\)".*/\1/p' zlib.h`'|g' \
-		zlib.pc.in > '$(DESTDIR)$(LIBRARY_PATH)'/pkgconfig/zlib.pc
-
-uninstall:
-	-if [ "$(SHARED_MODE)" = "1" ]; then \
-		$(RM) '$(DESTDIR)$(BINARY_PATH)'/$(SHAREDLIB); \
-		$(RM) '$(DESTDIR)$(LIBRARY_PATH)'/$(IMPLIB); \
-	fi
-	-$(RM) '$(DESTDIR)$(INCLUDE_PATH)'/zlib.h
-	-$(RM) '$(DESTDIR)$(INCLUDE_PATH)'/zconf.h
-	-$(RM) '$(DESTDIR)$(LIBRARY_PATH)'/$(STATICLIB)
-
-clean:
-	-$(RM) $(STATICLIB)
-	-$(RM) $(SHAREDLIB)
-	-$(RM) $(IMPLIB)
-	-$(RM) *.o
-	-$(RM) *.exe
-	-$(RM) foo.gz
-
-adler32.o: zlib.h zconf.h
-compress.o: zlib.h zconf.h
-crc32.o: crc32.h zlib.h zconf.h
-deflate.o: deflate.h zutil.h zlib.h zconf.h
-gzclose.o: zlib.h zconf.h gzguts.h
-gzlib.o: zlib.h zconf.h gzguts.h
-gzread.o: zlib.h zconf.h gzguts.h
-gzwrite.o: zlib.h zconf.h gzguts.h
-inffast.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-inflate.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-infback.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-inftrees.o: zutil.h zlib.h zconf.h inftrees.h
-trees.o: deflate.h zutil.h zlib.h zconf.h trees.h
-uncompr.o: zlib.h zconf.h
-zutil.o: zutil.h zlib.h zconf.h
diff -Nbaur gcc-4.8.1/zlib/win32/Makefile.msc gcc-4.8.1-ppc/zlib/win32/Makefile.msc
--- gcc-4.8.1/zlib/win32/Makefile.msc	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/win32/Makefile.msc	1970-01-01 01:00:00.000000000 +0100
@@ -1,160 +0,0 @@
-# Makefile for zlib using Microsoft (Visual) C
-# zlib is copyright (C) 1995-2006 Jean-loup Gailly and Mark Adler
-#
-# Usage:
-#   nmake -f win32/Makefile.msc                          (standard build)
-#   nmake -f win32/Makefile.msc LOC=-DFOO                (nonstandard build)
-#   nmake -f win32/Makefile.msc LOC="-DASMV -DASMINF" \
-#         OBJA="inffas32.obj match686.obj"               (use ASM code, x86)
-#   nmake -f win32/Makefile.msc AS=ml64 LOC="-DASMV -DASMINF -I." \
-#         OBJA="inffasx64.obj gvmat64.obj inffas8664.obj"  (use ASM code, x64)
-
-# optional build flags
-LOC =
-
-# variables
-STATICLIB = zlib.lib
-SHAREDLIB = zlib1.dll
-IMPLIB    = zdll.lib
-
-CC = cl
-AS = ml
-LD = link
-AR = lib
-RC = rc
-CFLAGS  = -nologo -MD -W3 -O2 -Oy- -Zi -Fd"zlib" $(LOC)
-WFLAGS  = -D_CRT_SECURE_NO_DEPRECATE -D_CRT_NONSTDC_NO_DEPRECATE
-ASFLAGS = -coff -Zi $(LOC)
-LDFLAGS = -nologo -debug -incremental:no -opt:ref
-ARFLAGS = -nologo
-RCFLAGS = /dWIN32 /r
-
-OBJS = adler32.obj compress.obj crc32.obj deflate.obj gzclose.obj gzlib.obj gzread.obj \
-       gzwrite.obj infback.obj inflate.obj inftrees.obj inffast.obj trees.obj uncompr.obj zutil.obj
-OBJA =
-
-
-# targets
-all: $(STATICLIB) $(SHAREDLIB) $(IMPLIB) \
-     example.exe minigzip.exe example_d.exe minigzip_d.exe
-
-$(STATICLIB): $(OBJS) $(OBJA)
-	$(AR) $(ARFLAGS) -out:$@ $(OBJS) $(OBJA)
-
-$(IMPLIB): $(SHAREDLIB)
-
-$(SHAREDLIB): win32/zlib.def $(OBJS) $(OBJA) zlib1.res
-	$(LD) $(LDFLAGS) -def:win32/zlib.def -dll -implib:$(IMPLIB) \
-	  -out:$@ -base:0x5A4C0000 $(OBJS) $(OBJA) zlib1.res
-	if exist $@.manifest \
-	  mt -nologo -manifest $@.manifest -outputresource:$@;2
-
-example.exe: example.obj $(STATICLIB)
-	$(LD) $(LDFLAGS) example.obj $(STATICLIB)
-	if exist $@.manifest \
-	  mt -nologo -manifest $@.manifest -outputresource:$@;1
-
-minigzip.exe: minigzip.obj $(STATICLIB)
-	$(LD) $(LDFLAGS) minigzip.obj $(STATICLIB)
-	if exist $@.manifest \
-	  mt -nologo -manifest $@.manifest -outputresource:$@;1
-
-example_d.exe: example.obj $(IMPLIB)
-	$(LD) $(LDFLAGS) -out:$@ example.obj $(IMPLIB)
-	if exist $@.manifest \
-	  mt -nologo -manifest $@.manifest -outputresource:$@;1
-
-minigzip_d.exe: minigzip.obj $(IMPLIB)
-	$(LD) $(LDFLAGS) -out:$@ minigzip.obj $(IMPLIB)
-	if exist $@.manifest \
-	  mt -nologo -manifest $@.manifest -outputresource:$@;1
-
-.c.obj:
-	$(CC) -c $(WFLAGS) $(CFLAGS) $<
-
-{test}.c.obj:
-	$(CC) -c -I. $(WFLAGS) $(CFLAGS) $<
-
-{contrib/masmx64}.c.obj:
-	$(CC) -c $(WFLAGS) $(CFLAGS) $<
-
-{contrib/masmx64}.asm.obj:
-	$(AS) -c $(ASFLAGS) $<
-
-{contrib/masmx86}.asm.obj:
-	$(AS) -c $(ASFLAGS) $<
-
-adler32.obj: adler32.c zlib.h zconf.h
-
-compress.obj: compress.c zlib.h zconf.h
-
-crc32.obj: crc32.c zlib.h zconf.h crc32.h
-
-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h
-
-gzclose.obj: gzclose.c zlib.h zconf.h gzguts.h
-
-gzlib.obj: gzlib.c zlib.h zconf.h gzguts.h
-
-gzread.obj: gzread.c zlib.h zconf.h gzguts.h
-
-gzwrite.obj: gzwrite.c zlib.h zconf.h gzguts.h
-
-infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
-             inffast.h inffixed.h
-
-inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
-             inffast.h
-
-inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
-             inffast.h inffixed.h
-
-inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h
-
-trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h
-
-uncompr.obj: uncompr.c zlib.h zconf.h
-
-zutil.obj: zutil.c zutil.h zlib.h zconf.h
-
-gvmat64.obj: contrib\masmx64\gvmat64.asm
-
-inffasx64.obj: contrib\masmx64\inffasx64.asm
-
-inffas8664.obj: contrib\masmx64\inffas8664.c zutil.h zlib.h zconf.h \
-		inftrees.h inflate.h inffast.h
-
-inffas32.obj: contrib\masmx86\inffas32.asm
-
-match686.obj: contrib\masmx86\match686.asm
-
-example.obj: test/example.c zlib.h zconf.h
-
-minigzip.obj: test/minigzip.c zlib.h zconf.h
-
-zlib1.res: win32/zlib1.rc
-	$(RC) $(RCFLAGS) /fo$@ win32/zlib1.rc
-
-
-# testing
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d
-
-testdll: example_d.exe minigzip_d.exe
-	example_d
-	echo hello world | minigzip_d | minigzip_d -d
-
-
-# cleanup
-clean:
-	-del $(STATICLIB)
-	-del $(SHAREDLIB)
-	-del $(IMPLIB)
-	-del *.obj
-	-del *.res
-	-del *.exp
-	-del *.exe
-	-del *.pdb
-	-del *.manifest
-	-del foo.gz
diff -Nbaur gcc-4.8.1/zlib/win32/README-WIN32.txt gcc-4.8.1-ppc/zlib/win32/README-WIN32.txt
--- gcc-4.8.1/zlib/win32/README-WIN32.txt	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/win32/README-WIN32.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,103 +0,0 @@
-ZLIB DATA COMPRESSION LIBRARY
-
-zlib 1.2.7 is a general purpose data compression library.  All the code is
-thread safe.  The data format used by the zlib library is described by RFCs
-(Request for Comments) 1950 to 1952 in the files
-http://www.ietf.org/rfc/rfc1950.txt (zlib format), rfc1951.txt (deflate format)
-and rfc1952.txt (gzip format).
-
-All functions of the compression library are documented in the file zlib.h
-(volunteer to write man pages welcome, contact zlib@gzip.org).  Two compiled
-examples are distributed in this package, example and minigzip.  The example_d
-and minigzip_d flavors validate that the zlib1.dll file is working correctly.
-
-Questions about zlib should be sent to <zlib@gzip.org>.  The zlib home page
-is http://zlib.net/ .  Before reporting a problem, please check this site to
-verify that you have the latest version of zlib; otherwise get the latest
-version and check whether the problem still exists or not.
-
-PLEASE read DLL_FAQ.txt, and the the zlib FAQ http://zlib.net/zlib_faq.html
-before asking for help.
-
-
-Manifest:
-
-The package zlib-1.2.7-win32-x86.zip will contain the following files:
-
-  README-WIN32.txt This document
-  ChangeLog        Changes since previous zlib packages
-  DLL_FAQ.txt      Frequently asked questions about zlib1.dll
-  zlib.3.pdf       Documentation of this library in Adobe Acrobat format
-
-  example.exe      A statically-bound example (using zlib.lib, not the dll)
-  example.pdb      Symbolic information for debugging example.exe
-
-  example_d.exe    A zlib1.dll bound example (using zdll.lib)
-  example_d.pdb    Symbolic information for debugging example_d.exe
-
-  minigzip.exe     A statically-bound test program (using zlib.lib, not the dll)
-  minigzip.pdb     Symbolic information for debugging minigzip.exe
-
-  minigzip_d.exe   A zlib1.dll bound test program (using zdll.lib)
-  minigzip_d.pdb   Symbolic information for debugging minigzip_d.exe
-
-  zlib.h           Install these files into the compilers' INCLUDE path to
-  zconf.h          compile programs which use zlib.lib or zdll.lib
-
-  zdll.lib         Install these files into the compilers' LIB path if linking
-  zdll.exp         a compiled program to the zlib1.dll binary
-
-  zlib.lib         Install these files into the compilers' LIB path to link zlib
-  zlib.pdb         into compiled programs, without zlib1.dll runtime dependency
-                   (zlib.pdb provides debugging info to the compile time linker)
-
-  zlib1.dll        Install this binary shared library into the system PATH, or
-                   the program's runtime directory (where the .exe resides)
-  zlib1.pdb        Install in the same directory as zlib1.dll, in order to debug
-                   an application crash using WinDbg or similar tools.
-
-All .pdb files above are entirely optional, but are very useful to a developer
-attempting to diagnose program misbehavior or a crash.  Many additional
-important files for developers can be found in the zlib127.zip source package
-available from http://zlib.net/ - review that package's README file for details.
-
-
-Acknowledgments:
-
-The deflate format used by zlib was defined by Phil Katz.  The deflate and
-zlib specifications were written by L.  Peter Deutsch.  Thanks to all the
-people who reported problems and suggested various improvements in zlib; they
-are too numerous to cite here.
-
-
-Copyright notice:
-
-  (C) 1995-2012 Jean-loup Gailly and Mark Adler
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Jean-loup Gailly        Mark Adler
-  jloup@gzip.org          madler@alumni.caltech.edu
-
-If you use the zlib library in a product, we would appreciate *not* receiving
-lengthy legal documents to sign.  The sources are provided for free but without
-warranty of any kind.  The library has been entirely written by Jean-loup
-Gailly and Mark Adler; it does not include third-party code.
-
-If you redistribute modified sources, we would appreciate that you include in
-the file ChangeLog history information documenting your changes.  Please read
-the FAQ for more information on the distribution of modified source versions.
diff -Nbaur gcc-4.8.1/zlib/win32/VisualC.txt gcc-4.8.1-ppc/zlib/win32/VisualC.txt
--- gcc-4.8.1/zlib/win32/VisualC.txt	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.8.1-ppc/zlib/win32/VisualC.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-
-To build zlib using the Microsoft Visual C++ environment,
-use the appropriate project from the projects/ directory.
diff -Nbaur gcc-4.8.1/zlib/win32/zlib1.rc gcc-4.8.1-ppc/zlib/win32/zlib1.rc
--- gcc-4.8.1/zlib/win32/zlib1.rc	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/win32/zlib1.rc	1970-01-01 01:00:00.000000000 +0100
@@ -1,40 +0,0 @@
-#include <winver.h>
-#include "../zlib.h"
-
-#ifdef GCC_WINDRES
-VS_VERSION_INFO		VERSIONINFO
-#else
-VS_VERSION_INFO		VERSIONINFO	MOVEABLE IMPURE LOADONCALL DISCARDABLE
-#endif
-  FILEVERSION		ZLIB_VER_MAJOR,ZLIB_VER_MINOR,ZLIB_VER_REVISION,0
-  PRODUCTVERSION	ZLIB_VER_MAJOR,ZLIB_VER_MINOR,ZLIB_VER_REVISION,0
-  FILEFLAGSMASK		VS_FFI_FILEFLAGSMASK
-#ifdef _DEBUG
-  FILEFLAGS		1
-#else
-  FILEFLAGS		0
-#endif
-  FILEOS		VOS__WINDOWS32
-  FILETYPE		VFT_DLL
-  FILESUBTYPE		0	// not used
-BEGIN
-  BLOCK "StringFileInfo"
-  BEGIN
-    BLOCK "040904E4"
-    //language ID = U.S. English, char set = Windows, Multilingual
-    BEGIN
-      VALUE "FileDescription",	"zlib data compression library\0"
-      VALUE "FileVersion",	ZLIB_VERSION "\0"
-      VALUE "InternalName",	"zlib1.dll\0"
-      VALUE "LegalCopyright",	"(C) 1995-2006 Jean-loup Gailly & Mark Adler\0"
-      VALUE "OriginalFilename",	"zlib1.dll\0"
-      VALUE "ProductName",	"zlib\0"
-      VALUE "ProductVersion",	ZLIB_VERSION "\0"
-      VALUE "Comments",		"For more information visit http://www.zlib.net/\0"
-    END
-  END
-  BLOCK "VarFileInfo"
-  BEGIN
-    VALUE "Translation", 0x0409, 1252
-  END
-END
diff -Nbaur gcc-4.8.1/zlib/win32/zlib.def gcc-4.8.1-ppc/zlib/win32/zlib.def
--- gcc-4.8.1/zlib/win32/zlib.def	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/win32/zlib.def	1970-01-01 01:00:00.000000000 +0100
@@ -1,84 +0,0 @@
-; zlib data compression library
-EXPORTS
-; basic functions
-    zlibVersion
-    deflate
-    deflateEnd
-    inflate
-    inflateEnd
-; advanced functions
-    deflateSetDictionary
-    deflateCopy
-    deflateReset
-    deflateParams
-    deflateTune
-    deflateBound
-    deflatePending
-    deflatePrime
-    deflateSetHeader
-    inflateSetDictionary
-    inflateSync
-    inflateCopy
-    inflateReset
-    inflateReset2
-    inflatePrime
-    inflateMark
-    inflateGetHeader
-    inflateBack
-    inflateBackEnd
-    zlibCompileFlags
-; utility functions
-    compress
-    compress2
-    compressBound
-    uncompress
-    gzopen
-    gzdopen
-    gzbuffer
-    gzsetparams
-    gzread
-    gzwrite
-    gzprintf
-    gzputs
-    gzgets
-    gzputc
-    gzgetc
-    gzungetc
-    gzflush
-    gzseek
-    gzrewind
-    gztell
-    gzoffset
-    gzeof
-    gzdirect
-    gzclose
-    gzclose_r
-    gzclose_w
-    gzerror
-    gzclearerr
-; large file functions
-    gzopen64
-    gzseek64
-    gztell64
-    gzoffset64
-    adler32_combine64
-    crc32_combine64
-; checksum functions
-    adler32
-    crc32
-    adler32_combine
-    crc32_combine
-; various hacks, don't look :)
-    deflateInit_
-    deflateInit2_
-    inflateInit_
-    inflateInit2_
-    inflateBackInit_
-    gzgetc_
-    zError
-    inflateSyncPoint
-    get_crc_table
-    inflateUndermine
-    inflateResetKeep
-    deflateResetKeep
-    gzopen_w
diff -Nbaur gcc-4.8.1/zlib/zconf.h gcc-4.8.1-ppc/zlib/zconf.h
--- gcc-4.8.1/zlib/zconf.h	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/zconf.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,522 +0,0 @@
-/* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995-2012 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id: zconf.h,v 1.1.1.2 2002/03/11 21:53:27 tromey Exp $ */
-
-#ifndef ZCONF_H
-#define ZCONF_H
-
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- * Even better than compiling with -DZ_PREFIX would be to use configure to set
- * this permanently in zconf.h using "./configure --zprefix".
- */
-#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
-#  define Z_PREFIX_SET
-
-/* all linked symbols */
-#  define _dist_code            z__dist_code
-#  define _length_code          z__length_code
-#  define _tr_align             z__tr_align
-#  define _tr_flush_block       z__tr_flush_block
-#  define _tr_init              z__tr_init
-#  define _tr_stored_block      z__tr_stored_block
-#  define _tr_tally             z__tr_tally
-#  define adler32               z_adler32
-#  define adler32_combine       z_adler32_combine
-#  define adler32_combine64     z_adler32_combine64
-#  ifndef Z_SOLO
-#    define compress              z_compress
-#    define compress2             z_compress2
-#    define compressBound         z_compressBound
-#  endif
-#  define crc32                 z_crc32
-#  define crc32_combine         z_crc32_combine
-#  define crc32_combine64       z_crc32_combine64
-#  define deflate               z_deflate
-#  define deflateBound          z_deflateBound
-#  define deflateCopy           z_deflateCopy
-#  define deflateEnd            z_deflateEnd
-#  define deflateInit2_         z_deflateInit2_
-#  define deflateInit_          z_deflateInit_
-#  define deflateParams         z_deflateParams
-#  define deflatePending        z_deflatePending
-#  define deflatePrime          z_deflatePrime
-#  define deflateReset          z_deflateReset
-#  define deflateResetKeep      z_deflateResetKeep
-#  define deflateSetDictionary  z_deflateSetDictionary
-#  define deflateSetHeader      z_deflateSetHeader
-#  define deflateTune           z_deflateTune
-#  define deflate_copyright     z_deflate_copyright
-#  define get_crc_table         z_get_crc_table
-#  ifndef Z_SOLO
-#    define gz_error              z_gz_error
-#    define gz_intmax             z_gz_intmax
-#    define gz_strwinerror        z_gz_strwinerror
-#    define gzbuffer              z_gzbuffer
-#    define gzclearerr            z_gzclearerr
-#    define gzclose               z_gzclose
-#    define gzclose_r             z_gzclose_r
-#    define gzclose_w             z_gzclose_w
-#    define gzdirect              z_gzdirect
-#    define gzdopen               z_gzdopen
-#    define gzeof                 z_gzeof
-#    define gzerror               z_gzerror
-#    define gzflush               z_gzflush
-#    define gzgetc                z_gzgetc
-#    define gzgetc_               z_gzgetc_
-#    define gzgets                z_gzgets
-#    define gzoffset              z_gzoffset
-#    define gzoffset64            z_gzoffset64
-#    define gzopen                z_gzopen
-#    define gzopen64              z_gzopen64
-#    ifdef _WIN32
-#      define gzopen_w              z_gzopen_w
-#    endif
-#    define gzprintf              z_gzprintf
-#    define gzputc                z_gzputc
-#    define gzputs                z_gzputs
-#    define gzread                z_gzread
-#    define gzrewind              z_gzrewind
-#    define gzseek                z_gzseek
-#    define gzseek64              z_gzseek64
-#    define gzsetparams           z_gzsetparams
-#    define gztell                z_gztell
-#    define gztell64              z_gztell64
-#    define gzungetc              z_gzungetc
-#    define gzwrite               z_gzwrite
-#  endif
-#  define inflate               z_inflate
-#  define inflateBack           z_inflateBack
-#  define inflateBackEnd        z_inflateBackEnd
-#  define inflateBackInit_      z_inflateBackInit_
-#  define inflateCopy           z_inflateCopy
-#  define inflateEnd            z_inflateEnd
-#  define inflateGetHeader      z_inflateGetHeader
-#  define inflateInit2_         z_inflateInit2_
-#  define inflateInit_          z_inflateInit_
-#  define inflateMark           z_inflateMark
-#  define inflatePrime          z_inflatePrime
-#  define inflateReset          z_inflateReset
-#  define inflateReset2         z_inflateReset2
-#  define inflateSetDictionary  z_inflateSetDictionary
-#  define inflateSync           z_inflateSync
-#  define inflateSyncPoint      z_inflateSyncPoint
-#  define inflateUndermine      z_inflateUndermine
-#  define inflateResetKeep      z_inflateResetKeep
-#  define inflate_copyright     z_inflate_copyright
-#  define inflate_fast          z_inflate_fast
-#  define inflate_table         z_inflate_table
-#  ifndef Z_SOLO
-#    define uncompress            z_uncompress
-#  endif
-#  define zError                z_zError
-#  ifndef Z_SOLO
-#    define zcalloc               z_zcalloc
-#    define zcfree                z_zcfree
-#  endif
-#  define zlibCompileFlags      z_zlibCompileFlags
-#  define zlibVersion           z_zlibVersion
-
-/* all zlib typedefs in zlib.h and zconf.h */
-#  define Byte                  z_Byte
-#  define Bytef                 z_Bytef
-#  define alloc_func            z_alloc_func
-#  define charf                 z_charf
-#  define free_func             z_free_func
-#  ifndef Z_SOLO
-#    define gzFile                z_gzFile
-#  endif
-#  define gz_header             z_gz_header
-#  define gz_headerp            z_gz_headerp
-#  define in_func               z_in_func
-#  define intf                  z_intf
-#  define out_func              z_out_func
-#  define uInt                  z_uInt
-#  define uIntf                 z_uIntf
-#  define uLong                 z_uLong
-#  define uLongf                z_uLongf
-#  define voidp                 z_voidp
-#  define voidpc                z_voidpc
-#  define voidpf                z_voidpf
-
-/* all zlib structs in zlib.h and zconf.h */
-#  define gz_header_s           z_gz_header_s
-#  define internal_state        z_internal_state
-
-#endif
-
-#if defined(__MSDOS__) && !defined(MSDOS)
-#  define MSDOS
-#endif
-#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
-#  define OS2
-#endif
-#if defined(_WINDOWS) && !defined(WINDOWS)
-#  define WINDOWS
-#endif
-#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
-#  ifndef WIN32
-#    define WIN32
-#  endif
-#endif
-#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
-#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
-#    ifndef SYS16BIT
-#      define SYS16BIT
-#    endif
-#  endif
-#endif
-
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- */
-#ifdef SYS16BIT
-#  define MAXSEG_64K
-#endif
-#ifdef MSDOS
-#  define UNALIGNED_OK
-#endif
-
-#ifdef __STDC_VERSION__
-#  ifndef STDC
-#    define STDC
-#  endif
-#  if __STDC_VERSION__ >= 199901L
-#    ifndef STDC99
-#      define STDC99
-#    endif
-#  endif
-#endif
-#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
-#  define STDC
-#endif
-
-#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
-#  define STDC
-#endif
-
-#ifndef STDC
-#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
-#    define const       /* note: need a more gentle solution here */
-#  endif
-#endif
-
-#if defined(ZLIB_CONST) && !defined(z_const)
-#  define z_const const
-#else
-#  define z_const
-#endif
-
-/* Some Mac compilers merge all .h files incorrectly: */
-#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
-#  define NO_DUMMY_DECL
-#endif
-
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-
-/* The memory requirements for deflate are (in bytes):
-            (1 << (windowBits+2)) +  (1 << (memLevel+9))
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus a few kilobytes
- for small objects.
-*/
-
-                        /* Type declarations */
-
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-
-#ifndef Z_ARG /* function prototypes for stdarg */
-#  if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#    define Z_ARG(args)  args
-#  else
-#    define Z_ARG(args)  ()
-#  endif
-#endif
-
-/* The following definitions for FAR are needed only for MSDOS mixed
- * model programming (small or medium model with some far allocations).
- * This was tested only with MSC; for other MSDOS compilers you may have
- * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
- * just define FAR to be empty.
- */
-#ifdef SYS16BIT
-#  if defined(M_I86SM) || defined(M_I86MM)
-     /* MSC small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef _MSC_VER
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#  if (defined(__SMALL__) || defined(__MEDIUM__))
-     /* Turbo C small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef __BORLANDC__
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#endif
-
-#if defined(WINDOWS) || defined(WIN32)
-   /* If building or using zlib as a DLL, define ZLIB_DLL.
-    * This is not mandatory, but it offers a little performance increase.
-    */
-#  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA WINAPIV
-#    else
-#      define ZEXPORTVA FAR CDECL
-#    endif
-#  endif
-#endif
-
-#if defined (__BEOS__)
-#  ifdef ZLIB_DLL
-#    ifdef ZLIB_INTERNAL
-#      define ZEXPORT   __declspec(dllexport)
-#      define ZEXPORTVA __declspec(dllexport)
-#    else
-#      define ZEXPORT   __declspec(dllimport)
-#      define ZEXPORTVA __declspec(dllimport)
-#    endif
-#  endif
-#endif
-
-#ifndef ZEXTERN
-#  define ZEXTERN extern
-#endif
-#ifndef ZEXPORT
-#  define ZEXPORT
-#endif
-#ifndef ZEXPORTVA
-#  define ZEXPORTVA
-#endif
-
-#ifndef FAR
-#  define FAR
-#endif
-
-#if !defined(__MACTYPES__)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-
-#ifdef SMALL_MEDIUM
-   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
-#  define Bytef Byte FAR
-#else
-   typedef Byte  FAR Bytef;
-#endif
-typedef char  FAR charf;
-typedef int   FAR intf;
-typedef uInt  FAR uIntf;
-typedef uLong FAR uLongf;
-
-#ifdef STDC
-   typedef void const *voidpc;
-   typedef void FAR   *voidpf;
-   typedef void       *voidp;
-#else
-   typedef Byte const *voidpc;
-   typedef Byte FAR   *voidpf;
-   typedef Byte       *voidp;
-#endif
-
-/* ./configure may #define Z_U4 here */
-
-#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)
-#  include <limits.h>
-#  if (UINT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned
-#  else
-#    if (ULONG_MAX == 0xffffffffUL)
-#      define Z_U4 unsigned long
-#    else
-#      if (USHRT_MAX == 0xffffffffUL)
-#        define Z_U4 unsigned short
-#      endif
-#    endif
-#  endif
-#endif
-
-#ifdef Z_U4
-   typedef Z_U4 z_crc_t;
-#else
-   typedef unsigned long z_crc_t;
-#endif
-
-#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_UNISTD_H
-#endif
-
-#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_STDARG_H
-#endif
-
-#ifdef STDC
-#  ifndef Z_SOLO
-#    include <sys/types.h>      /* for off_t */
-#  endif
-#endif
-
-#ifdef _WIN32
-#  include <stddef.h>           /* for wchar_t */
-#endif
-
-/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
- * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
- * though the former does not conform to the LFS document), but considering
- * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
- * equivalently requesting no 64-bit operations
- */
-#if defined(LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
-#  undef _LARGEFILE64_SOURCE
-#endif
-
-#if defined(__WATCOMC__) && !defined(Z_HAVE_UNISTD_H)
-#  define Z_HAVE_UNISTD_H
-#endif
-#ifndef Z_SOLO
-#  if defined(Z_HAVE_UNISTD_H) || defined(LARGEFILE64_SOURCE)
-#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
-#    ifdef VMS
-#      include <unixio.h>       /* for off_t */
-#    endif
-#    ifndef z_off_t
-#      define z_off_t off_t
-#    endif
-#  endif
-#endif
-
-#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
-#  define Z_LFS64
-#endif
-
-#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
-#  define Z_LARGE64
-#endif
-
-#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
-#  define Z_WANT64
-#endif
-
-#if !defined(SEEK_SET) && !defined(Z_SOLO)
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-
-#ifndef z_off_t
-#  define z_off_t long
-#endif
-
-#if !defined(_WIN32) && defined(Z_LARGE64)
-#  define z_off64_t off64_t
-#else
-#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
-#    define z_off64_t __int64
-#  else
-#    define z_off64_t z_off_t
-#  endif
-#endif
-
-/* MVS linker does not support external names larger than 8 bytes */
-#if defined(__MVS__)
-  #pragma map(deflateInit_,"DEIN")
-  #pragma map(deflateInit2_,"DEIN2")
-  #pragma map(deflateEnd,"DEEND")
-  #pragma map(deflateBound,"DEBND")
-  #pragma map(inflateInit_,"ININ")
-  #pragma map(inflateInit2_,"ININ2")
-  #pragma map(inflateEnd,"INEND")
-  #pragma map(inflateSync,"INSY")
-  #pragma map(inflateSetDictionary,"INSEDI")
-  #pragma map(compressBound,"CMBND")
-  #pragma map(inflate_table,"INTABL")
-  #pragma map(inflate_fast,"INFA")
-  #pragma map(inflate_copyright,"INCOPY")
-#endif
-
-/* Solaris 2.5.1 doesn't have vsnprintf */
-#if defined(__sun) && defined(__svr4__)
-#include <sys/feature_tests.h>
-#if _XOPEN_VERSION < 3
-#define NO_vsnprintf
-#endif
-#endif
-
-/* Tru64 UNIX V4.0 neither */
-#if defined(__alpha) && defined(__osf__)
-#include <unistd.h>
-#if _XOPEN_VERSION < 500
-#define NO_vsnprintf
-#endif
-#endif
-
-#endif /* ZCONF_H */
diff -Nbaur gcc-4.8.1/zlib/zconf.h.cmakein gcc-4.8.1-ppc/zlib/zconf.h.cmakein
--- gcc-4.8.1/zlib/zconf.h.cmakein	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/zconf.h.cmakein	1970-01-01 01:00:00.000000000 +0100
@@ -1,508 +0,0 @@
-/* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995-2012 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#ifndef ZCONF_H
-#define ZCONF_H
-#cmakedefine Z_PREFIX
-#cmakedefine Z_HAVE_UNISTD_H
-
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- * Even better than compiling with -DZ_PREFIX would be to use configure to set
- * this permanently in zconf.h using "./configure --zprefix".
- */
-#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
-#  define Z_PREFIX_SET
-
-/* all linked symbols */
-#  define _dist_code            z__dist_code
-#  define _length_code          z__length_code
-#  define _tr_align             z__tr_align
-#  define _tr_flush_block       z__tr_flush_block
-#  define _tr_init              z__tr_init
-#  define _tr_stored_block      z__tr_stored_block
-#  define _tr_tally             z__tr_tally
-#  define adler32               z_adler32
-#  define adler32_combine       z_adler32_combine
-#  define adler32_combine64     z_adler32_combine64
-#  ifndef Z_SOLO
-#    define compress              z_compress
-#    define compress2             z_compress2
-#    define compressBound         z_compressBound
-#  endif
-#  define crc32                 z_crc32
-#  define crc32_combine         z_crc32_combine
-#  define crc32_combine64       z_crc32_combine64
-#  define deflate               z_deflate
-#  define deflateBound          z_deflateBound
-#  define deflateCopy           z_deflateCopy
-#  define deflateEnd            z_deflateEnd
-#  define deflateInit2_         z_deflateInit2_
-#  define deflateInit_          z_deflateInit_
-#  define deflateParams         z_deflateParams
-#  define deflatePending        z_deflatePending
-#  define deflatePrime          z_deflatePrime
-#  define deflateReset          z_deflateReset
-#  define deflateResetKeep      z_deflateResetKeep
-#  define deflateSetDictionary  z_deflateSetDictionary
-#  define deflateSetHeader      z_deflateSetHeader
-#  define deflateTune           z_deflateTune
-#  define deflate_copyright     z_deflate_copyright
-#  define get_crc_table         z_get_crc_table
-#  ifndef Z_SOLO
-#    define gz_error              z_gz_error
-#    define gz_intmax             z_gz_intmax
-#    define gz_strwinerror        z_gz_strwinerror
-#    define gzbuffer              z_gzbuffer
-#    define gzclearerr            z_gzclearerr
-#    define gzclose               z_gzclose
-#    define gzclose_r             z_gzclose_r
-#    define gzclose_w             z_gzclose_w
-#    define gzdirect              z_gzdirect
-#    define gzdopen               z_gzdopen
-#    define gzeof                 z_gzeof
-#    define gzerror               z_gzerror
-#    define gzflush               z_gzflush
-#    define gzgetc                z_gzgetc
-#    define gzgetc_               z_gzgetc_
-#    define gzgets                z_gzgets
-#    define gzoffset              z_gzoffset
-#    define gzoffset64            z_gzoffset64
-#    define gzopen                z_gzopen
-#    define gzopen64              z_gzopen64
-#    ifdef _WIN32
-#      define gzopen_w              z_gzopen_w
-#    endif
-#    define gzprintf              z_gzprintf
-#    define gzputc                z_gzputc
-#    define gzputs                z_gzputs
-#    define gzread                z_gzread
-#    define gzrewind              z_gzrewind
-#    define gzseek                z_gzseek
-#    define gzseek64              z_gzseek64
-#    define gzsetparams           z_gzsetparams
-#    define gztell                z_gztell
-#    define gztell64              z_gztell64
-#    define gzungetc              z_gzungetc
-#    define gzwrite               z_gzwrite
-#  endif
-#  define inflate               z_inflate
-#  define inflateBack           z_inflateBack
-#  define inflateBackEnd        z_inflateBackEnd
-#  define inflateBackInit_      z_inflateBackInit_
-#  define inflateCopy           z_inflateCopy
-#  define inflateEnd            z_inflateEnd
-#  define inflateGetHeader      z_inflateGetHeader
-#  define inflateInit2_         z_inflateInit2_
-#  define inflateInit_          z_inflateInit_
-#  define inflateMark           z_inflateMark
-#  define inflatePrime          z_inflatePrime
-#  define inflateReset          z_inflateReset
-#  define inflateReset2         z_inflateReset2
-#  define inflateSetDictionary  z_inflateSetDictionary
-#  define inflateSync           z_inflateSync
-#  define inflateSyncPoint      z_inflateSyncPoint
-#  define inflateUndermine      z_inflateUndermine
-#  define inflateResetKeep      z_inflateResetKeep
-#  define inflate_copyright     z_inflate_copyright
-#  define inflate_fast          z_inflate_fast
-#  define inflate_table         z_inflate_table
-#  ifndef Z_SOLO
-#    define uncompress            z_uncompress
-#  endif
-#  define zError                z_zError
-#  ifndef Z_SOLO
-#    define zcalloc               z_zcalloc
-#    define zcfree                z_zcfree
-#  endif
-#  define zlibCompileFlags      z_zlibCompileFlags
-#  define zlibVersion           z_zlibVersion
-
-/* all zlib typedefs in zlib.h and zconf.h */
-#  define Byte                  z_Byte
-#  define Bytef                 z_Bytef
-#  define alloc_func            z_alloc_func
-#  define charf                 z_charf
-#  define free_func             z_free_func
-#  ifndef Z_SOLO
-#    define gzFile                z_gzFile
-#  endif
-#  define gz_header             z_gz_header
-#  define gz_headerp            z_gz_headerp
-#  define in_func               z_in_func
-#  define intf                  z_intf
-#  define out_func              z_out_func
-#  define uInt                  z_uInt
-#  define uIntf                 z_uIntf
-#  define uLong                 z_uLong
-#  define uLongf                z_uLongf
-#  define voidp                 z_voidp
-#  define voidpc                z_voidpc
-#  define voidpf                z_voidpf
-
-/* all zlib structs in zlib.h and zconf.h */
-#  define gz_header_s           z_gz_header_s
-#  define internal_state        z_internal_state
-
-#endif
-
-#if defined(__MSDOS__) && !defined(MSDOS)
-#  define MSDOS
-#endif
-#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
-#  define OS2
-#endif
-#if defined(_WINDOWS) && !defined(WINDOWS)
-#  define WINDOWS
-#endif
-#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
-#  ifndef WIN32
-#    define WIN32
-#  endif
-#endif
-#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
-#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
-#    ifndef SYS16BIT
-#      define SYS16BIT
-#    endif
-#  endif
-#endif
-
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- */
-#ifdef SYS16BIT
-#  define MAXSEG_64K
-#endif
-#ifdef MSDOS
-#  define UNALIGNED_OK
-#endif
-
-#ifdef __STDC_VERSION__
-#  ifndef STDC
-#    define STDC
-#  endif
-#  if __STDC_VERSION__ >= 199901L
-#    ifndef STDC99
-#      define STDC99
-#    endif
-#  endif
-#endif
-#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
-#  define STDC
-#endif
-
-#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
-#  define STDC
-#endif
-
-#ifndef STDC
-#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
-#    define const       /* note: need a more gentle solution here */
-#  endif
-#endif
-
-#if defined(ZLIB_CONST) && !defined(z_const)
-#  define z_const const
-#else
-#  define z_const
-#endif
-
-/* Some Mac compilers merge all .h files incorrectly: */
-#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
-#  define NO_DUMMY_DECL
-#endif
-
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-
-/* The memory requirements for deflate are (in bytes):
-            (1 << (windowBits+2)) +  (1 << (memLevel+9))
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus a few kilobytes
- for small objects.
-*/
-
-                        /* Type declarations */
-
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-
-#ifndef Z_ARG /* function prototypes for stdarg */
-#  if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#    define Z_ARG(args)  args
-#  else
-#    define Z_ARG(args)  ()
-#  endif
-#endif
-
-/* The following definitions for FAR are needed only for MSDOS mixed
- * model programming (small or medium model with some far allocations).
- * This was tested only with MSC; for other MSDOS compilers you may have
- * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
- * just define FAR to be empty.
- */
-#ifdef SYS16BIT
-#  if defined(M_I86SM) || defined(M_I86MM)
-     /* MSC small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef _MSC_VER
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#  if (defined(__SMALL__) || defined(__MEDIUM__))
-     /* Turbo C small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef __BORLANDC__
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#endif
-
-#if defined(WINDOWS) || defined(WIN32)
-   /* If building or using zlib as a DLL, define ZLIB_DLL.
-    * This is not mandatory, but it offers a little performance increase.
-    */
-#  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA WINAPIV
-#    else
-#      define ZEXPORTVA FAR CDECL
-#    endif
-#  endif
-#endif
-
-#if defined (__BEOS__)
-#  ifdef ZLIB_DLL
-#    ifdef ZLIB_INTERNAL
-#      define ZEXPORT   __declspec(dllexport)
-#      define ZEXPORTVA __declspec(dllexport)
-#    else
-#      define ZEXPORT   __declspec(dllimport)
-#      define ZEXPORTVA __declspec(dllimport)
-#    endif
-#  endif
-#endif
-
-#ifndef ZEXTERN
-#  define ZEXTERN extern
-#endif
-#ifndef ZEXPORT
-#  define ZEXPORT
-#endif
-#ifndef ZEXPORTVA
-#  define ZEXPORTVA
-#endif
-
-#ifndef FAR
-#  define FAR
-#endif
-
-#if !defined(__MACTYPES__)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-
-#ifdef SMALL_MEDIUM
-   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
-#  define Bytef Byte FAR
-#else
-   typedef Byte  FAR Bytef;
-#endif
-typedef char  FAR charf;
-typedef int   FAR intf;
-typedef uInt  FAR uIntf;
-typedef uLong FAR uLongf;
-
-#ifdef STDC
-   typedef void const *voidpc;
-   typedef void FAR   *voidpf;
-   typedef void       *voidp;
-#else
-   typedef Byte const *voidpc;
-   typedef Byte FAR   *voidpf;
-   typedef Byte       *voidp;
-#endif
-
-/* ./configure may #define Z_U4 here */
-
-#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)
-#  include <limits.h>
-#  if (UINT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned
-#  else
-#    if (ULONG_MAX == 0xffffffffUL)
-#      define Z_U4 unsigned long
-#    else
-#      if (USHRT_MAX == 0xffffffffUL)
-#        define Z_U4 unsigned short
-#      endif
-#    endif
-#  endif
-#endif
-
-#ifdef Z_U4
-   typedef Z_U4 z_crc_t;
-#else
-   typedef unsigned long z_crc_t;
-#endif
-
-#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_UNISTD_H
-#endif
-
-#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_STDARG_H
-#endif
-
-#ifdef STDC
-#  ifndef Z_SOLO
-#    include <sys/types.h>      /* for off_t */
-#  endif
-#endif
-
-#ifdef _WIN32
-#  include <stddef.h>           /* for wchar_t */
-#endif
-
-/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
- * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
- * though the former does not conform to the LFS document), but considering
- * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
- * equivalently requesting no 64-bit operations
- */
-#if defined(LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
-#  undef _LARGEFILE64_SOURCE
-#endif
-
-#if defined(__WATCOMC__) && !defined(Z_HAVE_UNISTD_H)
-#  define Z_HAVE_UNISTD_H
-#endif
-#ifndef Z_SOLO
-#  if defined(Z_HAVE_UNISTD_H) || defined(LARGEFILE64_SOURCE)
-#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
-#    ifdef VMS
-#      include <unixio.h>       /* for off_t */
-#    endif
-#    ifndef z_off_t
-#      define z_off_t off_t
-#    endif
-#  endif
-#endif
-
-#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
-#  define Z_LFS64
-#endif
-
-#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
-#  define Z_LARGE64
-#endif
-
-#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
-#  define Z_WANT64
-#endif
-
-#if !defined(SEEK_SET) && !defined(Z_SOLO)
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-
-#ifndef z_off_t
-#  define z_off_t long
-#endif
-
-#if !defined(_WIN32) && defined(Z_LARGE64)
-#  define z_off64_t off64_t
-#else
-#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
-#    define z_off64_t __int64
-#  else
-#    define z_off64_t z_off_t
-#  endif
-#endif
-
-/* MVS linker does not support external names larger than 8 bytes */
-#if defined(__MVS__)
-  #pragma map(deflateInit_,"DEIN")
-  #pragma map(deflateInit2_,"DEIN2")
-  #pragma map(deflateEnd,"DEEND")
-  #pragma map(deflateBound,"DEBND")
-  #pragma map(inflateInit_,"ININ")
-  #pragma map(inflateInit2_,"ININ2")
-  #pragma map(inflateEnd,"INEND")
-  #pragma map(inflateSync,"INSY")
-  #pragma map(inflateSetDictionary,"INSEDI")
-  #pragma map(compressBound,"CMBND")
-  #pragma map(inflate_table,"INTABL")
-  #pragma map(inflate_fast,"INFA")
-  #pragma map(inflate_copyright,"INCOPY")
-#endif
-
-#endif /* ZCONF_H */
diff -Nbaur gcc-4.8.1/zlib/zconf.h.in gcc-4.8.1-ppc/zlib/zconf.h.in
--- gcc-4.8.1/zlib/zconf.h.in	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/zconf.h.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,506 +0,0 @@
-/* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995-2012 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#ifndef ZCONF_H
-#define ZCONF_H
-
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- * Even better than compiling with -DZ_PREFIX would be to use configure to set
- * this permanently in zconf.h using "./configure --zprefix".
- */
-#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
-#  define Z_PREFIX_SET
-
-/* all linked symbols */
-#  define _dist_code            z__dist_code
-#  define _length_code          z__length_code
-#  define _tr_align             z__tr_align
-#  define _tr_flush_block       z__tr_flush_block
-#  define _tr_init              z__tr_init
-#  define _tr_stored_block      z__tr_stored_block
-#  define _tr_tally             z__tr_tally
-#  define adler32               z_adler32
-#  define adler32_combine       z_adler32_combine
-#  define adler32_combine64     z_adler32_combine64
-#  ifndef Z_SOLO
-#    define compress              z_compress
-#    define compress2             z_compress2
-#    define compressBound         z_compressBound
-#  endif
-#  define crc32                 z_crc32
-#  define crc32_combine         z_crc32_combine
-#  define crc32_combine64       z_crc32_combine64
-#  define deflate               z_deflate
-#  define deflateBound          z_deflateBound
-#  define deflateCopy           z_deflateCopy
-#  define deflateEnd            z_deflateEnd
-#  define deflateInit2_         z_deflateInit2_
-#  define deflateInit_          z_deflateInit_
-#  define deflateParams         z_deflateParams
-#  define deflatePending        z_deflatePending
-#  define deflatePrime          z_deflatePrime
-#  define deflateReset          z_deflateReset
-#  define deflateResetKeep      z_deflateResetKeep
-#  define deflateSetDictionary  z_deflateSetDictionary
-#  define deflateSetHeader      z_deflateSetHeader
-#  define deflateTune           z_deflateTune
-#  define deflate_copyright     z_deflate_copyright
-#  define get_crc_table         z_get_crc_table
-#  ifndef Z_SOLO
-#    define gz_error              z_gz_error
-#    define gz_intmax             z_gz_intmax
-#    define gz_strwinerror        z_gz_strwinerror
-#    define gzbuffer              z_gzbuffer
-#    define gzclearerr            z_gzclearerr
-#    define gzclose               z_gzclose
-#    define gzclose_r             z_gzclose_r
-#    define gzclose_w             z_gzclose_w
-#    define gzdirect              z_gzdirect
-#    define gzdopen               z_gzdopen
-#    define gzeof                 z_gzeof
-#    define gzerror               z_gzerror
-#    define gzflush               z_gzflush
-#    define gzgetc                z_gzgetc
-#    define gzgetc_               z_gzgetc_
-#    define gzgets                z_gzgets
-#    define gzoffset              z_gzoffset
-#    define gzoffset64            z_gzoffset64
-#    define gzopen                z_gzopen
-#    define gzopen64              z_gzopen64
-#    ifdef _WIN32
-#      define gzopen_w              z_gzopen_w
-#    endif
-#    define gzprintf              z_gzprintf
-#    define gzputc                z_gzputc
-#    define gzputs                z_gzputs
-#    define gzread                z_gzread
-#    define gzrewind              z_gzrewind
-#    define gzseek                z_gzseek
-#    define gzseek64              z_gzseek64
-#    define gzsetparams           z_gzsetparams
-#    define gztell                z_gztell
-#    define gztell64              z_gztell64
-#    define gzungetc              z_gzungetc
-#    define gzwrite               z_gzwrite
-#  endif
-#  define inflate               z_inflate
-#  define inflateBack           z_inflateBack
-#  define inflateBackEnd        z_inflateBackEnd
-#  define inflateBackInit_      z_inflateBackInit_
-#  define inflateCopy           z_inflateCopy
-#  define inflateEnd            z_inflateEnd
-#  define inflateGetHeader      z_inflateGetHeader
-#  define inflateInit2_         z_inflateInit2_
-#  define inflateInit_          z_inflateInit_
-#  define inflateMark           z_inflateMark
-#  define inflatePrime          z_inflatePrime
-#  define inflateReset          z_inflateReset
-#  define inflateReset2         z_inflateReset2
-#  define inflateSetDictionary  z_inflateSetDictionary
-#  define inflateSync           z_inflateSync
-#  define inflateSyncPoint      z_inflateSyncPoint
-#  define inflateUndermine      z_inflateUndermine
-#  define inflateResetKeep      z_inflateResetKeep
-#  define inflate_copyright     z_inflate_copyright
-#  define inflate_fast          z_inflate_fast
-#  define inflate_table         z_inflate_table
-#  ifndef Z_SOLO
-#    define uncompress            z_uncompress
-#  endif
-#  define zError                z_zError
-#  ifndef Z_SOLO
-#    define zcalloc               z_zcalloc
-#    define zcfree                z_zcfree
-#  endif
-#  define zlibCompileFlags      z_zlibCompileFlags
-#  define zlibVersion           z_zlibVersion
-
-/* all zlib typedefs in zlib.h and zconf.h */
-#  define Byte                  z_Byte
-#  define Bytef                 z_Bytef
-#  define alloc_func            z_alloc_func
-#  define charf                 z_charf
-#  define free_func             z_free_func
-#  ifndef Z_SOLO
-#    define gzFile                z_gzFile
-#  endif
-#  define gz_header             z_gz_header
-#  define gz_headerp            z_gz_headerp
-#  define in_func               z_in_func
-#  define intf                  z_intf
-#  define out_func              z_out_func
-#  define uInt                  z_uInt
-#  define uIntf                 z_uIntf
-#  define uLong                 z_uLong
-#  define uLongf                z_uLongf
-#  define voidp                 z_voidp
-#  define voidpc                z_voidpc
-#  define voidpf                z_voidpf
-
-/* all zlib structs in zlib.h and zconf.h */
-#  define gz_header_s           z_gz_header_s
-#  define internal_state        z_internal_state
-
-#endif
-
-#if defined(__MSDOS__) && !defined(MSDOS)
-#  define MSDOS
-#endif
-#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
-#  define OS2
-#endif
-#if defined(_WINDOWS) && !defined(WINDOWS)
-#  define WINDOWS
-#endif
-#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
-#  ifndef WIN32
-#    define WIN32
-#  endif
-#endif
-#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
-#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
-#    ifndef SYS16BIT
-#      define SYS16BIT
-#    endif
-#  endif
-#endif
-
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- */
-#ifdef SYS16BIT
-#  define MAXSEG_64K
-#endif
-#ifdef MSDOS
-#  define UNALIGNED_OK
-#endif
-
-#ifdef __STDC_VERSION__
-#  ifndef STDC
-#    define STDC
-#  endif
-#  if __STDC_VERSION__ >= 199901L
-#    ifndef STDC99
-#      define STDC99
-#    endif
-#  endif
-#endif
-#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
-#  define STDC
-#endif
-
-#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
-#  define STDC
-#endif
-
-#ifndef STDC
-#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
-#    define const       /* note: need a more gentle solution here */
-#  endif
-#endif
-
-#if defined(ZLIB_CONST) && !defined(z_const)
-#  define z_const const
-#else
-#  define z_const
-#endif
-
-/* Some Mac compilers merge all .h files incorrectly: */
-#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
-#  define NO_DUMMY_DECL
-#endif
-
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-
-/* The memory requirements for deflate are (in bytes):
-            (1 << (windowBits+2)) +  (1 << (memLevel+9))
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus a few kilobytes
- for small objects.
-*/
-
-                        /* Type declarations */
-
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-
-#ifndef Z_ARG /* function prototypes for stdarg */
-#  if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#    define Z_ARG(args)  args
-#  else
-#    define Z_ARG(args)  ()
-#  endif
-#endif
-
-/* The following definitions for FAR are needed only for MSDOS mixed
- * model programming (small or medium model with some far allocations).
- * This was tested only with MSC; for other MSDOS compilers you may have
- * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
- * just define FAR to be empty.
- */
-#ifdef SYS16BIT
-#  if defined(M_I86SM) || defined(M_I86MM)
-     /* MSC small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef _MSC_VER
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#  if (defined(__SMALL__) || defined(__MEDIUM__))
-     /* Turbo C small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef __BORLANDC__
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#endif
-
-#if defined(WINDOWS) || defined(WIN32)
-   /* If building or using zlib as a DLL, define ZLIB_DLL.
-    * This is not mandatory, but it offers a little performance increase.
-    */
-#  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA WINAPIV
-#    else
-#      define ZEXPORTVA FAR CDECL
-#    endif
-#  endif
-#endif
-
-#if defined (__BEOS__)
-#  ifdef ZLIB_DLL
-#    ifdef ZLIB_INTERNAL
-#      define ZEXPORT   __declspec(dllexport)
-#      define ZEXPORTVA __declspec(dllexport)
-#    else
-#      define ZEXPORT   __declspec(dllimport)
-#      define ZEXPORTVA __declspec(dllimport)
-#    endif
-#  endif
-#endif
-
-#ifndef ZEXTERN
-#  define ZEXTERN extern
-#endif
-#ifndef ZEXPORT
-#  define ZEXPORT
-#endif
-#ifndef ZEXPORTVA
-#  define ZEXPORTVA
-#endif
-
-#ifndef FAR
-#  define FAR
-#endif
-
-#if !defined(__MACTYPES__)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-
-#ifdef SMALL_MEDIUM
-   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
-#  define Bytef Byte FAR
-#else
-   typedef Byte  FAR Bytef;
-#endif
-typedef char  FAR charf;
-typedef int   FAR intf;
-typedef uInt  FAR uIntf;
-typedef uLong FAR uLongf;
-
-#ifdef STDC
-   typedef void const *voidpc;
-   typedef void FAR   *voidpf;
-   typedef void       *voidp;
-#else
-   typedef Byte const *voidpc;
-   typedef Byte FAR   *voidpf;
-   typedef Byte       *voidp;
-#endif
-
-/* ./configure may #define Z_U4 here */
-
-#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)
-#  include <limits.h>
-#  if (UINT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned
-#  else
-#    if (ULONG_MAX == 0xffffffffUL)
-#      define Z_U4 unsigned long
-#    else
-#      if (USHRT_MAX == 0xffffffffUL)
-#        define Z_U4 unsigned short
-#      endif
-#    endif
-#  endif
-#endif
-
-#ifdef Z_U4
-   typedef Z_U4 z_crc_t;
-#else
-   typedef unsigned long z_crc_t;
-#endif
-
-#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_UNISTD_H
-#endif
-
-#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_STDARG_H
-#endif
-
-#ifdef STDC
-#  ifndef Z_SOLO
-#    include <sys/types.h>      /* for off_t */
-#  endif
-#endif
-
-#ifdef _WIN32
-#  include <stddef.h>           /* for wchar_t */
-#endif
-
-/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
- * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
- * though the former does not conform to the LFS document), but considering
- * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
- * equivalently requesting no 64-bit operations
- */
-#if defined(LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
-#  undef _LARGEFILE64_SOURCE
-#endif
-
-#if defined(__WATCOMC__) && !defined(Z_HAVE_UNISTD_H)
-#  define Z_HAVE_UNISTD_H
-#endif
-#ifndef Z_SOLO
-#  if defined(Z_HAVE_UNISTD_H) || defined(LARGEFILE64_SOURCE)
-#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
-#    ifdef VMS
-#      include <unixio.h>       /* for off_t */
-#    endif
-#    ifndef z_off_t
-#      define z_off_t off_t
-#    endif
-#  endif
-#endif
-
-#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
-#  define Z_LFS64
-#endif
-
-#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
-#  define Z_LARGE64
-#endif
-
-#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
-#  define Z_WANT64
-#endif
-
-#if !defined(SEEK_SET) && !defined(Z_SOLO)
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-
-#ifndef z_off_t
-#  define z_off_t long
-#endif
-
-#if !defined(_WIN32) && defined(Z_LARGE64)
-#  define z_off64_t off64_t
-#else
-#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
-#    define z_off64_t __int64
-#  else
-#    define z_off64_t z_off_t
-#  endif
-#endif
-
-/* MVS linker does not support external names larger than 8 bytes */
-#if defined(__MVS__)
-  #pragma map(deflateInit_,"DEIN")
-  #pragma map(deflateInit2_,"DEIN2")
-  #pragma map(deflateEnd,"DEEND")
-  #pragma map(deflateBound,"DEBND")
-  #pragma map(inflateInit_,"ININ")
-  #pragma map(inflateInit2_,"ININ2")
-  #pragma map(inflateEnd,"INEND")
-  #pragma map(inflateSync,"INSY")
-  #pragma map(inflateSetDictionary,"INSEDI")
-  #pragma map(compressBound,"CMBND")
-  #pragma map(inflate_table,"INTABL")
-  #pragma map(inflate_fast,"INFA")
-  #pragma map(inflate_copyright,"INCOPY")
-#endif
-
-#endif /* ZCONF_H */
diff -Nbaur gcc-4.8.1/zlib/zlib2ansi gcc-4.8.1-ppc/zlib/zlib2ansi
--- gcc-4.8.1/zlib/zlib2ansi	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/zlib2ansi	1970-01-01 01:00:00.000000000 +0100
@@ -1,152 +0,0 @@
-#!/usr/bin/perl
-
-# Transform K&R C function definitions into ANSI equivalent.
-#
-# Author: Paul Marquess
-# Version: 1.0
-# Date: 3 October 2006
-
-# TODO
-#
-# Asumes no function pointer parameters. unless they are typedefed.
-# Assumes no literal strings that look like function definitions
-# Assumes functions start at the beginning of a line
-
-use strict;
-use warnings;
-
-local $/;
-$_ = <>;
-
-my $sp = qr{ \s* (?: /\* .*? \*/ )? \s* }x; # assume no nested comments
-
-my $d1    = qr{ $sp (?: [\w\*\s]+ $sp)* $sp \w+ $sp [\[\]\s]* $sp }x ;
-my $decl  = qr{ $sp (?: \w+ $sp )+ $d1 }xo ;
-my $dList = qr{ $sp $decl (?: $sp , $d1 )* $sp ; $sp }xo ;
-
-
-while (s/^
-            (                  # Start $1
-                (              #   Start $2
-                    .*?        #     Minimal eat content
-                    ( ^ \w [\w\s\*]+ )    #     $3 -- function name
-                    \s*        #     optional whitespace
-                )              # $2 - Matched up to before parameter list
-
-                \( \s*         # Literal "(" + optional whitespace
-                ( [^\)]+ )     # $4 - one or more anythings except ")"
-                \s* \)         # optional whitespace surrounding a Literal ")"
-
-                ( (?: $dList )+ ) # $5
-
-                $sp ^ {        # literal "{" at start of line
-            )                  # Remember to $1
-        //xsom
-      )
-{
-    my $all = $1 ;
-    my $prefix = $2;
-    my $param_list = $4 ;
-    my $params = $5;
-
-    StripComments($params);
-    StripComments($param_list);
-    $param_list =~ s/^\s+//;
-    $param_list =~ s/\s+$//;
-
-    my $i = 0 ;
-    my %pList = map { $_ => $i++ }
-                split /\s*,\s*/, $param_list;
-    my $pMatch = '(\b' . join('|', keys %pList) . '\b)\W*$' ;
-
-    my @params = split /\s*;\s*/, $params;
-    my @outParams = ();
-    foreach my $p (@params)
-    {
-        if ($p =~ /,/)
-        {
-            my @bits = split /\s*,\s*/, $p;
-            my $first = shift @bits;
-            $first =~ s/^\s*//;
-            push @outParams, $first;
-            $first =~ /^(\w+\s*)/;
-            my $type = $1 ;
-            push @outParams, map { $type . $_ } @bits;
-        }
-        else
-        {
-            $p =~ s/^\s+//;
-            push @outParams, $p;
-        }
-    }
-
-
-    my %tmp = map { /$pMatch/;  $_ => $pList{$1}  }
-              @outParams ;
-
-    @outParams = map  { "    $_" }
-                 sort { $tmp{$a} <=> $tmp{$b} }
-                 @outParams ;
-
-    print $prefix ;
-    print "(\n" . join(",\n", @outParams) . ")\n";
-    print "{" ;
-
-}
-
-# Output any trailing code.
-print ;
-exit 0;
-
-
-sub StripComments
-{
-
-  no warnings;
-
-  # Strip C & C++ coments
-  # From the perlfaq
-  $_[0] =~
-
-    s{
-       /\*         ##  Start of /* ... */ comment
-       [^*]*\*+    ##  Non-* followed by 1-or-more *'s
-       (
-         [^/*][^*]*\*+
-       )*          ##  0-or-more things which don't start with /
-                   ##    but do end with '*'
-       /           ##  End of /* ... */ comment
-
-     |         ##     OR  C++ Comment
-       //          ## Start of C++ comment //
-       [^\n]*      ## followed by 0-or-more non end of line characters
-
-     |         ##     OR  various things which aren't comments:
-
-       (
-         "           ##  Start of " ... " string
-         (
-           \\.           ##  Escaped char
-         |               ##    OR
-           [^"\\]        ##  Non "\
-         )*
-         "           ##  End of " ... " string
-
-       |         ##     OR
-
-         '           ##  Start of ' ... ' string
-         (
-           \\.           ##  Escaped char
-         |               ##    OR
-           [^'\\]        ##  Non '\
-         )*
-         '           ##  End of ' ... ' string
-
-       |         ##     OR
-
-         .           ##  Anything other char
-         [^/"'\\]*   ##  Chars which doesn't start a comment, string or escape
-       )
-     }{$2}gxs;
-
-}
diff -Nbaur gcc-4.8.1/zlib/zlib.3 gcc-4.8.1-ppc/zlib/zlib.3
--- gcc-4.8.1/zlib/zlib.3	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/zlib.3	1970-01-01 01:00:00.000000000 +0100
@@ -1,151 +0,0 @@
-.TH ZLIB 3 "2 May 2012"
-.SH NAME
-zlib \- compression/decompression library
-.SH SYNOPSIS
-[see
-.I zlib.h
-for full description]
-.SH DESCRIPTION
-The
-.I zlib
-library is a general purpose data compression library.
-The code is thread safe, assuming that the standard library functions
-used are thread safe, such as memory allocation routines.
-It provides in-memory compression and decompression functions,
-including integrity checks of the uncompressed data.
-This version of the library supports only one compression method (deflation)
-but other algorithms may be added later
-with the same stream interface.
-.LP
-Compression can be done in a single step if the buffers are large enough
-or can be done by repeated calls of the compression function.
-In the latter case,
-the application must provide more input and/or consume the output
-(providing more output space) before each call.
-.LP
-The library also supports reading and writing files in
-.IR gzip (1)
-(.gz) format
-with an interface similar to that of stdio.
-.LP
-The library does not install any signal handler.
-The decoder checks the consistency of the compressed data,
-so the library should never crash even in the case of corrupted input.
-.LP
-All functions of the compression library are documented in the file
-.IR zlib.h .
-The distribution source includes examples of use of the library
-in the files
-.I test/example.c
-and
-.IR test/minigzip.c,
-as well as other examples in the
-.IR examples/
-directory.
-.LP
-Changes to this version are documented in the file
-.I ChangeLog
-that accompanies the source.
-.LP
-.I zlib
-is available in Java using the java.util.zip package:
-.IP
-http://java.sun.com/developer/technicalArticles/Programming/compression/
-.LP
-A Perl interface to
-.IR zlib ,
-written by Paul Marquess (pmqs@cpan.org),
-is available at CPAN (Comprehensive Perl Archive Network) sites,
-including:
-.IP
-http://search.cpan.org/~pmqs/IO-Compress-Zlib/
-.LP
-A Python interface to
-.IR zlib ,
-written by A.M. Kuchling (amk@magnet.com),
-is available in Python 1.5 and later versions:
-.IP
-http://docs.python.org/library/zlib.html
-.LP
-.I zlib
-is built into
-.IR tcl:
-.IP
-http://wiki.tcl.tk/4610
-.LP
-An experimental package to read and write files in .zip format,
-written on top of
-.I zlib
-by Gilles Vollant (info@winimage.com),
-is available at:
-.IP
-http://www.winimage.com/zLibDll/minizip.html
-and also in the
-.I contrib/minizip
-directory of the main
-.I zlib
-source distribution.
-.SH "SEE ALSO"
-The
-.I zlib
-web site can be found at:
-.IP
-http://zlib.net/
-.LP
-The data format used by the zlib library is described by RFC
-(Request for Comments) 1950 to 1952 in the files:
-.IP
-http://tools.ietf.org/html/rfc1950 (for the zlib header and trailer format)
-.br
-http://tools.ietf.org/html/rfc1951 (for the deflate compressed data format)
-.br
-http://tools.ietf.org/html/rfc1952 (for the gzip header and trailer format)
-.LP
-Mark Nelson wrote an article about
-.I zlib
-for the Jan. 1997 issue of  Dr. Dobb's Journal;
-a copy of the article is available at:
-.IP
-http://marknelson.us/1997/01/01/zlib-engine/
-.SH "REPORTING PROBLEMS"
-Before reporting a problem,
-please check the
-.I zlib
-web site to verify that you have the latest version of
-.IR zlib ;
-otherwise,
-obtain the latest version and see if the problem still exists.
-Please read the
-.I zlib
-FAQ at:
-.IP
-http://zlib.net/zlib_faq.html
-.LP
-before asking for help.
-Send questions and/or comments to zlib@gzip.org,
-or (for the Windows DLL version) to Gilles Vollant (info@winimage.com).
-.SH AUTHORS
-Version 1.2.7
-Copyright (C) 1995-2012 Jean-loup Gailly (jloup@gzip.org)
-and Mark Adler (madler@alumni.caltech.edu).
-.LP
-This software is provided "as-is,"
-without any express or implied warranty.
-In no event will the authors be held liable for any damages
-arising from the use of this software.
-See the distribution directory with respect to requirements
-governing redistribution.
-The deflate format used by
-.I zlib
-was defined by Phil Katz.
-The deflate and
-.I zlib
-specifications were written by L. Peter Deutsch.
-Thanks to all the people who reported problems and suggested various
-improvements in
-.IR zlib ;
-who are too numerous to cite here.
-.LP
-UNIX manual page by R. P. C. Rodgers,
-U.S. National Library of Medicine (rodgers@nlm.nih.gov).
-.\" end of man page
diff -Nbaur gcc-4.8.1/zlib/zlib.h gcc-4.8.1-ppc/zlib/zlib.h
--- gcc-4.8.1/zlib/zlib.h	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/zlib.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,1744 +0,0 @@
-/* zlib.h -- interface of the 'zlib' general purpose compression library
-  version 1.2.7, May 2nd, 2012
-
-  Copyright (C) 1995-2012 Jean-loup Gailly and Mark Adler
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Jean-loup Gailly        Mark Adler
-  jloup@gzip.org          madler@alumni.caltech.edu
-
-
-  The data format used by the zlib library is described by RFCs (Request for
-  Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950
-  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).
-*/
-
-#ifndef ZLIB_H
-#define ZLIB_H
-
-#include "zconf.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define ZLIB_VERSION "1.2.7"
-#define ZLIB_VERNUM 0x1270
-#define ZLIB_VER_MAJOR 1
-#define ZLIB_VER_MINOR 2
-#define ZLIB_VER_REVISION 7
-#define ZLIB_VER_SUBREVISION 0
-
-/*
-    The 'zlib' compression library provides in-memory compression and
-  decompression functions, including integrity checks of the uncompressed data.
-  This version of the library supports only one compression method (deflation)
-  but other algorithms will be added later and will have the same stream
-  interface.
-
-    Compression can be done in a single step if the buffers are large enough,
-  or can be done by repeated calls of the compression function.  In the latter
-  case, the application must provide more input and/or consume the output
-  (providing more output space) before each call.
-
-    The compressed data format used by default by the in-memory functions is
-  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
-  around a deflate stream, which is itself documented in RFC 1951.
-
-    The library also supports reading and writing files in gzip (.gz) format
-  with an interface similar to that of stdio using the functions that start
-  with "gz".  The gzip format is different from the zlib format.  gzip is a
-  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
-
-    This library can optionally read and write gzip streams in memory as well.
-
-    The zlib format was designed to be compact and fast for use in memory
-  and on communications channels.  The gzip format was designed for single-
-  file compression on file systems, has a larger header than zlib to maintain
-  directory information, and uses a different, slower check method than zlib.
-
-    The library does not install any signal handler.  The decoder checks
-  the consistency of the compressed data, so the library should never crash
-  even in case of corrupted input.
-*/
-
-typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
-typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
-
-struct internal_state;
-
-typedef struct z_stream_s {
-    z_const Bytef *next_in;     /* next input byte */
-    uInt     avail_in;  /* number of bytes available at next_in */
-    uLong    total_in;  /* total number of input bytes read so far */
-
-    Bytef    *next_out; /* next output byte should be put there */
-    uInt     avail_out; /* remaining free space at next_out */
-    uLong    total_out; /* total number of bytes output so far */
-
-    z_const char *msg;  /* last error message, NULL if no error */
-    struct internal_state FAR *state; /* not visible by applications */
-
-    alloc_func zalloc;  /* used to allocate the internal state */
-    free_func  zfree;   /* used to free the internal state */
-    voidpf     opaque;  /* private data object passed to zalloc and zfree */
-
-    int     data_type;  /* best guess about the data type: binary or text */
-    uLong   adler;      /* adler32 value of the uncompressed data */
-    uLong   reserved;   /* reserved for future use */
-} z_stream;
-
-typedef z_stream FAR *z_streamp;
-
-/*
-     gzip header information passed to and from zlib routines.  See RFC 1952
-  for more details on the meanings of these fields.
-*/
-typedef struct gz_header_s {
-    int     text;       /* true if compressed data believed to be text */
-    uLong   time;       /* modification time */
-    int     xflags;     /* extra flags (not used when writing a gzip file) */
-    int     os;         /* operating system */
-    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
-    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
-    uInt    extra_max;  /* space at extra (only when reading header) */
-    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
-    uInt    name_max;   /* space at name (only when reading header) */
-    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
-    uInt    comm_max;   /* space at comment (only when reading header) */
-    int     hcrc;       /* true if there was or will be a header crc */
-    int     done;       /* true when done reading gzip header (not used
-                           when writing a gzip file) */
-} gz_header;
-
-typedef gz_header FAR *gz_headerp;
-
-/*
-     The application must update next_in and avail_in when avail_in has dropped
-   to zero.  It must update next_out and avail_out when avail_out has dropped
-   to zero.  The application must initialize zalloc, zfree and opaque before
-   calling the init function.  All other fields are set by the compression
-   library and must not be updated by the application.
-
-     The opaque value provided by the application will be passed as the first
-   parameter for calls of zalloc and zfree.  This can be useful for custom
-   memory management.  The compression library attaches no meaning to the
-   opaque value.
-
-     zalloc must return Z_NULL if there is not enough memory for the object.
-   If zlib is used in a multi-threaded application, zalloc and zfree must be
-   thread safe.
-
-     On 16-bit systems, the functions zalloc and zfree must be able to allocate
-   exactly 65536 bytes, but will not be required to allocate more than this if
-   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers
-   returned by zalloc for objects of exactly 65536 bytes *must* have their
-   offset normalized to zero.  The default allocation function provided by this
-   library ensures this (see zutil.c).  To reduce memory requirements and avoid
-   any allocation of 64K objects, at the expense of compression ratio, compile
-   the library with -DMAX_WBITS=14 (see zconf.h).
-
-     The fields total_in and total_out can be used for statistics or progress
-   reports.  After compression, total_in holds the total size of the
-   uncompressed data and may be saved for use in the decompressor (particularly
-   if the decompressor wants to decompress everything in a single step).
-*/
-
-                        /* constants */
-
-#define Z_NO_FLUSH      0
-#define Z_PARTIAL_FLUSH 1
-#define Z_SYNC_FLUSH    2
-#define Z_FULL_FLUSH    3
-#define Z_FINISH        4
-#define Z_BLOCK         5
-#define Z_TREES         6
-/* Allowed flush values; see deflate() and inflate() below for details */
-
-#define Z_OK            0
-#define Z_STREAM_END    1
-#define Z_NEED_DICT     2
-#define Z_ERRNO        (-1)
-#define Z_STREAM_ERROR (-2)
-#define Z_DATA_ERROR   (-3)
-#define Z_MEM_ERROR    (-4)
-#define Z_BUF_ERROR    (-5)
-#define Z_VERSION_ERROR (-6)
-/* Return codes for the compression/decompression functions. Negative values
- * are errors, positive values are used for special but normal events.
- */
-
-#define Z_NO_COMPRESSION         0
-#define Z_BEST_SPEED             1
-#define Z_BEST_COMPRESSION       9
-#define Z_DEFAULT_COMPRESSION  (-1)
-/* compression levels */
-
-#define Z_FILTERED            1
-#define Z_HUFFMAN_ONLY        2
-#define Z_RLE                 3
-#define Z_FIXED               4
-#define Z_DEFAULT_STRATEGY    0
-/* compression strategy; see deflateInit2() below for details */
-
-#define Z_BINARY   0
-#define Z_TEXT     1
-#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
-#define Z_UNKNOWN  2
-/* Possible values of the data_type field (though see inflate()) */
-
-#define Z_DEFLATED   8
-/* The deflate compression method (the only one supported in this version) */
-
-#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
-
-#define zlib_version zlibVersion()
-/* for compatibility with versions < 1.0.2 */
-
-
-                        /* basic functions */
-
-ZEXTERN const char * ZEXPORT zlibVersion OF((void));
-/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
-   If the first character differs, the library code actually used is not
-   compatible with the zlib.h header file used by the application.  This check
-   is automatically made by deflateInit and inflateInit.
- */
-
-/*
-ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
-
-     Initializes the internal stream state for compression.  The fields
-   zalloc, zfree and opaque must be initialized before by the caller.  If
-   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
-   allocation functions.
-
-     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
-   1 gives best speed, 9 gives best compression, 0 gives no compression at all
-   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
-   requests a default compromise between speed and compression (currently
-   equivalent to level 6).
-
-     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if level is not a valid compression level, or
-   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
-   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null
-   if there is no error message.  deflateInit does not perform any compression:
-   this will be done by deflate().
-*/
-
-
-ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
-/*
-    deflate compresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full.  It may introduce
-  some output latency (reading input without producing any output) except when
-  forced to flush.
-
-    The detailed semantics are as follows.  deflate performs one or both of the
-  following actions:
-
-  - Compress more input starting at next_in and update next_in and avail_in
-    accordingly.  If not all input can be processed (because there is not
-    enough room in the output buffer), next_in and avail_in are updated and
-    processing will resume at this point for the next call of deflate().
-
-  - Provide more output starting at next_out and update next_out and avail_out
-    accordingly.  This action is forced if the parameter flush is non zero.
-    Forcing flush frequently degrades the compression ratio, so this parameter
-    should be set only when necessary (in interactive applications).  Some
-    output may be provided even if flush is not set.
-
-    Before the call of deflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming more
-  output, and updating avail_in or avail_out accordingly; avail_out should
-  never be zero before the call.  The application can consume the compressed
-  output when it wants, for example when the output buffer is full (avail_out
-  == 0), or after each call of deflate().  If deflate returns Z_OK and with
-  zero avail_out, it must be called again after making room in the output
-  buffer because there might be more output pending.
-
-    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
-  decide how much data to accumulate before producing output, in order to
-  maximize compression.
-
-    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
-  flushed to the output buffer and the output is aligned on a byte boundary, so
-  that the decompressor can get all input data available so far.  (In
-  particular avail_in is zero after the call if enough output space has been
-  provided before the call.) Flushing may degrade compression for some
-  compression algorithms and so it should be used only when necessary.  This
-  completes the current deflate block and follows it with an empty stored block
-  that is three bits plus filler bits to the next byte, followed by four bytes
-  (00 00 ff ff).
-
-    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the
-  output buffer, but the output is not aligned to a byte boundary.  All of the
-  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.
-  This completes the current deflate block and follows it with an empty fixed
-  codes block that is 10 bits long.  This assures that enough bytes are output
-  in order for the decompressor to finish the block before the empty fixed code
-  block.
-
-    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as
-  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to
-  seven bits of the current block are held to be written as the next byte after
-  the next deflate block is completed.  In this case, the decompressor may not
-  be provided enough bits at this point in order to complete decompression of
-  the data provided so far to the compressor.  It may need to wait for the next
-  block to be emitted.  This is for advanced applications that need to control
-  the emission of deflate blocks.
-
-    If flush is set to Z_FULL_FLUSH, all output is flushed as with
-  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
-  restart from this point if previous compressed data has been damaged or if
-  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade
-  compression.
-
-    If deflate returns with avail_out == 0, this function must be called again
-  with the same value of the flush parameter and more output space (updated
-  avail_out), until the flush is complete (deflate returns with non-zero
-  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
-  avail_out is greater than six to avoid repeated flush markers due to
-  avail_out == 0 on return.
-
-    If the parameter flush is set to Z_FINISH, pending input is processed,
-  pending output is flushed and deflate returns with Z_STREAM_END if there was
-  enough output space; if deflate returns with Z_OK, this function must be
-  called again with Z_FINISH and more output space (updated avail_out) but no
-  more input data, until it returns with Z_STREAM_END or an error.  After
-  deflate has returned Z_STREAM_END, the only possible operations on the stream
-  are deflateReset or deflateEnd.
-
-    Z_FINISH can be used immediately after deflateInit if all the compression
-  is to be done in a single step.  In this case, avail_out must be at least the
-  value returned by deflateBound (see below).  Then deflate is guaranteed to
-  return Z_STREAM_END.  If not enough output space is provided, deflate will
-  not return Z_STREAM_END, and it must be called again as described above.
-
-    deflate() sets strm->adler to the adler32 checksum of all input read
-  so far (that is, total_in bytes).
-
-    deflate() may update strm->data_type if it can make a good guess about
-  the input data type (Z_BINARY or Z_TEXT).  In doubt, the data is considered
-  binary.  This field is only for information purposes and does not affect the
-  compression algorithm in any manner.
-
-    deflate() returns Z_OK if some progress has been made (more input
-  processed or more output produced), Z_STREAM_END if all input has been
-  consumed and all output has been produced (only when flush is set to
-  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
-  if next_in or next_out was Z_NULL), Z_BUF_ERROR if no progress is possible
-  (for example avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not
-  fatal, and deflate() can be called again with more input and more output
-  space to continue compressing.
-*/
-
-
-ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any pending
-   output.
-
-     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
-   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
-   prematurely (some input or output was discarded).  In the error case, msg
-   may be set but then points to a static string (which must not be
-   deallocated).
-*/
-
-
-/*
-ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
-
-     Initializes the internal stream state for decompression.  The fields
-   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
-   the caller.  If next_in is not Z_NULL and avail_in is large enough (the
-   exact value depends on the compression method), inflateInit determines the
-   compression method from the zlib header and allocates all data structures
-   accordingly; otherwise the allocation will be deferred to the first call of
-   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
-   use default allocation functions.
-
-     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
-   invalid, such as a null pointer to the structure.  msg is set to null if
-   there is no error message.  inflateInit does not perform any decompression
-   apart from possibly reading the zlib header if present: actual decompression
-   will be done by inflate().  (So next_in and avail_in may be modified, but
-   next_out and avail_out are unused and unchanged.) The current implementation
-   of inflateInit() does not process any header information -- that is deferred
-   until inflate() is called.
-*/
-
-
-ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
-/*
-    inflate decompresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full.  It may introduce
-  some output latency (reading input without producing any output) except when
-  forced to flush.
-
-  The detailed semantics are as follows.  inflate performs one or both of the
-  following actions:
-
-  - Decompress more input starting at next_in and update next_in and avail_in
-    accordingly.  If not all input can be processed (because there is not
-    enough room in the output buffer), next_in is updated and processing will
-    resume at this point for the next call of inflate().
-
-  - Provide more output starting at next_out and update next_out and avail_out
-    accordingly.  inflate() provides as much output as possible, until there is
-    no more input data or no more space in the output buffer (see below about
-    the flush parameter).
-
-    Before the call of inflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming more
-  output, and updating the next_* and avail_* values accordingly.  The
-  application can consume the uncompressed output when it wants, for example
-  when the output buffer is full (avail_out == 0), or after each call of
-  inflate().  If inflate returns Z_OK and with zero avail_out, it must be
-  called again after making room in the output buffer because there might be
-  more output pending.
-
-    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,
-  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much
-  output as possible to the output buffer.  Z_BLOCK requests that inflate()
-  stop if and when it gets to the next deflate block boundary.  When decoding
-  the zlib or gzip format, this will cause inflate() to return immediately
-  after the header and before the first block.  When doing a raw inflate,
-  inflate() will go ahead and process the first block, and will return when it
-  gets to the end of that block, or when it runs out of data.
-
-    The Z_BLOCK option assists in appending to or combining deflate streams.
-  Also to assist in this, on return inflate() will set strm->data_type to the
-  number of unused bits in the last byte taken from strm->next_in, plus 64 if
-  inflate() is currently decoding the last block in the deflate stream, plus
-  128 if inflate() returned immediately after decoding an end-of-block code or
-  decoding the complete header up to just before the first byte of the deflate
-  stream.  The end-of-block will not be indicated until all of the uncompressed
-  data from that block has been written to strm->next_out.  The number of
-  unused bits may in general be greater than seven, except when bit 7 of
-  data_type is set, in which case the number of unused bits will be less than
-  eight.  data_type is set as noted here every time inflate() returns for all
-  flush options, and so can be used to determine the amount of currently
-  consumed input in bits.
-
-    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the
-  end of each deflate block header is reached, before any actual data in that
-  block is decoded.  This allows the caller to determine the length of the
-  deflate block header for later use in random access within a deflate block.
-  256 is added to the value of strm->data_type when inflate() returns
-  immediately after reaching the end of the deflate block header.
-
-    inflate() should normally be called until it returns Z_STREAM_END or an
-  error.  However if all decompression is to be performed in a single step (a
-  single call of inflate), the parameter flush should be set to Z_FINISH.  In
-  this case all pending input is processed and all pending output is flushed;
-  avail_out must be large enough to hold all of the uncompressed data for the
-  operation to complete.  (The size of the uncompressed data may have been
-  saved by the compressor for this purpose.) The use of Z_FINISH is not
-  required to perform an inflation in one step.  However it may be used to
-  inform inflate that a faster approach can be used for the single inflate()
-  call.  Z_FINISH also informs inflate to not maintain a sliding window if the
-  stream completes, which reduces inflate's memory footprint.  If the stream
-  does not complete, either because not all of the stream is provided or not
-  enough output space is provided, then a sliding window will be allocated and
-  inflate() can be called again to continue the operation as if Z_NO_FLUSH had
-  been used.
-
-     In this implementation, inflate() always flushes as much output as
-  possible to the output buffer, and always uses the faster approach on the
-  first call.  So the effects of the flush parameter in this implementation are
-  on the return value of inflate() as noted below, when inflate() returns early
-  when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of
-  memory for a sliding window when Z_FINISH is used.
-
-     If a preset dictionary is needed after this call (see inflateSetDictionary
-  below), inflate sets strm->adler to the Adler-32 checksum of the dictionary
-  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
-  strm->adler to the Adler-32 checksum of all output produced so far (that is,
-  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
-  below.  At the end of the stream, inflate() checks that its computed adler32
-  checksum is equal to that saved by the compressor and returns Z_STREAM_END
-  only if the checksum is correct.
-
-    inflate() can decompress and check either zlib-wrapped or gzip-wrapped
-  deflate data.  The header type is detected automatically, if requested when
-  initializing with inflateInit2().  Any information contained in the gzip
-  header is not retained, so applications that need that information should
-  instead use raw inflate, see inflateInit2() below, or inflateBack() and
-  perform their own processing of the gzip header and trailer.  When processing
-  gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output
-  producted so far.  The CRC-32 is checked against the gzip trailer.
-
-    inflate() returns Z_OK if some progress has been made (more input processed
-  or more output produced), Z_STREAM_END if the end of the compressed data has
-  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
-  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
-  corrupted (input stream not conforming to the zlib format or incorrect check
-  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
-  next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory,
-  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
-  output buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
-  inflate() can be called again with more input and more output space to
-  continue decompressing.  If Z_DATA_ERROR is returned, the application may
-  then call inflateSync() to look for a good compression block if a partial
-  recovery of the data is desired.
-*/
-
-
-ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any pending
-   output.
-
-     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
-   was inconsistent.  In the error case, msg may be set but then points to a
-   static string (which must not be deallocated).
-*/
-
-
-                        /* Advanced functions */
-
-/*
-    The following functions are needed only in some special applications.
-*/
-
-/*
-ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
-                                     int  level,
-                                     int  method,
-                                     int  windowBits,
-                                     int  memLevel,
-                                     int  strategy));
-
-     This is another version of deflateInit with more compression options.  The
-   fields next_in, zalloc, zfree and opaque must be initialized before by the
-   caller.
-
-     The method parameter is the compression method.  It must be Z_DEFLATED in
-   this version of the library.
-
-     The windowBits parameter is the base two logarithm of the window size
-   (the size of the history buffer).  It should be in the range 8..15 for this
-   version of the library.  Larger values of this parameter result in better
-   compression at the expense of memory usage.  The default value is 15 if
-   deflateInit is used instead.
-
-     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits
-   determines the window size.  deflate() will then generate raw deflate data
-   with no zlib header or trailer, and will not compute an adler32 check value.
-
-     windowBits can also be greater than 15 for optional gzip encoding.  Add
-   16 to windowBits to write a simple gzip header and trailer around the
-   compressed data instead of a zlib wrapper.  The gzip header will have no
-   file name, no extra data, no comment, no modification time (set to zero), no
-   header crc, and the operating system will be set to 255 (unknown).  If a
-   gzip stream is being written, strm->adler is a crc32 instead of an adler32.
-
-     The memLevel parameter specifies how much memory should be allocated
-   for the internal compression state.  memLevel=1 uses minimum memory but is
-   slow and reduces compression ratio; memLevel=9 uses maximum memory for
-   optimal speed.  The default value is 8.  See zconf.h for total memory usage
-   as a function of windowBits and memLevel.
-
-     The strategy parameter is used to tune the compression algorithm.  Use the
-   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
-   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
-   string match), or Z_RLE to limit match distances to one (run-length
-   encoding).  Filtered data consists mostly of small values with a somewhat
-   random distribution.  In this case, the compression algorithm is tuned to
-   compress them better.  The effect of Z_FILTERED is to force more Huffman
-   coding and less string matching; it is somewhat intermediate between
-   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as
-   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The
-   strategy parameter only affects the compression ratio but not the
-   correctness of the compressed output even if it is not set appropriately.
-   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler
-   decoder for special applications.
-
-     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid
-   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is
-   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is
-   set to null if there is no error message.  deflateInit2 does not perform any
-   compression: this will be done by deflate().
-*/
-
-ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the compression dictionary from the given byte sequence
-   without producing any compressed output.  When using the zlib format, this
-   function must be called immediately after deflateInit, deflateInit2 or
-   deflateReset, and before any call of deflate.  When doing raw deflate, this
-   function must be called either before any call of deflate, or immediately
-   after the completion of a deflate block, i.e. after all input has been
-   consumed and all output has been delivered when using any of the flush
-   options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The
-   compressor and decompressor must use exactly the same dictionary (see
-   inflateSetDictionary).
-
-     The dictionary should consist of strings (byte sequences) that are likely
-   to be encountered later in the data to be compressed, with the most commonly
-   used strings preferably put towards the end of the dictionary.  Using a
-   dictionary is most useful when the data to be compressed is short and can be
-   predicted with good accuracy; the data can then be compressed better than
-   with the default empty dictionary.
-
-     Depending on the size of the compression data structures selected by
-   deflateInit or deflateInit2, a part of the dictionary may in effect be
-   discarded, for example if the dictionary is larger than the window size
-   provided in deflateInit or deflateInit2.  Thus the strings most likely to be
-   useful should be put at the end of the dictionary, not at the front.  In
-   addition, the current implementation of deflate will use at most the window
-   size minus 262 bytes of the provided dictionary.
-
-     Upon return of this function, strm->adler is set to the adler32 value
-   of the dictionary; the decompressor may later use this value to determine
-   which dictionary has been used by the compressor.  (The adler32 value
-   applies to the whole dictionary even if only a subset of the dictionary is
-   actually used by the compressor.) If a raw deflate was requested, then the
-   adler32 value is not computed and strm->adler is not set.
-
-     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
-   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
-   inconsistent (for example if deflate has already been called for this stream
-   or if not at a block boundary for raw deflate).  deflateSetDictionary does
-   not perform any compression: this will be done by deflate().
-*/
-
-ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-
-     This function can be useful when several compression strategies will be
-   tried, for example when there are several ways of pre-processing the input
-   data with a filter.  The streams that will be discarded should then be freed
-   by calling deflateEnd.  Note that deflateCopy duplicates the internal
-   compression state which can be quite large, so this strategy is slow and can
-   consume lots of memory.
-
-     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
-   destination.
-*/
-
-ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to deflateEnd followed by deflateInit,
-   but does not free and reallocate all the internal compression state.  The
-   stream will keep the same compression level and any other attributes that
-   may have been set by deflateInit2.
-
-     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL).
-*/
-
-ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
-                                      int level,
-                                      int strategy));
-/*
-     Dynamically update the compression level and compression strategy.  The
-   interpretation of level and strategy is as in deflateInit2.  This can be
-   used to switch between compression and straight copy of the input data, or
-   to switch to a different kind of input data requiring a different strategy.
-   If the compression level is changed, the input available so far is
-   compressed with the old level (and may be flushed); the new level will take
-   effect only at the next call of deflate().
-
-     Before the call of deflateParams, the stream state must be set as for
-   a call of deflate(), since the currently available input may have to be
-   compressed and flushed.  In particular, strm->avail_out must be non-zero.
-
-     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
-   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR if
-   strm->avail_out was zero.
-*/
-
-ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
-                                    int good_length,
-                                    int max_lazy,
-                                    int nice_length,
-                                    int max_chain));
-/*
-     Fine tune deflate's internal compression parameters.  This should only be
-   used by someone who understands the algorithm used by zlib's deflate for
-   searching for the best matching string, and even then only by the most
-   fanatic optimizer trying to squeeze out the last compressed bit for their
-   specific input data.  Read the deflate.c source code for the meaning of the
-   max_lazy, good_length, nice_length, and max_chain parameters.
-
-     deflateTune() can be called after deflateInit() or deflateInit2(), and
-   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
- */
-
-ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
-                                       uLong sourceLen));
-/*
-     deflateBound() returns an upper bound on the compressed size after
-   deflation of sourceLen bytes.  It must be called after deflateInit() or
-   deflateInit2(), and after deflateSetHeader(), if used.  This would be used
-   to allocate an output buffer for deflation in a single pass, and so would be
-   called before deflate().  If that first deflate() call is provided the
-   sourceLen input bytes, an output buffer allocated to the size returned by
-   deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed
-   to return Z_STREAM_END.  Note that it is possible for the compressed size to
-   be larger than the value returned by deflateBound() if flush options other
-   than Z_FINISH or Z_NO_FLUSH are used.
-*/
-
-ZEXTERN int ZEXPORT deflatePending OF((z_streamp strm,
-                                       unsigned *pending,
-                                       int *bits));
-/*
-     deflatePending() returns the number of bytes and bits of output that have
-   been generated, but not yet provided in the available output.  The bytes not
-   provided would be due to the available output space having being consumed.
-   The number of bits of output not provided are between 0 and 7, where they
-   await more bits to join them in order to fill out a full byte.  If pending
-   or bits are Z_NULL, then those values are not set.
-
-     deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
- */
-
-ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
-                                     int bits,
-                                     int value));
-/*
-     deflatePrime() inserts bits in the deflate output stream.  The intent
-   is that this function is used to start off the deflate output with the bits
-   leftover from a previous deflate stream when appending to it.  As such, this
-   function can only be used for raw deflate, and must be used before the first
-   deflate() call after a deflateInit2() or deflateReset().  bits must be less
-   than or equal to 16, and that many of the least significant bits of value
-   will be inserted in the output.
-
-     deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough
-   room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the
-   source stream state was inconsistent.
-*/
-
-ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
-                                         gz_headerp head));
-/*
-     deflateSetHeader() provides gzip header information for when a gzip
-   stream is requested by deflateInit2().  deflateSetHeader() may be called
-   after deflateInit2() or deflateReset() and before the first call of
-   deflate().  The text, time, os, extra field, name, and comment information
-   in the provided gz_header structure are written to the gzip header (xflag is
-   ignored -- the extra flags are set according to the compression level).  The
-   caller must assure that, if not Z_NULL, name and comment are terminated with
-   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
-   available there.  If hcrc is true, a gzip header crc is included.  Note that
-   the current versions of the command-line version of gzip (up through version
-   1.3.x) do not support header crc's, and will report that it is a "multi-part
-   gzip file" and give up.
-
-     If deflateSetHeader is not used, the default gzip header has text false,
-   the time set to zero, and os set to 255, with no extra, name, or comment
-   fields.  The gzip header is returned to the default state by deflateReset().
-
-     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-/*
-ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
-                                     int  windowBits));
-
-     This is another version of inflateInit with an extra parameter.  The
-   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
-   before by the caller.
-
-     The windowBits parameter is the base two logarithm of the maximum window
-   size (the size of the history buffer).  It should be in the range 8..15 for
-   this version of the library.  The default value is 15 if inflateInit is used
-   instead.  windowBits must be greater than or equal to the windowBits value
-   provided to deflateInit2() while compressing, or it must be equal to 15 if
-   deflateInit2() was not used.  If a compressed stream with a larger window
-   size is given as input, inflate() will return with the error code
-   Z_DATA_ERROR instead of trying to allocate a larger window.
-
-     windowBits can also be zero to request that inflate use the window size in
-   the zlib header of the compressed stream.
-
-     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits
-   determines the window size.  inflate() will then process raw deflate data,
-   not looking for a zlib or gzip header, not generating a check value, and not
-   looking for any check values for comparison at the end of the stream.  This
-   is for use with other formats that use the deflate compressed data format
-   such as zip.  Those formats provide their own check values.  If a custom
-   format is developed using the raw deflate format for compressed data, it is
-   recommended that a check value such as an adler32 or a crc32 be applied to
-   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
-   most applications, the zlib format should be used as is.  Note that comments
-   above on the use in deflateInit2() applies to the magnitude of windowBits.
-
-     windowBits can also be greater than 15 for optional gzip decoding.  Add
-   32 to windowBits to enable zlib and gzip decoding with automatic header
-   detection, or add 16 to decode only the gzip format (the zlib format will
-   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a
-   crc32 instead of an adler32.
-
-     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
-   invalid, such as a null pointer to the structure.  msg is set to null if
-   there is no error message.  inflateInit2 does not perform any decompression
-   apart from possibly reading the zlib header if present: actual decompression
-   will be done by inflate().  (So next_in and avail_in may be modified, but
-   next_out and avail_out are unused and unchanged.) The current implementation
-   of inflateInit2() does not process any header information -- that is
-   deferred until inflate() is called.
-*/
-
-ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the decompression dictionary from the given uncompressed byte
-   sequence.  This function must be called immediately after a call of inflate,
-   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor
-   can be determined from the adler32 value returned by that call of inflate.
-   The compressor and decompressor must use exactly the same dictionary (see
-   deflateSetDictionary).  For raw inflate, this function can be called at any
-   time to set the dictionary.  If the provided dictionary is smaller than the
-   window and there is already data in the window, then the provided dictionary
-   will amend what's there.  The application must insure that the dictionary
-   that was used for compression is provided.
-
-     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
-   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
-   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
-   expected one (incorrect adler32 value).  inflateSetDictionary does not
-   perform any decompression: this will be done by subsequent calls of
-   inflate().
-*/
-
-ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
-/*
-     Skips invalid compressed data until a possible full flush point (see above
-   for the description of deflate with Z_FULL_FLUSH) can be found, or until all
-   available input is skipped.  No output is provided.
-
-     inflateSync searches for a 00 00 FF FF pattern in the compressed data.
-   All full flush points have this pattern, but not all occurences of this
-   pattern are full flush points.
-
-     inflateSync returns Z_OK if a possible full flush point has been found,
-   Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point
-   has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.
-   In the success case, the application may save the current current value of
-   total_in which indicates where valid compressed data was found.  In the
-   error case, the application may repeatedly call inflateSync, providing more
-   input each time, until success or end of the input data.
-*/
-
-ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-
-     This function can be useful when randomly accessing a large stream.  The
-   first pass through the stream can periodically record the inflate state,
-   allowing restarting inflate at those points when randomly accessing the
-   stream.
-
-     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
-   destination.
-*/
-
-ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to inflateEnd followed by inflateInit,
-   but does not free and reallocate all the internal decompression state.  The
-   stream will keep attributes that may have been set by inflateInit2.
-
-     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL).
-*/
-
-ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,
-                                      int windowBits));
-/*
-     This function is the same as inflateReset, but it also permits changing
-   the wrap and window size requests.  The windowBits parameter is interpreted
-   the same as it is for inflateInit2.
-
-     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL), or if
-   the windowBits parameter is invalid.
-*/
-
-ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
-                                     int bits,
-                                     int value));
-/*
-     This function inserts bits in the inflate input stream.  The intent is
-   that this function is used to start inflating at a bit position in the
-   middle of a byte.  The provided bits will be used before any bytes are used
-   from next_in.  This function should only be used with raw inflate, and
-   should be used before the first inflate() call after inflateInit2() or
-   inflateReset().  bits must be less than or equal to 16, and that many of the
-   least significant bits of value will be inserted in the input.
-
-     If bits is negative, then the input stream bit buffer is emptied.  Then
-   inflatePrime() can be called again to put bits in the buffer.  This is used
-   to clear out bits leftover after feeding inflate a block description prior
-   to feeding inflate codes.
-
-     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));
-/*
-     This function returns two values, one in the lower 16 bits of the return
-   value, and the other in the remaining upper bits, obtained by shifting the
-   return value down 16 bits.  If the upper value is -1 and the lower value is
-   zero, then inflate() is currently decoding information outside of a block.
-   If the upper value is -1 and the lower value is non-zero, then inflate is in
-   the middle of a stored block, with the lower value equaling the number of
-   bytes from the input remaining to copy.  If the upper value is not -1, then
-   it is the number of bits back from the current bit position in the input of
-   the code (literal or length/distance pair) currently being processed.  In
-   that case the lower value is the number of bytes already emitted for that
-   code.
-
-     A code is being processed if inflate is waiting for more input to complete
-   decoding of the code, or if it has completed decoding but is waiting for
-   more output space to write the literal or match data.
-
-     inflateMark() is used to mark locations in the input data for random
-   access, which may be at bit positions, and to note those cases where the
-   output of a code may span boundaries of random access blocks.  The current
-   location in the input stream can be determined from avail_in and data_type
-   as noted in the description for the Z_BLOCK flush parameter for inflate.
-
-     inflateMark returns the value noted above or -1 << 16 if the provided
-   source stream state was inconsistent.
-*/
-
-ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
-                                         gz_headerp head));
-/*
-     inflateGetHeader() requests that gzip header information be stored in the
-   provided gz_header structure.  inflateGetHeader() may be called after
-   inflateInit2() or inflateReset(), and before the first call of inflate().
-   As inflate() processes the gzip stream, head->done is zero until the header
-   is completed, at which time head->done is set to one.  If a zlib stream is
-   being decoded, then head->done is set to -1 to indicate that there will be
-   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
-   used to force inflate() to return immediately after header processing is
-   complete and before any actual data is decompressed.
-
-     The text, time, xflags, and os fields are filled in with the gzip header
-   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
-   was valid if done is set to one.) If extra is not Z_NULL, then extra_max
-   contains the maximum number of bytes to write to extra.  Once done is true,
-   extra_len contains the actual extra field length, and extra contains the
-   extra field, or that field truncated if extra_max is less than extra_len.
-   If name is not Z_NULL, then up to name_max characters are written there,
-   terminated with a zero unless the length is greater than name_max.  If
-   comment is not Z_NULL, then up to comm_max characters are written there,
-   terminated with a zero unless the length is greater than comm_max.  When any
-   of extra, name, or comment are not Z_NULL and the respective field is not
-   present in the header, then that field is set to Z_NULL to signal its
-   absence.  This allows the use of deflateSetHeader() with the returned
-   structure to duplicate the header.  However if those fields are set to
-   allocated memory, then the application will need to save those pointers
-   elsewhere so that they can be eventually freed.
-
-     If inflateGetHeader is not used, then the header information is simply
-   discarded.  The header is always checked for validity, including the header
-   CRC if present.  inflateReset() will reset the process to discard the header
-   information.  The application would need to call inflateGetHeader() again to
-   retrieve the header from the next gzip stream.
-
-     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-/*
-ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
-                                        unsigned char FAR *window));
-
-     Initialize the internal stream state for decompression using inflateBack()
-   calls.  The fields zalloc, zfree and opaque in strm must be initialized
-   before the call.  If zalloc and zfree are Z_NULL, then the default library-
-   derived memory allocation routines are used.  windowBits is the base two
-   logarithm of the window size, in the range 8..15.  window is a caller
-   supplied buffer of that size.  Except for special applications where it is
-   assured that deflate was used with small window sizes, windowBits must be 15
-   and a 32K byte window must be supplied to be able to decompress general
-   deflate streams.
-
-     See inflateBack() for the usage of these routines.
-
-     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
-   the parameters are invalid, Z_MEM_ERROR if the internal state could not be
-   allocated, or Z_VERSION_ERROR if the version of the library does not match
-   the version of the header file.
-*/
-
-typedef unsigned (*in_func) OF((void FAR *, unsigned char FAR * FAR *));
-typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
-
-ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
-                                    in_func in, void FAR *in_desc,
-                                    out_func out, void FAR *out_desc));
-/*
-     inflateBack() does a raw inflate with a single call using a call-back
-   interface for input and output.  This is more efficient than inflate() for
-   file i/o applications in that it avoids copying between the output and the
-   sliding window by simply making the window itself the output buffer.  This
-   function trusts the application to not change the output buffer passed by
-   the output function, at least until inflateBack() returns.
-
-     inflateBackInit() must be called first to allocate the internal state
-   and to initialize the state with the user-provided window buffer.
-   inflateBack() may then be used multiple times to inflate a complete, raw
-   deflate stream with each call.  inflateBackEnd() is then called to free the
-   allocated state.
-
-     A raw deflate stream is one with no zlib or gzip header or trailer.
-   This routine would normally be used in a utility that reads zip or gzip
-   files and writes out uncompressed files.  The utility would decode the
-   header and process the trailer on its own, hence this routine expects only
-   the raw deflate stream to decompress.  This is different from the normal
-   behavior of inflate(), which expects either a zlib or gzip header and
-   trailer around the deflate stream.
-
-     inflateBack() uses two subroutines supplied by the caller that are then
-   called by inflateBack() for input and output.  inflateBack() calls those
-   routines until it reads a complete deflate stream and writes out all of the
-   uncompressed data, or until it encounters an error.  The function's
-   parameters and return types are defined above in the in_func and out_func
-   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
-   number of bytes of provided input, and a pointer to that input in buf.  If
-   there is no input available, in() must return zero--buf is ignored in that
-   case--and inflateBack() will return a buffer error.  inflateBack() will call
-   out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()
-   should return zero on success, or non-zero on failure.  If out() returns
-   non-zero, inflateBack() will return with an error.  Neither in() nor out()
-   are permitted to change the contents of the window provided to
-   inflateBackInit(), which is also the buffer that out() uses to write from.
-   The length written by out() will be at most the window size.  Any non-zero
-   amount of input may be provided by in().
-
-     For convenience, inflateBack() can be provided input on the first call by
-   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
-   in() will be called.  Therefore strm->next_in must be initialized before
-   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
-   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
-   must also be initialized, and then if strm->avail_in is not zero, input will
-   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].
-
-     The in_desc and out_desc parameters of inflateBack() is passed as the
-   first parameter of in() and out() respectively when they are called.  These
-   descriptors can be optionally used to pass any information that the caller-
-   supplied in() and out() functions need to do their job.
-
-     On return, inflateBack() will set strm->next_in and strm->avail_in to
-   pass back any unused input that was provided by the last in() call.  The
-   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
-   if in() or out() returned an error, Z_DATA_ERROR if there was a format error
-   in the deflate stream (in which case strm->msg is set to indicate the nature
-   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
-   In the case of Z_BUF_ERROR, an input or output error can be distinguished
-   using strm->next_in which will be Z_NULL only if in() returned an error.  If
-   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
-   non-zero.  (in() will always be called before out(), so strm->next_in is
-   assured to be defined if out() returns non-zero.) Note that inflateBack()
-   cannot return Z_OK.
-*/
-
-ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
-/*
-     All memory allocated by inflateBackInit() is freed.
-
-     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
-   state was inconsistent.
-*/
-
-ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
-/* Return flags indicating compile-time options.
-
-    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
-     1.0: size of uInt
-     3.2: size of uLong
-     5.4: size of voidpf (pointer)
-     7.6: size of z_off_t
-
-    Compiler, assembler, and debug options:
-     8: DEBUG
-     9: ASMV or ASMINF -- use ASM code
-     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
-     11: 0 (reserved)
-
-    One-time table building (smaller code, but not thread-safe if true):
-     12: BUILDFIXED -- build static block decoding tables when needed
-     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
-     14,15: 0 (reserved)
-
-    Library content (indicates missing functionality):
-     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
-                          deflate code when not needed)
-     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
-                    and decode gzip streams (to avoid linking crc code)
-     18-19: 0 (reserved)
-
-    Operation variations (changes in library functionality):
-     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
-     21: FASTEST -- deflate algorithm with only one, lowest compression level
-     22,23: 0 (reserved)
-
-    The sprintf variant used by gzprintf (zero is best):
-     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
-     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
-     26: 0 = returns value, 1 = void -- 1 means inferred string length returned
-
-    Remainder:
-     27-31: 0 (reserved)
- */
-
-#ifndef Z_SOLO
-
-                        /* utility functions */
-
-/*
-     The following utility functions are implemented on top of the basic
-   stream-oriented functions.  To simplify the interface, some default options
-   are assumed (compression level and memory usage, standard memory allocation
-   functions).  The source code of these utility functions can be modified if
-   you need special options.
-*/
-
-ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
-                                 const Bytef *source, uLong sourceLen));
-/*
-     Compresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer.  Upon entry, destLen is the total size
-   of the destination buffer, which must be at least the value returned by
-   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
-   compressed buffer.
-
-     compress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer.
-*/
-
-ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
-                                  const Bytef *source, uLong sourceLen,
-                                  int level));
-/*
-     Compresses the source buffer into the destination buffer.  The level
-   parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer.  Upon entry, destLen is the total size of the
-   destination buffer, which must be at least the value returned by
-   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
-   compressed buffer.
-
-     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
-   Z_STREAM_ERROR if the level parameter is invalid.
-*/
-
-ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
-/*
-     compressBound() returns an upper bound on the compressed size after
-   compress() or compress2() on sourceLen bytes.  It would be used before a
-   compress() or compress2() call to allocate the destination buffer.
-*/
-
-ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
-                                   const Bytef *source, uLong sourceLen));
-/*
-     Decompresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer.  Upon entry, destLen is the total size
-   of the destination buffer, which must be large enough to hold the entire
-   uncompressed data.  (The size of the uncompressed data must have been saved
-   previously by the compressor and transmitted to the decompressor by some
-   mechanism outside the scope of this compression library.) Upon exit, destLen
-   is the actual size of the uncompressed buffer.
-
-     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In
-   the case where there is not enough room, uncompress() will fill the output
-   buffer with the uncompressed data up to that point.
-*/
-
-                        /* gzip file access functions */
-
-/*
-     This library supports reading and writing files in gzip (.gz) format with
-   an interface similar to that of stdio, using the functions that start with
-   "gz".  The gzip format is different from the zlib format.  gzip is a gzip
-   wrapper, documented in RFC 1952, wrapped around a deflate stream.
-*/
-
-typedef struct gzFile_s *gzFile;    /* semi-opaque gzip file descriptor */
-
-/*
-ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));
-
-     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as
-   in fopen ("rb" or "wb") but can also include a compression level ("wb9") or
-   a strategy: 'f' for filtered data as in "wb6f", 'h' for Huffman-only
-   compression as in "wb1h", 'R' for run-length encoding as in "wb1R", or 'F'
-   for fixed code compression as in "wb9F".  (See the description of
-   deflateInit2 for more information about the strategy parameter.)  'T' will
-   request transparent writing or appending with no compression and not using
-   the gzip format.
-
-     "a" can be used instead of "w" to request that the gzip stream that will
-   be written be appended to the file.  "+" will result in an error, since
-   reading and writing to the same gzip file is not supported.  The addition of
-   "x" when writing will create the file exclusively, which fails if the file
-   already exists.  On systems that support it, the addition of "e" when
-   reading or writing will set the flag to close the file on an execve() call.
-
-     These functions, as well as gzip, will read and decode a sequence of gzip
-   streams in a file.  The append function of gzopen() can be used to create
-   such a file.  (Also see gzflush() for another way to do this.)  When
-   appending, gzopen does not test whether the file begins with a gzip stream,
-   nor does it look for the end of the gzip streams to begin appending.  gzopen
-   will simply append a gzip stream to the existing file.
-
-     gzopen can be used to read a file which is not in gzip format; in this
-   case gzread will directly read from the file without decompression.  When
-   reading, this will be detected automatically by looking for the magic two-
-   byte gzip header.
-
-     gzopen returns NULL if the file could not be opened, if there was
-   insufficient memory to allocate the gzFile state, or if an invalid mode was
-   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).
-   errno can be checked to determine if the reason gzopen failed was that the
-   file could not be opened.
-*/
-
-ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));
-/*
-     gzdopen associates a gzFile with the file descriptor fd.  File descriptors
-   are obtained from calls like open, dup, creat, pipe or fileno (if the file
-   has been previously opened with fopen).  The mode parameter is as in gzopen.
-
-     The next call of gzclose on the returned gzFile will also close the file
-   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
-   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
-   mode);.  The duplicated descriptor should be saved to avoid a leak, since
-   gzdopen does not close fd if it fails.  If you are using fileno() to get the
-   file descriptor from a FILE *, then you will have to use dup() to avoid
-   double-close()ing the file descriptor.  Both gzclose() and fclose() will
-   close the associated file descriptor, so they need to have different file
-   descriptors.
-
-     gzdopen returns NULL if there was insufficient memory to allocate the
-   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not
-   provided, or '+' was provided), or if fd is -1.  The file descriptor is not
-   used until the next gz* read, write, seek, or close operation, so gzdopen
-   will not detect if fd is invalid (unless fd is -1).
-*/
-
-ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));
-/*
-     Set the internal buffer size used by this library's functions.  The
-   default buffer size is 8192 bytes.  This function must be called after
-   gzopen() or gzdopen(), and before any other calls that read or write the
-   file.  The buffer memory allocation is always deferred to the first read or
-   write.  Two buffers are allocated, either both of the specified size when
-   writing, or one of the specified size and the other twice that size when
-   reading.  A larger buffer size of, for example, 64K or 128K bytes will
-   noticeably increase the speed of decompression (reading).
-
-     The new buffer size also affects the maximum length for gzprintf().
-
-     gzbuffer() returns 0 on success, or -1 on failure, such as being called
-   too late.
-*/
-
-ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
-/*
-     Dynamically update the compression level or strategy.  See the description
-   of deflateInit2 for the meaning of these parameters.
-
-     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
-   opened for writing.
-*/
-
-ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));
-/*
-     Reads the given number of uncompressed bytes from the compressed file.  If
-   the input file is not in gzip format, gzread copies the given number of
-   bytes into the buffer directly from the file.
-
-     After reaching the end of a gzip stream in the input, gzread will continue
-   to read, looking for another gzip stream.  Any number of gzip streams may be
-   concatenated in the input file, and will all be decompressed by gzread().
-   If something other than a gzip stream is encountered after a gzip stream,
-   that remaining trailing garbage is ignored (and no error is returned).
-
-     gzread can be used to read a gzip file that is being concurrently written.
-   Upon reaching the end of the input, gzread will return with the available
-   data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then
-   gzclearerr can be used to clear the end of file indicator in order to permit
-   gzread to be tried again.  Z_OK indicates that a gzip stream was completed
-   on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the
-   middle of a gzip stream.  Note that gzread does not return -1 in the event
-   of an incomplete gzip stream.  This error is deferred until gzclose(), which
-   will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip
-   stream.  Alternatively, gzerror can be used before gzclose to detect this
-   case.
-
-     gzread returns the number of uncompressed bytes actually read, less than
-   len for end of file, or -1 for error.
-*/
-
-ZEXTERN int ZEXPORT gzwrite OF((gzFile file,
-                                voidpc buf, unsigned len));
-/*
-     Writes the given number of uncompressed bytes into the compressed file.
-   gzwrite returns the number of uncompressed bytes written or 0 in case of
-   error.
-*/
-
-ZEXTERN int ZEXPORTVA gzprintf Z_ARG((gzFile file, const char *format, ...));
-/*
-     Converts, formats, and writes the arguments to the compressed file under
-   control of the format string, as in fprintf.  gzprintf returns the number of
-   uncompressed bytes actually written, or 0 in case of error.  The number of
-   uncompressed bytes written is limited to 8191, or one less than the buffer
-   size given to gzbuffer().  The caller should assure that this limit is not
-   exceeded.  If it is exceeded, then gzprintf() will return an error (0) with
-   nothing written.  In this case, there may also be a buffer overflow with
-   unpredictable consequences, which is possible only if zlib was compiled with
-   the insecure functions sprintf() or vsprintf() because the secure snprintf()
-   or vsnprintf() functions were not available.  This can be determined using
-   zlibCompileFlags().
-*/
-
-ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
-/*
-     Writes the given null-terminated string to the compressed file, excluding
-   the terminating null character.
-
-     gzputs returns the number of characters written, or -1 in case of error.
-*/
-
-ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
-/*
-     Reads bytes from the compressed file until len-1 characters are read, or a
-   newline character is read and transferred to buf, or an end-of-file
-   condition is encountered.  If any characters are read or if len == 1, the
-   string is terminated with a null character.  If no characters are read due
-   to an end-of-file or len < 1, then the buffer is left untouched.
-
-     gzgets returns buf which is a null-terminated string, or it returns NULL
-   for end-of-file or in case of error.  If there was an error, the contents at
-   buf are indeterminate.
-*/
-
-ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));
-/*
-     Writes c, converted to an unsigned char, into the compressed file.  gzputc
-   returns the value that was written, or -1 in case of error.
-*/
-
-ZEXTERN int ZEXPORT gzgetc OF((gzFile file));
-/*
-     Reads one byte from the compressed file.  gzgetc returns this byte or -1
-   in case of end of file or error.  This is implemented as a macro for speed.
-   As such, it does not do all of the checking the other functions do.  I.e.
-   it does not check to see if file is NULL, nor whether the structure file
-   points to has been clobbered or not.
-*/
-
-ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));
-/*
-     Push one character back onto the stream to be read as the first character
-   on the next read.  At least one character of push-back is allowed.
-   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will
-   fail if c is -1, and may fail if a character has been pushed but not read
-   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the
-   output buffer size of pushed characters is allowed.  (See gzbuffer above.)
-   The pushed character will be discarded if the stream is repositioned with
-   gzseek() or gzrewind().
-*/
-
-ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));
-/*
-     Flushes all pending output into the compressed file.  The parameter flush
-   is as in the deflate() function.  The return value is the zlib error number
-   (see function gzerror below).  gzflush is only permitted when writing.
-
-     If the flush parameter is Z_FINISH, the remaining data is written and the
-   gzip stream is completed in the output.  If gzwrite() is called again, a new
-   gzip stream will be started in the output.  gzread() is able to read such
-   concatented gzip streams.
-
-     gzflush should be called only when strictly necessary because it will
-   degrade compression if called too often.
-*/
-
-/*
-ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,
-                                   z_off_t offset, int whence));
-
-     Sets the starting position for the next gzread or gzwrite on the given
-   compressed file.  The offset represents a number of bytes in the
-   uncompressed data stream.  The whence parameter is defined as in lseek(2);
-   the value SEEK_END is not supported.
-
-     If the file is opened for reading, this function is emulated but can be
-   extremely slow.  If the file is opened for writing, only forward seeks are
-   supported; gzseek then compresses a sequence of zeroes up to the new
-   starting position.
-
-     gzseek returns the resulting offset location as measured in bytes from
-   the beginning of the uncompressed stream, or -1 in case of error, in
-   particular if the file is opened for writing and the new starting position
-   would be before the current position.
-*/
-
-ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
-/*
-     Rewinds the given file. This function is supported only for reading.
-
-     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
-*/
-
-/*
-ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
-
-     Returns the starting position for the next gzread or gzwrite on the given
-   compressed file.  This position represents a number of bytes in the
-   uncompressed data stream, and is zero when starting, even if appending or
-   reading a gzip stream from the middle of a file using gzdopen().
-
-     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
-*/
-
-/*
-ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));
-
-     Returns the current offset in the file being read or written.  This offset
-   includes the count of bytes that precede the gzip stream, for example when
-   appending or when using gzdopen() for reading.  When reading, the offset
-   does not include as yet unused buffered input.  This information can be used
-   for a progress indicator.  On error, gzoffset() returns -1.
-*/
-
-ZEXTERN int ZEXPORT gzeof OF((gzFile file));
-/*
-     Returns true (1) if the end-of-file indicator has been set while reading,
-   false (0) otherwise.  Note that the end-of-file indicator is set only if the
-   read tried to go past the end of the input, but came up short.  Therefore,
-   just like feof(), gzeof() may return false even if there is no more data to
-   read, in the event that the last read request was for the exact number of
-   bytes remaining in the input file.  This will happen if the input file size
-   is an exact multiple of the buffer size.
-
-     If gzeof() returns true, then the read functions will return no more data,
-   unless the end-of-file indicator is reset by gzclearerr() and the input file
-   has grown since the previous end of file was detected.
-*/
-
-ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
-/*
-     Returns true (1) if file is being copied directly while reading, or false
-   (0) if file is a gzip stream being decompressed.
-
-     If the input file is empty, gzdirect() will return true, since the input
-   does not contain a gzip stream.
-
-     If gzdirect() is used immediately after gzopen() or gzdopen() it will
-   cause buffers to be allocated to allow reading the file to determine if it
-   is a gzip file.  Therefore if gzbuffer() is used, it should be called before
-   gzdirect().
-
-     When writing, gzdirect() returns true (1) if transparent writing was
-   requested ("wT" for the gzopen() mode), or false (0) otherwise.  (Note:
-   gzdirect() is not needed when writing.  Transparent writing must be
-   explicitly requested, so the application already knows the answer.  When
-   linking statically, using gzdirect() will include all of the zlib code for
-   gzip file reading and decompression, which may not be desired.)
-*/
-
-ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
-/*
-     Flushes all pending output if necessary, closes the compressed file and
-   deallocates the (de)compression state.  Note that once file is closed, you
-   cannot call gzerror with file, since its structures have been deallocated.
-   gzclose must not be called more than once on the same file, just as free
-   must not be called more than once on the same allocation.
-
-     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a
-   file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the
-   last read ended in the middle of a gzip stream, or Z_OK on success.
-*/
-
-ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));
-ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));
-/*
-     Same as gzclose(), but gzclose_r() is only for use when reading, and
-   gzclose_w() is only for use when writing or appending.  The advantage to
-   using these instead of gzclose() is that they avoid linking in zlib
-   compression or decompression code that is not used when only reading or only
-   writing respectively.  If gzclose() is used, then both compression and
-   decompression code will be included the application when linking to a static
-   zlib library.
-*/
-
-ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
-/*
-     Returns the error message for the last error which occurred on the given
-   compressed file.  errnum is set to zlib error number.  If an error occurred
-   in the file system and not in the compression library, errnum is set to
-   Z_ERRNO and the application may consult errno to get the exact error code.
-
-     The application must not modify the returned string.  Future calls to
-   this function may invalidate the previously returned string.  If file is
-   closed, then the string previously returned by gzerror will no longer be
-   available.
-
-     gzerror() should be used to distinguish errors from end-of-file for those
-   functions above that do not distinguish those cases in their return values.
-*/
-
-ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
-/*
-     Clears the error and end-of-file flags for file.  This is analogous to the
-   clearerr() function in stdio.  This is useful for continuing to read a gzip
-   file that is being written concurrently.
-*/
-
-#endif /* !Z_SOLO */
-
-                        /* checksum functions */
-
-/*
-     These functions are not related to compression but are exported
-   anyway because they might be useful in applications using the compression
-   library.
-*/
-
-ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
-/*
-     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
-   return the updated checksum.  If buf is Z_NULL, this function returns the
-   required initial value for the checksum.
-
-     An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
-   much faster.
-
-   Usage example:
-
-     uLong adler = adler32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       adler = adler32(adler, buffer, length);
-     }
-     if (adler != original_adler) error();
-*/
-
-/*
-ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
-                                          z_off_t len2));
-
-     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
-   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
-   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
-   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note
-   that the z_off_t type (like off_t) is a signed integer.  If len2 is
-   negative, the result has no meaning or utility.
-*/
-
-ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
-/*
-     Update a running CRC-32 with the bytes buf[0..len-1] and return the
-   updated CRC-32.  If buf is Z_NULL, this function returns the required
-   initial value for the crc.  Pre- and post-conditioning (one's complement) is
-   performed within this function so it shouldn't be done by the application.
-
-   Usage example:
-
-     uLong crc = crc32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       crc = crc32(crc, buffer, length);
-     }
-     if (crc != original_crc) error();
-*/
-
-/*
-ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));
-
-     Combine two CRC-32 check values into one.  For two sequences of bytes,
-   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
-   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
-   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
-   len2.
-*/
-
-
-                        /* various hacks, don't look :) */
-
-/* deflateInit and inflateInit are macros to allow checking the zlib version
- * and the compiler's view of z_stream:
- */
-ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
-                                      int windowBits, int memLevel,
-                                      int strategy, const char *version,
-                                      int stream_size));
-ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
-                                      const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
-                                         unsigned char FAR *window,
-                                         const char *version,
-                                         int stream_size));
-#define deflateInit(strm, level) \
-        deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
-#define inflateInit(strm) \
-        inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
-#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
-        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
-                      (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
-#define inflateInit2(strm, windowBits) \
-        inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
-                      (int)sizeof(z_stream))
-#define inflateBackInit(strm, windowBits, window) \
-        inflateBackInit_((strm), (windowBits), (window), \
-                      ZLIB_VERSION, (int)sizeof(z_stream))
-
-#ifndef Z_SOLO
-
-/* gzgetc() macro and its supporting function and exposed data structure.  Note
- * that the real internal state is much larger than the exposed structure.
- * This abbreviated structure exposes just enough for the gzgetc() macro.  The
- * user should not mess with these exposed elements, since their names or
- * behavior could change in the future, perhaps even capriciously.  They can
- * only be used by the gzgetc() macro.  You have been warned.
- */
-struct gzFile_s {
-    unsigned have;
-    unsigned char *next;
-    z_off64_t pos;
-};
-ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  /* backward compatibility */
-#ifdef Z_PREFIX_SET
-#  undef z_gzgetc
-#  define z_gzgetc(g) \
-          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : gzgetc(g))
-#else
-#  define gzgetc(g) \
-          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : gzgetc(g))
-#endif
-
-/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or
- * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if
- * both are true, the application gets the *64 functions, and the regular
- * functions are changed to 64 bits) -- in case these are set on systems
- * without large file support, _LFS64_LARGEFILE must also be true
- */
-#ifdef Z_LARGE64
-   ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-   ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
-   ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
-   ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
-   ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));
-   ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));
-#endif
-
-#if !defined(ZLIB_INTERNAL) && defined(Z_WANT64)
-#  ifdef Z_PREFIX_SET
-#    define z_gzopen z_gzopen64
-#    define z_gzseek z_gzseek64
-#    define z_gztell z_gztell64
-#    define z_gzoffset z_gzoffset64
-#    define z_adler32_combine z_adler32_combine64
-#    define z_crc32_combine z_crc32_combine64
-#  else
-#    define gzopen gzopen64
-#    define gzseek gzseek64
-#    define gztell gztell64
-#    define gzoffset gzoffset64
-#    define adler32_combine adler32_combine64
-#    define crc32_combine crc32_combine64
-#  endif
-#  ifndef Z_LARGE64
-     ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-     ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));
-     ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));
-     ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));
-     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
-     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
-#  endif
-#else
-   ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));
-   ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));
-   ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));
-   ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));
-   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
-   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
-#endif
-
-#else /* Z_SOLO */
-
-   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
-   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
-
-#endif /* !Z_SOLO */
-
-/* hack for buggy compilers */
-#if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)
-    struct internal_state {int dummy;};
-#endif
-
-/* undocumented functions */
-ZEXTERN const char   * ZEXPORT zError           OF((int));
-ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));
-ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table    OF((void));
-ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));
-ZEXTERN int            ZEXPORT inflateResetKeep OF((z_streamp));
-ZEXTERN int            ZEXPORT deflateResetKeep OF((z_streamp));
-#if defined(_WIN32) && !defined(Z_SOLO)
-ZEXTERN gzFile         ZEXPORT gzopen_w OF((const wchar_t *path,
-                                            const char *mode));
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZLIB_H */
diff -Nbaur gcc-4.8.1/zlib/zlib.map gcc-4.8.1-ppc/zlib/zlib.map
--- gcc-4.8.1/zlib/zlib.map	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/zlib.map	1970-01-01 01:00:00.000000000 +0100
@@ -1,78 +0,0 @@
-ZLIB_1.2.0 {
-  global:
-    compressBound;
-    deflateBound;
-    inflateBack;
-    inflateBackEnd;
-    inflateBackInit_;
-    inflateCopy;
-  local:
-    deflate_copyright;
-    inflate_copyright;
-    inflate_fast;
-    inflate_table;
-    zcalloc;
-    zcfree;
-    z_errmsg;
-    gz_error;
-    gz_intmax;
-    _*;
-};
-
-ZLIB_1.2.0.2 {
-    gzclearerr;
-    gzungetc;
-    zlibCompileFlags;
-} ZLIB_1.2.0;
-
-ZLIB_1.2.0.8 {
-    deflatePrime;
-} ZLIB_1.2.0.2;
-
-ZLIB_1.2.2 {
-    adler32_combine;
-    crc32_combine;
-    deflateSetHeader;
-    inflateGetHeader;
-} ZLIB_1.2.0.8;
-
-ZLIB_1.2.2.3 {
-    deflateTune;
-    gzdirect;
-} ZLIB_1.2.2;
-
-ZLIB_1.2.2.4 {
-    inflatePrime;
-} ZLIB_1.2.2.3;
-
-ZLIB_1.2.3.3 {
-    adler32_combine64;
-    crc32_combine64;
-    gzopen64;
-    gzseek64;
-    gztell64;
-    inflateUndermine;
-} ZLIB_1.2.2.4;
-
-ZLIB_1.2.3.4 {
-    inflateReset2;
-    inflateMark;
-} ZLIB_1.2.3.3;
-
-ZLIB_1.2.3.5 {
-    gzbuffer;
-    gzoffset;
-    gzoffset64;
-    gzclose_r;
-    gzclose_w;
-} ZLIB_1.2.3.4;
-
-ZLIB_1.2.5.1 {
-    deflatePending;
-} ZLIB_1.2.3.5;
-
-ZLIB_1.2.5.2 {
-    deflateResetKeep;
-    gzgetc_;
-    inflateResetKeep;
-} ZLIB_1.2.5.1;
diff -Nbaur gcc-4.8.1/zlib/zlib.pc.cmakein gcc-4.8.1-ppc/zlib/zlib.pc.cmakein
--- gcc-4.8.1/zlib/zlib.pc.cmakein	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/zlib.pc.cmakein	1970-01-01 01:00:00.000000000 +0100
@@ -1,13 +0,0 @@
-prefix=@CMAKE_INSTALL_PREFIX@
-exec_prefix=@CMAKE_INSTALL_PREFIX@
-libdir=@INSTALL_LIB_DIR@
-sharedlibdir=@INSTALL_LIB_DIR@
-includedir=@INSTALL_INC_DIR@
-
-Name: zlib
-Description: zlib compression library
-Version: @VERSION@
-
-Requires:
-Libs: -L${libdir} -L${sharedlibdir} -lz
-Cflags: -I${includedir}
diff -Nbaur gcc-4.8.1/zlib/zlib.pc.in gcc-4.8.1-ppc/zlib/zlib.pc.in
--- gcc-4.8.1/zlib/zlib.pc.in	2012-03-02 17:15:20.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/zlib.pc.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,13 +0,0 @@
-prefix=@prefix@
-exec_prefix=@exec_prefix@
-libdir=@libdir@
-sharedlibdir=@sharedlibdir@
-includedir=@includedir@
-
-Name: zlib
-Description: zlib compression library
-Version: @VERSION@
-
-Requires:
-Libs: -L${libdir} -L${sharedlibdir} -lz
-Cflags: -I${includedir}
diff -Nbaur gcc-4.8.1/zlib/zutil.c gcc-4.8.1-ppc/zlib/zutil.c
--- gcc-4.8.1/zlib/zutil.c	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/zutil.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,324 +0,0 @@
-/* zutil.c -- target dependent utility functions for the compression library
- * Copyright (C) 1995-2005, 2010, 2011, 2012 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id: zutil.c,v 1.1.1.2 2002/03/11 21:53:27 tromey Exp $ */
-
-#include "zutil.h"
-#ifndef Z_SOLO
-#  include "gzguts.h"
-#endif
-
-#ifndef NO_DUMMY_DECL
-struct internal_state      {int dummy;}; /* for buggy compilers */
-#endif
-
-const char * const z_errmsg[10] = {
-"need dictionary",     /* Z_NEED_DICT       2  */
-"stream end",          /* Z_STREAM_END      1  */
-"",                    /* Z_OK              0  */
-"file error",          /* Z_ERRNO         (-1) */
-"stream error",        /* Z_STREAM_ERROR  (-2) */
-"data error",          /* Z_DATA_ERROR    (-3) */
-"insufficient memory", /* Z_MEM_ERROR     (-4) */
-"buffer error",        /* Z_BUF_ERROR     (-5) */
-"incompatible version",/* Z_VERSION_ERROR (-6) */
-""};
-
-
-const char * ZEXPORT zlibVersion()
-{
-    return ZLIB_VERSION;
-}
-
-uLong ZEXPORT zlibCompileFlags()
-{
-    uLong flags;
-
-    flags = 0;
-    switch ((int)(sizeof(uInt))) {
-    case 2:     break;
-    case 4:     flags += 1;     break;
-    case 8:     flags += 2;     break;
-    default:    flags += 3;
-    }
-    switch ((int)(sizeof(uLong))) {
-    case 2:     break;
-    case 4:     flags += 1 << 2;        break;
-    case 8:     flags += 2 << 2;        break;
-    default:    flags += 3 << 2;
-    }
-    switch ((int)(sizeof(voidpf))) {
-    case 2:     break;
-    case 4:     flags += 1 << 4;        break;
-    case 8:     flags += 2 << 4;        break;
-    default:    flags += 3 << 4;
-    }
-    switch ((int)(sizeof(z_off_t))) {
-    case 2:     break;
-    case 4:     flags += 1 << 6;        break;
-    case 8:     flags += 2 << 6;        break;
-    default:    flags += 3 << 6;
-    }
-#ifdef DEBUG
-    flags += 1 << 8;
-#endif
-#if defined(ASMV) || defined(ASMINF)
-    flags += 1 << 9;
-#endif
-#ifdef ZLIB_WINAPI
-    flags += 1 << 10;
-#endif
-#ifdef BUILDFIXED
-    flags += 1 << 12;
-#endif
-#ifdef DYNAMIC_CRC_TABLE
-    flags += 1 << 13;
-#endif
-#ifdef NO_GZCOMPRESS
-    flags += 1L << 16;
-#endif
-#ifdef NO_GZIP
-    flags += 1L << 17;
-#endif
-#ifdef PKZIP_BUG_WORKAROUND
-    flags += 1L << 20;
-#endif
-#ifdef FASTEST
-    flags += 1L << 21;
-#endif
-#if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#  ifdef NO_vsnprintf
-    flags += 1L << 25;
-#    ifdef HAS_vsprintf_void
-    flags += 1L << 26;
-#    endif
-#  else
-#    ifdef HAS_vsnprintf_void
-    flags += 1L << 26;
-#    endif
-#  endif
-#else
-    flags += 1L << 24;
-#  ifdef NO_snprintf
-    flags += 1L << 25;
-#    ifdef HAS_sprintf_void
-    flags += 1L << 26;
-#    endif
-#  else
-#    ifdef HAS_snprintf_void
-    flags += 1L << 26;
-#    endif
-#  endif
-#endif
-    return flags;
-}
-
-#ifdef DEBUG
-
-#  ifndef verbose
-#    define verbose 0
-#  endif
-int ZLIB_INTERNAL z_verbose = verbose;
-
-void ZLIB_INTERNAL z_error (m)
-    char *m;
-{
-    fprintf(stderr, "%s\n", m);
-    exit(1);
-}
-#endif
-
-/* exported to allow conversion of error code to string for compress() and
- * uncompress()
- */
-const char * ZEXPORT zError(err)
-    int err;
-{
-    return ERR_MSG(err);
-}
-
-#if defined(_WIN32_WCE)
-    /* The Microsoft C Run-Time Library for Windows CE doesn't have
-     * errno.  We define it as a global variable to simplify porting.
-     * Its value is always 0 and should not be used.
-     */
-    int errno = 0;
-#endif
-
-#ifndef HAVE_MEMCPY
-
-void ZLIB_INTERNAL zmemcpy(dest, source, len)
-    Bytef* dest;
-    const Bytef* source;
-    uInt  len;
-{
-    if (len == 0) return;
-    do {
-        *dest++ = *source++; /* ??? to be unrolled */
-    } while (--len != 0);
-}
-
-int ZLIB_INTERNAL zmemcmp(s1, s2, len)
-    const Bytef* s1;
-    const Bytef* s2;
-    uInt  len;
-{
-    uInt j;
-
-    for (j = 0; j < len; j++) {
-        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
-    }
-    return 0;
-}
-
-void ZLIB_INTERNAL zmemzero(dest, len)
-    Bytef* dest;
-    uInt  len;
-{
-    if (len == 0) return;
-    do {
-        *dest++ = 0;  /* ??? to be unrolled */
-    } while (--len != 0);
-}
-#endif
-
-#ifndef Z_SOLO
-
-#ifdef SYS16BIT
-
-#ifdef __TURBOC__
-/* Turbo C in 16-bit mode */
-
-#  define MY_ZCALLOC
-
-/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
- * and farmalloc(64K) returns a pointer with an offset of 8, so we
- * must fix the pointer. Warning: the pointer must be put back to its
- * original form in order to free it, use zcfree().
- */
-
-#define MAX_PTR 10
-/* 10*64K = 640K */
-
-local int next_ptr = 0;
-
-typedef struct ptr_table_s {
-    voidpf org_ptr;
-    voidpf new_ptr;
-} ptr_table;
-
-local ptr_table table[MAX_PTR];
-/* This table is used to remember the original form of pointers
- * to large buffers (64K). Such pointers are normalized with a zero offset.
- * Since MSDOS is not a preemptive multitasking OS, this table is not
- * protected from concurrent access. This hack doesn't work anyway on
- * a protected system like OS/2. Use Microsoft C instead.
- */
-
-voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, unsigned items, unsigned size)
-{
-    voidpf buf = opaque; /* just to make some compilers happy */
-    ulg bsize = (ulg)items*size;
-
-    /* If we allocate less than 65520 bytes, we assume that farmalloc
-     * will return a usable pointer which doesn't have to be normalized.
-     */
-    if (bsize < 65520L) {
-        buf = farmalloc(bsize);
-        if (*(ush*)&buf != 0) return buf;
-    } else {
-        buf = farmalloc(bsize + 16L);
-    }
-    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
-    table[next_ptr].org_ptr = buf;
-
-    /* Normalize the pointer to seg:0 */
-    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
-    *(ush*)&buf = 0;
-    table[next_ptr++].new_ptr = buf;
-    return buf;
-}
-
-void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
-{
-    int n;
-    if (*(ush*)&ptr != 0) { /* object < 64K */
-        farfree(ptr);
-        return;
-    }
-    /* Find the original pointer */
-    for (n = 0; n < next_ptr; n++) {
-        if (ptr != table[n].new_ptr) continue;
-
-        farfree(table[n].org_ptr);
-        while (++n < next_ptr) {
-            table[n-1] = table[n];
-        }
-        next_ptr--;
-        return;
-    }
-    ptr = opaque; /* just to make some compilers happy */
-    Assert(0, "zcfree: ptr not found");
-}
-
-#endif /* __TURBOC__ */
-
-
-#ifdef M_I86
-/* Microsoft C in 16-bit mode */
-
-#  define MY_ZCALLOC
-
-#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
-#  define _halloc  halloc
-#  define _hfree   hfree
-#endif
-
-voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, uInt items, uInt size)
-{
-    if (opaque) opaque = 0; /* to make compiler happy */
-    return _halloc((long)items, size);
-}
-
-void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
-{
-    if (opaque) opaque = 0; /* to make compiler happy */
-    _hfree(ptr);
-}
-
-#endif /* M_I86 */
-
-#endif /* SYS16BIT */
-
-
-#ifndef MY_ZCALLOC /* Any system without a special alloc function */
-
-#ifndef STDC
-extern voidp  malloc OF((uInt size));
-extern voidp  calloc OF((uInt items, uInt size));
-extern void   free   OF((voidpf ptr));
-#endif
-
-voidpf ZLIB_INTERNAL zcalloc (opaque, items, size)
-    voidpf opaque;
-    unsigned items;
-    unsigned size;
-{
-    if (opaque) items += size - size; /* make compiler happy */
-    return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
-                              (voidpf)calloc(items, size);
-}
-
-void ZLIB_INTERNAL zcfree (opaque, ptr)
-    voidpf opaque;
-    voidpf ptr;
-{
-    free(ptr);
-    if (opaque) return; /* make compiler happy */
-}
-
-#endif /* MY_ZCALLOC */
-
-#endif /* !Z_SOLO */
diff -Nbaur gcc-4.8.1/zlib/zutil.h gcc-4.8.1-ppc/zlib/zutil.h
--- gcc-4.8.1/zlib/zutil.h	2012-11-16 18:35:05.000000000 +0000
+++ gcc-4.8.1-ppc/zlib/zutil.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,252 +0,0 @@
-/* zutil.h -- internal interface and configuration of the compression library
- * Copyright (C) 1995-2012 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* @(#) $Id: zutil.h,v 1.1.1.2 2002/03/11 21:53:28 tromey Exp $ */
-
-#ifndef ZUTIL_H
-#define ZUTIL_H
-
-#ifdef HAVE_HIDDEN
-#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
-#else
-#  define ZLIB_INTERNAL
-#endif
-
-#include "zlib.h"
-
-#if defined(STDC) && !defined(Z_SOLO)
-#  if !(defined(_WIN32_WCE) && defined(_MSC_VER))
-#    include <stddef.h>
-#  endif
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-
-#ifdef Z_SOLO
-   typedef long ptrdiff_t;  /* guess -- will be caught if guess is wrong */
-#endif
-
-#ifndef local
-#  define local static
-#endif
-/* compile with -Dlocal if your debugger can't find static symbols */
-
-typedef unsigned char  uch;
-typedef uch FAR uchf;
-typedef unsigned short ush;
-typedef ush FAR ushf;
-typedef unsigned long  ulg;
-
-extern const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
-/* (size given to avoid silly warnings with Visual C++) */
-
-#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
-
-#define ERR_RETURN(strm,err) \
-  return (strm->msg = (char*)ERR_MSG(err), (err))
-/* To be used only when the state is known to be valid */
-
-        /* common constants */
-
-#ifndef DEF_WBITS
-#  define DEF_WBITS MAX_WBITS
-#endif
-/* default windowBits for decompression. MAX_WBITS is for compression only */
-
-#if MAX_MEM_LEVEL >= 8
-#  define DEF_MEM_LEVEL 8
-#else
-#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#endif
-/* default memLevel */
-
-#define STORED_BLOCK 0
-#define STATIC_TREES 1
-#define DYN_TREES    2
-/* The three kinds of block type */
-
-#define MIN_MATCH  3
-#define MAX_MATCH  258
-/* The minimum and maximum match lengths */
-
-#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */
-
-        /* target dependencies */
-
-#if defined(MSDOS) || (defined(WINDOWS) && !defined(WIN32))
-#  define OS_CODE  0x00
-#  ifndef Z_SOLO
-#    if defined(__TURBOC__) || defined(__BORLANDC__)
-#      if (__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
-         /* Allow compilation with ANSI keywords only enabled */
-         void _Cdecl farfree( void *block );
-         void *_Cdecl farmalloc( unsigned long nbytes );
-#      else
-#        include <alloc.h>
-#      endif
-#    else /* MSC or DJGPP */
-#      include <malloc.h>
-#    endif
-#  endif
-#endif
-
-#ifdef AMIGA
-#  define OS_CODE  0x01
-#endif
-
-#if defined(VAXC) || defined(VMS)
-#  define OS_CODE  0x02
-#  define F_OPEN(name, mode) \
-     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
-#endif
-
-#if defined(ATARI) || defined(atarist)
-#  define OS_CODE  0x05
-#endif
-
-#ifdef OS2
-#  define OS_CODE  0x06
-#  if defined(M_I86) && !defined(Z_SOLO)
-#    include <malloc.h>
-#  endif
-#endif
-
-#if defined(MACOS) || defined(TARGET_OS_MAC)
-#  define OS_CODE  0x07
-#  ifndef Z_SOLO
-#    if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
-#      include <unix.h> /* for fdopen */
-#    else
-#      ifndef fdopen
-#        define fdopen(fd,mode) NULL /* No fdopen() */
-#      endif
-#    endif
-#  endif
-#endif
-
-#ifdef TOPS20
-#  define OS_CODE  0x0a
-#endif
-
-#ifdef WIN32
-#  ifndef __CYGWIN__  /* Cygwin is Unix, not Win32 */
-#    define OS_CODE  0x0b
-#  endif
-#endif
-
-#ifdef __50SERIES /* Prime/PRIMOS */
-#  define OS_CODE  0x0f
-#endif
-
-#if defined(_BEOS_) || defined(RISCOS)
-#  define fdopen(fd,mode) NULL /* No fdopen() */
-#endif
-
-#if (defined(_MSC_VER) && (_MSC_VER > 600)) && !defined __INTERIX
-#  if defined(_WIN32_WCE)
-#    define fdopen(fd,mode) NULL /* No fdopen() */
-#    ifndef _PTRDIFF_T_DEFINED
-       typedef int ptrdiff_t;
-#      define _PTRDIFF_T_DEFINED
-#    endif
-#  else
-#    define fdopen(fd,type)  _fdopen(fd,type)
-#  endif
-#endif
-
-#if defined(__BORLANDC__) && !defined(MSDOS)
-  #pragma warn -8004
-  #pragma warn -8008
-  #pragma warn -8066
-#endif
-
-/* provide prototypes for these when building zlib without LFS */
-#if !defined(_WIN32) && (!defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0)
-    ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
-    ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
-#endif
-
-        /* common defaults */
-
-#ifndef OS_CODE
-#  define OS_CODE  0x03  /* assume Unix */
-#endif
-
-#ifndef F_OPEN
-#  define F_OPEN(name, mode) fopen((name), (mode))
-#endif
-
-         /* functions */
-
-#if defined(pyr) || defined(Z_SOLO)
-#  define NO_MEMCPY
-#endif
-#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
- /* Use our own functions for small and medium model with MSC <= 5.0.
-  * You may have to use the same strategy for Borland C (untested).
-  * The __SC__ check is for Symantec.
-  */
-#  define NO_MEMCPY
-#endif
-#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
-#  define HAVE_MEMCPY
-#endif
-#ifdef HAVE_MEMCPY
-#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
-#    define zmemcpy _fmemcpy
-#    define zmemcmp _fmemcmp
-#    define zmemzero(dest, len) _fmemset(dest, 0, len)
-#  else
-#    define zmemcpy memcpy
-#    define zmemcmp memcmp
-#    define zmemzero(dest, len) memset(dest, 0, len)
-#  endif
-#else
-   void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));
-   int ZLIB_INTERNAL zmemcmp OF((const Bytef* s1, const Bytef* s2, uInt len));
-   void ZLIB_INTERNAL zmemzero OF((Bytef* dest, uInt len));
-#endif
-
-/* Diagnostic functions */
-#ifdef DEBUG
-#  include <stdio.h>
-   extern int ZLIB_INTERNAL z_verbose;
-   extern void ZLIB_INTERNAL z_error OF((char *m));
-#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
-#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
-#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
-#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
-#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
-#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
-#else
-#  define Assert(cond,msg)
-#  define Trace(x)
-#  define Tracev(x)
-#  define Tracevv(x)
-#  define Tracec(c,x)
-#  define Tracecv(c,x)
-#endif
-
-#ifndef Z_SOLO
-   voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,
-                                    unsigned size));
-   void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));
-#endif
-
-#define ZALLOC(strm, items, size) \
-           (*((strm)->zalloc))((strm)->opaque, (items), (size))
-#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
-#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
-
-/* Reverse the bytes in a 32-bit value */
-#define ZSWAP32(q) ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
-                    (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))
-
-#endif /* ZUTIL_H */
