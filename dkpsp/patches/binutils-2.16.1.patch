diff -NBaur binutils-2.16.1/bfd/Makefile.am binutils-2.16.1-psp/bfd/Makefile.am
--- binutils-2.16.1/bfd/Makefile.am	Sun Jun 12 19:58:52 2005
+++ binutils-2.16.1-psp/bfd/Makefile.am	Mon Jul 25 20:30:03 2005
@@ -3,7 +3,7 @@
 AUTOMAKE_OPTIONS = 1.9 cygnus
 
 # Uncomment the following line when doing a release.
-RELEASE=y
+#RELEASE=y
 
 INCDIR = $(srcdir)/../include
 CSEARCH = -I. -I$(srcdir) -I$(INCDIR)
diff -NBaur binutils-2.16.1/bfd/Makefile.in binutils-2.16.1-psp/bfd/Makefile.in
--- binutils-2.16.1/bfd/Makefile.in	Sun Jun 12 19:58:55 2005
+++ binutils-2.16.1-psp/bfd/Makefile.in	Mon Jul 25 20:30:03 2005
@@ -250,7 +250,7 @@
 AUTOMAKE_OPTIONS = 1.9 cygnus
 
 # Uncomment the following line when doing a release.
-RELEASE=y
+#RELEASE=y
 INCDIR = $(srcdir)/../include
 CSEARCH = -I. -I$(srcdir) -I$(INCDIR)
 MKDEP = gcc -MM
diff -NBaur binutils-2.16.1/bfd/archures.c binutils-2.16.1-psp/bfd/archures.c
--- binutils-2.16.1/bfd/archures.c	Mon Jan 17 14:08:03 2005
+++ binutils-2.16.1-psp/bfd/archures.c	Mon Jul 25 20:30:03 2005
@@ -155,6 +155,7 @@
 .#define bfd_mach_mips16		16
 .#define bfd_mach_mips5                 5
 .#define bfd_mach_mips_sb1              12310201 {* octal 'SB', 01 *}
+.#define bfd_mach_mips_allegrex         10111431 {* octal 'AL', 31 *}
 .#define bfd_mach_mipsisa32             32
 .#define bfd_mach_mipsisa32r2           33
 .#define bfd_mach_mipsisa64             64
diff -NBaur binutils-2.16.1/bfd/bfd-in2.h binutils-2.16.1-psp/bfd/bfd-in2.h
--- binutils-2.16.1/bfd/bfd-in2.h	Wed Mar  2 21:23:20 2005
+++ binutils-2.16.1-psp/bfd/bfd-in2.h	Mon Jul 25 20:30:03 2005
@@ -1600,6 +1600,7 @@
 #define bfd_mach_mips16                16
 #define bfd_mach_mips5                 5
 #define bfd_mach_mips_sb1              12310201 /* octal 'SB', 01 */
+#define bfd_mach_mips_allegrex         10111431 /* octal 'AL', 31 */
 #define bfd_mach_mipsisa32             32
 #define bfd_mach_mipsisa32r2           33
 #define bfd_mach_mipsisa64             64
diff -NBaur binutils-2.16.1/bfd/cpu-mips.c binutils-2.16.1-psp/bfd/cpu-mips.c
--- binutils-2.16.1/bfd/cpu-mips.c	Thu Mar  3 11:40:58 2005
+++ binutils-2.16.1-psp/bfd/cpu-mips.c	Mon Jul 25 20:30:03 2005
@@ -86,6 +86,7 @@
   I_mipsisa64,
   I_mipsisa64r2,
   I_sb1,
+  I_allegrex,
 };
 
 #define NN(index) (&arch_info_struct[(index) + 1])
@@ -118,7 +119,8 @@
   N (32, 32, bfd_mach_mipsisa32r2,"mips:isa32r2", FALSE, NN(I_mipsisa32r2)),
   N (64, 64, bfd_mach_mipsisa64,  "mips:isa64",   FALSE, NN(I_mipsisa64)),
   N (64, 64, bfd_mach_mipsisa64r2,"mips:isa64r2", FALSE, NN(I_mipsisa64r2)),
-  N (64, 64, bfd_mach_mips_sb1, "mips:sb1",       FALSE, 0),
+  N (64, 64, bfd_mach_mips_sb1, "mips:sb1",       FALSE, NN(I_sb1)),
+  N (32, 32, bfd_mach_mips_allegrex, "mips:allegrex", FALSE, 0),
 };
 
 /* The default architecture is mips:3000, but with a machine number of
diff -NBaur binutils-2.16.1/bfd/elfxx-mips.c binutils-2.16.1-psp/bfd/elfxx-mips.c
--- binutils-2.16.1/bfd/elfxx-mips.c	Sat May 28 22:58:29 2005
+++ binutils-2.16.1-psp/bfd/elfxx-mips.c	Mon Jul 25 20:30:03 2005
@@ -4669,6 +4669,9 @@
     case E_MIPS_MACH_SB1:
       return bfd_mach_mips_sb1;
 
+    case E_MIPS_MACH_ALLEGREX:
+      return bfd_mach_mips_allegrex;
+
     default:
       switch (flags & EF_MIPS_ARCH)
 	{
@@ -7941,6 +7944,10 @@
       val = E_MIPS_ARCH_64 | E_MIPS_MACH_SB1;
       break;
 
+    case bfd_mach_mips_allegrex:
+      val = E_MIPS_ARCH_2 | E_MIPS_MACH_ALLEGREX;
+      break;
+
     case bfd_mach_mipsisa32:
       val = E_MIPS_ARCH_32;
       break;
@@ -9641,6 +9648,7 @@
   /* MIPS II extensions.  */
   { bfd_mach_mips4000, bfd_mach_mips6000 },
   { bfd_mach_mipsisa32, bfd_mach_mips6000 },
+  { bfd_mach_mips_allegrex, bfd_mach_mips6000 },
 
   /* MIPS I extensions.  */
   { bfd_mach_mips6000, bfd_mach_mips3000 },
diff -NBaur binutils-2.16.1/bfd/version.h binutils-2.16.1-psp/bfd/version.h
--- binutils-2.16.1/bfd/version.h	Sun Jun 12 18:37:59 2005
+++ binutils-2.16.1-psp/bfd/version.h	Mon Jul 25 20:30:55 2005
@@ -1,3 +1,3 @@
-#define BFD_VERSION_DATE 20050612
+#define BFD_VERSION_DATE (PSPDEV 20050722)
 #define BFD_VERSION @bfd_version@
 #define BFD_VERSION_STRING @bfd_version_string@
diff -NBaur binutils-2.16.1/binutils/readelf.c binutils-2.16.1-psp/binutils/readelf.c
--- binutils-2.16.1/binutils/readelf.c	Wed Apr 20 19:43:36 2005
+++ binutils-2.16.1-psp/binutils/readelf.c	Mon Jul 25 20:30:03 2005
@@ -2043,6 +2043,7 @@
 	    case E_MIPS_MACH_5500: strcat (buf, ", 5500"); break;
 	    case E_MIPS_MACH_SB1:  strcat (buf, ", sb1");  break;
 	    case E_MIPS_MACH_9000: strcat (buf, ", 9000"); break;
+	    case E_MIPS_MACH_ALLEGREX: strcat (buf, ", allegrex"); break;
 	    case 0:
 	    /* We simply ignore the field in this case to avoid confusion:
 	       MIPS ELF does not specify EF_MIPS_MACH, it is a GNU
diff -NBaur binutils-2.16.1/config.sub binutils-2.16.1-psp/config.sub
--- binutils-2.16.1/config.sub	Wed Jan 19 00:34:56 2005
+++ binutils-2.16.1-psp/config.sub	Mon Jul 25 20:30:04 2005
@@ -253,6 +253,7 @@
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
 	| mipstx39 | mipstx39el \
+	| mipsallegrex | mipsallegrexel \
 	| mn10200 | mn10300 \
 	| msp430 \
 	| ns16k | ns32k \
@@ -326,6 +327,7 @@
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
 	| mipstx39-* | mipstx39el-* \
+	| mipsallegrex-* | mipsallegrexel-* \
 	| mmix-* \
 	| msp430-* \
 	| none-* | np1-* | ns16k-* | ns32k-* \
@@ -664,6 +666,10 @@
 	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
 		basic_machine=m68k-atari
 		os=-mint
+		;;
+	psp)
+		basic_machine=mipsallegrexel-psp
+		os=-elf
 		;;
 	mips3*-*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
diff -NBaur binutils-2.16.1/gas/config/tc-mips.c binutils-2.16.1-psp/gas/config/tc-mips.c
--- binutils-2.16.1/gas/config/tc-mips.c	Sun Jun 12 19:07:03 2005
+++ binutils-2.16.1-psp/gas/config/tc-mips.c	Mon Jul 25 20:30:04 2005
@@ -365,11 +365,15 @@
 #define CPU_HAS_MDMX(cpu)	(FALSE                 \
 				 )
 
+/* True if the given CPU belongs to the Allegrex family.  */
+#define CPU_IS_ALLEGREX(CPU)	((CPU) == CPU_ALLEGREX	\
+    				 )
+
 /* True if CPU has a dror instruction.  */
 #define CPU_HAS_DROR(CPU)	((CPU) == CPU_VR5400 || (CPU) == CPU_VR5500)
 
 /* True if CPU has a ror instruction.  */
-#define CPU_HAS_ROR(CPU)	CPU_HAS_DROR (CPU)
+#define CPU_HAS_ROR(CPU)	CPU_HAS_DROR (CPU) || CPU_IS_ALLEGREX (CPU)
 
 /* True if mflo and mfhi can be immediately followed by instructions
    which write to the HI and LO registers.
@@ -7817,6 +7821,30 @@
       case '%': USE_BITS (OP_MASK_VECALIGN,	OP_SH_VECALIGN); break;
       case '[': break;
       case ']': break;
+      case '?':
+	/* MRB TODO: Fix this for the VFPU extensions. */
+	switch (c = *p++)
+	  {
+	  case 'f':
+	    /* MRB HACK: Skip the next character. */
+	    p++;
+	    break;
+	  case 'd':
+	  case 'm':
+	  case 'n':
+	  case 's':
+	  case 't':
+	  case 'v':
+	  case 'x':
+	    /* MRB HACK: Skip the next two characters. */
+	    p++;
+	    p++;
+	    break;
+	  default: break;
+	  }
+	/* MRB HACK: Set all used bits. */
+	used_bits = 0xffffffff;
+	break;
       default:
 	as_bad (_("internal: bad mips opcode (unknown operand type `%c'): %s %s"),
 		c, opc->name, opc->args);
@@ -8485,6 +8513,7 @@
 
 		  if ((regno & 1) != 0
 		      && HAVE_32BIT_FPRS
+		      && ! CPU_IS_ALLEGREX (mips_opts.arch)
 		      && ! (strcmp (str, "mtc1") == 0
 			    || strcmp (str, "mfc1") == 0
 			    || strcmp (str, "lwc1") == 0
@@ -13743,6 +13772,8 @@
 
   /* MIPS II */
   { "r6000",          0,      ISA_MIPS2,      CPU_R6000 },
+  /* Sony PSP "Allegrex" CPU core */
+  { "allegrex",       0,      ISA_MIPS2,      CPU_ALLEGREX },
 
   /* MIPS III */
   { "r4000",          0,      ISA_MIPS3,      CPU_R4000 },
diff -NBaur binutils-2.16.1/gas/configure binutils-2.16.1-psp/gas/configure
--- binutils-2.16.1/gas/configure	Tue Mar  1 00:43:51 2005
+++ binutils-2.16.1-psp/gas/configure	Mon Jul 25 20:30:04 2005
@@ -4537,6 +4537,9 @@
 	  mips64vr | mips64vrel)
 	    mips_cpu=vr4100
 	    ;;
+	  mipsallegrex | mipsallegrexel)
+	    mips_cpu=allegrex
+	    ;;
 	  mipsisa32r2* | mipsisa64r2*)
 	    mips_cpu=`echo $target_cpu | sed -e 's/[a-z]*..r2//' -e 's/el$//'`
 	    ;;
diff -NBaur binutils-2.16.1/gas/configure.in binutils-2.16.1-psp/gas/configure.in
--- binutils-2.16.1/gas/configure.in	Tue Mar  1 00:43:57 2005
+++ binutils-2.16.1-psp/gas/configure.in	Mon Jul 25 20:30:04 2005
@@ -222,6 +222,9 @@
 	  mips64vr | mips64vrel)
 	    mips_cpu=vr4100
 	    ;;
+	  mipsallegrex | mipsallegrexel)
+	    mips_cpu=allegrex
+	    ;;
 	  mipsisa32r2* | mipsisa64r2*)
 changequote(,)dnl
 	    mips_cpu=`echo $target_cpu | sed -e 's/[a-z]*..r2//' -e 's/el$//'`
diff -NBaur binutils-2.16.1/include/bin-bugs.h binutils-2.16.1-psp/include/bin-bugs.h
--- binutils-2.16.1/include/bin-bugs.h	Fri Jul 23 16:40:19 2004
+++ binutils-2.16.1-psp/include/bin-bugs.h	Mon Jul 25 20:30:04 2005
@@ -1,3 +1,3 @@
 #ifndef REPORT_BUGS_TO
-#define REPORT_BUGS_TO	"<URL:http://www.sourceware.org/bugzilla/>"
+#define REPORT_BUGS_TO	"<URL:http://wiki.pspdev.org/psp:toolchain#bugs>"
 #endif
diff -NBaur binutils-2.16.1/include/elf/common.h binutils-2.16.1-psp/include/elf/common.h
--- binutils-2.16.1/include/elf/common.h	Fri Oct  8 14:55:08 2004
+++ binutils-2.16.1-psp/include/elf/common.h	Mon Jul 25 20:30:04 2005
@@ -93,6 +93,7 @@
 #define ET_HIOS		0xFEFF	/* Operating system-specific */
 #define ET_LOPROC	0xFF00	/* Processor-specific */
 #define ET_HIPROC	0xFFFF	/* Processor-specific */
+#define ET_PSPEXEC	0xFFA0	/* Sony PSP executable file */
 
 /* Values for e_machine, which identifies the architecture.  These numbers
    are officially assigned by registry@caldera.com.  See below for a list of
diff -NBaur binutils-2.16.1/include/elf/mips.h binutils-2.16.1-psp/include/elf/mips.h
--- binutils-2.16.1/include/elf/mips.h	Thu Mar  3 11:58:06 2005
+++ binutils-2.16.1-psp/include/elf/mips.h	Mon Jul 25 20:30:04 2005
@@ -212,6 +212,7 @@
 #define E_MIPS_MACH_5400	0x00910000
 #define E_MIPS_MACH_5500	0x00980000
 #define E_MIPS_MACH_9000	0x00990000
+#define E_MIPS_MACH_ALLEGREX	0x00A20000
 
 /* Processor specific section indices.  These sections do not actually
    exist.  Symbols with a st_shndx field corresponding to one of these
diff -NBaur binutils-2.16.1/include/opcode/mips.h binutils-2.16.1-psp/include/opcode/mips.h
--- binutils-2.16.1/include/opcode/mips.h	Thu Mar  3 11:58:10 2005
+++ binutils-2.16.1-psp/include/opcode/mips.h	Mon Jul 25 20:30:04 2005
@@ -148,6 +148,19 @@
 #define OP_MASK_EXTMSBD		0x1f	/* "ext" MSBD.  */
 #define OP_SH_EXTMSBD		11
 
+#define OP_SH_VFPU_DELTA	0
+#define OP_MASK_VFPU_DELTA	0xfffc
+#define OP_SH_VFPU_IMM3		16
+#define OP_MASK_VFPU_IMM3	0x7
+#define OP_SH_VFPU_IMM5		16
+#define OP_MASK_VFPU_IMM5	0x1f
+#define OP_SH_VFPU_IMM8		16
+#define OP_MASK_VFPU_IMM8	0xff
+#define OP_SH_VFPU_CC		18
+#define OP_MASK_VFPU_CC		0x7
+#define OP_SH_VFPU_CONST	16
+#define OP_MASK_VFPU_CONST	0x1f
+
 #define	OP_OP_COP0		0x10
 #define	OP_OP_COP1		0x11
 #define	OP_OP_COP2		0x12
@@ -442,6 +455,8 @@
 #define INSN_5400		  0x01000000
 /* NEC VR5500 instruction.  */
 #define INSN_5500		  0x02000000
+/* Sony Allegrex instruction.  */
+#define INSN_ALLEGREX		  0x10000000
 
 /* MIPS ISA defines, use instead of hardcoding ISA level.  */
 
@@ -489,6 +504,7 @@
 #define CPU_MIPS64      64
 #define CPU_MIPS64R2	65
 #define CPU_SB1         12310201        /* octal 'SB', 01.  */
+#define CPU_ALLEGREX    10111431        /* octal 'AL', 31.  */
 
 /* Test for membership in an ISA including chip specific ISAs.  INSN
    is pointer to an element of the opcode table; ISA is the specified
@@ -510,6 +526,7 @@
      || (cpu == CPU_VR4120 && ((insn)->membership & INSN_4120) != 0)	\
      || (cpu == CPU_VR5400 && ((insn)->membership & INSN_5400) != 0)	\
      || (cpu == CPU_VR5500 && ((insn)->membership & INSN_5500) != 0)	\
+     || (cpu == CPU_ALLEGREX && ((insn)->membership & INSN_ALLEGREX) != 0)	\
      || 0)	/* Please keep this term for easier source merging.  */
 
 /* This is a list of macro expanded instructions.
diff -NBaur binutils-2.16.1/ld/Makefile.am binutils-2.16.1-psp/ld/Makefile.am
--- binutils-2.16.1/ld/Makefile.am	Thu Jan 20 19:37:49 2005
+++ binutils-2.16.1-psp/ld/Makefile.am	Mon Jul 25 20:30:04 2005
@@ -190,6 +190,7 @@
 	eelf_i386_chaos.o \
 	eelf_i386_fbsd.o \
 	eelf_i386_ldso.o \
+	eelf_mipsallegrexel_psp.o \
 	eelf_s390.o \
 	egld960.o \
 	egld960coff.o \
@@ -864,6 +865,9 @@
 eelf_i386_ldso.c: $(srcdir)/emulparams/elf_i386_ldso.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_i386_ldso "$(tdir_elf_i386_ldso)"
+eelf_mipsallegrexel_psp.c: $(srcdir)/emulparams/elf_mipsallegrexel_psp.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf_psp.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_mipsallegrexel_psp "$(tdir_elf_mipsallegrexel_psp)"
 eelf_s390.c: $(srcdir)/emulparams/elf_s390.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_s390 "$(tdir_elf_s390)"
diff -NBaur binutils-2.16.1/ld/Makefile.in binutils-2.16.1-psp/ld/Makefile.in
--- binutils-2.16.1/ld/Makefile.in	Sun Jan 23 05:36:37 2005
+++ binutils-2.16.1-psp/ld/Makefile.in	Mon Jul 25 20:30:04 2005
@@ -315,6 +315,7 @@
 	eelf_i386_chaos.o \
 	eelf_i386_fbsd.o \
 	eelf_i386_ldso.o \
+	eelf_mipsallegrexel_psp.o \
 	eelf_s390.o \
 	egld960.o \
 	egld960coff.o \
@@ -1601,6 +1602,9 @@
 eelf_i386_ldso.c: $(srcdir)/emulparams/elf_i386_ldso.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_i386_ldso "$(tdir_elf_i386_ldso)"
+eelf_mipsallegrexel_psp.c: $(srcdir)/emulparams/elf_mipsallegrexel_psp.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf_psp.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_mipsallegrexel_psp "$(tdir_elf_mipsallegrexel_psp)"
 eelf_s390.c: $(srcdir)/emulparams/elf_s390.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_s390 "$(tdir_elf_s390)"
diff -NBaur binutils-2.16.1/ld/configure.tgt binutils-2.16.1-psp/ld/configure.tgt
--- binutils-2.16.1/ld/configure.tgt	Tue Feb  8 19:54:27 2005
+++ binutils-2.16.1-psp/ld/configure.tgt	Mon Jul 25 20:30:04 2005
@@ -428,6 +428,8 @@
 mips*vr4100-*-elf*)	targ_emul=elf32b4300 ;;
 mips*vr5000el-*-elf*)	targ_emul=elf32l4300 ;;
 mips*vr5000-*-elf*)	targ_emul=elf32b4300 ;;
+mips*allegrexel-psp-elf*) targ_emul=elf_mipsallegrexel_psp
+			targ_extra_emuls="elf32elmip" ;;
 mips*el-*-elf*)		targ_emul=elf32elmip ;;
 mips*-*-elf*)		targ_emul=elf32ebmip ;;
 mips*el-*-rtems*)	targ_emul=elf32elmip ;;
diff -NBaur binutils-2.16.1/ld/emulparams/elf_mipsallegrexel_psp.sh binutils-2.16.1-psp/ld/emulparams/elf_mipsallegrexel_psp.sh
--- binutils-2.16.1/ld/emulparams/elf_mipsallegrexel_psp.sh	Thu Jan  1 00:00:00 1970
+++ binutils-2.16.1-psp/ld/emulparams/elf_mipsallegrexel_psp.sh	Mon Jul 25 20:30:04 2005
@@ -0,0 +1,22 @@
+# Based off of the default elf32 MIPS target.  However, we use a seperate
+# script template because the PSP architecture defines sections that normally
+# cannot be overriden here and would normally get absorbed (i.e.
+# .rodata.sceModuleInfo would be absorbed into .rodata).
+
+EMBEDDED=yes
+. ${srcdir}/emulparams/elf32lmip.sh
+unset NONPAGED_TEXT_START_ADDR
+unset SHLIB_TEXT_START_ADDR
+unset COMMONPAGESIZE
+
+SCRIPT_NAME=elf_psp
+TEXT_START_ADDR=0x08900000
+MAXPAGESIZE=256
+ARCH="mips:allegrex"
+MACHINE=
+TEMPLATE_NAME=elf32
+GENERATE_SHLIB_SCRIPT=yes
+DYNAMIC_LINK=FALSE
+
+# Discard the .comment and .pdr sections.
+OTHER_SECTIONS="/DISCARD/ : { *(.comment) *(.pdr) }"
diff -NBaur binutils-2.16.1/ld/scripttempl/elf_psp.sc binutils-2.16.1-psp/ld/scripttempl/elf_psp.sc
--- binutils-2.16.1/ld/scripttempl/elf_psp.sc	Thu Jan  1 00:00:00 1970
+++ binutils-2.16.1-psp/ld/scripttempl/elf_psp.sc	Mon Jul 25 20:30:04 2005
@@ -0,0 +1,496 @@
+#
+# Unusual variables checked by this code:
+#	NOP - four byte opcode for no-op (defaults to 0)
+#	NO_SMALL_DATA - no .sbss/.sbss2/.sdata/.sdata2 sections if not
+#		empty.
+#	SMALL_DATA_CTOR - .ctors contains small data.
+#	SMALL_DATA_DTOR - .dtors contains small data.
+#	DATA_ADDR - if end-of-text-plus-one-page isn't right for data start
+#	INITIAL_READONLY_SECTIONS - at start of text segment
+#	OTHER_READONLY_SECTIONS - other than .text .init .rodata ...
+#		(e.g., .PARISC.milli)
+#	OTHER_TEXT_SECTIONS - these get put in .text when relocating
+#	OTHER_READWRITE_SECTIONS - other than .data .bss .ctors .sdata ...
+#		(e.g., .PARISC.global)
+#	OTHER_RELRO_SECTIONS - other than .data.rel.ro ...
+#		(e.g. PPC32 .fixup, .got[12])
+#	OTHER_BSS_SECTIONS - other than .bss .sbss ...
+#	OTHER_SECTIONS - at the end
+#	EXECUTABLE_SYMBOLS - symbols that must be defined for an
+#		executable (e.g., _DYNAMIC_LINK)
+#       TEXT_START_ADDR - the first byte of the text segment, after any
+#               headers.
+#       TEXT_BASE_ADDRESS - the first byte of the text segment.
+#	TEXT_START_SYMBOLS - symbols that appear at the start of the
+#		.text section.
+#	DATA_START_SYMBOLS - symbols that appear at the start of the
+#		.data section.
+#	OTHER_GOT_SYMBOLS - symbols defined just before .got.
+#	OTHER_GOT_SECTIONS - sections just after .got.
+#	OTHER_SDATA_SECTIONS - sections just after .sdata.
+#	OTHER_BSS_SYMBOLS - symbols that appear at the start of the
+#		.bss section besides __bss_start.
+#	DATA_PLT - .plt should be in data segment, not text segment.
+#	PLT_BEFORE_GOT - .plt just before .got when .plt is in data segement.
+#	BSS_PLT - .plt should be in bss segment
+#	TEXT_DYNAMIC - .dynamic in text segment, not data segment.
+#	EMBEDDED - whether this is for an embedded system. 
+#	SHLIB_TEXT_START_ADDR - if set, add to SIZEOF_HEADERS to set
+#		start address of shared library.
+#	INPUT_FILES - INPUT command of files to always include
+#	WRITABLE_RODATA - if set, the .rodata section should be writable
+#	INIT_START, INIT_END -  statements just before and just after
+# 	combination of .init sections.
+#	FINI_START, FINI_END - statements just before and just after
+# 	combination of .fini sections.
+#	STACK_ADDR - start of a .stack section.
+#	OTHER_END_SYMBOLS - symbols to place right at the end of the script.
+#	SEPARATE_GOTPLT - if set, .got.plt should be separate output section,
+#		so that .got can be in the RELRO area.  It should be set to
+#		the number of bytes in the beginning of .got.plt which can be
+#		in the RELRO area as well.
+#
+# When adding sections, do note that the names of some sections are used
+# when specifying the start address of the next.
+#
+
+#  Many sections come in three flavours.  There is the 'real' section,
+#  like ".data".  Then there are the per-procedure or per-variable
+#  sections, generated by -ffunction-sections and -fdata-sections in GCC,
+#  and useful for --gc-sections, which for a variable "foo" might be
+#  ".data.foo".  Then there are the linkonce sections, for which the linker
+#  eliminates duplicates, which are named like ".gnu.linkonce.d.foo".
+#  The exact correspondences are:
+#
+#  Section	Linkonce section
+#  .text	.gnu.linkonce.t.foo
+#  .rodata	.gnu.linkonce.r.foo
+#  .data	.gnu.linkonce.d.foo
+#  .bss		.gnu.linkonce.b.foo
+#  .sdata	.gnu.linkonce.s.foo
+#  .sbss	.gnu.linkonce.sb.foo
+#  .sdata2	.gnu.linkonce.s2.foo
+#  .sbss2	.gnu.linkonce.sb2.foo
+#  .debug_info	.gnu.linkonce.wi.foo
+#  .tdata	.gnu.linkonce.td.foo
+#  .tbss	.gnu.linkonce.tb.foo
+#
+#  Each of these can also have corresponding .rel.* and .rela.* sections.
+
+test -z "$ENTRY" && ENTRY=_start
+test -z "${BIG_OUTPUT_FORMAT}" && BIG_OUTPUT_FORMAT=${OUTPUT_FORMAT}
+test -z "${LITTLE_OUTPUT_FORMAT}" && LITTLE_OUTPUT_FORMAT=${OUTPUT_FORMAT}
+if [ -z "$MACHINE" ]; then OUTPUT_ARCH=${ARCH}; else OUTPUT_ARCH=${ARCH}:${MACHINE}; fi
+test -z "${ELFSIZE}" && ELFSIZE=32
+test -z "${ALIGNMENT}" && ALIGNMENT="${ELFSIZE} / 8"
+test "$LD_FLAG" = "N" && DATA_ADDR=.
+test -n "$CREATE_SHLIB$CREATE_PIE" && test -n "$SHLIB_DATA_ADDR" && COMMONPAGESIZE=""
+test -z "$CREATE_SHLIB$CREATE_PIE" && test -n "$DATA_ADDR" && COMMONPAGESIZE=""
+test -n "$RELRO_NOW" && unset SEPARATE_GOTPLT
+DATA_SEGMENT_ALIGN="ALIGN(${SEGMENT_SIZE}) + (. & (${MAXPAGESIZE} - 1))"
+DATA_SEGMENT_RELRO_END=""
+DATA_SEGMENT_RELRO_GOTPLT_END=""
+DATA_SEGMENT_END=""
+if test -n "${COMMONPAGESIZE}"; then
+  DATA_SEGMENT_ALIGN="ALIGN (${SEGMENT_SIZE}) - ((${MAXPAGESIZE} - .) & (${MAXPAGESIZE} - 1)); . = DATA_SEGMENT_ALIGN (${MAXPAGESIZE}, ${COMMONPAGESIZE})"
+  DATA_SEGMENT_END=". = DATA_SEGMENT_END (.);"
+  if test -n "${SEPARATE_GOTPLT}"; then
+    DATA_SEGMENT_RELRO_GOTPLT_END=". = DATA_SEGMENT_RELRO_END (${SEPARATE_GOTPLT}, .);"
+  else
+    DATA_SEGMENT_RELRO_END=". = DATA_SEGMENT_RELRO_END (0, .);"
+  fi
+fi
+INTERP=".interp       ${RELOCATING-0} : { *(.interp) }"
+PLT=".plt          ${RELOCATING-0} : { *(.plt) }"
+if test -z "$GOT"; then
+  if test -z "$SEPARATE_GOTPLT"; then
+    GOT=".got          ${RELOCATING-0} : { *(.got.plt) *(.got) }"
+  else
+    GOT=".got          ${RELOCATING-0} : { *(.got) }"
+    GOTPLT="${RELOCATING+${DATA_SEGMENT_RELRO_GOTPLT_END}}
+  .got.plt      ${RELOCATING-0} : { *(.got.plt) }"
+  fi
+fi
+DYNAMIC=".dynamic      ${RELOCATING-0} : { *(.dynamic) }"
+RODATA=".rodata       ${RELOCATING-0} : { *(.rodata${RELOCATING+ .rodata.* .gnu.linkonce.r.*}) }"
+DATARELRO=".data.rel.ro : { *(.data.rel.ro.local) *(.data.rel.ro*) }"
+STACKNOTE="/DISCARD/ : { *(.note.GNU-stack) }"
+if test -z "${NO_SMALL_DATA}"; then
+  SBSS=".sbss         ${RELOCATING-0} :
+  {
+    ${RELOCATING+PROVIDE (__sbss_start = .);}
+    ${RELOCATING+PROVIDE (___sbss_start = .);}
+    ${CREATE_SHLIB+*(.sbss2 .sbss2.* .gnu.linkonce.sb2.*)}
+    *(.dynsbss)
+    *(.sbss${RELOCATING+ .sbss.* .gnu.linkonce.sb.*})
+    *(.scommon)
+    ${RELOCATING+PROVIDE (__sbss_end = .);}
+    ${RELOCATING+PROVIDE (___sbss_end = .);}
+  }"
+  SBSS2=".sbss2        ${RELOCATING-0} : { *(.sbss2${RELOCATING+ .sbss2.* .gnu.linkonce.sb2.*}) }"
+  SDATA="/* We want the small data sections together, so single-instruction offsets
+     can access them all, and initialized data all before uninitialized, so
+     we can shorten the on-disk segment size.  */
+  .sdata        ${RELOCATING-0} : 
+  {
+    ${RELOCATING+${SDATA_START_SYMBOLS}}
+    ${CREATE_SHLIB+*(.sdata2 .sdata2.* .gnu.linkonce.s2.*)}
+    *(.sdata${RELOCATING+ .sdata.* .gnu.linkonce.s.*})
+  }"
+  SDATA2=".sdata2       ${RELOCATING-0} : { *(.sdata2${RELOCATING+ .sdata2.* .gnu.linkonce.s2.*}) }"
+  REL_SDATA=".rel.sdata    ${RELOCATING-0} : { *(.rel.sdata${RELOCATING+ .rel.sdata.* .rel.gnu.linkonce.s.*}) }
+  .rela.sdata   ${RELOCATING-0} : { *(.rela.sdata${RELOCATING+ .rela.sdata.* .rela.gnu.linkonce.s.*}) }"
+  REL_SBSS=".rel.sbss     ${RELOCATING-0} : { *(.rel.sbss${RELOCATING+ .rel.sbss.* .rel.gnu.linkonce.sb.*}) }
+  .rela.sbss    ${RELOCATING-0} : { *(.rela.sbss${RELOCATING+ .rela.sbss.* .rela.gnu.linkonce.sb.*}) }"
+  REL_SDATA2=".rel.sdata2   ${RELOCATING-0} : { *(.rel.sdata2${RELOCATING+ .rel.sdata2.* .rel.gnu.linkonce.s2.*}) }
+  .rela.sdata2  ${RELOCATING-0} : { *(.rela.sdata2${RELOCATING+ .rela.sdata2.* .rela.gnu.linkonce.s2.*}) }"
+  REL_SBSS2=".rel.sbss2    ${RELOCATING-0} : { *(.rel.sbss2${RELOCATING+ .rel.sbss2.* .rel.gnu.linkonce.sb2.*}) }
+  .rela.sbss2   ${RELOCATING-0} : { *(.rela.sbss2${RELOCATING+ .rela.sbss2.* .rela.gnu.linkonce.sb2.*}) }"
+else
+  NO_SMALL_DATA=" "
+fi
+test -n "$SEPARATE_GOTPLT" && SEPARATE_GOTPLT=" "
+CTOR=".ctors        ${CONSTRUCTING-0} : 
+  {
+    ${CONSTRUCTING+${CTOR_START}}
+    /* gcc uses crtbegin.o to find the start of
+       the constructors, so we make sure it is
+       first.  Because this is a wildcard, it
+       doesn't matter if the user does not
+       actually link against crtbegin.o; the
+       linker won't look for a file to match a
+       wildcard.  The wildcard also means that it
+       doesn't matter which directory crtbegin.o
+       is in.  */
+
+    KEEP (*crtbegin*.o(.ctors))
+
+    /* We don't want to include the .ctor section from
+       from the crtend.o file until after the sorted ctors.
+       The .ctor section from the crtend file contains the
+       end of ctors marker and it must be last */
+
+    KEEP (*(EXCLUDE_FILE (*crtend*.o $OTHER_EXCLUDE_FILES) .ctors))
+    KEEP (*(SORT(.ctors.*)))
+    KEEP (*(.ctors))
+    ${CONSTRUCTING+${CTOR_END}}
+  }"
+DTOR=".dtors        ${CONSTRUCTING-0} :
+  {
+    ${CONSTRUCTING+${DTOR_START}}
+    KEEP (*crtbegin*.o(.dtors))
+    KEEP (*(EXCLUDE_FILE (*crtend*.o $OTHER_EXCLUDE_FILES) .dtors))
+    KEEP (*(SORT(.dtors.*)))
+    KEEP (*(.dtors))
+    ${CONSTRUCTING+${DTOR_END}}
+  }"
+STACK="  .stack        ${RELOCATING-0}${RELOCATING+${STACK_ADDR}} :
+  {
+    ${RELOCATING+_stack = .;}
+    *(.stack)
+  }"
+
+# if this is for an embedded system, don't add SIZEOF_HEADERS.
+if [ -z "$EMBEDDED" ]; then
+   test -z "${TEXT_BASE_ADDRESS}" && TEXT_BASE_ADDRESS="${TEXT_START_ADDR} + SIZEOF_HEADERS"
+else
+   test -z "${TEXT_BASE_ADDRESS}" && TEXT_BASE_ADDRESS="${TEXT_START_ADDR}"
+fi
+
+cat <<EOF
+OUTPUT_FORMAT("${OUTPUT_FORMAT}", "${BIG_OUTPUT_FORMAT}",
+	      "${LITTLE_OUTPUT_FORMAT}")
+OUTPUT_ARCH(${OUTPUT_ARCH})
+ENTRY(${ENTRY})
+
+${RELOCATING+${LIB_SEARCH_DIRS}}
+${RELOCATING+/* Do we need any of these for elf?
+   __DYNAMIC = 0; ${STACKZERO+${STACKZERO}} ${SHLIB_PATH+${SHLIB_PATH}}  */}
+${RELOCATING+${EXECUTABLE_SYMBOLS}}
+${RELOCATING+${INPUT_FILES}}
+${RELOCATING- /* For some reason, the Solaris linker makes bad executables
+  if gld -r is used and the intermediate file has sections starting
+  at non-zero addresses.  Could be a Solaris ld bug, could be a GNU ld
+  bug.  But for now assigning the zero vmas works.  */}
+
+SECTIONS
+{
+  /* Read-only sections, merged into text segment: */
+  ${CREATE_SHLIB-${CREATE_PIE-${RELOCATING+PROVIDE (__executable_start = ${TEXT_START_ADDR}); . = ${TEXT_BASE_ADDRESS};}}}
+  ${CREATE_SHLIB+${RELOCATING+. = ${SHLIB_TEXT_START_ADDR:-0} + SIZEOF_HEADERS;}}
+  ${CREATE_PIE+${RELOCATING+. = ${SHLIB_TEXT_START_ADDR:-0} + SIZEOF_HEADERS;}}
+  ${CREATE_SHLIB-${INTERP}}
+  ${INITIAL_READONLY_SECTIONS}
+  ${TEXT_DYNAMIC+${DYNAMIC}}
+  .hash         ${RELOCATING-0} : { *(.hash) }
+  .dynsym       ${RELOCATING-0} : { *(.dynsym) }
+  .dynstr       ${RELOCATING-0} : { *(.dynstr) }
+  .gnu.version  ${RELOCATING-0} : { *(.gnu.version) }
+  .gnu.version_d ${RELOCATING-0}: { *(.gnu.version_d) }
+  .gnu.version_r ${RELOCATING-0}: { *(.gnu.version_r) }
+
+EOF
+if [ "x$COMBRELOC" = x ]; then
+  COMBRELOCCAT=cat
+else
+  COMBRELOCCAT="cat > $COMBRELOC"
+fi
+eval $COMBRELOCCAT <<EOF
+  .rel.init     ${RELOCATING-0} : { *(.rel.init) }
+  .rela.init    ${RELOCATING-0} : { *(.rela.init) }
+  .rel.text     ${RELOCATING-0} : { *(.rel.text${RELOCATING+ .rel.text.* .rel.gnu.linkonce.t.*}) }
+  .rela.text    ${RELOCATING-0} : { *(.rela.text${RELOCATING+ .rela.text.* .rela.gnu.linkonce.t.*}) }
+  .rel.fini     ${RELOCATING-0} : { *(.rel.fini) }
+  .rela.fini    ${RELOCATING-0} : { *(.rela.fini) }
+
+  /* PSP-specific relocations. */
+  .rel.sceStub.text ${RELOCATING-0} : { *(.rel.sceStub.text) *(SORT(.rel.sceStub.text.*)) }
+  .rel.lib.ent.top  ${RELOCATING-0} : { *(.rel.lib.ent.top) }
+  .rel.lib.ent      ${RELOCATING-0} : { *(.rel.lib.ent) }
+  .rel.lib.ent.btm  ${RELOCATING-0} : { *(.rel.lib.ent.btm) }
+  .rel.lib.stub.top ${RELOCATING-0} : { *(.rel.lib.stub.top) }
+  .rel.lib.stub     ${RELOCATING-0} : { *(.rel.lib.stub) }
+  .rel.lib.stub.btm ${RELOCATING-0} : { *(.rel.lib.stub.btm) }
+  .rel.rodata.sceModuleInfo ${RELOCATING-0} : { *(.rel.rodata.sceModuleInfo) }
+  .rel.rodata.sceResident   ${RELOCATING-0} : { *(.rel.rodata.sceResident) }
+  .rel.rodata.sceNid        ${RELOCATING-0} : { *(.rel.rodata.sceNid) }
+  .rel.rodata.sceVstub      ${RELOCATING-0} : { *(.rel.rodata.sceVstub) *(SORT(.rel.rodata.sceVstub.*)) }
+
+  .rel.rodata   ${RELOCATING-0} : { *(.rel.rodata${RELOCATING+ .rel.rodata.* .rel.gnu.linkonce.r.*}) }
+  .rela.rodata  ${RELOCATING-0} : { *(.rela.rodata${RELOCATING+ .rela.rodata.* .rela.gnu.linkonce.r.*}) }
+  ${OTHER_READONLY_RELOC_SECTIONS}
+  .rel.data.rel.ro ${RELOCATING-0} : { *(.rel.data.rel.ro${RELOCATING+*}) }
+  .rela.data.rel.ro ${RELOCATING-0} : { *(.rel.data.rel.ro${RELOCATING+*}) }
+  .rel.data     ${RELOCATING-0} : { *(.rel.data${RELOCATING+ .rel.data.* .rel.gnu.linkonce.d.*}) }
+  .rela.data    ${RELOCATING-0} : { *(.rela.data${RELOCATING+ .rela.data.* .rela.gnu.linkonce.d.*}) }
+  .rel.tdata	${RELOCATING-0} : { *(.rel.tdata${RELOCATING+ .rel.tdata.* .rel.gnu.linkonce.td.*}) }
+  .rela.tdata	${RELOCATING-0} : { *(.rela.tdata${RELOCATING+ .rela.tdata.* .rela.gnu.linkonce.td.*}) }
+  .rel.tbss	${RELOCATING-0} : { *(.rel.tbss${RELOCATING+ .rel.tbss.* .rel.gnu.linkonce.tb.*}) }
+  .rela.tbss	${RELOCATING-0} : { *(.rela.tbss${RELOCATING+ .rela.tbss.* .rela.gnu.linkonce.tb.*}) }
+  .rel.ctors    ${RELOCATING-0} : { *(.rel.ctors) }
+  .rela.ctors   ${RELOCATING-0} : { *(.rela.ctors) }
+  .rel.dtors    ${RELOCATING-0} : { *(.rel.dtors) }
+  .rela.dtors   ${RELOCATING-0} : { *(.rela.dtors) }
+  .rel.got      ${RELOCATING-0} : { *(.rel.got) }
+  .rela.got     ${RELOCATING-0} : { *(.rela.got) }
+  ${OTHER_GOT_RELOC_SECTIONS}
+  ${REL_SDATA}
+  ${REL_SBSS}
+  ${REL_SDATA2}
+  ${REL_SBSS2}
+  .rel.bss      ${RELOCATING-0} : { *(.rel.bss${RELOCATING+ .rel.bss.* .rel.gnu.linkonce.b.*}) }
+  .rela.bss     ${RELOCATING-0} : { *(.rela.bss${RELOCATING+ .rela.bss.* .rela.gnu.linkonce.b.*}) }
+EOF
+if [ -n "$COMBRELOC" ]; then
+cat <<EOF
+  .rel.dyn      ${RELOCATING-0} :
+    {
+EOF
+sed -e '/^[ 	]*[{}][ 	]*$/d;/:[ 	]*$/d;/\.rela\./d;s/^.*: { *\(.*\)}$/      \1/' $COMBRELOC
+cat <<EOF
+    }
+  .rela.dyn     ${RELOCATING-0} :
+    {
+EOF
+sed -e '/^[ 	]*[{}][ 	]*$/d;/:[ 	]*$/d;/\.rel\./d;s/^.*: { *\(.*\)}/      \1/' $COMBRELOC
+cat <<EOF
+    }
+EOF
+fi
+cat <<EOF
+  .rel.plt      ${RELOCATING-0} : { *(.rel.plt) }
+  .rela.plt     ${RELOCATING-0} : { *(.rela.plt) }
+  ${OTHER_PLT_RELOC_SECTIONS}
+
+  .init         ${RELOCATING-0} : 
+  { 
+    ${RELOCATING+${INIT_START}}
+    KEEP (*(.init))
+    ${RELOCATING+${INIT_END}}
+  } =${NOP-0}
+
+  ${DATA_PLT-${BSS_PLT-${PLT}}}
+  .text         ${RELOCATING-0} :
+  {
+    ${RELOCATING+${TEXT_START_SYMBOLS}}
+    *(.text .stub${RELOCATING+ .text.* .gnu.linkonce.t.*})
+    KEEP (*(.text.*personality*))
+    /* .gnu.warning sections are handled specially by elf32.em.  */
+    *(.gnu.warning)
+    ${RELOCATING+${OTHER_TEXT_SECTIONS}}
+  } =${NOP-0}
+  .fini         ${RELOCATING-0} :
+  {
+    ${RELOCATING+${FINI_START}}
+    KEEP (*(.fini))
+    ${RELOCATING+${FINI_END}}
+  } =${NOP-0}
+
+  /* PSP library stub functions. */
+  .sceStub.text   ${RELOCATING-0} : { *(.sceStub.text) *(SORT(.sceStub.text.*)) }
+
+  ${RELOCATING+PROVIDE (__etext = .);}
+  ${RELOCATING+PROVIDE (_etext = .);}
+  ${RELOCATING+PROVIDE (etext = .);}
+
+  /* PSP library entry table and library stub table. */
+  .lib.ent.top  ${RELOCATING-0} : { *(.lib.ent.top) }
+  .lib.ent      ${RELOCATING-0} : { *(.lib.ent) }
+  .lib.ent.btm  ${RELOCATING-0} : { *(.lib.ent.btm) }
+
+  .lib.stub.top ${RELOCATING-0} : { *(.lib.stub.top) }
+  .lib.stub     ${RELOCATING-0} : { *(.lib.stub) }
+  .lib.stub.btm ${RELOCATING-0} : { *(.lib.stub.btm) }
+
+  /* PSP read-only data for module info, NIDs, and Vstubs.  The
+     .rodata.sceModuleInfo section must appear before the .rodata section
+     otherwise it would get absorbed into .rodata and the PSP bootloader
+     would be unable to locate the module info structure. */
+  .rodata.sceModuleInfo  ${RELOCATING-0} : { *(.rodata.sceModuleInfo) }
+  .rodata.sceResident    ${RELOCATING-0} : { *(.rodata.sceResident) }
+  .rodata.sceNid         ${RELOCATING-0} : { *(.rodata.sceNid) }
+  .rodata.sceVstub       ${RELOCATING-0} : { *(.rodata.sceVstub) *(SORT(.rodata.sceVstub.*)) }
+
+  ${WRITABLE_RODATA-${RODATA}}
+  .rodata1      ${RELOCATING-0} : { *(.rodata1) }
+  ${CREATE_SHLIB-${SDATA2}}
+  ${CREATE_SHLIB-${SBSS2}}
+  ${OTHER_READONLY_SECTIONS}
+  .eh_frame_hdr : { *(.eh_frame_hdr) }
+  .eh_frame     ${RELOCATING-0} : ONLY_IF_RO { KEEP (*(.eh_frame)) }
+  .gcc_except_table ${RELOCATING-0} : ONLY_IF_RO { KEEP (*(.gcc_except_table)) *(.gcc_except_table.*) }
+
+  /* Adjust the address for the data segment.  We want to adjust up to
+     the same address within the page on the next page up.  */
+  ${CREATE_SHLIB-${CREATE_PIE-${RELOCATING+. = ${DATA_ADDR-${DATA_SEGMENT_ALIGN}};}}}
+  ${CREATE_SHLIB+${RELOCATING+. = ${SHLIB_DATA_ADDR-${DATA_SEGMENT_ALIGN}};}}
+  ${CREATE_PIE+${RELOCATING+. = ${SHLIB_DATA_ADDR-${DATA_SEGMENT_ALIGN}};}}
+
+  /* Exception handling  */
+  .eh_frame     ${RELOCATING-0} : ONLY_IF_RW { KEEP (*(.eh_frame)) }
+  .gcc_except_table ${RELOCATING-0} : ONLY_IF_RW { KEEP (*(.gcc_except_table)) *(.gcc_except_table.*) }
+
+  /* Thread Local Storage sections  */
+  .tdata	${RELOCATING-0} : { *(.tdata${RELOCATING+ .tdata.* .gnu.linkonce.td.*}) }
+  .tbss		${RELOCATING-0} : { *(.tbss${RELOCATING+ .tbss.* .gnu.linkonce.tb.*})${RELOCATING+ *(.tcommon)} }
+
+  /* Ensure the __preinit_array_start label is properly aligned.  We
+     could instead move the label definition inside the section, but
+     the linker would then create the section even if it turns out to
+     be empty, which isn't pretty.  */
+  ${RELOCATING+. = ALIGN(${ALIGNMENT});}
+  ${RELOCATING+${CREATE_SHLIB-PROVIDE (__preinit_array_start = .);}}
+  .preinit_array   ${RELOCATING-0} : { KEEP (*(.preinit_array)) }
+  ${RELOCATING+${CREATE_SHLIB-PROVIDE (__preinit_array_end = .);}}
+
+  ${RELOCATING+${CREATE_SHLIB-PROVIDE (__init_array_start = .);}}
+  .init_array   ${RELOCATING-0} : { KEEP (*(.init_array)) }
+  ${RELOCATING+${CREATE_SHLIB-PROVIDE (__init_array_end = .);}}
+
+  ${RELOCATING+${CREATE_SHLIB-PROVIDE (__fini_array_start = .);}}
+  .fini_array   ${RELOCATING-0} : { KEEP (*(.fini_array)) }
+  ${RELOCATING+${CREATE_SHLIB-PROVIDE (__fini_array_end = .);}}
+
+  ${SMALL_DATA_CTOR-${RELOCATING+${CTOR}}}
+  ${SMALL_DATA_DTOR-${RELOCATING+${DTOR}}}
+  .jcr          ${RELOCATING-0} : { KEEP (*(.jcr)) }
+
+  ${RELOCATING+${DATARELRO}}
+  ${OTHER_RELRO_SECTIONS}
+  ${TEXT_DYNAMIC-${DYNAMIC}}
+  ${NO_SMALL_DATA+${RELRO_NOW+${GOT}}}
+  ${NO_SMALL_DATA+${RELRO_NOW-${SEPARATE_GOTPLT+${GOT}}}}
+  ${NO_SMALL_DATA+${RELRO_NOW-${SEPARATE_GOTPLT+${GOTPLT}}}}
+  ${RELOCATING+${DATA_SEGMENT_RELRO_END}}
+  ${NO_SMALL_DATA+${RELRO_NOW-${SEPARATE_GOTPLT-${GOT}}}}
+
+  ${DATA_PLT+${PLT_BEFORE_GOT-${PLT}}}
+
+  .data         ${RELOCATING-0} :
+  {
+    ${RELOCATING+${DATA_START_SYMBOLS}}
+    *(.data${RELOCATING+ .data.* .gnu.linkonce.d.*})
+    KEEP (*(.gnu.linkonce.d.*personality*))
+    ${CONSTRUCTING+SORT(CONSTRUCTORS)}
+  }
+  .data1        ${RELOCATING-0} : { *(.data1) }
+  ${WRITABLE_RODATA+${RODATA}}
+  ${OTHER_READWRITE_SECTIONS}
+  ${SMALL_DATA_CTOR+${RELOCATING+${CTOR}}}
+  ${SMALL_DATA_DTOR+${RELOCATING+${DTOR}}}
+  ${DATA_PLT+${PLT_BEFORE_GOT+${PLT}}}
+  ${RELOCATING+${OTHER_GOT_SYMBOLS}}
+  ${NO_SMALL_DATA-${GOT}}
+  ${OTHER_GOT_SECTIONS}
+  ${SDATA}
+  ${OTHER_SDATA_SECTIONS}
+  ${RELOCATING+_edata = .;}
+  ${RELOCATING+PROVIDE (edata = .);}
+  ${RELOCATING+__bss_start = .;}
+  ${RELOCATING+${OTHER_BSS_SYMBOLS}}
+  ${SBSS}
+  ${BSS_PLT+${PLT}}
+  .bss          ${RELOCATING-0} :
+  {
+   *(.dynbss)
+   *(.bss${RELOCATING+ .bss.* .gnu.linkonce.b.*})
+   *(COMMON)
+   /* Align here to ensure that the .bss section occupies space up to
+      _end.  Align after .bss to ensure correct alignment even if the
+      .bss section disappears because there are no input sections.  */
+   ${RELOCATING+. = ALIGN(${ALIGNMENT});}
+  }
+  ${OTHER_BSS_SECTIONS}
+  ${RELOCATING+. = ALIGN(${ALIGNMENT});}
+  ${RELOCATING+_end = .;}
+  ${RELOCATING+${OTHER_BSS_END_SYMBOLS}}
+  ${RELOCATING+PROVIDE (end = .);}
+  ${RELOCATING+${DATA_SEGMENT_END}}
+
+  /* Stabs debugging sections.  */
+  .stab          0 : { *(.stab) }
+  .stabstr       0 : { *(.stabstr) }
+  .stab.excl     0 : { *(.stab.excl) }
+  .stab.exclstr  0 : { *(.stab.exclstr) }
+  .stab.index    0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+
+  .comment       0 : { *(.comment) }
+
+  /* DWARF debug sections.
+     Symbols in the DWARF debugging sections are relative to the beginning
+     of the section so we begin them at 0.  */
+
+  /* DWARF 1 */
+  .debug          0 : { *(.debug) }
+  .line           0 : { *(.line) }
+
+  /* GNU DWARF 1 extensions */
+  .debug_srcinfo  0 : { *(.debug_srcinfo) }
+  .debug_sfnames  0 : { *(.debug_sfnames) }
+
+  /* DWARF 1.1 and DWARF 2 */
+  .debug_aranges  0 : { *(.debug_aranges) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+
+  /* DWARF 2 */
+  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
+  .debug_abbrev   0 : { *(.debug_abbrev) }
+  .debug_line     0 : { *(.debug_line) }
+  .debug_frame    0 : { *(.debug_frame) }
+  .debug_str      0 : { *(.debug_str) }
+  .debug_loc      0 : { *(.debug_loc) }
+  .debug_macinfo  0 : { *(.debug_macinfo) }
+
+  /* SGI/MIPS DWARF 2 extensions */
+  .debug_weaknames 0 : { *(.debug_weaknames) }
+  .debug_funcnames 0 : { *(.debug_funcnames) }
+  .debug_typenames 0 : { *(.debug_typenames) }
+  .debug_varnames  0 : { *(.debug_varnames) }
+
+  ${STACK_ADDR+${STACK}}
+  ${OTHER_SECTIONS}
+  ${RELOCATING+${OTHER_END_SYMBOLS}}
+  ${RELOCATING+${STACKNOTE}}
+}
+EOF
diff -NBaur binutils-2.16.1/opcodes/mips-dis.c binutils-2.16.1-psp/opcodes/mips-dis.c
--- binutils-2.16.1/opcodes/mips-dis.c	Thu Mar  3 11:49:50 2005
+++ binutils-2.16.1-psp/opcodes/mips-dis.c	Mon Jul 25 20:30:04 2005
@@ -140,6 +140,139 @@
   "c0_taglo",     "c0_taghi",     "c0_errorepc",  "c0_desave",
 };
 
+static const char * const vfpu_sreg_names[128] = {
+  "S000",  "S010",  "S020",  "S030",  "S100",  "S110",  "S120",  "S130",
+  "S200",  "S210",  "S220",  "S230",  "S300",  "S310",  "S320",  "S330",
+  "S400",  "S410",  "S420",  "S430",  "S500",  "S510",  "S520",  "S530",
+  "S600",  "S610",  "S620",  "S630",  "S700",  "S710",  "S720",  "S730",
+  "S001",  "S011",  "S021",  "S031",  "S101",  "S111",  "S121",  "S131",
+  "S201",  "S211",  "S221",  "S231",  "S301",  "S311",  "S321",  "S331",
+  "S401",  "S411",  "S421",  "S431",  "S501",  "S511",  "S521",  "S531",
+  "S601",  "S611",  "S621",  "S631",  "S701",  "S711",  "S721",  "S731",
+  "S002",  "S012",  "S022",  "S032",  "S102",  "S112",  "S122",  "S132",
+  "S202",  "S212",  "S222",  "S232",  "S302",  "S312",  "S322",  "S332",
+  "S402",  "S412",  "S422",  "S432",  "S502",  "S512",  "S522",  "S532",
+  "S602",  "S612",  "S622",  "S632",  "S702",  "S712",  "S722",  "S732",
+  "S003",  "S013",  "S023",  "S033",  "S103",  "S113",  "S123",  "S133",
+  "S203",  "S213",  "S223",  "S233",  "S303",  "S313",  "S323",  "S333",
+  "S403",  "S413",  "S423",  "S433",  "S503",  "S513",  "S523",  "S533",
+  "S603",  "S613",  "S623",  "S633",  "S703",  "S713",  "S723",  "S733"
+};
+
+static const char * const vfpu_vpreg_names[128] = {
+  "C000",  "C010",  "C020",  "C030",  "C100",  "C110",  "C120",  "C130",
+  "C200",  "C210",  "C220",  "C230",  "C300",  "C310",  "C320",  "C330",
+  "C400",  "C410",  "C420",  "C430",  "C500",  "C510",  "C520",  "C530",
+  "C600",  "C610",  "C620",  "C630",  "C700",  "C710",  "C720",  "C730",
+  "R000",  "R001",  "R002",  "R003",  "R100",  "R101",  "R102",  "R103",
+  "R200",  "R201",  "R202",  "R203",  "R300",  "R301",  "R302",  "R303",
+  "R400",  "R401",  "R402",  "R403",  "R500",  "R501",  "R502",  "R503",
+  "R600",  "R601",  "R602",  "R603",  "R700",  "R701",  "R702",  "R703",
+  "C002",  "C012",  "C022",  "C032",  "C102",  "C112",  "C122",  "C132",
+  "C202",  "C212",  "C222",  "C232",  "C302",  "C312",  "C322",  "C332",
+  "C402",  "C412",  "C422",  "C432",  "C502",  "C512",  "C522",  "C532",
+  "C602",  "C612",  "C622",  "C632",  "C702",  "C712",  "C722",  "C732",
+  "R020",  "R021",  "R022",  "R023",  "R120",  "R121",  "R122",  "R123",
+  "R220",  "R221",  "R222",  "R223",  "R320",  "R321",  "R322",  "R323",
+  "R420",  "R421",  "R422",  "R423",  "R520",  "R521",  "R522",  "R523",
+  "R620",  "R621",  "R622",  "R623",  "R720",  "R721",  "R722",  "R723"
+};
+
+static const char * const vfpu_vtreg_names[128] = {
+  "C000",  "C010",  "C020",  "C030",  "C100",  "C110",  "C120",  "C130",
+  "C200",  "C210",  "C220",  "C230",  "C300",  "C310",  "C320",  "C330",
+  "C400",  "C410",  "C420",  "C430",  "C500",  "C510",  "C520",  "C530",
+  "C600",  "C610",  "C620",  "C630",  "C700",  "C710",  "C720",  "C730",
+  "R000",  "R001",  "R002",  "R003",  "R100",  "R101",  "R102",  "R103",
+  "R200",  "R201",  "R202",  "R203",  "R300",  "R301",  "R302",  "R303",
+  "R400",  "R401",  "R402",  "R403",  "R500",  "R501",  "R502",  "R503",
+  "R600",  "R601",  "R602",  "R603",  "R700",  "R701",  "R702",  "R703",
+  "C001",  "C011",  "C021",  "C031",  "C101",  "C111",  "C121",  "C131",
+  "C201",  "C211",  "C221",  "C231",  "C301",  "C311",  "C321",  "C331",
+  "C401",  "C411",  "C421",  "C431",  "C501",  "C511",  "C521",  "C531",
+  "C601",  "C611",  "C621",  "C631",  "C701",  "C711",  "C721",  "C731",
+  "R010",  "R011",  "R012",  "R013",  "R110",  "R111",  "R112",  "R113",
+  "R210",  "R211",  "R212",  "R213",  "R310",  "R311",  "R312",  "R313",
+  "R410",  "R411",  "R412",  "R413",  "R510",  "R511",  "R512",  "R513",
+  "R610",  "R611",  "R612",  "R613",  "R710",  "R711",  "R712",  "R713"
+};
+
+static const char * const vfpu_vqreg_names[128] = {
+  "C000",  "C010",  "C020",  "C030",  "C100",  "C110",  "C120",  "C130",
+  "C200",  "C210",  "C220",  "C230",  "C300",  "C310",  "C320",  "C330",
+  "C400",  "C410",  "C420",  "C430",  "C500",  "C510",  "C520",  "C530",
+  "C600",  "C610",  "C620",  "C630",  "C700",  "C710",  "C720",  "C730",
+  "R000",  "R001",  "R002",  "R003",  "R100",  "R101",  "R102",  "R103",
+  "R200",  "R201",  "R202",  "R203",  "R300",  "R301",  "R302",  "R303",
+  "R400",  "R401",  "R402",  "R403",  "R500",  "R501",  "R502",  "R503",
+  "R600",  "R601",  "R602",  "R603",  "R700",  "R701",  "R702",  "R703",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  ""
+};
+
+static const char * const vfpu_mpreg_names[128] = {
+  "M000",  "",  "M020",  "",  "M100",  "",  "M120",  "",
+  "M200",  "",  "M220",  "",  "M300",  "",  "M320",  "",
+  "M400",  "",  "M420",  "",  "M500",  "",  "M520",  "",
+  "M600",  "",  "M620",  "",  "M700",  "",  "M720",  "",
+  "E000",  "",  "E002",  "",  "E100",  "",  "E102",  "",
+  "E200",  "",  "E202",  "",  "E300",  "",  "E302",  "",
+  "E400",  "",  "E402",  "",  "E500",  "",  "E502",  "",
+  "E600",  "",  "E602",  "",  "E700",  "",  "E702",  "",
+  "M002",  "",  "M022",  "",  "M102",  "",  "M122",  "",
+  "M202",  "",  "M222",  "",  "M302",  "",  "M322",  "",
+  "M402",  "",  "M422",  "",  "M502",  "",  "M522",  "",
+  "M602",  "",  "M622",  "",  "M702",  "",  "M722",  "",
+  "E020",  "",  "E022",  "",  "E120",  "",  "E122",  "",
+  "E220",  "",  "E222",  "",  "E320",  "",  "E322",  "",
+  "E420",  "",  "E422",  "",  "E520",  "",  "E522",  "",
+  "E620",  "",  "E622",  "",  "E720",  "",  "E722",  ""
+};
+
+static const char * const vfpu_mtreg_names[128] = {
+  "M000",  "M010",  "",  "",  "M100",  "M110",  "",  "",
+  "M200",  "M210",  "",  "",  "M300",  "M310",  "",  "",
+  "M400",  "M410",  "",  "",  "M500",  "M510",  "",  "",
+  "M600",  "M610",  "",  "",  "M700",  "M710",  "",  "",
+  "E000",  "E001",  "",  "",  "E100",  "E101",  "",  "",
+  "E200",  "E201",  "",  "",  "E300",  "E301",  "",  "",
+  "E400",  "E401",  "",  "",  "E500",  "E501",  "",  "",
+  "E600",  "E601",  "",  "",  "E700",  "E701",  "",  "",
+  "M001",  "M011",  "",  "",  "M101",  "M111",  "",  "",
+  "M201",  "M211",  "",  "",  "M301",  "M311",  "",  "",
+  "M401",  "M411",  "",  "",  "M501",  "M511",  "",  "",
+  "M601",  "M611",  "",  "",  "M701",  "M711",  "",  "",
+  "E010",  "E011",  "",  "",  "E110",  "E111",  "",  "",
+  "E210",  "E211",  "",  "",  "E310",  "E311",  "",  "",
+  "E410",  "E411",  "",  "",  "E510",  "E511",  "",  "",
+  "E610",  "E611",  "",  "",  "E710",  "E711",  "",  ""
+};
+
+static const char * const vfpu_mqreg_names[128] = {
+  "M000",  "",  "",  "",  "M100",  "",  "",  "",
+  "M200",  "",  "",  "",  "M300",  "",  "",  "",
+  "M400",  "",  "",  "",  "M500",  "",  "",  "",
+  "M600",  "",  "",  "",  "M700",  "",  "",  "",
+  "E000",  "",  "",  "",  "E100",  "",  "",  "",
+  "E200",  "",  "",  "",  "E300",  "",  "",  "",
+  "E400",  "",  "",  "",  "E500",  "",  "",  "",
+  "E600",  "",  "",  "",  "E700",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  ""
+};
+
 static const struct mips_cp0sel_name mips_cp0sel_names_mips3264[] = {
   { 16, 1, "c0_config1"		},
   { 16, 2, "c0_config2"		},
@@ -288,6 +421,54 @@
   "$24",  "$25",  "$26",  "$27",  "$28",  "$29",  "$30",  "$31"
 };
 
+static const char * const vfpu_cond_names[16] = {
+  "FL",  "EQ",  "LT",  "LE",  "TR",  "NE",  "GE",  "GT",
+  "EZ",  "EN",  "EI",  "ES",  "NZ",  "NN",  "NI",  "NS"
+};
+
+static const char * const vfpu_const_names[20] = {
+  "",
+  "VFPU_HUGE",
+  "VFPU_SQRT2",
+  "VFPU_SQRT1_2",
+  "VFPU_2_SQRTPI",
+  "VFPU_2_PI",
+  "VFPU_1_PI",
+  "VFPU_PI_4",
+  "VFPU_PI_2",
+  "VFPU_PI",
+  "VFPU_E",
+  "VFPU_LOG2E",
+  "VFPU_LOG10E",
+  "VFPU_LN2",
+  "VFPU_LN10",
+  "VFPU_2PI",
+  "VFPU_PI_6",
+  "VFPU_LOG10TWO",
+  "VFPU_LOG2TEN",
+  "VFPU_SQRT3_2"
+};
+
+#define VFPU_NUM_CONSTANTS \
+  ((sizeof vfpu_const_names) / (sizeof (vfpu_const_names[0])))
+const unsigned int vfpu_num_constants = VFPU_NUM_CONSTANTS;
+
+static const char * const vfpu_rwb_names[4] = {
+  "wt",  "wb",  "",  ""
+};
+
+static const char * const pfx_cst_names[8] = {
+  "0",  "1",  "2",  "1/2",  "3",  "1/3",  "1/4",  "1/6"
+};
+
+static const char * const pfx_swz_names[4] = {
+  "x",  "y",  "z",  "w"
+};
+
+static const char * const pfx_sat_names[4] = {
+  "",  "[0:1]",  "",  "[-1:1]"
+};
+
 struct mips_abi_choice {
   const char *name;
   const char * const *gpr_names;
@@ -359,6 +540,8 @@
     mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
   { "mips5",	1, bfd_mach_mips5, CPU_MIPS5, ISA_MIPS5,
     mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
+  { "allegrex", 1, bfd_mach_mips_allegrex, CPU_ALLEGREX, ISA_MIPS2,
+    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
 
   /* For stock MIPS32, disassemble all applicable MIPS-specified ASEs.
      Note that MIPS-3D and MDMX are not applicable to MIPS32.  (See
@@ -1029,6 +1212,121 @@
 	case 'Z':
 	  (*info->fprintf_func) (info->stream, "$v%d",
 				 (l >> OP_SH_FT) & OP_MASK_FT);
+	  break;
+
+	case '?':
+	  /* VFPU extensions.  */
+	  d++;
+	  switch (*d)
+	    {
+	    case '\0':
+	      /* xgettext:c-format */
+	      (*info->fprintf_func) (info->stream,
+				     _("# internal error, incomplete extension sequence (?)"));
+	      return;
+
+	    case 'o':
+	      delta = (l >> OP_SH_VFPU_DELTA) & OP_MASK_VFPU_DELTA;
+	      if (delta & 0x8000)
+		delta |= ~0xffff;
+	      (*info->fprintf_func) (info->stream, "%d",
+				     delta);
+	      break;
+
+	    case '0':
+	    case '1':
+	    case '2':
+	    case '3':
+	      break;
+
+	    case '4':
+	    case '5':
+	    case '6':
+	    case '7':
+	      break;
+
+	    case 'a':
+	      {
+		unsigned int c = (l >> OP_SH_VFPU_CONST) & OP_MASK_VFPU_CONST;
+		if (c < vfpu_num_constants)
+		  {
+		    (*info->fprintf_func) (info->stream, "%s",
+					   vfpu_const_names[c]);
+		  }
+		break;
+	      }
+
+	    case 'b':
+	      /* 5-bit immediate value.  */
+	      (*info->fprintf_func) (info->stream, "%d",
+				     (l >> OP_SH_VFPU_IMM5) & OP_MASK_VFPU_IMM5);
+	      break;
+
+	    case 'c':
+	      /* VFPU condition code.  */
+	      (*info->fprintf_func) (info->stream, "%d",
+				     (l >> OP_SH_VFPU_CC) & OP_MASK_VFPU_CC);
+	      break;
+
+	    case 'e':
+	      /* 3-bit immediate value.  */
+	      (*info->fprintf_func) (info->stream, "%d",
+				     (l >> OP_SH_VFPU_IMM3) & OP_MASK_VFPU_IMM3);
+	      break;
+
+	    case 'f':
+	      /* Conditional compare.  */
+	      (*info->fprintf_func) (info->stream, "%s",
+				     vfpu_cond_names[l & 0x0f]);
+	      /* Apparently this specifier is unused.  */
+	      d++;
+	      break;
+
+	    case 'i':
+	      /* 8-bit immediate value.  */
+	      (*info->fprintf_func) (info->stream, "0x%02x",
+				     (l >> OP_SH_VFPU_IMM8) & OP_MASK_VFPU_IMM8);
+	      break;
+
+	    case 'q':
+	      /* VFPU control register (vmtvc).  */
+	      (*info->fprintf_func) (info->stream, "$%d",
+				     l & 0xff);
+	      break;
+
+	    case 'r':
+	      /* VFPU control register (vmfvc).  */
+	      (*info->fprintf_func) (info->stream, "$%d",
+				     (l >> 8) & 0xff);
+	      break;
+
+	    case 'u':
+	      break;
+
+	    case 'w':
+	      break;
+
+	    case 'd':
+	    case 'm':
+	    case 'n':
+	    case 's':
+	    case 't':
+	    case 'v':
+	    case 'x':
+	      break;
+
+	    case 'z':
+	      (*info->fprintf_func) (info->stream, "%s",
+				     vfpu_rwb_names[(l >> 1) & 0x1]);
+	      break;
+
+	    default:
+	      /* xgettext:c-format */
+	      (*info->fprintf_func) (info->stream,
+				     _("# internal error, undefined extension sequence (?%c)"),
+				     *d);
+	      return;
+	    }
 	  break;
 
 	default:
diff -NBaur binutils-2.16.1/opcodes/mips-opc.c binutils-2.16.1-psp/opcodes/mips-opc.c
--- binutils-2.16.1/opcodes/mips-opc.c	Thu Mar  3 11:49:50 2005
+++ binutils-2.16.1-psp/opcodes/mips-opc.c	Mon Jul 25 20:30:04 2005
@@ -109,6 +109,7 @@
 #define N5	(INSN_5400 | INSN_5500)
 #define N54	INSN_5400
 #define N55	INSN_5500
+#define AL	INSN_ALLEGREX
 
 #define G1      (T3             \
                  )
@@ -271,6 +272,7 @@
 {"bnel",    "s,t,p",	0x54000000, 0xfc000000,	CBL|RD_s|RD_t, 		0,		I2|T3	},
 {"bnel",    "s,I,p",	0,    (int) M_BNEL_I,	INSN_MACRO,		0,		I2|T3	},
 {"break",   "",		0x0000000d, 0xffffffff,	TRAP,			0,		I1	},
+{"break",   "B",	0x0000000d, 0xfc00003f,	TRAP,			0,		I32|AL	},
 {"break",   "c",	0x0000000d, 0xfc00ffff,	TRAP,			0,		I1	},
 {"break",   "c,q",	0x0000000d, 0xfc00003f,	TRAP,			0,		I1	},
 {"c.f.d",   "S,T",	0x46200030, 0xffe007ff,	RD_S|RD_T|WR_CC|FP_D,	0,		I1	},
@@ -432,7 +434,7 @@
 {"cabs.un.d",  "M,S,T",	0x46200071, 0xffe000ff,	RD_S|RD_T|WR_CC|FP_D,	0,		M3D	},
 {"cabs.un.ps", "M,S,T",	0x46c00071, 0xffe000ff,	RD_S|RD_T|WR_CC|FP_D,	0,		M3D	},
 {"cabs.un.s",  "M,S,T",	0x46000071, 0xffe000ff,	RD_S|RD_T|WR_CC|FP_S,	0,		M3D	},
-{"cache",   "k,o(b)",   0xbc000000, 0xfc000000, RD_b,           	0,		I3|I32|T3},
+{"cache",   "k,o(b)",   0xbc000000, 0xfc000000, RD_b,           	0,		I3|I32|T3|AL},
 {"ceil.l.d", "D,S",	0x4620000a, 0xffff003f, WR_D|RD_S|FP_D,		0,		I3	},
 {"ceil.l.s", "D,S",	0x4600000a, 0xffff003f, WR_D|RD_S|FP_S,		0,		I3	},
 {"ceil.w.d", "D,S",	0x4620000e, 0xffff003f, WR_D|RD_S|FP_D,		0,		I2	},
@@ -443,7 +445,9 @@
 /* cfc2 is at the bottom of the table.  */
 {"cfc3",    "t,G",	0x4c400000, 0xffe007ff,	LCD|WR_t|RD_C3,		0,		I1	},
 {"clo",     "U,s",      0x70000021, 0xfc0007ff, WR_d|WR_t|RD_s, 	0,		I32|N55 },
+{"clo",     "d,s",      0x00000017, 0xfc1f07ff, WR_d|RD_s,      	0,		AL	},
 {"clz",     "U,s",      0x70000020, 0xfc0007ff, WR_d|WR_t|RD_s, 	0,		I32|N55 },
+{"clz",     "d,s",      0x00000016, 0xfc1f07ff, WR_d|RD_s,              0,              AL      },
 {"ctc0",    "t,G",	0x40c00000, 0xffe007ff,	COD|RD_t|WR_CC,		0,		I1	},
 {"ctc1",    "t,G",	0x44c00000, 0xffe007ff,	COD|RD_t|WR_CC|FP_S,	0,		I1	},
 {"ctc1",    "t,S",	0x44c00000, 0xffe007ff,	COD|RD_t|WR_CC|FP_S,	0,		I1	},
@@ -465,10 +469,12 @@
 {"cvt.ps.s","D,V,T",	0x46000026, 0xffe0003f,	WR_D|RD_S|RD_T|FP_D,	0,		I5	},
 {"cvt.pw.ps", "D,S",	0x46c00024, 0xffff003f,	WR_D|RD_S|FP_S|FP_D,	0,		M3D	},
 {"dabs",    "d,v",	0,    (int) M_DABS,	INSN_MACRO,		0,		I3	},
+{"max",     "d,v,t",    0x0000002c, 0xfc0007ff, WR_d|RD_s|RD_t,         0,              AL	},
 {"dadd",    "d,v,t",	0x0000002c, 0xfc0007ff, WR_d|RD_s|RD_t,		0,		I3	},
 {"dadd",    "t,r,I",	0,    (int) M_DADD_I,	INSN_MACRO,		0,		I3	},
 {"daddi",   "t,r,j",	0x60000000, 0xfc000000, WR_t|RD_s,		0,		I3	},
 {"daddiu",  "t,r,j",	0x64000000, 0xfc000000, WR_t|RD_s,		0,		I3	},
+{"min",     "d,v,t",    0x0000002d, 0xfc0007ff, WR_d|RD_s|RD_t,         0,              AL	},
 {"daddu",   "d,v,t",	0x0000002d, 0xfc0007ff, WR_d|RD_s|RD_t,		0,		I3	},
 {"daddu",   "t,r,I",	0,    (int) M_DADDU_I,	INSN_MACRO,		0,		I3	},
 {"dbreak",  "",		0x7000003f, 0xffffffff,	0,			0,		N5	},
@@ -595,8 +601,8 @@
 {"dsubu",   "d,v,I",	0,    (int) M_DSUBU_I,	INSN_MACRO,		0,		I3	},
 {"ei",      "",		0x41606020, 0xffffffff,	WR_t|WR_C0,		0,		I33	},
 {"ei",      "t",	0x41606020, 0xffe0ffff,	WR_t|WR_C0,		0,		I33	},
-{"eret",    "",         0x42000018, 0xffffffff, 0,      		0,		I3|I32	},
-{"ext",     "t,r,+A,+C", 0x7c000000, 0xfc00003f, WR_t|RD_s,    		0,		I33	},
+{"eret",    "",         0x42000018, 0xffffffff, 0,      		0,		I3|I32|AL	},
+{"ext",     "t,r,+A,+C", 0x7c000000, 0xfc00003f, WR_t|RD_s,    		0,		I33|AL	},
 {"floor.l.d", "D,S",	0x4620000b, 0xffff003f, WR_D|RD_S|FP_D,		0,		I3	},
 {"floor.l.s", "D,S",	0x4600000b, 0xffff003f, WR_D|RD_S|FP_S,		0,		I3	},
 {"floor.w.d", "D,S",	0x4620000f, 0xffff003f, WR_D|RD_S|FP_D,		0,		I2	},
@@ -605,7 +611,7 @@
 {"flushd",  "",		0xbc020000, 0xffffffff, 0, 			0,		L1	},
 {"flushid", "",		0xbc030000, 0xffffffff, 0, 			0,		L1	},
 {"hibernate","",        0x42000023, 0xffffffff,	0, 			0,		V1	},
-{"ins",     "t,r,+A,+B", 0x7c000004, 0xfc00003f, WR_t|RD_s,    		0,		I33	},
+{"ins",     "t,r,+A,+B", 0x7c000004, 0xfc00003f, WR_t|RD_s,    		0,		I33|AL	},
 {"jr",      "s",	0x00000008, 0xfc1fffff,	UBD|RD_s,		0,		I1	},
 {"jr.hb",   "s",	0x00000408, 0xfc1fffff,	UBD|RD_s,		0,		I33	},
 {"j",       "s",	0x00000008, 0xfc1fffff,	UBD|RD_s,		0,		I1	}, /* jr */
@@ -639,18 +645,11 @@
 {"ld",	    "t,o(b)",   0xdc000000, 0xfc000000, WR_t|RD_b,		0,		I3	},
 {"ld",      "t,o(b)",	0,    (int) M_LD_OB,	INSN_MACRO,		0,		I1	},
 {"ld",      "t,A(b)",	0,    (int) M_LD_AB,	INSN_MACRO,		0,		I1	},
-{"ldc1",    "T,o(b)",	0xd4000000, 0xfc000000, CLD|RD_b|WR_T|FP_D,	0,		I2	},
-{"ldc1",    "E,o(b)",	0xd4000000, 0xfc000000, CLD|RD_b|WR_T|FP_D,	0,		I2	},
-{"ldc1",    "T,A(b)",	0,    (int) M_LDC1_AB,	INSN_MACRO,		0,		I2	},
-{"ldc1",    "E,A(b)",	0,    (int) M_LDC1_AB,	INSN_MACRO,		0,		I2	},
-{"l.d",     "T,o(b)",	0xd4000000, 0xfc000000, CLD|RD_b|WR_T|FP_D,	0,		I2	}, /* ldc1 */
-{"l.d",     "T,o(b)",	0,    (int) M_L_DOB,	INSN_MACRO,		0,		I1	},
-{"l.d",     "T,A(b)",	0,    (int) M_L_DAB,	INSN_MACRO,		0,		I1	},
-{"ldc2",    "E,o(b)",	0xd8000000, 0xfc000000, CLD|RD_b|WR_CC,		0,		I2	},
-{"ldc2",    "E,A(b)",	0,    (int) M_LDC2_AB,	INSN_MACRO,		0,		I2	},
+/* ldc1 is at the bottom of the table.  */
+/* ldc2 is at the bottom of the table.  */
 {"ldc3",    "E,o(b)",	0xdc000000, 0xfc000000, CLD|RD_b|WR_CC,		0,		I2	},
 {"ldc3",    "E,A(b)",	0,    (int) M_LDC3_AB,	INSN_MACRO,		0,		I2	},
-{"ldl",	    "t,o(b)",	0x68000000, 0xfc000000, LDD|WR_t|RD_b,		0,		I3	},
+{"ldl",	    "t,o(b)",	0x68000000, 0xfc000000, LDD|WR_t|RD_b,		0,		I3|AL	},
 {"ldl",	    "t,A(b)",	0,    (int) M_LDL_AB,	INSN_MACRO,		0,		I3	},
 {"ldr",	    "t,o(b)",	0x6c000000, 0xfc000000, LDD|WR_t|RD_b,		0,		I3	},
 {"ldr",     "t,A(b)",	0,    (int) M_LDR_AB,	INSN_MACRO,		0,		I3	},
@@ -680,8 +679,7 @@
 {"lwc1",    "E,A(b)",	0,    (int) M_LWC1_AB,	INSN_MACRO,		0,		I1	},
 {"l.s",     "T,o(b)",	0xc4000000, 0xfc000000,	CLD|RD_b|WR_T|FP_S,	0,		I1	}, /* lwc1 */
 {"l.s",     "T,A(b)",	0,    (int) M_LWC1_AB,	INSN_MACRO,		0,		I1	},
-{"lwc2",    "E,o(b)",	0xc8000000, 0xfc000000,	CLD|RD_b|WR_CC,		0,		I1	},
-{"lwc2",    "E,A(b)",	0,    (int) M_LWC2_AB,	INSN_MACRO,		0,		I1	},
+/* lwc2 is at the bottom of the table.  */
 {"lwc3",    "E,o(b)",	0xcc000000, 0xfc000000,	CLD|RD_b|WR_CC,		0,		I1	},
 {"lwc3",    "E,A(b)",	0,    (int) M_LWC3_AB,	INSN_MACRO,		0,		I1	},
 {"lwl",     "t,o(b)",	0x88000000, 0xfc000000,	LDD|RD_b|WR_t,		0,		I1	},
@@ -713,10 +711,12 @@
 {"madd.s",  "D,R,S,T",	0x4c000020, 0xfc00003f, RD_R|RD_S|RD_T|WR_D|FP_S,    0,		I4	},
 {"madd.ps", "D,R,S,T",	0x4c000026, 0xfc00003f, RD_R|RD_S|RD_T|WR_D|FP_D,    0,		I5	},
 {"madd",    "s,t",      0x0000001c, 0xfc00ffff, RD_s|RD_t|WR_HILO,           0,		L1 },
+{"madd",    "s,t",      0x0000001c, 0xfc00ffff, RD_s|RD_t|WR_HILO|IS_M,      0,         AL	},
 {"madd",    "s,t",      0x70000000, 0xfc00ffff, RD_s|RD_t|MOD_HILO,          0,		I32|N55},
 {"madd",    "s,t",      0x70000000, 0xfc00ffff, RD_s|RD_t|WR_HILO|IS_M,      0,		G1 },
 {"madd",    "d,s,t",    0x70000000, 0xfc0007ff, RD_s|RD_t|WR_HILO|WR_d|IS_M, 0,		G1 },
 {"maddu",   "s,t",      0x0000001d, 0xfc00ffff, RD_s|RD_t|WR_HILO,           0,		L1 },
+{"maddu",   "s,t",      0x0000001d, 0xfc00ffff, RD_s|RD_t|WR_HILO|IS_M,      0,         AL	},
 {"maddu",   "s,t",      0x70000001, 0xfc00ffff, RD_s|RD_t|MOD_HILO,          0,		I32|N55},
 {"maddu",   "s,t",      0x70000001, 0xfc00ffff, RD_s|RD_t|WR_HILO|IS_M,      0,		G1	},
 {"maddu",   "d,s,t",    0x70000001, 0xfc0007ff, RD_s|RD_t|WR_HILO|WR_d|IS_M, 0,		G1	},
@@ -756,7 +756,7 @@
 {"movf.l",  "X,Y,N",	0x46a00011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_D,	0,		MX|SB1	},
 {"movf.s",  "D,S,N",    0x46000011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_S,   0,		I4|I32	},
 {"movf.ps", "D,S,N",	0x46c00011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_D,	0,		I5	},
-{"movn",    "d,v,t",    0x0000000b, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		I4|I32	},
+{"movn",    "d,v,t",    0x0000000b, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		I4|I32|AL	},
 {"ffc",     "d,v",	0x0000000b, 0xfc1f07ff,	WR_d|RD_s,		0,		L1	},
 {"movn.d",  "D,S,t",    0x46200013, 0xffe0003f, WR_D|RD_S|RD_t|FP_D,    0,		I4|I32	},
 {"movn.l",  "D,S,t",    0x46a00013, 0xffe0003f, WR_D|RD_S|RD_t|FP_D,    0,		MX|SB1	},
@@ -769,7 +769,7 @@
 {"movt.l",  "X,Y,N",    0x46a10011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_D,   0,		MX|SB1	},
 {"movt.s",  "D,S,N",    0x46010011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_S,   0,		I4|I32	},
 {"movt.ps", "D,S,N",	0x46c10011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_D,	0,		I5	},
-{"movz",    "d,v,t",    0x0000000a, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		I4|I32	},
+{"movz",    "d,v,t",    0x0000000a, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		I4|I32|AL	},
 {"ffs",     "d,v",	0x0000000a, 0xfc1f07ff,	WR_d|RD_s,		0,		L1	},
 {"movz.d",  "D,S,t",    0x46200012, 0xffe0003f, WR_D|RD_S|RD_t|FP_D,    0,		I4|I32	},
 {"movz.l",  "D,S,t",    0x46a00012, 0xffe0003f, WR_D|RD_S|RD_t|FP_D,    0,		MX|SB1	},
@@ -786,8 +786,10 @@
 {"msub.s",  "D,R,S,T",	0x4c000028, 0xfc00003f, RD_R|RD_S|RD_T|WR_D|FP_S, 0,		I4	},
 {"msub.ps", "D,R,S,T",	0x4c00002e, 0xfc00003f, RD_R|RD_S|RD_T|WR_D|FP_D, 0,		I5	},
 {"msub",    "s,t",      0x0000001e, 0xfc00ffff, RD_s|RD_t|WR_HILO,	0,		L1    	},
+{"msub",    "s,t",      0x0000002e, 0xfc00ffff, RD_s|RD_t|WR_HILO|IS_M, 0,              AL	},
 {"msub",    "s,t",      0x70000004, 0xfc00ffff, RD_s|RD_t|MOD_HILO,     0,		I32|N55 },
 {"msubu",   "s,t",      0x0000001f, 0xfc00ffff, RD_s|RD_t|WR_HILO,	0,		L1	},
+{"msubu",   "s,t",      0x0000002f, 0xfc00ffff, RD_s|RD_t|WR_HILO|IS_M, 0,              AL	},
 {"msubu",   "s,t",      0x70000005, 0xfc00ffff, RD_s|RD_t|MOD_HILO,     0,		I32|N55	},
 {"mtpc",    "t,P",	0x4080c801, 0xffe0ffc1,	COD|RD_t|WR_C0,		0,		M1|N5	},
 {"mtps",    "t,P",	0x4080c800, 0xffe0ffc1,	COD|RD_t|WR_C0,		0,		M1|N5	},
@@ -936,13 +938,13 @@
 {"rol",     "d,v,I",	0,    (int) M_ROL_I,	INSN_MACRO,		0,		I1	},
 {"ror",     "d,v,t",	0,    (int) M_ROR,	INSN_MACRO,		0,		I1	},
 {"ror",     "d,v,I",	0,    (int) M_ROR_I,	INSN_MACRO,		0,		I1	},
-{"ror",	    "d,w,<",	0x00200002, 0xffe0003f,	WR_d|RD_t,		0,		N5|I33	},
-{"rorv",    "d,t,s",	0x00000046, 0xfc0007ff,	RD_t|RD_s|WR_d,		0,		N5|I33	},
-{"rotl",    "d,v,t",	0,    (int) M_ROL,	INSN_MACRO,		0,		I33	},
-{"rotl",    "d,v,I",	0,    (int) M_ROL_I,	INSN_MACRO,		0,		I33	},
-{"rotr",    "d,v,t",	0,    (int) M_ROR,	INSN_MACRO,		0,		I33	},
-{"rotr",    "d,v,I",	0,    (int) M_ROR_I,	INSN_MACRO,		0,		I33	},
-{"rotrv",   "d,t,s",	0x00000046, 0xfc0007ff,	RD_t|RD_s|WR_d,		0,		I33	},
+{"ror",	    "d,w,<",	0x00200002, 0xffe0003f,	WR_d|RD_t,		0,		N5|I33|AL	},
+{"rorv",    "d,t,s",	0x00000046, 0xfc0007ff,	RD_t|RD_s|WR_d,		0,		N5|I33|AL	},
+{"rotl",    "d,v,t",	0,    (int) M_ROL,	INSN_MACRO,		0,		I33|AL	},
+{"rotl",    "d,v,I",	0,    (int) M_ROL_I,	INSN_MACRO,		0,		I33|AL	},
+{"rotr",    "d,v,t",	0,    (int) M_ROR,	INSN_MACRO,		0,		I33|AL	},
+{"rotr",    "d,v,I",	0,    (int) M_ROR_I,	INSN_MACRO,		0,		I33|AL	},
+{"rotrv",   "d,t,s",	0x00000046, 0xfc0007ff,	RD_t|RD_s|WR_d,		0,		I33|AL	},
 {"round.l.d", "D,S",	0x46200008, 0xffff003f, WR_D|RD_S|FP_D,		0,		I3	},
 {"round.l.s", "D,S",	0x46000008, 0xffff003f, WR_D|RD_S|FP_S,		0,		I3	},
 {"round.w.d", "D,S",	0x4620000c, 0xffff003f, WR_D|RD_S|FP_D,		0,		I2	},
@@ -974,24 +976,18 @@
 {"sdbbp",   "c,q",	0x0000000e, 0xfc00003f,	TRAP,			0,		G2	},
 {"sdbbp",   "",         0x7000003f, 0xffffffff, TRAP,           	0,		I32     },
 {"sdbbp",   "B",        0x7000003f, 0xfc00003f, TRAP,           	0,		I32     },
-{"sdc1",    "T,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,	0,		I2	},
-{"sdc1",    "E,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,	0,		I2	},
-{"sdc1",    "T,A(b)",	0,    (int) M_SDC1_AB,	INSN_MACRO,		0,		I2	},
-{"sdc1",    "E,A(b)",	0,    (int) M_SDC1_AB,	INSN_MACRO,		0,		I2	},
-{"sdc2",    "E,o(b)",	0xf8000000, 0xfc000000, SM|RD_C2|RD_b,		0,		I2	},
-{"sdc2",    "E,A(b)",	0,    (int) M_SDC2_AB,	INSN_MACRO,		0,		I2	},
+/* sdc1 is at the bottom of the table.  */ 
+/* sdc2 is at the bottom of the table.  */
 {"sdc3",    "E,o(b)",	0xfc000000, 0xfc000000, SM|RD_C3|RD_b,		0,		I2	},
 {"sdc3",    "E,A(b)",	0,    (int) M_SDC3_AB,	INSN_MACRO,		0,		I2	},
-{"s.d",     "T,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,	0,		I2	},
-{"s.d",     "T,o(b)",	0,    (int) M_S_DOB,	INSN_MACRO,		0,		I1	},
-{"s.d",     "T,A(b)",	0,    (int) M_S_DAB,	INSN_MACRO,		0,		I1	},
-{"sdl",     "t,o(b)",	0xb0000000, 0xfc000000,	SM|RD_t|RD_b,		0,		I3	},
+/* s.d (sdc1 is at the bottom of the table.  */
+{"sdl",     "t,o(b)",	0xb0000000, 0xfc000000,	SM|RD_t|RD_b,		0,		I3|AL	},
 {"sdl",     "t,A(b)",	0,    (int) M_SDL_AB,	INSN_MACRO,		0,		I3	},
 {"sdr",     "t,o(b)",	0xb4000000, 0xfc000000,	SM|RD_t|RD_b,		0,		I3	},
 {"sdr",     "t,A(b)",	0,    (int) M_SDR_AB,	INSN_MACRO,		0,		I3	},
 {"sdxc1",   "S,t(b)",   0x4c000009, 0xfc0007ff, SM|RD_S|RD_t|RD_b,	0,		I4	},
-{"seb",     "d,w",	0x7c000420, 0xffe007ff,	WR_d|RD_t,		0,		I33	},
-{"seh",     "d,w",	0x7c000620, 0xffe007ff,	WR_d|RD_t,		0,		I33	},
+{"seb",     "d,w",	0x7c000420, 0xffe007ff,	WR_d|RD_t,		0,		I33|AL	},
+{"seh",     "d,w",	0x7c000620, 0xffe007ff,	WR_d|RD_t,		0,		I33|AL	},
 {"selsl",   "d,v,t",	0x00000005, 0xfc0007ff,	WR_d|RD_s|RD_t,		0,		L1	},
 {"selsr",   "d,v,t",	0x00000001, 0xfc0007ff,	WR_d|RD_s|RD_t,		0,		L1	},
 {"seq",     "d,v,t",	0,    (int) M_SEQ,	INSN_MACRO,		0,		I1	},
@@ -1083,8 +1079,7 @@
 {"swc1",    "E,A(b)",	0,    (int) M_SWC1_AB,	INSN_MACRO,		0,		I1	},
 {"s.s",     "T,o(b)",	0xe4000000, 0xfc000000,	SM|RD_T|RD_b|FP_S,	0,		I1	}, /* swc1 */
 {"s.s",     "T,A(b)",	0,    (int) M_SWC1_AB,	INSN_MACRO,		0,		I1	},
-{"swc2",    "E,o(b)",	0xe8000000, 0xfc000000,	SM|RD_C2|RD_b,		0,		I1	},
-{"swc2",    "E,A(b)",	0,    (int) M_SWC2_AB,	INSN_MACRO,		0,		I1	},
+/* swc2 is at the bottom of the table.  */
 {"swc3",    "E,o(b)",	0xec000000, 0xfc000000,	SM|RD_C3|RD_b,		0,		I1	},
 {"swc3",    "E,A(b)",	0,    (int) M_SWC3_AB,	INSN_MACRO,		0,		I1	},
 {"swl",     "t,o(b)",	0xa8000000, 0xfc000000,	SM|RD_t|RD_b,		0,		I1	},
@@ -1169,7 +1164,8 @@
 {"waiti",   "",		0x42000020, 0xffffffff,	TRAP,			0,		L1	},
 {"wb", 	    "o(b)",	0xbc040000, 0xfc1f0000, SM|RD_b,		0,		L1	},
 {"wrpgpr",  "d,w",	0x41c00000, 0xffe007ff, RD_t,			0,		I33	},
-{"wsbh",    "d,w",	0x7c0000a0, 0xffe007ff,	WR_d|RD_t,		0,		I33	},
+{"wsbh",    "d,w",	0x7c0000a0, 0xffe007ff,	WR_d|RD_t,		0,		I33|AL	},
+{"wsbw",    "d,t",	0x7c0000e0, 0xffe007ff, WR_d|RD_t,		0,		AL	},
 {"xor",     "d,v,t",	0x00000026, 0xfc0007ff,	WR_d|RD_s|RD_t,		0,		I1	},
 {"xor",     "t,r,I",	0,    (int) M_XOR_I,	INSN_MACRO,		0,		I1	},
 {"xor.ob",  "X,Y,Q",	0x7800000d, 0xfc20003f,	WR_D|RD_S|RD_T|FP_D,	0,		MX|SB1	},
@@ -1179,6 +1175,320 @@
 {"xor.qh",  "X,Y,Q",	0x7820000d, 0xfc20003f,	WR_D|RD_S|RD_T|FP_D,	0,		MX	},
 {"xori",    "t,r,i",	0x38000000, 0xfc000000,	WR_t|RD_s,		0,		I1	},
 
+/* Sony Allegrex CPU core.  */
+{"bitrev",  "d,t",      0x7c000520, 0xffe007ff, WR_d|RD_t,              0,              AL	},
+
+/* Sony Allegrex VFPU instructions.  */
+/* MRB: I don't know all of the instructions that should be using WR_C2/RD_C2 (they're just synonyms
+   for INSN_COP).  It's not that important and more for reference, but someone should fill them in later.  */
+/* MRB: I don't know the real macro names either, so they are assumed from the opcode's name.  */
+{"bvf",     "?c,p",		0x49000000, 0xffe30000, CBD|RD_CC,	0,		AL	},
+{"bvfl",    "?c,p",		0x49020000, 0xffe30000, CBL|RD_CC,	0,		AL	},
+{"bvt",     "?c,p",		0x49010000, 0xffe30000, CBD|RD_CC,	0,		AL	},
+{"bvtl",    "?c,p",		0x49030000, 0xffe30000, CBL|RD_CC,	0,		AL	},
+{"lv.s",    "?m0x,?o(b)",	0xc8000000, 0xfc000000, CLD|RD_s|WR_CC,	0,		AL	},
+{"lv.s",    "?m0x,A(b)",	0         , 0x00000073, INSN_MACRO,	0,		AL	},
+{"ulv.s",   "?m0x,o(b)",	0         , 0x000000da, INSN_MACRO,	0,		AL	},
+{"lv.q",    "?n3x,?o(b)",	0xd8000000, 0xfc000002, CLD|RD_s|WR_CC,	0,		AL	},
+{"lv.q",    "?n3x,A(b)",	0         , 0x00000074, INSN_MACRO,	0,		AL	},
+{"ulv.q",   "?n3x,?o(b)",	0         , 0x000000dc, INSN_MACRO,	0,		AL	},
+{"ulv.q",   "?n3x,A(b)",	0         , 0x000000dd, INSN_MACRO,	0,		AL	},
+{"lvi.s",   "?t0x,l?y0",	0         , 0x00000062, INSN_MACRO,	0,		AL	},
+{"lvi.p",   "?t1x,?[l?y0,l?y1?]", 0         , 0x00000063, INSN_MACRO,	0,		AL	},
+{"lvi.t",   "?t2x,?[l?y0,l?y1,l?y2?]", 0         , 0x00000064, INSN_MACRO, 0,		AL	},
+{"lvi.q",   "?t3x,?[l?y0,l?y1,l?y2,l?y3?]", 0         , 0x00000065, INSN_MACRO,	0,	AL	},
+{"lvhi.s",  "?t0x,?[?u?y0,?u?y1?]", 0         , 0x00000060, INSN_MACRO, 0,		AL	},
+{"lvhi.p",  "?t1x,?[?u?y0,?u?y1,?u?y2,?u?y3?]", 0         , 0x00000061, INSN_MACRO, 0,	AL	},
+{"sv.s",    "?m0x,?o(b)",	0xe8000000, 0xfc000000, SM|RD_s|RD_C0,	0,		AL	},
+{"sv.s",    "?m0x,A(b)",	0         , 0x000000bf, INSN_MACRO,	0,		AL	},
+{"usv.s",   "?m0x,o(b)",	0         , 0x000000e4, INSN_MACRO,	0,		AL	},
+{"sv.q",    "?n3x,?o(b)",	0xf8000000, 0xfc000002, SM|RD_s|RD_C0,	0,		AL	},
+{"sv.q",    "?n3x,?o(b),?z",	0xf8000000, 0xfc000000, SM|RD_s|RD_C0,	0,		AL	},
+{"sv.q",    "?n3x,A(b)",	0         , 0x000000c0, INSN_MACRO,	0,		AL	},
+{"sv.q",    "?n3x,A(b),?z",	0         , 0x000000c0, INSN_MACRO,	0,		AL	},
+{"sv.q",    "?n3x,A,?z",	0         , 0x000000c0, INSN_MACRO,	0,		AL	},
+{"usv.q",   "?n3x,?o(b)",	0         , 0x000000e6, INSN_MACRO,	0,		AL	},
+{"usv.q",   "?n3x,A(b)",	0         , 0x000000e7, INSN_MACRO,	0,		AL	},
+{"vwb.q",   "?n3x,?o(b)",	0xf8000002, 0xfc000002, SM|RD_s|RD_C0,	0,		AL	},
+{"lvl.q",   "?n3x,?o(b)",	0xd4000000, 0xfc000002, CLD|RD_s|WR_CC,	0,		AL	},
+{"lvl.q",   "?n3x,A(b)",	0         , 0x00000075, INSN_MACRO,	0,		AL	},
+{"lvr.q",   "?n3x,?o(b)",	0xd4000002, 0xfc000002, CLD|RD_s|WR_CC,	0,		AL	},
+{"lvr.q",   "?n3x,A(b)",	0         , 0x00000076, INSN_MACRO,	0,		AL	},
+{"svl.q",   "?n3x,?o(b)",	0xf4000000, 0xfc000002, SM|RD_s|RD_C0,	0,		AL	},
+{"svl.q",   "?n3x,A(b)",	0         , 0x000000c1, INSN_MACRO,	0,		AL	},
+{"svr.q",   "?n3x,?o(b)",	0xf4000002, 0xfc000002, SM|RD_s|RD_C0,	0,		AL	},
+{"svr.q",   "?n3x,A(b)",	0         , 0x000000c2, INSN_MACRO,	0,		AL	},
+{"mtv",     "t,?d0z",		0x48e00000, 0xffe0ff80, LCD|WR_t|RD_C0,	0,		AL	},
+{"mfv",     "t,?d0z",		0x48600000, 0xffe0ff80, COD|RD_t|WR_CC|RD_C0, 0,	AL	},
+{"mtvc",    "t,?q",		0x48e00000, 0xffe0ff00, LCD|WR_t|RD_C0,	0,		AL	},
+{"mfvc",    "t,?q",		0x48600000, 0xffe0ff00, COD|RD_t|WR_CC|RD_C0, 0,	AL	},
+{"vmtvc",   "?q,?s0y",		0xd0510000, 0xffff8000, RD_C0,		0,		AL	},
+{"vmfvc",   "?d0z,?r",		0xd0500000, 0xffff0080, RD_C0,		0,		AL	},
+{"vadd.q",  "?d3d,?s3s,?t3t",	0x60008080, 0xff808080, RD_C0,		0,		AL	},
+{"vsub.q",  "?d3d,?s3s,?t3t",	0x60808080, 0xff808080, RD_C0,		0,		AL	},
+{"vdiv.q",  "?x3z,?s3y,?t3x",	0x63808080, 0xff808080, RD_C0,		0,		AL	},
+{"vmul.q",  "?d3d,?s3s,?t3t",	0x64008080, 0xff808080, RD_C0,		0,		AL	},
+{"vdot.q",  "?d0d,?s3s,?t3t",	0x64808080, 0xff808080, RD_C0,		0,		AL	},
+{"vscl.q",  "?d3d,?s3s,?t0x",	0x65008080, 0xff808080, RD_C0,		0,		AL	},
+{"vhdp.q",  "?d0d,?s3y,?t3t",	0x66008080, 0xff808080, RD_C0,		0,		AL	},
+{"vcmp.q",  "?f2,?s3s,?t3t",	0x6c008080, 0xff8080f0, RD_C0,		0,		AL	},
+{"vcmp.q",  "?f1,?s3s",		0x6c008080, 0xffff80f0, RD_C0,		0,		AL	},
+{"vcmp.q",  "?f0",		0x6c008080, 0xfffffff0, RD_C0,		0,		AL	},
+{"vmin.q",  "?d3d,?s3s,?t3t",	0x6d008080, 0xff808080, RD_C0,		0,		AL	},
+{"vmax.q",  "?d3d,?s3s,?t3t",	0x6d808080, 0xff808080, RD_C0,		0,		AL	},
+{"vsgn.q",  "?d3d,?s3s",	0xd04a8080, 0xffff8080, RD_C0,		0,		AL	},
+{"vcst.q",  "?d3d,?a",		0xd0608080, 0xffe0ff80, RD_C0,		0,		AL	},
+{"vscmp.q", "?d3d,?s3s,?t3t",	0x6e808080, 0xff808080, RD_C0,		0,		AL	},
+{"vsge.q",  "?d3d,?s3s,?t3t",	0x6f008080, 0xff808080, RD_C0,		0,		AL	},
+{"vslt.q",  "?d3d,?s3s,?t3t",	0x6f808080, 0xff808080, RD_C0,		0,		AL	},
+{"vi2uc.q", "?d0m,?s3w",	0xd03c8080, 0xffff8080, RD_C0,		0,		AL	},
+{"vi2c.q",  "?d0m,?s3w",	0xd03d8080, 0xffff8080, RD_C0,		0,		AL	},
+{"vi2us.q", "?d1m,?s3w",	0xd03e8080, 0xffff8080, RD_C0,		0,		AL	},
+{"vi2s.q",  "?d1m,?s3w",	0xd03f8080, 0xffff8080, RD_C0,		0,		AL	},
+{"vmov.q",  "?d3d,?s3s",	0xd0008080, 0xffff8080, RD_C0,		0,		AL	},
+{"vabs.q",  "?d3d,?s3w",	0xd0018080, 0xffff8080, RD_C0,		0,		AL	},
+{"vneg.q",  "?d3d,?s3w",	0xd0028080, 0xffff8080, RD_C0,		0,		AL	},
+{"vidt.q",  "?d3d",		0xd0038080, 0xffffff80, RD_C0,		0,		AL	},
+{"vsat0.q", "?d3z,?s3s",	0xd0048080, 0xffff8080, RD_C0,		0,		AL	},
+{"vsat1.q", "?d3z,?s3s",	0xd0058080, 0xffff8080, RD_C0,		0,		AL	},
+{"vzero.q", "?d3d",		0xd0068080, 0xffffff80, RD_C0,		0,		AL	},
+{"vone.q",  "?d3d",		0xd0078080, 0xffffff80, RD_C0,		0,		AL	},
+{"vrcp.q",  "?x3z,?s3y",	0xd0108080, 0xffff8080, RD_C0,		0,		AL	},
+{"vrsq.q",  "?x3z,?s3y",	0xd0118080, 0xffff8080, RD_C0,		0,		AL	},
+{"vsin.q",  "?x3z,?s3y",	0xd0128080, 0xffff8080, RD_C0,		0,		AL	},
+{"vcos.q",  "?x3z,?s3y",	0xd0138080, 0xffff8080, RD_C0,		0,		AL	},
+{"vexp2.q", "?x3z,?s3y",	0xd0148080, 0xffff8080, RD_C0,		0,		AL	},
+{"vlog2.q", "?x3z,?s3y",	0xd0158080, 0xffff8080, RD_C0,		0,		AL	},
+{"vsqrt.q", "?x3z,?s3y",	0xd0168080, 0xffff8080, RD_C0,		0,		AL	},
+{"vasin.q", "?x3z,?s3y",	0xd0178080, 0xffff8080, RD_C0,		0,		AL	},
+{"vnrcp.q", "?x3z,?s3y",	0xd0188080, 0xffff8080, RD_C0,		0,		AL	},
+{"vnsin.q", "?x3z,?s3y",	0xd01a8080, 0xffff8080, RD_C0,		0,		AL	},
+{"vrexp2.q", "?x3z,?s3y",	0xd01c8080, 0xffff8080, RD_C0,		0,		AL	},
+{"vrndi.q", "?d3z",		0xd0218080, 0xffffff80, RD_C0,		0,		AL	},
+{"vrndf1.q", "?d3z",		0xd0228080, 0xffffff80, RD_C0,		0,		AL	},
+{"vrndf2.q", "?d3z",		0xd0238080, 0xffffff80, RD_C0,		0,		AL	},
+{"vf2h.q",  "?d1m,?s3s",	0xd0328080, 0xffff8080, RD_C0,		0,		AL	},
+{"vsrt1.q", "?d3d,?s3s",	0xd0408080, 0xffff8080, RD_C0,		0,		AL	},
+{"vsrt2.q", "?d3d,?s3s",	0xd0418080, 0xffff8080, RD_C0,		0,		AL	},
+{"vsrt3.q", "?d3d,?s3s",	0xd0488080, 0xffff8080, RD_C0,		0,		AL	},
+{"vsrt4.q", "?d3d,?s3s",	0xd0498080, 0xffff8080, RD_C0,		0,		AL	},
+{"vbfy1.q", "?d3d,?s3s",	0xd0428080, 0xffff8080, RD_C0,		0,		AL	},
+{"vbfy2.q", "?d3d,?s3s",	0xd0438080, 0xffff8080, RD_C0,		0,		AL	},
+{"vocp.q",  "?d3d,?s3y",	0xd0448080, 0xffff8080, RD_C0,		0,		AL	},
+{"vfad.q",  "?d0d,?s3s",	0xd0468080, 0xffff8080, RD_C0,		0,		AL	},
+{"vavg.q",  "?d0d,?s3s",	0xd0478080, 0xffff8080, RD_C0,		0,		AL	},
+{"vf2in.q", "?d3m,?s3s,?b",	0xd2008080, 0xffe08080, RD_C0,		0,		AL	},
+{"vf2iz.q", "?d3m,?s3s,?b",	0xd2208080, 0xffe08080, RD_C0,		0,		AL	},
+{"vf2iu.q", "?d3m,?s3s,?b",	0xd2408080, 0xffe08080, RD_C0,		0,		AL	},
+{"vf2id.q", "?d3m,?s3s,?b",	0xd2608080, 0xffe08080, RD_C0,		0,		AL	},
+{"vi2f.q",  "?d3d,?s3w,?b",	0xd2808080, 0xffe08080, RD_C0,		0,		AL	},
+{"vcmov.q", "?d3d,?s3s,?e",	0         , 0x000000e9, INSN_MACRO,	0,		AL	},
+{"vcmovt.q", "?d3d,?s3s,?e",	0xd2a08080, 0xfff88080, RD_C0,		0,		AL	},
+{"vcmovf.q", "?d3d,?s3s,?e",	0xd2a88080, 0xfff88080, RD_C0,		0,		AL	},
+{"vmmul.q", "?v7z,?s7y,?t7x",	0xf0008080, 0xff808080, RD_C0,		0,		AL	},
+{"vtfm4.q", "?v3z,?s7y,?t3x",	0xf1808080, 0xff808080, RD_C0,		0,		AL	},
+{"vhtfm4.q", "?v3z,?s7y,?t3x",	0xf1808000, 0xff808080, RD_C0,		0,		AL	},
+{"vmscl.q", "?x7z,?s7y,?t0x",	0xf2008080, 0xff808080, RD_C0,		0,		AL	},
+{"vqmul.q", "?v3z,?s3y,?t3x",	0xf2808080, 0xff808080, RD_C0,		0,		AL	},
+{"vmmov.q", "?x7z,?s7y",	0xf3808080, 0xffff8080, RD_C0,		0,		AL	},
+{"vmidt.q", "?d7z",		0xf3838080, 0xffffff80, RD_C0,		0,		AL	},
+{"vmzero.q", "?d7z",		0xf3868080, 0xffffff80, RD_C0,		0,		AL	},
+{"vmone.q", "?d7z",		0xf3878080, 0xffffff80, RD_C0,		0,		AL	},
+{"vrot.q",  "?x3z,?s0y,?w",	0xf3a08080, 0xffe08080, RD_C0,		0,		AL	},
+{"vt4444.q", "?d1z,?s3w",	0xd0598080, 0xffff8080, RD_C0,		0,		AL	},
+{"vt5551.q", "?d1z,?s3w",	0xd05a8080, 0xffff8080, RD_C0,		0,		AL	},
+{"vt5650.q", "?d1z,?s3w",	0xd05b8080, 0xffff8080, RD_C0,		0,		AL	},
+{"vadd.t",  "?d2d,?s2s,?t2t",	0x60008000, 0xff808080, RD_C0,		0,		AL	},
+{"vsub.t",  "?d2d,?s2s,?t2t",	0x60808000, 0xff808080, RD_C0,		0,		AL	},
+{"vdiv.t",  "?x2z,?s2y,?t2x",	0x63808000, 0xff808080, RD_C0,		0,		AL	},
+{"vmul.t",  "?d2d,?s2s,?t2t",	0x64008000, 0xff808080, RD_C0,		0,		AL	},
+{"vdot.t",  "?d0d,?s2s,?t2t",	0x64808000, 0xff808080, RD_C0,		0,		AL	},
+{"vscl.t",  "?d2d,?s2s,?t0x",	0x65008000, 0xff808080, RD_C0,		0,		AL	},
+{"vhdp.t",  "?d0d,?s2y,?t2t",	0x66008000, 0xff808080, RD_C0,		0,		AL	},
+{"vcrs.t",  "?d2d,?s2y,?t2x",	0x66808000, 0xff808080, RD_C0,		0,		AL	},
+{"vcmp.t",  "?f2,?s2s,?t2t",	0x6c008000, 0xff8080f0, RD_C0,		0,		AL	},
+{"vcmp.t",  "?f1,?s2s",		0x6c008000, 0xffff80f0, RD_C0,		0,		AL	},
+{"vcmp.t",  "?f0",		0x6c008000, 0xfffffff0, RD_C0,		0,		AL	},
+{"vmin.t",  "?d2d,?s2s,?t2t",	0x6d008000, 0xff808080, RD_C0,		0,		AL	},
+{"vmax.t",  "?d2d,?s2s,?t2t",	0x6d808000, 0xff808080, RD_C0,		0,		AL	},
+{"vsgn.t",  "?d2d,?s2s",	0xd04a8000, 0xffff8080, RD_C0,		0,		AL	},
+{"vcst.t",  "?d2d,?a",		0xd0608000, 0xffe0ff80, RD_C0,		0,		AL	},
+{"vscmp.t", "?d2d,?s2s,?t2t",	0x6e808000, 0xff808080, RD_C0,		0,		AL	},
+{"vsge.t",  "?d2d,?s2s,?t2t",	0x6f008000, 0xff808080, RD_C0,		0,		AL	},
+{"vslt.t",  "?d2d,?s2s,?t2t",	0x6f808000, 0xff808080, RD_C0,		0,		AL	},
+{"vmov.t",  "?d2d,?s2s",	0xd0008000, 0xffff8080, RD_C0,		0,		AL	},
+{"vabs.t",  "?d2d,?s2w",	0xd0018000, 0xffff8080, RD_C0,		0,		AL	},
+{"vneg.t",  "?d2d,?s2w",	0xd0028000, 0xffff8080, RD_C0,		0,		AL	},
+{"vsat0.t", "?d2z,?s2s",	0xd0048000, 0xffff8080, RD_C0,		0,		AL	},
+{"vsat1.t", "?d2z,?s2s",	0xd0058000, 0xffff8080, RD_C0,		0,		AL	},
+{"vzero.t", "?d2d",		0xd0068000, 0xffffff80, RD_C0,		0,		AL	},
+{"vone.t",  "?d2d",		0xd0078000, 0xffffff80, RD_C0,		0,		AL	},
+{"vrcp.t",  "?x2z,?s2y",	0xd0108000, 0xffff8080, RD_C0,		0,		AL	},
+{"vrsq.t",  "?x2z,?s2y",	0xd0118000, 0xffff8080, RD_C0,		0,		AL	},
+{"vsin.t",  "?x2z,?s2y",	0xd0128000, 0xffff8080, RD_C0,		0,		AL	},
+{"vcos.t",  "?x2z,?s2y",	0xd0138000, 0xffff8080, RD_C0,		0,		AL	},
+{"vexp2.t", "?x2z,?s2y",	0xd0148000, 0xffff8080, RD_C0,		0,		AL	},
+{"vlog2.t", "?x2z,?s2y",	0xd0158000, 0xffff8080, RD_C0,		0,		AL	},
+{"vsqrt.t", "?x2z,?s2y",	0xd0168000, 0xffff8080, RD_C0,		0,		AL	},
+{"vasin.t", "?x2z,?s2y",	0xd0178000, 0xffff8080, RD_C0,		0,		AL	},
+{"vnrcp.t", "?x2z,?s2y",	0xd0188000, 0xffff8080, RD_C0,		0,		AL	},
+{"vnsin.t", "?x2z,?s2y",	0xd01a8000, 0xffff8080, RD_C0,		0,		AL	},
+{"vrexp2.t", "?x2z,?s2y",	0xd01c8000, 0xffff8080, RD_C0,		0,		AL	},
+{"vrndi.t", "?d2z",		0xd0218000, 0xffffff80, RD_C0,		0,		AL	},
+{"vrndf1.t", "?d2z",		0xd0228000, 0xffffff80, RD_C0,		0,		AL	},
+{"vrndf2.t", "?d2z",		0xd0238000, 0xffffff80, RD_C0,		0,		AL	},
+{"vocp.t",  "?d2d,?s2y",	0xd0448000, 0xffff8080, RD_C0,		0,		AL	},
+{"vfad.t",  "?d0d,?s2s",	0xd0468000, 0xffff8080, RD_C0,		0,		AL	},
+{"vavg.t",  "?d0d,?s2s",	0xd0478000, 0xffff8080, RD_C0,		0,		AL	},
+{"vf2in.t", "?d2m,?s2s,?b",	0xd2008000, 0xffe08080, RD_C0,		0,		AL	},
+{"vf2iz.t", "?d2m,?s2s,?b",	0xd2208000, 0xffe08080, RD_C0,		0,		AL	},
+{"vf2iu.t", "?d2m,?s2s,?b",	0xd2408000, 0xffe08080, RD_C0,		0,		AL	},
+{"vf2id.t", "?d2m,?s2s,?b",	0xd2608000, 0xffe08080, RD_C0,		0,		AL	},
+{"vi2f.t",  "?d2d,?s2w,?b",	0xd2808000, 0xffe08080, RD_C0,		0,		AL	},
+{"vcmov.t", "?d2d,?s2s,?e",	0         , 0x000000eb, INSN_MACRO,	0,		AL	},
+{"vcmovt.t", "?d2d,?s2s,?e",	0xd2a08000, 0xfff88080, RD_C0,		0,		AL	},
+{"vcmovf.t", "?d2d,?s2s,?e",	0xd2a88000, 0xfff88080, RD_C0,		0,		AL	},
+{"vmmul.t", "?v6z,?s6y,?t6x",	0xf0008000, 0xff808080, RD_C0,		0,		AL	},
+{"vtfm3.t", "?v2z,?s6y,?t2x",	0xf1008000, 0xff808080, RD_C0,		0,		AL	},
+{"vhtfm3.t", "?v2z,?s6y,?t2x",	0xf1000080, 0xff808080, RD_C0,		0,		AL	},
+{"vmscl.t", "?x6z,?s6y,?t0x",	0xf2008000, 0xff808080, RD_C0,		0,		AL	},
+{"vmmov.t", "?x6z,?s6y",	0xf3808000, 0xffff8080, RD_C0,		0,		AL	},
+{"vmidt.t", "?d6z",		0xf3838000, 0xffffff80, RD_C0,		0,		AL	},
+{"vmzero.t", "?d6z",		0xf3868000, 0xffffff80, RD_C0,		0,		AL	},
+{"vmone.t", "?d6z",		0xf3878000, 0xffffff80, RD_C0,		0,		AL	},
+{"vrot.t",  "?x2z,?s0y,?w",	0xf3a08000, 0xffe08080, RD_C0,		0,		AL	},
+{"vcrsp.t", "?d2z,?s2y,?t2x",	0xf2808000, 0xff808080, RD_C0,		0,		AL	},
+{"vadd.p",  "?d1d,?s1s,?t1t",	0x60000080, 0xff808080, RD_C0,		0,		AL	},
+{"vsub.p",  "?d1d,?s1s,?t1t",	0x60800080, 0xff808080, RD_C0,		0,		AL	},
+{"vdiv.p",  "?x1z,?s1y,?t1x",	0x63800080, 0xff808080, RD_C0,		0,		AL	},
+{"vmul.p",  "?d1d,?s1s,?t1t",	0x64000080, 0xff808080, RD_C0,		0,		AL	},
+{"vdot.p",  "?d0d,?s1s,?t1t",	0x64800080, 0xff808080, RD_C0,		0,		AL	},
+{"vscl.p",  "?d1d,?s1s,?t0x",	0x65000080, 0xff808080, RD_C0,		0,		AL	},
+{"vhdp.p",  "?d0d,?s1y,?t1t",	0x66000080, 0xff808080, RD_C0,		0,		AL	},
+{"vdet.p",  "?d0d,?s1s,?t1x",	0x67000080, 0xff808080, RD_C0,		0,		AL	},
+{"vcmp.p",  "?f2,?s1s,?t1t",	0x6c000080, 0xff8080f0, RD_C0,		0,		AL	},
+{"vcmp.p",  "?f1,?s1s",		0x6c000080, 0xffff80f0, RD_C0,		0,		AL	},
+{"vcmp.p",  "?f0",		0x6c000080, 0xfffffff0, RD_C0,		0,		AL	},
+{"vmin.p",  "?d1d,?s1s,?t1t",	0x6d000080, 0xff808080, RD_C0,		0,		AL	},
+{"vmax.p",  "?d1d,?s1s,?t1t",	0x6d800080, 0xff808080, RD_C0,		0,		AL	},
+{"vsgn.p",  "?d1d,?s1s",	0xd04a0080, 0xffff8080, RD_C0,		0,		AL	},
+{"vcst.p",  "?d1d,?a",		0xd0600080, 0xffe0ff80, RD_C0,		0,		AL	},
+{"vscmp.p", "?d1d,?s1s,?t1t",	0x6e800080, 0xff808080, RD_C0,		0,		AL	},
+{"vsge.p",  "?d1d,?s1s,?t1t",	0x6f000080, 0xff808080, RD_C0,		0,		AL	},
+{"vslt.p",  "?d1d,?s1s,?t1t",	0x6f800080, 0xff808080, RD_C0,		0,		AL	},
+{"vus2i.p", "?d3m,?s1y",	0xd03a0080, 0xffff8080, RD_C0,		0,		AL	},
+{"vs2i.p",  "?d3m,?s1y",	0xd03b0080, 0xffff8080, RD_C0,		0,		AL	},
+{"vi2us.p", "?d0m,?s1w",	0xd03e0080, 0xffff8080, RD_C0,		0,		AL	},
+{"vi2s.p",  "?d0m,?s1w",	0xd03f0080, 0xffff8080, RD_C0,		0,		AL	},
+{"vmov.p",  "?d1d,?s1s",	0xd0000080, 0xffff8080, RD_C0,		0,		AL	},
+{"vabs.p",  "?d1d,?s1w",	0xd0010080, 0xffff8080, RD_C0,		0,		AL	},
+{"vneg.p",  "?d1d,?s1w",	0xd0020080, 0xffff8080, RD_C0,		0,		AL	},
+{"vidt.p",  "?d1d",		0xd0030080, 0xffffff80, RD_C0,		0,		AL	},
+{"vsat0.p", "?d1z,?s1s",	0xd0040080, 0xffff8080, RD_C0,		0,		AL	},
+{"vsat1.p", "?d1z,?s1s",	0xd0050080, 0xffff8080, RD_C0,		0,		AL	},
+{"vzero.p", "?d1d",		0xd0060080, 0xffffff80, RD_C0,		0,		AL	},
+{"vone.p",  "?d1d",		0xd0070080, 0xffffff80, RD_C0,		0,		AL	},
+{"vrcp.p",  "?x1z,?s1y",	0xd0100080, 0xffff8080, RD_C0,		0,		AL	},
+{"vrsq.p",  "?x1z,?s1y",	0xd0110080, 0xffff8080, RD_C0,		0,		AL	},
+{"vsin.p",  "?x1z,?s1y",	0xd0120080, 0xffff8080, RD_C0,		0,		AL	},
+{"vcos.p",  "?x1z,?s1y",	0xd0130080, 0xffff8080, RD_C0,		0,		AL	},
+{"vexp2.p", "?x1z,?s1y",	0xd0140080, 0xffff8080, RD_C0,		0,		AL	},
+{"vlog2.p", "?x1z,?s1y",	0xd0150080, 0xffff8080, RD_C0,		0,		AL	},
+{"vsqrt.p", "?x1z,?s1y",	0xd0160080, 0xffff8080, RD_C0,		0,		AL	},
+{"vasin.p", "?x1z,?s1y",	0xd0170080, 0xffff8080, RD_C0,		0,		AL	},
+{"vnrcp.p", "?x1z,?s1y",	0xd0180080, 0xffff8080, RD_C0,		0,		AL	},
+{"vnsin.p", "?x1z,?s1y",	0xd01a0080, 0xffff8080, RD_C0,		0,		AL	},
+{"vrexp2.p", "?x1z,?s1y",	0xd01c0080, 0xffff8080, RD_C0,		0,		AL	},
+{"vrndi.p", "?d1z",		0xd0210080, 0xffffff80, RD_C0,		0,		AL	},
+{"vrndf1.p", "?d1z",		0xd0220080, 0xffffff80, RD_C0,		0,		AL	},
+{"vrndf2.p", "?d1z",		0xd0230080, 0xffffff80, RD_C0,		0,		AL	},
+{"vf2h.p",  "?d0m,?s1s",	0xd0320080, 0xffff8080, RD_C0,		0,		AL	},
+{"vh2f.p",  "?d3d,?s1y",	0xd0330080, 0xffff8080, RD_C0,		0,		AL	},
+{"vbfy1.p", "?d1d,?s1s",	0xd0420080, 0xffff8080, RD_C0,		0,		AL	},
+{"vocp.p",  "?d1d,?s1y",	0xd0440080, 0xffff8080, RD_C0,		0,		AL	},
+{"vsocp.p", "?d3z,?s1y",	0xd0450080, 0xffff8080, RD_C0,		0,		AL	},
+{"vfad.p",  "?d0d,?s1s",	0xd0460080, 0xffff8080, RD_C0,		0,		AL	},
+{"vavg.p",  "?d0d,?s1s",	0xd0470080, 0xffff8080, RD_C0,		0,		AL	},
+{"vf2in.p", "?d1m,?s1s,?b",	0xd2000080, 0xffe08080, RD_C0,		0,		AL	},
+{"vf2iz.p", "?d1m,?s1s,?b",	0xd2200080, 0xffe08080, RD_C0,		0,		AL	},
+{"vf2iu.p", "?d1m,?s1s,?b",	0xd2400080, 0xffe08080, RD_C0,		0,		AL	},
+{"vf2id.p", "?d1m,?s1s,?b",	0xd2600080, 0xffe08080, RD_C0,		0,		AL	},
+{"vi2f.p",  "?d1d,?s1w,?b",	0xd2800080, 0xffe08080, RD_C0,		0,		AL	},
+{"vcmov.p", "?d1d,?s1s,?e",	0         , 0x000000e8, INSN_MACRO,	0,		AL	},
+{"vcmovt.p", "?d1d,?s1s,?e",	0xd2a00080, 0xfff88080, RD_C0,		0,		AL	},
+{"vcmovf.p", "?d1d,?s1s,?e",	0xd2a80080, 0xfff88080, RD_C0,		0,		AL	},
+{"vmmul.p", "?v5z,?s5y,?t5x",	0xf0000080, 0xff808080, RD_C0,		0,		AL	},
+{"vtfm2.p", "?v1z,?s5y,?t1x",	0xf0800080, 0xff808080, RD_C0,		0,		AL	},
+{"vhtfm2.p", "?v1z,?s5y,?t1x",	0xf0800000, 0xff808080, RD_C0,		0,		AL	},
+{"vmscl.p", "?x5z,?s5y,?t0x",	0xf2000080, 0xff808080, RD_C0,		0,		AL	},
+{"vmmov.p", "?x5z,?s5y",	0xf3800080, 0xffff8080, RD_C0,		0,		AL	},
+{"vmidt.p", "?d5z",		0xf3830080, 0xffffff80, RD_C0,		0,		AL	},
+{"vmzero.p", "?d5z",		0xf3860080, 0xffffff80, RD_C0,		0,		AL	},
+{"vmone.p", "?d5z",		0xf3870080, 0xffffff80, RD_C0,		0,		AL	},
+{"vrot.p",  "?x1z,?s0y,?w",	0xf3a00080, 0xffe08080, RD_C0,		0,		AL	},
+{"vadd.s",  "?d0d,?s0s,?t0t",	0x60000000, 0xff808080, RD_C0,		0,		AL	},
+{"vsub.s",  "?d0d,?s0s,?t0t",	0x60800000, 0xff808080, RD_C0,		0,		AL	},
+{"vdiv.s",  "?x0d,?s0s,?t0t",	0x63800000, 0xff808080, RD_C0,		0,		AL	},
+{"vmul.s",  "?d0d,?s0s,?t0t",	0x64000000, 0xff808080, RD_C0,		0,		AL	},
+{"vcmp.s",  "?f2,?s0s,?t0t",	0x6c000000, 0xff8080f0, RD_C0,		0,		AL	},
+{"vcmp.s",  "?f1,?s0s",		0x6c000000, 0xffff80f0, RD_C0,		0,		AL	},
+{"vcmp.s",  "?f0",		0x6c000000, 0xfffffff0, RD_C0,		0,		AL	},
+{"vmin.s",  "?d0d,?s0s,?t0t",	0x6d000000, 0xff808080, RD_C0,		0,		AL	},
+{"vmax.s",  "?d0d,?s0s,?t0t",	0x6d800000, 0xff808080, RD_C0,		0,		AL	},
+{"vsgn.s",  "?d0d,?s0s",	0xd04a0000, 0xffff8080, RD_C0,		0,		AL	},
+{"vcst.s",  "?d0d,?a",		0xd0600000, 0xffe0ff80, RD_C0,		0,		AL	},
+{"vscmp.s", "?d0d,?s0s,?t0t",	0x6e800000, 0xff808080, RD_C0,		0,		AL	},
+{"vsge.s",  "?d0d,?s0s,?t0t",	0x6f000000, 0xff808080, RD_C0,		0,		AL	},
+{"vslt.s",  "?d0d,?s0s,?t0t",	0x6f800000, 0xff808080, RD_C0,		0,		AL	},
+{"vus2i.s", "?d1m,?s0y",	0xd03a0000, 0xffff8080, RD_C0,		0,		AL	},
+{"vs2i.s",  "?d1m,?s0y",	0xd03b0000, 0xffff8080, RD_C0,		0,		AL	},
+{"vmov.s",  "?d0d,?s0s",	0xd0000000, 0xffff8080, RD_C0,		0,		AL	},
+{"vabs.s",  "?d0d,?s0w",	0xd0010000, 0xffff8080, RD_C0,		0,		AL	},
+{"vneg.s",  "?d0d,?s0w",	0xd0020000, 0xffff8080, RD_C0,		0,		AL	},
+{"vsat0.s", "?d0z,?s0s",	0xd0040000, 0xffff8080, RD_C0,		0,		AL	},
+{"vsat1.s", "?d0z,?s0s",	0xd0050000, 0xffff8080, RD_C0,		0,		AL	},
+{"vzero.s", "?d0d",		0xd0060000, 0xffffff80, RD_C0,		0,		AL	},
+{"vone.s",  "?d0d",		0xd0070000, 0xffffff80, RD_C0,		0,		AL	},
+{"vrcp.s",  "?x0d,?s0s",	0xd0100000, 0xffff8080, RD_C0,		0,		AL	},
+{"vrsq.s",  "?x0d,?s0s",	0xd0110000, 0xffff8080, RD_C0,		0,		AL	},
+{"vsin.s",  "?x0d,?s0s",	0xd0120000, 0xffff8080, RD_C0,		0,		AL	},
+{"vcos.s",  "?x0d,?s0s",	0xd0130000, 0xffff8080, RD_C0,		0,		AL	},
+{"vexp2.s", "?x0d,?s0s",	0xd0140000, 0xffff8080, RD_C0,		0,		AL	},
+{"vlog2.s", "?x0d,?s0s",	0xd0150000, 0xffff8080, RD_C0,		0,		AL	},
+{"vsqrt.s", "?x0d,?s0s",	0xd0160000, 0xffff8080, RD_C0,		0,		AL	},
+{"vasin.s", "?x0d,?s0s",	0xd0170000, 0xffff8080, RD_C0,		0,		AL	},
+{"vnrcp.s", "?x0d,?s0y",	0xd0180000, 0xffff8080, RD_C0,		0,		AL	},
+{"vnsin.s", "?x0d,?s0y",	0xd01a0000, 0xffff8080, RD_C0,		0,		AL	},
+{"vrexp2.s", "?x0d,?s0y",	0xd01c0000, 0xffff8080, RD_C0,		0,		AL	},
+{"vrnds.s", "?s0y",		0xd0200000, 0xffff80ff, RD_C0,		0,		AL	},
+{"vrndi.s", "?d0d",		0xd0210000, 0xffffff80, RD_C0,		0,		AL	},
+{"vrndf1.s", "?d0d",		0xd0220000, 0xffffff80, RD_C0,		0,		AL	},
+{"vrndf2.s", "?d0d",		0xd0230000, 0xffffff80, RD_C0,		0,		AL	},
+{"vh2f.s",  "?d1d,?s0y",	0xd0330000, 0xffff8080, RD_C0,		0,		AL	},
+{"vsbz.s",  "?d0d,?s0s",	0xd0360000, 0xffff8080, RD_C0,		0,		AL	},
+{"vsbn.s",  "?d0d,?s0s,?t0t",	0x61000000, 0xff808080, RD_C0,		0,		AL	},
+{"vlgb.s",  "?d0d,?s0s",	0xd0370000, 0xffff8080, RD_C0,		0,		AL	},
+{"vocp.s",  "?d0d,?s0y",	0xd0440000, 0xffff8080, RD_C0,		0,		AL	},
+{"vsocp.s", "?d1z,?s0y",	0xd0450000, 0xffff8080, RD_C0,		0,		AL	},
+{"vf2in.s", "?d0m,?s0s,?b",	0xd2000000, 0xffe08080, RD_C0,		0,		AL	},
+{"vf2iz.s", "?d0m,?s0s,?b",	0xd2200000, 0xffe08080, RD_C0,		0,		AL	},
+{"vf2iu.s", "?d0m,?s0s,?b",	0xd2400000, 0xffe08080, RD_C0,		0,		AL	},
+{"vf2id.s", "?d0m,?s0s,?b",	0xd2600000, 0xffe08080, RD_C0,		0,		AL	},
+{"vi2f.s",  "?d0d,?s0w,?b",	0xd2800000, 0xffe08080, RD_C0,		0,		AL	},
+{"vcmov.s", "?d0d,?s0s,?e",	0         , 0x000000ea, INSN_MACRO,	0,		AL	},
+{"vcmovt.s", "?d0d,?s0s,?e",	0xd2a00000, 0xfff88080, RD_C0,		0,		AL	},
+{"vcmovf.s", "?d0d,?s0s,?e",	0xd2a80000, 0xfff88080, RD_C0,		0,		AL	},
+{"vwbn.s",  "?d0d,?s0s,?i",	0xd3000000, 0xff008080, RD_C0,		0,		AL	},
+{"vpfxs",   "?0,?1,?2,?3",	0xdc000000, 0xff000000, RD_C0,		0,		AL	},
+{"vpfxt",   "?0,?1,?2,?3",	0xdd000000, 0xff000000, RD_C0,		0,		AL	},
+{"vpfxd",   "?4,?5,?6,?7",	0xde000000, 0xff000000, RD_C0,		0,		AL	},
+{"viim.s",  "?t0d,j",		0xdf000000, 0xff800000, RD_C0,		0,		AL	},
+{"vfim.s",  "?t0d,?u",		0xdf800000, 0xff800000, RD_C0,		0,		AL	},
+{"vnop",    "",			0xffff0000, 0xffffffff, RD_C0,		0,		AL	},
+{"vflush",  "",			0xffff040d, 0xffffffff, RD_C0,		0,		AL	},
+{"vsync",   "",			0xffff0320, 0xffffffff, RD_C0,		0,		AL	},
+{"vsync",   "i",		0xffff0000, 0xffff0000, RD_C0,		0,		AL	},
+
 /* Coprocessor 2 move/branch operations overlap with VR5400 .ob format
    instructions so they are here for the latters to take precedence.  */
 {"bc2f",    "p",	0x49000000, 0xffff0000,	CBD|RD_CC,		0,		I1	},
@@ -1197,6 +1507,32 @@
 {"mtc2",    "t,G",	0x48800000, 0xffe007ff,	COD|RD_t|WR_C2|WR_CC,	0,		I1	},
 {"mtc2",    "t,G,H",	0x48800000, 0xffe007f8,	COD|RD_t|WR_C2|WR_CC,	0,		I32	},
 {"mthc2",   "t,i",	0x48e00000, 0xffe00000,	COD|RD_t|WR_C2|WR_CC,	0,		I33	},
+
+/* Coprocessor 2 load/store operations overlap with the Allegrex VFPU
+   instructions so they are here for the latters to take precedence.  */
+/* Coprocessor 1 ldc1 and sdc1 also overlap with the VFPU.  */
+{"ldc1",    "T,o(b)",	0xd4000000, 0xfc000000, CLD|RD_b|WR_T|FP_D,	0,		I2	},
+{"ldc1",    "E,o(b)",	0xd4000000, 0xfc000000, CLD|RD_b|WR_T|FP_D,	0,		I2	},
+{"ldc1",    "T,A(b)",	0,    (int) M_LDC1_AB,	INSN_MACRO,		0,		I2	},
+{"ldc1",    "E,A(b)",	0,    (int) M_LDC1_AB,	INSN_MACRO,		0,		I2	},
+{"l.d",     "T,o(b)",	0xd4000000, 0xfc000000, CLD|RD_b|WR_T|FP_D,	0,		I2	}, /* ldc1 */
+{"l.d",     "T,o(b)",	0,    (int) M_L_DOB,	INSN_MACRO,		0,		I1	},
+{"l.d",     "T,A(b)",	0,    (int) M_L_DAB,	INSN_MACRO,		0,		I1	},
+{"ldc2",    "E,o(b)",	0xd8000000, 0xfc000000, CLD|RD_b|WR_CC,		0,		I2	},
+{"ldc2",    "E,A(b)",	0,    (int) M_LDC2_AB,	INSN_MACRO,		0,		I2	},
+{"lwc2",    "E,o(b)",	0xc8000000, 0xfc000000,	CLD|RD_b|WR_CC,		0,		I1	},
+{"lwc2",    "E,A(b)",	0,    (int) M_LWC2_AB,	INSN_MACRO,		0,		I1	},
+{"sdc1",    "T,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,	0,		I2	},
+{"sdc1",    "E,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,	0,		I2	},
+{"sdc1",    "T,A(b)",	0,    (int) M_SDC1_AB,	INSN_MACRO,		0,		I2	},
+{"sdc1",    "E,A(b)",	0,    (int) M_SDC1_AB,	INSN_MACRO,		0,		I2	},
+{"s.d",     "T,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,	0,		I2	},
+{"s.d",     "T,o(b)",	0,    (int) M_S_DOB,	INSN_MACRO,		0,		I1	},
+{"s.d",     "T,A(b)",	0,    (int) M_S_DAB,	INSN_MACRO,		0,		I1	},
+{"sdc2",    "E,o(b)",	0xf8000000, 0xfc000000, SM|RD_C2|RD_b,		0,		I2	},
+{"sdc2",    "E,A(b)",	0,    (int) M_SDC2_AB,	INSN_MACRO,		0,		I2	},
+{"swc2",    "E,o(b)",	0xe8000000, 0xfc000000,	SM|RD_C2|RD_b,		0,		I1	},
+{"swc2",    "E,A(b)",	0,    (int) M_SWC2_AB,	INSN_MACRO,		0,		I1	},
 
 /* No hazard protection on coprocessor instructions--they shouldn't
    change the state of the processor and if they do it's up to the
