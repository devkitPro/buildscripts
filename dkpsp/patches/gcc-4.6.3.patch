diff -Nbaur gcc-4.6.3/config.sub gcc-4.6.3-psp/config.sub
--- gcc-4.6.3/config.sub	2010-05-25 14:22:07.000000000 +0100
+++ gcc-4.6.3-psp/config.sub	2012-04-03 18:40:18.000000000 +0100
@@ -279,6 +279,7 @@
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
 	| mipstx39 | mipstx39el \
+	| mipsallegrex | mipsallegrexel \
 	| mn10200 | mn10300 \
 	| moxie \
 	| mt \
@@ -375,6 +376,7 @@
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
 	| mipstx39-* | mipstx39el-* \
+	| mipsallegrex-* | mipsallegrexel-* \
 	| mmix-* \
 	| mt-* \
 	| msp430-* \
@@ -771,6 +773,10 @@
 		basic_machine=m68k-atari
 		os=-mint
 		;;
+	psp)
+		basic_machine=mipsallegrexel-psp
+		os=-elf
+		;;
 	mips3*-*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
 		;;
diff -Nbaur gcc-4.6.3/gcc/config/mips/allegrex.md gcc-4.6.3-psp/gcc/config/mips/allegrex.md
--- gcc-4.6.3/gcc/config/mips/allegrex.md	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.6.3-psp/gcc/config/mips/allegrex.md	2012-04-03 18:40:18.000000000 +0100
@@ -0,0 +1,191 @@
+;; Sony ALLEGREX instructions.
+;; Copyright (C) 2005 Free Software Foundation, Inc.
+;;
+;; This file is part of GCC.
+;;
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 2, or (at your option)
+;; any later version.
+;;
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+;;
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING.  If not, write to
+;; the Free Software Foundation, 59 Temple Place - Suite 330,
+;; Boston, MA 02111-1307, USA.
+
+(define_c_enum "unspec" [
+  UNSPEC_WSBH
+  UNSPEC_CLO
+  UNSPEC_CTO
+  UNSPEC_CACHE
+  UNSPEC_CEIL_W_S
+  UNSPEC_FLOOR_W_S
+  UNSPEC_ROUND_W_S
+])
+
+;; Multiply Add and Subtract.
+;; Note: removed clobbering for madd and msub (testing needed)
+
+(define_insn "allegrex_madd"
+  [(set (match_operand:SI 0 "register_operand" "+l")
+       (plus:SI (mult:SI (match_operand:SI 1 "register_operand" "d")
+             (match_operand:SI 2 "register_operand" "d"))
+        (match_dup 0)))]
+  "TARGET_ALLEGREX"
+  "madd\t%1,%2"
+  [(set_attr "type"    "imadd")
+   (set_attr "mode"    "SI")])
+
+(define_insn "allegrex_msub"
+  [(set (match_operand:SI 0 "register_operand" "+l")
+       (minus:SI (match_dup 0)
+         (mult:SI (match_operand:SI 1 "register_operand" "d")
+              (match_operand:SI 2 "register_operand" "d"))))]
+  "TARGET_ALLEGREX"
+  "msub\t%1,%2"
+  [(set_attr "type"    "imadd")
+   (set_attr "mode"    "SI")])
+
+
+;; Min and max.
+
+(define_insn "sminsi3"
+  [(set (match_operand:SI 0 "register_operand" "=d")
+        (smin:SI (match_operand:SI 1 "register_operand" "d")
+                 (match_operand:SI 2 "register_operand" "d")))]
+  "TARGET_ALLEGREX"
+  "min\t%0,%1,%2"
+  [(set_attr "type"    "arith")
+   (set_attr "mode"    "SI")])
+
+(define_insn "smaxsi3"
+  [(set (match_operand:SI 0 "register_operand" "=d")
+        (smax:SI (match_operand:SI 1 "register_operand" "d")
+                 (match_operand:SI 2 "register_operand" "d")))]
+  "TARGET_ALLEGREX"
+  "max\t%0,%1,%2"
+  [(set_attr "type"    "arith")
+   (set_attr "mode"    "SI")])
+
+
+;; Extended shift instructions.
+
+(define_insn "allegrex_bitrev"
+  [(set (match_operand:SI 0 "register_operand" "=d")
+   (unspec:SI [(match_operand:SI 1 "register_operand" "d")]
+          UNSPEC_BITREV))]
+  "TARGET_ALLEGREX"
+  "bitrev\t%0,%1"
+  [(set_attr "type"    "arith")
+   (set_attr "mode"    "SI")])
+
+(define_insn "allegrex_wsbh"
+  [(set (match_operand:SI 0 "register_operand" "=d")
+   (unspec:SI [(match_operand:SI 1 "register_operand" "d")]
+          UNSPEC_WSBH))]
+  "TARGET_ALLEGREX"
+  "wsbh\t%0,%1"
+  [(set_attr "type"    "arith")
+   (set_attr "mode"    "SI")])
+
+(define_insn "bswapsi2"
+  [(set (match_operand:SI 0 "register_operand" "=d")
+   (bswap:SI (match_operand:SI 1 "register_operand" "d")))]
+  "TARGET_ALLEGREX"
+  "wsbw\t%0,%1"
+  [(set_attr "type"    "shift")
+   (set_attr "mode"    "SI")])
+
+
+;; Count leading ones, count trailing zeros, and count trailing ones (clz is
+;; already defined).
+
+(define_insn "allegrex_clo"
+  [(set (match_operand:SI 0 "register_operand" "=d")
+       (unspec:SI [(match_operand:SI 1 "register_operand" "d")]
+          UNSPEC_CLO))]
+  "TARGET_ALLEGREX"
+  "clo\t%0,%1"
+  [(set_attr "type"    "clz")
+   (set_attr "mode"    "SI")])
+
+(define_expand "ctzsi2"
+  [(set (match_operand:SI 0 "register_operand")
+       (ctz:SI (match_operand:SI 1 "register_operand")))]
+  "TARGET_ALLEGREX"
+{
+  rtx r1;
+
+  r1 = gen_reg_rtx (SImode);
+  emit_insn (gen_allegrex_bitrev (r1, operands[1]));
+  emit_insn (gen_clzsi2 (operands[0], r1));
+  DONE;
+})
+
+(define_expand "allegrex_cto"
+  [(set (match_operand:SI 0 "register_operand")
+       (unspec:SI [(match_operand:SI 1 "register_operand")]
+          UNSPEC_CTO))]
+  "TARGET_ALLEGREX"
+{
+  rtx r1;
+
+  r1 = gen_reg_rtx (SImode);
+  emit_insn (gen_allegrex_bitrev (r1, operands[1]));
+  emit_insn (gen_allegrex_clo (operands[0], r1));
+  DONE;
+})
+
+
+;; Misc.
+
+(define_insn "allegrex_sync"
+  [(unspec_volatile [(const_int 0)] UNSPEC_SYNC)]
+  "TARGET_ALLEGREX"
+  "sync"
+  [(set_attr "type"    "unknown")
+   (set_attr "mode"    "none")])
+
+(define_insn "allegrex_cache"
+  [(unspec_volatile [(match_operand:SI 0 "const_int_operand" "")
+            (match_operand:SI 1 "register_operand" "d")]
+           UNSPEC_CACHE)]
+  "TARGET_ALLEGREX"
+  "cache\t%0,0(%1)"
+  [(set_attr "type"    "unknown")
+   (set_attr "mode"    "none")])
+
+
+;; Floating-point builtins.
+
+(define_insn "allegrex_ceil_w_s"
+  [(set (match_operand:SI 0 "register_operand" "=f")
+       (unspec:SI [(match_operand:SF 1 "register_operand" "f")]
+          UNSPEC_CEIL_W_S))]
+  "TARGET_ALLEGREX"
+  "ceil.w.s\t%0,%1"
+  [(set_attr "type"    "fcvt")
+   (set_attr "mode"    "SF")])
+
+(define_insn "allegrex_floor_w_s"
+  [(set (match_operand:SI 0 "register_operand" "=f")
+       (unspec:SI [(match_operand:SF 1 "register_operand" "f")]
+          UNSPEC_FLOOR_W_S))]
+  "TARGET_ALLEGREX"
+  "floor.w.s\t%0,%1"
+  [(set_attr "type"    "fcvt")
+   (set_attr "mode"    "SF")])
+
+(define_insn "allegrex_round_w_s"
+  [(set (match_operand:SI 0 "register_operand" "=f")
+       (unspec:SI [(match_operand:SF 1 "register_operand" "f")]
+          UNSPEC_ROUND_W_S))]
+  "TARGET_ALLEGREX"
+  "round.w.s\t%0,%1"
+  [(set_attr "type"    "fcvt")
+   (set_attr "mode"    "SF")])
diff -Nbaur gcc-4.6.3/gcc/config/mips/mips.c gcc-4.6.3-psp/gcc/config/mips/mips.c
--- gcc-4.6.3/gcc/config/mips/mips.c	2011-05-29 18:48:14.000000000 +0100
+++ gcc-4.6.3-psp/gcc/config/mips/mips.c	2012-04-03 18:40:18.000000000 +0100
@@ -239,7 +239,12 @@
   MIPS_BUILTIN_CMP_SINGLE,
 
   /* For generating bposge32 branch instructions in MIPS32 DSP ASE.  */
-  MIPS_BUILTIN_BPOSGE32
+  MIPS_BUILTIN_BPOSGE32,
+
+  /* The builtin corresponds to the ALLEGREX cache instruction.  Operand 0
+     is the function code (must be less than 32) and operand 1 is the base
+     address.  */
+  MIPS_BUILTIN_CACHE
 };
 
 /* Invoke MACRO (COND) for each C.cond.fmt condition.  */
@@ -516,6 +521,10 @@
    normal branch.  */
 static bool mips_branch_likely;
 
+/* Preferred stack boundary for proper stack vars alignment */
+unsigned int mips_preferred_stack_boundary;
+unsigned int mips_preferred_stack_align;
+
 /* The current instruction-set architecture.  */
 enum processor mips_arch;
 const struct mips_cpu_info *mips_arch_info;
@@ -691,6 +700,7 @@
 
   /* MIPS II processors.  */
   { "r6000", PROCESSOR_R6000, 2, 0 },
+  { "allegrex", PROCESSOR_ALLEGREX, 2, 0 },
 
   /* MIPS III processors.  */
   { "r4000", PROCESSOR_R4000, 3, 0 },
@@ -969,6 +979,9 @@
 		     1,           /* branch_cost */
 		     4            /* memory_latency */
   },
+  { /* Allegrex */
+    DEFAULT_COSTS
+  },
   { /* Loongson-2E */
     DEFAULT_COSTS
   },
@@ -12605,6 +12618,7 @@
 AVAIL_NON_MIPS16 (dspr2_32, !TARGET_64BIT && TARGET_DSPR2)
 AVAIL_NON_MIPS16 (loongson, TARGET_LOONGSON_VECTORS)
 AVAIL_NON_MIPS16 (cache, TARGET_CACHE_BUILTIN)
+AVAIL_NON_MIPS16 (allegrex, TARGET_ALLEGREX)
 
 /* Construct a mips_builtin_description from the given arguments.
 
@@ -12701,6 +12715,30 @@
   MIPS_BUILTIN (bposge, f, "bposge" #VALUE,				\
 		MIPS_BUILTIN_BPOSGE ## VALUE, MIPS_SI_FTYPE_VOID, AVAIL)
 
+/* Define a MIPS_BUILTIN_DIRECT function for instruction CODE_FOR_allegrex_<INSN>.
+   FUNCTION_TYPE and TARGET_FLAGS are builtin_description fields.  */
+#define DIRECT_ALLEGREX_BUILTIN(INSN, FUNCTION_TYPE, TARGET_FLAGS) \
+  { CODE_FOR_allegrex_ ## INSN, MIPS_FP_COND_f, "__builtin_allegrex_" #INSN,        \
+    MIPS_BUILTIN_DIRECT, FUNCTION_TYPE, mips_builtin_avail_allegrex }
+
+/* Same as the above, but mapped to an instruction that doesn't share the
+   NAME.  NAME is the name of the builtin without the builtin prefix.  */
+#define DIRECT_ALLEGREX_NAMED_BUILTIN(NAME, INSN, FUNCTION_TYPE, TARGET_FLAGS) \
+  { CODE_FOR_ ## INSN, MIPS_FP_COND_f, "__builtin_allegrex_" #NAME,             \
+    MIPS_BUILTIN_DIRECT, FUNCTION_TYPE, mips_builtin_avail_allegrex }
+
+/* Define a MIPS_BUILTIN_DIRECT_NO_TARGET function for instruction
+   CODE_FOR_allegrex_<INSN>.  FUNCTION_TYPE and TARGET_FLAGS are
+   builtin_description fields.  */
+#define DIRECT_ALLEGREX_NO_TARGET_BUILTIN(INSN, FUNCTION_TYPE, TARGET_FLAGS)   \
+  { CODE_FOR_allegrex_ ## INSN, MIPS_FP_COND_f, "__builtin_allegrex_" #INSN,            \
+    MIPS_BUILTIN_DIRECT_NO_TARGET, FUNCTION_TYPE, mips_builtin_avail_allegrex }
+
+/* Define a builtin with a specific function TYPE.  */
+#define SPECIAL_ALLEGREX_BUILTIN(TYPE, INSN, FUNCTION_TYPE, TARGET_FLAGS)  \
+  { CODE_FOR_allegrex_ ## INSN, MIPS_FP_COND_f, "__builtin_allegrex_" #INSN,            \
+    MIPS_BUILTIN_ ## TYPE, FUNCTION_TYPE, mips_builtin_avail_allegrex }
+
 /* Define a Loongson MIPS_BUILTIN_DIRECT function __builtin_loongson_<FN_NAME>
    for instruction CODE_FOR_loongson_<INSN>.  FUNCTION_TYPE is a
    builtin_description field.  */
@@ -12945,6 +12983,40 @@
   DIRECT_BUILTIN (dpsqx_s_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dspr2_32),
   DIRECT_BUILTIN (dpsqx_sa_w_ph, MIPS_DI_FTYPE_DI_V2HI_V2HI, dspr2_32),
 
+/* Builtin functions for the Sony ALLEGREX processor.
+
+   These have the `__builtin_allegrex_' prefix instead of `__builtin_mips_'
+   to maintain compatibility with Sony's ALLEGREX GCC port.
+
+   Some of the builtins may seem redundant, but they are the same as the
+   builtins defined in the Sony compiler.  I chose to map redundant and
+   trivial builtins to the original instruction instead of creating
+   duplicate patterns specifically for the ALLEGREX (as Sony does).  */
+
+  DIRECT_ALLEGREX_BUILTIN(bitrev, MIPS_SI_FTYPE_SI, 0),
+  DIRECT_ALLEGREX_BUILTIN(wsbh, MIPS_SI_FTYPE_SI, 0),
+  DIRECT_ALLEGREX_NAMED_BUILTIN(wsbw, bswapsi2, MIPS_SI_FTYPE_SI, 0),
+  DIRECT_ALLEGREX_NAMED_BUILTIN(clz, clzsi2, MIPS_SI_FTYPE_SI, 0),
+  DIRECT_ALLEGREX_BUILTIN(clo, MIPS_SI_FTYPE_SI, 0),
+  DIRECT_ALLEGREX_NAMED_BUILTIN(ctz, ctzsi2, MIPS_SI_FTYPE_SI, 0),
+  DIRECT_ALLEGREX_BUILTIN(cto, MIPS_SI_FTYPE_SI, 0),
+  DIRECT_ALLEGREX_NAMED_BUILTIN(rotr, rotrsi3, MIPS_SI_FTYPE_SI_SI, 0),
+  DIRECT_ALLEGREX_NAMED_BUILTIN(rotl, rotlsi3, MIPS_SI_FTYPE_SI_SI, 0),
+
+  DIRECT_ALLEGREX_NAMED_BUILTIN(seb, extendqisi2, MIPS_SI_FTYPE_QI, 0),
+  DIRECT_ALLEGREX_NAMED_BUILTIN(seh, extendhisi2, MIPS_SI_FTYPE_HI, 0),
+  DIRECT_ALLEGREX_NAMED_BUILTIN(max, smaxsi3, MIPS_SI_FTYPE_SI_SI, 0),
+  DIRECT_ALLEGREX_NAMED_BUILTIN(min, sminsi3, MIPS_SI_FTYPE_SI_SI, 0),
+
+  DIRECT_ALLEGREX_NO_TARGET_BUILTIN(sync, MIPS_VOID_FTYPE_VOID, 0),
+  SPECIAL_ALLEGREX_BUILTIN(CACHE, cache, MIPS_VOID_FTYPE_SI_SI, 0),
+
+  DIRECT_ALLEGREX_NAMED_BUILTIN(sqrt_s, sqrtsf2, MIPS_SF_FTYPE_SF, 0),
+  DIRECT_ALLEGREX_BUILTIN(ceil_w_s, MIPS_SI_FTYPE_SF, 0),
+  DIRECT_ALLEGREX_BUILTIN(floor_w_s, MIPS_SI_FTYPE_SF, 0),
+  DIRECT_ALLEGREX_BUILTIN(round_w_s, MIPS_SI_FTYPE_SF, 0),
+  DIRECT_ALLEGREX_NAMED_BUILTIN(trunc_w_s, fix_truncsfsi2_insn, MIPS_SI_FTYPE_SF, 0),
+
   /* Builtin functions for ST Microelectronics Loongson-2E/2F cores.  */
   LOONGSON_BUILTIN (packsswh, MIPS_V4HI_FTYPE_V2SI_V2SI),
   LOONGSON_BUILTIN (packsshb, MIPS_V8QI_FTYPE_V4HI_V4HI),
@@ -13096,6 +13168,8 @@
 /* Standard mode-based argument types.  */
 #define MIPS_ATYPE_UQI unsigned_intQI_type_node
 #define MIPS_ATYPE_SI intSI_type_node
+#define MIPS_ATYPE_HI intHI_type_node
+#define MIPS_ATYPE_QI intQI_type_node
 #define MIPS_ATYPE_USI unsigned_intSI_type_node
 #define MIPS_ATYPE_DI intDI_type_node
 #define MIPS_ATYPE_UDI unsigned_intDI_type_node
@@ -13270,6 +13344,9 @@
 
   switch (opno)
     {
+    case 0:
+      emit_insn (GEN_FCN (icode) (0));
+      break;
     case 2:
       emit_insn (GEN_FCN (icode) (ops[0], ops[1]));
       break;
@@ -13439,6 +13516,28 @@
 				       const1_rtx, const0_rtx);
 }
 
+/* Expand a __builtin_allegrex_cache() function.  Make sure the passed
+   cache function code is less than 32.  */
+
+static rtx
+mips_expand_builtin_cache (enum insn_code icode, rtx target, tree exp)
+{
+  rtx op0, op1;
+
+  op0 = mips_prepare_builtin_arg (icode, 0, exp, 0);
+  op1 = mips_prepare_builtin_arg (icode, 1, exp, 1);
+
+  if (GET_CODE (op0) == CONST_INT)
+    if (INTVAL (op0) < 0 || INTVAL (op0) > 0x1f)
+      {
+   error ("invalid function code '%d'", INTVAL (op0));
+   return const0_rtx;
+      }
+
+  emit_insn (GEN_FCN (icode) (op0, op1));
+  return target;
+}
+
 /* Implement TARGET_EXPAND_BUILTIN.  */
 
 static rtx
@@ -13484,6 +13583,9 @@
 
     case MIPS_BUILTIN_BPOSGE32:
       return mips_expand_builtin_bposge (d->builtin_type, target);
+
+    case MIPS_BUILTIN_CACHE:
+      return mips_expand_builtin_cache (d->icode, target, exp);
     }
   gcc_unreachable ();
 }
@@ -15918,6 +16020,22 @@
      Do all CPP-sensitive stuff in non-MIPS16 mode; we'll switch to
      MIPS16 mode afterwards if need be.  */
   mips_set_mips16_mode (false);
+
+  /* Validate -mpreferred-stack-boundary= value, or provide default.
+     The default of 128-bit is for newABI else 64-bit.  */
+  mips_preferred_stack_boundary = (TARGET_NEWABI ? 128 : 64);
+  mips_preferred_stack_align = (TARGET_NEWABI ? 16 : 8);
+  if (mips_preferred_stack_boundary_string)
+    {
+      i = atoi (mips_preferred_stack_boundary_string);
+      if (i < 2 || i > 12)
+       error ("-mpreferred-stack-boundary=%d is not between 2 and 12", i);
+      else
+        {
+          mips_preferred_stack_align = (1 << i);
+          mips_preferred_stack_boundary = mips_preferred_stack_align * 8;
+        }
+    }
 }
 
 /* Implement TARGET_OPTION_OPTIMIZATION_TABLE.  */
diff -Nbaur gcc-4.6.3/gcc/config/mips/mips-ftypes.def gcc-4.6.3-psp/gcc/config/mips/mips-ftypes.def
--- gcc-4.6.3/gcc/config/mips/mips-ftypes.def	2009-02-20 15:20:38.000000000 +0000
+++ gcc-4.6.3-psp/gcc/config/mips/mips-ftypes.def	2012-04-03 18:40:18.000000000 +0100
@@ -53,9 +53,12 @@
 
 DEF_MIPS_FTYPE (2, (SI, DI, SI))
 DEF_MIPS_FTYPE (2, (SI, POINTER, SI))
+DEF_MIPS_FTYPE (1, (SI, HI))
+DEF_MIPS_FTYPE (1, (SI, SF))
 DEF_MIPS_FTYPE (1, (SI, SI))
 DEF_MIPS_FTYPE (2, (SI, SI, SI))
 DEF_MIPS_FTYPE (3, (SI, SI, SI, SI))
+DEF_MIPS_FTYPE (1, (SI, QI))
 DEF_MIPS_FTYPE (1, (SI, V2HI))
 DEF_MIPS_FTYPE (2, (SI, V2HI, V2HI))
 DEF_MIPS_FTYPE (1, (SI, V4QI))
@@ -124,3 +127,4 @@
 DEF_MIPS_FTYPE (2, (VOID, SI, SI))
 DEF_MIPS_FTYPE (2, (VOID, V2HI, V2HI))
 DEF_MIPS_FTYPE (2, (VOID, V4QI, V4QI))
+DEF_MIPS_FTYPE (1, (VOID, VOID))
diff -Nbaur gcc-4.6.3/gcc/config/mips/mips.h gcc-4.6.3-psp/gcc/config/mips/mips.h
--- gcc-4.6.3/gcc/config/mips/mips.h	2011-03-08 20:51:11.000000000 +0000
+++ gcc-4.6.3-psp/gcc/config/mips/mips.h	2012-04-03 18:40:18.000000000 +0100
@@ -231,6 +231,7 @@
 #define TARGET_SB1                  (mips_arch == PROCESSOR_SB1		\
 				     || mips_arch == PROCESSOR_SB1A)
 #define TARGET_SR71K                (mips_arch == PROCESSOR_SR71000)
+#define TARGET_ALLEGREX             (mips_arch == PROCESSOR_ALLEGREX)
 
 /* Scheduling target defines.  */
 #define TUNE_20KC		    (mips_tune == PROCESSOR_20KC)
@@ -258,6 +259,7 @@
 #define TUNE_OCTEON		    (mips_tune == PROCESSOR_OCTEON)
 #define TUNE_SB1                    (mips_tune == PROCESSOR_SB1		\
 				     || mips_tune == PROCESSOR_SB1A)
+#define TUNE_ALLEGREX               (mips_tune == PROCESSOR_ALLEGREX)
 
 /* Whether vector modes and intrinsics for ST Microelectronics
    Loongson-2E/2F processors should be enabled.  In o32 pairs of
@@ -852,6 +854,9 @@
 /* ISA has LDC1 and SDC1.  */
 #define ISA_HAS_LDC1_SDC1	(!ISA_MIPS1 && !TARGET_MIPS16)
 
+/* ISA has just the integer condition move instructions (movn,movz) */
+#define ISA_HAS_INT_CONDMOVE   (TARGET_ALLEGREX)
+
 /* ISA has the mips4 FP condition code instructions: FP-compare to CC,
    branch on CC, and move (both FP and non-FP) on CC.  */
 #define ISA_HAS_8CC		(ISA_MIPS4				\
@@ -874,6 +879,7 @@
 
 /* ISA has conditional trap instructions.  */
 #define ISA_HAS_COND_TRAP	(!ISA_MIPS1				\
+				 && !TARGET_ALLEGREX				\
 				 && !TARGET_MIPS16)
 
 /* ISA has integer multiply-accumulate instructions, madd and msub.  */
@@ -910,6 +916,7 @@
 /* ISA has count leading zeroes/ones instruction (not implemented).  */
 #define ISA_HAS_CLZ_CLO		((ISA_MIPS32				\
 				  || ISA_MIPS32R2			\
+				  || TARGET_ALLEGREX		\
 				  || ISA_MIPS64				\
 				  || ISA_MIPS64R2)			\
 				 && !TARGET_MIPS16)
@@ -955,6 +962,7 @@
 				  || TARGET_MIPS5400			\
 				  || TARGET_MIPS5500			\
 				  || TARGET_SR71K			\
+				  || TARGET_ALLEGREX			\
 				  || TARGET_SMARTMIPS)			\
 				 && !TARGET_MIPS16)
 
@@ -984,11 +992,13 @@
 
 /* ISA includes the MIPS32r2 seb and seh instructions.  */
 #define ISA_HAS_SEB_SEH		((ISA_MIPS32R2		\
+				  || TARGET_ALLEGREX	\
 				  || ISA_MIPS64R2)	\
 				 && !TARGET_MIPS16)
 
 /* ISA includes the MIPS32/64 rev 2 ext and ins instructions.  */
 #define ISA_HAS_EXT_INS		((ISA_MIPS32R2		\
+				  || TARGET_ALLEGREX	\
 				  || ISA_MIPS64R2)	\
 				 && !TARGET_MIPS16)
 
@@ -1038,7 +1048,8 @@
 				 || ISA_MIPS64				\
 				 || ISA_MIPS64R2			\
 				 || TARGET_MIPS5500			\
-				 || TARGET_LOONGSON_2EF)
+				 || TARGET_LOONGSON_2EF		\
+				 || TARGET_ALLEGREX)
 
 /* ISA includes synci, jr.hb and jalr.hb.  */
 #define ISA_HAS_SYNCI ((ISA_MIPS32R2		\
@@ -2133,7 +2144,7 @@
    `crtl->outgoing_args_size'.  */
 #define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1
 
-#define STACK_BOUNDARY (TARGET_NEWABI ? 128 : 64)
+#define STACK_BOUNDARY (mips_preferred_stack_boundary)
 
 /* Symbolic macros for the registers used to return integer and floating
    point values.  */
@@ -2259,7 +2270,7 @@
 /* Treat LOC as a byte offset from the stack pointer and round it up
    to the next fully-aligned offset.  */
 #define MIPS_STACK_ALIGN(LOC) \
-  (TARGET_NEWABI ? ((LOC) + 15) & -16 : ((LOC) + 7) & -8)
+  (((LOC) + (mips_preferred_stack_align - 1)) & -(mips_preferred_stack_align))
 
 
 /* Output assembler code to FILE to increment profiler label # LABELNO
@@ -2911,6 +2922,9 @@
 #endif
 #endif
 
+extern unsigned int mips_preferred_stack_boundary;
+extern unsigned int mips_preferred_stack_align;
+
 #ifndef HAVE_AS_TLS
 #define HAVE_AS_TLS 0
 #endif
diff -Nbaur gcc-4.6.3/gcc/config/mips/mips.md gcc-4.6.3-psp/gcc/config/mips/mips.md
--- gcc-4.6.3/gcc/config/mips/mips.md	2012-01-09 22:09:53.000000000 +0000
+++ gcc-4.6.3-psp/gcc/config/mips/mips.md	2012-04-03 18:40:18.000000000 +0100
@@ -37,6 +37,7 @@
   74kf2_1
   74kf1_1
   74kf3_2
+  allegrex
   loongson_2e
   loongson_2f
   loongson_3a
@@ -598,7 +599,7 @@
 ;; This mode iterator allows :MOVECC to be used anywhere that a
 ;; conditional-move-type condition is needed.
 (define_mode_iterator MOVECC [SI (DI "TARGET_64BIT")
-                              (CC "TARGET_HARD_FLOAT && !TARGET_LOONGSON_2EF")])
+                              (CC "TARGET_HARD_FLOAT && !TARGET_LOONGSON_2EF && !TARGET_ALLEGREX")])
 
 ;; 32-bit integer moves for which we provide move patterns.
 (define_mode_iterator IMOVE32
@@ -1885,11 +1886,11 @@
 	   (mult:DI
 	      (any_extend:DI (match_operand:SI 1 "register_operand" "d"))
 	      (any_extend:DI (match_operand:SI 2 "register_operand" "d")))))]
-  "!TARGET_64BIT && (ISA_HAS_MSAC || GENERATE_MADD_MSUB || ISA_HAS_DSP)"
+  "!TARGET_64BIT && (ISA_HAS_MSAC || GENERATE_MADD_MSUB || ISA_HAS_DSP || TARGET_ALLEGREX)"
 {
   if (ISA_HAS_DSP_MULT)
     return "msub<u>\t%q0,%1,%2";
-  else if (TARGET_MIPS5500 || GENERATE_MADD_MSUB)
+  else if (TARGET_MIPS5500 || GENERATE_MADD_MSUB || TARGET_ALLEGREX)
     return "msub<u>\t%1,%2";
   else
     return "msac<u>\t$0,%1,%2";
@@ -2066,14 +2067,14 @@
 	 (mult:DI (any_extend:DI (match_operand:SI 1 "register_operand" "d"))
 		  (any_extend:DI (match_operand:SI 2 "register_operand" "d")))
 	 (match_operand:DI 3 "register_operand" "0")))]
-  "(TARGET_MAD || ISA_HAS_MACC || GENERATE_MADD_MSUB || ISA_HAS_DSP)
+  "(TARGET_MAD || ISA_HAS_MACC || GENERATE_MADD_MSUB || ISA_HAS_DSP || TARGET_ALLEGREX)
    && !TARGET_64BIT"
 {
   if (TARGET_MAD)
     return "mad<u>\t%1,%2";
   else if (ISA_HAS_DSP_MULT)
     return "madd<u>\t%q0,%1,%2";
-  else if (GENERATE_MADD_MSUB || TARGET_MIPS5500)
+  else if (GENERATE_MADD_MSUB || TARGET_MIPS5500 || TARGET_ALLEGREX)
     return "madd<u>\t%1,%2";
   else
     /* See comment in *macc.  */
@@ -2500,6 +2501,33 @@
 ;;
 ;;  ....................
 ;;
+;; FIND FIRST BIT INSTRUCTION
+;;
+;;  ....................
+;;
+
+(define_expand "ffs<mode>2"
+  [(set (match_operand:GPR 0 "register_operand" "")
+   (ffs:GPR (match_operand:GPR 1 "register_operand" "")))]
+  "ISA_HAS_CLZ_CLO"
+{
+  rtx r1, r2, r3, r4;
+  
+  r1 = gen_reg_rtx (<MODE>mode);
+  r2 = gen_reg_rtx (<MODE>mode);
+  r3 = gen_reg_rtx (<MODE>mode);
+  r4 = gen_reg_rtx (<MODE>mode);
+  emit_insn (gen_neg<mode>2 (r1, operands[1]));
+  emit_insn (gen_and<mode>3 (r2, operands[1], r1));
+  emit_insn (gen_clz<mode>2 (r3, r2));
+  emit_move_insn (r4, GEN_INT (GET_MODE_BITSIZE (<MODE>mode)));
+  emit_insn (gen_sub<mode>3 (operands[0], r4, r3));
+  DONE;
+})
+
+;;
+;;  ....................
+;;
 ;;	NEGATION and ONE'S COMPLEMENT
 ;;
 ;;  ....................
@@ -2550,6 +2578,25 @@
   [(set_attr "alu_type" "not")
    (set_attr "mode" "<MODE>")])
 
+(define_expand "rotl<mode>3"
+  [(set (match_operand:GPR 0 "register_operand")
+       (rotate:GPR (match_operand:GPR 1 "register_operand")
+           (match_operand:SI 2 "arith_operand")))]
+  "ISA_HAS_ROR"
+{
+  rtx temp;
+
+  if (GET_CODE (operands[2]) == CONST_INT)
+    temp = GEN_INT (GET_MODE_BITSIZE (<MODE>mode) - INTVAL (operands[2]));
+  else
+    {
+      temp = gen_reg_rtx (<MODE>mode);
+      emit_insn (gen_neg<mode>2 (temp, operands[2]));
+    }
+  emit_insn (gen_rotr<mode>3 (operands[0], operands[1], temp));
+  DONE;
+})
+
 ;;
 ;;  ....................
 ;;
@@ -6301,7 +6348,7 @@
 		 (const_int 0)])
 	 (match_operand:GPR 2 "reg_or_0_operand" "dJ,0")
 	 (match_operand:GPR 3 "reg_or_0_operand" "0,dJ")))]
-  "ISA_HAS_CONDMOVE"
+  "ISA_HAS_CONDMOVE || ISA_HAS_INT_CONDMOVE"
   "@
     mov%T4\t%0,%z2,%1
     mov%t4\t%0,%z3,%1"
@@ -6331,8 +6378,12 @@
 	(if_then_else:GPR (match_dup 5)
 			  (match_operand:GPR 2 "reg_or_0_operand")
 			  (match_operand:GPR 3 "reg_or_0_operand")))]
-  "ISA_HAS_CONDMOVE"
+  "ISA_HAS_CONDMOVE || ISA_HAS_INT_CONDMOVE"
 {
+  if (ISA_HAS_INT_CONDMOVE
+      && GET_MODE_CLASS (GET_MODE (operands[0])) == MODE_FLOAT)
+    FAIL;
+
   mips_expand_conditional_move (operands);
   DONE;
 })
@@ -6481,6 +6532,9 @@
 ; ST-Microelectronics Loongson-2E/2F-specific patterns.
 (include "loongson.md")
 
+; Sony ALLEGREX instructions.
+(include "allegrex.md")
+
 (define_c_enum "unspec" [
   UNSPEC_ADDRESS_FIRST
 ])
diff -Nbaur gcc-4.6.3/gcc/config/mips/mips.opt gcc-4.6.3-psp/gcc/config/mips/mips.opt
--- gcc-4.6.3/gcc/config/mips/mips.opt	2011-02-17 01:59:04.000000000 +0000
+++ gcc-4.6.3-psp/gcc/config/mips/mips.opt	2012-04-03 18:40:18.000000000 +0100
@@ -306,5 +306,9 @@
 Target Report Var(TARGET_XGOT)
 Lift restrictions on GOT size
 
+mpreferred-stack-boundary=
+Target RejectNegative Joined Var(mips_preferred_stack_boundary_string)
+Attempt to keep stack aligned to this power of 2
+
 noasmopt
 Driver
diff -Nbaur gcc-4.6.3/gcc/config/mips/psp.h gcc-4.6.3-psp/gcc/config/mips/psp.h
--- gcc-4.6.3/gcc/config/mips/psp.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.6.3-psp/gcc/config/mips/psp.h	2012-04-03 18:40:18.000000000 +0100
@@ -0,0 +1,31 @@
+/* Support for Sony's Playstation Portable (PSP).
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   Contributed by Marcus R. Brown <mrbrown@ocgnet.org>
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* Override the startfile spec to include crt0.o. */
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC "crt0%O%s crti%O%s crtbegin%O%s"
+
+#undef SUBTARGET_CPP_SPEC
+#define SUBTARGET_CPP_SPEC "-DPSP=1 -D__psp__=1 -D_PSP=1"
+
+/* Get rid of the .pdr section. */
+#undef SUBTARGET_ASM_SPEC
+#define SUBTARGET_ASM_SPEC "-mno-pdr"
diff -Nbaur gcc-4.6.3/gcc/config/mips/t-allegrex gcc-4.6.3-psp/gcc/config/mips/t-allegrex
--- gcc-4.6.3/gcc/config/mips/t-allegrex	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.6.3-psp/gcc/config/mips/t-allegrex	2012-04-03 18:40:18.000000000 +0100
@@ -0,0 +1,29 @@
+# Suppress building libgcc1.a, since the MIPS compiler port is complete
+# and does not need anything from libgcc1.a.
+LIBGCC1 =
+CROSS_LIBGCC1 =
+
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crti.o crtn.o
+# Don't let CTOR_LIST end up in sdata section.
+CRTSTUFF_T_CFLAGS = -G 0
+
+# Assemble startup files.
+$(T)crti.o: $(srcdir)/config/mips/crti.asm $(GCC_PASSES)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \
+	-c -o $(T)crti.o -x assembler-with-cpp $(srcdir)/config/mips/crti.asm
+
+$(T)crtn.o: $(srcdir)/config/mips/crtn.asm $(GCC_PASSES)
+	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \
+	-c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/mips/crtn.asm
+
+# We must build libgcc2.a with -G 0, in case the user wants to link
+# without the $gp register.
+TARGET_LIBGCC2_CFLAGS = -G 0
+
+# Build the libraries for both hard and soft floating point
+
+MULTILIB_OPTIONS = 
+MULTILIB_DIRNAMES = 
+
+LIBGCC = stmp-multilib
+INSTALL_LIBGCC = install-multilib
diff -Nbaur gcc-4.6.3/gcc/config.gcc gcc-4.6.3-psp/gcc/config.gcc
--- gcc-4.6.3/gcc/config.gcc	2011-07-22 17:44:50.000000000 +0100
+++ gcc-4.6.3-psp/gcc/config.gcc	2012-04-03 18:40:18.000000000 +0100
@@ -2033,6 +2033,18 @@
 	tm_file="elfos.h newlib-stdint.h ${tm_file} mips/r3900.h mips/elf.h"
 	tmake_file="mips/t-r3900 mips/t-libgcc-mips16"
 	;;
+mipsallegrex-*-elf* | mipsallegrexel-*-elf*)
+   tm_file="elfos.h ${tm_file} mips/elf.h"
+   tmake_file=mips/t-allegrex
+   target_cpu_default="MASK_SINGLE_FLOAT|MASK_DIVIDE_BREAKS"
+   tm_defines="MIPS_ISA_DEFAULT=2 MIPS_CPU_STRING_DEFAULT=\\\"allegrex\\\" MIPS_ABI_DEFAULT=ABI_EABI"
+   case ${target} in
+   mipsallegrex*-psp-elf*) 
+       tm_file="${tm_file} mips/psp.h"
+       ;;
+   esac
+   use_fixproto=yes
+   ;;
 mmix-knuth-mmixware)
 	tm_file="${tm_file} newlib-stdint.h"
 	need_64bit_hwint=yes
diff -Nbaur gcc-4.6.3/libgcc/config.host gcc-4.6.3-psp/libgcc/config.host
--- gcc-4.6.3/libgcc/config.host	2011-11-23 22:15:54.000000000 +0000
+++ gcc-4.6.3-psp/libgcc/config.host	2012-04-03 19:04:30.000000000 +0100
@@ -436,6 +436,8 @@
 	;;
 mipstx39-*-elf* | mipstx39el-*-elf*)
 	;;
+mips*-psp-elf*)
+	;;
 mmix-knuth-mmixware)
 	extra_parts="crti.o crtn.o crtbegin.o crtend.o"
 	tmake_file="${tmake_file} ${cpu_type}/t-${cpu_type}"
diff -Nbaur gcc-4.6.3/zlib/acinclude.m4 gcc-4.6.3-psp/zlib/acinclude.m4
--- gcc-4.6.3/zlib/acinclude.m4	2005-09-12 18:02:07.000000000 +0100
+++ gcc-4.6.3-psp/zlib/acinclude.m4	1970-01-01 01:00:00.000000000 +0100
@@ -1,9 +0,0 @@
-sinclude(../config/no-executables.m4)
-sinclude(../libtool.m4)
-dnl The lines below arrange for aclocal not to bring libtool.m4
-dnl AM_PROG_LIBTOOL into aclocal.m4, while still arranging for automake
-dnl to add a definition of LIBTOOL to Makefile.in.
-ifelse(yes,no,[
-AC_DEFUN([AM_PROG_LIBTOOL],)
-AC_SUBST(LIBTOOL)
-])
diff -Nbaur gcc-4.6.3/zlib/aclocal.m4 gcc-4.6.3-psp/zlib/aclocal.m4
--- gcc-4.6.3/zlib/aclocal.m4	2010-04-02 19:18:06.000000000 +0100
+++ gcc-4.6.3-psp/zlib/aclocal.m4	1970-01-01 01:00:00.000000000 +0100
@@ -1,979 +0,0 @@
-# generated automatically by aclocal 1.11.1 -*- Autoconf -*-
-
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-m4_ifndef([AC_AUTOCONF_VERSION],
-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
-m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,
-[m4_warning([this file was generated for autoconf 2.64.
-You have another version of autoconf.  It may work, but is not guaranteed to.
-If you have problems, you may need to regenerate the build system entirely.
-To do so, use the procedure documented by the package, typically `autoreconf'.])])
-
-# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# AM_AUTOMAKE_VERSION(VERSION)
-# ----------------------------
-# Automake X.Y traces this macro to ensure aclocal.m4 has been
-# generated from the m4 files accompanying Automake X.Y.
-# (This private macro should not be called outside this file.)
-AC_DEFUN([AM_AUTOMAKE_VERSION],
-[am__api_version='1.11'
-dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
-dnl require some minimum version.  Point them to the right macro.
-m4_if([$1], [1.11.1], [],
-      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
-])
-
-# _AM_AUTOCONF_VERSION(VERSION)
-# -----------------------------
-# aclocal traces this macro to find the Autoconf version.
-# This is a private macro too.  Using m4_define simplifies
-# the logic in aclocal, which can simply ignore this definition.
-m4_define([_AM_AUTOCONF_VERSION], [])
-
-# AM_SET_CURRENT_AUTOMAKE_VERSION
-# -------------------------------
-# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
-# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
-AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-[AM_AUTOMAKE_VERSION([1.11.1])dnl
-m4_ifndef([AC_AUTOCONF_VERSION],
-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
-_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
-
-# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
-
-# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
-# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
-# `$srcdir', `$srcdir/..', or `$srcdir/../..'.
-#
-# Of course, Automake must honor this variable whenever it calls a
-# tool from the auxiliary directory.  The problem is that $srcdir (and
-# therefore $ac_aux_dir as well) can be either absolute or relative,
-# depending on how configure is run.  This is pretty annoying, since
-# it makes $ac_aux_dir quite unusable in subdirectories: in the top
-# source directory, any form will work fine, but in subdirectories a
-# relative path needs to be adjusted first.
-#
-# $ac_aux_dir/missing
-#    fails when called from a subdirectory if $ac_aux_dir is relative
-# $top_srcdir/$ac_aux_dir/missing
-#    fails if $ac_aux_dir is absolute,
-#    fails when called from a subdirectory in a VPATH build with
-#          a relative $ac_aux_dir
-#
-# The reason of the latter failure is that $top_srcdir and $ac_aux_dir
-# are both prefixed by $srcdir.  In an in-source build this is usually
-# harmless because $srcdir is `.', but things will broke when you
-# start a VPATH build or use an absolute $srcdir.
-#
-# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
-# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:
-#   am_aux_dir='\$(top_srcdir)/'`expr "$ac_aux_dir" : "$srcdir//*\(.*\)"`
-# and then we would define $MISSING as
-#   MISSING="\${SHELL} $am_aux_dir/missing"
-# This will work as long as MISSING is not called from configure, because
-# unfortunately $(top_srcdir) has no meaning in configure.
-# However there are other variables, like CC, which are often used in
-# configure, and could therefore not use this "fixed" $ac_aux_dir.
-#
-# Another solution, used here, is to always expand $ac_aux_dir to an
-# absolute PATH.  The drawback is that using absolute paths prevent a
-# configured tree to be moved without reconfiguration.
-
-AC_DEFUN([AM_AUX_DIR_EXPAND],
-[dnl Rely on autoconf to set up CDPATH properly.
-AC_PREREQ([2.50])dnl
-# expand $ac_aux_dir to an absolute path
-am_aux_dir=`cd $ac_aux_dir && pwd`
-])
-
-# AM_CONDITIONAL                                            -*- Autoconf -*-
-
-# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008
-# Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 9
-
-# AM_CONDITIONAL(NAME, SHELL-CONDITION)
-# -------------------------------------
-# Define a conditional.
-AC_DEFUN([AM_CONDITIONAL],
-[AC_PREREQ(2.52)dnl
- ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
-	[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
-AC_SUBST([$1_TRUE])dnl
-AC_SUBST([$1_FALSE])dnl
-_AM_SUBST_NOTMAKE([$1_TRUE])dnl
-_AM_SUBST_NOTMAKE([$1_FALSE])dnl
-m4_define([_AM_COND_VALUE_$1], [$2])dnl
-if $2; then
-  $1_TRUE=
-  $1_FALSE='#'
-else
-  $1_TRUE='#'
-  $1_FALSE=
-fi
-AC_CONFIG_COMMANDS_PRE(
-[if test -z "${$1_TRUE}" && test -z "${$1_FALSE}"; then
-  AC_MSG_ERROR([[conditional "$1" was never defined.
-Usually this means the macro was only invoked conditionally.]])
-fi])])
-
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009
-# Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 10
-
-# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
-# written in clear, in which case automake, when reading aclocal.m4,
-# will think it sees a *use*, and therefore will trigger all it's
-# C support machinery.  Also note that it means that autoscan, seeing
-# CC etc. in the Makefile, will ask for an AC_PROG_CC use...
-
-
-# _AM_DEPENDENCIES(NAME)
-# ----------------------
-# See how the compiler implements dependency checking.
-# NAME is "CC", "CXX", "GCJ", or "OBJC".
-# We try a few techniques and use that to set a single cache variable.
-#
-# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was
-# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular
-# dependency, and given that the user is not expected to run this macro,
-# just rely on AC_PROG_CC.
-AC_DEFUN([_AM_DEPENDENCIES],
-[AC_REQUIRE([AM_SET_DEPDIR])dnl
-AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl
-AC_REQUIRE([AM_MAKE_INCLUDE])dnl
-AC_REQUIRE([AM_DEP_TRACK])dnl
-
-ifelse([$1], CC,   [depcc="$CC"   am_compiler_list=],
-       [$1], CXX,  [depcc="$CXX"  am_compiler_list=],
-       [$1], OBJC, [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
-       [$1], UPC,  [depcc="$UPC"  am_compiler_list=],
-       [$1], GCJ,  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
-                   [depcc="$$1"   am_compiler_list=])
-
-AC_CACHE_CHECK([dependency style of $depcc],
-               [am_cv_$1_dependencies_compiler_type],
-[if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
-  # We make a subdir and do the tests there.  Otherwise we can end up
-  # making bogus files that we don't know about and never remove.  For
-  # instance it was reported that on HP-UX the gcc test will end up
-  # making a dummy file named `D' -- because `-MD' means `put the output
-  # in D'.
-  mkdir conftest.dir
-  # Copy depcomp to subdir because otherwise we won't find it if we're
-  # using a relative directory.
-  cp "$am_depcomp" conftest.dir
-  cd conftest.dir
-  # We will build objects and dependencies in a subdirectory because
-  # it helps to detect inapplicable dependency modes.  For instance
-  # both Tru64's cc and ICC support -MD to output dependencies as a
-  # side effect of compilation, but ICC will put the dependencies in
-  # the current directory while Tru64 will put them in the object
-  # directory.
-  mkdir sub
-
-  am_cv_$1_dependencies_compiler_type=none
-  if test "$am_compiler_list" = ""; then
-     am_compiler_list=`sed -n ['s/^#*\([a-zA-Z0-9]*\))$/\1/p'] < ./depcomp`
-  fi
-  am__universal=false
-  m4_case([$1], [CC],
-    [case " $depcc " in #(
-     *\ -arch\ *\ -arch\ *) am__universal=true ;;
-     esac],
-    [CXX],
-    [case " $depcc " in #(
-     *\ -arch\ *\ -arch\ *) am__universal=true ;;
-     esac])
-
-  for depmode in $am_compiler_list; do
-    # Setup a source with many dependencies, because some compilers
-    # like to wrap large dependency lists on column 80 (with \), and
-    # we should not choose a depcomp mode which is confused by this.
-    #
-    # We need to recreate these files for each test, as the compiler may
-    # overwrite some of them when testing with obscure command lines.
-    # This happens at least with the AIX C compiler.
-    : > sub/conftest.c
-    for i in 1 2 3 4 5 6; do
-      echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
-      # Solaris 8's {/usr,}/bin/sh.
-      touch sub/conftst$i.h
-    done
-    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
-
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
-    # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
-    am__obj=sub/conftest.${OBJEXT-o}
-    am__minus_obj="-o $am__obj"
-    case $depmode in
-    gcc)
-      # This depmode causes a compiler race in universal mode.
-      test "$am__universal" = false || continue
-      ;;
-    nosideeffect)
-      # after this tag, mechanisms are not by side-effect, so they'll
-      # only be used when explicitly requested
-      if test "x$enable_dependency_tracking" = xyes; then
-	continue
-      else
-	break
-      fi
-      ;;
-    msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
-      # not run yet.  These depmodes are late enough in the game, and
-      # so weak that their functioning should not be impacted.
-      am__obj=conftest.${OBJEXT-o}
-      am__minus_obj=
-      ;;
-    none) break ;;
-    esac
-    if depmode=$depmode \
-       source=sub/conftest.c object=$am__obj \
-       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
-       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
-         >/dev/null 2>conftest.err &&
-       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
-       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
-       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
-       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
-      # icc doesn't choke on unknown options, it will just issue warnings
-      # or remarks (even with -Werror).  So we grep stderr for any message
-      # that says an option was ignored or not supported.
-      # When given -MP, icc 7.0 and 7.1 complain thusly:
-      #   icc: Command line warning: ignoring option '-M'; no argument required
-      # The diagnosis changed in icc 8.0:
-      #   icc: Command line remark: option '-MP' not supported
-      if (grep 'ignoring option' conftest.err ||
-          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
-        am_cv_$1_dependencies_compiler_type=$depmode
-        break
-      fi
-    fi
-  done
-
-  cd ..
-  rm -rf conftest.dir
-else
-  am_cv_$1_dependencies_compiler_type=none
-fi
-])
-AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])
-AM_CONDITIONAL([am__fastdep$1], [
-  test "x$enable_dependency_tracking" != xno \
-  && test "$am_cv_$1_dependencies_compiler_type" = gcc3])
-])
-
-
-# AM_SET_DEPDIR
-# -------------
-# Choose a directory name for dependency files.
-# This macro is AC_REQUIREd in _AM_DEPENDENCIES
-AC_DEFUN([AM_SET_DEPDIR],
-[AC_REQUIRE([AM_SET_LEADING_DOT])dnl
-AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
-])
-
-
-# AM_DEP_TRACK
-# ------------
-AC_DEFUN([AM_DEP_TRACK],
-[AC_ARG_ENABLE(dependency-tracking,
-[  --disable-dependency-tracking  speeds up one-time build
-  --enable-dependency-tracking   do not reject slow dependency extractors])
-if test "x$enable_dependency_tracking" != xno; then
-  am_depcomp="$ac_aux_dir/depcomp"
-  AMDEPBACKSLASH='\'
-fi
-AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
-AC_SUBST([AMDEPBACKSLASH])dnl
-_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl
-])
-
-# Generate code to set up dependency tracking.              -*- Autoconf -*-
-
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008
-# Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-#serial 5
-
-# _AM_OUTPUT_DEPENDENCY_COMMANDS
-# ------------------------------
-AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
-[{
-  # Autoconf 2.62 quotes --file arguments for eval, but not when files
-  # are listed without --file.  Let's play safe and only enable the eval
-  # if we detect the quoting.
-  case $CONFIG_FILES in
-  *\'*) eval set x "$CONFIG_FILES" ;;
-  *)   set x $CONFIG_FILES ;;
-  esac
-  shift
-  for mf
-  do
-    # Strip MF so we end up with the name of the file.
-    mf=`echo "$mf" | sed -e 's/:.*$//'`
-    # Check whether this is an Automake generated Makefile or not.
-    # We used to match only the files named `Makefile.in', but
-    # some people rename them; so instead we look at the file content.
-    # Grep'ing the first line is not enough: some people post-process
-    # each Makefile.in and add a new line on top of each file to say so.
-    # Grep'ing the whole file is not good either: AIX grep has a line
-    # limit of 2048, but all sed's we know have understand at least 4000.
-    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
-      dirpart=`AS_DIRNAME("$mf")`
-    else
-      continue
-    fi
-    # Extract the definition of DEPDIR, am__include, and am__quote
-    # from the Makefile without running `make'.
-    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
-    test -z "$DEPDIR" && continue
-    am__include=`sed -n 's/^am__include = //p' < "$mf"`
-    test -z "am__include" && continue
-    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
-    # When using ansi2knr, U may be empty or an underscore; expand it
-    U=`sed -n 's/^U = //p' < "$mf"`
-    # Find all dependency output files, they are included files with
-    # $(DEPDIR) in their names.  We invoke sed twice because it is the
-    # simplest approach to changing $(DEPDIR) to its actual value in the
-    # expansion.
-    for file in `sed -n "
-      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
-	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
-      # Make sure the directory exists.
-      test -f "$dirpart/$file" && continue
-      fdir=`AS_DIRNAME(["$file"])`
-      AS_MKDIR_P([$dirpart/$fdir])
-      # echo "creating $dirpart/$file"
-      echo '# dummy' > "$dirpart/$file"
-    done
-  done
-}
-])# _AM_OUTPUT_DEPENDENCY_COMMANDS
-
-
-# AM_OUTPUT_DEPENDENCY_COMMANDS
-# -----------------------------
-# This macro should only be invoked once -- use via AC_REQUIRE.
-#
-# This code is only required when automatic dependency tracking
-# is enabled.  FIXME.  This creates each `.P' file that we will
-# need in order to bootstrap the dependency handling code.
-AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
-[AC_CONFIG_COMMANDS([depfiles],
-     [test x"$AMDEP_TRUE" != x"" || _AM_OUTPUT_DEPENDENCY_COMMANDS],
-     [AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"])
-])
-
-# Do all the work for Automake.                             -*- Autoconf -*-
-
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 16
-
-# This macro actually does too much.  Some checks are only needed if
-# your package does certain things.  But this isn't really a big deal.
-
-# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])
-# AM_INIT_AUTOMAKE([OPTIONS])
-# -----------------------------------------------
-# The call with PACKAGE and VERSION arguments is the old style
-# call (pre autoconf-2.50), which is being phased out.  PACKAGE
-# and VERSION should now be passed to AC_INIT and removed from
-# the call to AM_INIT_AUTOMAKE.
-# We support both call styles for the transition.  After
-# the next Automake release, Autoconf can make the AC_INIT
-# arguments mandatory, and then we can depend on a new Autoconf
-# release and drop the old call support.
-AC_DEFUN([AM_INIT_AUTOMAKE],
-[AC_PREREQ([2.62])dnl
-dnl Autoconf wants to disallow AM_ names.  We explicitly allow
-dnl the ones we care about.
-m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl
-AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl
-AC_REQUIRE([AC_PROG_INSTALL])dnl
-if test "`cd $srcdir && pwd`" != "`pwd`"; then
-  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
-  # is not polluted with repeated "-I."
-  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl
-  # test to see if srcdir already configured
-  if test -f $srcdir/config.status; then
-    AC_MSG_ERROR([source directory already configured; run "make distclean" there first])
-  fi
-fi
-
-# test whether we have cygpath
-if test -z "$CYGPATH_W"; then
-  if (cygpath --version) >/dev/null 2>/dev/null; then
-    CYGPATH_W='cygpath -w'
-  else
-    CYGPATH_W=echo
-  fi
-fi
-AC_SUBST([CYGPATH_W])
-
-# Define the identity of the package.
-dnl Distinguish between old-style and new-style calls.
-m4_ifval([$2],
-[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
- AC_SUBST([PACKAGE], [$1])dnl
- AC_SUBST([VERSION], [$2])],
-[_AM_SET_OPTIONS([$1])dnl
-dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.
-m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,
-  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl
- AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
- AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl
-
-_AM_IF_OPTION([no-define],,
-[AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE", [Name of package])
- AC_DEFINE_UNQUOTED(VERSION, "$VERSION", [Version number of package])])dnl
-
-# Some tools Automake needs.
-AC_REQUIRE([AM_SANITY_CHECK])dnl
-AC_REQUIRE([AC_ARG_PROGRAM])dnl
-AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})
-AM_MISSING_PROG(AUTOCONF, autoconf)
-AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})
-AM_MISSING_PROG(AUTOHEADER, autoheader)
-AM_MISSING_PROG(MAKEINFO, makeinfo)
-AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
-AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl
-AC_REQUIRE([AM_PROG_MKDIR_P])dnl
-# We need awk for the "check" target.  The system "awk" is bad on
-# some platforms.
-AC_REQUIRE([AC_PROG_AWK])dnl
-AC_REQUIRE([AC_PROG_MAKE_SET])dnl
-AC_REQUIRE([AM_SET_LEADING_DOT])dnl
-_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],
-	      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],
-			     [_AM_PROG_TAR([v7])])])
-_AM_IF_OPTION([no-dependencies],,
-[AC_PROVIDE_IFELSE([AC_PROG_CC],
-		  [_AM_DEPENDENCIES(CC)],
-		  [define([AC_PROG_CC],
-			  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl
-AC_PROVIDE_IFELSE([AC_PROG_CXX],
-		  [_AM_DEPENDENCIES(CXX)],
-		  [define([AC_PROG_CXX],
-			  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl
-AC_PROVIDE_IFELSE([AC_PROG_OBJC],
-		  [_AM_DEPENDENCIES(OBJC)],
-		  [define([AC_PROG_OBJC],
-			  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl
-])
-_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl
-dnl The `parallel-tests' driver may need to know about EXEEXT, so add the
-dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro
-dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.
-AC_CONFIG_COMMANDS_PRE(dnl
-[m4_provide_if([_AM_COMPILER_EXEEXT],
-  [AM_CONDITIONAL([am__EXEEXT], [test -n "$EXEEXT"])])])dnl
-])
-
-dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
-dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further
-dnl mangled by Autoconf and run in a shell conditional statement.
-m4_define([_AC_COMPILER_EXEEXT],
-m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])
-
-
-# When config.status generates a header, we must update the stamp-h file.
-# This file resides in the same directory as the config header
-# that is generated.  The stamp files are numbered to have different names.
-
-# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the
-# loop where config.status creates the headers, so we can generate
-# our stamp files there.
-AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],
-[# Compute $1's index in $config_headers.
-_am_arg=$1
-_am_stamp_count=1
-for _am_header in $config_headers :; do
-  case $_am_header in
-    $_am_arg | $_am_arg:* )
-      break ;;
-    * )
-      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
-  esac
-done
-echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
-
-# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# AM_PROG_INSTALL_SH
-# ------------------
-# Define $install_sh.
-AC_DEFUN([AM_PROG_INSTALL_SH],
-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
-if test x"${install_sh}" != xset; then
-  case $am_aux_dir in
-  *\ * | *\	*)
-    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
-  *)
-    install_sh="\${SHELL} $am_aux_dir/install-sh"
-  esac
-fi
-AC_SUBST(install_sh)])
-
-# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-
-# From Jim Meyering
-
-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008
-# Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 5
-
-# AM_MAINTAINER_MODE([DEFAULT-MODE])
-# ----------------------------------
-# Control maintainer-specific portions of Makefiles.
-# Default is to disable them, unless `enable' is passed literally.
-# For symmetry, `disable' may be passed as well.  Anyway, the user
-# can override the default with the --enable/--disable switch.
-AC_DEFUN([AM_MAINTAINER_MODE],
-[m4_case(m4_default([$1], [disable]),
-       [enable], [m4_define([am_maintainer_other], [disable])],
-       [disable], [m4_define([am_maintainer_other], [enable])],
-       [m4_define([am_maintainer_other], [enable])
-        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])
-AC_MSG_CHECKING([whether to am_maintainer_other maintainer-specific portions of Makefiles])
-  dnl maintainer-mode's default is 'disable' unless 'enable' is passed
-  AC_ARG_ENABLE([maintainer-mode],
-[  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful
-			  (and sometimes confusing) to the casual installer],
-      [USE_MAINTAINER_MODE=$enableval],
-      [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))
-  AC_MSG_RESULT([$USE_MAINTAINER_MODE])
-  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])
-  MAINT=$MAINTAINER_MODE_TRUE
-  AC_SUBST([MAINT])dnl
-]
-)
-
-AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])
-
-# Check to see how 'make' treats includes.	            -*- Autoconf -*-
-
-# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 4
-
-# AM_MAKE_INCLUDE()
-# -----------------
-# Check to see how make treats includes.
-AC_DEFUN([AM_MAKE_INCLUDE],
-[am_make=${MAKE-make}
-cat > confinc << 'END'
-am__doit:
-	@echo this is the am__doit target
-.PHONY: am__doit
-END
-# If we don't find an include directive, just comment out the code.
-AC_MSG_CHECKING([for style of include used by $am_make])
-am__include="#"
-am__quote=
-_am_result=none
-# First try GNU make style include.
-echo "include confinc" > confmf
-# Ignore all kinds of additional output from `make'.
-case `$am_make -s -f confmf 2> /dev/null` in #(
-*the\ am__doit\ target*)
-  am__include=include
-  am__quote=
-  _am_result=GNU
-  ;;
-esac
-# Now try BSD make style include.
-if test "$am__include" = "#"; then
-   echo '.include "confinc"' > confmf
-   case `$am_make -s -f confmf 2> /dev/null` in #(
-   *the\ am__doit\ target*)
-     am__include=.include
-     am__quote="\""
-     _am_result=BSD
-     ;;
-   esac
-fi
-AC_SUBST([am__include])
-AC_SUBST([am__quote])
-AC_MSG_RESULT([$_am_result])
-rm -f confinc confmf
-])
-
-# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
-
-# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008
-# Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 6
-
-# AM_MISSING_PROG(NAME, PROGRAM)
-# ------------------------------
-AC_DEFUN([AM_MISSING_PROG],
-[AC_REQUIRE([AM_MISSING_HAS_RUN])
-$1=${$1-"${am_missing_run}$2"}
-AC_SUBST($1)])
-
-
-# AM_MISSING_HAS_RUN
-# ------------------
-# Define MISSING if not defined so far and test if it supports --run.
-# If it does, set am_missing_run to use it, otherwise, to nothing.
-AC_DEFUN([AM_MISSING_HAS_RUN],
-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
-AC_REQUIRE_AUX_FILE([missing])dnl
-if test x"${MISSING+set}" != xset; then
-  case $am_aux_dir in
-  *\ * | *\	*)
-    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
-  *)
-    MISSING="\${SHELL} $am_aux_dir/missing" ;;
-  esac
-fi
-# Use eval to expand $SHELL
-if eval "$MISSING --run true"; then
-  am_missing_run="$MISSING --run "
-else
-  am_missing_run=
-  AC_MSG_WARN([`missing' script is too old or missing])
-fi
-])
-
-# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# AM_PROG_MKDIR_P
-# ---------------
-# Check for `mkdir -p'.
-AC_DEFUN([AM_PROG_MKDIR_P],
-[AC_PREREQ([2.60])dnl
-AC_REQUIRE([AC_PROG_MKDIR_P])dnl
-dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,
-dnl while keeping a definition of mkdir_p for backward compatibility.
-dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.
-dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of
-dnl Makefile.ins that do not define MKDIR_P, so we do our own
-dnl adjustment using top_builddir (which is defined more often than
-dnl MKDIR_P).
-AC_SUBST([mkdir_p], ["$MKDIR_P"])dnl
-case $mkdir_p in
-  [[\\/$]]* | ?:[[\\/]]*) ;;
-  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
-esac
-])
-
-# Helper functions for option handling.                     -*- Autoconf -*-
-
-# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 4
-
-# _AM_MANGLE_OPTION(NAME)
-# -----------------------
-AC_DEFUN([_AM_MANGLE_OPTION],
-[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])
-
-# _AM_SET_OPTION(NAME)
-# ------------------------------
-# Set option NAME.  Presently that only means defining a flag for this option.
-AC_DEFUN([_AM_SET_OPTION],
-[m4_define(_AM_MANGLE_OPTION([$1]), 1)])
-
-# _AM_SET_OPTIONS(OPTIONS)
-# ----------------------------------
-# OPTIONS is a space-separated list of Automake options.
-AC_DEFUN([_AM_SET_OPTIONS],
-[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])
-
-# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])
-# -------------------------------------------
-# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
-AC_DEFUN([_AM_IF_OPTION],
-[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])
-
-# Check to make sure that the build environment is sane.    -*- Autoconf -*-
-
-# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008
-# Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 5
-
-# AM_SANITY_CHECK
-# ---------------
-AC_DEFUN([AM_SANITY_CHECK],
-[AC_MSG_CHECKING([whether build environment is sane])
-# Just in case
-sleep 1
-echo timestamp > conftest.file
-# Reject unsafe characters in $srcdir or the absolute working directory
-# name.  Accept space and tab only in the latter.
-am_lf='
-'
-case `pwd` in
-  *[[\\\"\#\$\&\'\`$am_lf]]*)
-    AC_MSG_ERROR([unsafe absolute working directory name]);;
-esac
-case $srcdir in
-  *[[\\\"\#\$\&\'\`$am_lf\ \	]]*)
-    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;
-esac
-
-# Do `set' in a subshell so we don't clobber the current shell's
-# arguments.  Must try -L first in case configure is actually a
-# symlink; some systems play weird games with the mod time of symlinks
-# (eg FreeBSD returns the mod time of the symlink's containing
-# directory).
-if (
-   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
-   if test "$[*]" = "X"; then
-      # -L didn't work.
-      set X `ls -t "$srcdir/configure" conftest.file`
-   fi
-   rm -f conftest.file
-   if test "$[*]" != "X $srcdir/configure conftest.file" \
-      && test "$[*]" != "X conftest.file $srcdir/configure"; then
-
-      # If neither matched, then we have a broken ls.  This can happen
-      # if, for instance, CONFIG_SHELL is bash and it inherits a
-      # broken ls alias from the environment.  This has actually
-      # happened.  Such a system could not be considered "sane".
-      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
-alias in your environment])
-   fi
-
-   test "$[2]" = conftest.file
-   )
-then
-   # Ok.
-   :
-else
-   AC_MSG_ERROR([newly created file is older than distributed files!
-Check your system clock])
-fi
-AC_MSG_RESULT(yes)])
-
-# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# AM_PROG_INSTALL_STRIP
-# ---------------------
-# One issue with vendor `install' (even GNU) is that you can't
-# specify the program used to strip binaries.  This is especially
-# annoying in cross-compiling environments, where the build's strip
-# is unlikely to handle the host's binaries.
-# Fortunately install-sh will honor a STRIPPROG variable, so we
-# always use install-sh in `make install-strip', and initialize
-# STRIPPROG with the value of the STRIP variable (set by the user).
-AC_DEFUN([AM_PROG_INSTALL_STRIP],
-[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
-# Installed binaries are usually stripped using `strip' when the user
-# run `make install-strip'.  However `strip' might not be the right
-# tool to use in cross-compilation environments, therefore Automake
-# will honor the `STRIP' environment variable to overrule this program.
-dnl Don't test for $cross_compiling = yes, because it might be `maybe'.
-if test "$cross_compiling" != no; then
-  AC_CHECK_TOOL([STRIP], [strip], :)
-fi
-INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
-AC_SUBST([INSTALL_STRIP_PROGRAM])])
-
-# Copyright (C) 2006, 2008  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 2
-
-# _AM_SUBST_NOTMAKE(VARIABLE)
-# ---------------------------
-# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.
-# This macro is traced by Automake.
-AC_DEFUN([_AM_SUBST_NOTMAKE])
-
-# AM_SUBST_NOTMAKE(VARIABLE)
-# ---------------------------
-# Public sister of _AM_SUBST_NOTMAKE.
-AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])
-
-# Check how to create a tarball.                            -*- Autoconf -*-
-
-# Copyright (C) 2004, 2005  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# serial 2
-
-# _AM_PROG_TAR(FORMAT)
-# --------------------
-# Check how to create a tarball in format FORMAT.
-# FORMAT should be one of `v7', `ustar', or `pax'.
-#
-# Substitute a variable $(am__tar) that is a command
-# writing to stdout a FORMAT-tarball containing the directory
-# $tardir.
-#     tardir=directory && $(am__tar) > result.tar
-#
-# Substitute a variable $(am__untar) that extract such
-# a tarball read from stdin.
-#     $(am__untar) < result.tar
-AC_DEFUN([_AM_PROG_TAR],
-[# Always define AMTAR for backward compatibility.
-AM_MISSING_PROG([AMTAR], [tar])
-m4_if([$1], [v7],
-     [am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'],
-     [m4_case([$1], [ustar],, [pax],,
-              [m4_fatal([Unknown tar format])])
-AC_MSG_CHECKING([how to create a $1 tar archive])
-# Loop over all known methods to create a tar archive until one works.
-_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'
-_am_tools=${am_cv_prog_tar_$1-$_am_tools}
-# Do not fold the above two line into one, because Tru64 sh and
-# Solaris sh will not grok spaces in the rhs of `-'.
-for _am_tool in $_am_tools
-do
-  case $_am_tool in
-  gnutar)
-    for _am_tar in tar gnutar gtar;
-    do
-      AM_RUN_LOG([$_am_tar --version]) && break
-    done
-    am__tar="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$$tardir"'
-    am__tar_="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$tardir"'
-    am__untar="$_am_tar -xf -"
-    ;;
-  plaintar)
-    # Must skip GNU tar: if it does not support --format= it doesn't create
-    # ustar tarball either.
-    (tar --version) >/dev/null 2>&1 && continue
-    am__tar='tar chf - "$$tardir"'
-    am__tar_='tar chf - "$tardir"'
-    am__untar='tar xf -'
-    ;;
-  pax)
-    am__tar='pax -L -x $1 -w "$$tardir"'
-    am__tar_='pax -L -x $1 -w "$tardir"'
-    am__untar='pax -r'
-    ;;
-  cpio)
-    am__tar='find "$$tardir" -print | cpio -o -H $1 -L'
-    am__tar_='find "$tardir" -print | cpio -o -H $1 -L'
-    am__untar='cpio -i -H $1 -d'
-    ;;
-  none)
-    am__tar=false
-    am__tar_=false
-    am__untar=false
-    ;;
-  esac
-
-  # If the value was cached, stop now.  We just wanted to have am__tar
-  # and am__untar set.
-  test -n "${am_cv_prog_tar_$1}" && break
-
-  # tar/untar a dummy directory, and stop if the command works
-  rm -rf conftest.dir
-  mkdir conftest.dir
-  echo GrepMe > conftest.dir/file
-  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
-  rm -rf conftest.dir
-  if test -s conftest.tar; then
-    AM_RUN_LOG([$am__untar <conftest.tar])
-    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
-  fi
-done
-rm -rf conftest.dir
-
-AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
-AC_MSG_RESULT([$am_cv_prog_tar_$1])])
-AC_SUBST([am__tar])
-AC_SUBST([am__untar])
-]) # _AM_PROG_TAR
-
-m4_include([../config/depstand.m4])
-m4_include([../config/lead-dot.m4])
-m4_include([../config/multi.m4])
-m4_include([../config/override.m4])
-m4_include([../ltoptions.m4])
-m4_include([../ltsugar.m4])
-m4_include([../ltversion.m4])
-m4_include([../lt~obsolete.m4])
-m4_include([acinclude.m4])
diff -Nbaur gcc-4.6.3/zlib/adler32.c gcc-4.6.3-psp/zlib/adler32.c
--- gcc-4.6.3/zlib/adler32.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/adler32.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,149 +0,0 @@
-/* adler32.c -- compute the Adler-32 checksum of a data stream
- * Copyright (C) 1995-2004 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id: adler32.c,v 1.1.1.2 2002/03/11 21:53:23 tromey Exp $ */
-
-#define ZLIB_INTERNAL
-#include "zlib.h"
-
-#define BASE 65521UL    /* largest prime smaller than 65536 */
-#define NMAX 5552
-/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
-
-#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}
-#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
-#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
-#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
-#define DO16(buf)   DO8(buf,0); DO8(buf,8);
-
-/* use NO_DIVIDE if your processor does not do division in hardware */
-#ifdef NO_DIVIDE
-#  define MOD(a) \
-    do { \
-        if (a >= (BASE << 16)) a -= (BASE << 16); \
-        if (a >= (BASE << 15)) a -= (BASE << 15); \
-        if (a >= (BASE << 14)) a -= (BASE << 14); \
-        if (a >= (BASE << 13)) a -= (BASE << 13); \
-        if (a >= (BASE << 12)) a -= (BASE << 12); \
-        if (a >= (BASE << 11)) a -= (BASE << 11); \
-        if (a >= (BASE << 10)) a -= (BASE << 10); \
-        if (a >= (BASE << 9)) a -= (BASE << 9); \
-        if (a >= (BASE << 8)) a -= (BASE << 8); \
-        if (a >= (BASE << 7)) a -= (BASE << 7); \
-        if (a >= (BASE << 6)) a -= (BASE << 6); \
-        if (a >= (BASE << 5)) a -= (BASE << 5); \
-        if (a >= (BASE << 4)) a -= (BASE << 4); \
-        if (a >= (BASE << 3)) a -= (BASE << 3); \
-        if (a >= (BASE << 2)) a -= (BASE << 2); \
-        if (a >= (BASE << 1)) a -= (BASE << 1); \
-        if (a >= BASE) a -= BASE; \
-    } while (0)
-#  define MOD4(a) \
-    do { \
-        if (a >= (BASE << 4)) a -= (BASE << 4); \
-        if (a >= (BASE << 3)) a -= (BASE << 3); \
-        if (a >= (BASE << 2)) a -= (BASE << 2); \
-        if (a >= (BASE << 1)) a -= (BASE << 1); \
-        if (a >= BASE) a -= BASE; \
-    } while (0)
-#else
-#  define MOD(a) a %= BASE
-#  define MOD4(a) a %= BASE
-#endif
-
-/* ========================================================================= */
-uLong ZEXPORT adler32(adler, buf, len)
-    uLong adler;
-    const Bytef *buf;
-    uInt len;
-{
-    unsigned long sum2;
-    unsigned n;
-
-    /* split Adler-32 into component sums */
-    sum2 = (adler >> 16) & 0xffff;
-    adler &= 0xffff;
-
-    /* in case user likes doing a byte at a time, keep it fast */
-    if (len == 1) {
-        adler += buf[0];
-        if (adler >= BASE)
-            adler -= BASE;
-        sum2 += adler;
-        if (sum2 >= BASE)
-            sum2 -= BASE;
-        return adler | (sum2 << 16);
-    }
-
-    /* initial Adler-32 value (deferred check for len == 1 speed) */
-    if (buf == Z_NULL)
-        return 1L;
-
-    /* in case short lengths are provided, keep it somewhat fast */
-    if (len < 16) {
-        while (len--) {
-            adler += *buf++;
-            sum2 += adler;
-        }
-        if (adler >= BASE)
-            adler -= BASE;
-        MOD4(sum2);             /* only added so many BASE's */
-        return adler | (sum2 << 16);
-    }
-
-    /* do length NMAX blocks -- requires just one modulo operation */
-    while (len >= NMAX) {
-        len -= NMAX;
-        n = NMAX / 16;          /* NMAX is divisible by 16 */
-        do {
-            DO16(buf);          /* 16 sums unrolled */
-            buf += 16;
-        } while (--n);
-        MOD(adler);
-        MOD(sum2);
-    }
-
-    /* do remaining bytes (less than NMAX, still just one modulo) */
-    if (len) {                  /* avoid modulos if none remaining */
-        while (len >= 16) {
-            len -= 16;
-            DO16(buf);
-            buf += 16;
-        }
-        while (len--) {
-            adler += *buf++;
-            sum2 += adler;
-        }
-        MOD(adler);
-        MOD(sum2);
-    }
-
-    /* return recombined sums */
-    return adler | (sum2 << 16);
-}
-
-/* ========================================================================= */
-uLong ZEXPORT adler32_combine(adler1, adler2, len2)
-    uLong adler1;
-    uLong adler2;
-    z_off_t len2;
-{
-    unsigned long sum1;
-    unsigned long sum2;
-    unsigned rem;
-
-    /* the derivation of this formula is left as an exercise for the reader */
-    rem = (unsigned)(len2 % BASE);
-    sum1 = adler1 & 0xffff;
-    sum2 = rem * sum1;
-    MOD(sum2);
-    sum1 += (adler2 & 0xffff) + BASE - 1;
-    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;
-    if (sum1 > BASE) sum1 -= BASE;
-    if (sum1 > BASE) sum1 -= BASE;
-    if (sum2 > (BASE << 1)) sum2 -= (BASE << 1);
-    if (sum2 > BASE) sum2 -= BASE;
-    return sum1 | (sum2 << 16);
-}
diff -Nbaur gcc-4.6.3/zlib/algorithm.txt gcc-4.6.3-psp/zlib/algorithm.txt
--- gcc-4.6.3/zlib/algorithm.txt	2005-09-12 18:02:07.000000000 +0100
+++ gcc-4.6.3-psp/zlib/algorithm.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,209 +0,0 @@
-1. Compression algorithm (deflate)
-
-The deflation algorithm used by gzip (also zip and zlib) is a variation of
-LZ77 (Lempel-Ziv 1977, see reference below). It finds duplicated strings in
-the input data.  The second occurrence of a string is replaced by a
-pointer to the previous string, in the form of a pair (distance,
-length).  Distances are limited to 32K bytes, and lengths are limited
-to 258 bytes. When a string does not occur anywhere in the previous
-32K bytes, it is emitted as a sequence of literal bytes.  (In this
-description, `string' must be taken as an arbitrary sequence of bytes,
-and is not restricted to printable characters.)
-
-Literals or match lengths are compressed with one Huffman tree, and
-match distances are compressed with another tree. The trees are stored
-in a compact form at the start of each block. The blocks can have any
-size (except that the compressed data for one block must fit in
-available memory). A block is terminated when deflate() determines that
-it would be useful to start another block with fresh trees. (This is
-somewhat similar to the behavior of LZW-based _compress_.)
-
-Duplicated strings are found using a hash table. All input strings of
-length 3 are inserted in the hash table. A hash index is computed for
-the next 3 bytes. If the hash chain for this index is not empty, all
-strings in the chain are compared with the current input string, and
-the longest match is selected.
-
-The hash chains are searched starting with the most recent strings, to
-favor small distances and thus take advantage of the Huffman encoding.
-The hash chains are singly linked. There are no deletions from the
-hash chains, the algorithm simply discards matches that are too old.
-
-To avoid a worst-case situation, very long hash chains are arbitrarily
-truncated at a certain length, determined by a runtime option (level
-parameter of deflateInit). So deflate() does not always find the longest
-possible match but generally finds a match which is long enough.
-
-deflate() also defers the selection of matches with a lazy evaluation
-mechanism. After a match of length N has been found, deflate() searches for
-a longer match at the next input byte. If a longer match is found, the
-previous match is truncated to a length of one (thus producing a single
-literal byte) and the process of lazy evaluation begins again. Otherwise,
-the original match is kept, and the next match search is attempted only N
-steps later.
-
-The lazy match evaluation is also subject to a runtime parameter. If
-the current match is long enough, deflate() reduces the search for a longer
-match, thus speeding up the whole process. If compression ratio is more
-important than speed, deflate() attempts a complete second search even if
-the first match is already long enough.
-
-The lazy match evaluation is not performed for the fastest compression
-modes (level parameter 1 to 3). For these fast modes, new strings
-are inserted in the hash table only when no match was found, or
-when the match is not too long. This degrades the compression ratio
-but saves time since there are both fewer insertions and fewer searches.
-
-
-2. Decompression algorithm (inflate)
-
-2.1 Introduction
-
-The key question is how to represent a Huffman code (or any prefix code) so
-that you can decode fast.  The most important characteristic is that shorter
-codes are much more common than longer codes, so pay attention to decoding the
-short codes fast, and let the long codes take longer to decode.
-
-inflate() sets up a first level table that covers some number of bits of
-input less than the length of longest code.  It gets that many bits from the
-stream, and looks it up in the table.  The table will tell if the next
-code is that many bits or less and how many, and if it is, it will tell
-the value, else it will point to the next level table for which inflate()
-grabs more bits and tries to decode a longer code.
-
-How many bits to make the first lookup is a tradeoff between the time it
-takes to decode and the time it takes to build the table.  If building the
-table took no time (and if you had infinite memory), then there would only
-be a first level table to cover all the way to the longest code.  However,
-building the table ends up taking a lot longer for more bits since short
-codes are replicated many times in such a table.  What inflate() does is
-simply to make the number of bits in the first table a variable, and  then
-to set that variable for the maximum speed.
-
-For inflate, which has 286 possible codes for the literal/length tree, the size
-of the first table is nine bits.  Also the distance trees have 30 possible
-values, and the size of the first table is six bits.  Note that for each of
-those cases, the table ended up one bit longer than the ``average'' code
-length, i.e. the code length of an approximately flat code which would be a
-little more than eight bits for 286 symbols and a little less than five bits
-for 30 symbols.
-
-
-2.2 More details on the inflate table lookup
-
-Ok, you want to know what this cleverly obfuscated inflate tree actually
-looks like.  You are correct that it's not a Huffman tree.  It is simply a
-lookup table for the first, let's say, nine bits of a Huffman symbol.  The
-symbol could be as short as one bit or as long as 15 bits.  If a particular
-symbol is shorter than nine bits, then that symbol's translation is duplicated
-in all those entries that start with that symbol's bits.  For example, if the
-symbol is four bits, then it's duplicated 32 times in a nine-bit table.  If a
-symbol is nine bits long, it appears in the table once.
-
-If the symbol is longer than nine bits, then that entry in the table points
-to another similar table for the remaining bits.  Again, there are duplicated
-entries as needed.  The idea is that most of the time the symbol will be short
-and there will only be one table look up.  (That's whole idea behind data
-compression in the first place.)  For the less frequent long symbols, there
-will be two lookups.  If you had a compression method with really long
-symbols, you could have as many levels of lookups as is efficient.  For
-inflate, two is enough.
-
-So a table entry either points to another table (in which case nine bits in
-the above example are gobbled), or it contains the translation for the symbol
-and the number of bits to gobble.  Then you start again with the next
-ungobbled bit.
-
-You may wonder: why not just have one lookup table for how ever many bits the
-longest symbol is?  The reason is that if you do that, you end up spending
-more time filling in duplicate symbol entries than you do actually decoding.
-At least for deflate's output that generates new trees every several 10's of
-kbytes.  You can imagine that filling in a 2^15 entry table for a 15-bit code
-would take too long if you're only decoding several thousand symbols.  At the
-other extreme, you could make a new table for every bit in the code.  In fact,
-that's essentially a Huffman tree.  But then you spend two much time
-traversing the tree while decoding, even for short symbols.
-
-So the number of bits for the first lookup table is a trade of the time to
-fill out the table vs. the time spent looking at the second level and above of
-the table.
-
-Here is an example, scaled down:
-
-The code being decoded, with 10 symbols, from 1 to 6 bits long:
-
-A: 0
-B: 10
-C: 1100
-D: 11010
-E: 11011
-F: 11100
-G: 11101
-H: 11110
-I: 111110
-J: 111111
-
-Let's make the first table three bits long (eight entries):
-
-000: A,1
-001: A,1
-010: A,1
-011: A,1
-100: B,2
-101: B,2
-110: -> table X (gobble 3 bits)
-111: -> table Y (gobble 3 bits)
-
-Each entry is what the bits decode as and how many bits that is, i.e. how
-many bits to gobble.  Or the entry points to another table, with the number of
-bits to gobble implicit in the size of the table.
-
-Table X is two bits long since the longest code starting with 110 is five bits
-long:
-
-00: C,1
-01: C,1
-10: D,2
-11: E,2
-
-Table Y is three bits long since the longest code starting with 111 is six
-bits long:
-
-000: F,2
-001: F,2
-010: G,2
-011: G,2
-100: H,2
-101: H,2
-110: I,3
-111: J,3
-
-So what we have here are three tables with a total of 20 entries that had to
-be constructed.  That's compared to 64 entries for a single table.  Or
-compared to 16 entries for a Huffman tree (six two entry tables and one four
-entry table).  Assuming that the code ideally represents the probability of
-the symbols, it takes on the average 1.25 lookups per symbol.  That's compared
-to one lookup for the single table, or 1.66 lookups per symbol for the
-Huffman tree.
-
-There, I think that gives you a picture of what's going on.  For inflate, the
-meaning of a particular symbol is often more than just a letter.  It can be a
-byte (a "literal"), or it can be either a length or a distance which
-indicates a base value and a number of bits to fetch after the code that is
-added to the base value.  Or it might be the special end-of-block code.  The
-data structures created in inftrees.c try to encode all that information
-compactly in the tables.
-
-
-Jean-loup Gailly        Mark Adler
-jloup@gzip.org          madler@alumni.caltech.edu
-
-
-References:
-
-[LZ77] Ziv J., Lempel A., ``A Universal Algorithm for Sequential Data
-Compression,'' IEEE Transactions on Information Theory, Vol. 23, No. 3,
-pp. 337-343.
-
-``DEFLATE Compressed Data Format Specification'' available in
-http://www.ietf.org/rfc/rfc1951.txt
diff -Nbaur gcc-4.6.3/zlib/amiga/Makefile.pup gcc-4.6.3-psp/zlib/amiga/Makefile.pup
--- gcc-4.6.3/zlib/amiga/Makefile.pup	2004-10-11 19:45:43.000000000 +0100
+++ gcc-4.6.3-psp/zlib/amiga/Makefile.pup	1970-01-01 01:00:00.000000000 +0100
@@ -1,66 +0,0 @@
-# Amiga powerUP (TM) Makefile
-# makefile for libpng and SAS C V6.58/7.00 PPC compiler
-# Copyright (C) 1998 by Andreas R. Kleinert
-
-LIBNAME	= libzip.a
-
-CC	= scppc
-CFLAGS	= NOSTKCHK NOSINT OPTIMIZE OPTGO OPTPEEP OPTINLOCAL OPTINL \
-	  OPTLOOP OPTRDEP=8 OPTDEP=8 OPTCOMP=8 NOVER
-AR	= ppc-amigaos-ar cr
-RANLIB	= ppc-amigaos-ranlib
-LD	= ppc-amigaos-ld -r
-LDFLAGS	= -o
-LDLIBS	= LIB:scppc.a LIB:end.o
-RM	= delete quiet
-
-OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \
-       zutil.o inflate.o infback.o inftrees.o inffast.o
-
-TEST_OBJS = example.o minigzip.o
-
-all: example minigzip
-
-check: test
-test: all
-	example
-	echo hello world | minigzip | minigzip -d
-
-$(LIBNAME): $(OBJS)
-	$(AR) $@ $(OBJS)
-	-$(RANLIB) $@
-
-example: example.o $(LIBNAME)
-	$(LD) $(LDFLAGS) $@ LIB:c_ppc.o $@.o $(LIBNAME) $(LDLIBS)
-
-minigzip: minigzip.o $(LIBNAME)
-	$(LD) $(LDFLAGS) $@ LIB:c_ppc.o $@.o $(LIBNAME) $(LDLIBS)
-
-mostlyclean: clean
-clean:
-	$(RM) *.o example minigzip $(LIBNAME) foo.gz
-
-zip:
-	zip -ul9 zlib README ChangeLog Makefile Make????.??? Makefile.?? \
-	  descrip.mms *.[ch]
-
-tgz:
-	cd ..; tar cfz zlib/zlib.tgz zlib/README zlib/ChangeLog zlib/Makefile \
-	  zlib/Make????.??? zlib/Makefile.?? zlib/descrip.mms zlib/*.[ch]
-
-# DO NOT DELETE THIS LINE -- make depend depends on it.
-
-adler32.o: zlib.h zconf.h
-compress.o: zlib.h zconf.h
-crc32.o: crc32.h zlib.h zconf.h
-deflate.o: deflate.h zutil.h zlib.h zconf.h
-example.o: zlib.h zconf.h
-gzio.o: zutil.h zlib.h zconf.h
-inffast.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-inflate.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-infback.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-inftrees.o: zutil.h zlib.h zconf.h inftrees.h
-minigzip.o: zlib.h zconf.h
-trees.o: deflate.h zutil.h zlib.h zconf.h trees.h
-uncompr.o: zlib.h zconf.h
-zutil.o: zutil.h zlib.h zconf.h
diff -Nbaur gcc-4.6.3/zlib/amiga/Makefile.sas gcc-4.6.3-psp/zlib/amiga/Makefile.sas
--- gcc-4.6.3/zlib/amiga/Makefile.sas	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/amiga/Makefile.sas	1970-01-01 01:00:00.000000000 +0100
@@ -1,65 +0,0 @@
-# SMakefile for zlib
-# Modified from the standard UNIX Makefile Copyright Jean-loup Gailly
-# Osma Ahvenlampi <Osma.Ahvenlampi@hut.fi>
-# Amiga, SAS/C 6.56 & Smake
-
-CC=sc
-CFLAGS=OPT
-#CFLAGS=OPT CPU=68030
-#CFLAGS=DEBUG=LINE
-LDFLAGS=LIB z.lib
-
-SCOPTIONS=OPTSCHED OPTINLINE OPTALIAS OPTTIME OPTINLOCAL STRMERGE \
-       NOICONS PARMS=BOTH NOSTACKCHECK UTILLIB NOVERSION ERRORREXX \
-       DEF=POSTINC
-
-OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \
-       zutil.o inflate.o infback.o inftrees.o inffast.o
-
-TEST_OBJS = example.o minigzip.o
-
-all: SCOPTIONS example minigzip
-
-check: test
-test: all
-	example
-	echo hello world | minigzip | minigzip -d
-
-install: z.lib
-	copy clone zlib.h zconf.h INCLUDE:
-	copy clone z.lib LIB:
-
-z.lib: $(OBJS)
-	oml z.lib r $(OBJS)
-
-example: example.o z.lib
-	$(CC) $(CFLAGS) LINK TO $@ example.o $(LDFLAGS)
-
-minigzip: minigzip.o z.lib
-	$(CC) $(CFLAGS) LINK TO $@ minigzip.o $(LDFLAGS)
-
-mostlyclean: clean
-clean:
-	-delete force quiet example minigzip *.o z.lib foo.gz *.lnk SCOPTIONS
-
-SCOPTIONS: Makefile.sas
-	copy to $@ <from <
-$(SCOPTIONS)
-<
-
-# DO NOT DELETE THIS LINE -- make depend depends on it.
-
-adler32.o: zlib.h zconf.h
-compress.o: zlib.h zconf.h
-crc32.o: crc32.h zlib.h zconf.h
-deflate.o: deflate.h zutil.h zlib.h zconf.h
-example.o: zlib.h zconf.h
-gzio.o: zutil.h zlib.h zconf.h
-inffast.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-inflate.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-infback.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-inftrees.o: zutil.h zlib.h zconf.h inftrees.h
-minigzip.o: zlib.h zconf.h
-trees.o: deflate.h zutil.h zlib.h zconf.h trees.h
-uncompr.o: zlib.h zconf.h
-zutil.o: zutil.h zlib.h zconf.h
diff -Nbaur gcc-4.6.3/zlib/as400/bndsrc gcc-4.6.3-psp/zlib/as400/bndsrc
--- gcc-4.6.3/zlib/as400/bndsrc	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/as400/bndsrc	1970-01-01 01:00:00.000000000 +0100
@@ -1,132 +0,0 @@
-STRPGMEXP PGMLVL(*CURRENT) SIGNATURE('ZLIB')
-
-/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
-/*   Version 1.1.3 entry points.                                    */
-/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
-
-/********************************************************************/
-/*   *MODULE      ADLER32      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("adler32")
-
-/********************************************************************/
-/*   *MODULE      COMPRESS     ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("compress")
-  EXPORT SYMBOL("compress2")
-
-/********************************************************************/
-/*   *MODULE      CRC32        ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("crc32")
-  EXPORT SYMBOL("get_crc_table")
-
-/********************************************************************/
-/*   *MODULE      DEFLATE      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("deflate")
-  EXPORT SYMBOL("deflateEnd")
-  EXPORT SYMBOL("deflateSetDictionary")
-  EXPORT SYMBOL("deflateCopy")
-  EXPORT SYMBOL("deflateReset")
-  EXPORT SYMBOL("deflateParams")
-  EXPORT SYMBOL("deflatePrime")
-  EXPORT SYMBOL("deflateInit_")
-  EXPORT SYMBOL("deflateInit2_")
-
-/********************************************************************/
-/*   *MODULE      GZIO         ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("gzopen")
-  EXPORT SYMBOL("gzdopen")
-  EXPORT SYMBOL("gzsetparams")
-  EXPORT SYMBOL("gzread")
-  EXPORT SYMBOL("gzwrite")
-  EXPORT SYMBOL("gzprintf")
-  EXPORT SYMBOL("gzputs")
-  EXPORT SYMBOL("gzgets")
-  EXPORT SYMBOL("gzputc")
-  EXPORT SYMBOL("gzgetc")
-  EXPORT SYMBOL("gzflush")
-  EXPORT SYMBOL("gzseek")
-  EXPORT SYMBOL("gzrewind")
-  EXPORT SYMBOL("gztell")
-  EXPORT SYMBOL("gzeof")
-  EXPORT SYMBOL("gzclose")
-  EXPORT SYMBOL("gzerror")
-
-/********************************************************************/
-/*   *MODULE      INFLATE      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("inflate")
-  EXPORT SYMBOL("inflateEnd")
-  EXPORT SYMBOL("inflateSetDictionary")
-  EXPORT SYMBOL("inflateSync")
-  EXPORT SYMBOL("inflateReset")
-  EXPORT SYMBOL("inflateInit_")
-  EXPORT SYMBOL("inflateInit2_")
-  EXPORT SYMBOL("inflateSyncPoint")
-
-/********************************************************************/
-/*   *MODULE      UNCOMPR      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("uncompress")
-
-/********************************************************************/
-/*   *MODULE      ZUTIL        ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("zlibVersion")
-  EXPORT SYMBOL("zError")
-
-/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
-/*   Version 1.2.1 additional entry points.                         */
-/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/
-
-/********************************************************************/
-/*   *MODULE      COMPRESS     ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("compressBound")
-
-/********************************************************************/
-/*   *MODULE      DEFLATE      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("deflateBound")
-
-/********************************************************************/
-/*   *MODULE      GZIO         ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("gzungetc")
-  EXPORT SYMBOL("gzclearerr")
-
-/********************************************************************/
-/*   *MODULE      INFBACK      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("inflateBack")
-  EXPORT SYMBOL("inflateBackEnd")
-  EXPORT SYMBOL("inflateBackInit_")
-
-/********************************************************************/
-/*   *MODULE      INFLATE      ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("inflateCopy")
-
-/********************************************************************/
-/*   *MODULE      ZUTIL        ZLIB         01/02/01  00:15:09      */
-/********************************************************************/
-
-  EXPORT SYMBOL("zlibCompileFlags")
-
-ENDPGMEXP
diff -Nbaur gcc-4.6.3/zlib/as400/compile.clp gcc-4.6.3-psp/zlib/as400/compile.clp
--- gcc-4.6.3/zlib/as400/compile.clp	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/as400/compile.clp	1970-01-01 01:00:00.000000000 +0100
@@ -1,123 +0,0 @@
-/******************************************************************************/
-/*                                                                            */
-/*  ZLIB                                                                      */
-/*                                                                            */
-/*    Compile sources into modules and link them into a service program.      */
-/*                                                                            */
-/******************************************************************************/
-
-             PGM
-
-/*      Configuration adjustable parameters.                                  */
-
-             DCL        VAR(&SRCLIB) TYPE(*CHAR) LEN(10) +
-                          VALUE('ZLIB')                         /* Source library. */
-             DCL        VAR(&SRCFILE) TYPE(*CHAR) LEN(10) +
-                          VALUE('SOURCES')                      /* Source member file. */
-             DCL        VAR(&CTLFILE) TYPE(*CHAR) LEN(10) +
-                          VALUE('TOOLS')                        /* Control member file. */
-
-             DCL        VAR(&MODLIB) TYPE(*CHAR) LEN(10) +
-                          VALUE('ZLIB')                         /* Module library. */
-
-             DCL        VAR(&SRVLIB) TYPE(*CHAR) LEN(10) +
-                          VALUE('LGPL')                         /* Service program library. */
-
-             DCL        VAR(&CFLAGS) TYPE(*CHAR) +
-                          VALUE('OPTIMIZE(40)')                 /* Compile options. */
-
-
-/*      Working storage.                                                      */
-
-             DCL        VAR(&CMDLEN) TYPE(*DEC) LEN(15 5) VALUE(300)    /* Command length. */
-             DCL        VAR(&CMD) TYPE(*CHAR) LEN(512)
-
-
-/*      Compile sources into modules.                                         */
-
-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +
-                        '/ADLER32)               SRCFILE(' *TCAT               +
-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +
-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +
-                        '/COMPRESS)              SRCFILE(' *TCAT               +
-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +
-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +
-                        '/CRC32)                 SRCFILE(' *TCAT               +
-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +
-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +
-                        '/DEFLATE)               SRCFILE(' *TCAT               +
-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +
-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +
-                        '/GZIO)                  SRCFILE(' *TCAT               +
-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +
-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +
-                        '/INFBACK)               SRCFILE(' *TCAT               +
-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +
-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +
-                        '/INFFAST)               SRCFILE(' *TCAT               +
-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +
-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +
-                        '/INFLATE)               SRCFILE(' *TCAT               +
-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +
-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +
-                        '/INFTREES)              SRCFILE(' *TCAT               +
-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +
-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +
-                        '/TREES)                 SRCFILE(' *TCAT               +
-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +
-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +
-                        '/UNCOMPR)               SRCFILE(' *TCAT               +
-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +
-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-             CHGVAR     VAR(&CMD) VALUE('CRTCMOD MODULE(' *TCAT &MODLIB *TCAT  +
-                        '/ZUTIL)                 SRCFILE(' *TCAT               +
-                        &SRCLIB *TCAT '/' *TCAT &SRCFILE *TCAT                 +
-                        ') SYSIFCOPT(*IFSIO)' *BCAT &CFLAGS)
-             CALL       PGM(QCMDEXC) PARM(&CMD &CMDLEN)
-
-
-/*      Link modules into a service program.                                  */
-
-             CRTSRVPGM  SRVPGM(&SRVLIB/ZLIB) +
-                          MODULE(&MODLIB/ADLER32     &MODLIB/COMPRESS    +
-                                 &MODLIB/CRC32       &MODLIB/DEFLATE     +
-                                 &MODLIB/GZIO        &MODLIB/INFBACK     +
-                                 &MODLIB/INFFAST     &MODLIB/INFLATE     +
-                                 &MODLIB/INFTREES    &MODLIB/TREES       +
-                                 &MODLIB/UNCOMPR     &MODLIB/ZUTIL)      +
-                          SRCFILE(&SRCLIB/&CTLFILE) SRCMBR(BNDSRC) +
-                          TEXT('ZLIB 1.2.3') TGTRLS(V4R4M0)
-
-             ENDPGM
diff -Nbaur gcc-4.6.3/zlib/as400/readme.txt gcc-4.6.3-psp/zlib/as400/readme.txt
--- gcc-4.6.3/zlib/as400/readme.txt	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/as400/readme.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,111 +0,0 @@
-        ZLIB version 1.2.3 for AS400 installation instructions
-
-I) From an AS400 *SAVF file:
-
-1)      Unpacking archive to an AS400 save file
-
-On the AS400:
-
-_       Create the ZLIB AS400 library:
-
-        CRTLIB LIB(ZLIB) TYPE(PROD) TEXT('ZLIB compression API library')
-
-_       Create a work save file, for example:
-
-                CRTSAVF FILE(ZLIB/ZLIBSAVF)
-
-On a PC connected to the target AS400:
-
-_       Unpack the save file image to a PC file "ZLIBSAVF"
-_       Upload this file into the save file on the AS400, for example
-                using ftp in BINARY mode.
-
-
-2)      Populating the ZLIB AS400 source library
-
-On the AS400:
-
-_       Extract the saved objects into the ZLIB AS400 library using:
-
-RSTOBJ OBJ(*ALL) SAVLIB(ZLIB) DEV(*SAVF) SAVF(ZLIB/ZLIBSAVF) RSTLIB(ZLIB)
-
-
-3)      Customize installation:
-
-_       Edit CL member ZLIB/TOOLS(COMPILE) and change parameters if needed,
-                according to the comments.
-
-_       Compile this member with:
-
-        CRTCLPGM PGM(ZLIB/COMPILE) SRCFILE(ZLIB/TOOLS) SRCMBR(COMPILE)
-
-
-4)      Compile and generate the service program:
-
-_       This can now be done by executing:
-
-        CALL PGM(ZLIB/COMPILE)
-
-
-
-II) From the original source distribution:
-
-1)      On the AS400, create the source library:
-
-        CRTLIB LIB(ZLIB) TYPE(PROD) TEXT('ZLIB compression API library')
-
-2)      Create the source files:
-
-        CRTSRCPF FILE(ZLIB/SOURCES) RCDLEN(112) TEXT('ZLIB library modules')
-        CRTSRCPF FILE(ZLIB/H)       RCDLEN(112) TEXT('ZLIB library includes')
-        CRTSRCPF FILE(ZLIB/TOOLS)   RCDLEN(112) TEXT('ZLIB library control utilities')
-
-3)      From the machine hosting the distribution files, upload them (with
-                FTP in text mode, for example) according to the following table:
-
-    Original    AS400   AS400    AS400 AS400
-    file        file    member   type  description
-                SOURCES                Original ZLIB C subprogram sources
-    adler32.c           ADLER32  C     ZLIB - Compute the Adler-32 checksum of a dta strm
-    compress.c          COMPRESS C     ZLIB - Compress a memory buffer
-    crc32.c             CRC32    C     ZLIB - Compute the CRC-32 of a data stream
-    deflate.c           DEFLATE  C     ZLIB - Compress data using the deflation algorithm
-    gzio.c              GZIO     C     ZLIB - IO on .gz files
-    infback.c           INFBACK  C     ZLIB - Inflate using a callback interface
-    inffast.c           INFFAST  C     ZLIB - Fast proc. literals & length/distance pairs
-    inflate.c           INFLATE  C     ZLIB - Interface to inflate modules
-    inftrees.c          INFTREES C     ZLIB - Generate Huffman trees for efficient decode
-    trees.c             TREES    C     ZLIB - Output deflated data using Huffman coding
-    uncompr.c           UNCOMPR  C     ZLIB - Decompress a memory buffer
-    zutil.c             ZUTIL    C     ZLIB - Target dependent utility functions
-                H                      Original ZLIB C and ILE/RPG include files
-    crc32.h             CRC32    C     ZLIB - CRC32 tables
-    deflate.h           DEFLATE  C     ZLIB - Internal compression state
-    inffast.h           INFFAST  C     ZLIB - Header to use inffast.c
-    inffixed.h          INFFIXED C     ZLIB - Table for decoding fixed codes
-    inflate.h           INFLATE  C     ZLIB - Internal inflate state definitions
-    inftrees.h          INFTREES C     ZLIB - Header to use inftrees.c
-    trees.h             TREES    C     ZLIB - Created automatically with -DGEN_TREES_H
-    zconf.h             ZCONF    C     ZLIB - Compression library configuration
-    zlib.h              ZLIB     C     ZLIB - Compression library C user interface
-    as400/zlib.inc      ZLIB.INC RPGLE ZLIB - Compression library ILE RPG user interface
-    zutil.h             ZUTIL    C     ZLIB - Internal interface and configuration
-                TOOLS                  Building source software & AS/400 README
-    as400/bndsrc        BNDSRC         Entry point exportation list
-    as400/compile.clp   COMPILE  CLP   Compile sources & generate service program
-    as400/readme.txt    README   TXT   Installation instructions
-
-4)      Continue as in I)3).
-
-
-
-
-Notes:  For AS400 ILE RPG programmers, a /copy member defining the ZLIB
-                API prototypes for ILE RPG can be found in ZLIB/H(ZLIB.INC).
-                Please read comments in this member for more information.
-
-        Remember that most foreign textual data are ASCII coded: this
-                implementation does not handle conversion from/to ASCII, so
-                text data code conversions must be done explicitely.
-
-        Always open zipped files in binary mode.
diff -Nbaur gcc-4.6.3/zlib/as400/zlib.inc gcc-4.6.3-psp/zlib/as400/zlib.inc
--- gcc-4.6.3/zlib/as400/zlib.inc	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/as400/zlib.inc	1970-01-01 01:00:00.000000000 +0100
@@ -1,331 +0,0 @@
-      *  ZLIB.INC - Interface to the general purpose compression library
-      *
-      *  ILE RPG400 version by Patrick Monnerat, DATASPHERE.
-      *  Version 1.2.3
-      *
-      *
-      *  WARNING:
-      *     Procedures inflateInit(), inflateInit2(), deflateInit(),
-      *         deflateInit2() and inflateBackInit() need to be called with
-      *         two additional arguments:
-      *         the package version string and the stream control structure.
-      *         size. This is needed because RPG lacks some macro feature.
-      *         Call these procedures as:
-      *             inflateInit(...: ZLIB_VERSION: %size(z_stream))
-      *
-      /if not defined(ZLIB_H_)
-      /define ZLIB_H_
-      *
-      **************************************************************************
-      *                               Constants
-      **************************************************************************
-      *
-      *  Versioning information.
-      *
-     D ZLIB_VERSION    C                   '1.2.3'
-     D ZLIB_VERNUM     C                   X'1230'
-      *
-      *  Other equates.
-      *
-     D Z_NO_FLUSH      C                   0
-     D Z_SYNC_FLUSH    C                   2
-     D Z_FULL_FLUSH    C                   3
-     D Z_FINISH        C                   4
-     D Z_BLOCK         C                   5
-      *
-     D Z_OK            C                   0
-     D Z_STREAM_END    C                   1
-     D Z_NEED_DICT     C                   2
-     D Z_ERRNO         C                   -1
-     D Z_STREAM_ERROR  C                   -2
-     D Z_DATA_ERROR    C                   -3
-     D Z_MEM_ERROR     C                   -4
-     D Z_BUF_ERROR     C                   -5
-     DZ_VERSION_ERROR  C                   -6
-      *
-     D Z_NO_COMPRESSION...
-     D                 C                   0
-     D Z_BEST_SPEED    C                   1
-     D Z_BEST_COMPRESSION...
-     D                 C                   9
-     D Z_DEFAULT_COMPRESSION...
-     D                 C                   -1
-      *
-     D Z_FILTERED      C                   1
-     D Z_HUFFMAN_ONLY  C                   2
-     D Z_RLE           C                   3
-     D Z_DEFAULT_STRATEGY...
-     D                 C                   0
-      *
-     D Z_BINARY        C                   0
-     D Z_ASCII         C                   1
-     D Z_UNKNOWN       C                   2
-      *
-     D Z_DEFLATED      C                   8
-      *
-     D Z_NULL          C                   0
-      *
-      **************************************************************************
-      *                                 Types
-      **************************************************************************
-      *
-     D z_streamp       S               *                                        Stream struct ptr
-     D gzFile          S               *                                        File pointer
-     D z_off_t         S             10i 0                                      Stream offsets
-      *
-      **************************************************************************
-      *                               Structures
-      **************************************************************************
-      *
-      *  The GZIP encode/decode stream support structure.
-      *
-     D z_stream        DS                  align based(z_streamp)
-     D  zs_next_in                     *                                        Next input byte
-     D  zs_avail_in                  10U 0                                      Byte cnt at next_in
-     D  zs_total_in                  10U 0                                      Total bytes read
-     D  zs_next_out                    *                                        Output buffer ptr
-     D  zs_avail_out                 10U 0                                      Room left @ next_out
-     D  zs_total_out                 10U 0                                      Total bytes written
-     D  zs_msg                         *                                        Last errmsg or null
-     D  zs_state                       *                                        Internal state
-     D  zs_zalloc                      *   procptr                              Int. state allocator
-     D  zs_free                        *   procptr                              Int. state dealloc.
-     D  zs_opaque                      *                                        Private alloc. data
-     D  zs_data_type                 10i 0                                      ASC/BIN best guess
-     D  zs_adler                     10u 0                                      Uncompr. adler32 val
-     D                               10U 0                                      Reserved
-     D                               10U 0                                      Ptr. alignment
-      *
-      **************************************************************************
-      *                     Utility function prototypes
-      **************************************************************************
-      *
-     D compress        PR            10I 0 extproc('compress')
-     D  dest                      32767    options(*varsize)                    Destination buffer
-     D  destLen                      10U 0                                      Destination length
-     D  source                    32767    const options(*varsize)              Source buffer
-     D  sourceLen                    10u 0 value                                Source length
-      *
-     D compress2       PR            10I 0 extproc('compress2')
-     D  dest                      32767    options(*varsize)                    Destination buffer
-     D  destLen                      10U 0                                      Destination length
-     D  source                    32767    const options(*varsize)              Source buffer
-     D  sourceLen                    10U 0 value                                Source length
-     D  level                        10I 0 value                                Compression level
-      *
-     D compressBound   PR            10U 0 extproc('compressBound')
-     D  sourceLen                    10U 0 value
-      *
-     D uncompress      PR            10I 0 extproc('uncompress')
-     D  dest                      32767    options(*varsize)                    Destination buffer
-     D  destLen                      10U 0                                      Destination length
-     D  source                    32767    const options(*varsize)              Source buffer
-     D  sourceLen                    10U 0 value                                Source length
-      *
-     D gzopen          PR                  extproc('gzopen')
-     D                                     like(gzFile)
-     D  path                           *   value options(*string)               File pathname
-     D  mode                           *   value options(*string)               Open mode
-      *
-     D gzdopen         PR                  extproc('gzdopen')
-     D                                     like(gzFile)
-     D  fd                           10i 0 value                                File descriptor
-     D  mode                           *   value options(*string)               Open mode
-      *
-     D gzsetparams     PR            10I 0 extproc('gzsetparams')
-     D  file                               value like(gzFile)                   File pointer
-     D  level                        10I 0 value
-     D  strategy                     10i 0 value
-      *
-     D gzread          PR            10I 0 extproc('gzread')
-     D  file                               value like(gzFile)                   File pointer
-     D  buf                       32767    options(*varsize)                    Buffer
-     D  len                          10u 0 value                                Buffer length
-      *
-     D gzwrite         PR            10I 0 extproc('gzwrite')
-     D  file                               value like(gzFile)                   File pointer
-     D  buf                       32767    const options(*varsize)              Buffer
-     D  len                          10u 0 value                                Buffer length
-      *
-     D gzputs          PR            10I 0 extproc('gzputs')
-     D  file                               value like(gzFile)                   File pointer
-     D  s                              *   value options(*string)               String to output
-      *
-     D gzgets          PR              *   extproc('gzgets')
-     D  file                               value like(gzFile)                   File pointer
-     D  buf                       32767    options(*varsize)                    Read buffer
-     D  len                          10i 0 value                                Buffer length
-      *
-     D gzflush         PR            10i 0 extproc('gzflush')
-     D  file                               value like(gzFile)                   File pointer
-     D  flush                        10I 0 value                                Type of flush
-      *
-     D gzseek          PR                  extproc('gzseek')
-     D                                     like(z_off_t)
-     D  file                               value like(gzFile)                   File pointer
-     D  offset                             value like(z_off_t)                  Offset
-     D  whence                       10i 0 value                                Origin
-      *
-     D gzrewind        PR            10i 0 extproc('gzrewind')
-     D  file                               value like(gzFile)                   File pointer
-      *
-     D gztell          PR                  extproc('gztell')
-     D                                     like(z_off_t)
-     D  file                               value like(gzFile)                   File pointer
-      *
-     D gzeof           PR            10i 0 extproc('gzeof')
-     D  file                               value like(gzFile)                   File pointer
-      *
-     D gzclose         PR            10i 0 extproc('gzclose')
-     D  file                               value like(gzFile)                   File pointer
-      *
-     D gzerror         PR              *   extproc('gzerror')                   Error string
-     D  file                               value like(gzFile)                   File pointer
-     D  errnum                       10I 0                                      Error code
-      *
-     D gzclearerr      PR                  extproc('gzclearerr')
-     D  file                               value like(gzFile)                   File pointer
-      *
-      **************************************************************************
-      *                        Basic function prototypes
-      **************************************************************************
-      *
-     D zlibVersion     PR              *   extproc('zlibVersion')               Version string
-      *
-     D deflateInit     PR            10I 0 extproc('deflateInit_')              Init. compression
-     D  strm                               like(z_stream)                       Compression stream
-     D  level                        10I 0 value                                Compression level
-     D  version                        *   value options(*string)               Version string
-     D  stream_size                  10i 0 value                                Stream struct. size
-      *
-     D deflate         PR            10I 0 extproc('deflate')                   Compress data
-     D  strm                               like(z_stream)                       Compression stream
-     D  flush                        10I 0 value                                Flush type required
-      *
-     D deflateEnd      PR            10I 0 extproc('deflateEnd')                Termin. compression
-     D  strm                               like(z_stream)                       Compression stream
-      *
-     D inflateInit     PR            10I 0 extproc('inflateInit_')              Init. expansion
-     D  strm                               like(z_stream)                       Expansion stream
-     D  version                        *   value options(*string)               Version string
-     D  stream_size                  10i 0 value                                Stream struct. size
-      *
-     D inflate         PR            10I 0 extproc('inflate')                   Expand data
-     D  strm                               like(z_stream)                       Expansion stream
-     D  flush                        10I 0 value                                Flush type required
-      *
-     D inflateEnd      PR            10I 0 extproc('inflateEnd')                Termin. expansion
-     D  strm                               like(z_stream)                       Expansion stream
-      *
-      **************************************************************************
-      *                        Advanced function prototypes
-      **************************************************************************
-      *
-     D deflateInit2    PR            10I 0 extproc('deflateInit2_')             Init. compression
-     D  strm                               like(z_stream)                       Compression stream
-     D  level                        10I 0 value                                Compression level
-     D  method                       10I 0 value                                Compression method
-     D  windowBits                   10I 0 value                                log2(window size)
-     D  memLevel                     10I 0 value                                Mem/cmpress tradeoff
-     D  strategy                     10I 0 value                                Compression stategy
-     D  version                        *   value options(*string)               Version string
-     D  stream_size                  10i 0 value                                Stream struct. size
-      *
-     D deflateSetDictionary...
-     D                 PR            10I 0 extproc('deflateSetDictionary')      Init. dictionary
-     D  strm                               like(z_stream)                       Compression stream
-     D  dictionary                32767    const options(*varsize)              Dictionary bytes
-     D  dictLength                   10U 0 value                                Dictionary length
-      *
-     D deflateCopy     PR            10I 0 extproc('deflateCopy')               Compress strm 2 strm
-     D  dest                               like(z_stream)                       Destination stream
-     D  source                             like(z_stream)                       Source stream
-      *
-     D deflateReset    PR            10I 0 extproc('deflateReset')              End and init. stream
-     D  strm                               like(z_stream)                       Compression stream
-      *
-     D deflateParams   PR            10I 0 extproc('deflateParams')             Change level & strat
-     D  strm                               like(z_stream)                       Compression stream
-     D  level                        10I 0 value                                Compression level
-     D  strategy                     10I 0 value                                Compression stategy
-      *
-     D deflateBound    PR            10U 0 extproc('deflateBound')              Change level & strat
-     D  strm                               like(z_stream)                       Compression stream
-     D  sourcelen                    10U 0 value                                Compression level
-      *
-     D deflatePrime    PR            10I 0 extproc('deflatePrime')              Change level & strat
-     D  strm                               like(z_stream)                       Compression stream
-     D  bits                         10I 0 value                                Number of bits to insert
-     D  value                        10I 0 value                                Bits to insert
-      *
-     D inflateInit2    PR            10I 0 extproc('inflateInit2_')             Init. expansion
-     D  strm                               like(z_stream)                       Expansion stream
-     D  windowBits                   10I 0 value                                log2(window size)
-     D  version                        *   value options(*string)               Version string
-     D  stream_size                  10i 0 value                                Stream struct. size
-      *
-     D inflateSetDictionary...
-     D                 PR            10I 0 extproc('inflateSetDictionary')      Init. dictionary
-     D  strm                               like(z_stream)                       Expansion stream
-     D  dictionary                32767    const options(*varsize)              Dictionary bytes
-     D  dictLength                   10U 0 value                                Dictionary length
-      *
-     D inflateSync     PR            10I 0 extproc('inflateSync')               Sync. expansion
-     D  strm                               like(z_stream)                       Expansion stream
-      *
-     D inflateCopy     PR            10I 0 extproc('inflateCopy')
-     D  dest                               like(z_stream)                       Destination stream
-     D  source                             like(z_stream)                       Source stream
-      *
-     D inflateReset    PR            10I 0 extproc('inflateReset')              End and init. stream
-     D  strm                               like(z_stream)                       Expansion stream
-      *
-     D inflateBackInit...
-     D                 PR            10I 0 extproc('inflateBackInit_')
-     D  strm                               like(z_stream)                       Expansion stream
-     D  windowBits                   10I 0 value                                Log2(buffer size)
-     D  window                    32767    options(*varsize)                    Buffer
-     D  version                        *   value options(*string)               Version string
-     D  stream_size                  10i 0 value                                Stream struct. size
-      *
-     D inflateBack     PR            10I 0 extproc('inflateBack')
-     D  strm                               like(z_stream)                       Expansion stream
-     D  in                             *   value procptr                        Input function
-     D  in_desc                        *   value                                Input descriptor
-     D  out                            *   value procptr                        Output function
-     D  out_desc                       *   value                                Output descriptor
-      *
-     D inflateBackEnd  PR            10I 0 extproc('inflateBackEnd')
-     D  strm                               like(z_stream)                       Expansion stream
-      *
-     D zlibCompileFlags...
-     D                 PR            10U 0 extproc('zlibCompileFlags')
-      *
-      **************************************************************************
-      *                        Checksum function prototypes
-      **************************************************************************
-      *
-     D adler32         PR            10U 0 extproc('adler32')                   New checksum
-     D  adler                        10U 0 value                                Old checksum
-     D  buf                       32767    const options(*varsize)              Bytes to accumulate
-     D  len                          10U 0 value                                Buffer length
-      *
-     D crc32           PR            10U 0 extproc('crc32')                     New checksum
-     D  crc                          10U 0 value                                Old checksum
-     D  buf                       32767    const options(*varsize)              Bytes to accumulate
-     D  len                          10U 0 value                                Buffer length
-      *
-      **************************************************************************
-      *                     Miscellaneous function prototypes
-      **************************************************************************
-      *
-     D zError          PR              *   extproc('zError')                    Error string
-     D  err                          10I 0 value                                Error code
-      *
-     D inflateSyncPoint...
-     D                 PR            10I 0 extproc('inflateSyncPoint')
-     D  strm                               like(z_stream)                       Expansion stream
-      *
-     D get_crc_table   PR              *   extproc('get_crc_table')             Ptr to ulongs
-      *
-      /endif
diff -Nbaur gcc-4.6.3/zlib/ChangeLog gcc-4.6.3-psp/zlib/ChangeLog
--- gcc-4.6.3/zlib/ChangeLog	2012-03-01 11:53:21.000000000 +0000
+++ gcc-4.6.3-psp/zlib/ChangeLog	1970-01-01 01:00:00.000000000 +0100
@@ -1,875 +0,0 @@
-2012-03-01  Release Manager
-
-	* GCC 4.6.3 released.
-
-2011-11-20  Andreas Tobler  <andreast@fgznet.ch>
-
-	* configure: Regenerate.
-
-2011-10-26  Release Manager
-
-	* GCC 4.6.2 released.
-
-2011-06-27  Release Manager
-
-	* GCC 4.6.1 released.
-
-2011-03-25  Release Manager
-
-	* GCC 4.6.0 released.
-
-
-                ChangeLog file for zlib
-
-Changes in 1.2.3 (18 July 2005)
-- Apply security vulnerability fixes to contrib/infback9 as well
-- Clean up some text files (carriage returns, trailing space)
-- Update testzlib, vstudio, masmx64, and masmx86 in contrib [Vollant]
-
-Changes in 1.2.2.4 (11 July 2005)
-- Add inflatePrime() function for starting inflation at bit boundary
-- Avoid some Visual C warnings in deflate.c
-- Avoid more silly Visual C warnings in inflate.c and inftrees.c for 64-bit
-  compile
-- Fix some spelling errors in comments [Betts]
-- Correct inflateInit2() error return documentation in zlib.h
-- Added zran.c example of compressed data random access to examples
-  directory, shows use of inflatePrime()
-- Fix cast for assignments to strm->state in inflate.c and infback.c
-- Fix zlibCompileFlags() in zutil.c to use 1L for long shifts [Oberhumer]
-- Move declarations of gf2 functions to right place in crc32.c [Oberhumer]
-- Add cast in trees.c t avoid a warning [Oberhumer]
-- Avoid some warnings in fitblk.c, gun.c, gzjoin.c in examples [Oberhumer]
-- Update make_vms.com [Zinser]
-- Initialize state->write in inflateReset() since copied in inflate_fast()
-- Be more strict on incomplete code sets in inflate_table() and increase
-  ENOUGH and MAXD -- this repairs a possible security vulnerability for
-  invalid inflate input.  Thanks to Tavis Ormandy and Markus Oberhumer for
-  discovering the vulnerability and providing test cases.
-- Add ia64 support to configure for HP-UX [Smith]
-- Add error return to gzread() for format or i/o error [Levin]
-- Use malloc.h for OS/2 [Necasek]
-
-Changes in 1.2.2.3 (27 May 2005)
-- Replace 1U constants in inflate.c and inftrees.c for 64-bit compile
-- Typecast fread() return values in gzio.c [Vollant]
-- Remove trailing space in minigzip.c outmode (VC++ can't deal with it)
-- Fix crc check bug in gzread() after gzungetc() [Heiner]
-- Add the deflateTune() function to adjust internal compression parameters
-- Add a fast gzip decompressor, gun.c, to examples (use of inflateBack)
-- Remove an incorrect assertion in examples/zpipe.c
-- Add C++ wrapper in infback9.h [Donais]
-- Fix bug in inflateCopy() when decoding fixed codes
-- Note in zlib.h how much deflateSetDictionary() actually uses
-- Remove USE_DICT_HEAD in deflate.c (would mess up inflate if used)
-- Add _WIN32_WCE to define WIN32 in zconf.in.h [Spencer]
-- Don't include stderr.h or errno.h for _WIN32_WCE in zutil.h [Spencer]
-- Add gzdirect() function to indicate transparent reads
-- Update contrib/minizip [Vollant]
-- Fix compilation of deflate.c when both ASMV and FASTEST [Oberhumer]
-- Add casts in crc32.c to avoid warnings [Oberhumer]
-- Add contrib/masmx64 [Vollant]
-- Update contrib/asm586, asm686, masmx86, testzlib, vstudio [Vollant]
-
-Changes in 1.2.2.2 (30 December 2004)
-- Replace structure assignments in deflate.c and inflate.c with zmemcpy to
-  avoid implicit memcpy calls (portability for no-library compilation)
-- Increase sprintf() buffer size in gzdopen() to allow for large numbers
-- Add INFLATE_STRICT to check distances against zlib header
-- Improve WinCE errno handling and comments [Chang]
-- Remove comment about no gzip header processing in FAQ
-- Add Z_FIXED strategy option to deflateInit2() to force fixed trees
-- Add updated make_vms.com [Coghlan], update README
-- Create a new "examples" directory, move gzappend.c there, add zpipe.c,
-  fitblk.c, gzlog.[ch], gzjoin.c, and zlib_how.html.
-- Add FAQ entry and comments in deflate.c on uninitialized memory access
-- Add Solaris 9 make options in configure [Gilbert]
-- Allow strerror() usage in gzio.c for STDC
-- Fix DecompressBuf in contrib/delphi/ZLib.pas [ManChesTer]
-- Update contrib/masmx86/inffas32.asm and gvmat32.asm [Vollant]
-- Use z_off_t for adler32_combine() and crc32_combine() lengths
-- Make adler32() much faster for small len
-- Use OS_CODE in deflate() default gzip header
-
-Changes in 1.2.2.1 (31 October 2004)
-- Allow inflateSetDictionary() call for raw inflate
-- Fix inflate header crc check bug for file names and comments
-- Add deflateSetHeader() and gz_header structure for custom gzip headers
-- Add inflateGetheader() to retrieve gzip headers
-- Add crc32_combine() and adler32_combine() functions
-- Add alloc_func, free_func, in_func, out_func to Z_PREFIX list
-- Use zstreamp consistently in zlib.h (inflate_back functions)
-- Remove GUNZIP condition from definition of inflate_mode in inflate.h
-  and in contrib/inflate86/inffast.S [Truta, Anderson]
-- Add support for AMD64 in contrib/inflate86/inffas86.c [Anderson]
-- Update projects/README.projects and projects/visualc6 [Truta]
-- Update win32/DLL_FAQ.txt [Truta]
-- Avoid warning under NO_GZCOMPRESS in gzio.c; fix typo [Truta]
-- Deprecate Z_ASCII; use Z_TEXT instead [Truta]
-- Use a new algorithm for setting strm->data_type in trees.c [Truta]
-- Do not define an exit() prototype in zutil.c unless DEBUG defined
-- Remove prototype of exit() from zutil.c, example.c, minigzip.c [Truta]
-- Add comment in zlib.h for Z_NO_FLUSH parameter to deflate()
-- Fix Darwin build version identification [Peterson]
-
-Changes in 1.2.2 (3 October 2004)
-- Update zlib.h comments on gzip in-memory processing
-- Set adler to 1 in inflateReset() to support Java test suite [Walles]
-- Add contrib/dotzlib [Ravn]
-- Update win32/DLL_FAQ.txt [Truta]
-- Update contrib/minizip [Vollant]
-- Move contrib/visual-basic.txt to old/ [Truta]
-- Fix assembler builds in projects/visualc6/ [Truta]
-
-Changes in 1.2.1.2 (9 September 2004)
-- Update INDEX file
-- Fix trees.c to update strm->data_type (no one ever noticed!)
-- Fix bug in error case in inflate.c, infback.c, and infback9.c [Brown]
-- Add "volatile" to crc table flag declaration (for DYNAMIC_CRC_TABLE)
-- Add limited multitasking protection to DYNAMIC_CRC_TABLE
-- Add NO_vsnprintf for VMS in zutil.h [Mozilla]
-- Don't declare strerror() under VMS [Mozilla]
-- Add comment to DYNAMIC_CRC_TABLE to use get_crc_table() to initialize
-- Update contrib/ada [Anisimkov]
-- Update contrib/minizip [Vollant]
-- Fix configure to not hardcode directories for Darwin [Peterson]
-- Fix gzio.c to not return error on empty files [Brown]
-- Fix indentation; update version in contrib/delphi/ZLib.pas and
-  contrib/pascal/zlibpas.pas [Truta]
-- Update mkasm.bat in contrib/masmx86 [Truta]
-- Update contrib/untgz [Truta]
-- Add projects/README.projects [Truta]
-- Add project for MS Visual C++ 6.0 in projects/visualc6 [Cadieux, Truta]
-- Update win32/DLL_FAQ.txt [Truta]
-- Update list of Z_PREFIX symbols in zconf.h [Randers-Pehrson, Truta]
-- Remove an unnecessary assignment to curr in inftrees.c [Truta]
-- Add OS/2 to exe builds in configure [Poltorak]
-- Remove err dummy parameter in zlib.h [Kientzle]
-
-Changes in 1.2.1.1 (9 January 2004)
-- Update email address in README
-- Several FAQ updates
-- Fix a big fat bug in inftrees.c that prevented decoding valid
-  dynamic blocks with only literals and no distance codes --
-  Thanks to "Hot Emu" for the bug report and sample file
-- Add a note to puff.c on no distance codes case.
-
-Changes in 1.2.1 (17 November 2003)
-- Remove a tab in contrib/gzappend/gzappend.c
-- Update some interfaces in contrib for new zlib functions
-- Update zlib version number in some contrib entries
-- Add Windows CE definition for ptrdiff_t in zutil.h [Mai, Truta]
-- Support shared libraries on Hurd and KFreeBSD [Brown]
-- Fix error in NO_DIVIDE option of adler32.c
-
-Changes in 1.2.0.8 (4 November 2003)
-- Update version in contrib/delphi/ZLib.pas and contrib/pascal/zlibpas.pas
-- Add experimental NO_DIVIDE #define in adler32.c
-    - Possibly faster on some processors (let me know if it is)
-- Correct Z_BLOCK to not return on first inflate call if no wrap
-- Fix strm->data_type on inflate() return to correctly indicate EOB
-- Add deflatePrime() function for appending in the middle of a byte
-- Add contrib/gzappend for an example of appending to a stream
-- Update win32/DLL_FAQ.txt [Truta]
-- Delete Turbo C comment in README [Truta]
-- Improve some indentation in zconf.h [Truta]
-- Fix infinite loop on bad input in configure script [Church]
-- Fix gzeof() for concatenated gzip files [Johnson]
-- Add example to contrib/visual-basic.txt [Michael B.]
-- Add -p to mkdir's in Makefile.in [vda]
-- Fix configure to properly detect presence or lack of printf functions
-- Add AS400 support [Monnerat]
-- Add a little Cygwin support [Wilson]
-
-Changes in 1.2.0.7 (21 September 2003)
-- Correct some debug formats in contrib/infback9
-- Cast a type in a debug statement in trees.c
-- Change search and replace delimiter in configure from % to # [Beebe]
-- Update contrib/untgz to 0.2 with various fixes [Truta]
-- Add build support for Amiga [Nikl]
-- Remove some directories in old that have been updated to 1.2
-- Add dylib building for Mac OS X in configure and Makefile.in
-- Remove old distribution stuff from Makefile
-- Update README to point to DLL_FAQ.txt, and add comment on Mac OS X
-- Update links in README
-
-Changes in 1.2.0.6 (13 September 2003)
-- Minor FAQ updates
-- Update contrib/minizip to 1.00 [Vollant]
-- Remove test of gz functions in example.c when GZ_COMPRESS defined [Truta]
-- Update POSTINC comment for 68060 [Nikl]
-- Add contrib/infback9 with deflate64 decoding (unsupported)
-- For MVS define NO_vsnprintf and undefine FAR [van Burik]
-- Add pragma for fdopen on MVS [van Burik]
-
-Changes in 1.2.0.5 (8 September 2003)
-- Add OF to inflateBackEnd() declaration in zlib.h
-- Remember start when using gzdopen in the middle of a file
-- Use internal off_t counters in gz* functions to properly handle seeks
-- Perform more rigorous check for distance-too-far in inffast.c
-- Add Z_BLOCK flush option to return from inflate at block boundary
-- Set strm->data_type on return from inflate
-    - Indicate bits unused, if at block boundary, and if in last block
-- Replace size_t with ptrdiff_t in crc32.c, and check for correct size
-- Add condition so old NO_DEFLATE define still works for compatibility
-- FAQ update regarding the Windows DLL [Truta]
-- INDEX update: add qnx entry, remove aix entry [Truta]
-- Install zlib.3 into mandir [Wilson]
-- Move contrib/zlib_dll_FAQ.txt to win32/DLL_FAQ.txt; update [Truta]
-- Adapt the zlib interface to the new DLL convention guidelines [Truta]
-- Introduce ZLIB_WINAPI macro to allow the export of functions using
-  the WINAPI calling convention, for Visual Basic [Vollant, Truta]
-- Update msdos and win32 scripts and makefiles [Truta]
-- Export symbols by name, not by ordinal, in win32/zlib.def [Truta]
-- Add contrib/ada [Anisimkov]
-- Move asm files from contrib/vstudio/vc70_32 to contrib/asm386 [Truta]
-- Rename contrib/asm386 to contrib/masmx86 [Truta, Vollant]
-- Add contrib/masm686 [Truta]
-- Fix offsets in contrib/inflate86 and contrib/masmx86/inffas32.asm
-  [Truta, Vollant]
-- Update contrib/delphi; rename to contrib/pascal; add example [Truta]
-- Remove contrib/delphi2; add a new contrib/delphi [Truta]
-- Avoid inclusion of the nonstandard <memory.h> in contrib/iostream,
-  and fix some method prototypes [Truta]
-- Fix the ZCR_SEED2 constant to avoid warnings in contrib/minizip
-  [Truta]
-- Avoid the use of backslash (\) in contrib/minizip [Vollant]
-- Fix file time handling in contrib/untgz; update makefiles [Truta]
-- Update contrib/vstudio/vc70_32 to comply with the new DLL guidelines
-  [Vollant]
-- Remove contrib/vstudio/vc15_16 [Vollant]
-- Rename contrib/vstudio/vc70_32 to contrib/vstudio/vc7 [Truta]
-- Update README.contrib [Truta]
-- Invert the assignment order of match_head and s->prev[...] in
-  INSERT_STRING [Truta]
-- Compare TOO_FAR with 32767 instead of 32768, to avoid 16-bit warnings
-  [Truta]
-- Compare function pointers with 0, not with NULL or Z_NULL [Truta]
-- Fix prototype of syncsearch in inflate.c [Truta]
-- Introduce ASMINF macro to be enabled when using an ASM implementation
-  of inflate_fast [Truta]
-- Change NO_DEFLATE to NO_GZCOMPRESS [Truta]
-- Modify test_gzio in example.c to take a single file name as a
-  parameter [Truta]
-- Exit the example.c program if gzopen fails [Truta]
-- Add type casts around strlen in example.c [Truta]
-- Remove casting to sizeof in minigzip.c; give a proper type
-  to the variable compared with SUFFIX_LEN [Truta]
-- Update definitions of STDC and STDC99 in zconf.h [Truta]
-- Synchronize zconf.h with the new Windows DLL interface [Truta]
-- Use SYS16BIT instead of __32BIT__ to distinguish between
-  16- and 32-bit platforms [Truta]
-- Use far memory allocators in small 16-bit memory models for
-  Turbo C [Truta]
-- Add info about the use of ASMV, ASMINF and ZLIB_WINAPI in
-  zlibCompileFlags [Truta]
-- Cygwin has vsnprintf [Wilson]
-- In Windows16, OS_CODE is 0, as in MSDOS [Truta]
-- In Cygwin, OS_CODE is 3 (Unix), not 11 (Windows32) [Wilson]
-
-Changes in 1.2.0.4 (10 August 2003)
-- Minor FAQ updates
-- Be more strict when checking inflateInit2's windowBits parameter
-- Change NO_GUNZIP compile option to NO_GZIP to cover deflate as well
-- Add gzip wrapper option to deflateInit2 using windowBits
-- Add updated QNX rule in configure and qnx directory [Bonnefoy]
-- Make inflate distance-too-far checks more rigorous
-- Clean up FAR usage in inflate
-- Add casting to sizeof() in gzio.c and minigzip.c
-
-Changes in 1.2.0.3 (19 July 2003)
-- Fix silly error in gzungetc() implementation [Vollant]
-- Update contrib/minizip and contrib/vstudio [Vollant]
-- Fix printf format in example.c
-- Correct cdecl support in zconf.in.h [Anisimkov]
-- Minor FAQ updates
-
-Changes in 1.2.0.2 (13 July 2003)
-- Add ZLIB_VERNUM in zlib.h for numerical preprocessor comparisons
-- Attempt to avoid warnings in crc32.c for pointer-int conversion
-- Add AIX to configure, remove aix directory [Bakker]
-- Add some casts to minigzip.c
-- Improve checking after insecure sprintf() or vsprintf() calls
-- Remove #elif's from crc32.c
-- Change leave label to inf_leave in inflate.c and infback.c to avoid
-  library conflicts
-- Remove inflate gzip decoding by default--only enable gzip decoding by
-  special request for stricter backward compatibility
-- Add zlibCompileFlags() function to return compilation information
-- More typecasting in deflate.c to avoid warnings
-- Remove leading underscore from _Capital #defines [Truta]
-- Fix configure to link shared library when testing
-- Add some Windows CE target adjustments [Mai]
-- Remove #define ZLIB_DLL in zconf.h [Vollant]
-- Add zlib.3 [Rodgers]
-- Update RFC URL in deflate.c and algorithm.txt [Mai]
-- Add zlib_dll_FAQ.txt to contrib [Truta]
-- Add UL to some constants [Truta]
-- Update minizip and vstudio [Vollant]
-- Remove vestigial NEED_DUMMY_RETURN from zconf.in.h
-- Expand use of NO_DUMMY_DECL to avoid all dummy structures
-- Added iostream3 to contrib [Schwardt]
-- Replace rewind() with fseek() for WinCE [Truta]
-- Improve setting of zlib format compression level flags
-    - Report 0 for huffman and rle strategies and for level == 0 or 1
-    - Report 2 only for level == 6
-- Only deal with 64K limit when necessary at compile time [Truta]
-- Allow TOO_FAR check to be turned off at compile time [Truta]
-- Add gzclearerr() function [Souza]
-- Add gzungetc() function
-
-Changes in 1.2.0.1 (17 March 2003)
-- Add Z_RLE strategy for run-length encoding [Truta]
-    - When Z_RLE requested, restrict matches to distance one
-    - Update zlib.h, minigzip.c, gzopen(), gzdopen() for Z_RLE
-- Correct FASTEST compilation to allow level == 0
-- Clean up what gets compiled for FASTEST
-- Incorporate changes to zconf.in.h [Vollant]
-    - Refine detection of Turbo C need for dummy returns
-    - Refine ZLIB_DLL compilation
-    - Include additional header file on VMS for off_t typedef
-- Try to use _vsnprintf where it supplants vsprintf [Vollant]
-- Add some casts in inffast.c
-- Enchance comments in zlib.h on what happens if gzprintf() tries to
-  write more than 4095 bytes before compression
-- Remove unused state from inflateBackEnd()
-- Remove exit(0) from minigzip.c, example.c
-- Get rid of all those darn tabs
-- Add "check" target to Makefile.in that does the same thing as "test"
-- Add "mostlyclean" and "maintainer-clean" targets to Makefile.in
-- Update contrib/inflate86 [Anderson]
-- Update contrib/testzlib, contrib/vstudio, contrib/minizip [Vollant]
-- Add msdos and win32 directories with makefiles [Truta]
-- More additions and improvements to the FAQ
-
-Changes in 1.2.0 (9 March 2003)
-- New and improved inflate code
-    - About 20% faster
-    - Does not allocate 32K window unless and until needed
-    - Automatically detects and decompresses gzip streams
-    - Raw inflate no longer needs an extra dummy byte at end
-    - Added inflateBack functions using a callback interface--even faster
-      than inflate, useful for file utilities (gzip, zip)
-    - Added inflateCopy() function to record state for random access on
-      externally generated deflate streams (e.g. in gzip files)
-    - More readable code (I hope)
-- New and improved crc32()
-    - About 50% faster, thanks to suggestions from Rodney Brown
-- Add deflateBound() and compressBound() functions
-- Fix memory leak in deflateInit2()
-- Permit setting dictionary for raw deflate (for parallel deflate)
-- Fix const declaration for gzwrite()
-- Check for some malloc() failures in gzio.c
-- Fix bug in gzopen() on single-byte file 0x1f
-- Fix bug in gzread() on concatenated file with 0x1f at end of buffer
-  and next buffer doesn't start with 0x8b
-- Fix uncompress() to return Z_DATA_ERROR on truncated input
-- Free memory at end of example.c
-- Remove MAX #define in trees.c (conflicted with some libraries)
-- Fix static const's in deflate.c, gzio.c, and zutil.[ch]
-- Declare malloc() and free() in gzio.c if STDC not defined
-- Use malloc() instead of calloc() in zutil.c if int big enough
-- Define STDC for AIX
-- Add aix/ with approach for compiling shared library on AIX
-- Add HP-UX support for shared libraries in configure
-- Add OpenUNIX support for shared libraries in configure
-- Use $cc instead of gcc to build shared library
-- Make prefix directory if needed when installing
-- Correct Macintosh avoidance of typedef Byte in zconf.h
-- Correct Turbo C memory allocation when under Linux
-- Use libz.a instead of -lz in Makefile (assure use of compiled library)
-- Update configure to check for snprintf or vsnprintf functions and their
-  return value, warn during make if using an insecure function
-- Fix configure problem with compile-time knowledge of HAVE_UNISTD_H that
-  is lost when library is used--resolution is to build new zconf.h
-- Documentation improvements (in zlib.h):
-    - Document raw deflate and inflate
-    - Update RFCs URL
-    - Point out that zlib and gzip formats are different
-    - Note that Z_BUF_ERROR is not fatal
-    - Document string limit for gzprintf() and possible buffer overflow
-    - Note requirement on avail_out when flushing
-    - Note permitted values of flush parameter of inflate()
-- Add some FAQs (and even answers) to the FAQ
-- Add contrib/inflate86/ for x86 faster inflate
-- Add contrib/blast/ for PKWare Data Compression Library decompression
-- Add contrib/puff/ simple inflate for deflate format description
-
-Changes in 1.1.4 (11 March 2002)
-- ZFREE was repeated on same allocation on some error conditions.
-  This creates a security problem described in
-  http://www.zlib.org/advisory-2002-03-11.txt
-- Returned incorrect error (Z_MEM_ERROR) on some invalid data
-- Avoid accesses before window for invalid distances with inflate window
-  less than 32K.
-- force windowBits > 8 to avoid a bug in the encoder for a window size
-  of 256 bytes. (A complete fix will be available in 1.1.5).
-
-Changes in 1.1.3 (9 July 1998)
-- fix "an inflate input buffer bug that shows up on rare but persistent
-  occasions" (Mark)
-- fix gzread and gztell for concatenated .gz files (Didier Le Botlan)
-- fix gzseek(..., SEEK_SET) in write mode
-- fix crc check after a gzeek (Frank Faubert)
-- fix miniunzip when the last entry in a zip file is itself a zip file
-  (J Lillge)
-- add contrib/asm586 and contrib/asm686 (Brian Raiter)
-  See http://www.muppetlabs.com/~breadbox/software/assembly.html
-- add support for Delphi 3 in contrib/delphi (Bob Dellaca)
-- add support for C++Builder 3 and Delphi 3 in contrib/delphi2 (Davide Moretti)
-- do not exit prematurely in untgz if 0 at start of block (Magnus Holmgren)
-- use macro EXTERN instead of extern to support DLL for BeOS (Sander Stoks)
-- added a FAQ file
-
-- Support gzdopen on Mac with Metrowerks (Jason Linhart)
-- Do not redefine Byte on Mac (Brad Pettit & Jason Linhart)
-- define SEEK_END too if SEEK_SET is not defined (Albert Chin-A-Young)
-- avoid some warnings with Borland C (Tom Tanner)
-- fix a problem in contrib/minizip/zip.c for 16-bit MSDOS (Gilles Vollant)
-- emulate utime() for WIN32 in contrib/untgz  (Gilles Vollant)
-- allow several arguments to configure (Tim Mooney, Frodo Looijaard)
-- use libdir and includedir in Makefile.in (Tim Mooney)
-- support shared libraries on OSF1 V4 (Tim Mooney)
-- remove so_locations in "make clean"  (Tim Mooney)
-- fix maketree.c compilation error (Glenn, Mark)
-- Python interface to zlib now in Python 1.5 (Jeremy Hylton)
-- new Makefile.riscos (Rich Walker)
-- initialize static descriptors in trees.c for embedded targets (Nick Smith)
-- use "foo-gz" in example.c for RISCOS and VMS (Nick Smith)
-- add the OS/2 files in Makefile.in too (Andrew Zabolotny)
-- fix fdopen and halloc macros for Microsoft C 6.0 (Tom Lane)
-- fix maketree.c to allow clean compilation of inffixed.h (Mark)
-- fix parameter check in deflateCopy (Gunther Nikl)
-- cleanup trees.c, use compressed_len only in debug mode (Christian Spieler)
-- Many portability patches by Christian Spieler:
-  . zutil.c, zutil.h: added "const" for zmem*
-  . Make_vms.com: fixed some typos
-  . Make_vms.com: msdos/Makefile.*: removed zutil.h from some dependency lists
-  . msdos/Makefile.msc: remove "default rtl link library" info from obj files
-  . msdos/Makefile.*: use model-dependent name for the built zlib library
-  . msdos/Makefile.emx, nt/Makefile.emx, nt/Makefile.gcc:
-     new makefiles, for emx (DOS/OS2), emx&rsxnt and mingw32 (Windows 9x / NT)
-- use define instead of typedef for Bytef also for MSC small/medium (Tom Lane)
-- replace __far with _far for better portability (Christian Spieler, Tom Lane)
-- fix test for errno.h in configure (Tim Newsham)
-
-Changes in 1.1.2 (19 March 98)
-- added contrib/minzip, mini zip and unzip based on zlib (Gilles Vollant)
-  See http://www.winimage.com/zLibDll/unzip.html
-- preinitialize the inflate tables for fixed codes, to make the code
-  completely thread safe (Mark)
-- some simplifications and slight speed-up to the inflate code (Mark)
-- fix gzeof on non-compressed files (Allan Schrum)
-- add -std1 option in configure for OSF1 to fix gzprintf (Martin Mokrejs)
-- use default value of 4K for Z_BUFSIZE for 16-bit MSDOS (Tim Wegner + Glenn)
-- added os2/Makefile.def and os2/zlib.def (Andrew Zabolotny)
-- add shared lib support for UNIX_SV4.2MP (MATSUURA Takanori)
-- do not wrap extern "C" around system includes (Tom Lane)
-- mention zlib binding for TCL in README (Andreas Kupries)
-- added amiga/Makefile.pup for Amiga powerUP SAS/C PPC (Andreas Kleinert)
-- allow "make install prefix=..." even after configure (Glenn Randers-Pehrson)
-- allow "configure --prefix $HOME" (Tim Mooney)
-- remove warnings in example.c and gzio.c (Glenn Randers-Pehrson)
-- move Makefile.sas to amiga/Makefile.sas
-
-Changes in 1.1.1 (27 Feb 98)
-- fix macros _tr_tally_* in deflate.h for debug mode  (Glenn Randers-Pehrson)
-- remove block truncation heuristic which had very marginal effect for zlib
-  (smaller lit_bufsize than in gzip 1.2.4) and degraded a little the
-  compression ratio on some files. This also allows inlining _tr_tally for
-  matches in deflate_slow.
-- added msdos/Makefile.w32 for WIN32 Microsoft Visual C++ (Bob Frazier)
-
-Changes in 1.1.0 (24 Feb 98)
-- do not return STREAM_END prematurely in inflate (John Bowler)
-- revert to the zlib 1.0.8 inflate to avoid the gcc 2.8.0 bug (Jeremy Buhler)
-- compile with -DFASTEST to get compression code optimized for speed only
-- in minigzip, try mmap'ing the input file first (Miguel Albrecht)
-- increase size of I/O buffers in minigzip.c and gzio.c (not a big gain
-  on Sun but significant on HP)
-
-- add a pointer to experimental unzip library in README (Gilles Vollant)
-- initialize variable gcc in configure (Chris Herborth)
-
-Changes in 1.0.9 (17 Feb 1998)
-- added gzputs and gzgets functions
-- do not clear eof flag in gzseek (Mark Diekhans)
-- fix gzseek for files in transparent mode (Mark Diekhans)
-- do not assume that vsprintf returns the number of bytes written (Jens Krinke)
-- replace EXPORT with ZEXPORT to avoid conflict with other programs
-- added compress2 in zconf.h, zlib.def, zlib.dnt
-- new asm code from Gilles Vollant in contrib/asm386
-- simplify the inflate code (Mark):
- . Replace ZALLOC's in huft_build() with single ZALLOC in inflate_blocks_new()
- . ZALLOC the length list in inflate_trees_fixed() instead of using stack
- . ZALLOC the value area for huft_build() instead of using stack
- . Simplify Z_FINISH check in inflate()
-
-- Avoid gcc 2.8.0 comparison bug a little differently than zlib 1.0.8
-- in inftrees.c, avoid cc -O bug on HP (Farshid Elahi)
-- in zconf.h move the ZLIB_DLL stuff earlier to avoid problems with
-  the declaration of FAR (Gilles VOllant)
-- install libz.so* with mode 755 (executable) instead of 644 (Marc Lehmann)
-- read_buf buf parameter of type Bytef* instead of charf*
-- zmemcpy parameters are of type Bytef*, not charf* (Joseph Strout)
-- do not redeclare unlink in minigzip.c for WIN32 (John Bowler)
-- fix check for presence of directories in "make install" (Ian Willis)
-
-Changes in 1.0.8 (27 Jan 1998)
-- fixed offsets in contrib/asm386/gvmat32.asm (Gilles Vollant)
-- fix gzgetc and gzputc for big endian systems (Markus Oberhumer)
-- added compress2() to allow setting the compression level
-- include sys/types.h to get off_t on some systems (Marc Lehmann & QingLong)
-- use constant arrays for the static trees in trees.c instead of computing
-  them at run time (thanks to Ken Raeburn for this suggestion). To create
-  trees.h, compile with GEN_TREES_H and run "make test".
-- check return code of example in "make test" and display result
-- pass minigzip command line options to file_compress
-- simplifying code of inflateSync to avoid gcc 2.8 bug
-
-- support CC="gcc -Wall" in configure -s (QingLong)
-- avoid a flush caused by ftell in gzopen for write mode (Ken Raeburn)
-- fix test for shared library support to avoid compiler warnings
-- zlib.lib -> zlib.dll in msdos/zlib.rc (Gilles Vollant)
-- check for TARGET_OS_MAC in addition to MACOS (Brad Pettit)
-- do not use fdopen for Metrowerks on Mac (Brad Pettit))
-- add checks for gzputc and gzputc in example.c
-- avoid warnings in gzio.c and deflate.c (Andreas Kleinert)
-- use const for the CRC table (Ken Raeburn)
-- fixed "make uninstall" for shared libraries
-- use Tracev instead of Trace in infblock.c
-- in example.c use correct compressed length for test_sync
-- suppress +vnocompatwarnings in configure for HPUX (not always supported)
-
-Changes in 1.0.7 (20 Jan 1998)
-- fix gzseek which was broken in write mode
-- return error for gzseek to negative absolute position
-- fix configure for Linux (Chun-Chung Chen)
-- increase stack space for MSC (Tim Wegner)
-- get_crc_table and inflateSyncPoint are EXPORTed (Gilles Vollant)
-- define EXPORTVA for gzprintf (Gilles Vollant)
-- added man page zlib.3 (Rick Rodgers)
-- for contrib/untgz, fix makedir() and improve Makefile
-
-- check gzseek in write mode in example.c
-- allocate extra buffer for seeks only if gzseek is actually called
-- avoid signed/unsigned comparisons (Tim Wegner, Gilles Vollant)
-- add inflateSyncPoint in zconf.h
-- fix list of exported functions in nt/zlib.dnt and mdsos/zlib.def
-
-Changes in 1.0.6 (19 Jan 1998)
-- add functions gzprintf, gzputc, gzgetc, gztell, gzeof, gzseek, gzrewind and
-  gzsetparams (thanks to Roland Giersig and Kevin Ruland for some of this code)
-- Fix a deflate bug occurring only with compression level 0 (thanks to
-  Andy Buckler for finding this one).
-- In minigzip, pass transparently also the first byte for .Z files.
-- return Z_BUF_ERROR instead of Z_OK if output buffer full in uncompress()
-- check Z_FINISH in inflate (thanks to Marc Schluper)
-- Implement deflateCopy (thanks to Adam Costello)
-- make static libraries by default in configure, add --shared option.
-- move MSDOS or Windows specific files to directory msdos
-- suppress the notion of partial flush to simplify the interface
-  (but the symbol Z_PARTIAL_FLUSH is kept for compatibility with 1.0.4)
-- suppress history buffer provided by application to simplify the interface
-  (this feature was not implemented anyway in 1.0.4)
-- next_in and avail_in must be initialized before calling inflateInit or
-  inflateInit2
-- add EXPORT in all exported functions (for Windows DLL)
-- added Makefile.nt (thanks to Stephen Williams)
-- added the unsupported "contrib" directory:
-   contrib/asm386/ by Gilles Vollant <info@winimage.com>
-        386 asm code replacing longest_match().
-   contrib/iostream/ by Kevin Ruland <kevin@rodin.wustl.edu>
-        A C++ I/O streams interface to the zlib gz* functions
-   contrib/iostream2/  by Tyge Lvset <Tyge.Lovset@cmr.no>
-        Another C++ I/O streams interface
-   contrib/untgz/  by "Pedro A. Aranda Guti\irrez" <paag@tid.es>
-        A very simple tar.gz file extractor using zlib
-   contrib/visual-basic.txt by Carlos Rios <c_rios@sonda.cl>
-        How to use compress(), uncompress() and the gz* functions from VB.
-- pass params -f (filtered data), -h (huffman only), -1 to -9 (compression
-  level) in minigzip (thanks to Tom Lane)
-
-- use const for rommable constants in deflate
-- added test for gzseek and gztell in example.c
-- add undocumented function inflateSyncPoint() (hack for Paul Mackerras)
-- add undocumented function zError to convert error code to string
-  (for Tim Smithers)
-- Allow compilation of gzio with -DNO_DEFLATE to avoid the compression code.
-- Use default memcpy for Symantec MSDOS compiler.
-- Add EXPORT keyword for check_func (needed for Windows DLL)
-- add current directory to LD_LIBRARY_PATH for "make test"
-- create also a link for libz.so.1
-- added support for FUJITSU UXP/DS (thanks to Toshiaki Nomura)
-- use $(SHAREDLIB) instead of libz.so in Makefile.in (for HPUX)
-- added -soname for Linux in configure (Chun-Chung Chen,
-- assign numbers to the exported functions in zlib.def (for Windows DLL)
-- add advice in zlib.h for best usage of deflateSetDictionary
-- work around compiler bug on Atari (cast Z_NULL in call of s->checkfn)
-- allow compilation with ANSI keywords only enabled for TurboC in large model
-- avoid "versionString"[0] (Borland bug)
-- add NEED_DUMMY_RETURN for Borland
-- use variable z_verbose for tracing in debug mode (L. Peter Deutsch).
-- allow compilation with CC
-- defined STDC for OS/2 (David Charlap)
-- limit external names to 8 chars for MVS (Thomas Lund)
-- in minigzip.c, use static buffers only for 16-bit systems
-- fix suffix check for "minigzip -d foo.gz"
-- do not return an error for the 2nd of two consecutive gzflush() (Felix Lee)
-- use _fdopen instead of fdopen for MSC >= 6.0 (Thomas Fanslau)
-- added makelcc.bat for lcc-win32 (Tom St Denis)
-- in Makefile.dj2, use copy and del instead of install and rm (Frank Donahoe)
-- Avoid expanded $Id: ChangeLog,v 1.5 2002/05/08 04:38:00 aoliva Exp $. Use "rcs -kb" or "cvs admin -kb" to avoid Id expansion.
-- check for unistd.h in configure (for off_t)
-- remove useless check parameter in inflate_blocks_free
-- avoid useless assignment of s->check to itself in inflate_blocks_new
-- do not flush twice in gzclose (thanks to Ken Raeburn)
-- rename FOPEN as F_OPEN to avoid clash with /usr/include/sys/file.h
-- use NO_ERRNO_H instead of enumeration of operating systems with errno.h
-- work around buggy fclose on pipes for HP/UX
-- support zlib DLL with BORLAND C++ 5.0 (thanks to Glenn Randers-Pehrson)
-- fix configure if CC is already equal to gcc
-
-Changes in 1.0.5 (3 Jan 98)
-- Fix inflate to terminate gracefully when fed corrupted or invalid data
-- Use const for rommable constants in inflate
-- Eliminate memory leaks on error conditions in inflate
-- Removed some vestigial code in inflate
-- Update web address in README
-
-Changes in 1.0.4 (24 Jul 96)
-- In very rare conditions, deflate(s, Z_FINISH) could fail to produce an EOF
-  bit, so the decompressor could decompress all the correct data but went
-  on to attempt decompressing extra garbage data. This affected minigzip too.
-- zlibVersion and gzerror return const char* (needed for DLL)
-- port to RISCOS (no fdopen, no multiple dots, no unlink, no fileno)
-- use z_error only for DEBUG (avoid problem with DLLs)
-
-Changes in 1.0.3 (2 Jul 96)
-- use z_streamp instead of z_stream *, which is now a far pointer in MSDOS
-  small and medium models; this makes the library incompatible with previous
-  versions for these models. (No effect in large model or on other systems.)
-- return OK instead of BUF_ERROR if previous deflate call returned with
-  avail_out as zero but there is nothing to do
-- added memcmp for non STDC compilers
-- define NO_DUMMY_DECL for more Mac compilers (.h files merged incorrectly)
-- define __32BIT__ if __386__ or i386 is defined (pb. with Watcom and SCO)
-- better check for 16-bit mode MSC (avoids problem with Symantec)
-
-Changes in 1.0.2 (23 May 96)
-- added Windows DLL support
-- added a function zlibVersion (for the DLL support)
-- fixed declarations using Bytef in infutil.c (pb with MSDOS medium model)
-- Bytef is define's instead of typedef'd only for Borland C
-- avoid reading uninitialized memory in example.c
-- mention in README that the zlib format is now RFC1950
-- updated Makefile.dj2
-- added algorithm.doc
-
-Changes in 1.0.1 (20 May 96) [1.0 skipped to avoid confusion]
-- fix array overlay in deflate.c which sometimes caused bad compressed data
-- fix inflate bug with empty stored block
-- fix MSDOS medium model which was broken in 0.99
-- fix deflateParams() which could generated bad compressed data.
-- Bytef is define'd instead of typedef'ed (work around Borland bug)
-- added an INDEX file
-- new makefiles for DJGPP (Makefile.dj2), 32-bit Borland (Makefile.b32),
-  Watcom (Makefile.wat), Amiga SAS/C (Makefile.sas)
-- speed up adler32 for modern machines without auto-increment
-- added -ansi for IRIX in configure
-- static_init_done in trees.c is an int
-- define unlink as delete for VMS
-- fix configure for QNX
-- add configure branch for SCO and HPUX
-- avoid many warnings (unused variables, dead assignments, etc...)
-- no fdopen for BeOS
-- fix the Watcom fix for 32 bit mode (define FAR as empty)
-- removed redefinition of Byte for MKWERKS
-- work around an MWKERKS bug (incorrect merge of all .h files)
-
-Changes in 0.99 (27 Jan 96)
-- allow preset dictionary shared between compressor and decompressor
-- allow compression level 0 (no compression)
-- add deflateParams in zlib.h: allow dynamic change of compression level
-  and compression strategy.
-- test large buffers and deflateParams in example.c
-- add optional "configure" to build zlib as a shared library
-- suppress Makefile.qnx, use configure instead
-- fixed deflate for 64-bit systems (detected on Cray)
-- fixed inflate_blocks for 64-bit systems (detected on Alpha)
-- declare Z_DEFLATED in zlib.h (possible parameter for deflateInit2)
-- always return Z_BUF_ERROR when deflate() has nothing to do
-- deflateInit and inflateInit are now macros to allow version checking
-- prefix all global functions and types with z_ with -DZ_PREFIX
-- make falloc completely reentrant (inftrees.c)
-- fixed very unlikely race condition in ct_static_init
-- free in reverse order of allocation to help memory manager
-- use zlib-1.0/* instead of zlib/* inside the tar.gz
-- make zlib warning-free with "gcc -O3 -Wall -Wwrite-strings -Wpointer-arith
-  -Wconversion -Wstrict-prototypes -Wmissing-prototypes"
-- allow gzread on concatenated .gz files
-- deflateEnd now returns Z_DATA_ERROR if it was premature
-- deflate is finally (?) fully deterministic (no matches beyond end of input)
-- Document Z_SYNC_FLUSH
-- add uninstall in Makefile
-- Check for __cpluplus in zlib.h
-- Better test in ct_align for partial flush
-- avoid harmless warnings for Borland C++
-- initialize hash_head in deflate.c
-- avoid warning on fdopen (gzio.c) for HP cc -Aa
-- include stdlib.h for STDC compilers
-- include errno.h for Cray
-- ignore error if ranlib doesn't exist
-- call ranlib twice for NeXTSTEP
-- use exec_prefix instead of prefix for libz.a
-- renamed ct_* as _tr_* to avoid conflict with applications
-- clear z->msg in inflateInit2 before any error return
-- initialize opaque in example.c, gzio.c, deflate.c and inflate.c
-- fixed typo in zconf.h (_GNUC__ => __GNUC__)
-- check for WIN32 in zconf.h and zutil.c (avoid farmalloc in 32-bit mode)
-- fix typo in Make_vms.com (f$trnlnm -> f$getsyi)
-- in fcalloc, normalize pointer if size > 65520 bytes
-- don't use special fcalloc for 32 bit Borland C++
-- use STDC instead of __GO32__ to avoid redeclaring exit, calloc, etc...
-- use Z_BINARY instead of BINARY
-- document that gzclose after gzdopen will close the file
-- allow "a" as mode in gzopen.
-- fix error checking in gzread
-- allow skipping .gz extra-field on pipes
-- added reference to Perl interface in README
-- put the crc table in FAR data (I dislike more and more the medium model :)
-- added get_crc_table
-- added a dimension to all arrays (Borland C can't count).
-- workaround Borland C bug in declaration of inflate_codes_new & inflate_fast
-- guard against multiple inclusion of *.h (for precompiled header on Mac)
-- Watcom C pretends to be Microsoft C small model even in 32 bit mode.
-- don't use unsized arrays to avoid silly warnings by Visual C++:
-     warning C4746: 'inflate_mask' : unsized array treated as  '__far'
-     (what's wrong with far data in far model?).
-- define enum out of inflate_blocks_state to allow compilation with C++
-
-Changes in 0.95 (16 Aug 95)
-- fix MSDOS small and medium model (now easier to adapt to any compiler)
-- inlined send_bits
-- fix the final (:-) bug for deflate with flush (output was correct but
-  not completely flushed in rare occasions).
-- default window size is same for compression and decompression
-  (it's now sufficient to set MAX_WBITS in zconf.h).
-- voidp -> voidpf and voidnp -> voidp (for consistency with other
-  typedefs and because voidnp was not near in large model).
-
-Changes in 0.94 (13 Aug 95)
-- support MSDOS medium model
-- fix deflate with flush (could sometimes generate bad output)
-- fix deflateReset (zlib header was incorrectly suppressed)
-- added support for VMS
-- allow a compression level in gzopen()
-- gzflush now calls fflush
-- For deflate with flush, flush even if no more input is provided.
-- rename libgz.a as libz.a
-- avoid complex expression in infcodes.c triggering Turbo C bug
-- work around a problem with gcc on Alpha (in INSERT_STRING)
-- don't use inline functions (problem with some gcc versions)
-- allow renaming of Byte, uInt, etc... with #define.
-- avoid warning about (unused) pointer before start of array in deflate.c
-- avoid various warnings in gzio.c, example.c, infblock.c, adler32.c, zutil.c
-- avoid reserved word 'new' in trees.c
-
-Changes in 0.93 (25 June 95)
-- temporarily disable inline functions
-- make deflate deterministic
-- give enough lookahead for PARTIAL_FLUSH
-- Set binary mode for stdin/stdout in minigzip.c for OS/2
-- don't even use signed char in inflate (not portable enough)
-- fix inflate memory leak for segmented architectures
-
-Changes in 0.92 (3 May 95)
-- don't assume that char is signed (problem on SGI)
-- Clear bit buffer when starting a stored block
-- no memcpy on Pyramid
-- suppressed inftest.c
-- optimized fill_window, put longest_match inline for gcc
-- optimized inflate on stored blocks.
-- untabify all sources to simplify patches
-
-Changes in 0.91 (2 May 95)
-- Default MEM_LEVEL is 8 (not 9 for Unix) as documented in zlib.h
-- Document the memory requirements in zconf.h
-- added "make install"
-- fix sync search logic in inflateSync
-- deflate(Z_FULL_FLUSH) now works even if output buffer too short
-- after inflateSync, don't scare people with just "lo world"
-- added support for DJGPP
-
-Changes in 0.9 (1 May 95)
-- don't assume that zalloc clears the allocated memory (the TurboC bug
-  was Mark's bug after all :)
-- let again gzread copy uncompressed data unchanged (was working in 0.71)
-- deflate(Z_FULL_FLUSH), inflateReset and inflateSync are now fully implemented
-- added a test of inflateSync in example.c
-- moved MAX_WBITS to zconf.h because users might want to change that.
-- document explicitly that zalloc(64K) on MSDOS must return a normalized
-  pointer (zero offset)
-- added Makefiles for Microsoft C, Turbo C, Borland C++
-- faster crc32()
-
-Changes in 0.8 (29 April 95)
-- added fast inflate (inffast.c)
-- deflate(Z_FINISH) now returns Z_STREAM_END when done. Warning: this
-  is incompatible with previous versions of zlib which returned Z_OK.
-- work around a TurboC compiler bug (bad code for b << 0, see infutil.h)
-  (actually that was not a compiler bug, see 0.81 above)
-- gzread no longer reads one extra byte in certain cases
-- In gzio destroy(), don't reference a freed structure
-- avoid many warnings for MSDOS
-- avoid the ERROR symbol which is used by MS Windows
-
-Changes in 0.71 (14 April 95)
-- Fixed more MSDOS compilation problems :( There is still a bug with
-  TurboC large model.
-
-Changes in 0.7 (14 April 95)
-- Added full inflate support.
-- Simplified the crc32() interface. The pre- and post-conditioning
-  (one's complement) is now done inside crc32(). WARNING: this is
-  incompatible with previous versions; see zlib.h for the new usage.
-
-Changes in 0.61 (12 April 95)
-- workaround for a bug in TurboC. example and minigzip now work on MSDOS.
-
-Changes in 0.6 (11 April 95)
-- added minigzip.c
-- added gzdopen to reopen a file descriptor as gzFile
-- added transparent reading of non-gziped files in gzread.
-- fixed bug in gzread (don't read crc as data)
-- fixed bug in destroy (gzio.c) (don't return Z_STREAM_END for gzclose).
-- don't allocate big arrays in the stack (for MSDOS)
-- fix some MSDOS compilation problems
-
-Changes in 0.5:
-- do real compression in deflate.c. Z_PARTIAL_FLUSH is supported but
-  not yet Z_FULL_FLUSH.
-- support decompression but only in a single step (forced Z_FINISH)
-- added opaque object for zalloc and zfree.
-- added deflateReset and inflateReset
-- added a variable zlib_version for consistency checking.
-- renamed the 'filter' parameter of deflateInit2 as 'strategy'.
-  Added Z_FILTERED and Z_HUFFMAN_ONLY constants.
-
-Changes in 0.4:
-- avoid "zip" everywhere, use zlib instead of ziplib.
-- suppress Z_BLOCK_FLUSH, interpret Z_PARTIAL_FLUSH as block flush
-  if compression method == 8.
-- added adler32 and crc32
-- renamed deflateOptions as deflateInit2, call one or the other but not both
-- added the method parameter for deflateInit2.
-- added inflateInit2
-- simplied considerably deflateInit and inflateInit by not supporting
-  user-provided history buffer. This is supported only in deflateInit2
-  and inflateInit2.
-
-Changes in 0.3:
-- prefix all macro names with Z_
-- use Z_FINISH instead of deflateEnd to finish compression.
-- added Z_HUFFMAN_ONLY
-- added gzerror()
diff -Nbaur gcc-4.6.3/zlib/ChangeLog.gcj gcc-4.6.3-psp/zlib/ChangeLog.gcj
--- gcc-4.6.3/zlib/ChangeLog.gcj	2011-02-13 11:45:53.000000000 +0000
+++ gcc-4.6.3-psp/zlib/ChangeLog.gcj	1970-01-01 01:00:00.000000000 +0100
@@ -1,322 +0,0 @@
-2011-02-13  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* configure: Regenerate.
-
-2010-04-02  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* Makefile.in: Regenerate.
-	* aclocal.m4: Regenerate.
-
-2009-12-05  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* Makefile.in: Regenerate.
-	* configure: Regenerate.
-
-2009-08-24  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* configure.ac (AC_PREREQ): Bump to 2.64.
-
-2009-08-22  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* Makefile.am (install-html, install-pdf, html): Remove.
-	* Makefile.in: Regenerate.
-
-	* Makefile.in: Regenerate.
-	* aclocal.m4: Regenerate.
-	* configure: Regenerate.
-
-2009-07-30  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* configure.ac (_AC_ARG_VAR_PRECIOUS): Use m4_rename_force.
-
-2009-03-01  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* configure: Regenerate.
-
-2008-12-18  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* configure: Regenerate.
-
-2008-09-26  Peter O'Gorman  <pogma@thewrittenword.com>
-            Steve Ellcey  <sje@cup.hp.com>
-
-	* configure: Regenerate for new libtool.
-	* Makefile.in: Ditto.
-
-2008-06-17  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* Makefile.in: Regenerate.
-	* configure: Regenerate.
-
-2008-03-16  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
-
-	* aclocal.m4: Regenerate.
-	* configure: Likewise.
-	* Makefile.in: Likewise.
-
-2008-01-24  David Edelsohn  <edelsohn@gnu.org>
-
-	* configure: Regenerate.
-
-2007-07-05  H.J. Lu  <hongjiu.lu@intel.com>
-
-	* aclocal.m4: Regenerated.
-
-2007-05-23  Steve Ellcey  <sje@cup.hp.com>
-
-	* Makefile.in: Regenerate.
-	* configure: Regenerate.
-	* aclocal.m4: Regenerate.
-
-2007-04-14  Steve Ellcey  <sje@cup.hp.com>
-
-	* Makefile.am: Add -I .. to ACLOCAL_AMFLAGS.
-	* Makefile.in: Regenerate.
-
-2007-03-01  Brooks Moses  <brooks.moses@codesourcery.com>
-
-	* Makefile.am: Add dummy install-pdf target.
-	* Makefile.in: Regenerate
-
-2007-01-16  Jack Howarth  <howarth@bromo.med.uc.edu>
-
-	* Makefile.am: Add ACLOCAL_AMFLAGS to use multi.m4.
-	* aclocal.m4: Regenerate.
-	* configure: Regenerate.
-	* Makefile.in: Regenerate.
-
-2006-06-13  Carlos O'Donell  <carlos@codesourcery.com>
-
-	* Makefile.am: Add html and install-html stubs.
-	* Makefile.in: Regenerate.
-	* aclocal.m4: Regenerate.
-
-2005-06-14  Tom Tromey  <tromey@redhat.com>
-
-	* Imported zlib 1.2.3; merged local changes.
-
-2005-06-14  Tom Tromey  <tromey@redhat.com>
-
-	PR libgcj/19877:
-	* configure, aclocal.m4, Makefile.in: Rebuilt.
-
-2005-06-06  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
-
-	* zconf.h (NO_vsnprintf): Define on Tru64 UNIX V4.0.
-
-2005-05-09  Mike Stump  <mrs@apple.com>
-	
-	* configure: Regenerate.
-
-2005-04-12  Mike Stump  <mrs@apple.com>
-
-	* configure: Regenerate.
-
-2004-11-24  Kelley Cook  <kcook@gcc.gnu.org>
-
-	* configure: Regenerate for libtool change.
-
-2004-11-24  Kelley Cook  <kcook@gcc.gnu.org>
-
-	* Makefile.in, aclocal.m4: Regenerate with automake 1.9.3.
-
-2004-11-22  Eric Botcazou  <ebotcazou@libertysurf.fr>
-
-	* zconf.h: Define NO_vsnprintf on Solaris 2.5.1.
-
-2004-10-11  Tom Tromey  <tromey@redhat.com>
-
-	PR libgcj/14856:
-	* Imported zlib 1.2.1; merged local changes.
-
-2005-06-15  Paolo Bonzini  <bonzini@gnu.org>
-
-	* Makefile.am: Remove useless multilib rules.
-	* configure.ac: Rewrite multilib support to use
-	features of recent automakes.
-	* aclocal.m4: Regenerate with Automake 1.8.5.
-	* Makefile.in: Regenerate with Automake 1.8.5.
-	* configure: Regenerate.
-
-2004-04-12  Kelley Cook  <kcook@gcc.gnu.org>
-
-	* Makefile.am: Add in libz_a_CFLAGS as recommended by automake doc.
-	* Makefile.in: Regenerate with automake 1.7.9.
-	* aclocal.m4: Likewise.
-	* configure: Regenerate.
-
-2004-04-10  Kelley Cook  <kcook@gcc.gnu.org>
-
-	* configure.in: Rename file to ...
-	* configure.ac: ...this.
-	* Makefile.in: Regenerate.
-
-2004-04-09  Nathanael Nerode  <neroden@gcc.gnu.org>
-
-	* configure.in: Update to autoconf 2.59; clean up slightly.
-	* acinclude.m4: Update to autoconf 2.59.
-	* aclocal.m4: Regenerate. 
-	* Makefile.in: Regenerate.
-	* configure: Regenerate.
-
-2004-01-14  Kelley Cook  <kcook@gcc.gnu.org>
-
-	* configure.in: Add in AC_PREREQ(2.13)
-
-2003-09-09  Alan Modra  <amodra@bigpond.net.au>
-
-	* configure: Regenerate.
-
-2003-07-11  Nathanael Nerode  <neroden@gcc.gnu.org>
-
-	PR bootstrap/7126
-	* configure.in: Correct zlib version number.
-	* configure: Regenerate.
-
-2003-07-11  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>
-
-	* README: Note that zlib is not part of GCC.
-
-2003-03-12  Andreas Schwab  <schwab@suse.de>
-
-	* configure.in:  Avoid trailing /. in toolexeclibdir.
-	* configure: Rebuilt.
-
-2003-02-20  Alexandre Oliva  <aoliva@redhat.com>
-
-	* configure.in: Propagate ORIGINAL_LD_FOR_MULTILIBS to
-	config.status.
-	* configure: Rebuilt.
-
-2003-02-19  Alexandre Oliva  <aoliva@redhat.com>
-
-	* configure.in (multiosdir): Set to nothing if compiler is not GCC
-	or if it doesn't support -print-multi-os-directory.
-	* configure: Rebuilt.
-
-2002-09-22  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
-
-	* Makefile.am (all-multi): Fix multilib parallel build.
-
-2002-05-16  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
-
-	* configure.in: Allow for PWDCMD to override hardcoded pwd.
-	* configure: Regenerate.
-
-	* ChangeLog: Move entries to ChangeLog.gcj.
-
-2002-05-08  Alexandre Oliva  <aoliva@redhat.com>
-
-	* configure.in (ORIGINAL_LD_FOR_MULTILIBS): Preserve LD at
-	script entry, and set LD to it when configuring multilibs.
-	* configure: Rebuilt.
-
-2002-03-17  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>
-
-	* Makefile.am: Make target library a convenience library.
-	* Makefile.in: Rebuilt.
-
-2002-03-11  Tom Tromey  <tromey@redhat.com>
-
-	* ChangeLog.gcj: Imported 1.1.4, while preserving local changes.
-
-2001-07-03  Tom Tromey  <tromey@redhat.com>
-
-	Fix for PR bootstrap/3281:
-	* configure, Makefile.in: Rebuilt.
-	* configure.in: Set mkinstalldirs, for in-tree build.
-
-2001-06-09  Alexandre Oliva  <aoliva@redhat.com>, Stephen L Moshier  <moshier@mediaone.net>
-
-	* configure.in (AC_EXEEXT): Work around in case it expands to
-	nothing, as in autoconf 2.50.
-	* configure: Rebuilt.
-
-2001-05-13  Alexandre Oliva  <aoliva@redhat.com>
-
-	* acinclude.m4: Use ../libtool.m4.
-	* configure.in: Use ${zlib_basedir}/.. for AC_CONFIG_AUX_DIR.
-	* acinclude.m4, configure, Makefile.in: Rebuilt.
-
-2000-10-24  Chris Demetriou  <cgd@sibyte.com>
-
-	* configure.in: Invoke AC_PROG_CPP unconditionally before
-	conditional feature tests.
-
-2000-10-10  Alexandre Oliva  <aoliva@redhat.com>
-
-	* configure.in (zlib_basedir): Cope with empty with_target_subdir
-	* configure: Rebuilt.
-
-2000-09-06  Alexandre Oliva  <aoliva@redhat.com>
-
-	* configure.in (multilib): Enable by default only for target.
-	* configure: Rebuilt.
-
-Sun Sep  3 12:37:12 2000  Anthony Green  <green@redhat.com>
-
-	* configure.in: Add TARGET_LIBRARY conditional.
-	* configure: Rebuilt.
-	* Makefile.am: If we're building a build host library, call the
-	library libz.a and don't use libtool.
-	* Makefile.in: Rebuilt.
-
-1999-10-04  Tom Tromey  <tromey@cygnus.com>
-
-	* configure: Rebuilt.
-	* configure.in: Call AC_EXEEXT after LIB_AC_PROG_CC, but don't
-	actually let AC_EXEEXT run.
-
-1999-09-28  Tom Tromey  <tromey@cygnus.com>
-
-	* aclocal.m4, configure: Rebuilt.
-	* acinclude.m4 (LIB_AC_PROG_CC): Provide appropriate AC_PROG_ symbol.
-
-Mon Aug  9 18:33:38 1999  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
-
-	* Makefile.in: Rebuilt.
-	* Makefile.am (toolexeclibdir): Add $(MULTISUBDIR) even for native
-	builds.
-
-	* configure: Rebuilt.
-	* configure.in: Properly align --help output, fix capitalization.
-
-1999-08-02  Tom Tromey  <tromey@cygnus.com>
-
-	* aclocal.m4, configure: Rebuilt for new libtool.
-
-1999-07-19  Alexandre Oliva  <oliva@dcc.unicamp.br>
-
-	* Makefile.am (*-recursive, *-am, *-multi): Automake does not
-	generate *-recursive for this Makefile, use *-am instead.
-	* Makefile.in: Rebuilt.
-
-1999-06-21  Tom Tromey  <tromey@cygnus.com>
-
-	* Makefile.in: Rebuilt.
-	* Makefile.am (libzgcj_la_LDFLAGS): Use -version-info, not
-	-release.
-
-	* Makefile.in: Rebuilt.
-	* Makefile.am (toolexeclibdir): Define as libdir when
-	appropriate.
-	* configure: Rebuilt.
-	* configure.in (USE_LIBDIR): New conditional.
-
-1999-05-10  Tom Tromey  <tromey@cygnus.com>
-
-	* configure, Makefile.in: Rebuilt.
-	* Makefile.am (EXTRA_LTLIBRARIES): New macro.
-	(toolexeclib_LTLIBRARIES): Use @target_all@.
-	* configure.in: Recognize --with-system-zlib.  Subst target_all.
-
-1999-05-04  Tom Tromey  <tromey@cygnus.com>
-
-	* Makefile.in: Replace with automake-generated file.
-	* Makefile.am: New file.
-	* configure: Replaced with autoconf-generated script.
-	* aclocal.m4: New file.
-	* acinclude.m4: New file.
-	* configure.in: New file.
-	* Makefile: Removed.
-
diff -Nbaur gcc-4.6.3/zlib/compress.c gcc-4.6.3-psp/zlib/compress.c
--- gcc-4.6.3/zlib/compress.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/compress.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,79 +0,0 @@
-/* compress.c -- compress a memory buffer
- * Copyright (C) 1995-2003 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id: compress.c,v 1.1.1.2 2002/03/11 21:53:23 tromey Exp $ */
-
-#define ZLIB_INTERNAL
-#include "zlib.h"
-
-/* ===========================================================================
-     Compresses the source buffer into the destination buffer. The level
-   parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer. Upon entry, destLen is the total size of the
-   destination buffer, which must be at least 0.1% larger than sourceLen plus
-   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
-
-     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
-   Z_STREAM_ERROR if the level parameter is invalid.
-*/
-int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-    int level;
-{
-    z_stream stream;
-    int err;
-
-    stream.next_in = (Bytef*)source;
-    stream.avail_in = (uInt)sourceLen;
-#ifdef MAXSEG_64K
-    /* Check for source > 64K on 16-bit machine: */
-    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
-#endif
-    stream.next_out = dest;
-    stream.avail_out = (uInt)*destLen;
-    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
-
-    stream.zalloc = (alloc_func)0;
-    stream.zfree = (free_func)0;
-    stream.opaque = (voidpf)0;
-
-    err = deflateInit(&stream, level);
-    if (err != Z_OK) return err;
-
-    err = deflate(&stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        deflateEnd(&stream);
-        return err == Z_OK ? Z_BUF_ERROR : err;
-    }
-    *destLen = stream.total_out;
-
-    err = deflateEnd(&stream);
-    return err;
-}
-
-/* ===========================================================================
- */
-int ZEXPORT compress (dest, destLen, source, sourceLen)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-{
-    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
-}
-
-/* ===========================================================================
-     If the default memLevel or windowBits for deflateInit() is changed, then
-   this function needs to be updated.
- */
-uLong ZEXPORT compressBound (sourceLen)
-    uLong sourceLen;
-{
-    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) + 11;
-}
diff -Nbaur gcc-4.6.3/zlib/configure gcc-4.6.3-psp/zlib/configure
--- gcc-4.6.3/zlib/configure	2011-11-20 21:24:07.000000000 +0000
+++ gcc-4.6.3-psp/zlib/configure	1970-01-01 01:00:00.000000000 +0100
@@ -1,13398 +0,0 @@
-#! /bin/sh
-# Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.64.
-#
-# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
-# Foundation, Inc.
-#
-# This configure script is free software; the Free Software Foundation
-# gives unlimited permission to copy, distribute and modify it.
-## -------------------- ##
-## M4sh Initialization. ##
-## -------------------- ##
-
-# Be more Bourne compatible
-DUALCASE=1; export DUALCASE # for MKS sh
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
-  emulate sh
-  NULLCMD=:
-  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in #(
-  *posix*) :
-    set -o posix ;; #(
-  *) :
-     ;;
-esac
-fi
-
-
-as_nl='
-'
-export as_nl
-# Printing a long string crashes Solaris 7 /usr/bin/printf.
-as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
-# Prefer a ksh shell builtin over an external printf program on Solaris,
-# but without wasting forks for bash or zsh.
-if test -z "$BASH_VERSION$ZSH_VERSION" \
-    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='print -r --'
-  as_echo_n='print -rn --'
-elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='printf %s\n'
-  as_echo_n='printf %s'
-else
-  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
-    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
-    as_echo_n='/usr/ucb/echo -n'
-  else
-    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
-    as_echo_n_body='eval
-      arg=$1;
-      case $arg in #(
-      *"$as_nl"*)
-	expr "X$arg" : "X\\(.*\\)$as_nl";
-	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
-      esac;
-      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
-    '
-    export as_echo_n_body
-    as_echo_n='sh -c $as_echo_n_body as_echo'
-  fi
-  export as_echo_body
-  as_echo='sh -c $as_echo_body as_echo'
-fi
-
-# The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
-  PATH_SEPARATOR=:
-  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
-    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
-      PATH_SEPARATOR=';'
-  }
-fi
-
-
-# IFS
-# We need space, tab and new line, in precisely that order.  Quoting is
-# there to prevent editors from complaining about space-tab.
-# (If _AS_PATH_WALK were called with IFS unset, it would disable word
-# splitting by setting IFS to empty value.)
-IFS=" ""	$as_nl"
-
-# Find who we are.  Look in the path if we contain no directory separator.
-case $0 in #((
-  *[\\/]* ) as_myself=$0 ;;
-  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-  done
-IFS=$as_save_IFS
-
-     ;;
-esac
-# We did not find ourselves, most probably we were run as `sh COMMAND'
-# in which case we are not to be found in the path.
-if test "x$as_myself" = x; then
-  as_myself=$0
-fi
-if test ! -f "$as_myself"; then
-  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
-  exit 1
-fi
-
-# Unset variables that we do not need and which cause bugs (e.g. in
-# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
-# suppresses any "Segmentation fault" message there.  '((' could
-# trigger a bug in pdksh 5.2.14.
-for as_var in BASH_ENV ENV MAIL MAILPATH
-do eval test x\${$as_var+set} = xset \
-  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
-done
-PS1='$ '
-PS2='> '
-PS4='+ '
-
-# NLS nuisances.
-LC_ALL=C
-export LC_ALL
-LANGUAGE=C
-export LANGUAGE
-
-# CDPATH.
-(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
-
-if test "x$CONFIG_SHELL" = x; then
-  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
-  emulate sh
-  NULLCMD=:
-  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '\${1+\"\$@\"}'='\"\$@\"'
-  setopt NO_GLOB_SUBST
-else
-  case \`(set -o) 2>/dev/null\` in #(
-  *posix*) :
-    set -o posix ;; #(
-  *) :
-     ;;
-esac
-fi
-"
-  as_required="as_fn_return () { (exit \$1); }
-as_fn_success () { as_fn_return 0; }
-as_fn_failure () { as_fn_return 1; }
-as_fn_ret_success () { return 0; }
-as_fn_ret_failure () { return 1; }
-
-exitcode=0
-as_fn_success || { exitcode=1; echo as_fn_success failed.; }
-as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
-as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
-as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
-if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
-
-else
-  exitcode=1; echo positional parameters were not saved.
-fi
-test x\$exitcode = x0 || exit 1"
-  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
-  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
-  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
-  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
-
-  test -n \"\${ZSH_VERSION+set}\${BASH_VERSION+set}\" || (
-    ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-    ECHO=\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO
-    ECHO=\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO
-    PATH=/empty FPATH=/empty; export PATH FPATH
-    test \"X\`printf %s \$ECHO\`\" = \"X\$ECHO\" \\
-      || test \"X\`print -r -- \$ECHO\`\" = \"X\$ECHO\" ) || exit 1
-test \$(( 1 + 1 )) = 2 || exit 1"
-  if (eval "$as_required") 2>/dev/null; then :
-  as_have_required=yes
-else
-  as_have_required=no
-fi
-  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :
-
-else
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-as_found=false
-for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  as_found=:
-  case $as_dir in #(
-	 /*)
-	   for as_base in sh bash ksh sh5; do
-	     # Try only shells that exist, to save several forks.
-	     as_shell=$as_dir/$as_base
-	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
-		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
-  CONFIG_SHELL=$as_shell as_have_required=yes
-		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
-  break 2
-fi
-fi
-	   done;;
-       esac
-  as_found=false
-done
-$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
-	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
-  CONFIG_SHELL=$SHELL as_have_required=yes
-fi; }
-IFS=$as_save_IFS
-
-
-      if test "x$CONFIG_SHELL" != x; then :
-  # We cannot yet assume a decent shell, so we have to provide a
-	# neutralization value for shells without unset; and this also
-	# works around shells that cannot unset nonexistent variables.
-	BASH_ENV=/dev/null
-	ENV=/dev/null
-	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
-	export CONFIG_SHELL
-	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
-fi
-
-    if test x$as_have_required = xno; then :
-  $as_echo "$0: This script requires a shell more modern than all"
-  $as_echo "$0: the shells that I found on your system."
-  if test x${ZSH_VERSION+set} = xset ; then
-    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
-    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
-  else
-    $as_echo "$0: Please tell bug-autoconf@gnu.org about your system,
-$0: including any error possibly output before this
-$0: message. Then install a modern shell, or manually run
-$0: the script under such a shell if you do have one."
-  fi
-  exit 1
-fi
-fi
-fi
-SHELL=${CONFIG_SHELL-/bin/sh}
-export SHELL
-# Unset more variables known to interfere with behavior of common tools.
-CLICOLOR_FORCE= GREP_OPTIONS=
-unset CLICOLOR_FORCE GREP_OPTIONS
-
-## --------------------- ##
-## M4sh Shell Functions. ##
-## --------------------- ##
-# as_fn_unset VAR
-# ---------------
-# Portably unset VAR.
-as_fn_unset ()
-{
-  { eval $1=; unset $1;}
-}
-as_unset=as_fn_unset
-
-# as_fn_set_status STATUS
-# -----------------------
-# Set $? to STATUS, without forking.
-as_fn_set_status ()
-{
-  return $1
-} # as_fn_set_status
-
-# as_fn_exit STATUS
-# -----------------
-# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
-as_fn_exit ()
-{
-  set +e
-  as_fn_set_status $1
-  exit $1
-} # as_fn_exit
-
-# as_fn_mkdir_p
-# -------------
-# Create "$as_dir" as a directory, including parents if necessary.
-as_fn_mkdir_p ()
-{
-
-  case $as_dir in #(
-  -*) as_dir=./$as_dir;;
-  esac
-  test -d "$as_dir" || eval $as_mkdir_p || {
-    as_dirs=
-    while :; do
-      case $as_dir in #(
-      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
-      *) as_qdir=$as_dir;;
-      esac
-      as_dirs="'$as_qdir' $as_dirs"
-      as_dir=`$as_dirname -- "$as_dir" ||
-$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_dir" : 'X\(//\)[^/]' \| \
-	 X"$as_dir" : 'X\(//\)$' \| \
-	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_dir" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      test -d "$as_dir" && break
-    done
-    test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
-
-
-} # as_fn_mkdir_p
-# as_fn_append VAR VALUE
-# ----------------------
-# Append the text in VALUE to the end of the definition contained in VAR. Take
-# advantage of any shell optimizations that allow amortized linear growth over
-# repeated appends, instead of the typical quadratic growth present in naive
-# implementations.
-if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
-  eval 'as_fn_append ()
-  {
-    eval $1+=\$2
-  }'
-else
-  as_fn_append ()
-  {
-    eval $1=\$$1\$2
-  }
-fi # as_fn_append
-
-# as_fn_arith ARG...
-# ------------------
-# Perform arithmetic evaluation on the ARGs, and store the result in the
-# global $as_val. Take advantage of shells that can avoid forks. The arguments
-# must be portable across $(()) and expr.
-if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
-  eval 'as_fn_arith ()
-  {
-    as_val=$(( $* ))
-  }'
-else
-  as_fn_arith ()
-  {
-    as_val=`expr "$@" || test $? -eq 1`
-  }
-fi # as_fn_arith
-
-
-# as_fn_error ERROR [LINENO LOG_FD]
-# ---------------------------------
-# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
-# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with status $?, using 1 if that was 0.
-as_fn_error ()
-{
-  as_status=$?; test $as_status -eq 0 && as_status=1
-  if test "$3"; then
-    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
-  fi
-  $as_echo "$as_me: error: $1" >&2
-  as_fn_exit $as_status
-} # as_fn_error
-
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
-  as_basename=basename
-else
-  as_basename=false
-fi
-
-if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
-  as_dirname=dirname
-else
-  as_dirname=false
-fi
-
-as_me=`$as_basename -- "$0" ||
-$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
-	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X/"$0" |
-    sed '/^.*\/\([^/][^/]*\)\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
-
-  as_lineno_1=$LINENO as_lineno_1a=$LINENO
-  as_lineno_2=$LINENO as_lineno_2a=$LINENO
-  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
-  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
-  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
-  sed -n '
-    p
-    /[$]LINENO/=
-  ' <$as_myself |
-    sed '
-      s/[$]LINENO.*/&-/
-      t lineno
-      b
-      :lineno
-      N
-      :loop
-      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
-      t loop
-      s/-\n.*//
-    ' >$as_me.lineno &&
-  chmod +x "$as_me.lineno" ||
-    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
-
-  # Don't try to exec as it changes $[0], causing all sort of problems
-  # (the dirname of $[0] is not the place where we might find the
-  # original and so on.  Autoconf is especially sensitive to this).
-  . "./$as_me.lineno"
-  # Exit status is that of the last command.
-  exit
-}
-
-ECHO_C= ECHO_N= ECHO_T=
-case `echo -n x` in #(((((
--n*)
-  case `echo 'xy\c'` in
-  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
-  xy)  ECHO_C='\c';;
-  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
-       ECHO_T='	';;
-  esac;;
-*)
-  ECHO_N='-n';;
-esac
-
-rm -f conf$$ conf$$.exe conf$$.file
-if test -d conf$$.dir; then
-  rm -f conf$$.dir/conf$$.file
-else
-  rm -f conf$$.dir
-  mkdir conf$$.dir 2>/dev/null
-fi
-if (echo >conf$$.file) 2>/dev/null; then
-  if ln -s conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s='ln -s'
-    # ... but there are two gotchas:
-    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
-    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
-    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
-  elif ln conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s=ln
-  else
-    as_ln_s='cp -p'
-  fi
-else
-  as_ln_s='cp -p'
-fi
-rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
-rmdir conf$$.dir 2>/dev/null
-
-if mkdir -p . 2>/dev/null; then
-  as_mkdir_p='mkdir -p "$as_dir"'
-else
-  test -d ./-p && rmdir ./-p
-  as_mkdir_p=false
-fi
-
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
-
-# Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
-
-# Sed expression to map a string onto a valid variable name.
-as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
-
-SHELL=${CONFIG_SHELL-/bin/sh}
-
-
-exec 7<&0 </dev/null 6>&1
-
-# Name of the host.
-# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
-# so uname gets run too.
-ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
-
-#
-# Initializations.
-#
-ac_default_prefix=/usr/local
-ac_clean_files=
-ac_config_libobj_dir=.
-LIBOBJS=
-cross_compiling=no
-subdirs=
-MFLAGS=
-MAKEFLAGS=
-
-# Identity of this package.
-PACKAGE_NAME=
-PACKAGE_TARNAME=
-PACKAGE_VERSION=
-PACKAGE_STRING=
-PACKAGE_BUGREPORT=
-PACKAGE_URL=
-
-ac_unique_file="zlib.h"
-# Factoring default headers for most tests.
-ac_includes_default="\
-#include <stdio.h>
-#ifdef HAVE_SYS_TYPES_H
-# include <sys/types.h>
-#endif
-#ifdef HAVE_SYS_STAT_H
-# include <sys/stat.h>
-#endif
-#ifdef STDC_HEADERS
-# include <stdlib.h>
-# include <stddef.h>
-#else
-# ifdef HAVE_STDLIB_H
-#  include <stdlib.h>
-# endif
-#endif
-#ifdef HAVE_STRING_H
-# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
-#  include <memory.h>
-# endif
-# include <string.h>
-#endif
-#ifdef HAVE_STRINGS_H
-# include <strings.h>
-#endif
-#ifdef HAVE_INTTYPES_H
-# include <inttypes.h>
-#endif
-#ifdef HAVE_STDINT_H
-# include <stdint.h>
-#endif
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif"
-
-ac_subst_vars='am__EXEEXT_FALSE
-am__EXEEXT_TRUE
-LTLIBOBJS
-LIBOBJS
-TARGET_LIBRARY_FALSE
-TARGET_LIBRARY_TRUE
-toolexeclibdir
-toolexecdir
-target_all
-CPP
-OTOOL64
-OTOOL
-LIPO
-NMEDIT
-DSYMUTIL
-RANLIB
-AR
-OBJDUMP
-LN_S
-NM
-ac_ct_DUMPBIN
-DUMPBIN
-LD
-FGREP
-EGREP
-GREP
-SED
-LIBTOOL
-am__fastdepCC_FALSE
-am__fastdepCC_TRUE
-CCDEPMODE
-AMDEPBACKSLASH
-AMDEP_FALSE
-AMDEP_TRUE
-am__quote
-am__include
-DEPDIR
-OBJEXT
-EXEEXT
-ac_ct_CC
-CPPFLAGS
-LDFLAGS
-CFLAGS
-CC
-COMPPATH
-MAINT
-MAINTAINER_MODE_FALSE
-MAINTAINER_MODE_TRUE
-am__untar
-am__tar
-AMTAR
-am__leading_dot
-SET_MAKE
-AWK
-mkdir_p
-MKDIR_P
-INSTALL_STRIP_PROGRAM
-STRIP
-install_sh
-MAKEINFO
-AUTOHEADER
-AUTOMAKE
-AUTOCONF
-ACLOCAL
-VERSION
-PACKAGE
-CYGPATH_W
-am__isrc
-INSTALL_DATA
-INSTALL_SCRIPT
-INSTALL_PROGRAM
-mkinstalldirs
-target_os
-target_vendor
-target_cpu
-target
-host_os
-host_vendor
-host_cpu
-host
-build_os
-build_vendor
-build_cpu
-build
-multi_basedir
-target_alias
-host_alias
-build_alias
-LIBS
-ECHO_T
-ECHO_N
-ECHO_C
-DEFS
-mandir
-localedir
-libdir
-psdir
-pdfdir
-dvidir
-htmldir
-infodir
-docdir
-oldincludedir
-includedir
-localstatedir
-sharedstatedir
-sysconfdir
-datadir
-datarootdir
-libexecdir
-sbindir
-bindir
-program_transform_name
-prefix
-exec_prefix
-PACKAGE_URL
-PACKAGE_BUGREPORT
-PACKAGE_STRING
-PACKAGE_VERSION
-PACKAGE_TARNAME
-PACKAGE_NAME
-PATH_SEPARATOR
-SHELL'
-ac_subst_files=''
-ac_user_opts='
-enable_option_checking
-enable_multilib
-enable_maintainer_mode
-with_target_subdir
-with_cross_host
-with_system_zlib
-enable_dependency_tracking
-enable_shared
-enable_static
-with_pic
-enable_fast_install
-with_gnu_ld
-enable_libtool_lock
-'
-      ac_precious_vars='build_alias
-host_alias
-target_alias
-CPP
-CPPFLAGS'
-
-
-# Initialize some variables set by options.
-ac_init_help=
-ac_init_version=false
-ac_unrecognized_opts=
-ac_unrecognized_sep=
-# The variables have the same names as the options, with
-# dashes changed to underlines.
-cache_file=/dev/null
-exec_prefix=NONE
-no_create=
-no_recursion=
-prefix=NONE
-program_prefix=NONE
-program_suffix=NONE
-program_transform_name=s,x,x,
-silent=
-site=
-srcdir=
-verbose=
-x_includes=NONE
-x_libraries=NONE
-
-# Installation directory options.
-# These are left unexpanded so users can "make install exec_prefix=/foo"
-# and all the variables that are supposed to be based on exec_prefix
-# by default will actually change.
-# Use braces instead of parens because sh, perl, etc. also accept them.
-# (The list follows the same order as the GNU Coding Standards.)
-bindir='${exec_prefix}/bin'
-sbindir='${exec_prefix}/sbin'
-libexecdir='${exec_prefix}/libexec'
-datarootdir='${prefix}/share'
-datadir='${datarootdir}'
-sysconfdir='${prefix}/etc'
-sharedstatedir='${prefix}/com'
-localstatedir='${prefix}/var'
-includedir='${prefix}/include'
-oldincludedir='/usr/include'
-docdir='${datarootdir}/doc/${PACKAGE}'
-infodir='${datarootdir}/info'
-htmldir='${docdir}'
-dvidir='${docdir}'
-pdfdir='${docdir}'
-psdir='${docdir}'
-libdir='${exec_prefix}/lib'
-localedir='${datarootdir}/locale'
-mandir='${datarootdir}/man'
-
-ac_prev=
-ac_dashdash=
-for ac_option
-do
-  # If the previous option needs an argument, assign it.
-  if test -n "$ac_prev"; then
-    eval $ac_prev=\$ac_option
-    ac_prev=
-    continue
-  fi
-
-  case $ac_option in
-  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
-  *)	ac_optarg=yes ;;
-  esac
-
-  # Accept the important Cygnus configure options, so we can diagnose typos.
-
-  case $ac_dashdash$ac_option in
-  --)
-    ac_dashdash=yes ;;
-
-  -bindir | --bindir | --bindi | --bind | --bin | --bi)
-    ac_prev=bindir ;;
-  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
-    bindir=$ac_optarg ;;
-
-  -build | --build | --buil | --bui | --bu)
-    ac_prev=build_alias ;;
-  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
-    build_alias=$ac_optarg ;;
-
-  -cache-file | --cache-file | --cache-fil | --cache-fi \
-  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
-    ac_prev=cache_file ;;
-  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
-  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
-    cache_file=$ac_optarg ;;
-
-  --config-cache | -C)
-    cache_file=config.cache ;;
-
-  -datadir | --datadir | --datadi | --datad)
-    ac_prev=datadir ;;
-  -datadir=* | --datadir=* | --datadi=* | --datad=*)
-    datadir=$ac_optarg ;;
-
-  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
-  | --dataroo | --dataro | --datar)
-    ac_prev=datarootdir ;;
-  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
-  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
-    datarootdir=$ac_optarg ;;
-
-  -disable-* | --disable-*)
-    ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid feature name: $ac_useropt"
-    ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
-    case $ac_user_opts in
-      *"
-"enable_$ac_useropt"
-"*) ;;
-      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig"
-	 ac_unrecognized_sep=', ';;
-    esac
-    eval enable_$ac_useropt=no ;;
-
-  -docdir | --docdir | --docdi | --doc | --do)
-    ac_prev=docdir ;;
-  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
-    docdir=$ac_optarg ;;
-
-  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
-    ac_prev=dvidir ;;
-  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
-    dvidir=$ac_optarg ;;
-
-  -enable-* | --enable-*)
-    ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid feature name: $ac_useropt"
-    ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
-    case $ac_user_opts in
-      *"
-"enable_$ac_useropt"
-"*) ;;
-      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig"
-	 ac_unrecognized_sep=', ';;
-    esac
-    eval enable_$ac_useropt=\$ac_optarg ;;
-
-  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
-  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
-  | --exec | --exe | --ex)
-    ac_prev=exec_prefix ;;
-  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
-  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
-  | --exec=* | --exe=* | --ex=*)
-    exec_prefix=$ac_optarg ;;
-
-  -gas | --gas | --ga | --g)
-    # Obsolete; use --with-gas.
-    with_gas=yes ;;
-
-  -help | --help | --hel | --he | -h)
-    ac_init_help=long ;;
-  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
-    ac_init_help=recursive ;;
-  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
-    ac_init_help=short ;;
-
-  -host | --host | --hos | --ho)
-    ac_prev=host_alias ;;
-  -host=* | --host=* | --hos=* | --ho=*)
-    host_alias=$ac_optarg ;;
-
-  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
-    ac_prev=htmldir ;;
-  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
-  | --ht=*)
-    htmldir=$ac_optarg ;;
-
-  -includedir | --includedir | --includedi | --included | --include \
-  | --includ | --inclu | --incl | --inc)
-    ac_prev=includedir ;;
-  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
-  | --includ=* | --inclu=* | --incl=* | --inc=*)
-    includedir=$ac_optarg ;;
-
-  -infodir | --infodir | --infodi | --infod | --info | --inf)
-    ac_prev=infodir ;;
-  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
-    infodir=$ac_optarg ;;
-
-  -libdir | --libdir | --libdi | --libd)
-    ac_prev=libdir ;;
-  -libdir=* | --libdir=* | --libdi=* | --libd=*)
-    libdir=$ac_optarg ;;
-
-  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
-  | --libexe | --libex | --libe)
-    ac_prev=libexecdir ;;
-  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
-  | --libexe=* | --libex=* | --libe=*)
-    libexecdir=$ac_optarg ;;
-
-  -localedir | --localedir | --localedi | --localed | --locale)
-    ac_prev=localedir ;;
-  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
-    localedir=$ac_optarg ;;
-
-  -localstatedir | --localstatedir | --localstatedi | --localstated \
-  | --localstate | --localstat | --localsta | --localst | --locals)
-    ac_prev=localstatedir ;;
-  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
-  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
-    localstatedir=$ac_optarg ;;
-
-  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
-    ac_prev=mandir ;;
-  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
-    mandir=$ac_optarg ;;
-
-  -nfp | --nfp | --nf)
-    # Obsolete; use --without-fp.
-    with_fp=no ;;
-
-  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
-  | --no-cr | --no-c | -n)
-    no_create=yes ;;
-
-  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
-  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
-    no_recursion=yes ;;
-
-  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
-  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
-  | --oldin | --oldi | --old | --ol | --o)
-    ac_prev=oldincludedir ;;
-  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
-  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
-  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
-    oldincludedir=$ac_optarg ;;
-
-  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
-    ac_prev=prefix ;;
-  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
-    prefix=$ac_optarg ;;
-
-  -program-prefix | --program-prefix | --program-prefi | --program-pref \
-  | --program-pre | --program-pr | --program-p)
-    ac_prev=program_prefix ;;
-  -program-prefix=* | --program-prefix=* | --program-prefi=* \
-  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
-    program_prefix=$ac_optarg ;;
-
-  -program-suffix | --program-suffix | --program-suffi | --program-suff \
-  | --program-suf | --program-su | --program-s)
-    ac_prev=program_suffix ;;
-  -program-suffix=* | --program-suffix=* | --program-suffi=* \
-  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
-    program_suffix=$ac_optarg ;;
-
-  -program-transform-name | --program-transform-name \
-  | --program-transform-nam | --program-transform-na \
-  | --program-transform-n | --program-transform- \
-  | --program-transform | --program-transfor \
-  | --program-transfo | --program-transf \
-  | --program-trans | --program-tran \
-  | --progr-tra | --program-tr | --program-t)
-    ac_prev=program_transform_name ;;
-  -program-transform-name=* | --program-transform-name=* \
-  | --program-transform-nam=* | --program-transform-na=* \
-  | --program-transform-n=* | --program-transform-=* \
-  | --program-transform=* | --program-transfor=* \
-  | --program-transfo=* | --program-transf=* \
-  | --program-trans=* | --program-tran=* \
-  | --progr-tra=* | --program-tr=* | --program-t=*)
-    program_transform_name=$ac_optarg ;;
-
-  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
-    ac_prev=pdfdir ;;
-  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
-    pdfdir=$ac_optarg ;;
-
-  -psdir | --psdir | --psdi | --psd | --ps)
-    ac_prev=psdir ;;
-  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
-    psdir=$ac_optarg ;;
-
-  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-  | -silent | --silent | --silen | --sile | --sil)
-    silent=yes ;;
-
-  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
-    ac_prev=sbindir ;;
-  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
-  | --sbi=* | --sb=*)
-    sbindir=$ac_optarg ;;
-
-  -sharedstatedir | --sharedstatedir | --sharedstatedi \
-  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
-  | --sharedst | --shareds | --shared | --share | --shar \
-  | --sha | --sh)
-    ac_prev=sharedstatedir ;;
-  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
-  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
-  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
-  | --sha=* | --sh=*)
-    sharedstatedir=$ac_optarg ;;
-
-  -site | --site | --sit)
-    ac_prev=site ;;
-  -site=* | --site=* | --sit=*)
-    site=$ac_optarg ;;
-
-  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
-    ac_prev=srcdir ;;
-  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
-    srcdir=$ac_optarg ;;
-
-  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
-  | --syscon | --sysco | --sysc | --sys | --sy)
-    ac_prev=sysconfdir ;;
-  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
-  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
-    sysconfdir=$ac_optarg ;;
-
-  -target | --target | --targe | --targ | --tar | --ta | --t)
-    ac_prev=target_alias ;;
-  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
-    target_alias=$ac_optarg ;;
-
-  -v | -verbose | --verbose | --verbos | --verbo | --verb)
-    verbose=yes ;;
-
-  -version | --version | --versio | --versi | --vers | -V)
-    ac_init_version=: ;;
-
-  -with-* | --with-*)
-    ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid package name: $ac_useropt"
-    ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
-    case $ac_user_opts in
-      *"
-"with_$ac_useropt"
-"*) ;;
-      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig"
-	 ac_unrecognized_sep=', ';;
-    esac
-    eval with_$ac_useropt=\$ac_optarg ;;
-
-  -without-* | --without-*)
-    ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error "invalid package name: $ac_useropt"
-    ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
-    case $ac_user_opts in
-      *"
-"with_$ac_useropt"
-"*) ;;
-      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig"
-	 ac_unrecognized_sep=', ';;
-    esac
-    eval with_$ac_useropt=no ;;
-
-  --x)
-    # Obsolete; use --with-x.
-    with_x=yes ;;
-
-  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
-  | --x-incl | --x-inc | --x-in | --x-i)
-    ac_prev=x_includes ;;
-  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
-  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
-    x_includes=$ac_optarg ;;
-
-  -x-libraries | --x-libraries | --x-librarie | --x-librari \
-  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
-    ac_prev=x_libraries ;;
-  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
-  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
-    x_libraries=$ac_optarg ;;
-
-  -*) as_fn_error "unrecognized option: \`$ac_option'
-Try \`$0 --help' for more information."
-    ;;
-
-  *=*)
-    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
-    # Reject names that are not valid shell variable names.
-    case $ac_envvar in #(
-      '' | [0-9]* | *[!_$as_cr_alnum]* )
-      as_fn_error "invalid variable name: \`$ac_envvar'" ;;
-    esac
-    eval $ac_envvar=\$ac_optarg
-    export $ac_envvar ;;
-
-  *)
-    # FIXME: should be removed in autoconf 3.0.
-    $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
-    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
-      $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
-    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
-    ;;
-
-  esac
-done
-
-if test -n "$ac_prev"; then
-  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
-  as_fn_error "missing argument to $ac_option"
-fi
-
-if test -n "$ac_unrecognized_opts"; then
-  case $enable_option_checking in
-    no) ;;
-    fatal) as_fn_error "unrecognized options: $ac_unrecognized_opts" ;;
-    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
-  esac
-fi
-
-# Check all directory arguments for consistency.
-for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
-		datadir sysconfdir sharedstatedir localstatedir includedir \
-		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
-		libdir localedir mandir
-do
-  eval ac_val=\$$ac_var
-  # Remove trailing slashes.
-  case $ac_val in
-    */ )
-      ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
-      eval $ac_var=\$ac_val;;
-  esac
-  # Be sure to have absolute directory names.
-  case $ac_val in
-    [\\/$]* | ?:[\\/]* )  continue;;
-    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
-  esac
-  as_fn_error "expected an absolute directory name for --$ac_var: $ac_val"
-done
-
-# There might be people who depend on the old broken behavior: `$host'
-# used to hold the argument of --host etc.
-# FIXME: To remove some day.
-build=$build_alias
-host=$host_alias
-target=$target_alias
-
-# FIXME: To remove some day.
-if test "x$host_alias" != x; then
-  if test "x$build_alias" = x; then
-    cross_compiling=maybe
-    $as_echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
-    If a cross compiler is detected then cross compile mode will be used." >&2
-  elif test "x$build_alias" != "x$host_alias"; then
-    cross_compiling=yes
-  fi
-fi
-
-ac_tool_prefix=
-test -n "$host_alias" && ac_tool_prefix=$host_alias-
-
-test "$silent" = yes && exec 6>/dev/null
-
-
-ac_pwd=`pwd` && test -n "$ac_pwd" &&
-ac_ls_di=`ls -di .` &&
-ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
-  as_fn_error "working directory cannot be determined"
-test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
-  as_fn_error "pwd does not report name of working directory"
-
-
-# Find the source files, if location was not specified.
-if test -z "$srcdir"; then
-  ac_srcdir_defaulted=yes
-  # Try the directory containing this script, then the parent directory.
-  ac_confdir=`$as_dirname -- "$as_myself" ||
-$as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_myself" : 'X\(//\)[^/]' \| \
-	 X"$as_myself" : 'X\(//\)$' \| \
-	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_myself" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-  srcdir=$ac_confdir
-  if test ! -r "$srcdir/$ac_unique_file"; then
-    srcdir=..
-  fi
-else
-  ac_srcdir_defaulted=no
-fi
-if test ! -r "$srcdir/$ac_unique_file"; then
-  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
-  as_fn_error "cannot find sources ($ac_unique_file) in $srcdir"
-fi
-ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
-ac_abs_confdir=`(
-	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error "$ac_msg"
-	pwd)`
-# When building in place, set srcdir=.
-if test "$ac_abs_confdir" = "$ac_pwd"; then
-  srcdir=.
-fi
-# Remove unnecessary trailing slashes from srcdir.
-# Double slashes in file names in object file debugging info
-# mess up M-x gdb in Emacs.
-case $srcdir in
-*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
-esac
-for ac_var in $ac_precious_vars; do
-  eval ac_env_${ac_var}_set=\${${ac_var}+set}
-  eval ac_env_${ac_var}_value=\$${ac_var}
-  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
-  eval ac_cv_env_${ac_var}_value=\$${ac_var}
-done
-
-#
-# Report the --help message.
-#
-if test "$ac_init_help" = "long"; then
-  # Omit some internal or obsolete options to make the list less imposing.
-  # This message is too long to be a string in the A/UX 3.1 sh.
-  cat <<_ACEOF
-\`configure' configures this package to adapt to many kinds of systems.
-
-Usage: $0 [OPTION]... [VAR=VALUE]...
-
-To assign environment variables (e.g., CC, CFLAGS...), specify them as
-VAR=VALUE.  See below for descriptions of some of the useful variables.
-
-Defaults for the options are specified in brackets.
-
-Configuration:
-  -h, --help              display this help and exit
-      --help=short        display options specific to this package
-      --help=recursive    display the short help of all the included packages
-  -V, --version           display version information and exit
-  -q, --quiet, --silent   do not print \`checking...' messages
-      --cache-file=FILE   cache test results in FILE [disabled]
-  -C, --config-cache      alias for \`--cache-file=config.cache'
-  -n, --no-create         do not create output files
-      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
-
-Installation directories:
-  --prefix=PREFIX         install architecture-independent files in PREFIX
-                          [$ac_default_prefix]
-  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
-                          [PREFIX]
-
-By default, \`make install' will install all the files in
-\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
-an installation prefix other than \`$ac_default_prefix' using \`--prefix',
-for instance \`--prefix=\$HOME'.
-
-For better control, use the options below.
-
-Fine tuning of the installation directories:
-  --bindir=DIR            user executables [EPREFIX/bin]
-  --sbindir=DIR           system admin executables [EPREFIX/sbin]
-  --libexecdir=DIR        program executables [EPREFIX/libexec]
-  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
-  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
-  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
-  --libdir=DIR            object code libraries [EPREFIX/lib]
-  --includedir=DIR        C header files [PREFIX/include]
-  --oldincludedir=DIR     C header files for non-gcc [/usr/include]
-  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]
-  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]
-  --infodir=DIR           info documentation [DATAROOTDIR/info]
-  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
-  --mandir=DIR            man documentation [DATAROOTDIR/man]
-  --docdir=DIR            documentation root [DATAROOTDIR/doc/PACKAGE]
-  --htmldir=DIR           html documentation [DOCDIR]
-  --dvidir=DIR            dvi documentation [DOCDIR]
-  --pdfdir=DIR            pdf documentation [DOCDIR]
-  --psdir=DIR             ps documentation [DOCDIR]
-_ACEOF
-
-  cat <<\_ACEOF
-
-Program names:
-  --program-prefix=PREFIX            prepend PREFIX to installed program names
-  --program-suffix=SUFFIX            append SUFFIX to installed program names
-  --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
-
-System types:
-  --build=BUILD     configure for building on BUILD [guessed]
-  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
-  --target=TARGET   configure for building compilers for TARGET [HOST]
-_ACEOF
-fi
-
-if test -n "$ac_init_help"; then
-
-  cat <<\_ACEOF
-
-Optional Features:
-  --disable-option-checking  ignore unrecognized --enable/--with options
-  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
-  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
-  --enable-multilib       build many library versions (default)
-  --enable-maintainer-mode  enable make rules and dependencies not useful
-			  (and sometimes confusing) to the casual installer
-  --disable-dependency-tracking  speeds up one-time build
-  --enable-dependency-tracking   do not reject slow dependency extractors
-  --enable-shared[=PKGS]  build shared libraries [default=yes]
-  --enable-static[=PKGS]  build static libraries [default=yes]
-  --enable-fast-install[=PKGS]
-                          optimize for fast installation [default=yes]
-  --disable-libtool-lock  avoid locking (might break parallel builds)
-
-Optional Packages:
-  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
-  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
-  --with-target-subdir=SUBDIR
-                          configuring in a subdirectory
-  --with-cross-host=HOST  configuring with a cross compiler
-  --with-system-zlib      use installed libz
-  --with-pic              try to use only PIC/non-PIC objects [default=use
-                          both]
-  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]
-
-Some influential environment variables:
-  CC          C compiler command
-  CFLAGS      C compiler flags
-  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
-              nonstandard directory <lib dir>
-  LIBS        libraries to pass to the linker, e.g. -l<library>
-  CPPFLAGS    C/C++/Objective C preprocessor flags, e.g. -I<include dir> if
-              you have headers in a nonstandard directory <include dir>
-  CPP         C preprocessor
-
-Use these variables to override the choices made by `configure' or to help
-it to find libraries and programs with nonstandard names/locations.
-
-Report bugs to the package provider.
-_ACEOF
-ac_status=$?
-fi
-
-if test "$ac_init_help" = "recursive"; then
-  # If there are subdirs, report their specific --help.
-  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
-    test -d "$ac_dir" ||
-      { cd "$srcdir" && ac_pwd=`pwd` && srcdir=. && test -d "$ac_dir"; } ||
-      continue
-    ac_builddir=.
-
-case "$ac_dir" in
-.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
-*)
-  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
-  # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
-  case $ac_top_builddir_sub in
-  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
-  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
-  esac ;;
-esac
-ac_abs_top_builddir=$ac_pwd
-ac_abs_builddir=$ac_pwd$ac_dir_suffix
-# for backward compatibility:
-ac_top_builddir=$ac_top_build_prefix
-
-case $srcdir in
-  .)  # We are building in place.
-    ac_srcdir=.
-    ac_top_srcdir=$ac_top_builddir_sub
-    ac_abs_top_srcdir=$ac_pwd ;;
-  [\\/]* | ?:[\\/]* )  # Absolute name.
-    ac_srcdir=$srcdir$ac_dir_suffix;
-    ac_top_srcdir=$srcdir
-    ac_abs_top_srcdir=$srcdir ;;
-  *) # Relative name.
-    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
-    ac_top_srcdir=$ac_top_build_prefix$srcdir
-    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
-esac
-ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
-
-    cd "$ac_dir" || { ac_status=$?; continue; }
-    # Check for guested configure.
-    if test -f "$ac_srcdir/configure.gnu"; then
-      echo &&
-      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
-    elif test -f "$ac_srcdir/configure"; then
-      echo &&
-      $SHELL "$ac_srcdir/configure" --help=recursive
-    else
-      $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
-    fi || ac_status=$?
-    cd "$ac_pwd" || { ac_status=$?; break; }
-  done
-fi
-
-test -n "$ac_init_help" && exit $ac_status
-if $ac_init_version; then
-  cat <<\_ACEOF
-configure
-generated by GNU Autoconf 2.64
-
-Copyright (C) 2009 Free Software Foundation, Inc.
-This configure script is free software; the Free Software Foundation
-gives unlimited permission to copy, distribute and modify it.
-_ACEOF
-  exit
-fi
-
-## ------------------------ ##
-## Autoconf initialization. ##
-## ------------------------ ##
-
-# ac_fn_c_try_compile LINENO
-# --------------------------
-# Try to compile conftest.$ac_ext, and return whether this succeeded.
-ac_fn_c_try_compile ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext
-  if { { ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compile") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_retval=1
-fi
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-  return $ac_retval
-
-} # ac_fn_c_try_compile
-
-# ac_fn_c_try_link LINENO
-# -----------------------
-# Try to link conftest.$ac_ext, and return whether this succeeded.
-ac_fn_c_try_link ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext conftest$ac_exeext
-  if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_retval=1
-fi
-  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
-  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
-  # interfere with the next link command; also delete a directory that is
-  # left behind by Apple's compiler.  We do this before executing the actions.
-  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-  return $ac_retval
-
-} # ac_fn_c_try_link
-
-# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
-# -------------------------------------------------------
-# Tests whether HEADER exists and can be compiled using the include files in
-# INCLUDES, setting the cache variable VAR accordingly.
-ac_fn_c_check_header_compile ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-#include <$2>
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  eval "$3=yes"
-else
-  eval "$3=no"
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-
-} # ac_fn_c_check_header_compile
-
-# ac_fn_c_try_cpp LINENO
-# ----------------------
-# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
-ac_fn_c_try_cpp ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { { ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-    ac_retval=1
-fi
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-  return $ac_retval
-
-} # ac_fn_c_try_cpp
-
-# ac_fn_c_try_run LINENO
-# ----------------------
-# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
-# that executables *can* be run.
-ac_fn_c_try_run ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
-  { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-       $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-       ac_retval=$ac_status
-fi
-  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-  return $ac_retval
-
-} # ac_fn_c_try_run
-
-# ac_fn_c_check_func LINENO FUNC VAR
-# ----------------------------------
-# Tests whether FUNC exists, setting the cache variable VAR accordingly
-ac_fn_c_check_func ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-/* Define $2 to an innocuous variant, in case <limits.h> declares $2.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $2 innocuous_$2
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $2 (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $2
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $2 ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$2 || defined __stub___$2
-choke me
-#endif
-
-int
-main ()
-{
-return $2 ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  eval "$3=yes"
-else
-  eval "$3=no"
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-
-} # ac_fn_c_check_func
-
-# ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES
-# -------------------------------------------------------
-# Tests whether HEADER exists, giving a warning if it cannot be compiled using
-# the include files in INCLUDES and setting the cache variable VAR
-# accordingly.
-ac_fn_c_check_header_mongrel ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
-  $as_echo_n "(cached) " >&6
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 usability" >&5
-$as_echo_n "checking $2 usability... " >&6; }
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-#include <$2>
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_header_compiler=yes
-else
-  ac_header_compiler=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 presence" >&5
-$as_echo_n "checking $2 presence... " >&6; }
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <$2>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  ac_header_preproc=yes
-else
-  ac_header_preproc=no
-fi
-rm -f conftest.err conftest.$ac_ext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in #((
-  yes:no: )
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $2: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $2:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $2: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
-    ;;
-esac
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
-  $as_echo_n "(cached) " >&6
-else
-  eval "$3=\$ac_header_compiler"
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-fi
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-
-} # ac_fn_c_check_header_mongrel
-cat >config.log <<_ACEOF
-This file contains any messages produced by compilers while
-running configure, to aid debugging if configure makes a mistake.
-
-It was created by $as_me, which was
-generated by GNU Autoconf 2.64.  Invocation command line was
-
-  $ $0 $@
-
-_ACEOF
-exec 5>>config.log
-{
-cat <<_ASUNAME
-## --------- ##
-## Platform. ##
-## --------- ##
-
-hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
-uname -m = `(uname -m) 2>/dev/null || echo unknown`
-uname -r = `(uname -r) 2>/dev/null || echo unknown`
-uname -s = `(uname -s) 2>/dev/null || echo unknown`
-uname -v = `(uname -v) 2>/dev/null || echo unknown`
-
-/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
-/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
-
-/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
-/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
-/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
-/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
-/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
-/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
-/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
-
-_ASUNAME
-
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    $as_echo "PATH: $as_dir"
-  done
-IFS=$as_save_IFS
-
-} >&5
-
-cat >&5 <<_ACEOF
-
-
-## ----------- ##
-## Core tests. ##
-## ----------- ##
-
-_ACEOF
-
-
-# Keep a trace of the command line.
-# Strip out --no-create and --no-recursion so they do not pile up.
-# Strip out --silent because we don't want to record it for future runs.
-# Also quote any args containing shell meta-characters.
-# Make two passes to allow for proper duplicate-argument suppression.
-ac_configure_args=
-ac_configure_args0=
-ac_configure_args1=
-ac_must_keep_next=false
-for ac_pass in 1 2
-do
-  for ac_arg
-  do
-    case $ac_arg in
-    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
-    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-    | -silent | --silent | --silen | --sile | --sil)
-      continue ;;
-    *\'*)
-      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
-    esac
-    case $ac_pass in
-    1) as_fn_append ac_configure_args0 " '$ac_arg'" ;;
-    2)
-      as_fn_append ac_configure_args1 " '$ac_arg'"
-      if test $ac_must_keep_next = true; then
-	ac_must_keep_next=false # Got value, back to normal.
-      else
-	case $ac_arg in
-	  *=* | --config-cache | -C | -disable-* | --disable-* \
-	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
-	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
-	  | -with-* | --with-* | -without-* | --without-* | --x)
-	    case "$ac_configure_args0 " in
-	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
-	    esac
-	    ;;
-	  -* ) ac_must_keep_next=true ;;
-	esac
-      fi
-      as_fn_append ac_configure_args " '$ac_arg'"
-      ;;
-    esac
-  done
-done
-{ ac_configure_args0=; unset ac_configure_args0;}
-{ ac_configure_args1=; unset ac_configure_args1;}
-
-# When interrupted or exit'd, cleanup temporary files, and complete
-# config.log.  We remove comments because anyway the quotes in there
-# would cause problems or look ugly.
-# WARNING: Use '\'' to represent an apostrophe within the trap.
-# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
-trap 'exit_status=$?
-  # Save into config.log some information that might help in debugging.
-  {
-    echo
-
-    cat <<\_ASBOX
-## ---------------- ##
-## Cache variables. ##
-## ---------------- ##
-_ASBOX
-    echo
-    # The following way of writing the cache mishandles newlines in values,
-(
-  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
-    eval ac_val=\$$ac_var
-    case $ac_val in #(
-    *${as_nl}*)
-      case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
-$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
-      esac
-      case $ac_var in #(
-      _ | IFS | as_nl) ;; #(
-      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
-      *) { eval $ac_var=; unset $ac_var;} ;;
-      esac ;;
-    esac
-  done
-  (set) 2>&1 |
-    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
-    *${as_nl}ac_space=\ *)
-      sed -n \
-	"s/'\''/'\''\\\\'\'''\''/g;
-	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
-      ;; #(
-    *)
-      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
-      ;;
-    esac |
-    sort
-)
-    echo
-
-    cat <<\_ASBOX
-## ----------------- ##
-## Output variables. ##
-## ----------------- ##
-_ASBOX
-    echo
-    for ac_var in $ac_subst_vars
-    do
-      eval ac_val=\$$ac_var
-      case $ac_val in
-      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
-      esac
-      $as_echo "$ac_var='\''$ac_val'\''"
-    done | sort
-    echo
-
-    if test -n "$ac_subst_files"; then
-      cat <<\_ASBOX
-## ------------------- ##
-## File substitutions. ##
-## ------------------- ##
-_ASBOX
-      echo
-      for ac_var in $ac_subst_files
-      do
-	eval ac_val=\$$ac_var
-	case $ac_val in
-	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
-	esac
-	$as_echo "$ac_var='\''$ac_val'\''"
-      done | sort
-      echo
-    fi
-
-    if test -s confdefs.h; then
-      cat <<\_ASBOX
-## ----------- ##
-## confdefs.h. ##
-## ----------- ##
-_ASBOX
-      echo
-      cat confdefs.h
-      echo
-    fi
-    test "$ac_signal" != 0 &&
-      $as_echo "$as_me: caught signal $ac_signal"
-    $as_echo "$as_me: exit $exit_status"
-  } >&5
-  rm -f core *.core core.conftest.* &&
-    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
-    exit $exit_status
-' 0
-for ac_signal in 1 2 13 15; do
-  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal
-done
-ac_signal=0
-
-# confdefs.h avoids OS command line length limits that DEFS can exceed.
-rm -f -r conftest* confdefs.h
-
-$as_echo "/* confdefs.h */" > confdefs.h
-
-# Predefined preprocessor variables.
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_NAME "$PACKAGE_NAME"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_VERSION "$PACKAGE_VERSION"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_STRING "$PACKAGE_STRING"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_URL "$PACKAGE_URL"
-_ACEOF
-
-
-# Let the site file select an alternate cache file if it wants to.
-# Prefer an explicitly selected file to automatically selected ones.
-ac_site_file1=NONE
-ac_site_file2=NONE
-if test -n "$CONFIG_SITE"; then
-  ac_site_file1=$CONFIG_SITE
-elif test "x$prefix" != xNONE; then
-  ac_site_file1=$prefix/share/config.site
-  ac_site_file2=$prefix/etc/config.site
-else
-  ac_site_file1=$ac_default_prefix/share/config.site
-  ac_site_file2=$ac_default_prefix/etc/config.site
-fi
-for ac_site_file in "$ac_site_file1" "$ac_site_file2"
-do
-  test "x$ac_site_file" = xNONE && continue
-  if test -r "$ac_site_file"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
-$as_echo "$as_me: loading site script $ac_site_file" >&6;}
-    sed 's/^/| /' "$ac_site_file" >&5
-    . "$ac_site_file"
-  fi
-done
-
-if test -r "$cache_file"; then
-  # Some versions of bash will fail to source /dev/null (special
-  # files actually), so we avoid doing that.
-  if test -f "$cache_file"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
-$as_echo "$as_me: loading cache $cache_file" >&6;}
-    case $cache_file in
-      [\\/]* | ?:[\\/]* ) . "$cache_file";;
-      *)                      . "./$cache_file";;
-    esac
-  fi
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
-$as_echo "$as_me: creating cache $cache_file" >&6;}
-  >$cache_file
-fi
-
-# Check that the precious variables saved in the cache have kept the same
-# value.
-ac_cache_corrupted=false
-for ac_var in $ac_precious_vars; do
-  eval ac_old_set=\$ac_cv_env_${ac_var}_set
-  eval ac_new_set=\$ac_env_${ac_var}_set
-  eval ac_old_val=\$ac_cv_env_${ac_var}_value
-  eval ac_new_val=\$ac_env_${ac_var}_value
-  case $ac_old_set,$ac_new_set in
-    set,)
-      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
-$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
-      ac_cache_corrupted=: ;;
-    ,set)
-      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
-$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
-      ac_cache_corrupted=: ;;
-    ,);;
-    *)
-      if test "x$ac_old_val" != "x$ac_new_val"; then
-	# differences in whitespace do not lead to failure.
-	ac_old_val_w=`echo x $ac_old_val`
-	ac_new_val_w=`echo x $ac_new_val`
-	if test "$ac_old_val_w" != "$ac_new_val_w"; then
-	  { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
-$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
-	  ac_cache_corrupted=:
-	else
-	  { $as_echo "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
-$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
-	  eval $ac_var=\$ac_old_val
-	fi
-	{ $as_echo "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
-$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
-	{ $as_echo "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
-$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
-      fi;;
-  esac
-  # Pass precious variables to config.status.
-  if test "$ac_new_set" = set; then
-    case $ac_new_val in
-    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
-    *) ac_arg=$ac_var=$ac_new_val ;;
-    esac
-    case " $ac_configure_args " in
-      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
-      *) as_fn_append ac_configure_args " '$ac_arg'" ;;
-    esac
-  fi
-done
-if $ac_cache_corrupted; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-  { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
-$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
-  as_fn_error "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
-fi
-## -------------------- ##
-## Main body of script. ##
-## -------------------- ##
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-
-
-
-
-
-# Default to --enable-multilib
-# Check whether --enable-multilib was given.
-if test "${enable_multilib+set}" = set; then :
-  enableval=$enable_multilib; case "$enableval" in
-  yes) multilib=yes ;;
-  no)  multilib=no ;;
-  *)   as_fn_error "bad value $enableval for multilib option" "$LINENO" 5 ;;
- esac
-else
-  multilib=yes
-fi
-
-
-# We may get other options which we leave undocumented:
-# --with-target-subdir, --with-multisrctop, --with-multisubdir
-# See config-ml.in if you want the gory details.
-
-if test "$srcdir" = "."; then
-  if test "$with_target_subdir" != "."; then
-    multi_basedir="$srcdir/$with_multisrctop../.."
-  else
-    multi_basedir="$srcdir/$with_multisrctop.."
-  fi
-else
-  multi_basedir="$srcdir/.."
-fi
-
-
-# Even if the default multilib is not a cross compilation,
-# it may be that some of the other multilibs are.
-if test $cross_compiling = no && test $multilib = yes \
-   && test "x${with_multisubdir}" != x ; then
-   cross_compiling=maybe
-fi
-
-ac_config_commands="$ac_config_commands default-1"
-
-
-ac_aux_dir=
-for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
-  for ac_t in install-sh install.sh shtool; do
-    if test -f "$ac_dir/$ac_t"; then
-      ac_aux_dir=$ac_dir
-      ac_install_sh="$ac_aux_dir/$ac_t -c"
-      break 2
-    fi
-  done
-done
-if test -z "$ac_aux_dir"; then
-  as_fn_error "cannot find install-sh, install.sh, or shtool in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" "$LINENO" 5
-fi
-
-# These three variables are undocumented and unsupported,
-# and are intended to be withdrawn in a future Autoconf release.
-# They can cause serious problems if a builder's source tree is in a directory
-# whose full name contains unusual characters.
-ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
-ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
-ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
-
-
-# Make sure we can run config.sub.
-$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
-  as_fn_error "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
-$as_echo_n "checking build system type... " >&6; }
-if test "${ac_cv_build+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_build_alias=$build_alias
-test "x$ac_build_alias" = x &&
-  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
-test "x$ac_build_alias" = x &&
-  as_fn_error "cannot guess build type; you must specify one" "$LINENO" 5
-ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
-  as_fn_error "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
-$as_echo "$ac_cv_build" >&6; }
-case $ac_cv_build in
-*-*-*) ;;
-*) as_fn_error "invalid value of canonical build" "$LINENO" 5;;
-esac
-build=$ac_cv_build
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_build
-shift
-build_cpu=$1
-build_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-build_os=$*
-IFS=$ac_save_IFS
-case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
-$as_echo_n "checking host system type... " >&6; }
-if test "${ac_cv_host+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test "x$host_alias" = x; then
-  ac_cv_host=$ac_cv_build
-else
-  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
-    as_fn_error "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
-$as_echo "$ac_cv_host" >&6; }
-case $ac_cv_host in
-*-*-*) ;;
-*) as_fn_error "invalid value of canonical host" "$LINENO" 5;;
-esac
-host=$ac_cv_host
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_host
-shift
-host_cpu=$1
-host_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-host_os=$*
-IFS=$ac_save_IFS
-case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking target system type" >&5
-$as_echo_n "checking target system type... " >&6; }
-if test "${ac_cv_target+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test "x$target_alias" = x; then
-  ac_cv_target=$ac_cv_host
-else
-  ac_cv_target=`$SHELL "$ac_aux_dir/config.sub" $target_alias` ||
-    as_fn_error "$SHELL $ac_aux_dir/config.sub $target_alias failed" "$LINENO" 5
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_target" >&5
-$as_echo "$ac_cv_target" >&6; }
-case $ac_cv_target in
-*-*-*) ;;
-*) as_fn_error "invalid value of canonical target" "$LINENO" 5;;
-esac
-target=$ac_cv_target
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_target
-shift
-target_cpu=$1
-target_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-target_os=$*
-IFS=$ac_save_IFS
-case $target_os in *\ *) target_os=`echo "$target_os" | sed 's/ /-/g'`;; esac
-
-
-# The aliases save the names the user supplied, while $host etc.
-# will get canonicalized.
-test -n "$target_alias" &&
-  test "$program_prefix$program_suffix$program_transform_name" = \
-    NONENONEs,x,x, &&
-  program_prefix=${target_alias}-
-
-
-# This works around an automake problem.
-mkinstalldirs="`cd $ac_aux_dir && ${PWDCMD-pwd}`/mkinstalldirs"
-
-
-am__api_version='1.11'
-
-# Find a good install program.  We prefer a C program (faster),
-# so one script is as good as another.  But avoid the broken or
-# incompatible versions:
-# SysV /etc/install, /usr/sbin/install
-# SunOS /usr/etc/install
-# IRIX /sbin/install
-# AIX /bin/install
-# AmigaOS /C/install, which installs bootblocks on floppy discs
-# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
-# AFS /usr/afsws/bin/install, which mishandles nonexistent args
-# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
-# OS/2's system install, which has a completely different semantic
-# ./install, which can be erroneously created by make from ./install.sh.
-# Reject install programs that cannot install multiple files.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a BSD-compatible install" >&5
-$as_echo_n "checking for a BSD-compatible install... " >&6; }
-if test -z "$INSTALL"; then
-if test "${ac_cv_path_install+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    # Account for people who put trailing slashes in PATH elements.
-case $as_dir/ in #((
-  ./ | .// | /[cC]/* | \
-  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
-  ?:[\\/]os2[\\/]install[\\/]* | ?:[\\/]OS2[\\/]INSTALL[\\/]* | \
-  /usr/ucb/* ) ;;
-  *)
-    # OSF1 and SCO ODT 3.0 have their own names for install.
-    # Don't use installbsd from OSF since it installs stuff as root
-    # by default.
-    for ac_prog in ginstall scoinst install; do
-      for ac_exec_ext in '' $ac_executable_extensions; do
-	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
-	  if test $ac_prog = install &&
-	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
-	    # AIX install.  It has an incompatible calling convention.
-	    :
-	  elif test $ac_prog = install &&
-	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
-	    # program-specific install script used by HP pwplus--don't use.
-	    :
-	  else
-	    rm -rf conftest.one conftest.two conftest.dir
-	    echo one > conftest.one
-	    echo two > conftest.two
-	    mkdir conftest.dir
-	    if "$as_dir/$ac_prog$ac_exec_ext" -c conftest.one conftest.two "`pwd`/conftest.dir" &&
-	      test -s conftest.one && test -s conftest.two &&
-	      test -s conftest.dir/conftest.one &&
-	      test -s conftest.dir/conftest.two
-	    then
-	      ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
-	      break 3
-	    fi
-	  fi
-	fi
-      done
-    done
-    ;;
-esac
-
-  done
-IFS=$as_save_IFS
-
-rm -rf conftest.one conftest.two conftest.dir
-
-fi
-  if test "${ac_cv_path_install+set}" = set; then
-    INSTALL=$ac_cv_path_install
-  else
-    # As a last resort, use the slow shell script.  Don't cache a
-    # value for INSTALL within a source directory, because that will
-    # break other packages using the cache if that directory is
-    # removed, or if the value is a relative name.
-    INSTALL=$ac_install_sh
-  fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $INSTALL" >&5
-$as_echo "$INSTALL" >&6; }
-
-# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
-# It thinks the first close brace ends the variable substitution.
-test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
-
-test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
-
-test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether build environment is sane" >&5
-$as_echo_n "checking whether build environment is sane... " >&6; }
-# Just in case
-sleep 1
-echo timestamp > conftest.file
-# Reject unsafe characters in $srcdir or the absolute working directory
-# name.  Accept space and tab only in the latter.
-am_lf='
-'
-case `pwd` in
-  *[\\\"\#\$\&\'\`$am_lf]*)
-    as_fn_error "unsafe absolute working directory name" "$LINENO" 5;;
-esac
-case $srcdir in
-  *[\\\"\#\$\&\'\`$am_lf\ \	]*)
-    as_fn_error "unsafe srcdir value: \`$srcdir'" "$LINENO" 5;;
-esac
-
-# Do `set' in a subshell so we don't clobber the current shell's
-# arguments.  Must try -L first in case configure is actually a
-# symlink; some systems play weird games with the mod time of symlinks
-# (eg FreeBSD returns the mod time of the symlink's containing
-# directory).
-if (
-   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
-   if test "$*" = "X"; then
-      # -L didn't work.
-      set X `ls -t "$srcdir/configure" conftest.file`
-   fi
-   rm -f conftest.file
-   if test "$*" != "X $srcdir/configure conftest.file" \
-      && test "$*" != "X conftest.file $srcdir/configure"; then
-
-      # If neither matched, then we have a broken ls.  This can happen
-      # if, for instance, CONFIG_SHELL is bash and it inherits a
-      # broken ls alias from the environment.  This has actually
-      # happened.  Such a system could not be considered "sane".
-      as_fn_error "ls -t appears to fail.  Make sure there is not a broken
-alias in your environment" "$LINENO" 5
-   fi
-
-   test "$2" = conftest.file
-   )
-then
-   # Ok.
-   :
-else
-   as_fn_error "newly created file is older than distributed files!
-Check your system clock" "$LINENO" 5
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-test "$program_prefix" != NONE &&
-  program_transform_name="s&^&$program_prefix&;$program_transform_name"
-# Use a double $ so make ignores it.
-test "$program_suffix" != NONE &&
-  program_transform_name="s&\$&$program_suffix&;$program_transform_name"
-# Double any \ or $.
-# By default was `s,x,x', remove it if useless.
-ac_script='s/[\\$]/&&/g;s/;s,x,x,$//'
-program_transform_name=`$as_echo "$program_transform_name" | sed "$ac_script"`
-
-# expand $ac_aux_dir to an absolute path
-am_aux_dir=`cd $ac_aux_dir && pwd`
-
-if test x"${MISSING+set}" != xset; then
-  case $am_aux_dir in
-  *\ * | *\	*)
-    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
-  *)
-    MISSING="\${SHELL} $am_aux_dir/missing" ;;
-  esac
-fi
-# Use eval to expand $SHELL
-if eval "$MISSING --run true"; then
-  am_missing_run="$MISSING --run "
-else
-  am_missing_run=
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`missing' script is too old or missing" >&5
-$as_echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
-fi
-
-if test x"${install_sh}" != xset; then
-  case $am_aux_dir in
-  *\ * | *\	*)
-    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
-  *)
-    install_sh="\${SHELL} $am_aux_dir/install-sh"
-  esac
-fi
-
-# Installed binaries are usually stripped using `strip' when the user
-# run `make install-strip'.  However `strip' might not be the right
-# tool to use in cross-compilation environments, therefore Automake
-# will honor the `STRIP' environment variable to overrule this program.
-if test "$cross_compiling" != no; then
-  if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
-set dummy ${ac_tool_prefix}strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_STRIP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$STRIP"; then
-  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-STRIP=$ac_cv_prog_STRIP
-if test -n "$STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
-$as_echo "$STRIP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_STRIP"; then
-  ac_ct_STRIP=$STRIP
-  # Extract the first word of "strip", so it can be a program name with args.
-set dummy strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_STRIP"; then
-  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_STRIP="strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
-if test -n "$ac_ct_STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
-$as_echo "$ac_ct_STRIP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_STRIP" = x; then
-    STRIP=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    STRIP=$ac_ct_STRIP
-  fi
-else
-  STRIP="$ac_cv_prog_STRIP"
-fi
-
-fi
-INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a thread-safe mkdir -p" >&5
-$as_echo_n "checking for a thread-safe mkdir -p... " >&6; }
-if test -z "$MKDIR_P"; then
-  if test "${ac_cv_path_mkdir+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/opt/sfw/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in mkdir gmkdir; do
-	 for ac_exec_ext in '' $ac_executable_extensions; do
-	   { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; } || continue
-	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
-	     'mkdir (GNU coreutils) '* | \
-	     'mkdir (coreutils) '* | \
-	     'mkdir (fileutils) '4.1*)
-	       ac_cv_path_mkdir=$as_dir/$ac_prog$ac_exec_ext
-	       break 3;;
-	   esac
-	 done
-       done
-  done
-IFS=$as_save_IFS
-
-fi
-
-  if test "${ac_cv_path_mkdir+set}" = set; then
-    MKDIR_P="$ac_cv_path_mkdir -p"
-  else
-    # As a last resort, use the slow shell script.  Don't cache a
-    # value for MKDIR_P within a source directory, because that will
-    # break other packages using the cache if that directory is
-    # removed, or if the value is a relative name.
-    test -d ./--version && rmdir ./--version
-    MKDIR_P="$ac_install_sh -d"
-  fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $MKDIR_P" >&5
-$as_echo "$MKDIR_P" >&6; }
-
-mkdir_p="$MKDIR_P"
-case $mkdir_p in
-  [\\/$]* | ?:[\\/]*) ;;
-  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
-esac
-
-for ac_prog in gawk mawk nawk awk
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_AWK+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$AWK"; then
-  ac_cv_prog_AWK="$AWK" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_AWK="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-AWK=$ac_cv_prog_AWK
-if test -n "$AWK"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AWK" >&5
-$as_echo "$AWK" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$AWK" && break
-done
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} sets \$(MAKE)" >&5
-$as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
-set x ${MAKE-make}
-ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
-if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.make <<\_ACEOF
-SHELL = /bin/sh
-all:
-	@echo '@@@%%%=$(MAKE)=@@@%%%'
-_ACEOF
-# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
-case `${MAKE-make} -f conftest.make 2>/dev/null` in
-  *@@@%%%=?*=@@@%%%*)
-    eval ac_cv_prog_make_${ac_make}_set=yes;;
-  *)
-    eval ac_cv_prog_make_${ac_make}_set=no;;
-esac
-rm -f conftest.make
-fi
-if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-  SET_MAKE=
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-  SET_MAKE="MAKE=${MAKE-make}"
-fi
-
-rm -rf .tst 2>/dev/null
-mkdir .tst 2>/dev/null
-if test -d .tst; then
-  am__leading_dot=.
-else
-  am__leading_dot=_
-fi
-rmdir .tst 2>/dev/null
-
-if test "`cd $srcdir && pwd`" != "`pwd`"; then
-  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
-  # is not polluted with repeated "-I."
-  am__isrc=' -I$(srcdir)'
-  # test to see if srcdir already configured
-  if test -f $srcdir/config.status; then
-    as_fn_error "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
-  fi
-fi
-
-# test whether we have cygpath
-if test -z "$CYGPATH_W"; then
-  if (cygpath --version) >/dev/null 2>/dev/null; then
-    CYGPATH_W='cygpath -w'
-  else
-    CYGPATH_W=echo
-  fi
-fi
-
-
-# Define the identity of the package.
- PACKAGE=zlib
- VERSION=1.1.4
-
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE "$PACKAGE"
-_ACEOF
-
-
-cat >>confdefs.h <<_ACEOF
-#define VERSION "$VERSION"
-_ACEOF
-
-# Some tools Automake needs.
-
-ACLOCAL=${ACLOCAL-"${am_missing_run}aclocal-${am__api_version}"}
-
-
-AUTOCONF=${AUTOCONF-"${am_missing_run}autoconf"}
-
-
-AUTOMAKE=${AUTOMAKE-"${am_missing_run}automake-${am__api_version}"}
-
-
-AUTOHEADER=${AUTOHEADER-"${am_missing_run}autoheader"}
-
-
-MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
-
-# We need awk for the "check" target.  The system "awk" is bad on
-# some platforms.
-# Always define AMTAR for backward compatibility.
-
-AMTAR=${AMTAR-"${am_missing_run}tar"}
-
-am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to enable maintainer-specific portions of Makefiles" >&5
-$as_echo_n "checking whether to enable maintainer-specific portions of Makefiles... " >&6; }
-    # Check whether --enable-maintainer-mode was given.
-if test "${enable_maintainer_mode+set}" = set; then :
-  enableval=$enable_maintainer_mode; USE_MAINTAINER_MODE=$enableval
-else
-  USE_MAINTAINER_MODE=no
-fi
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $USE_MAINTAINER_MODE" >&5
-$as_echo "$USE_MAINTAINER_MODE" >&6; }
-   if test $USE_MAINTAINER_MODE = yes; then
-  MAINTAINER_MODE_TRUE=
-  MAINTAINER_MODE_FALSE='#'
-else
-  MAINTAINER_MODE_TRUE='#'
-  MAINTAINER_MODE_FALSE=
-fi
-
-  MAINT=$MAINTAINER_MODE_TRUE
-
-
-
-
-# Check whether --with-target-subdir was given.
-if test "${with_target_subdir+set}" = set; then :
-  withval=$with_target_subdir;
-fi
-
-
-if test -z "$with_target_subdir" || test "$with_target_subdir" = "."; then
-   COMPPATH=.
-else
-   COMPPATH=..
-fi
-
-
-
-# Check whether --with-cross-host was given.
-if test "${with_cross_host+set}" = set; then :
-  withval=$with_cross_host;
-fi
-
-
-# Check whether --enable-multilib was given.
-if test "${enable_multilib+set}" = set; then :
-  enableval=$enable_multilib; case "${enableval}" in
-  yes) multilib=yes ;;
-  no)  multilib=no ;;
-  *)   as_fn_error "bad value ${enableval} for multilib option" "$LINENO" 5 ;;
- esac
-else
-  test -z "$with_target_subdir" && multilib=no || multilib=yes
-fi
-
-
-# Check whether --with-system-zlib was given.
-if test "${with_system_zlib+set}" = set; then :
-  withval=$with_system_zlib;
-fi
-
-
-# Make sure we don't test executables when making cross-tools.
-
-
-# The same as in boehm-gc and libstdc++. Have to borrow it from there.
-# We must force CC to /not/ be precious variables; otherwise
-# the wrong, non-multilib-adjusted value will be used in multilibs.
-# As a side effect, we have to subst CFLAGS ourselves.
-
-
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
-set dummy ${ac_tool_prefix}gcc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CC="${ac_tool_prefix}gcc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_CC"; then
-  ac_ct_CC=$CC
-  # Extract the first word of "gcc", so it can be a program name with args.
-set dummy gcc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_CC"; then
-  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_CC="gcc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_CC=$ac_cv_prog_ac_ct_CC
-if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
-$as_echo "$ac_ct_CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_CC" = x; then
-    CC=""
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    CC=$ac_ct_CC
-  fi
-else
-  CC="$ac_cv_prog_CC"
-fi
-
-if test -z "$CC"; then
-          if test -n "$ac_tool_prefix"; then
-    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
-set dummy ${ac_tool_prefix}cc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CC="${ac_tool_prefix}cc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  fi
-fi
-if test -z "$CC"; then
-  # Extract the first word of "cc", so it can be a program name with args.
-set dummy cc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-  ac_prog_rejected=no
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
-       ac_prog_rejected=yes
-       continue
-     fi
-    ac_cv_prog_CC="cc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-if test $ac_prog_rejected = yes; then
-  # We found a bogon in the path, so make sure we never use it.
-  set dummy $ac_cv_prog_CC
-  shift
-  if test $# != 0; then
-    # We chose a different compiler from the bogus one.
-    # However, it has the same basename, so the bogon will be chosen
-    # first if we set CC to just the basename; use the full file name.
-    shift
-    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
-  fi
-fi
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$CC"; then
-  if test -n "$ac_tool_prefix"; then
-  for ac_prog in cl.exe
-  do
-    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
-set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-    test -n "$CC" && break
-  done
-fi
-if test -z "$CC"; then
-  ac_ct_CC=$CC
-  for ac_prog in cl.exe
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_CC"; then
-  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_CC="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_CC=$ac_cv_prog_ac_ct_CC
-if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
-$as_echo "$ac_ct_CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$ac_ct_CC" && break
-done
-
-  if test "x$ac_ct_CC" = x; then
-    CC=""
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    CC=$ac_ct_CC
-  fi
-fi
-
-fi
-
-
-test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "no acceptable C compiler found in \$PATH
-See \`config.log' for more details." "$LINENO" 5; }
-
-# Provide some information about the compiler.
-$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
-set X $ac_compile
-ac_compiler=$2
-for ac_option in --version -v -V -qversion; do
-  { { ac_try="$ac_compiler $ac_option >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    sed '10a\
-... rest of stderr output deleted ...
-         10q' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    rm -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-done
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-# FIXME: Cleanup?
-if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
-  gcc_no_link=no
-else
-  gcc_no_link=yes
-fi
-if test x$gcc_no_link = xyes; then
-  # Setting cross_compile will disable run tests; it will
-  # also disable AC_CHECK_FILE but that's generally
-  # correct if we can't link.
-  cross_compiling=yes
-  EXEEXT=
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-ac_clean_files_save=$ac_clean_files
-ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out conftest.out"
-# Try to create an executable without -o first, disregard a.out.
-# It will help us diagnose broken compilers, and finding out an intuition
-# of exeext.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name" >&5
-$as_echo_n "checking for C compiler default output file name... " >&6; }
-ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
-
-# The possible output files:
-ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
-
-ac_rmfiles=
-for ac_file in $ac_files
-do
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
-    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
-  esac
-done
-rm -f $ac_rmfiles
-
-if { { ac_try="$ac_link_default"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link_default") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
-  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
-# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
-# in a Makefile.  We should not override ac_cv_exeext if it was cached,
-# so that the user can short-circuit this test for compilers unknown to
-# Autoconf.
-for ac_file in $ac_files ''
-do
-  test -f "$ac_file" || continue
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
-	;;
-    [ab].out )
-	# We found the default executable, but exeext='' is most
-	# certainly right.
-	break;;
-    *.* )
-	if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
-	then :; else
-	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-	fi
-	# We set ac_cv_exeext here because the later test for it is not
-	# safe: cross compilers may not add the suffix if given an `-o'
-	# argument, so we may need to know it at that point already.
-	# Even if this section looks crufty: it has the advantage of
-	# actually working.
-	break;;
-    * )
-	break;;
-  esac
-done
-test "$ac_cv_exeext" = no && ac_cv_exeext=
-
-else
-  ac_file=''
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_file" >&5
-$as_echo "$ac_file" >&6; }
-if test -z "$ac_file"; then :
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-{ as_fn_set_status 77
-as_fn_error "C compiler cannot create executables
-See \`config.log' for more details." "$LINENO" 5; }; }
-fi
-ac_exeext=$ac_cv_exeext
-
-# Check that the compiler produces executables we can run.  If not, either
-# the compiler is broken, or we cross compile.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler works" >&5
-$as_echo_n "checking whether the C compiler works... " >&6; }
-# If not cross compiling, check that we can run a simple program.
-if test "$cross_compiling" != yes; then
-  if { ac_try='./$ac_file'
-  { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; }; then
-    cross_compiling=no
-  else
-    if test "$cross_compiling" = maybe; then
-	cross_compiling=yes
-    else
-	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot run C compiled programs.
-If you meant to cross compile, use \`--host'.
-See \`config.log' for more details." "$LINENO" 5; }
-    fi
-  fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-
-rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out conftest.out
-ac_clean_files=$ac_clean_files_save
-# Check that the compiler produces executables we can run.  If not, either
-# the compiler is broken, or we cross compile.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling" >&5
-$as_echo_n "checking whether we are cross compiling... " >&6; }
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $cross_compiling" >&5
-$as_echo "$cross_compiling" >&6; }
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
-$as_echo_n "checking for suffix of executables... " >&6; }
-if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
-  # If both `conftest.exe' and `conftest' are `present' (well, observable)
-# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
-# work properly (i.e., refer to `conftest.exe'), while it won't with
-# `rm'.
-for ac_file in conftest.exe conftest conftest.*; do
-  test -f "$ac_file" || continue
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
-    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-	  break;;
-    * ) break;;
-  esac
-done
-else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot compute suffix of executables: cannot compile and link
-See \`config.log' for more details." "$LINENO" 5; }
-fi
-rm -f conftest$ac_cv_exeext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
-$as_echo "$ac_cv_exeext" >&6; }
-
-rm -f conftest.$ac_ext
-EXEEXT=$ac_cv_exeext
-ac_exeext=$EXEEXT
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
-$as_echo_n "checking for suffix of object files... " >&6; }
-if test "${ac_cv_objext+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.o conftest.obj
-if { { ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compile") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
-  for ac_file in conftest.o conftest.obj conftest.*; do
-  test -f "$ac_file" || continue;
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
-    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
-       break;;
-  esac
-done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot compute suffix of object files: cannot compile
-See \`config.log' for more details." "$LINENO" 5; }
-fi
-rm -f conftest.$ac_cv_objext conftest.$ac_ext
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
-$as_echo "$ac_cv_objext" >&6; }
-OBJEXT=$ac_cv_objext
-ac_objext=$OBJEXT
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
-$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
-if test "${ac_cv_c_compiler_gnu+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-#ifndef __GNUC__
-       choke me
-#endif
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_compiler_gnu=yes
-else
-  ac_compiler_gnu=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-ac_cv_c_compiler_gnu=$ac_compiler_gnu
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
-$as_echo "$ac_cv_c_compiler_gnu" >&6; }
-if test $ac_compiler_gnu = yes; then
-  GCC=yes
-else
-  GCC=
-fi
-ac_test_CFLAGS=${CFLAGS+set}
-ac_save_CFLAGS=$CFLAGS
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
-$as_echo_n "checking whether $CC accepts -g... " >&6; }
-if test "${ac_cv_prog_cc_g+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_save_c_werror_flag=$ac_c_werror_flag
-   ac_c_werror_flag=yes
-   ac_cv_prog_cc_g=no
-   CFLAGS="-g"
-   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_prog_cc_g=yes
-else
-  CFLAGS=""
-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-else
-  ac_c_werror_flag=$ac_save_c_werror_flag
-	 CFLAGS="-g"
-	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_prog_cc_g=yes
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-   ac_c_werror_flag=$ac_save_c_werror_flag
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
-$as_echo "$ac_cv_prog_cc_g" >&6; }
-if test "$ac_test_CFLAGS" = set; then
-  CFLAGS=$ac_save_CFLAGS
-elif test $ac_cv_prog_cc_g = yes; then
-  if test "$GCC" = yes; then
-    CFLAGS="-g -O2"
-  else
-    CFLAGS="-g"
-  fi
-else
-  if test "$GCC" = yes; then
-    CFLAGS="-O2"
-  else
-    CFLAGS=
-  fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
-$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
-if test "${ac_cv_prog_cc_c89+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_prog_cc_c89=no
-ac_save_CC=$CC
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdarg.h>
-#include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
-struct buf { int x; };
-FILE * (*rcsopen) (struct buf *, struct stat *, int);
-static char *e (p, i)
-     char **p;
-     int i;
-{
-  return p[i];
-}
-static char *f (char * (*g) (char **, int), char **p, ...)
-{
-  char *s;
-  va_list v;
-  va_start (v,p);
-  s = g (p, va_arg (v,int));
-  va_end (v);
-  return s;
-}
-
-/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
-   function prototypes and stuff, but not '\xHH' hex character constants.
-   These don't provoke an error unfortunately, instead are silently treated
-   as 'x'.  The following induces an error, until -std is added to get
-   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
-   array size at least.  It's necessary to write '\x00'==0 to get something
-   that's true only with -std.  */
-int osf4_cc_array ['\x00' == 0 ? 1 : -1];
-
-/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
-   inside strings and character constants.  */
-#define FOO(x) 'x'
-int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
-
-int test (int i, double x);
-struct s1 {int (*f) (int a);};
-struct s2 {int (*f) (double a);};
-int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
-int argc;
-char **argv;
-int
-main ()
-{
-return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
-  ;
-  return 0;
-}
-_ACEOF
-for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
-	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
-do
-  CC="$ac_save_CC $ac_arg"
-  if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_prog_cc_c89=$ac_arg
-fi
-rm -f core conftest.err conftest.$ac_objext
-  test "x$ac_cv_prog_cc_c89" != "xno" && break
-done
-rm -f conftest.$ac_ext
-CC=$ac_save_CC
-
-fi
-# AC_CACHE_VAL
-case "x$ac_cv_prog_cc_c89" in
-  x)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
-$as_echo "none needed" >&6; } ;;
-  xno)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
-$as_echo "unsupported" >&6; } ;;
-  *)
-    CC="$CC $ac_cv_prog_cc_c89"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
-$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
-esac
-if test "x$ac_cv_prog_cc_c89" != xno; then :
-
-fi
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-DEPDIR="${am__leading_dot}deps"
-
-ac_config_commands="$ac_config_commands depfiles"
-
-
-am_make=${MAKE-make}
-cat > confinc << 'END'
-am__doit:
-	@echo this is the am__doit target
-.PHONY: am__doit
-END
-# If we don't find an include directive, just comment out the code.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for style of include used by $am_make" >&5
-$as_echo_n "checking for style of include used by $am_make... " >&6; }
-am__include="#"
-am__quote=
-_am_result=none
-# First try GNU make style include.
-echo "include confinc" > confmf
-# Ignore all kinds of additional output from `make'.
-case `$am_make -s -f confmf 2> /dev/null` in #(
-*the\ am__doit\ target*)
-  am__include=include
-  am__quote=
-  _am_result=GNU
-  ;;
-esac
-# Now try BSD make style include.
-if test "$am__include" = "#"; then
-   echo '.include "confinc"' > confmf
-   case `$am_make -s -f confmf 2> /dev/null` in #(
-   *the\ am__doit\ target*)
-     am__include=.include
-     am__quote="\""
-     _am_result=BSD
-     ;;
-   esac
-fi
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $_am_result" >&5
-$as_echo "$_am_result" >&6; }
-rm -f confinc confmf
-
-# Check whether --enable-dependency-tracking was given.
-if test "${enable_dependency_tracking+set}" = set; then :
-  enableval=$enable_dependency_tracking;
-fi
-
-if test "x$enable_dependency_tracking" != xno; then
-  am_depcomp="$ac_aux_dir/depcomp"
-  AMDEPBACKSLASH='\'
-fi
- if test "x$enable_dependency_tracking" != xno; then
-  AMDEP_TRUE=
-  AMDEP_FALSE='#'
-else
-  AMDEP_TRUE='#'
-  AMDEP_FALSE=
-fi
-
-
-
-depcc="$CC"   am_compiler_list=
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
-$as_echo_n "checking dependency style of $depcc... " >&6; }
-if test "${am_cv_CC_dependencies_compiler_type+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
-  # We make a subdir and do the tests there.  Otherwise we can end up
-  # making bogus files that we don't know about and never remove.  For
-  # instance it was reported that on HP-UX the gcc test will end up
-  # making a dummy file named `D' -- because `-MD' means `put the output
-  # in D'.
-  mkdir conftest.dir
-  # Copy depcomp to subdir because otherwise we won't find it if we're
-  # using a relative directory.
-  cp "$am_depcomp" conftest.dir
-  cd conftest.dir
-  # We will build objects and dependencies in a subdirectory because
-  # it helps to detect inapplicable dependency modes.  For instance
-  # both Tru64's cc and ICC support -MD to output dependencies as a
-  # side effect of compilation, but ICC will put the dependencies in
-  # the current directory while Tru64 will put them in the object
-  # directory.
-  mkdir sub
-
-  am_cv_CC_dependencies_compiler_type=none
-  if test "$am_compiler_list" = ""; then
-     am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
-  fi
-  am__universal=false
-  case " $depcc " in #(
-     *\ -arch\ *\ -arch\ *) am__universal=true ;;
-     esac
-
-  for depmode in $am_compiler_list; do
-    # Setup a source with many dependencies, because some compilers
-    # like to wrap large dependency lists on column 80 (with \), and
-    # we should not choose a depcomp mode which is confused by this.
-    #
-    # We need to recreate these files for each test, as the compiler may
-    # overwrite some of them when testing with obscure command lines.
-    # This happens at least with the AIX C compiler.
-    : > sub/conftest.c
-    for i in 1 2 3 4 5 6; do
-      echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
-      # Solaris 8's {/usr,}/bin/sh.
-      touch sub/conftst$i.h
-    done
-    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
-
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
-    # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
-    am__obj=sub/conftest.${OBJEXT-o}
-    am__minus_obj="-o $am__obj"
-    case $depmode in
-    gcc)
-      # This depmode causes a compiler race in universal mode.
-      test "$am__universal" = false || continue
-      ;;
-    nosideeffect)
-      # after this tag, mechanisms are not by side-effect, so they'll
-      # only be used when explicitly requested
-      if test "x$enable_dependency_tracking" = xyes; then
-	continue
-      else
-	break
-      fi
-      ;;
-    msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
-      # not run yet.  These depmodes are late enough in the game, and
-      # so weak that their functioning should not be impacted.
-      am__obj=conftest.${OBJEXT-o}
-      am__minus_obj=
-      ;;
-    none) break ;;
-    esac
-    if depmode=$depmode \
-       source=sub/conftest.c object=$am__obj \
-       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
-       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
-         >/dev/null 2>conftest.err &&
-       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
-       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
-       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
-       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
-      # icc doesn't choke on unknown options, it will just issue warnings
-      # or remarks (even with -Werror).  So we grep stderr for any message
-      # that says an option was ignored or not supported.
-      # When given -MP, icc 7.0 and 7.1 complain thusly:
-      #   icc: Command line warning: ignoring option '-M'; no argument required
-      # The diagnosis changed in icc 8.0:
-      #   icc: Command line remark: option '-MP' not supported
-      if (grep 'ignoring option' conftest.err ||
-          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
-        am_cv_CC_dependencies_compiler_type=$depmode
-        break
-      fi
-    fi
-  done
-
-  cd ..
-  rm -rf conftest.dir
-else
-  am_cv_CC_dependencies_compiler_type=none
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_CC_dependencies_compiler_type" >&5
-$as_echo "$am_cv_CC_dependencies_compiler_type" >&6; }
-CCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type
-
- if
-  test "x$enable_dependency_tracking" != xno \
-  && test "$am_cv_CC_dependencies_compiler_type" = gcc3; then
-  am__fastdepCC_TRUE=
-  am__fastdepCC_FALSE='#'
-else
-  am__fastdepCC_TRUE='#'
-  am__fastdepCC_FALSE=
-fi
-
-
-
-
-
-
-case `pwd` in
-  *\ * | *\	*)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&5
-$as_echo "$as_me: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&2;} ;;
-esac
-
-
-
-macro_version='2.2.7a'
-macro_revision='1.3134'
-
-
-
-
-
-
-
-
-
-
-
-
-
-ltmain="$ac_aux_dir/ltmain.sh"
-
-# Backslashify metacharacters that are still active within
-# double-quoted strings.
-sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
-
-# Same as above, but do not quote variable references.
-double_quote_subst='s/\(["`\\]\)/\\\1/g'
-
-# Sed substitution to delay expansion of an escaped shell variable in a
-# double_quote_subst'ed string.
-delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
-
-# Sed substitution to delay expansion of an escaped single quote.
-delay_single_quote_subst='s/'\''/'\'\\\\\\\'\''/g'
-
-# Sed substitution to avoid accidental globbing in evaled expressions
-no_glob_subst='s/\*/\\\*/g'
-
-ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO
-ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to print strings" >&5
-$as_echo_n "checking how to print strings... " >&6; }
-# Test print first, because it will be a builtin if present.
-if test "X`print -r -- -n 2>/dev/null`" = X-n && \
-   test "X`print -r -- $ECHO 2>/dev/null`" = "X$ECHO"; then
-  ECHO='print -r --'
-elif test "X`printf %s $ECHO 2>/dev/null`" = "X$ECHO"; then
-  ECHO='printf %s\n'
-else
-  # Use this function as a fallback that always works.
-  func_fallback_echo ()
-  {
-    eval 'cat <<_LTECHO_EOF
-$1
-_LTECHO_EOF'
-  }
-  ECHO='func_fallback_echo'
-fi
-
-# func_echo_all arg...
-# Invoke $ECHO with all args, space-separated.
-func_echo_all ()
-{
-    $ECHO ""
-}
-
-case "$ECHO" in
-  printf*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: printf" >&5
-$as_echo "printf" >&6; } ;;
-  print*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: print -r" >&5
-$as_echo "print -r" >&6; } ;;
-  *) { $as_echo "$as_me:${as_lineno-$LINENO}: result: cat" >&5
-$as_echo "cat" >&6; } ;;
-esac
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a sed that does not truncate output" >&5
-$as_echo_n "checking for a sed that does not truncate output... " >&6; }
-if test "${ac_cv_path_SED+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-            ac_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/
-     for ac_i in 1 2 3 4 5 6 7; do
-       ac_script="$ac_script$as_nl$ac_script"
-     done
-     echo "$ac_script" 2>/dev/null | sed 99q >conftest.sed
-     { ac_script=; unset ac_script;}
-     if test -z "$SED"; then
-  ac_path_SED_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in sed gsed; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_SED="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_SED" && $as_test_x "$ac_path_SED"; } || continue
-# Check for GNU ac_path_SED and select it if it is found.
-  # Check for GNU $ac_path_SED
-case `"$ac_path_SED" --version 2>&1` in
-*GNU*)
-  ac_cv_path_SED="$ac_path_SED" ac_path_SED_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo '' >> "conftest.nl"
-    "$ac_path_SED" -f conftest.sed < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_SED_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_SED="$ac_path_SED"
-      ac_path_SED_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_SED_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_SED"; then
-    as_fn_error "no acceptable sed could be found in \$PATH" "$LINENO" 5
-  fi
-else
-  ac_cv_path_SED=$SED
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_SED" >&5
-$as_echo "$ac_cv_path_SED" >&6; }
- SED="$ac_cv_path_SED"
-  rm -f conftest.sed
-
-test -z "$SED" && SED=sed
-Xsed="$SED -e 1s/^X//"
-
-
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
-$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
-if test "${ac_cv_path_GREP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -z "$GREP"; then
-  ac_path_GREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in grep ggrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
-# Check for GNU ac_path_GREP and select it if it is found.
-  # Check for GNU $ac_path_GREP
-case `"$ac_path_GREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'GREP' >> "conftest.nl"
-    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_GREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_GREP="$ac_path_GREP"
-      ac_path_GREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_GREP_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_GREP"; then
-    as_fn_error "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
-  fi
-else
-  ac_cv_path_GREP=$GREP
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
-$as_echo "$ac_cv_path_GREP" >&6; }
- GREP="$ac_cv_path_GREP"
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
-$as_echo_n "checking for egrep... " >&6; }
-if test "${ac_cv_path_EGREP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
-   then ac_cv_path_EGREP="$GREP -E"
-   else
-     if test -z "$EGREP"; then
-  ac_path_EGREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in egrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
-# Check for GNU ac_path_EGREP and select it if it is found.
-  # Check for GNU $ac_path_EGREP
-case `"$ac_path_EGREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'EGREP' >> "conftest.nl"
-    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_EGREP="$ac_path_EGREP"
-      ac_path_EGREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_EGREP_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_EGREP"; then
-    as_fn_error "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
-  fi
-else
-  ac_cv_path_EGREP=$EGREP
-fi
-
-   fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
-$as_echo "$ac_cv_path_EGREP" >&6; }
- EGREP="$ac_cv_path_EGREP"
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for fgrep" >&5
-$as_echo_n "checking for fgrep... " >&6; }
-if test "${ac_cv_path_FGREP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if echo 'ab*c' | $GREP -F 'ab*c' >/dev/null 2>&1
-   then ac_cv_path_FGREP="$GREP -F"
-   else
-     if test -z "$FGREP"; then
-  ac_path_FGREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in fgrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_FGREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_FGREP" && $as_test_x "$ac_path_FGREP"; } || continue
-# Check for GNU ac_path_FGREP and select it if it is found.
-  # Check for GNU $ac_path_FGREP
-case `"$ac_path_FGREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_FGREP="$ac_path_FGREP" ac_path_FGREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'FGREP' >> "conftest.nl"
-    "$ac_path_FGREP" FGREP < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_FGREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_FGREP="$ac_path_FGREP"
-      ac_path_FGREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_FGREP_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_FGREP"; then
-    as_fn_error "no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
-  fi
-else
-  ac_cv_path_FGREP=$FGREP
-fi
-
-   fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_FGREP" >&5
-$as_echo "$ac_cv_path_FGREP" >&6; }
- FGREP="$ac_cv_path_FGREP"
-
-
-test -z "$GREP" && GREP=grep
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-# Check whether --with-gnu-ld was given.
-if test "${with_gnu_ld+set}" = set; then :
-  withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
-else
-  with_gnu_ld=no
-fi
-
-ac_prog=ld
-if test "$GCC" = yes; then
-  # Check if gcc -print-prog-name=ld gives a path.
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
-$as_echo_n "checking for ld used by $CC... " >&6; }
-  case $host in
-  *-*-mingw*)
-    # gcc leaves a trailing carriage return which upsets mingw
-    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
-  *)
-    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
-  esac
-  case $ac_prog in
-    # Accept absolute paths.
-    [\\/]* | ?:[\\/]*)
-      re_direlt='/[^/][^/]*/\.\./'
-      # Canonicalize the pathname of ld
-      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
-      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
-	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
-      done
-      test -z "$LD" && LD="$ac_prog"
-      ;;
-  "")
-    # If it fails, then pretend we aren't using GCC.
-    ac_prog=ld
-    ;;
-  *)
-    # If it is relative, then search for the first ld in PATH.
-    with_gnu_ld=unknown
-    ;;
-  esac
-elif test "$with_gnu_ld" = yes; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU ld" >&5
-$as_echo_n "checking for GNU ld... " >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for non-GNU ld" >&5
-$as_echo_n "checking for non-GNU ld... " >&6; }
-fi
-if test "${lt_cv_path_LD+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -z "$LD"; then
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-  for ac_dir in $PATH; do
-    IFS="$lt_save_ifs"
-    test -z "$ac_dir" && ac_dir=.
-    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
-      lt_cv_path_LD="$ac_dir/$ac_prog"
-      # Check to see if the program is GNU ld.  I'd rather use --version,
-      # but apparently some variants of GNU ld only accept -v.
-      # Break only if it was the GNU/non-GNU ld that we prefer.
-      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
-      *GNU* | *'with BFD'*)
-	test "$with_gnu_ld" != no && break
-	;;
-      *)
-	test "$with_gnu_ld" != yes && break
-	;;
-      esac
-    fi
-  done
-  IFS="$lt_save_ifs"
-else
-  lt_cv_path_LD="$LD" # Let the user override the test with a path.
-fi
-fi
-
-LD="$lt_cv_path_LD"
-if test -n "$LD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
-$as_echo "$LD" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-test -z "$LD" && as_fn_error "no acceptable ld found in \$PATH" "$LINENO" 5
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if the linker ($LD) is GNU ld" >&5
-$as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
-if test "${lt_cv_prog_gnu_ld+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  # I'd rather use --version here, but apparently some GNU lds only accept -v.
-case `$LD -v 2>&1 </dev/null` in
-*GNU* | *'with BFD'*)
-  lt_cv_prog_gnu_ld=yes
-  ;;
-*)
-  lt_cv_prog_gnu_ld=no
-  ;;
-esac
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_gnu_ld" >&5
-$as_echo "$lt_cv_prog_gnu_ld" >&6; }
-with_gnu_ld=$lt_cv_prog_gnu_ld
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for BSD- or MS-compatible name lister (nm)" >&5
-$as_echo_n "checking for BSD- or MS-compatible name lister (nm)... " >&6; }
-if test "${lt_cv_path_NM+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$NM"; then
-  # Let the user override the test.
-  lt_cv_path_NM="$NM"
-else
-  lt_nm_to_check="${ac_tool_prefix}nm"
-  if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
-    lt_nm_to_check="$lt_nm_to_check nm"
-  fi
-  for lt_tmp_nm in $lt_nm_to_check; do
-    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do
-      IFS="$lt_save_ifs"
-      test -z "$ac_dir" && ac_dir=.
-      tmp_nm="$ac_dir/$lt_tmp_nm"
-      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
-	# Check to see if the nm accepts a BSD-compat flag.
-	# Adding the `sed 1q' prevents false positives on HP-UX, which says:
-	#   nm: unknown option "B" ignored
-	# Tru64's nm complains that /dev/null is an invalid object file
-	case `"$tmp_nm" -B /dev/null 2>&1 | sed '1q'` in
-	*/dev/null* | *'Invalid file or object type'*)
-	  lt_cv_path_NM="$tmp_nm -B"
-	  break
-	  ;;
-	*)
-	  case `"$tmp_nm" -p /dev/null 2>&1 | sed '1q'` in
-	  */dev/null*)
-	    lt_cv_path_NM="$tmp_nm -p"
-	    break
-	    ;;
-	  *)
-	    lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
-	    continue # so that we can try to find one that supports BSD flags
-	    ;;
-	  esac
-	  ;;
-	esac
-      fi
-    done
-    IFS="$lt_save_ifs"
-  done
-  : ${lt_cv_path_NM=no}
-fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_path_NM" >&5
-$as_echo "$lt_cv_path_NM" >&6; }
-if test "$lt_cv_path_NM" != "no"; then
-  NM="$lt_cv_path_NM"
-else
-  # Didn't find any BSD compatible name lister, look for dumpbin.
-  if test -n "$DUMPBIN"; then :
-    # Let the user override the test.
-  else
-    if test -n "$ac_tool_prefix"; then
-  for ac_prog in dumpbin "link -dump"
-  do
-    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
-set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_DUMPBIN+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$DUMPBIN"; then
-  ac_cv_prog_DUMPBIN="$DUMPBIN" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_DUMPBIN="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-DUMPBIN=$ac_cv_prog_DUMPBIN
-if test -n "$DUMPBIN"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DUMPBIN" >&5
-$as_echo "$DUMPBIN" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-    test -n "$DUMPBIN" && break
-  done
-fi
-if test -z "$DUMPBIN"; then
-  ac_ct_DUMPBIN=$DUMPBIN
-  for ac_prog in dumpbin "link -dump"
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_DUMPBIN+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_DUMPBIN"; then
-  ac_cv_prog_ac_ct_DUMPBIN="$ac_ct_DUMPBIN" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_DUMPBIN="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_DUMPBIN=$ac_cv_prog_ac_ct_DUMPBIN
-if test -n "$ac_ct_DUMPBIN"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DUMPBIN" >&5
-$as_echo "$ac_ct_DUMPBIN" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$ac_ct_DUMPBIN" && break
-done
-
-  if test "x$ac_ct_DUMPBIN" = x; then
-    DUMPBIN=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    DUMPBIN=$ac_ct_DUMPBIN
-  fi
-fi
-
-    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in
-    *COFF*)
-      DUMPBIN="$DUMPBIN -symbols"
-      ;;
-    *)
-      DUMPBIN=:
-      ;;
-    esac
-  fi
-
-  if test "$DUMPBIN" != ":"; then
-    NM="$DUMPBIN"
-  fi
-fi
-test -z "$NM" && NM=nm
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the name lister ($NM) interface" >&5
-$as_echo_n "checking the name lister ($NM) interface... " >&6; }
-if test "${lt_cv_nm_interface+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_nm_interface="BSD nm"
-  echo "int some_variable = 0;" > conftest.$ac_ext
-  (eval echo "\"\$as_me:$LINENO: $ac_compile\"" >&5)
-  (eval "$ac_compile" 2>conftest.err)
-  cat conftest.err >&5
-  (eval echo "\"\$as_me:$LINENO: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
-  (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
-  cat conftest.err >&5
-  (eval echo "\"\$as_me:$LINENO: output\"" >&5)
-  cat conftest.out >&5
-  if $GREP 'External.*some_variable' conftest.out > /dev/null; then
-    lt_cv_nm_interface="MS dumpbin"
-  fi
-  rm -f conftest*
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_nm_interface" >&5
-$as_echo "$lt_cv_nm_interface" >&6; }
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ln -s works" >&5
-$as_echo_n "checking whether ln -s works... " >&6; }
-LN_S=$as_ln_s
-if test "$LN_S" = "ln -s"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no, using $LN_S" >&5
-$as_echo "no, using $LN_S" >&6; }
-fi
-
-# find the maximum length of command line arguments
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the maximum length of command line arguments" >&5
-$as_echo_n "checking the maximum length of command line arguments... " >&6; }
-if test "${lt_cv_sys_max_cmd_len+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-    i=0
-  teststring="ABCD"
-
-  case $build_os in
-  msdosdjgpp*)
-    # On DJGPP, this test can blow up pretty badly due to problems in libc
-    # (any single argument exceeding 2000 bytes causes a buffer overrun
-    # during glob expansion).  Even if it were fixed, the result of this
-    # check would be larger than it should be.
-    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
-    ;;
-
-  gnu*)
-    # Under GNU Hurd, this test is not required because there is
-    # no limit to the length of command line arguments.
-    # Libtool will interpret -1 as no limit whatsoever
-    lt_cv_sys_max_cmd_len=-1;
-    ;;
-
-  cygwin* | mingw* | cegcc*)
-    # On Win9x/ME, this test blows up -- it succeeds, but takes
-    # about 5 minutes as the teststring grows exponentially.
-    # Worse, since 9x/ME are not pre-emptively multitasking,
-    # you end up with a "frozen" computer, even though with patience
-    # the test eventually succeeds (with a max line length of 256k).
-    # Instead, let's just punt: use the minimum linelength reported by
-    # all of the supported platforms: 8192 (on NT/2K/XP).
-    lt_cv_sys_max_cmd_len=8192;
-    ;;
-
-  mint*)
-    # On MiNT this can take a long time and run out of memory.
-    lt_cv_sys_max_cmd_len=8192;
-    ;;
-
-  amigaos*)
-    # On AmigaOS with pdksh, this test takes hours, literally.
-    # So we just punt and use a minimum line length of 8192.
-    lt_cv_sys_max_cmd_len=8192;
-    ;;
-
-  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
-    # This has been around since 386BSD, at least.  Likely further.
-    if test -x /sbin/sysctl; then
-      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
-    elif test -x /usr/sbin/sysctl; then
-      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
-    else
-      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
-    fi
-    # And add a safety zone
-    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
-    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
-    ;;
-
-  interix*)
-    # We know the value 262144 and hardcode it with a safety zone (like BSD)
-    lt_cv_sys_max_cmd_len=196608
-    ;;
-
-  osf*)
-    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure
-    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
-    # nice to cause kernel panics so lets avoid the loop below.
-    # First set a reasonable default.
-    lt_cv_sys_max_cmd_len=16384
-    #
-    if test -x /sbin/sysconfig; then
-      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
-        *1*) lt_cv_sys_max_cmd_len=-1 ;;
-      esac
-    fi
-    ;;
-  sco3.2v5*)
-    lt_cv_sys_max_cmd_len=102400
-    ;;
-  sysv5* | sco5v6* | sysv4.2uw2*)
-    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
-    if test -n "$kargmax"; then
-      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[	 ]//'`
-    else
-      lt_cv_sys_max_cmd_len=32768
-    fi
-    ;;
-  *)
-    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
-    if test -n "$lt_cv_sys_max_cmd_len"; then
-      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
-      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
-    else
-      # Make teststring a little bigger before we do anything with it.
-      # a 1K string should be a reasonable start.
-      for i in 1 2 3 4 5 6 7 8 ; do
-        teststring=$teststring$teststring
-      done
-      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
-      # If test is not a shell built-in, we'll probably end up computing a
-      # maximum length that is only half of the actual maximum length, but
-      # we can't tell.
-      while { test "X"`func_fallback_echo "$teststring$teststring" 2>/dev/null` \
-	         = "X$teststring$teststring"; } >/dev/null 2>&1 &&
-	      test $i != 17 # 1/2 MB should be enough
-      do
-        i=`expr $i + 1`
-        teststring=$teststring$teststring
-      done
-      # Only check the string length outside the loop.
-      lt_cv_sys_max_cmd_len=`expr "X$teststring" : ".*" 2>&1`
-      teststring=
-      # Add a significant safety factor because C++ compilers can tack on
-      # massive amounts of additional arguments before passing them to the
-      # linker.  It appears as though 1/2 is a usable value.
-      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
-    fi
-    ;;
-  esac
-
-fi
-
-if test -n $lt_cv_sys_max_cmd_len ; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_sys_max_cmd_len" >&5
-$as_echo "$lt_cv_sys_max_cmd_len" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: none" >&5
-$as_echo "none" >&6; }
-fi
-max_cmd_len=$lt_cv_sys_max_cmd_len
-
-
-
-
-
-
-: ${CP="cp -f"}
-: ${MV="mv -f"}
-: ${RM="rm -f"}
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands some XSI constructs" >&5
-$as_echo_n "checking whether the shell understands some XSI constructs... " >&6; }
-# Try some XSI features
-xsi_shell=no
-( _lt_dummy="a/b/c"
-  test "${_lt_dummy##*/},${_lt_dummy%/*},"${_lt_dummy%"$_lt_dummy"}, \
-      = c,a/b,, \
-    && eval 'test $(( 1 + 1 )) -eq 2 \
-    && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
-  && xsi_shell=yes
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $xsi_shell" >&5
-$as_echo "$xsi_shell" >&6; }
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands \"+=\"" >&5
-$as_echo_n "checking whether the shell understands \"+=\"... " >&6; }
-lt_shell_append=no
-( foo=bar; set foo baz; eval "$1+=\$2" && test "$foo" = barbaz ) \
-    >/dev/null 2>&1 \
-  && lt_shell_append=yes
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_shell_append" >&5
-$as_echo "$lt_shell_append" >&6; }
-
-
-if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
-  lt_unset=unset
-else
-  lt_unset=false
-fi
-
-
-
-
-
-# test EBCDIC or ASCII
-case `echo X|tr X '\101'` in
- A) # ASCII based system
-    # \n is not interpreted correctly by Solaris 8 /usr/ucb/tr
-  lt_SP2NL='tr \040 \012'
-  lt_NL2SP='tr \015\012 \040\040'
-  ;;
- *) # EBCDIC based system
-  lt_SP2NL='tr \100 \n'
-  lt_NL2SP='tr \r\n \100\100'
-  ;;
-esac
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $LD option to reload object files" >&5
-$as_echo_n "checking for $LD option to reload object files... " >&6; }
-if test "${lt_cv_ld_reload_flag+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_ld_reload_flag='-r'
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_reload_flag" >&5
-$as_echo "$lt_cv_ld_reload_flag" >&6; }
-reload_flag=$lt_cv_ld_reload_flag
-case $reload_flag in
-"" | " "*) ;;
-*) reload_flag=" $reload_flag" ;;
-esac
-reload_cmds='$LD$reload_flag -o $output$reload_objs'
-case $host_os in
-  darwin*)
-    if test "$GCC" = yes; then
-      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
-    else
-      reload_cmds='$LD$reload_flag -o $output$reload_objs'
-    fi
-    ;;
-esac
-
-
-
-
-
-
-
-
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}objdump", so it can be a program name with args.
-set dummy ${ac_tool_prefix}objdump; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_OBJDUMP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$OBJDUMP"; then
-  ac_cv_prog_OBJDUMP="$OBJDUMP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_OBJDUMP="${ac_tool_prefix}objdump"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-OBJDUMP=$ac_cv_prog_OBJDUMP
-if test -n "$OBJDUMP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OBJDUMP" >&5
-$as_echo "$OBJDUMP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_OBJDUMP"; then
-  ac_ct_OBJDUMP=$OBJDUMP
-  # Extract the first word of "objdump", so it can be a program name with args.
-set dummy objdump; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_OBJDUMP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_OBJDUMP"; then
-  ac_cv_prog_ac_ct_OBJDUMP="$ac_ct_OBJDUMP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_OBJDUMP="objdump"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_OBJDUMP=$ac_cv_prog_ac_ct_OBJDUMP
-if test -n "$ac_ct_OBJDUMP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OBJDUMP" >&5
-$as_echo "$ac_ct_OBJDUMP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_OBJDUMP" = x; then
-    OBJDUMP="false"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    OBJDUMP=$ac_ct_OBJDUMP
-  fi
-else
-  OBJDUMP="$ac_cv_prog_OBJDUMP"
-fi
-
-test -z "$OBJDUMP" && OBJDUMP=objdump
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to recognize dependent libraries" >&5
-$as_echo_n "checking how to recognize dependent libraries... " >&6; }
-if test "${lt_cv_deplibs_check_method+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_file_magic_cmd='$MAGIC_CMD'
-lt_cv_file_magic_test_file=
-lt_cv_deplibs_check_method='unknown'
-# Need to set the preceding variable on all platforms that support
-# interlibrary dependencies.
-# 'none' -- dependencies not supported.
-# `unknown' -- same as none, but documents that we really don't know.
-# 'pass_all' -- all dependencies passed with no checks.
-# 'test_compile' -- check by making test program.
-# 'file_magic [[regex]]' -- check by looking for files in library path
-# which responds to the $file_magic_cmd with a given extended regex.
-# If you have `file' or equivalent on your system and you're not sure
-# whether `pass_all' will *always* work, you probably want this one.
-
-case $host_os in
-aix[4-9]*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-beos*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-bsdi[45]*)
-  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib)'
-  lt_cv_file_magic_cmd='/usr/bin/file -L'
-  lt_cv_file_magic_test_file=/shlib/libc.so
-  ;;
-
-cygwin*)
-  # func_win32_libid is a shell function defined in ltmain.sh
-  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
-  lt_cv_file_magic_cmd='func_win32_libid'
-  ;;
-
-mingw* | pw32*)
-  # Base MSYS/MinGW do not provide the 'file' command needed by
-  # func_win32_libid shell function, so use a weaker test based on 'objdump',
-  # unless we find 'file', for example because we are cross-compiling.
-  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.
-  if ( test "$lt_cv_nm_interface" = "BSD nm" && file / ) >/dev/null 2>&1; then
-    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
-    lt_cv_file_magic_cmd='func_win32_libid'
-  else
-    lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'
-    lt_cv_file_magic_cmd='$OBJDUMP -f'
-  fi
-  ;;
-
-cegcc*)
-  # use the weaker test based on 'objdump'. See mingw*.
-  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'
-  lt_cv_file_magic_cmd='$OBJDUMP -f'
-  ;;
-
-darwin* | rhapsody*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-freebsd* | dragonfly*)
-  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
-    case $host_cpu in
-    i*86 )
-      # Not sure whether the presence of OpenBSD here was a mistake.
-      # Let's accept both of them until this is cleared up.
-      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[3-9]86 (compact )?demand paged shared library'
-      lt_cv_file_magic_cmd=/usr/bin/file
-      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
-      ;;
-    esac
-  else
-    lt_cv_deplibs_check_method=pass_all
-  fi
-  ;;
-
-gnu*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-haiku*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-hpux10.20* | hpux11*)
-  lt_cv_file_magic_cmd=/usr/bin/file
-  case $host_cpu in
-  ia64*)
-    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF-[0-9][0-9]) shared object file - IA64'
-    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so
-    ;;
-  hppa*64*)
-    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\.[0-9]'
-    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl
-    ;;
-  *)
-    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|PA-RISC[0-9]\.[0-9]) shared library'
-    lt_cv_file_magic_test_file=/usr/lib/libc.sl
-    ;;
-  esac
-  ;;
-
-interix[3-9]*)
-  # PIC code is broken on Interix 3.x, that's why |\.a not |_pic\.a here
-  lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|\.a)$'
-  ;;
-
-irix5* | irix6* | nonstopux*)
-  case $LD in
-  *-32|*"-32 ") libmagic=32-bit;;
-  *-n32|*"-n32 ") libmagic=N32;;
-  *-64|*"-64 ") libmagic=64-bit;;
-  *) libmagic=never-match;;
-  esac
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-# This must be Linux ELF.
-linux* | k*bsd*-gnu | kopensolaris*-gnu)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-netbsd*)
-  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
-    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
-  else
-    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|_pic\.a)$'
-  fi
-  ;;
-
-newos6*)
-  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (executable|dynamic lib)'
-  lt_cv_file_magic_cmd=/usr/bin/file
-  lt_cv_file_magic_test_file=/usr/lib/libnls.so
-  ;;
-
-*nto* | *qnx*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-openbsd*)
-  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|\.so|_pic\.a)$'
-  else
-    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
-  fi
-  ;;
-
-osf3* | osf4* | osf5*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-rdos*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-solaris*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-sysv4 | sysv4.3*)
-  case $host_vendor in
-  motorola)
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib) M[0-9][0-9]* Version [0-9]'
-    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`
-    ;;
-  ncr)
-    lt_cv_deplibs_check_method=pass_all
-    ;;
-  sequent)
-    lt_cv_file_magic_cmd='/bin/file'
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )'
-    ;;
-  sni)
-    lt_cv_file_magic_cmd='/bin/file'
-    lt_cv_deplibs_check_method="file_magic ELF [0-9][0-9]*-bit [LM]SB dynamic lib"
-    lt_cv_file_magic_test_file=/lib/libc.so
-    ;;
-  siemens)
-    lt_cv_deplibs_check_method=pass_all
-    ;;
-  pc)
-    lt_cv_deplibs_check_method=pass_all
-    ;;
-  esac
-  ;;
-
-tpf*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-esac
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_deplibs_check_method" >&5
-$as_echo "$lt_cv_deplibs_check_method" >&6; }
-file_magic_cmd=$lt_cv_file_magic_cmd
-deplibs_check_method=$lt_cv_deplibs_check_method
-test -z "$deplibs_check_method" && deplibs_check_method=unknown
-
-
-
-
-
-
-
-
-
-
-
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
-set dummy ${ac_tool_prefix}ar; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_AR+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$AR"; then
-  ac_cv_prog_AR="$AR" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_AR="${ac_tool_prefix}ar"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-AR=$ac_cv_prog_AR
-if test -n "$AR"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
-$as_echo "$AR" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_AR"; then
-  ac_ct_AR=$AR
-  # Extract the first word of "ar", so it can be a program name with args.
-set dummy ar; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_AR+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_AR"; then
-  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_AR="ar"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_AR=$ac_cv_prog_ac_ct_AR
-if test -n "$ac_ct_AR"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
-$as_echo "$ac_ct_AR" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_AR" = x; then
-    AR="false"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    AR=$ac_ct_AR
-  fi
-else
-  AR="$ac_cv_prog_AR"
-fi
-
-test -z "$AR" && AR=ar
-test -z "$AR_FLAGS" && AR_FLAGS=cru
-
-
-
-
-
-
-
-
-
-
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
-set dummy ${ac_tool_prefix}strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_STRIP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$STRIP"; then
-  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-STRIP=$ac_cv_prog_STRIP
-if test -n "$STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
-$as_echo "$STRIP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_STRIP"; then
-  ac_ct_STRIP=$STRIP
-  # Extract the first word of "strip", so it can be a program name with args.
-set dummy strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_STRIP"; then
-  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_STRIP="strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
-if test -n "$ac_ct_STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
-$as_echo "$ac_ct_STRIP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_STRIP" = x; then
-    STRIP=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    STRIP=$ac_ct_STRIP
-  fi
-else
-  STRIP="$ac_cv_prog_STRIP"
-fi
-
-test -z "$STRIP" && STRIP=:
-
-
-
-
-
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
-set dummy ${ac_tool_prefix}ranlib; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_RANLIB+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$RANLIB"; then
-  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-RANLIB=$ac_cv_prog_RANLIB
-if test -n "$RANLIB"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
-$as_echo "$RANLIB" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_RANLIB"; then
-  ac_ct_RANLIB=$RANLIB
-  # Extract the first word of "ranlib", so it can be a program name with args.
-set dummy ranlib; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_RANLIB"; then
-  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_RANLIB="ranlib"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
-if test -n "$ac_ct_RANLIB"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
-$as_echo "$ac_ct_RANLIB" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_RANLIB" = x; then
-    RANLIB=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    RANLIB=$ac_ct_RANLIB
-  fi
-else
-  RANLIB="$ac_cv_prog_RANLIB"
-fi
-
-test -z "$RANLIB" && RANLIB=:
-
-
-
-
-
-
-# Determine commands to create old-style static archives.
-old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'
-old_postinstall_cmds='chmod 644 $oldlib'
-old_postuninstall_cmds=
-
-if test -n "$RANLIB"; then
-  case $host_os in
-  openbsd*)
-    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$oldlib"
-    ;;
-  *)
-    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB \$oldlib"
-    ;;
-  esac
-  old_archive_cmds="$old_archive_cmds~\$RANLIB \$oldlib"
-fi
-
-case $host_os in
-  darwin*)
-    lock_old_archive_extraction=yes ;;
-  *)
-    lock_old_archive_extraction=no ;;
-esac
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-# If no C compiler was specified, use CC.
-LTCC=${LTCC-"$CC"}
-
-# If no C compiler flags were specified, use CFLAGS.
-LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
-
-# Allow CC to be a program name with arguments.
-compiler=$CC
-
-
-# Check for command to grab the raw symbol name followed by C symbol from nm.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking command to parse $NM output from $compiler object" >&5
-$as_echo_n "checking command to parse $NM output from $compiler object... " >&6; }
-if test "${lt_cv_sys_global_symbol_pipe+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-
-# These are sane defaults that work on at least a few old systems.
-# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
-
-# Character class describing NM global symbol codes.
-symcode='[BCDEGRST]'
-
-# Regexp to match symbols that can be accessed directly from C.
-sympat='\([_A-Za-z][_A-Za-z0-9]*\)'
-
-# Define system-specific variables.
-case $host_os in
-aix*)
-  symcode='[BCDT]'
-  ;;
-cygwin* | mingw* | pw32* | cegcc*)
-  symcode='[ABCDGISTW]'
-  ;;
-hpux*)
-  if test "$host_cpu" = ia64; then
-    symcode='[ABCDEGRST]'
-  fi
-  ;;
-irix* | nonstopux*)
-  symcode='[BCDEGRST]'
-  ;;
-osf*)
-  symcode='[BCDEGQRST]'
-  ;;
-solaris*)
-  symcode='[BDRT]'
-  ;;
-sco3.2v5*)
-  symcode='[DT]'
-  ;;
-sysv4.2uw2*)
-  symcode='[DT]'
-  ;;
-sysv5* | sco5v6* | unixware* | OpenUNIX*)
-  symcode='[ABDT]'
-  ;;
-sysv4)
-  symcode='[DFNSTU]'
-  ;;
-esac
-
-# If we're using GNU nm, then use its standard symbol codes.
-case `$NM -V 2>&1` in
-*GNU* | *'with BFD'*)
-  symcode='[ABCDGIRSTW]' ;;
-esac
-
-# Transform an extracted symbol line into a proper C declaration.
-# Some systems (esp. on ia64) link data and code symbols differently,
-# so use this general approach.
-lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
-
-# Transform an extracted symbol line into symbol name and symbol address
-lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"\2\", (void *) \&\2},/p'"
-lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \(lib[^ ]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
-
-# Handle CRLF in mingw tool chain
-opt_cr=
-case $build_os in
-mingw*)
-  opt_cr=`$ECHO 'x\{0,1\}' | tr x '\015'` # option cr in regexp
-  ;;
-esac
-
-# Try without a prefix underscore, then with it.
-for ac_symprfx in "" "_"; do
-
-  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.
-  symxfrm="\\1 $ac_symprfx\\2 \\2"
-
-  # Write the raw and C identifiers.
-  if test "$lt_cv_nm_interface" = "MS dumpbin"; then
-    # Fake it for dumpbin and say T for any non-static function
-    # and D for any global variable.
-    # Also find C++ and __fastcall symbols from MSVC++,
-    # which start with @ or ?.
-    lt_cv_sys_global_symbol_pipe="$AWK '"\
-"     {last_section=section; section=\$ 3};"\
-"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};"\
-"     \$ 0!~/External *\|/{next};"\
-"     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
-"     {if(hide[section]) next};"\
-"     {f=0}; \$ 0~/\(\).*\|/{f=1}; {printf f ? \"T \" : \"D \"};"\
-"     {split(\$ 0, a, /\||\r/); split(a[2], s)};"\
-"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
-"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
-"     ' prfx=^$ac_symprfx"
-  else
-    lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[	 ]\($symcode$symcode*\)[	 ][	 ]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
-  fi
-
-  # Check to see that the pipe works correctly.
-  pipe_works=no
-
-  rm -f conftest*
-  cat > conftest.$ac_ext <<_LT_EOF
-#ifdef __cplusplus
-extern "C" {
-#endif
-char nm_test_var;
-void nm_test_func(void);
-void nm_test_func(void){}
-#ifdef __cplusplus
-}
-#endif
-int main(){nm_test_var='a';nm_test_func();return(0);}
-_LT_EOF
-
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    # Now try to grab the symbols.
-    nlist=conftest.nm
-    if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist\""; } >&5
-  (eval $NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s "$nlist"; then
-      # Try sorting and uniquifying the output.
-      if sort "$nlist" | uniq > "$nlist"T; then
-	mv -f "$nlist"T "$nlist"
-      else
-	rm -f "$nlist"T
-      fi
-
-      # Make sure that we snagged all the symbols we need.
-      if $GREP ' nm_test_var$' "$nlist" >/dev/null; then
-	if $GREP ' nm_test_func$' "$nlist" >/dev/null; then
-	  cat <<_LT_EOF > conftest.$ac_ext
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-_LT_EOF
-	  # Now generate the symbol file.
-	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | $GREP -v main >> conftest.$ac_ext'
-
-	  cat <<_LT_EOF >> conftest.$ac_ext
-
-/* The mapping between symbol names and symbols.  */
-const struct {
-  const char *name;
-  void       *address;
-}
-lt__PROGRAM__LTX_preloaded_symbols[] =
-{
-  { "@PROGRAM@", (void *) 0 },
-_LT_EOF
-	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
-	  cat <<\_LT_EOF >> conftest.$ac_ext
-  {0, (void *) 0}
-};
-
-/* This works around a problem in FreeBSD linker */
-#ifdef FREEBSD_WORKAROUND
-static const void *lt_preloaded_setup() {
-  return lt__PROGRAM__LTX_preloaded_symbols;
-}
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-_LT_EOF
-	  # Now try linking the two files.
-	  mv conftest.$ac_objext conftstm.$ac_objext
-	  lt_save_LIBS="$LIBS"
-	  lt_save_CFLAGS="$CFLAGS"
-	  LIBS="conftstm.$ac_objext"
-	  CFLAGS="$CFLAGS$lt_prog_compiler_no_builtin_flag"
-	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s conftest${ac_exeext}; then
-	    pipe_works=yes
-	  fi
-	  LIBS="$lt_save_LIBS"
-	  CFLAGS="$lt_save_CFLAGS"
-	else
-	  echo "cannot find nm_test_func in $nlist" >&5
-	fi
-      else
-	echo "cannot find nm_test_var in $nlist" >&5
-      fi
-    else
-      echo "cannot run $lt_cv_sys_global_symbol_pipe" >&5
-    fi
-  else
-    echo "$progname: failed program was:" >&5
-    cat conftest.$ac_ext >&5
-  fi
-  rm -rf conftest* conftst*
-
-  # Do not use the global_symbol_pipe unless it works.
-  if test "$pipe_works" = yes; then
-    break
-  else
-    lt_cv_sys_global_symbol_pipe=
-  fi
-done
-
-fi
-
-if test -z "$lt_cv_sys_global_symbol_pipe"; then
-  lt_cv_sys_global_symbol_to_cdecl=
-fi
-if test -z "$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: failed" >&5
-$as_echo "failed" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: ok" >&5
-$as_echo "ok" >&6; }
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-# Check whether --enable-libtool-lock was given.
-if test "${enable_libtool_lock+set}" = set; then :
-  enableval=$enable_libtool_lock;
-fi
-
-test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
-
-# Some flags need to be propagated to the compiler or linker for good
-# libtool support.
-case $host in
-ia64-*-hpux*)
-  # Find out which ABI we are using.
-  echo 'int i;' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    case `/usr/bin/file conftest.$ac_objext` in
-      *ELF-32*)
-	HPUX_IA64_MODE="32"
-	;;
-      *ELF-64*)
-	HPUX_IA64_MODE="64"
-	;;
-    esac
-  fi
-  rm -rf conftest*
-  ;;
-*-*-irix6*)
-  # Find out which ABI we are using.
-  echo '#line '$LINENO' "configure"' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    if test "$lt_cv_prog_gnu_ld" = yes; then
-      case `/usr/bin/file conftest.$ac_objext` in
-	*32-bit*)
-	  LD="${LD-ld} -melf32bsmip"
-	  ;;
-	*N32*)
-	  LD="${LD-ld} -melf32bmipn32"
-	  ;;
-	*64-bit*)
-	  LD="${LD-ld} -melf64bmip"
-	;;
-      esac
-    else
-      case `/usr/bin/file conftest.$ac_objext` in
-	*32-bit*)
-	  LD="${LD-ld} -32"
-	  ;;
-	*N32*)
-	  LD="${LD-ld} -n32"
-	  ;;
-	*64-bit*)
-	  LD="${LD-ld} -64"
-	  ;;
-      esac
-    fi
-  fi
-  rm -rf conftest*
-  ;;
-
-x86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \
-s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
-  # Find out which ABI we are using.
-  echo 'int i;' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    case `/usr/bin/file conftest.o` in
-      *32-bit*)
-	case $host in
-	  x86_64-*kfreebsd*-gnu)
-	    LD="${LD-ld} -m elf_i386_fbsd"
-	    ;;
-	  x86_64-*linux*)
-	    LD="${LD-ld} -m elf_i386"
-	    ;;
-	  ppc64-*linux*|powerpc64-*linux*)
-	    LD="${LD-ld} -m elf32ppclinux"
-	    ;;
-	  s390x-*linux*)
-	    LD="${LD-ld} -m elf_s390"
-	    ;;
-	  sparc64-*linux*)
-	    LD="${LD-ld} -m elf32_sparc"
-	    ;;
-	esac
-	;;
-      *64-bit*)
-	case $host in
-	  x86_64-*kfreebsd*-gnu)
-	    LD="${LD-ld} -m elf_x86_64_fbsd"
-	    ;;
-	  x86_64-*linux*)
-	    LD="${LD-ld} -m elf_x86_64"
-	    ;;
-	  ppc*-*linux*|powerpc*-*linux*)
-	    LD="${LD-ld} -m elf64ppc"
-	    ;;
-	  s390*-*linux*|s390*-*tpf*)
-	    LD="${LD-ld} -m elf64_s390"
-	    ;;
-	  sparc*-*linux*)
-	    LD="${LD-ld} -m elf64_sparc"
-	    ;;
-	esac
-	;;
-    esac
-  fi
-  rm -rf conftest*
-  ;;
-
-*-*-sco3.2v5*)
-  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
-  SAVE_CFLAGS="$CFLAGS"
-  CFLAGS="$CFLAGS -belf"
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler needs -belf" >&5
-$as_echo_n "checking whether the C compiler needs -belf... " >&6; }
-if test "${lt_cv_cc_needs_belf+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-     if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  lt_cv_cc_needs_belf=yes
-else
-  lt_cv_cc_needs_belf=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-     ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_cc_needs_belf" >&5
-$as_echo "$lt_cv_cc_needs_belf" >&6; }
-  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
-    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
-    CFLAGS="$SAVE_CFLAGS"
-  fi
-  ;;
-sparc*-*solaris*)
-  # Find out which ABI we are using.
-  echo 'int i;' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    case `/usr/bin/file conftest.o` in
-    *64-bit*)
-      case $lt_cv_prog_gnu_ld in
-      yes*) LD="${LD-ld} -m elf64_sparc" ;;
-      *)
-	if ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then
-	  LD="${LD-ld} -64"
-	fi
-	;;
-      esac
-      ;;
-    esac
-  fi
-  rm -rf conftest*
-  ;;
-esac
-
-need_locks="$enable_libtool_lock"
-
-
-  case $host_os in
-    rhapsody* | darwin*)
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}dsymutil", so it can be a program name with args.
-set dummy ${ac_tool_prefix}dsymutil; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_DSYMUTIL+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$DSYMUTIL"; then
-  ac_cv_prog_DSYMUTIL="$DSYMUTIL" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_DSYMUTIL="${ac_tool_prefix}dsymutil"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-DSYMUTIL=$ac_cv_prog_DSYMUTIL
-if test -n "$DSYMUTIL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DSYMUTIL" >&5
-$as_echo "$DSYMUTIL" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_DSYMUTIL"; then
-  ac_ct_DSYMUTIL=$DSYMUTIL
-  # Extract the first word of "dsymutil", so it can be a program name with args.
-set dummy dsymutil; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_DSYMUTIL+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_DSYMUTIL"; then
-  ac_cv_prog_ac_ct_DSYMUTIL="$ac_ct_DSYMUTIL" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_DSYMUTIL="dsymutil"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_DSYMUTIL=$ac_cv_prog_ac_ct_DSYMUTIL
-if test -n "$ac_ct_DSYMUTIL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DSYMUTIL" >&5
-$as_echo "$ac_ct_DSYMUTIL" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_DSYMUTIL" = x; then
-    DSYMUTIL=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    DSYMUTIL=$ac_ct_DSYMUTIL
-  fi
-else
-  DSYMUTIL="$ac_cv_prog_DSYMUTIL"
-fi
-
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}nmedit", so it can be a program name with args.
-set dummy ${ac_tool_prefix}nmedit; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_NMEDIT+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$NMEDIT"; then
-  ac_cv_prog_NMEDIT="$NMEDIT" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_NMEDIT="${ac_tool_prefix}nmedit"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-NMEDIT=$ac_cv_prog_NMEDIT
-if test -n "$NMEDIT"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $NMEDIT" >&5
-$as_echo "$NMEDIT" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_NMEDIT"; then
-  ac_ct_NMEDIT=$NMEDIT
-  # Extract the first word of "nmedit", so it can be a program name with args.
-set dummy nmedit; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_NMEDIT+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_NMEDIT"; then
-  ac_cv_prog_ac_ct_NMEDIT="$ac_ct_NMEDIT" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_NMEDIT="nmedit"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_NMEDIT=$ac_cv_prog_ac_ct_NMEDIT
-if test -n "$ac_ct_NMEDIT"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_NMEDIT" >&5
-$as_echo "$ac_ct_NMEDIT" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_NMEDIT" = x; then
-    NMEDIT=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    NMEDIT=$ac_ct_NMEDIT
-  fi
-else
-  NMEDIT="$ac_cv_prog_NMEDIT"
-fi
-
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}lipo", so it can be a program name with args.
-set dummy ${ac_tool_prefix}lipo; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_LIPO+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$LIPO"; then
-  ac_cv_prog_LIPO="$LIPO" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_LIPO="${ac_tool_prefix}lipo"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-LIPO=$ac_cv_prog_LIPO
-if test -n "$LIPO"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LIPO" >&5
-$as_echo "$LIPO" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_LIPO"; then
-  ac_ct_LIPO=$LIPO
-  # Extract the first word of "lipo", so it can be a program name with args.
-set dummy lipo; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_LIPO+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_LIPO"; then
-  ac_cv_prog_ac_ct_LIPO="$ac_ct_LIPO" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_LIPO="lipo"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_LIPO=$ac_cv_prog_ac_ct_LIPO
-if test -n "$ac_ct_LIPO"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_LIPO" >&5
-$as_echo "$ac_ct_LIPO" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_LIPO" = x; then
-    LIPO=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    LIPO=$ac_ct_LIPO
-  fi
-else
-  LIPO="$ac_cv_prog_LIPO"
-fi
-
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}otool", so it can be a program name with args.
-set dummy ${ac_tool_prefix}otool; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_OTOOL+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$OTOOL"; then
-  ac_cv_prog_OTOOL="$OTOOL" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_OTOOL="${ac_tool_prefix}otool"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-OTOOL=$ac_cv_prog_OTOOL
-if test -n "$OTOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL" >&5
-$as_echo "$OTOOL" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_OTOOL"; then
-  ac_ct_OTOOL=$OTOOL
-  # Extract the first word of "otool", so it can be a program name with args.
-set dummy otool; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_OTOOL+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_OTOOL"; then
-  ac_cv_prog_ac_ct_OTOOL="$ac_ct_OTOOL" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_OTOOL="otool"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_OTOOL=$ac_cv_prog_ac_ct_OTOOL
-if test -n "$ac_ct_OTOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL" >&5
-$as_echo "$ac_ct_OTOOL" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_OTOOL" = x; then
-    OTOOL=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    OTOOL=$ac_ct_OTOOL
-  fi
-else
-  OTOOL="$ac_cv_prog_OTOOL"
-fi
-
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}otool64", so it can be a program name with args.
-set dummy ${ac_tool_prefix}otool64; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_OTOOL64+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$OTOOL64"; then
-  ac_cv_prog_OTOOL64="$OTOOL64" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_OTOOL64="${ac_tool_prefix}otool64"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-OTOOL64=$ac_cv_prog_OTOOL64
-if test -n "$OTOOL64"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL64" >&5
-$as_echo "$OTOOL64" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_OTOOL64"; then
-  ac_ct_OTOOL64=$OTOOL64
-  # Extract the first word of "otool64", so it can be a program name with args.
-set dummy otool64; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_OTOOL64+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_OTOOL64"; then
-  ac_cv_prog_ac_ct_OTOOL64="$ac_ct_OTOOL64" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_OTOOL64="otool64"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_OTOOL64=$ac_cv_prog_ac_ct_OTOOL64
-if test -n "$ac_ct_OTOOL64"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL64" >&5
-$as_echo "$ac_ct_OTOOL64" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_OTOOL64" = x; then
-    OTOOL64=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    OTOOL64=$ac_ct_OTOOL64
-  fi
-else
-  OTOOL64="$ac_cv_prog_OTOOL64"
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -single_module linker flag" >&5
-$as_echo_n "checking for -single_module linker flag... " >&6; }
-if test "${lt_cv_apple_cc_single_mod+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_apple_cc_single_mod=no
-      if test -z "${LT_MULTI_MODULE}"; then
-	# By default we will add the -single_module flag. You can override
-	# by either setting the environment variable LT_MULTI_MODULE
-	# non-empty at configure time, or by adding -multi_module to the
-	# link flags.
-	rm -rf libconftest.dylib*
-	echo "int foo(void){return 1;}" > conftest.c
-	echo "$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
--dynamiclib -Wl,-single_module conftest.c" >&5
-	$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
-	  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err
-        _lt_result=$?
-	if test -f libconftest.dylib && test ! -s conftest.err && test $_lt_result = 0; then
-	  lt_cv_apple_cc_single_mod=yes
-	else
-	  cat conftest.err >&5
-	fi
-	rm -rf libconftest.dylib*
-	rm -f conftest.*
-      fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_apple_cc_single_mod" >&5
-$as_echo "$lt_cv_apple_cc_single_mod" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -exported_symbols_list linker flag" >&5
-$as_echo_n "checking for -exported_symbols_list linker flag... " >&6; }
-if test "${lt_cv_ld_exported_symbols_list+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_ld_exported_symbols_list=no
-      save_LDFLAGS=$LDFLAGS
-      echo "_main" > conftest.sym
-      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
-      if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  lt_cv_ld_exported_symbols_list=yes
-else
-  lt_cv_ld_exported_symbols_list=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-	LDFLAGS="$save_LDFLAGS"
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_exported_symbols_list" >&5
-$as_echo "$lt_cv_ld_exported_symbols_list" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -force_load linker flag" >&5
-$as_echo_n "checking for -force_load linker flag... " >&6; }
-if test "${lt_cv_ld_force_load+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_ld_force_load=no
-      cat > conftest.c << _LT_EOF
-int forced_loaded() { return 2;}
-_LT_EOF
-      echo "$LTCC $LTCFLAGS -c -o conftest.o conftest.c" >&5
-      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&5
-      echo "$AR cru libconftest.a conftest.o" >&5
-      $AR cru libconftest.a conftest.o 2>&5
-      cat > conftest.c << _LT_EOF
-int main() { return 0;}
-_LT_EOF
-      echo "$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a" >&5
-      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err
-      _lt_result=$?
-      if test -f conftest && test ! -s conftest.err && test $_lt_result = 0 && $GREP forced_load conftest 2>&1 >/dev/null; then
-	lt_cv_ld_force_load=yes
-      else
-	cat conftest.err >&5
-      fi
-        rm -f conftest.err libconftest.a conftest conftest.c
-        rm -rf conftest.dSYM
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_force_load" >&5
-$as_echo "$lt_cv_ld_force_load" >&6; }
-    case $host_os in
-    rhapsody* | darwin1.[012])
-      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
-    darwin1.*)
-      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
-    darwin*) # darwin 5.x on
-      # if running on 10.5 or later, the deployment target defaults
-      # to the OS version, if on x86, and 10.4, the deployment
-      # target defaults to 10.4. Don't you love it?
-      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
-	10.0,*86*-darwin8*|10.0,*-darwin[91]*)
-	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
-	10.[012]*)
-	  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
-	10.*)
-	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
-      esac
-    ;;
-  esac
-    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
-      _lt_dar_single_mod='$single_module'
-    fi
-    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
-      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
-    else
-      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
-    fi
-    if test "$DSYMUTIL" != ":" && test "$lt_cv_ld_force_load" = "no"; then
-      _lt_dsymutil='~$DSYMUTIL $lib || :'
-    else
-      _lt_dsymutil=
-    fi
-    ;;
-  esac
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
-$as_echo_n "checking how to run the C preprocessor... " >&6; }
-# On Suns, sometimes $CPP names a directory.
-if test -n "$CPP" && test -d "$CPP"; then
-  CPP=
-fi
-if test -z "$CPP"; then
-  if test "${ac_cv_prog_CPP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-      # Double quotes because CPP needs to be expanded
-    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
-    do
-      ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-  break
-fi
-
-    done
-    ac_cv_prog_CPP=$CPP
-
-fi
-  CPP=$ac_cv_prog_CPP
-else
-  ac_cv_prog_CPP=$CPP
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
-$as_echo "$CPP" >&6; }
-ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-
-else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details." "$LINENO" 5; }
-fi
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
-$as_echo_n "checking for ANSI C header files... " >&6; }
-if test "${ac_cv_header_stdc+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <float.h>
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_header_stdc=yes
-else
-  ac_cv_header_stdc=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-if test $ac_cv_header_stdc = yes; then
-  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <string.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "memchr" >/dev/null 2>&1; then :
-
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
-
-fi
-
-if test $ac_cv_header_stdc = yes; then
-  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdlib.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "free" >/dev/null 2>&1; then :
-
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
-
-fi
-
-if test $ac_cv_header_stdc = yes; then
-  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
-  if test "$cross_compiling" = yes; then :
-  :
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ctype.h>
-#include <stdlib.h>
-#if ((' ' & 0x0FF) == 0x020)
-# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
-# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
-#else
-# define ISLOWER(c) \
-		   (('a' <= (c) && (c) <= 'i') \
-		     || ('j' <= (c) && (c) <= 'r') \
-		     || ('s' <= (c) && (c) <= 'z'))
-# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
-#endif
-
-#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
-int
-main ()
-{
-  int i;
-  for (i = 0; i < 256; i++)
-    if (XOR (islower (i), ISLOWER (i))
-	|| toupper (i) != TOUPPER (i))
-      return 2;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
-
-else
-  ac_cv_header_stdc=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-fi
-
-fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
-$as_echo "$ac_cv_header_stdc" >&6; }
-if test $ac_cv_header_stdc = yes; then
-
-$as_echo "#define STDC_HEADERS 1" >>confdefs.h
-
-fi
-
-# On IRIX 5.3, sys/types and inttypes.h are conflicting.
-for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
-		  inttypes.h stdint.h unistd.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
-"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-for ac_header in dlfcn.h
-do :
-  ac_fn_c_check_header_compile "$LINENO" "dlfcn.h" "ac_cv_header_dlfcn_h" "$ac_includes_default
-"
-if test "x$ac_cv_header_dlfcn_h" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_DLFCN_H 1
-_ACEOF
-
-fi
-
-done
-
-
-
-
-
-# Set options
-
-
-
-        enable_dlopen=no
-
-
-  enable_win32_dll=no
-
-
-            # Check whether --enable-shared was given.
-if test "${enable_shared+set}" = set; then :
-  enableval=$enable_shared; p=${PACKAGE-default}
-    case $enableval in
-    yes) enable_shared=yes ;;
-    no) enable_shared=no ;;
-    *)
-      enable_shared=no
-      # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
-      for pkg in $enableval; do
-	IFS="$lt_save_ifs"
-	if test "X$pkg" = "X$p"; then
-	  enable_shared=yes
-	fi
-      done
-      IFS="$lt_save_ifs"
-      ;;
-    esac
-else
-  enable_shared=yes
-fi
-
-
-
-
-
-
-
-
-
-  # Check whether --enable-static was given.
-if test "${enable_static+set}" = set; then :
-  enableval=$enable_static; p=${PACKAGE-default}
-    case $enableval in
-    yes) enable_static=yes ;;
-    no) enable_static=no ;;
-    *)
-     enable_static=no
-      # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
-      for pkg in $enableval; do
-	IFS="$lt_save_ifs"
-	if test "X$pkg" = "X$p"; then
-	  enable_static=yes
-	fi
-      done
-      IFS="$lt_save_ifs"
-      ;;
-    esac
-else
-  enable_static=yes
-fi
-
-
-
-
-
-
-
-
-
-
-# Check whether --with-pic was given.
-if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
-else
-  pic_mode=default
-fi
-
-
-test -z "$pic_mode" && pic_mode=default
-
-
-
-
-
-
-
-  # Check whether --enable-fast-install was given.
-if test "${enable_fast_install+set}" = set; then :
-  enableval=$enable_fast_install; p=${PACKAGE-default}
-    case $enableval in
-    yes) enable_fast_install=yes ;;
-    no) enable_fast_install=no ;;
-    *)
-      enable_fast_install=no
-      # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
-      for pkg in $enableval; do
-	IFS="$lt_save_ifs"
-	if test "X$pkg" = "X$p"; then
-	  enable_fast_install=yes
-	fi
-      done
-      IFS="$lt_save_ifs"
-      ;;
-    esac
-else
-  enable_fast_install=yes
-fi
-
-
-
-
-
-
-
-
-
-
-
-# This can be used to rebuild libtool when needed
-LIBTOOL_DEPS="$ltmain"
-
-# Always use our own libtool.
-LIBTOOL='$(SHELL) $(top_builddir)/libtool'
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-test -z "$LN_S" && LN_S="ln -s"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-if test -n "${ZSH_VERSION+set}" ; then
-   setopt NO_GLOB_SUBST
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for objdir" >&5
-$as_echo_n "checking for objdir... " >&6; }
-if test "${lt_cv_objdir+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  rm -f .libs 2>/dev/null
-mkdir .libs 2>/dev/null
-if test -d .libs; then
-  lt_cv_objdir=.libs
-else
-  # MS-DOS does not allow filenames that begin with a dot.
-  lt_cv_objdir=_libs
-fi
-rmdir .libs 2>/dev/null
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_objdir" >&5
-$as_echo "$lt_cv_objdir" >&6; }
-objdir=$lt_cv_objdir
-
-
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define LT_OBJDIR "$lt_cv_objdir/"
-_ACEOF
-
-
-
-
-case $host_os in
-aix3*)
-  # AIX sometimes has problems with the GCC collect2 program.  For some
-  # reason, if we set the COLLECT_NAMES environment variable, the problems
-  # vanish in a puff of smoke.
-  if test "X${COLLECT_NAMES+set}" != Xset; then
-    COLLECT_NAMES=
-    export COLLECT_NAMES
-  fi
-  ;;
-esac
-
-# Global variables:
-ofile=libtool
-can_build_shared=yes
-
-# All known linkers require a `.a' archive for static linking (except MSVC,
-# which needs '.lib').
-libext=a
-
-with_gnu_ld="$lt_cv_prog_gnu_ld"
-
-old_CC="$CC"
-old_CFLAGS="$CFLAGS"
-
-# Set sane defaults for various variables
-test -z "$CC" && CC=cc
-test -z "$LTCC" && LTCC=$CC
-test -z "$LTCFLAGS" && LTCFLAGS=$CFLAGS
-test -z "$LD" && LD=ld
-test -z "$ac_objext" && ac_objext=o
-
-for cc_temp in $compiler""; do
-  case $cc_temp in
-    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
-    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
-    \-*) ;;
-    *) break;;
-  esac
-done
-cc_basename=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
-
-
-# Only perform the check for file, if the check method requires it
-test -z "$MAGIC_CMD" && MAGIC_CMD=file
-case $deplibs_check_method in
-file_magic*)
-  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${ac_tool_prefix}file" >&5
-$as_echo_n "checking for ${ac_tool_prefix}file... " >&6; }
-if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $MAGIC_CMD in
-[\\/*] |  ?:[\\/]*)
-  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
-  ;;
-*)
-  lt_save_MAGIC_CMD="$MAGIC_CMD"
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
-  for ac_dir in $ac_dummy; do
-    IFS="$lt_save_ifs"
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/${ac_tool_prefix}file; then
-      lt_cv_path_MAGIC_CMD="$ac_dir/${ac_tool_prefix}file"
-      if test -n "$file_magic_test_file"; then
-	case $deplibs_check_method in
-	"file_magic "*)
-	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
-	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
-	    $EGREP "$file_magic_regex" > /dev/null; then
-	    :
-	  else
-	    cat <<_LT_EOF 1>&2
-
-*** Warning: the command libtool uses to detect shared libraries,
-*** $file_magic_cmd, produces output that libtool cannot recognize.
-*** The result is that libtool may fail to recognize shared libraries
-*** as such.  This will affect the creation of libtool libraries that
-*** depend on shared libraries, but programs linked with such libtool
-*** libraries will work regardless of this problem.  Nevertheless, you
-*** may want to report the problem to your system manager and/or to
-*** bug-libtool@gnu.org
-
-_LT_EOF
-	  fi ;;
-	esac
-      fi
-      break
-    fi
-  done
-  IFS="$lt_save_ifs"
-  MAGIC_CMD="$lt_save_MAGIC_CMD"
-  ;;
-esac
-fi
-
-MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-if test -n "$MAGIC_CMD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
-$as_echo "$MAGIC_CMD" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-
-
-
-if test -z "$lt_cv_path_MAGIC_CMD"; then
-  if test -n "$ac_tool_prefix"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for file" >&5
-$as_echo_n "checking for file... " >&6; }
-if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $MAGIC_CMD in
-[\\/*] |  ?:[\\/]*)
-  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
-  ;;
-*)
-  lt_save_MAGIC_CMD="$MAGIC_CMD"
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
-  for ac_dir in $ac_dummy; do
-    IFS="$lt_save_ifs"
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/file; then
-      lt_cv_path_MAGIC_CMD="$ac_dir/file"
-      if test -n "$file_magic_test_file"; then
-	case $deplibs_check_method in
-	"file_magic "*)
-	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
-	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
-	    $EGREP "$file_magic_regex" > /dev/null; then
-	    :
-	  else
-	    cat <<_LT_EOF 1>&2
-
-*** Warning: the command libtool uses to detect shared libraries,
-*** $file_magic_cmd, produces output that libtool cannot recognize.
-*** The result is that libtool may fail to recognize shared libraries
-*** as such.  This will affect the creation of libtool libraries that
-*** depend on shared libraries, but programs linked with such libtool
-*** libraries will work regardless of this problem.  Nevertheless, you
-*** may want to report the problem to your system manager and/or to
-*** bug-libtool@gnu.org
-
-_LT_EOF
-	  fi ;;
-	esac
-      fi
-      break
-    fi
-  done
-  IFS="$lt_save_ifs"
-  MAGIC_CMD="$lt_save_MAGIC_CMD"
-  ;;
-esac
-fi
-
-MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-if test -n "$MAGIC_CMD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
-$as_echo "$MAGIC_CMD" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  else
-    MAGIC_CMD=:
-  fi
-fi
-
-  fi
-  ;;
-esac
-
-# Use C for the default configuration in the libtool script
-
-lt_save_CC="$CC"
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-# Source file extension for C test sources.
-ac_ext=c
-
-# Object file extension for compiled C test sources.
-objext=o
-objext=$objext
-
-# Code to be used in simple compile tests
-lt_simple_compile_test_code="int some_variable = 0;"
-
-# Code to be used in simple link tests
-lt_simple_link_test_code='int main(){return(0);}'
-
-
-
-
-
-
-
-# If no C compiler was specified, use CC.
-LTCC=${LTCC-"$CC"}
-
-# If no C compiler flags were specified, use CFLAGS.
-LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
-
-# Allow CC to be a program name with arguments.
-compiler=$CC
-
-# Save the default compiler, since it gets overwritten when the other
-# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.
-compiler_DEFAULT=$CC
-
-# save warnings/boilerplate of simple test code
-ac_outfile=conftest.$ac_objext
-echo "$lt_simple_compile_test_code" >conftest.$ac_ext
-eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
-_lt_compiler_boilerplate=`cat conftest.err`
-$RM conftest*
-
-ac_outfile=conftest.$ac_objext
-echo "$lt_simple_link_test_code" >conftest.$ac_ext
-eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
-_lt_linker_boilerplate=`cat conftest.err`
-$RM -r conftest*
-
-
-## CAVEAT EMPTOR:
-## There is no encapsulation within the following macros, do not change
-## the running order or otherwise move them around unless you know exactly
-## what you are doing...
-if test -n "$compiler"; then
-
-lt_prog_compiler_no_builtin_flag=
-
-if test "$GCC" = yes; then
-  case $cc_basename in
-  nvcc*)
-    lt_prog_compiler_no_builtin_flag=' -Xcompiler -fno-builtin' ;;
-  *)
-    lt_prog_compiler_no_builtin_flag=' -fno-builtin' ;;
-  esac
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
-$as_echo_n "checking if $compiler supports -fno-rtti -fno-exceptions... " >&6; }
-if test "${lt_cv_prog_compiler_rtti_exceptions+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_rtti_exceptions=no
-   ac_outfile=conftest.$ac_objext
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-   lt_compiler_flag="-fno-rtti -fno-exceptions"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   # The option is referenced via a variable to avoid confusing sed.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>conftest.err)
-   ac_status=$?
-   cat conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s "$ac_outfile"; then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings other than the usual output.
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
-     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_rtti_exceptions=yes
-     fi
-   fi
-   $RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_rtti_exceptions" >&5
-$as_echo "$lt_cv_prog_compiler_rtti_exceptions" >&6; }
-
-if test x"$lt_cv_prog_compiler_rtti_exceptions" = xyes; then
-    lt_prog_compiler_no_builtin_flag="$lt_prog_compiler_no_builtin_flag -fno-rtti -fno-exceptions"
-else
-    :
-fi
-
-fi
-
-
-
-
-
-
-  lt_prog_compiler_wl=
-lt_prog_compiler_pic=
-lt_prog_compiler_static=
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $compiler option to produce PIC" >&5
-$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
-
-  if test "$GCC" = yes; then
-    lt_prog_compiler_wl='-Wl,'
-    lt_prog_compiler_static='-static'
-
-    case $host_os in
-      aix*)
-      # All AIX code is PIC.
-      if test "$host_cpu" = ia64; then
-	# AIX 5 now supports IA64 processor
-	lt_prog_compiler_static='-Bstatic'
-      fi
-      ;;
-
-    amigaos*)
-      case $host_cpu in
-      powerpc)
-            # see comment about AmigaOS4 .so support
-            lt_prog_compiler_pic='-fPIC'
-        ;;
-      m68k)
-            # FIXME: we need at least 68020 code to build shared libraries, but
-            # adding the `-m68020' flag to GCC prevents building anything better,
-            # like `-m68040'.
-            lt_prog_compiler_pic='-m68020 -resident32 -malways-restore-a4'
-        ;;
-      esac
-      ;;
-
-    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
-      # PIC is the default for these OSes.
-      ;;
-
-    mingw* | cygwin* | pw32* | os2* | cegcc*)
-      # This hack is so that the source file can tell whether it is being
-      # built for inclusion in a dll (and should export symbols for example).
-      # Although the cygwin gcc ignores -fPIC, still need this for old-style
-      # (--disable-auto-import) libraries
-      lt_prog_compiler_pic='-DDLL_EXPORT'
-      ;;
-
-    darwin* | rhapsody*)
-      # PIC is the default on this platform
-      # Common symbols not allowed in MH_DYLIB files
-      lt_prog_compiler_pic='-fno-common'
-      ;;
-
-    haiku*)
-      # PIC is the default for Haiku.
-      # The "-static" flag exists, but is broken.
-      lt_prog_compiler_static=
-      ;;
-
-    hpux*)
-      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
-      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
-      # sets the default TLS model and affects inlining.
-      case $host_cpu in
-      hppa*64*)
-	# +Z the default
-	;;
-      *)
-	lt_prog_compiler_pic='-fPIC'
-	;;
-      esac
-      ;;
-
-    interix[3-9]*)
-      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
-      # Instead, we relocate shared libraries at runtime.
-      ;;
-
-    msdosdjgpp*)
-      # Just because we use GCC doesn't mean we suddenly get shared libraries
-      # on systems that don't support them.
-      lt_prog_compiler_can_build_shared=no
-      enable_shared=no
-      ;;
-
-    *nto* | *qnx*)
-      # QNX uses GNU C++, but need to define -shared option too, otherwise
-      # it will coredump.
-      lt_prog_compiler_pic='-fPIC -shared'
-      ;;
-
-    sysv4*MP*)
-      if test -d /usr/nec; then
-	lt_prog_compiler_pic=-Kconform_pic
-      fi
-      ;;
-
-    *)
-      lt_prog_compiler_pic='-fPIC'
-      ;;
-    esac
-
-    case $cc_basename in
-    nvcc*) # Cuda Compiler Driver 2.2
-      lt_prog_compiler_wl='-Xlinker '
-      lt_prog_compiler_pic='-Xcompiler -fPIC'
-      ;;
-    esac
-  else
-    # PORTME Check for flag to pass linker flags through the system compiler.
-    case $host_os in
-    aix*)
-      lt_prog_compiler_wl='-Wl,'
-      if test "$host_cpu" = ia64; then
-	# AIX 5 now supports IA64 processor
-	lt_prog_compiler_static='-Bstatic'
-      else
-	lt_prog_compiler_static='-bnso -bI:/lib/syscalls.exp'
-      fi
-      ;;
-
-    mingw* | cygwin* | pw32* | os2* | cegcc*)
-      # This hack is so that the source file can tell whether it is being
-      # built for inclusion in a dll (and should export symbols for example).
-      lt_prog_compiler_pic='-DDLL_EXPORT'
-      ;;
-
-    hpux9* | hpux10* | hpux11*)
-      lt_prog_compiler_wl='-Wl,'
-      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
-      # not for PA HP-UX.
-      case $host_cpu in
-      hppa*64*|ia64*)
-	# +Z the default
-	;;
-      *)
-	lt_prog_compiler_pic='+Z'
-	;;
-      esac
-      # Is there a better lt_prog_compiler_static that works with the bundled CC?
-      lt_prog_compiler_static='${wl}-a ${wl}archive'
-      ;;
-
-    irix5* | irix6* | nonstopux*)
-      lt_prog_compiler_wl='-Wl,'
-      # PIC (with -KPIC) is the default.
-      lt_prog_compiler_static='-non_shared'
-      ;;
-
-    linux* | k*bsd*-gnu | kopensolaris*-gnu)
-      case $cc_basename in
-      # old Intel for x86_64 which still supported -KPIC.
-      ecc*)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-KPIC'
-	lt_prog_compiler_static='-static'
-        ;;
-      # icc used to be incompatible with GCC.
-      # ICC 10 doesn't accept -KPIC any more.
-      icc* | ifort*)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-fPIC'
-	lt_prog_compiler_static='-static'
-        ;;
-      # Lahey Fortran 8.1.
-      lf95*)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='--shared'
-	lt_prog_compiler_static='--static'
-	;;
-      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)
-        # Portland Group compilers (*not* the Pentium gcc compiler,
-	# which looks to be a dead project)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-fpic'
-	lt_prog_compiler_static='-Bstatic'
-        ;;
-      ccc*)
-        lt_prog_compiler_wl='-Wl,'
-        # All Alpha code is PIC.
-        lt_prog_compiler_static='-non_shared'
-        ;;
-      xl* | bgxl* | bgf* | mpixl*)
-	# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-qpic'
-	lt_prog_compiler_static='-qstaticlink'
-	;;
-      *)
-	case `$CC -V 2>&1 | sed 5q` in
-	*Sun\ F* | *Sun*Fortran*)
-	  # Sun Fortran 8.3 passes all unrecognized flags to the linker
-	  lt_prog_compiler_pic='-KPIC'
-	  lt_prog_compiler_static='-Bstatic'
-	  lt_prog_compiler_wl=''
-	  ;;
-	*Sun\ C*)
-	  # Sun C 5.9
-	  lt_prog_compiler_pic='-KPIC'
-	  lt_prog_compiler_static='-Bstatic'
-	  lt_prog_compiler_wl='-Wl,'
-	  ;;
-	esac
-	;;
-      esac
-      ;;
-
-    newsos6)
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
-
-    *nto* | *qnx*)
-      # QNX uses GNU C++, but need to define -shared option too, otherwise
-      # it will coredump.
-      lt_prog_compiler_pic='-fPIC -shared'
-      ;;
-
-    osf3* | osf4* | osf5*)
-      lt_prog_compiler_wl='-Wl,'
-      # All OSF/1 code is PIC.
-      lt_prog_compiler_static='-non_shared'
-      ;;
-
-    rdos*)
-      lt_prog_compiler_static='-non_shared'
-      ;;
-
-    solaris*)
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      case $cc_basename in
-      f77* | f90* | f95*)
-	lt_prog_compiler_wl='-Qoption ld ';;
-      *)
-	lt_prog_compiler_wl='-Wl,';;
-      esac
-      ;;
-
-    sunos4*)
-      lt_prog_compiler_wl='-Qoption ld '
-      lt_prog_compiler_pic='-PIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
-
-    sysv4 | sysv4.2uw2* | sysv4.3*)
-      lt_prog_compiler_wl='-Wl,'
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
-
-    sysv4*MP*)
-      if test -d /usr/nec ;then
-	lt_prog_compiler_pic='-Kconform_pic'
-	lt_prog_compiler_static='-Bstatic'
-      fi
-      ;;
-
-    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
-      lt_prog_compiler_wl='-Wl,'
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
-
-    unicos*)
-      lt_prog_compiler_wl='-Wl,'
-      lt_prog_compiler_can_build_shared=no
-      ;;
-
-    uts4*)
-      lt_prog_compiler_pic='-pic'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
-
-    *)
-      lt_prog_compiler_can_build_shared=no
-      ;;
-    esac
-  fi
-
-case $host_os in
-  # For platforms which do not support PIC, -DPIC is meaningless:
-  *djgpp*)
-    lt_prog_compiler_pic=
-    ;;
-  *)
-    lt_prog_compiler_pic="$lt_prog_compiler_pic -DPIC"
-    ;;
-esac
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic" >&5
-$as_echo "$lt_prog_compiler_pic" >&6; }
-
-
-
-
-
-
-#
-# Check to make sure the PIC flag actually works.
-#
-if test -n "$lt_prog_compiler_pic"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler PIC flag $lt_prog_compiler_pic works" >&5
-$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic works... " >&6; }
-if test "${lt_cv_prog_compiler_pic_works+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_pic_works=no
-   ac_outfile=conftest.$ac_objext
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-   lt_compiler_flag="$lt_prog_compiler_pic -DPIC"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   # The option is referenced via a variable to avoid confusing sed.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>conftest.err)
-   ac_status=$?
-   cat conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s "$ac_outfile"; then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings other than the usual output.
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
-     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_pic_works=yes
-     fi
-   fi
-   $RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic_works" >&5
-$as_echo "$lt_cv_prog_compiler_pic_works" >&6; }
-
-if test x"$lt_cv_prog_compiler_pic_works" = xyes; then
-    case $lt_prog_compiler_pic in
-     "" | " "*) ;;
-     *) lt_prog_compiler_pic=" $lt_prog_compiler_pic" ;;
-     esac
-else
-    lt_prog_compiler_pic=
-     lt_prog_compiler_can_build_shared=no
-fi
-
-fi
-
-
-
-
-
-
-#
-# Check to make sure the static flag actually works.
-#
-wl=$lt_prog_compiler_wl eval lt_tmp_static_flag=\"$lt_prog_compiler_static\"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler static flag $lt_tmp_static_flag works" >&5
-$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
-if test "${lt_cv_prog_compiler_static_works+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_static_works=no
-   save_LDFLAGS="$LDFLAGS"
-   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
-   echo "$lt_simple_link_test_code" > conftest.$ac_ext
-   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
-     # The linker can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     if test -s conftest.err; then
-       # Append any errors to the config.log.
-       cat conftest.err 1>&5
-       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
-       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-       if diff conftest.exp conftest.er2 >/dev/null; then
-         lt_cv_prog_compiler_static_works=yes
-       fi
-     else
-       lt_cv_prog_compiler_static_works=yes
-     fi
-   fi
-   $RM -r conftest*
-   LDFLAGS="$save_LDFLAGS"
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_static_works" >&5
-$as_echo "$lt_cv_prog_compiler_static_works" >&6; }
-
-if test x"$lt_cv_prog_compiler_static_works" = xyes; then
-    :
-else
-    lt_prog_compiler_static=
-fi
-
-
-
-
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
-$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
-if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_c_o=no
-   $RM -r conftest 2>/dev/null
-   mkdir conftest
-   cd conftest
-   mkdir out
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-
-   lt_compiler_flag="-o out/conftest2.$ac_objext"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>out/conftest.err)
-   ac_status=$?
-   cat out/conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s out/conftest2.$ac_objext
-   then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
-     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
-     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_c_o=yes
-     fi
-   fi
-   chmod u+w . 2>&5
-   $RM conftest*
-   # SGI C++ compiler will create directory out/ii_files/ for
-   # template instantiation
-   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
-   $RM out/* && rmdir out
-   cd ..
-   $RM -r conftest
-   $RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
-$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
-
-
-
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
-$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
-if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_c_o=no
-   $RM -r conftest 2>/dev/null
-   mkdir conftest
-   cd conftest
-   mkdir out
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-
-   lt_compiler_flag="-o out/conftest2.$ac_objext"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>out/conftest.err)
-   ac_status=$?
-   cat out/conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s out/conftest2.$ac_objext
-   then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
-     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
-     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_c_o=yes
-     fi
-   fi
-   chmod u+w . 2>&5
-   $RM conftest*
-   # SGI C++ compiler will create directory out/ii_files/ for
-   # template instantiation
-   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
-   $RM out/* && rmdir out
-   cd ..
-   $RM -r conftest
-   $RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
-$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
-
-
-
-
-hard_links="nottested"
-if test "$lt_cv_prog_compiler_c_o" = no && test "$need_locks" != no; then
-  # do not overwrite the value of need_locks provided by the user
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
-$as_echo_n "checking if we can lock with hard links... " >&6; }
-  hard_links=yes
-  $RM conftest*
-  ln conftest.a conftest.b 2>/dev/null && hard_links=no
-  touch conftest.a
-  ln conftest.a conftest.b 2>&5 || hard_links=no
-  ln conftest.a conftest.b 2>/dev/null && hard_links=no
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
-$as_echo "$hard_links" >&6; }
-  if test "$hard_links" = no; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
-$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
-    need_locks=warn
-  fi
-else
-  need_locks=no
-fi
-
-
-
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
-$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
-
-  runpath_var=
-  allow_undefined_flag=
-  always_export_symbols=no
-  archive_cmds=
-  archive_expsym_cmds=
-  compiler_needs_object=no
-  enable_shared_with_static_runtimes=no
-  export_dynamic_flag_spec=
-  export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
-  hardcode_automatic=no
-  hardcode_direct=no
-  hardcode_direct_absolute=no
-  hardcode_libdir_flag_spec=
-  hardcode_libdir_flag_spec_ld=
-  hardcode_libdir_separator=
-  hardcode_minus_L=no
-  hardcode_shlibpath_var=unsupported
-  inherit_rpath=no
-  link_all_deplibs=unknown
-  module_cmds=
-  module_expsym_cmds=
-  old_archive_from_new_cmds=
-  old_archive_from_expsyms_cmds=
-  thread_safe_flag_spec=
-  whole_archive_flag_spec=
-  # include_expsyms should be a list of space-separated symbols to be *always*
-  # included in the symbol list
-  include_expsyms=
-  # exclude_expsyms can be an extended regexp of symbols to exclude
-  # it will be wrapped by ` (' and `)$', so one must not match beginning or
-  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
-  # as well as any symbol that contains `d'.
-  exclude_expsyms='_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*'
-  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
-  # platforms (ab)use it in PIC code, but their linkers get confused if
-  # the symbol is explicitly referenced.  Since portable code cannot
-  # rely on this symbol name, it's probably fine to never include it in
-  # preloaded symbol tables.
-  # Exclude shared library initialization/finalization symbols.
-  extract_expsyms_cmds=
-
-  case $host_os in
-  cygwin* | mingw* | pw32* | cegcc*)
-    # FIXME: the MSVC++ port hasn't been tested in a loooong time
-    # When not using gcc, we currently assume that we are using
-    # Microsoft Visual C++.
-    if test "$GCC" != yes; then
-      with_gnu_ld=no
-    fi
-    ;;
-  interix*)
-    # we just hope/assume this is gcc and not c89 (= MSVC++)
-    with_gnu_ld=yes
-    ;;
-  openbsd*)
-    with_gnu_ld=no
-    ;;
-  esac
-
-  ld_shlibs=yes
-
-  # On some targets, GNU ld is compatible enough with the native linker
-  # that we're better off using the native interface for both.
-  lt_use_gnu_ld_interface=no
-  if test "$with_gnu_ld" = yes; then
-    case $host_os in
-      aix*)
-	# The AIX port of GNU ld has always aspired to compatibility
-	# with the native linker.  However, as the warning in the GNU ld
-	# block says, versions before 2.19.5* couldn't really create working
-	# shared libraries, regardless of the interface used.
-	case `$LD -v 2>&1` in
-	  *\ \(GNU\ Binutils\)\ 2.19.5*) ;;
-	  *\ \(GNU\ Binutils\)\ 2.[2-9]*) ;;
-	  *\ \(GNU\ Binutils\)\ [3-9]*) ;;
-	  *)
-	    lt_use_gnu_ld_interface=yes
-	    ;;
-	esac
-	;;
-      *)
-	lt_use_gnu_ld_interface=yes
-	;;
-    esac
-  fi
-
-  if test "$lt_use_gnu_ld_interface" = yes; then
-    # If archive_cmds runs LD, not CC, wlarc should be empty
-    wlarc='${wl}'
-
-    # Set some defaults for GNU ld with shared library support. These
-    # are reset later if shared libraries are not supported. Putting them
-    # here allows them to be overridden if necessary.
-    runpath_var=LD_RUN_PATH
-    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-    export_dynamic_flag_spec='${wl}--export-dynamic'
-    # ancient GNU ld didn't support --whole-archive et. al.
-    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then
-      whole_archive_flag_spec="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
-    else
-      whole_archive_flag_spec=
-    fi
-    supports_anon_versioning=no
-    case `$LD -v 2>&1` in
-      *GNU\ gold*) supports_anon_versioning=yes ;;
-      *\ [01].* | *\ 2.[0-9].* | *\ 2.10.*) ;; # catch versions < 2.11
-      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
-      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
-      *\ 2.11.*) ;; # other 2.11 versions
-      *) supports_anon_versioning=yes ;;
-    esac
-
-    # See if GNU ld supports shared libraries.
-    case $host_os in
-    aix[3-9]*)
-      # On AIX/PPC, the GNU linker is very broken
-      if test "$host_cpu" != ia64; then
-	ld_shlibs=no
-	cat <<_LT_EOF 1>&2
-
-*** Warning: the GNU linker, at least up to release 2.19, is reported
-*** to be unable to reliably create shared libraries on AIX.
-*** Therefore, libtool is disabling shared libraries support.  If you
-*** really care for shared libraries, you may want to install binutils
-*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.
-*** You will then need to restart the configuration process.
-
-_LT_EOF
-      fi
-      ;;
-
-    amigaos*)
-      case $host_cpu in
-      powerpc)
-            # see comment about AmigaOS4 .so support
-            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-            archive_expsym_cmds=''
-        ;;
-      m68k)
-            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
-            hardcode_libdir_flag_spec='-L$libdir'
-            hardcode_minus_L=yes
-        ;;
-      esac
-      ;;
-
-    beos*)
-      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	allow_undefined_flag=unsupported
-	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
-	# support --undefined.  This deserves some investigation.  FIXME
-	archive_cmds='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
-
-    cygwin* | mingw* | pw32* | cegcc*)
-      # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
-      # as there is no search path for DLLs.
-      hardcode_libdir_flag_spec='-L$libdir'
-      export_dynamic_flag_spec='${wl}--export-all-symbols'
-      allow_undefined_flag=unsupported
-      always_export_symbols=no
-      enable_shared_with_static_runtimes=yes
-      export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1 DATA/'\'' | $SED -e '\''/^[AITW][ ]/s/.*[ ]//'\'' | sort | uniq > $export_symbols'
-
-      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
-        archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
-	# If the export-symbols file already is a .def file (1st line
-	# is EXPORTS), use it as is; otherwise, prepend...
-	archive_expsym_cmds='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
-	  cp $export_symbols $output_objdir/$soname.def;
-	else
-	  echo EXPORTS > $output_objdir/$soname.def;
-	  cat $export_symbols >> $output_objdir/$soname.def;
-	fi~
-	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
-
-    haiku*)
-      archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-      link_all_deplibs=yes
-      ;;
-
-    interix[3-9]*)
-      hardcode_direct=no
-      hardcode_shlibpath_var=no
-      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-      export_dynamic_flag_spec='${wl}-E'
-      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
-      # Instead, shared libraries are loaded at an image base (0x10000000 by
-      # default) and relocated if they conflict, which is a slow very memory
-      # consuming and fragmenting process.  To avoid this, we pick a random,
-      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
-      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
-      archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
-      archive_expsym_cmds='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
-      ;;
-
-    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
-      tmp_diet=no
-      if test "$host_os" = linux-dietlibc; then
-	case $cc_basename in
-	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
-	esac
-      fi
-      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \
-	 && test "$tmp_diet" = no
-      then
-	tmp_addflag=
-	tmp_sharedflag='-shared'
-	case $cc_basename,$host_cpu in
-        pgcc*)				# Portland Group C compiler
-	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
-	  tmp_addflag=' $pic_flag'
-	  ;;
-	pgf77* | pgf90* | pgf95* | pgfortran*)
-					# Portland Group f77 and f90 compilers
-	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
-	  tmp_addflag=' $pic_flag -Mnomain' ;;
-	ecc*,ia64* | icc*,ia64*)	# Intel C compiler on ia64
-	  tmp_addflag=' -i_dynamic' ;;
-	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
-	  tmp_addflag=' -i_dynamic -nofor_main' ;;
-	ifc* | ifort*)			# Intel Fortran compiler
-	  tmp_addflag=' -nofor_main' ;;
-	lf95*)				# Lahey Fortran 8.1
-	  whole_archive_flag_spec=
-	  tmp_sharedflag='--shared' ;;
-	xl[cC]* | bgxl[cC]* | mpixl[cC]*) # IBM XL C 8.0 on PPC (deal with xlf below)
-	  tmp_sharedflag='-qmkshrobj'
-	  tmp_addflag= ;;
-	nvcc*)	# Cuda Compiler Driver 2.2
-	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
-	  compiler_needs_object=yes
-	  ;;
-	esac
-	case `$CC -V 2>&1 | sed 5q` in
-	*Sun\ C*)			# Sun C 5.9
-	  whole_archive_flag_spec='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
-	  compiler_needs_object=yes
-	  tmp_sharedflag='-G' ;;
-	*Sun\ F*)			# Sun Fortran 8.3
-	  tmp_sharedflag='-G' ;;
-	esac
-	archive_cmds='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-
-        if test "x$supports_anon_versioning" = xyes; then
-          archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
-	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
-	    echo "local: *; };" >> $output_objdir/$libname.ver~
-	    $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
-        fi
-
-	case $cc_basename in
-	xlf* | bgf* | bgxlf* | mpixlf*)
-	  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself
-	  whole_archive_flag_spec='--whole-archive$convenience --no-whole-archive'
-	  hardcode_libdir_flag_spec=
-	  hardcode_libdir_flag_spec_ld='-rpath $libdir'
-	  archive_cmds='$LD -shared $libobjs $deplibs $compiler_flags -soname $soname -o $lib'
-	  if test "x$supports_anon_versioning" = xyes; then
-	    archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
-	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
-	      echo "local: *; };" >> $output_objdir/$libname.ver~
-	      $LD -shared $libobjs $deplibs $compiler_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
-	  fi
-	  ;;
-	esac
-      else
-        ld_shlibs=no
-      fi
-      ;;
-
-    netbsd*)
-      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-	archive_cmds='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
-	wlarc=
-      else
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-      fi
-      ;;
-
-    solaris*)
-      if $LD -v 2>&1 | $GREP 'BFD 2\.8' > /dev/null; then
-	ld_shlibs=no
-	cat <<_LT_EOF 1>&2
-
-*** Warning: The releases 2.8.* of the GNU linker cannot reliably
-*** create shared libraries on Solaris systems.  Therefore, libtool
-*** is disabling shared libraries support.  We urge you to upgrade GNU
-*** binutils to release 2.9.1 or newer.  Another option is to modify
-*** your PATH or compiler configuration so that the native linker is
-*** used, and then restart.
-
-_LT_EOF
-      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
-
-    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
-      case `$LD -v 2>&1` in
-        *\ [01].* | *\ 2.[0-9].* | *\ 2.1[0-5].*)
-	ld_shlibs=no
-	cat <<_LT_EOF 1>&2
-
-*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
-*** reliably create shared libraries on SCO systems.  Therefore, libtool
-*** is disabling shared libraries support.  We urge you to upgrade GNU
-*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
-*** your PATH or compiler configuration so that the native linker is
-*** used, and then restart.
-
-_LT_EOF
-	;;
-	*)
-	  # For security reasons, it is highly recommended that you always
-	  # use absolute paths for naming shared libraries, and exclude the
-	  # DT_RUNPATH tag from executables and libraries.  But doing so
-	  # requires that you compile everything twice, which is a pain.
-	  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-	    archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	    archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-	  else
-	    ld_shlibs=no
-	  fi
-	;;
-      esac
-      ;;
-
-    sunos4*)
-      archive_cmds='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
-      wlarc=
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
-
-    *)
-      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
-    esac
-
-    if test "$ld_shlibs" = no; then
-      runpath_var=
-      hardcode_libdir_flag_spec=
-      export_dynamic_flag_spec=
-      whole_archive_flag_spec=
-    fi
-  else
-    # PORTME fill in a description of your system's linker (not GNU ld)
-    case $host_os in
-    aix3*)
-      allow_undefined_flag=unsupported
-      always_export_symbols=yes
-      archive_expsym_cmds='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
-      # Note: this linker hardcodes the directories in LIBPATH if there
-      # are no directories specified by -L.
-      hardcode_minus_L=yes
-      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
-	# Neither direct hardcoding nor static linking is supported with a
-	# broken collect2.
-	hardcode_direct=unsupported
-      fi
-      ;;
-
-    aix[4-9]*)
-      if test "$host_cpu" = ia64; then
-	# On IA64, the linker does run time linking by default, so we don't
-	# have to do anything special.
-	aix_use_runtimelinking=no
-	exp_sym_flag='-Bexport'
-	no_entry_flag=""
-      else
-	# If we're using GNU nm, then we don't want the "-C" option.
-	# -C means demangle to AIX nm, but means don't demangle with GNU nm
-	# Also, AIX nm treats weak defined symbols like other global
-	# defined symbols, whereas GNU nm marks them as "W".
-	if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
-	  export_symbols_cmds='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
-	else
-	  export_symbols_cmds='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
-	fi
-	aix_use_runtimelinking=no
-
-	# Test if we are trying to use run time linking or normal
-	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
-	# need to do runtime linking.
-	case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)
-	  for ld_flag in $LDFLAGS; do
-	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
-	    aix_use_runtimelinking=yes
-	    break
-	  fi
-	  done
-	  ;;
-	esac
-
-	exp_sym_flag='-bexport'
-	no_entry_flag='-bnoentry'
-      fi
-
-      # When large executables or shared objects are built, AIX ld can
-      # have problems creating the table of contents.  If linking a library
-      # or program results in "error TOC overflow" add -mminimal-toc to
-      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
-      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
-
-      archive_cmds=''
-      hardcode_direct=yes
-      hardcode_direct_absolute=yes
-      hardcode_libdir_separator=':'
-      link_all_deplibs=yes
-      file_list_spec='${wl}-f,'
-
-      if test "$GCC" = yes; then
-	case $host_os in aix4.[012]|aix4.[012].*)
-	# We only want to do this on AIX 4.2 and lower, the check
-	# below for broken collect2 doesn't work under 4.3+
-	  collect2name=`${CC} -print-prog-name=collect2`
-	  if test -f "$collect2name" &&
-	   strings "$collect2name" | $GREP resolve_lib_name >/dev/null
-	  then
-	  # We have reworked collect2
-	  :
-	  else
-	  # We have old collect2
-	  hardcode_direct=unsupported
-	  # It fails to find uninstalled libraries when the uninstalled
-	  # path is not listed in the libpath.  Setting hardcode_minus_L
-	  # to unsupported forces relinking
-	  hardcode_minus_L=yes
-	  hardcode_libdir_flag_spec='-L$libdir'
-	  hardcode_libdir_separator=
-	  fi
-	  ;;
-	esac
-	shared_flag='-shared'
-	if test "$aix_use_runtimelinking" = yes; then
-	  shared_flag="$shared_flag "'${wl}-G'
-	fi
-      else
-	# not using gcc
-	if test "$host_cpu" = ia64; then
-	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
-	# chokes on -Wl,-G. The following line is correct:
-	  shared_flag='-G'
-	else
-	  if test "$aix_use_runtimelinking" = yes; then
-	    shared_flag='${wl}-G'
-	  else
-	    shared_flag='${wl}-bM:SRE'
-	  fi
-	fi
-      fi
-
-      export_dynamic_flag_spec='${wl}-bexpall'
-      # It seems that -bexpall does not export symbols beginning with
-      # underscore (_), so it is better to generate a list of symbols to export.
-      always_export_symbols=yes
-      if test "$aix_use_runtimelinking" = yes; then
-	# Warning - without using the other runtime loading flags (-brtl),
-	# -berok will link without error, but may produce a broken library.
-	allow_undefined_flag='-berok'
-        # Determine the default libpath from the value encoded in an
-        # empty executable.
-        if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-
-lt_aix_libpath_sed='
-    /Import File Strings/,/^$/ {
-	/^0/ {
-	    s/^0  *\(.*\)$/\1/
-	    p
-	}
-    }'
-aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-# Check for a 64-bit object if we didn't find anything.
-if test -z "$aix_libpath"; then
-  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
-
-        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
-        archive_expsym_cmds='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
-      else
-	if test "$host_cpu" = ia64; then
-	  hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
-	  allow_undefined_flag="-z nodefs"
-	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
-	else
-	 # Determine the default libpath from the value encoded in an
-	 # empty executable.
-	 if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-
-lt_aix_libpath_sed='
-    /Import File Strings/,/^$/ {
-	/^0/ {
-	    s/^0  *\(.*\)$/\1/
-	    p
-	}
-    }'
-aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-# Check for a 64-bit object if we didn't find anything.
-if test -z "$aix_libpath"; then
-  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
-
-	 hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
-	  # Warning - without using the other run time loading flags,
-	  # -berok will link without error, but may produce a broken library.
-	  no_undefined_flag=' ${wl}-bernotok'
-	  allow_undefined_flag=' ${wl}-berok'
-	  if test "$with_gnu_ld" = yes; then
-	    # We only use this code for GNU lds that support --whole-archive.
-	    whole_archive_flag_spec='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
-	  else
-	    # Exported symbols can be pulled into shared objects from archives
-	    whole_archive_flag_spec='$convenience'
-	  fi
-	  archive_cmds_need_lc=yes
-	  # This is similar to how AIX traditionally builds its shared libraries.
-	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
-	fi
-      fi
-      ;;
-
-    amigaos*)
-      case $host_cpu in
-      powerpc)
-            # see comment about AmigaOS4 .so support
-            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-            archive_expsym_cmds=''
-        ;;
-      m68k)
-            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
-            hardcode_libdir_flag_spec='-L$libdir'
-            hardcode_minus_L=yes
-        ;;
-      esac
-      ;;
-
-    bsdi[45]*)
-      export_dynamic_flag_spec=-rdynamic
-      ;;
-
-    cygwin* | mingw* | pw32* | cegcc*)
-      # When not using gcc, we currently assume that we are using
-      # Microsoft Visual C++.
-      # hardcode_libdir_flag_spec is actually meaningless, as there is
-      # no search path for DLLs.
-      hardcode_libdir_flag_spec=' '
-      allow_undefined_flag=unsupported
-      # Tell ltmain to make .lib files, not .a files.
-      libext=lib
-      # Tell ltmain to make .dll files, not .so files.
-      shrext_cmds=".dll"
-      # FIXME: Setting linknames here is a bad hack.
-      archive_cmds='$CC -o $lib $libobjs $compiler_flags `func_echo_all "$deplibs" | $SED '\''s/ -lc$//'\''` -link -dll~linknames='
-      # The linker will automatically build a .lib file if we build a DLL.
-      old_archive_from_new_cmds='true'
-      # FIXME: Should let the user specify the lib program.
-      old_archive_cmds='lib -OUT:$oldlib$oldobjs$old_deplibs'
-      fix_srcfile_path='`cygpath -w "$srcfile"`'
-      enable_shared_with_static_runtimes=yes
-      ;;
-
-    darwin* | rhapsody*)
-
-
-  archive_cmds_need_lc=no
-  hardcode_direct=no
-  hardcode_automatic=yes
-  hardcode_shlibpath_var=unsupported
-  if test "$lt_cv_ld_force_load" = "yes"; then
-    whole_archive_flag_spec='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience ${wl}-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
-  else
-    whole_archive_flag_spec=''
-  fi
-  link_all_deplibs=yes
-  allow_undefined_flag="$_lt_dar_allow_undefined"
-  case $cc_basename in
-     ifort*) _lt_dar_can_shared=yes ;;
-     *) _lt_dar_can_shared=$GCC ;;
-  esac
-  if test "$_lt_dar_can_shared" = "yes"; then
-    output_verbose_link_cmd=func_echo_all
-    archive_cmds="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
-    module_cmds="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
-    archive_expsym_cmds="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
-    module_expsym_cmds="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
-
-  else
-  ld_shlibs=no
-  fi
-
-      ;;
-
-    dgux*)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_shlibpath_var=no
-      ;;
-
-    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
-    # support.  Future versions do this automatically, but an explicit c++rt0.o
-    # does not break anything, and helps significantly (at the cost of a little
-    # extra space).
-    freebsd2.2*)
-      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
-
-    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2.*)
-      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_direct=yes
-      hardcode_minus_L=yes
-      hardcode_shlibpath_var=no
-      ;;
-
-    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
-    freebsd* | dragonfly*)
-      archive_cmds='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
-
-    hpux9*)
-      if test "$GCC" = yes; then
-	archive_cmds='$RM $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
-      else
-	archive_cmds='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
-      fi
-      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-      hardcode_libdir_separator=:
-      hardcode_direct=yes
-
-      # hardcode_minus_L: Not really in the search PATH,
-      # but as the default location of the library.
-      hardcode_minus_L=yes
-      export_dynamic_flag_spec='${wl}-E'
-      ;;
-
-    hpux10*)
-      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
-	archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
-      fi
-      if test "$with_gnu_ld" = no; then
-	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-	hardcode_libdir_flag_spec_ld='+b $libdir'
-	hardcode_libdir_separator=:
-	hardcode_direct=yes
-	hardcode_direct_absolute=yes
-	export_dynamic_flag_spec='${wl}-E'
-	# hardcode_minus_L: Not really in the search PATH,
-	# but as the default location of the library.
-	hardcode_minus_L=yes
-      fi
-      ;;
-
-    hpux11*)
-      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
-	case $host_cpu in
-	hppa*64*)
-	  archive_cmds='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	ia64*)
-	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	*)
-	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	esac
-      else
-	case $host_cpu in
-	hppa*64*)
-	  archive_cmds='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	ia64*)
-	  archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	*)
-
-	  # Older versions of the 11.00 compiler do not understand -b yet
-	  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)
-	  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $CC understands -b" >&5
-$as_echo_n "checking if $CC understands -b... " >&6; }
-if test "${lt_cv_prog_compiler__b+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler__b=no
-   save_LDFLAGS="$LDFLAGS"
-   LDFLAGS="$LDFLAGS -b"
-   echo "$lt_simple_link_test_code" > conftest.$ac_ext
-   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
-     # The linker can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     if test -s conftest.err; then
-       # Append any errors to the config.log.
-       cat conftest.err 1>&5
-       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
-       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-       if diff conftest.exp conftest.er2 >/dev/null; then
-         lt_cv_prog_compiler__b=yes
-       fi
-     else
-       lt_cv_prog_compiler__b=yes
-     fi
-   fi
-   $RM -r conftest*
-   LDFLAGS="$save_LDFLAGS"
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler__b" >&5
-$as_echo "$lt_cv_prog_compiler__b" >&6; }
-
-if test x"$lt_cv_prog_compiler__b" = xyes; then
-    archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
-else
-    archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
-fi
-
-	  ;;
-	esac
-      fi
-      if test "$with_gnu_ld" = no; then
-	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-	hardcode_libdir_separator=:
-
-	case $host_cpu in
-	hppa*64*|ia64*)
-	  hardcode_direct=no
-	  hardcode_shlibpath_var=no
-	  ;;
-	*)
-	  hardcode_direct=yes
-	  hardcode_direct_absolute=yes
-	  export_dynamic_flag_spec='${wl}-E'
-
-	  # hardcode_minus_L: Not really in the search PATH,
-	  # but as the default location of the library.
-	  hardcode_minus_L=yes
-	  ;;
-	esac
-      fi
-      ;;
-
-    irix5* | irix6* | nonstopux*)
-      if test "$GCC" = yes; then
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-	# Try to use the -exported_symbol ld option, if it does not
-	# work, assume that -exports_file does not work either and
-	# implicitly export all symbols.
-        save_LDFLAGS="$LDFLAGS"
-        LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
-        if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int foo(void) {}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
-
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-        LDFLAGS="$save_LDFLAGS"
-      else
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
-      fi
-      archive_cmds_need_lc='no'
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      inherit_rpath=yes
-      link_all_deplibs=yes
-      ;;
-
-    netbsd*)
-      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-	archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
-      else
-	archive_cmds='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
-      fi
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
-
-    newsos6)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_direct=yes
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      hardcode_shlibpath_var=no
-      ;;
-
-    *nto* | *qnx*)
-      ;;
-
-    openbsd*)
-      if test -f /usr/libexec/ld.so; then
-	hardcode_direct=yes
-	hardcode_shlibpath_var=no
-	hardcode_direct_absolute=yes
-	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-	  archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
-	  archive_expsym_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
-	  hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-	  export_dynamic_flag_spec='${wl}-E'
-	else
-	  case $host_os in
-	   openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
-	     archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
-	     hardcode_libdir_flag_spec='-R$libdir'
-	     ;;
-	   *)
-	     archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
-	     hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-	     ;;
-	  esac
-	fi
-      else
-	ld_shlibs=no
-      fi
-      ;;
-
-    os2*)
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_minus_L=yes
-      allow_undefined_flag=unsupported
-      archive_cmds='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
-      old_archive_from_new_cmds='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
-      ;;
-
-    osf3*)
-      if test "$GCC" = yes; then
-	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-      else
-	allow_undefined_flag=' -expect_unresolved \*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-      fi
-      archive_cmds_need_lc='no'
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      ;;
-
-    osf4* | osf5*)	# as osf3* with the addition of -msym flag
-      if test "$GCC" = yes; then
-	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-	hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      else
-	allow_undefined_flag=' -expect_unresolved \*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-	archive_expsym_cmds='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
-	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
-
-	# Both c and cxx compiler support -rpath directly
-	hardcode_libdir_flag_spec='-rpath $libdir'
-      fi
-      archive_cmds_need_lc='no'
-      hardcode_libdir_separator=:
-      ;;
-
-    solaris*)
-      no_undefined_flag=' -z defs'
-      if test "$GCC" = yes; then
-	wlarc='${wl}'
-	archive_cmds='$CC -shared ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $CC -shared ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
-      else
-	case `$CC -V 2>&1` in
-	*"Compilers 5.0"*)
-	  wlarc=''
-	  archive_cmds='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
-	  ;;
-	*)
-	  wlarc='${wl}'
-	  archive_cmds='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'
-	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
-	  ;;
-	esac
-      fi
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_shlibpath_var=no
-      case $host_os in
-      solaris2.[0-5] | solaris2.[0-5].*) ;;
-      *)
-	# The compiler driver will combine and reorder linker options,
-	# but understands `-z linker_flag'.  GCC discards it without `$wl',
-	# but is careful enough not to reorder.
-	# Supported since Solaris 2.6 (maybe 2.5.1?)
-	if test "$GCC" = yes; then
-	  whole_archive_flag_spec='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
-	else
-	  whole_archive_flag_spec='-z allextract$convenience -z defaultextract'
-	fi
-	;;
-      esac
-      link_all_deplibs=yes
-      ;;
-
-    sunos4*)
-      if test "x$host_vendor" = xsequent; then
-	# Use $CC to link under sequent, because it throws in some extra .o
-	# files that make .init and .fini sections work.
-	archive_cmds='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
-      fi
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_direct=yes
-      hardcode_minus_L=yes
-      hardcode_shlibpath_var=no
-      ;;
-
-    sysv4)
-      case $host_vendor in
-	sni)
-	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	  hardcode_direct=yes # is this really true???
-	;;
-	siemens)
-	  ## LD is ld it makes a PLAMLIB
-	  ## CC just makes a GrossModule.
-	  archive_cmds='$LD -G -o $lib $libobjs $deplibs $linker_flags'
-	  reload_cmds='$CC -r -o $output$reload_objs'
-	  hardcode_direct=no
-        ;;
-	motorola)
-	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	  hardcode_direct=no #Motorola manual says yes, but my tests say they lie
-	;;
-      esac
-      runpath_var='LD_RUN_PATH'
-      hardcode_shlibpath_var=no
-      ;;
-
-    sysv4.3*)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_shlibpath_var=no
-      export_dynamic_flag_spec='-Bexport'
-      ;;
-
-    sysv4*MP*)
-      if test -d /usr/nec; then
-	archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	hardcode_shlibpath_var=no
-	runpath_var=LD_RUN_PATH
-	hardcode_runpath_var=yes
-	ld_shlibs=yes
-      fi
-      ;;
-
-    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
-      no_undefined_flag='${wl}-z,text'
-      archive_cmds_need_lc=no
-      hardcode_shlibpath_var=no
-      runpath_var='LD_RUN_PATH'
-
-      if test "$GCC" = yes; then
-	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      fi
-      ;;
-
-    sysv5* | sco3.2v5* | sco5v6*)
-      # Note: We can NOT use -z defs as we might desire, because we do not
-      # link with -lc, and that would cause any symbols used from libc to
-      # always be unresolved, which means just about no library would
-      # ever link correctly.  If we're not using GNU ld we use -z text
-      # though, which does catch some bad symbols but isn't as heavy-handed
-      # as -z defs.
-      no_undefined_flag='${wl}-z,text'
-      allow_undefined_flag='${wl}-z,nodefs'
-      archive_cmds_need_lc=no
-      hardcode_shlibpath_var=no
-      hardcode_libdir_flag_spec='${wl}-R,$libdir'
-      hardcode_libdir_separator=':'
-      link_all_deplibs=yes
-      export_dynamic_flag_spec='${wl}-Bexport'
-      runpath_var='LD_RUN_PATH'
-
-      if test "$GCC" = yes; then
-	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      fi
-      ;;
-
-    uts4*)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_shlibpath_var=no
-      ;;
-
-    *)
-      ld_shlibs=no
-      ;;
-    esac
-
-    if test x$host_vendor = xsni; then
-      case $host in
-      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
-	export_dynamic_flag_spec='${wl}-Blargedynsym'
-	;;
-      esac
-    fi
-  fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs" >&5
-$as_echo "$ld_shlibs" >&6; }
-test "$ld_shlibs" = no && can_build_shared=no
-
-with_gnu_ld=$with_gnu_ld
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-#
-# Do we need to explicitly link libc?
-#
-case "x$archive_cmds_need_lc" in
-x|xyes)
-  # Assume -lc should be added
-  archive_cmds_need_lc=yes
-
-  if test "$enable_shared" = yes && test "$GCC" = yes; then
-    case $archive_cmds in
-    *'~'*)
-      # FIXME: we may have to deal with multi-command sequences.
-      ;;
-    '$CC '*)
-      # Test whether the compiler implicitly links with -lc since on some
-      # systems, -lgcc has to come before -lc. If gcc already passes -lc
-      # to ld, don't add -lc before -lgcc.
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -lc should be explicitly linked in" >&5
-$as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
-if test "${lt_cv_archive_cmds_need_lc+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  $RM conftest*
-	echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-
-	if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } 2>conftest.err; then
-	  soname=conftest
-	  lib=conftest
-	  libobjs=conftest.$ac_objext
-	  deplibs=
-	  wl=$lt_prog_compiler_wl
-	  pic_flag=$lt_prog_compiler_pic
-	  compiler_flags=-v
-	  linker_flags=-v
-	  verstring=
-	  output_objdir=.
-	  libname=conftest
-	  lt_save_allow_undefined_flag=$allow_undefined_flag
-	  allow_undefined_flag=
-	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1\""; } >&5
-  (eval $archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-	  then
-	    lt_cv_archive_cmds_need_lc=no
-	  else
-	    lt_cv_archive_cmds_need_lc=yes
-	  fi
-	  allow_undefined_flag=$lt_save_allow_undefined_flag
-	else
-	  cat conftest.err 1>&5
-	fi
-	$RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_archive_cmds_need_lc" >&5
-$as_echo "$lt_cv_archive_cmds_need_lc" >&6; }
-      archive_cmds_need_lc=$lt_cv_archive_cmds_need_lc
-      ;;
-    esac
-  fi
-  ;;
-esac
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
-$as_echo_n "checking dynamic linker characteristics... " >&6; }
-
-if test "$GCC" = yes; then
-  case $host_os in
-    darwin*) lt_awk_arg="/^libraries:/,/LR/" ;;
-    *) lt_awk_arg="/^libraries:/" ;;
-  esac
-  case $host_os in
-    mingw* | cegcc*) lt_sed_strip_eq="s,=\([A-Za-z]:\),\1,g" ;;
-    *) lt_sed_strip_eq="s,=/,/,g" ;;
-  esac
-  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e "s/^libraries://" -e $lt_sed_strip_eq`
-  case $lt_search_path_spec in
-  *\;*)
-    # if the path contains ";" then we assume it to be the separator
-    # otherwise default to the standard path separator (i.e. ":") - it is
-    # assumed that no part of a normal pathname contains ";" but that should
-    # okay in the real world where ";" in dirpaths is itself problematic.
-    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED 's/;/ /g'`
-    ;;
-  *)
-    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED "s/$PATH_SEPARATOR/ /g"`
-    ;;
-  esac
-  # Ok, now we have the path, separated by spaces, we can step through it
-  # and add multilib dir if necessary.
-  lt_tmp_lt_search_path_spec=
-  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
-  for lt_sys_path in $lt_search_path_spec; do
-    if test -d "$lt_sys_path/$lt_multi_os_dir"; then
-      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir"
-    else
-      test -d "$lt_sys_path" && \
-	lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path"
-    fi
-  done
-  lt_search_path_spec=`$ECHO "$lt_tmp_lt_search_path_spec" | awk '
-BEGIN {RS=" "; FS="/|\n";} {
-  lt_foo="";
-  lt_count=0;
-  for (lt_i = NF; lt_i > 0; lt_i--) {
-    if ($lt_i != "" && $lt_i != ".") {
-      if ($lt_i == "..") {
-        lt_count++;
-      } else {
-        if (lt_count == 0) {
-          lt_foo="/" $lt_i lt_foo;
-        } else {
-          lt_count--;
-        }
-      }
-    }
-  }
-  if (lt_foo != "") { lt_freq[lt_foo]++; }
-  if (lt_freq[lt_foo] == 1) { print lt_foo; }
-}'`
-  # AWK program above erroneously prepends '/' to C:/dos/paths
-  # for these hosts.
-  case $host_os in
-    mingw* | cegcc*) lt_search_path_spec=`$ECHO "$lt_search_path_spec" |\
-      $SED 's,/\([A-Za-z]:\),\1,g'` ;;
-  esac
-  sys_lib_search_path_spec=`$ECHO "$lt_search_path_spec" | $lt_NL2SP`
-else
-  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
-fi
-library_names_spec=
-libname_spec='lib$name'
-soname_spec=
-shrext_cmds=".so"
-postinstall_cmds=
-postuninstall_cmds=
-finish_cmds=
-finish_eval=
-shlibpath_var=
-shlibpath_overrides_runpath=unknown
-version_type=none
-dynamic_linker="$host_os ld.so"
-sys_lib_dlsearch_path_spec="/lib /usr/lib"
-need_lib_prefix=unknown
-hardcode_into_libs=no
-
-# when you set need_version to no, make sure it does not cause -set_version
-# flags to be left without arguments
-need_version=unknown
-
-case $host_os in
-aix3*)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
-  shlibpath_var=LIBPATH
-
-  # AIX 3 has no versioning support, so we append a major version to the name.
-  soname_spec='${libname}${release}${shared_ext}$major'
-  ;;
-
-aix[4-9]*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  hardcode_into_libs=yes
-  if test "$host_cpu" = ia64; then
-    # AIX 5 supports IA64
-    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
-    shlibpath_var=LD_LIBRARY_PATH
-  else
-    # With GCC up to 2.95.x, collect2 would create an import file
-    # for dependence libraries.  The import file would start with
-    # the line `#! .'.  This would cause the generated library to
-    # depend on `.', always an invalid library.  This was fixed in
-    # development snapshots of GCC prior to 3.0.
-    case $host_os in
-      aix4 | aix4.[01] | aix4.[01].*)
-      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
-	   echo ' yes '
-	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
-	:
-      else
-	can_build_shared=no
-      fi
-      ;;
-    esac
-    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
-    # soname into executable. Probably we can add versioning support to
-    # collect2, so additional links can be useful in future.
-    if test "$aix_use_runtimelinking" = yes; then
-      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
-      # instead of lib<name>.a to let people know that these are not
-      # typical AIX shared libraries.
-      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    else
-      # We preserve .a as extension for shared libraries through AIX4.2
-      # and later when we are not doing run time linking.
-      library_names_spec='${libname}${release}.a $libname.a'
-      soname_spec='${libname}${release}${shared_ext}$major'
-    fi
-    shlibpath_var=LIBPATH
-  fi
-  ;;
-
-amigaos*)
-  case $host_cpu in
-  powerpc)
-    # Since July 2007 AmigaOS4 officially supports .so libraries.
-    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    ;;
-  m68k)
-    library_names_spec='$libname.ixlibrary $libname.a'
-    # Create ${libname}_ixlibrary.a entries in /sys/libs.
-    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
-    ;;
-  esac
-  ;;
-
-beos*)
-  library_names_spec='${libname}${shared_ext}'
-  dynamic_linker="$host_os ld.so"
-  shlibpath_var=LIBRARY_PATH
-  ;;
-
-bsdi[45]*)
-  version_type=linux
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
-  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
-  # the default ld.so.conf also contains /usr/contrib/lib and
-  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
-  # libtool to hard-code these into programs
-  ;;
-
-cygwin* | mingw* | pw32* | cegcc*)
-  version_type=windows
-  shrext_cmds=".dll"
-  need_version=no
-  need_lib_prefix=no
-
-  case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
-    library_names_spec='$libname.dll.a'
-    # DLL is installed to $(libdir)/../bin by postinstall_cmds
-    postinstall_cmds='base_file=`basename \${file}`~
-      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
-      dldir=$destdir/`dirname \$dlpath`~
-      test -d \$dldir || mkdir -p \$dldir~
-      $install_prog $dir/$dlname \$dldir/$dlname~
-      chmod a+x \$dldir/$dlname~
-      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
-        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
-      fi'
-    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
-      dlpath=$dir/\$dldll~
-       $RM \$dlpath'
-    shlibpath_overrides_runpath=yes
-
-    case $host_os in
-    cygwin*)
-      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
-      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-
-      sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
-      ;;
-    mingw* | cegcc*)
-      # MinGW DLLs use traditional 'lib' prefix
-      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-      ;;
-    pw32*)
-      # pw32 DLLs use 'pw' prefix rather than 'lib'
-      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-      ;;
-    esac
-    ;;
-
-  *)
-    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
-    ;;
-  esac
-  dynamic_linker='Win32 ld.exe'
-  # FIXME: first we should search . and the directory the executable is in
-  shlibpath_var=PATH
-  ;;
-
-darwin* | rhapsody*)
-  dynamic_linker="$host_os dyld"
-  version_type=darwin
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
-  soname_spec='${libname}${release}${major}$shared_ext'
-  shlibpath_overrides_runpath=yes
-  shlibpath_var=DYLD_LIBRARY_PATH
-  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
-
-  sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/local/lib"
-  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
-  ;;
-
-dgux*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  ;;
-
-freebsd* | dragonfly*)
-  # DragonFly does not have aout.  When/if they implement a new
-  # versioning mechanism, adjust this.
-  if test -x /usr/bin/objformat; then
-    objformat=`/usr/bin/objformat`
-  else
-    case $host_os in
-    freebsd[23].*) objformat=aout ;;
-    *) objformat=elf ;;
-    esac
-  fi
-  version_type=freebsd-$objformat
-  case $version_type in
-    freebsd-elf*)
-      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
-      need_version=no
-      need_lib_prefix=no
-      ;;
-    freebsd-*)
-      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
-      need_version=yes
-      ;;
-  esac
-  shlibpath_var=LD_LIBRARY_PATH
-  case $host_os in
-  freebsd2.*)
-    shlibpath_overrides_runpath=yes
-    ;;
-  freebsd3.[01]* | freebsdelf3.[01]*)
-    shlibpath_overrides_runpath=yes
-    hardcode_into_libs=yes
-    ;;
-  freebsd3.[2-9]* | freebsdelf3.[2-9]* | \
-  freebsd4.[0-5] | freebsdelf4.[0-5] | freebsd4.1.1 | freebsdelf4.1.1)
-    shlibpath_overrides_runpath=no
-    hardcode_into_libs=yes
-    ;;
-  *) # from 4.6 on, and DragonFly
-    shlibpath_overrides_runpath=yes
-    hardcode_into_libs=yes
-    ;;
-  esac
-  ;;
-
-gnu*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  hardcode_into_libs=yes
-  ;;
-
-haiku*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  dynamic_linker="$host_os runtime_loader"
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/beos/system/lib'
-  hardcode_into_libs=yes
-  ;;
-
-hpux9* | hpux10* | hpux11*)
-  # Give a soname corresponding to the major version so that dld.sl refuses to
-  # link against other versions.
-  version_type=sunos
-  need_lib_prefix=no
-  need_version=no
-  case $host_cpu in
-  ia64*)
-    shrext_cmds='.so'
-    hardcode_into_libs=yes
-    dynamic_linker="$host_os dld.so"
-    shlibpath_var=LD_LIBRARY_PATH
-    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    if test "X$HPUX_IA64_MODE" = X32; then
-      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
-    else
-      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
-    fi
-    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
-    ;;
-  hppa*64*)
-    shrext_cmds='.sl'
-    hardcode_into_libs=yes
-    dynamic_linker="$host_os dld.sl"
-    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
-    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
-    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
-    ;;
-  *)
-    shrext_cmds='.sl'
-    dynamic_linker="$host_os dld.sl"
-    shlibpath_var=SHLIB_PATH
-    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    ;;
-  esac
-  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...
-  postinstall_cmds='chmod 555 $lib'
-  # or fails outright, so override atomically:
-  install_override_mode=555
-  ;;
-
-interix[3-9]*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  ;;
-
-irix5* | irix6* | nonstopux*)
-  case $host_os in
-    nonstopux*) version_type=nonstopux ;;
-    *)
-	if test "$lt_cv_prog_gnu_ld" = yes; then
-		version_type=linux
-	else
-		version_type=irix
-	fi ;;
-  esac
-  need_lib_prefix=no
-  need_version=no
-  soname_spec='${libname}${release}${shared_ext}$major'
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
-  case $host_os in
-  irix5* | nonstopux*)
-    libsuff= shlibsuff=
-    ;;
-  *)
-    case $LD in # libtool.m4 will add one of these switches to LD
-    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
-      libsuff= shlibsuff= libmagic=32-bit;;
-    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
-      libsuff=32 shlibsuff=N32 libmagic=N32;;
-    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
-      libsuff=64 shlibsuff=64 libmagic=64-bit;;
-    *) libsuff= shlibsuff= libmagic=never-match;;
-    esac
-    ;;
-  esac
-  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
-  shlibpath_overrides_runpath=no
-  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
-  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
-  hardcode_into_libs=yes
-  ;;
-
-# No shared lib support for Linux oldld, aout, or coff.
-linux*oldld* | linux*aout* | linux*coff*)
-  dynamic_linker=no
-  ;;
-
-# This must be Linux ELF.
-linux* | k*bsd*-gnu | kopensolaris*-gnu)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-
-  # Some binutils ld are patched to set DT_RUNPATH
-  if test "${lt_cv_shlibpath_overrides_runpath+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_shlibpath_overrides_runpath=no
-    save_LDFLAGS=$LDFLAGS
-    save_libdir=$libdir
-    eval "libdir=/foo; wl=\"$lt_prog_compiler_wl\"; \
-	 LDFLAGS=\"\$LDFLAGS $hardcode_libdir_flag_spec\""
-    if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  if  ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null; then :
-  lt_cv_shlibpath_overrides_runpath=yes
-fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-    LDFLAGS=$save_LDFLAGS
-    libdir=$save_libdir
-
-fi
-
-  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath
-
-  # This implies no fast_install, which is unacceptable.
-  # Some rework will be needed to allow for fast_install
-  # before this can be enabled.
-  hardcode_into_libs=yes
-
-  # Append ld.so.conf contents to the search path
-  if test -f /etc/ld.so.conf; then
-    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
-    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
-  fi
-
-  # We used to test for /lib/ld.so.1 and disable shared libraries on
-  # powerpc, because MkLinux only supported shared libraries with the
-  # GNU dynamic linker.  Since this was broken with cross compilers,
-  # most powerpc-linux boxes support dynamic linking these days and
-  # people can always --disable-shared, the test was removed, and we
-  # assume the GNU/Linux dynamic linker is in use.
-  dynamic_linker='GNU/Linux ld.so'
-  ;;
-
-netbsd*)
-  version_type=sunos
-  need_lib_prefix=no
-  need_version=no
-  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
-    dynamic_linker='NetBSD (a.out) ld.so'
-  else
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    dynamic_linker='NetBSD ld.elf_so'
-  fi
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  hardcode_into_libs=yes
-  ;;
-
-newsos6)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  ;;
-
-*nto* | *qnx*)
-  version_type=qnx
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  dynamic_linker='ldqnx.so'
-  ;;
-
-openbsd*)
-  version_type=sunos
-  sys_lib_dlsearch_path_spec="/usr/lib"
-  need_lib_prefix=no
-  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
-  case $host_os in
-    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
-    *)				need_version=no  ;;
-  esac
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-    case $host_os in
-      openbsd2.[89] | openbsd2.[89].*)
-	shlibpath_overrides_runpath=no
-	;;
-      *)
-	shlibpath_overrides_runpath=yes
-	;;
-      esac
-  else
-    shlibpath_overrides_runpath=yes
-  fi
-  ;;
-
-os2*)
-  libname_spec='$name'
-  shrext_cmds=".dll"
-  need_lib_prefix=no
-  library_names_spec='$libname${shared_ext} $libname.a'
-  dynamic_linker='OS/2 ld.exe'
-  shlibpath_var=LIBPATH
-  ;;
-
-osf3* | osf4* | osf5*)
-  version_type=osf
-  need_lib_prefix=no
-  need_version=no
-  soname_spec='${libname}${release}${shared_ext}$major'
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
-  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
-  ;;
-
-rdos*)
-  dynamic_linker=no
-  ;;
-
-solaris*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  hardcode_into_libs=yes
-  # ldd complains unless libraries are executable
-  postinstall_cmds='chmod +x $lib'
-  ;;
-
-sunos4*)
-  version_type=sunos
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  if test "$with_gnu_ld" = yes; then
-    need_lib_prefix=no
-  fi
-  need_version=yes
-  ;;
-
-sysv4 | sysv4.3*)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  case $host_vendor in
-    sni)
-      shlibpath_overrides_runpath=no
-      need_lib_prefix=no
-      runpath_var=LD_RUN_PATH
-      ;;
-    siemens)
-      need_lib_prefix=no
-      ;;
-    motorola)
-      need_lib_prefix=no
-      need_version=no
-      shlibpath_overrides_runpath=no
-      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
-      ;;
-  esac
-  ;;
-
-sysv4*MP*)
-  if test -d /usr/nec ;then
-    version_type=linux
-    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
-    soname_spec='$libname${shared_ext}.$major'
-    shlibpath_var=LD_LIBRARY_PATH
-  fi
-  ;;
-
-sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
-  version_type=freebsd-elf
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  hardcode_into_libs=yes
-  if test "$with_gnu_ld" = yes; then
-    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
-  else
-    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
-    case $host_os in
-      sco3.2v5*)
-        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
-	;;
-    esac
-  fi
-  sys_lib_dlsearch_path_spec='/usr/lib'
-  ;;
-
-tpf*)
-  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  ;;
-
-uts4*)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  ;;
-
-*)
-  dynamic_linker=no
-  ;;
-esac
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $dynamic_linker" >&5
-$as_echo "$dynamic_linker" >&6; }
-test "$dynamic_linker" = no && can_build_shared=no
-
-variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
-if test "$GCC" = yes; then
-  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
-fi
-
-if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
-  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
-fi
-if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
-  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking how to hardcode library paths into programs" >&5
-$as_echo_n "checking how to hardcode library paths into programs... " >&6; }
-hardcode_action=
-if test -n "$hardcode_libdir_flag_spec" ||
-   test -n "$runpath_var" ||
-   test "X$hardcode_automatic" = "Xyes" ; then
-
-  # We can hardcode non-existent directories.
-  if test "$hardcode_direct" != no &&
-     # If the only mechanism to avoid hardcoding is shlibpath_var, we
-     # have to relink, otherwise we might link with an installed library
-     # when we should be linking with a yet-to-be-installed one
-     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, )" != no &&
-     test "$hardcode_minus_L" != no; then
-    # Linking always hardcodes the temporary library directory.
-    hardcode_action=relink
-  else
-    # We can link without hardcoding, and we can hardcode nonexisting dirs.
-    hardcode_action=immediate
-  fi
-else
-  # We cannot hardcode anything, or else we can only hardcode existing
-  # directories.
-  hardcode_action=unsupported
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action" >&5
-$as_echo "$hardcode_action" >&6; }
-
-if test "$hardcode_action" = relink ||
-   test "$inherit_rpath" = yes; then
-  # Fast installation is not supported
-  enable_fast_install=no
-elif test "$shlibpath_overrides_runpath" = yes ||
-     test "$enable_shared" = no; then
-  # Fast installation is not necessary
-  enable_fast_install=needless
-fi
-
-
-
-
-
-
-  if test "x$enable_dlopen" != xyes; then
-  enable_dlopen=unknown
-  enable_dlopen_self=unknown
-  enable_dlopen_self_static=unknown
-else
-  lt_cv_dlopen=no
-  lt_cv_dlopen_libs=
-
-  case $host_os in
-  beos*)
-    lt_cv_dlopen="load_add_on"
-    lt_cv_dlopen_libs=
-    lt_cv_dlopen_self=yes
-    ;;
-
-  mingw* | pw32* | cegcc*)
-    lt_cv_dlopen="LoadLibrary"
-    lt_cv_dlopen_libs=
-    ;;
-
-  cygwin*)
-    lt_cv_dlopen="dlopen"
-    lt_cv_dlopen_libs=
-    ;;
-
-  darwin*)
-  # if libdl is installed we need to link against it
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
-$as_echo_n "checking for dlopen in -ldl... " >&6; }
-if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldl  $LIBS"
-if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dlopen ();
-int
-main ()
-{
-return dlopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dl_dlopen=yes
-else
-  ac_cv_lib_dl_dlopen=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
-$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
-if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
-else
-
-    lt_cv_dlopen="dyld"
-    lt_cv_dlopen_libs=
-    lt_cv_dlopen_self=yes
-
-fi
-
-    ;;
-
-  *)
-    ac_fn_c_check_func "$LINENO" "shl_load" "ac_cv_func_shl_load"
-if test "x$ac_cv_func_shl_load" = x""yes; then :
-  lt_cv_dlopen="shl_load"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shl_load in -ldld" >&5
-$as_echo_n "checking for shl_load in -ldld... " >&6; }
-if test "${ac_cv_lib_dld_shl_load+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldld  $LIBS"
-if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char shl_load ();
-int
-main ()
-{
-return shl_load ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dld_shl_load=yes
-else
-  ac_cv_lib_dld_shl_load=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_shl_load" >&5
-$as_echo "$ac_cv_lib_dld_shl_load" >&6; }
-if test "x$ac_cv_lib_dld_shl_load" = x""yes; then :
-  lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"
-else
-  ac_fn_c_check_func "$LINENO" "dlopen" "ac_cv_func_dlopen"
-if test "x$ac_cv_func_dlopen" = x""yes; then :
-  lt_cv_dlopen="dlopen"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
-$as_echo_n "checking for dlopen in -ldl... " >&6; }
-if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldl  $LIBS"
-if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dlopen ();
-int
-main ()
-{
-return dlopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dl_dlopen=yes
-else
-  ac_cv_lib_dl_dlopen=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
-$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
-if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -lsvld" >&5
-$as_echo_n "checking for dlopen in -lsvld... " >&6; }
-if test "${ac_cv_lib_svld_dlopen+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lsvld  $LIBS"
-if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dlopen ();
-int
-main ()
-{
-return dlopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_svld_dlopen=yes
-else
-  ac_cv_lib_svld_dlopen=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_svld_dlopen" >&5
-$as_echo "$ac_cv_lib_svld_dlopen" >&6; }
-if test "x$ac_cv_lib_svld_dlopen" = x""yes; then :
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dld_link in -ldld" >&5
-$as_echo_n "checking for dld_link in -ldld... " >&6; }
-if test "${ac_cv_lib_dld_dld_link+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldld  $LIBS"
-if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dld_link ();
-int
-main ()
-{
-return dld_link ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dld_dld_link=yes
-else
-  ac_cv_lib_dld_dld_link=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_dld_link" >&5
-$as_echo "$ac_cv_lib_dld_dld_link" >&6; }
-if test "x$ac_cv_lib_dld_dld_link" = x""yes; then :
-  lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"
-fi
-
-
-fi
-
-
-fi
-
-
-fi
-
-
-fi
-
-
-fi
-
-    ;;
-  esac
-
-  if test "x$lt_cv_dlopen" != xno; then
-    enable_dlopen=yes
-  else
-    enable_dlopen=no
-  fi
-
-  case $lt_cv_dlopen in
-  dlopen)
-    save_CPPFLAGS="$CPPFLAGS"
-    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
-
-    save_LDFLAGS="$LDFLAGS"
-    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
-
-    save_LIBS="$LIBS"
-    LIBS="$lt_cv_dlopen_libs $LIBS"
-
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a program can dlopen itself" >&5
-$as_echo_n "checking whether a program can dlopen itself... " >&6; }
-if test "${lt_cv_dlopen_self+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  	  if test "$cross_compiling" = yes; then :
-  lt_cv_dlopen_self=cross
-else
-  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
-  lt_status=$lt_dlunknown
-  cat > conftest.$ac_ext <<_LT_EOF
-#line 10389 "configure"
-#include "confdefs.h"
-
-#if HAVE_DLFCN_H
-#include <dlfcn.h>
-#endif
-
-#include <stdio.h>
-
-#ifdef RTLD_GLOBAL
-#  define LT_DLGLOBAL		RTLD_GLOBAL
-#else
-#  ifdef DL_GLOBAL
-#    define LT_DLGLOBAL		DL_GLOBAL
-#  else
-#    define LT_DLGLOBAL		0
-#  endif
-#endif
-
-/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
-   find out it does not work in some platform. */
-#ifndef LT_DLLAZY_OR_NOW
-#  ifdef RTLD_LAZY
-#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
-#  else
-#    ifdef DL_LAZY
-#      define LT_DLLAZY_OR_NOW		DL_LAZY
-#    else
-#      ifdef RTLD_NOW
-#        define LT_DLLAZY_OR_NOW	RTLD_NOW
-#      else
-#        ifdef DL_NOW
-#          define LT_DLLAZY_OR_NOW	DL_NOW
-#        else
-#          define LT_DLLAZY_OR_NOW	0
-#        endif
-#      endif
-#    endif
-#  endif
-#endif
-
-/* When -fvisbility=hidden is used, assume the code has been annotated
-   correspondingly for the symbols needed.  */
-#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
-void fnord () __attribute__((visibility("default")));
-#endif
-
-void fnord () { int i=42; }
-int main ()
-{
-  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
-  int status = $lt_dlunknown;
-
-  if (self)
-    {
-      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
-      else
-        {
-	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
-          else puts (dlerror ());
-	}
-      /* dlclose (self); */
-    }
-  else
-    puts (dlerror ());
-
-  return status;
-}
-_LT_EOF
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
-    (./conftest; exit; ) >&5 2>/dev/null
-    lt_status=$?
-    case x$lt_status in
-      x$lt_dlno_uscore) lt_cv_dlopen_self=yes ;;
-      x$lt_dlneed_uscore) lt_cv_dlopen_self=yes ;;
-      x$lt_dlunknown|x*) lt_cv_dlopen_self=no ;;
-    esac
-  else :
-    # compilation failed
-    lt_cv_dlopen_self=no
-  fi
-fi
-rm -fr conftest*
-
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self" >&5
-$as_echo "$lt_cv_dlopen_self" >&6; }
-
-    if test "x$lt_cv_dlopen_self" = xyes; then
-      wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a statically linked program can dlopen itself" >&5
-$as_echo_n "checking whether a statically linked program can dlopen itself... " >&6; }
-if test "${lt_cv_dlopen_self_static+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  	  if test "$cross_compiling" = yes; then :
-  lt_cv_dlopen_self_static=cross
-else
-  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
-  lt_status=$lt_dlunknown
-  cat > conftest.$ac_ext <<_LT_EOF
-#line 10495 "configure"
-#include "confdefs.h"
-
-#if HAVE_DLFCN_H
-#include <dlfcn.h>
-#endif
-
-#include <stdio.h>
-
-#ifdef RTLD_GLOBAL
-#  define LT_DLGLOBAL		RTLD_GLOBAL
-#else
-#  ifdef DL_GLOBAL
-#    define LT_DLGLOBAL		DL_GLOBAL
-#  else
-#    define LT_DLGLOBAL		0
-#  endif
-#endif
-
-/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
-   find out it does not work in some platform. */
-#ifndef LT_DLLAZY_OR_NOW
-#  ifdef RTLD_LAZY
-#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
-#  else
-#    ifdef DL_LAZY
-#      define LT_DLLAZY_OR_NOW		DL_LAZY
-#    else
-#      ifdef RTLD_NOW
-#        define LT_DLLAZY_OR_NOW	RTLD_NOW
-#      else
-#        ifdef DL_NOW
-#          define LT_DLLAZY_OR_NOW	DL_NOW
-#        else
-#          define LT_DLLAZY_OR_NOW	0
-#        endif
-#      endif
-#    endif
-#  endif
-#endif
-
-/* When -fvisbility=hidden is used, assume the code has been annotated
-   correspondingly for the symbols needed.  */
-#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
-void fnord () __attribute__((visibility("default")));
-#endif
-
-void fnord () { int i=42; }
-int main ()
-{
-  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
-  int status = $lt_dlunknown;
-
-  if (self)
-    {
-      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
-      else
-        {
-	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
-          else puts (dlerror ());
-	}
-      /* dlclose (self); */
-    }
-  else
-    puts (dlerror ());
-
-  return status;
-}
-_LT_EOF
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
-    (./conftest; exit; ) >&5 2>/dev/null
-    lt_status=$?
-    case x$lt_status in
-      x$lt_dlno_uscore) lt_cv_dlopen_self_static=yes ;;
-      x$lt_dlneed_uscore) lt_cv_dlopen_self_static=yes ;;
-      x$lt_dlunknown|x*) lt_cv_dlopen_self_static=no ;;
-    esac
-  else :
-    # compilation failed
-    lt_cv_dlopen_self_static=no
-  fi
-fi
-rm -fr conftest*
-
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self_static" >&5
-$as_echo "$lt_cv_dlopen_self_static" >&6; }
-    fi
-
-    CPPFLAGS="$save_CPPFLAGS"
-    LDFLAGS="$save_LDFLAGS"
-    LIBS="$save_LIBS"
-    ;;
-  esac
-
-  case $lt_cv_dlopen_self in
-  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
-  *) enable_dlopen_self=unknown ;;
-  esac
-
-  case $lt_cv_dlopen_self_static in
-  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
-  *) enable_dlopen_self_static=unknown ;;
-  esac
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-striplib=
-old_striplib=
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether stripping libraries is possible" >&5
-$as_echo_n "checking whether stripping libraries is possible... " >&6; }
-if test -n "$STRIP" && $STRIP -V 2>&1 | $GREP "GNU strip" >/dev/null; then
-  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
-  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-else
-# FIXME - insert some real tests, host_os isn't really good enough
-  case $host_os in
-  darwin*)
-    if test -n "$STRIP" ; then
-      striplib="$STRIP -x"
-      old_striplib="$STRIP -S"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-    else
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-    fi
-    ;;
-  *)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-    ;;
-  esac
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-  # Report which library types will actually be built
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if libtool supports shared libraries" >&5
-$as_echo_n "checking if libtool supports shared libraries... " >&6; }
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $can_build_shared" >&5
-$as_echo "$can_build_shared" >&6; }
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build shared libraries" >&5
-$as_echo_n "checking whether to build shared libraries... " >&6; }
-  test "$can_build_shared" = "no" && enable_shared=no
-
-  # On AIX, shared libraries and static libraries use the same namespace, and
-  # are all built from PIC.
-  case $host_os in
-  aix3*)
-    test "$enable_shared" = yes && enable_static=no
-    if test -n "$RANLIB"; then
-      archive_cmds="$archive_cmds~\$RANLIB \$lib"
-      postinstall_cmds='$RANLIB $lib'
-    fi
-    ;;
-
-  aix[4-9]*)
-    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
-      test "$enable_shared" = yes && enable_static=no
-    fi
-    ;;
-  esac
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_shared" >&5
-$as_echo "$enable_shared" >&6; }
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build static libraries" >&5
-$as_echo_n "checking whether to build static libraries... " >&6; }
-  # Make sure either enable_shared or enable_static is yes.
-  test "$enable_shared" = yes || enable_static=yes
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_static" >&5
-$as_echo "$enable_static" >&6; }
-
-
-
-
-fi
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-CC="$lt_save_CC"
-
-
-
-
-
-
-
-
-
-
-
-
-
-        ac_config_commands="$ac_config_commands libtool"
-
-
-
-
-# Only expand once:
-
-
-
-# Find CPP now so that any conditional tests below won't do it and
-# thereby make the resulting definitions conditional.
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
-$as_echo_n "checking how to run the C preprocessor... " >&6; }
-# On Suns, sometimes $CPP names a directory.
-if test -n "$CPP" && test -d "$CPP"; then
-  CPP=
-fi
-if test -z "$CPP"; then
-  if test "${ac_cv_prog_CPP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-      # Double quotes because CPP needs to be expanded
-    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
-    do
-      ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-  break
-fi
-
-    done
-    ac_cv_prog_CPP=$CPP
-
-fi
-  CPP=$ac_cv_prog_CPP
-else
-  ac_cv_prog_CPP=$CPP
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
-$as_echo "$CPP" >&6; }
-ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-
-else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details." "$LINENO" 5; }
-fi
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-if test -n "$with_cross_host"; then
-   # We are being configured with a cross compiler.  AC_REPLACE_FUNCS
-   # may not work correctly, because the compiler may not be able to
-   # link executables.
-
-   # We assume newlib.  This lets us hard-code the functions we know
-   # we'll have.
-   $as_echo "#define HAVE_MEMCPY 1" >>confdefs.h
-
-   $as_echo "#define HAVE_STRERROR 1" >>confdefs.h
-
-
-   # We ignore --with-system-zlib in this case.
-   target_all=libzgcj.la
-else
-   if test x$gcc_no_link = xyes; then
-  if test "x${ac_cv_func_mmap_fixed_mapped+set}" != xset; then
-    ac_cv_func_mmap_fixed_mapped=no
-  fi
-fi
-if test "x${ac_cv_func_mmap_fixed_mapped}" != xno; then
-  for ac_header in stdlib.h unistd.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-for ac_func in getpagesize
-do :
-  ac_fn_c_check_func "$LINENO" "getpagesize" "ac_cv_func_getpagesize"
-if test "x$ac_cv_func_getpagesize" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_GETPAGESIZE 1
-_ACEOF
-
-fi
-done
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for working mmap" >&5
-$as_echo_n "checking for working mmap... " >&6; }
-if test "${ac_cv_func_mmap_fixed_mapped+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then :
-  ac_cv_func_mmap_fixed_mapped=no
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$ac_includes_default
-/* malloc might have been renamed as rpl_malloc. */
-#undef malloc
-
-/* Thanks to Mike Haertel and Jim Avera for this test.
-   Here is a matrix of mmap possibilities:
-	mmap private not fixed
-	mmap private fixed at somewhere currently unmapped
-	mmap private fixed at somewhere already mapped
-	mmap shared not fixed
-	mmap shared fixed at somewhere currently unmapped
-	mmap shared fixed at somewhere already mapped
-   For private mappings, we should verify that changes cannot be read()
-   back from the file, nor mmap's back from the file at a different
-   address.  (There have been systems where private was not correctly
-   implemented like the infamous i386 svr4.0, and systems where the
-   VM page cache was not coherent with the file system buffer cache
-   like early versions of FreeBSD and possibly contemporary NetBSD.)
-   For shared mappings, we should conversely verify that changes get
-   propagated back to all the places they're supposed to be.
-
-   Grep wants private fixed already mapped.
-   The main things grep needs to know about mmap are:
-   * does it exist and is it safe to write into the mmap'd area
-   * how to use it (BSD variants)  */
-
-#include <fcntl.h>
-#include <sys/mman.h>
-
-#if !defined STDC_HEADERS && !defined HAVE_STDLIB_H
-char *malloc ();
-#endif
-
-/* This mess was copied from the GNU getpagesize.h.  */
-#ifndef HAVE_GETPAGESIZE
-/* Assume that all systems that can run configure have sys/param.h.  */
-# ifndef HAVE_SYS_PARAM_H
-#  define HAVE_SYS_PARAM_H 1
-# endif
-
-# ifdef _SC_PAGESIZE
-#  define getpagesize() sysconf(_SC_PAGESIZE)
-# else /* no _SC_PAGESIZE */
-#  ifdef HAVE_SYS_PARAM_H
-#   include <sys/param.h>
-#   ifdef EXEC_PAGESIZE
-#    define getpagesize() EXEC_PAGESIZE
-#   else /* no EXEC_PAGESIZE */
-#    ifdef NBPG
-#     define getpagesize() NBPG * CLSIZE
-#     ifndef CLSIZE
-#      define CLSIZE 1
-#     endif /* no CLSIZE */
-#    else /* no NBPG */
-#     ifdef NBPC
-#      define getpagesize() NBPC
-#     else /* no NBPC */
-#      ifdef PAGESIZE
-#       define getpagesize() PAGESIZE
-#      endif /* PAGESIZE */
-#     endif /* no NBPC */
-#    endif /* no NBPG */
-#   endif /* no EXEC_PAGESIZE */
-#  else /* no HAVE_SYS_PARAM_H */
-#   define getpagesize() 8192	/* punt totally */
-#  endif /* no HAVE_SYS_PARAM_H */
-# endif /* no _SC_PAGESIZE */
-
-#endif /* no HAVE_GETPAGESIZE */
-
-int
-main ()
-{
-  char *data, *data2, *data3;
-  int i, pagesize;
-  int fd;
-
-  pagesize = getpagesize ();
-
-  /* First, make a file with some known garbage in it. */
-  data = (char *) malloc (pagesize);
-  if (!data)
-    return 1;
-  for (i = 0; i < pagesize; ++i)
-    *(data + i) = rand ();
-  umask (0);
-  fd = creat ("conftest.mmap", 0600);
-  if (fd < 0)
-    return 1;
-  if (write (fd, data, pagesize) != pagesize)
-    return 1;
-  close (fd);
-
-  /* Next, try to mmap the file at a fixed address which already has
-     something else allocated at it.  If we can, also make sure that
-     we see the same garbage.  */
-  fd = open ("conftest.mmap", O_RDWR);
-  if (fd < 0)
-    return 1;
-  data2 = (char *) malloc (2 * pagesize);
-  if (!data2)
-    return 1;
-  data2 += (pagesize - ((long int) data2 & (pagesize - 1))) & (pagesize - 1);
-  if (data2 != mmap (data2, pagesize, PROT_READ | PROT_WRITE,
-		     MAP_PRIVATE | MAP_FIXED, fd, 0L))
-    return 1;
-  for (i = 0; i < pagesize; ++i)
-    if (*(data + i) != *(data2 + i))
-      return 1;
-
-  /* Finally, make sure that changes to the mapped area do not
-     percolate back to the file as seen by read().  (This is a bug on
-     some variants of i386 svr4.0.)  */
-  for (i = 0; i < pagesize; ++i)
-    *(data2 + i) = *(data2 + i) + 1;
-  data3 = (char *) malloc (pagesize);
-  if (!data3)
-    return 1;
-  if (read (fd, data3, pagesize) != pagesize)
-    return 1;
-  for (i = 0; i < pagesize; ++i)
-    if (*(data + i) != *(data3 + i))
-      return 1;
-  close (fd);
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
-  ac_cv_func_mmap_fixed_mapped=yes
-else
-  ac_cv_func_mmap_fixed_mapped=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_func_mmap_fixed_mapped" >&5
-$as_echo "$ac_cv_func_mmap_fixed_mapped" >&6; }
-if test $ac_cv_func_mmap_fixed_mapped = yes; then
-
-$as_echo "#define HAVE_MMAP 1" >>confdefs.h
-
-fi
-rm -f conftest.mmap
-
-fi
-   for ac_func in memcpy strerror
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-done
-
-
-   if test "$with_system_zlib" = yes; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for deflate in -lz" >&5
-$as_echo_n "checking for deflate in -lz... " >&6; }
-if test "${ac_cv_lib_z_deflate+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lz  $LIBS"
-if test x$gcc_no_link = xyes; then
-  as_fn_error "Link tests are not allowed after GCC_NO_EXECUTABLES." "$LINENO" 5
-fi
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char deflate ();
-int
-main ()
-{
-return deflate ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_z_deflate=yes
-else
-  ac_cv_lib_z_deflate=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_z_deflate" >&5
-$as_echo "$ac_cv_lib_z_deflate" >&6; }
-if test "x$ac_cv_lib_z_deflate" = x""yes; then :
-  target_all=
-else
-  target_all=libzgcj.la
-fi
-
-   else
-      target_all=libzgcj.la
-   fi
-fi
-
-
-
-for ac_header in unistd.h
-do :
-  ac_fn_c_check_header_mongrel "$LINENO" "unistd.h" "ac_cv_header_unistd_h" "$ac_includes_default"
-if test "x$ac_cv_header_unistd_h" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_UNISTD_H 1
-_ACEOF
-
-fi
-
-done
-
-
-if test -n "$with_cross_host" &&
-   test x"$with_cross_host" != x"no"; then
-  toolexecdir='$(exec_prefix)/$(target_alias)'
-  toolexeclibdir='$(toolexecdir)/lib'
-else
-  toolexecdir='$(libdir)/gcc-lib/$(target_alias)'
-  toolexeclibdir='$(libdir)'
-fi
-if test "$GCC" = yes && $CC -print-multi-os-directory > /dev/null 2>&1; then
-  multiosdir=/`$CC -print-multi-os-directory`
-  case $multiosdir in
-    /.) multiosdir= ;; # Avoid trailing /.
-  esac
-else
-  multiosdir=
-fi
-toolexeclibdir=${toolexeclibdir}${multiosdir}
-
-
-
- if test -n "$with_target_subdir"; then
-  TARGET_LIBRARY_TRUE=
-  TARGET_LIBRARY_FALSE='#'
-else
-  TARGET_LIBRARY_TRUE='#'
-  TARGET_LIBRARY_FALSE=
-fi
-
-
-if test "${multilib}" = "yes"; then
-  multilib_arg="--enable-multilib"
-else
-  multilib_arg=
-fi
-
-ac_config_files="$ac_config_files Makefile"
-
-cat >confcache <<\_ACEOF
-# This file is a shell script that caches the results of configure
-# tests run on this system so they can be shared between configure
-# scripts and configure runs, see configure's option --config-cache.
-# It is not useful on other systems.  If it contains results you don't
-# want to keep, you may remove or edit it.
-#
-# config.status only pays attention to the cache file if you give it
-# the --recheck option to rerun configure.
-#
-# `ac_cv_env_foo' variables (set or unset) will be overridden when
-# loading this file, other *unset* `ac_cv_foo' will be assigned the
-# following values.
-
-_ACEOF
-
-# The following way of writing the cache mishandles newlines in values,
-# but we know of no workaround that is simple, portable, and efficient.
-# So, we kill variables containing newlines.
-# Ultrix sh set writes to stderr and can't be redirected directly,
-# and sets the high bit in the cache file unless we assign to the vars.
-(
-  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
-    eval ac_val=\$$ac_var
-    case $ac_val in #(
-    *${as_nl}*)
-      case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
-$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
-      esac
-      case $ac_var in #(
-      _ | IFS | as_nl) ;; #(
-      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
-      *) { eval $ac_var=; unset $ac_var;} ;;
-      esac ;;
-    esac
-  done
-
-  (set) 2>&1 |
-    case $as_nl`(ac_space=' '; set) 2>&1` in #(
-    *${as_nl}ac_space=\ *)
-      # `set' does not quote correctly, so add quotes: double-quote
-      # substitution turns \\\\ into \\, and sed turns \\ into \.
-      sed -n \
-	"s/'/'\\\\''/g;
-	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
-      ;; #(
-    *)
-      # `set' quotes correctly as required by POSIX, so do not add quotes.
-      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
-      ;;
-    esac |
-    sort
-) |
-  sed '
-     /^ac_cv_env_/b end
-     t clear
-     :clear
-     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
-     t end
-     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
-     :end' >>confcache
-if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
-  if test -w "$cache_file"; then
-    test "x$cache_file" != "x/dev/null" &&
-      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
-$as_echo "$as_me: updating cache $cache_file" >&6;}
-    cat confcache >$cache_file
-  else
-    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
-$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
-  fi
-fi
-rm -f confcache
-
-test "x$prefix" = xNONE && prefix=$ac_default_prefix
-# Let make expand exec_prefix.
-test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
-
-# Transform confdefs.h into DEFS.
-# Protect against shell expansion while executing Makefile rules.
-# Protect against Makefile macro expansion.
-#
-# If the first sed substitution is executed (which looks for macros that
-# take arguments), then branch to the quote section.  Otherwise,
-# look for a macro that doesn't take arguments.
-ac_script='
-:mline
-/\\$/{
- N
- s,\\\n,,
- b mline
-}
-t clear
-:clear
-s/^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*([^)]*)\)[	 ]*\(.*\)/-D\1=\2/g
-t quote
-s/^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\)/-D\1=\2/g
-t quote
-b any
-:quote
-s/[	 `~#$^&*(){}\\|;'\''"<>?]/\\&/g
-s/\[/\\&/g
-s/\]/\\&/g
-s/\$/$$/g
-H
-:any
-${
-	g
-	s/^\n//
-	s/\n/ /g
-	p
-}
-'
-DEFS=`sed -n "$ac_script" confdefs.h`
-
-
-ac_libobjs=
-ac_ltlibobjs=
-for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
-  # 1. Remove the extension, and $U if already installed.
-  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
-  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
-  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
-  #    will be set to the directory where LIBOBJS objects are built.
-  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
-  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
-done
-LIBOBJS=$ac_libobjs
-
-LTLIBOBJS=$ac_ltlibobjs
-
-
- if test -n "$EXEEXT"; then
-  am__EXEEXT_TRUE=
-  am__EXEEXT_FALSE='#'
-else
-  am__EXEEXT_TRUE='#'
-  am__EXEEXT_FALSE=
-fi
-
-if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
-  as_fn_error "conditional \"MAINTAINER_MODE\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
-fi
-if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
-  as_fn_error "conditional \"AMDEP\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
-fi
-if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
-  as_fn_error "conditional \"am__fastdepCC\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
-fi
-if test -z "${TARGET_LIBRARY_TRUE}" && test -z "${TARGET_LIBRARY_FALSE}"; then
-  as_fn_error "conditional \"TARGET_LIBRARY\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
-fi
-
-: ${CONFIG_STATUS=./config.status}
-ac_write_fail=0
-ac_clean_files_save=$ac_clean_files
-ac_clean_files="$ac_clean_files $CONFIG_STATUS"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
-$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
-as_write_fail=0
-cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
-#! $SHELL
-# Generated by $as_me.
-# Run this file to recreate the current configuration.
-# Compiler output produced by configure, useful for debugging
-# configure, is in config.log if it exists.
-
-debug=false
-ac_cs_recheck=false
-ac_cs_silent=false
-
-SHELL=\${CONFIG_SHELL-$SHELL}
-export SHELL
-_ASEOF
-cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
-## -------------------- ##
-## M4sh Initialization. ##
-## -------------------- ##
-
-# Be more Bourne compatible
-DUALCASE=1; export DUALCASE # for MKS sh
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
-  emulate sh
-  NULLCMD=:
-  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in #(
-  *posix*) :
-    set -o posix ;; #(
-  *) :
-     ;;
-esac
-fi
-
-
-as_nl='
-'
-export as_nl
-# Printing a long string crashes Solaris 7 /usr/bin/printf.
-as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
-# Prefer a ksh shell builtin over an external printf program on Solaris,
-# but without wasting forks for bash or zsh.
-if test -z "$BASH_VERSION$ZSH_VERSION" \
-    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='print -r --'
-  as_echo_n='print -rn --'
-elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='printf %s\n'
-  as_echo_n='printf %s'
-else
-  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
-    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
-    as_echo_n='/usr/ucb/echo -n'
-  else
-    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
-    as_echo_n_body='eval
-      arg=$1;
-      case $arg in #(
-      *"$as_nl"*)
-	expr "X$arg" : "X\\(.*\\)$as_nl";
-	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
-      esac;
-      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
-    '
-    export as_echo_n_body
-    as_echo_n='sh -c $as_echo_n_body as_echo'
-  fi
-  export as_echo_body
-  as_echo='sh -c $as_echo_body as_echo'
-fi
-
-# The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
-  PATH_SEPARATOR=:
-  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
-    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
-      PATH_SEPARATOR=';'
-  }
-fi
-
-
-# IFS
-# We need space, tab and new line, in precisely that order.  Quoting is
-# there to prevent editors from complaining about space-tab.
-# (If _AS_PATH_WALK were called with IFS unset, it would disable word
-# splitting by setting IFS to empty value.)
-IFS=" ""	$as_nl"
-
-# Find who we are.  Look in the path if we contain no directory separator.
-case $0 in #((
-  *[\\/]* ) as_myself=$0 ;;
-  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-  done
-IFS=$as_save_IFS
-
-     ;;
-esac
-# We did not find ourselves, most probably we were run as `sh COMMAND'
-# in which case we are not to be found in the path.
-if test "x$as_myself" = x; then
-  as_myself=$0
-fi
-if test ! -f "$as_myself"; then
-  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
-  exit 1
-fi
-
-# Unset variables that we do not need and which cause bugs (e.g. in
-# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
-# suppresses any "Segmentation fault" message there.  '((' could
-# trigger a bug in pdksh 5.2.14.
-for as_var in BASH_ENV ENV MAIL MAILPATH
-do eval test x\${$as_var+set} = xset \
-  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
-done
-PS1='$ '
-PS2='> '
-PS4='+ '
-
-# NLS nuisances.
-LC_ALL=C
-export LC_ALL
-LANGUAGE=C
-export LANGUAGE
-
-# CDPATH.
-(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
-
-
-# as_fn_error ERROR [LINENO LOG_FD]
-# ---------------------------------
-# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
-# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with status $?, using 1 if that was 0.
-as_fn_error ()
-{
-  as_status=$?; test $as_status -eq 0 && as_status=1
-  if test "$3"; then
-    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
-  fi
-  $as_echo "$as_me: error: $1" >&2
-  as_fn_exit $as_status
-} # as_fn_error
-
-
-# as_fn_set_status STATUS
-# -----------------------
-# Set $? to STATUS, without forking.
-as_fn_set_status ()
-{
-  return $1
-} # as_fn_set_status
-
-# as_fn_exit STATUS
-# -----------------
-# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
-as_fn_exit ()
-{
-  set +e
-  as_fn_set_status $1
-  exit $1
-} # as_fn_exit
-
-# as_fn_unset VAR
-# ---------------
-# Portably unset VAR.
-as_fn_unset ()
-{
-  { eval $1=; unset $1;}
-}
-as_unset=as_fn_unset
-# as_fn_append VAR VALUE
-# ----------------------
-# Append the text in VALUE to the end of the definition contained in VAR. Take
-# advantage of any shell optimizations that allow amortized linear growth over
-# repeated appends, instead of the typical quadratic growth present in naive
-# implementations.
-if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
-  eval 'as_fn_append ()
-  {
-    eval $1+=\$2
-  }'
-else
-  as_fn_append ()
-  {
-    eval $1=\$$1\$2
-  }
-fi # as_fn_append
-
-# as_fn_arith ARG...
-# ------------------
-# Perform arithmetic evaluation on the ARGs, and store the result in the
-# global $as_val. Take advantage of shells that can avoid forks. The arguments
-# must be portable across $(()) and expr.
-if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
-  eval 'as_fn_arith ()
-  {
-    as_val=$(( $* ))
-  }'
-else
-  as_fn_arith ()
-  {
-    as_val=`expr "$@" || test $? -eq 1`
-  }
-fi # as_fn_arith
-
-
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
-  as_basename=basename
-else
-  as_basename=false
-fi
-
-if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
-  as_dirname=dirname
-else
-  as_dirname=false
-fi
-
-as_me=`$as_basename -- "$0" ||
-$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
-	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X/"$0" |
-    sed '/^.*\/\([^/][^/]*\)\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
-ECHO_C= ECHO_N= ECHO_T=
-case `echo -n x` in #(((((
--n*)
-  case `echo 'xy\c'` in
-  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
-  xy)  ECHO_C='\c';;
-  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
-       ECHO_T='	';;
-  esac;;
-*)
-  ECHO_N='-n';;
-esac
-
-rm -f conf$$ conf$$.exe conf$$.file
-if test -d conf$$.dir; then
-  rm -f conf$$.dir/conf$$.file
-else
-  rm -f conf$$.dir
-  mkdir conf$$.dir 2>/dev/null
-fi
-if (echo >conf$$.file) 2>/dev/null; then
-  if ln -s conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s='ln -s'
-    # ... but there are two gotchas:
-    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
-    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
-    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
-  elif ln conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s=ln
-  else
-    as_ln_s='cp -p'
-  fi
-else
-  as_ln_s='cp -p'
-fi
-rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
-rmdir conf$$.dir 2>/dev/null
-
-
-# as_fn_mkdir_p
-# -------------
-# Create "$as_dir" as a directory, including parents if necessary.
-as_fn_mkdir_p ()
-{
-
-  case $as_dir in #(
-  -*) as_dir=./$as_dir;;
-  esac
-  test -d "$as_dir" || eval $as_mkdir_p || {
-    as_dirs=
-    while :; do
-      case $as_dir in #(
-      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
-      *) as_qdir=$as_dir;;
-      esac
-      as_dirs="'$as_qdir' $as_dirs"
-      as_dir=`$as_dirname -- "$as_dir" ||
-$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_dir" : 'X\(//\)[^/]' \| \
-	 X"$as_dir" : 'X\(//\)$' \| \
-	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_dir" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      test -d "$as_dir" && break
-    done
-    test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
-
-
-} # as_fn_mkdir_p
-if mkdir -p . 2>/dev/null; then
-  as_mkdir_p='mkdir -p "$as_dir"'
-else
-  test -d ./-p && rmdir ./-p
-  as_mkdir_p=false
-fi
-
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
-
-# Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
-
-# Sed expression to map a string onto a valid variable name.
-as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
-
-
-exec 6>&1
-## ----------------------------------- ##
-## Main body of $CONFIG_STATUS script. ##
-## ----------------------------------- ##
-_ASEOF
-test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-# Save the log message, to keep $0 and so on meaningful, and to
-# report actual input values of CONFIG_FILES etc. instead of their
-# values after options handling.
-ac_log="
-This file was extended by $as_me, which was
-generated by GNU Autoconf 2.64.  Invocation command line was
-
-  CONFIG_FILES    = $CONFIG_FILES
-  CONFIG_HEADERS  = $CONFIG_HEADERS
-  CONFIG_LINKS    = $CONFIG_LINKS
-  CONFIG_COMMANDS = $CONFIG_COMMANDS
-  $ $0 $@
-
-on `(hostname || uname -n) 2>/dev/null | sed 1q`
-"
-
-_ACEOF
-
-case $ac_config_files in *"
-"*) set x $ac_config_files; shift; ac_config_files=$*;;
-esac
-
-
-
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-# Files that config.status was made for.
-config_files="$ac_config_files"
-config_commands="$ac_config_commands"
-
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-ac_cs_usage="\
-\`$as_me' instantiates files and other configuration actions
-from templates according to the current configuration.  Unless the files
-and actions are specified as TAGs, all are instantiated by default.
-
-Usage: $0 [OPTION]... [TAG]...
-
-  -h, --help       print this help, then exit
-  -V, --version    print version number and configuration settings, then exit
-  -q, --quiet, --silent
-                   do not print progress messages
-  -d, --debug      don't remove temporary files
-      --recheck    update $as_me by reconfiguring in the same conditions
-      --file=FILE[:TEMPLATE]
-                   instantiate the configuration file FILE
-
-Configuration files:
-$config_files
-
-Configuration commands:
-$config_commands
-
-Report bugs to the package provider."
-
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-ac_cs_version="\\
-config.status
-configured by $0, generated by GNU Autoconf 2.64,
-  with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
-
-Copyright (C) 2009 Free Software Foundation, Inc.
-This config.status script is free software; the Free Software Foundation
-gives unlimited permission to copy, distribute and modify it."
-
-ac_pwd='$ac_pwd'
-srcdir='$srcdir'
-INSTALL='$INSTALL'
-MKDIR_P='$MKDIR_P'
-AWK='$AWK'
-test -n "\$AWK" || AWK=awk
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-# The default lists apply if the user does not specify any file.
-ac_need_defaults=:
-while test $# != 0
-do
-  case $1 in
-  --*=*)
-    ac_option=`expr "X$1" : 'X\([^=]*\)='`
-    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
-    ac_shift=:
-    ;;
-  *)
-    ac_option=$1
-    ac_optarg=$2
-    ac_shift=shift
-    ;;
-  esac
-
-  case $ac_option in
-  # Handling of the options.
-  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
-    ac_cs_recheck=: ;;
-  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
-    $as_echo "$ac_cs_version"; exit ;;
-  --debug | --debu | --deb | --de | --d | -d )
-    debug=: ;;
-  --file | --fil | --fi | --f )
-    $ac_shift
-    case $ac_optarg in
-    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
-    esac
-    as_fn_append CONFIG_FILES " '$ac_optarg'"
-    ac_need_defaults=false;;
-  --he | --h |  --help | --hel | -h )
-    $as_echo "$ac_cs_usage"; exit ;;
-  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-  | -silent | --silent | --silen | --sile | --sil | --si | --s)
-    ac_cs_silent=: ;;
-
-  # This is an error.
-  -*) as_fn_error "unrecognized option: \`$1'
-Try \`$0 --help' for more information." ;;
-
-  *) as_fn_append ac_config_targets " $1"
-     ac_need_defaults=false ;;
-
-  esac
-  shift
-done
-
-ac_configure_extra_args=
-
-if $ac_cs_silent; then
-  exec 6>/dev/null
-  ac_configure_extra_args="$ac_configure_extra_args --silent"
-fi
-
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-if \$ac_cs_recheck; then
-  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
-  shift
-  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
-  CONFIG_SHELL='$SHELL'
-  export CONFIG_SHELL
-  exec "\$@"
-fi
-
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-exec 5>>config.log
-{
-  echo
-  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
-## Running $as_me. ##
-_ASBOX
-  $as_echo "$ac_log"
-} >&5
-
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-#
-# INIT-COMMANDS
-#
-
-srcdir="$srcdir"
-host="$host"
-target="$target"
-with_multisubdir="$with_multisubdir"
-with_multisrctop="$with_multisrctop"
-with_target_subdir="$with_target_subdir"
-ac_configure_args="${multilib_arg} ${ac_configure_args}"
-multi_basedir="$multi_basedir"
-CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
-CC="$CC"
-CXX="$CXX"
-GFORTRAN="$GFORTRAN"
-GCJ="$GCJ"
-AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
-
-
-# The HP-UX ksh and POSIX shell print the target directory to stdout
-# if CDPATH is set.
-(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
-
-sed_quote_subst='$sed_quote_subst'
-double_quote_subst='$double_quote_subst'
-delay_variable_subst='$delay_variable_subst'
-macro_version='`$ECHO "$macro_version" | $SED "$delay_single_quote_subst"`'
-macro_revision='`$ECHO "$macro_revision" | $SED "$delay_single_quote_subst"`'
-enable_shared='`$ECHO "$enable_shared" | $SED "$delay_single_quote_subst"`'
-enable_static='`$ECHO "$enable_static" | $SED "$delay_single_quote_subst"`'
-pic_mode='`$ECHO "$pic_mode" | $SED "$delay_single_quote_subst"`'
-enable_fast_install='`$ECHO "$enable_fast_install" | $SED "$delay_single_quote_subst"`'
-SHELL='`$ECHO "$SHELL" | $SED "$delay_single_quote_subst"`'
-ECHO='`$ECHO "$ECHO" | $SED "$delay_single_quote_subst"`'
-host_alias='`$ECHO "$host_alias" | $SED "$delay_single_quote_subst"`'
-host='`$ECHO "$host" | $SED "$delay_single_quote_subst"`'
-host_os='`$ECHO "$host_os" | $SED "$delay_single_quote_subst"`'
-build_alias='`$ECHO "$build_alias" | $SED "$delay_single_quote_subst"`'
-build='`$ECHO "$build" | $SED "$delay_single_quote_subst"`'
-build_os='`$ECHO "$build_os" | $SED "$delay_single_quote_subst"`'
-SED='`$ECHO "$SED" | $SED "$delay_single_quote_subst"`'
-Xsed='`$ECHO "$Xsed" | $SED "$delay_single_quote_subst"`'
-GREP='`$ECHO "$GREP" | $SED "$delay_single_quote_subst"`'
-EGREP='`$ECHO "$EGREP" | $SED "$delay_single_quote_subst"`'
-FGREP='`$ECHO "$FGREP" | $SED "$delay_single_quote_subst"`'
-LD='`$ECHO "$LD" | $SED "$delay_single_quote_subst"`'
-NM='`$ECHO "$NM" | $SED "$delay_single_quote_subst"`'
-LN_S='`$ECHO "$LN_S" | $SED "$delay_single_quote_subst"`'
-max_cmd_len='`$ECHO "$max_cmd_len" | $SED "$delay_single_quote_subst"`'
-ac_objext='`$ECHO "$ac_objext" | $SED "$delay_single_quote_subst"`'
-exeext='`$ECHO "$exeext" | $SED "$delay_single_quote_subst"`'
-lt_unset='`$ECHO "$lt_unset" | $SED "$delay_single_quote_subst"`'
-lt_SP2NL='`$ECHO "$lt_SP2NL" | $SED "$delay_single_quote_subst"`'
-lt_NL2SP='`$ECHO "$lt_NL2SP" | $SED "$delay_single_quote_subst"`'
-reload_flag='`$ECHO "$reload_flag" | $SED "$delay_single_quote_subst"`'
-reload_cmds='`$ECHO "$reload_cmds" | $SED "$delay_single_quote_subst"`'
-OBJDUMP='`$ECHO "$OBJDUMP" | $SED "$delay_single_quote_subst"`'
-deplibs_check_method='`$ECHO "$deplibs_check_method" | $SED "$delay_single_quote_subst"`'
-file_magic_cmd='`$ECHO "$file_magic_cmd" | $SED "$delay_single_quote_subst"`'
-AR='`$ECHO "$AR" | $SED "$delay_single_quote_subst"`'
-AR_FLAGS='`$ECHO "$AR_FLAGS" | $SED "$delay_single_quote_subst"`'
-STRIP='`$ECHO "$STRIP" | $SED "$delay_single_quote_subst"`'
-RANLIB='`$ECHO "$RANLIB" | $SED "$delay_single_quote_subst"`'
-old_postinstall_cmds='`$ECHO "$old_postinstall_cmds" | $SED "$delay_single_quote_subst"`'
-old_postuninstall_cmds='`$ECHO "$old_postuninstall_cmds" | $SED "$delay_single_quote_subst"`'
-old_archive_cmds='`$ECHO "$old_archive_cmds" | $SED "$delay_single_quote_subst"`'
-lock_old_archive_extraction='`$ECHO "$lock_old_archive_extraction" | $SED "$delay_single_quote_subst"`'
-CC='`$ECHO "$CC" | $SED "$delay_single_quote_subst"`'
-CFLAGS='`$ECHO "$CFLAGS" | $SED "$delay_single_quote_subst"`'
-compiler='`$ECHO "$compiler" | $SED "$delay_single_quote_subst"`'
-GCC='`$ECHO "$GCC" | $SED "$delay_single_quote_subst"`'
-lt_cv_sys_global_symbol_pipe='`$ECHO "$lt_cv_sys_global_symbol_pipe" | $SED "$delay_single_quote_subst"`'
-lt_cv_sys_global_symbol_to_cdecl='`$ECHO "$lt_cv_sys_global_symbol_to_cdecl" | $SED "$delay_single_quote_subst"`'
-lt_cv_sys_global_symbol_to_c_name_address='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address" | $SED "$delay_single_quote_subst"`'
-lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address_lib_prefix" | $SED "$delay_single_quote_subst"`'
-objdir='`$ECHO "$objdir" | $SED "$delay_single_quote_subst"`'
-MAGIC_CMD='`$ECHO "$MAGIC_CMD" | $SED "$delay_single_quote_subst"`'
-lt_prog_compiler_no_builtin_flag='`$ECHO "$lt_prog_compiler_no_builtin_flag" | $SED "$delay_single_quote_subst"`'
-lt_prog_compiler_wl='`$ECHO "$lt_prog_compiler_wl" | $SED "$delay_single_quote_subst"`'
-lt_prog_compiler_pic='`$ECHO "$lt_prog_compiler_pic" | $SED "$delay_single_quote_subst"`'
-lt_prog_compiler_static='`$ECHO "$lt_prog_compiler_static" | $SED "$delay_single_quote_subst"`'
-lt_cv_prog_compiler_c_o='`$ECHO "$lt_cv_prog_compiler_c_o" | $SED "$delay_single_quote_subst"`'
-need_locks='`$ECHO "$need_locks" | $SED "$delay_single_quote_subst"`'
-DSYMUTIL='`$ECHO "$DSYMUTIL" | $SED "$delay_single_quote_subst"`'
-NMEDIT='`$ECHO "$NMEDIT" | $SED "$delay_single_quote_subst"`'
-LIPO='`$ECHO "$LIPO" | $SED "$delay_single_quote_subst"`'
-OTOOL='`$ECHO "$OTOOL" | $SED "$delay_single_quote_subst"`'
-OTOOL64='`$ECHO "$OTOOL64" | $SED "$delay_single_quote_subst"`'
-libext='`$ECHO "$libext" | $SED "$delay_single_quote_subst"`'
-shrext_cmds='`$ECHO "$shrext_cmds" | $SED "$delay_single_quote_subst"`'
-extract_expsyms_cmds='`$ECHO "$extract_expsyms_cmds" | $SED "$delay_single_quote_subst"`'
-archive_cmds_need_lc='`$ECHO "$archive_cmds_need_lc" | $SED "$delay_single_quote_subst"`'
-enable_shared_with_static_runtimes='`$ECHO "$enable_shared_with_static_runtimes" | $SED "$delay_single_quote_subst"`'
-export_dynamic_flag_spec='`$ECHO "$export_dynamic_flag_spec" | $SED "$delay_single_quote_subst"`'
-whole_archive_flag_spec='`$ECHO "$whole_archive_flag_spec" | $SED "$delay_single_quote_subst"`'
-compiler_needs_object='`$ECHO "$compiler_needs_object" | $SED "$delay_single_quote_subst"`'
-old_archive_from_new_cmds='`$ECHO "$old_archive_from_new_cmds" | $SED "$delay_single_quote_subst"`'
-old_archive_from_expsyms_cmds='`$ECHO "$old_archive_from_expsyms_cmds" | $SED "$delay_single_quote_subst"`'
-archive_cmds='`$ECHO "$archive_cmds" | $SED "$delay_single_quote_subst"`'
-archive_expsym_cmds='`$ECHO "$archive_expsym_cmds" | $SED "$delay_single_quote_subst"`'
-module_cmds='`$ECHO "$module_cmds" | $SED "$delay_single_quote_subst"`'
-module_expsym_cmds='`$ECHO "$module_expsym_cmds" | $SED "$delay_single_quote_subst"`'
-with_gnu_ld='`$ECHO "$with_gnu_ld" | $SED "$delay_single_quote_subst"`'
-allow_undefined_flag='`$ECHO "$allow_undefined_flag" | $SED "$delay_single_quote_subst"`'
-no_undefined_flag='`$ECHO "$no_undefined_flag" | $SED "$delay_single_quote_subst"`'
-hardcode_libdir_flag_spec='`$ECHO "$hardcode_libdir_flag_spec" | $SED "$delay_single_quote_subst"`'
-hardcode_libdir_flag_spec_ld='`$ECHO "$hardcode_libdir_flag_spec_ld" | $SED "$delay_single_quote_subst"`'
-hardcode_libdir_separator='`$ECHO "$hardcode_libdir_separator" | $SED "$delay_single_quote_subst"`'
-hardcode_direct='`$ECHO "$hardcode_direct" | $SED "$delay_single_quote_subst"`'
-hardcode_direct_absolute='`$ECHO "$hardcode_direct_absolute" | $SED "$delay_single_quote_subst"`'
-hardcode_minus_L='`$ECHO "$hardcode_minus_L" | $SED "$delay_single_quote_subst"`'
-hardcode_shlibpath_var='`$ECHO "$hardcode_shlibpath_var" | $SED "$delay_single_quote_subst"`'
-hardcode_automatic='`$ECHO "$hardcode_automatic" | $SED "$delay_single_quote_subst"`'
-inherit_rpath='`$ECHO "$inherit_rpath" | $SED "$delay_single_quote_subst"`'
-link_all_deplibs='`$ECHO "$link_all_deplibs" | $SED "$delay_single_quote_subst"`'
-fix_srcfile_path='`$ECHO "$fix_srcfile_path" | $SED "$delay_single_quote_subst"`'
-always_export_symbols='`$ECHO "$always_export_symbols" | $SED "$delay_single_quote_subst"`'
-export_symbols_cmds='`$ECHO "$export_symbols_cmds" | $SED "$delay_single_quote_subst"`'
-exclude_expsyms='`$ECHO "$exclude_expsyms" | $SED "$delay_single_quote_subst"`'
-include_expsyms='`$ECHO "$include_expsyms" | $SED "$delay_single_quote_subst"`'
-prelink_cmds='`$ECHO "$prelink_cmds" | $SED "$delay_single_quote_subst"`'
-file_list_spec='`$ECHO "$file_list_spec" | $SED "$delay_single_quote_subst"`'
-variables_saved_for_relink='`$ECHO "$variables_saved_for_relink" | $SED "$delay_single_quote_subst"`'
-need_lib_prefix='`$ECHO "$need_lib_prefix" | $SED "$delay_single_quote_subst"`'
-need_version='`$ECHO "$need_version" | $SED "$delay_single_quote_subst"`'
-version_type='`$ECHO "$version_type" | $SED "$delay_single_quote_subst"`'
-runpath_var='`$ECHO "$runpath_var" | $SED "$delay_single_quote_subst"`'
-shlibpath_var='`$ECHO "$shlibpath_var" | $SED "$delay_single_quote_subst"`'
-shlibpath_overrides_runpath='`$ECHO "$shlibpath_overrides_runpath" | $SED "$delay_single_quote_subst"`'
-libname_spec='`$ECHO "$libname_spec" | $SED "$delay_single_quote_subst"`'
-library_names_spec='`$ECHO "$library_names_spec" | $SED "$delay_single_quote_subst"`'
-soname_spec='`$ECHO "$soname_spec" | $SED "$delay_single_quote_subst"`'
-install_override_mode='`$ECHO "$install_override_mode" | $SED "$delay_single_quote_subst"`'
-postinstall_cmds='`$ECHO "$postinstall_cmds" | $SED "$delay_single_quote_subst"`'
-postuninstall_cmds='`$ECHO "$postuninstall_cmds" | $SED "$delay_single_quote_subst"`'
-finish_cmds='`$ECHO "$finish_cmds" | $SED "$delay_single_quote_subst"`'
-finish_eval='`$ECHO "$finish_eval" | $SED "$delay_single_quote_subst"`'
-hardcode_into_libs='`$ECHO "$hardcode_into_libs" | $SED "$delay_single_quote_subst"`'
-sys_lib_search_path_spec='`$ECHO "$sys_lib_search_path_spec" | $SED "$delay_single_quote_subst"`'
-sys_lib_dlsearch_path_spec='`$ECHO "$sys_lib_dlsearch_path_spec" | $SED "$delay_single_quote_subst"`'
-hardcode_action='`$ECHO "$hardcode_action" | $SED "$delay_single_quote_subst"`'
-enable_dlopen='`$ECHO "$enable_dlopen" | $SED "$delay_single_quote_subst"`'
-enable_dlopen_self='`$ECHO "$enable_dlopen_self" | $SED "$delay_single_quote_subst"`'
-enable_dlopen_self_static='`$ECHO "$enable_dlopen_self_static" | $SED "$delay_single_quote_subst"`'
-old_striplib='`$ECHO "$old_striplib" | $SED "$delay_single_quote_subst"`'
-striplib='`$ECHO "$striplib" | $SED "$delay_single_quote_subst"`'
-
-LTCC='$LTCC'
-LTCFLAGS='$LTCFLAGS'
-compiler='$compiler_DEFAULT'
-
-# A function that is used when there is no print builtin or printf.
-func_fallback_echo ()
-{
-  eval 'cat <<_LTECHO_EOF
-\$1
-_LTECHO_EOF'
-}
-
-# Quote evaled strings.
-for var in SHELL \
-ECHO \
-SED \
-GREP \
-EGREP \
-FGREP \
-LD \
-NM \
-LN_S \
-lt_SP2NL \
-lt_NL2SP \
-reload_flag \
-OBJDUMP \
-deplibs_check_method \
-file_magic_cmd \
-AR \
-AR_FLAGS \
-STRIP \
-RANLIB \
-CC \
-CFLAGS \
-compiler \
-lt_cv_sys_global_symbol_pipe \
-lt_cv_sys_global_symbol_to_cdecl \
-lt_cv_sys_global_symbol_to_c_name_address \
-lt_cv_sys_global_symbol_to_c_name_address_lib_prefix \
-lt_prog_compiler_no_builtin_flag \
-lt_prog_compiler_wl \
-lt_prog_compiler_pic \
-lt_prog_compiler_static \
-lt_cv_prog_compiler_c_o \
-need_locks \
-DSYMUTIL \
-NMEDIT \
-LIPO \
-OTOOL \
-OTOOL64 \
-shrext_cmds \
-export_dynamic_flag_spec \
-whole_archive_flag_spec \
-compiler_needs_object \
-with_gnu_ld \
-allow_undefined_flag \
-no_undefined_flag \
-hardcode_libdir_flag_spec \
-hardcode_libdir_flag_spec_ld \
-hardcode_libdir_separator \
-fix_srcfile_path \
-exclude_expsyms \
-include_expsyms \
-file_list_spec \
-variables_saved_for_relink \
-libname_spec \
-library_names_spec \
-soname_spec \
-install_override_mode \
-finish_eval \
-old_striplib \
-striplib; do
-    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
-    *[\\\\\\\`\\"\\\$]*)
-      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED \\"\\\$sed_quote_subst\\"\\\`\\\\\\""
-      ;;
-    *)
-      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
-      ;;
-    esac
-done
-
-# Double-quote double-evaled strings.
-for var in reload_cmds \
-old_postinstall_cmds \
-old_postuninstall_cmds \
-old_archive_cmds \
-extract_expsyms_cmds \
-old_archive_from_new_cmds \
-old_archive_from_expsyms_cmds \
-archive_cmds \
-archive_expsym_cmds \
-module_cmds \
-module_expsym_cmds \
-export_symbols_cmds \
-prelink_cmds \
-postinstall_cmds \
-postuninstall_cmds \
-finish_cmds \
-sys_lib_search_path_spec \
-sys_lib_dlsearch_path_spec; do
-    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
-    *[\\\\\\\`\\"\\\$]*)
-      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\""
-      ;;
-    *)
-      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
-      ;;
-    esac
-done
-
-ac_aux_dir='$ac_aux_dir'
-xsi_shell='$xsi_shell'
-lt_shell_append='$lt_shell_append'
-
-# See if we are running on zsh, and set the options which allow our
-# commands through without removal of \ escapes INIT.
-if test -n "\${ZSH_VERSION+set}" ; then
-   setopt NO_GLOB_SUBST
-fi
-
-
-    PACKAGE='$PACKAGE'
-    VERSION='$VERSION'
-    TIMESTAMP='$TIMESTAMP'
-    RM='$RM'
-    ofile='$ofile'
-
-
-
-
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-
-# Handling of arguments.
-for ac_config_target in $ac_config_targets
-do
-  case $ac_config_target in
-    "default-1") CONFIG_COMMANDS="$CONFIG_COMMANDS default-1" ;;
-    "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
-    "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
-    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
-
-  *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
-  esac
-done
-
-
-# If the user did not use the arguments to specify the items to instantiate,
-# then the envvar interface is used.  Set only those that are not.
-# We use the long form for the default assignment because of an extremely
-# bizarre bug on SunOS 4.1.3.
-if $ac_need_defaults; then
-  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
-  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
-fi
-
-# Have a temporary directory for convenience.  Make it in the build tree
-# simply because there is no reason against having it here, and in addition,
-# creating and moving files from /tmp can sometimes cause problems.
-# Hook for its removal unless debugging.
-# Note that there is a small window in which the directory will not be cleaned:
-# after its creation but before its name has been assigned to `$tmp'.
-$debug ||
-{
-  tmp=
-  trap 'exit_status=$?
-  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
-' 0
-  trap 'as_fn_exit 1' 1 2 13 15
-}
-# Create a (secure) tmp directory for tmp files.
-
-{
-  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
-  test -n "$tmp" && test -d "$tmp"
-}  ||
-{
-  tmp=./conf$$-$RANDOM
-  (umask 077 && mkdir "$tmp")
-} || as_fn_error "cannot create a temporary directory in ." "$LINENO" 5
-
-# Set up the scripts for CONFIG_FILES section.
-# No need to generate them if there are no CONFIG_FILES.
-# This happens for instance with `./config.status config.h'.
-if test -n "$CONFIG_FILES"; then
-
-
-ac_cr=`echo X | tr X '\015'`
-# On cygwin, bash can eat \r inside `` if the user requested igncr.
-# But we know of no other shell where ac_cr would be empty at this
-# point, so we can use a bashism as a fallback.
-if test "x$ac_cr" = x; then
-  eval ac_cr=\$\'\\r\'
-fi
-ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
-if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
-  ac_cs_awk_cr='\r'
-else
-  ac_cs_awk_cr=$ac_cr
-fi
-
-echo 'BEGIN {' >"$tmp/subs1.awk" &&
-_ACEOF
-
-
-{
-  echo "cat >conf$$subs.awk <<_ACEOF" &&
-  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
-  echo "_ACEOF"
-} >conf$$subs.sh ||
-  as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
-ac_delim_num=`echo "$ac_subst_vars" | grep -c '$'`
-ac_delim='%!_!# '
-for ac_last_try in false false false false false :; do
-  . ./conf$$subs.sh ||
-    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
-
-  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
-  if test $ac_delim_n = $ac_delim_num; then
-    break
-  elif $ac_last_try; then
-    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
-  else
-    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
-  fi
-done
-rm -f conf$$subs.sh
-
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-cat >>"\$tmp/subs1.awk" <<\\_ACAWK &&
-_ACEOF
-sed -n '
-h
-s/^/S["/; s/!.*/"]=/
-p
-g
-s/^[^!]*!//
-:repl
-t repl
-s/'"$ac_delim"'$//
-t delim
-:nl
-h
-s/\(.\{148\}\).*/\1/
-t more1
-s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
-p
-n
-b repl
-:more1
-s/["\\]/\\&/g; s/^/"/; s/$/"\\/
-p
-g
-s/.\{148\}//
-t nl
-:delim
-h
-s/\(.\{148\}\).*/\1/
-t more2
-s/["\\]/\\&/g; s/^/"/; s/$/"/
-p
-b
-:more2
-s/["\\]/\\&/g; s/^/"/; s/$/"\\/
-p
-g
-s/.\{148\}//
-t delim
-' <conf$$subs.awk | sed '
-/^[^""]/{
-  N
-  s/\n//
-}
-' >>$CONFIG_STATUS || ac_write_fail=1
-rm -f conf$$subs.awk
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-_ACAWK
-cat >>"\$tmp/subs1.awk" <<_ACAWK &&
-  for (key in S) S_is_set[key] = 1
-  FS = ""
-
-}
-{
-  line = $ 0
-  nfields = split(line, field, "@")
-  substed = 0
-  len = length(field[1])
-  for (i = 2; i < nfields; i++) {
-    key = field[i]
-    keylen = length(key)
-    if (S_is_set[key]) {
-      value = S[key]
-      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
-      len += length(value) + length(field[++i])
-      substed = 1
-    } else
-      len += 1 + keylen
-  }
-
-  print line
-}
-
-_ACAWK
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
-  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
-else
-  cat
-fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
-  || as_fn_error "could not setup config files machinery" "$LINENO" 5
-_ACEOF
-
-# VPATH may cause trouble with some makes, so we remove $(srcdir),
-# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
-# trailing colons and then remove the whole line if VPATH becomes empty
-# (actually we leave an empty line to preserve line numbers).
-if test "x$srcdir" = x.; then
-  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
-s/:*\$(srcdir):*/:/
-s/:*\${srcdir}:*/:/
-s/:*@srcdir@:*/:/
-s/^\([^=]*=[	 ]*\):*/\1/
-s/:*$//
-s/^[^=]*=[	 ]*$//
-}'
-fi
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-fi # test -n "$CONFIG_FILES"
-
-
-eval set X "  :F $CONFIG_FILES      :C $CONFIG_COMMANDS"
-shift
-for ac_tag
-do
-  case $ac_tag in
-  :[FHLC]) ac_mode=$ac_tag; continue;;
-  esac
-  case $ac_mode$ac_tag in
-  :[FHL]*:*);;
-  :L* | :C*:*) as_fn_error "invalid tag \`$ac_tag'" "$LINENO" 5;;
-  :[FH]-) ac_tag=-:-;;
-  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
-  esac
-  ac_save_IFS=$IFS
-  IFS=:
-  set x $ac_tag
-  IFS=$ac_save_IFS
-  shift
-  ac_file=$1
-  shift
-
-  case $ac_mode in
-  :L) ac_source=$1;;
-  :[FH])
-    ac_file_inputs=
-    for ac_f
-    do
-      case $ac_f in
-      -) ac_f="$tmp/stdin";;
-      *) # Look for the file first in the build tree, then in the source tree
-	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
-	 # because $ac_f cannot contain `:'.
-	 test -f "$ac_f" ||
-	   case $ac_f in
-	   [\\/$]*) false;;
-	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
-	   esac ||
-	   as_fn_error "cannot find input file: \`$ac_f'" "$LINENO" 5;;
-      esac
-      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
-      as_fn_append ac_file_inputs " '$ac_f'"
-    done
-
-    # Let's still pretend it is `configure' which instantiates (i.e., don't
-    # use $as_me), people would be surprised to read:
-    #    /* config.h.  Generated by config.status.  */
-    configure_input='Generated from '`
-	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
-	`' by configure.'
-    if test x"$ac_file" != x-; then
-      configure_input="$ac_file.  $configure_input"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
-$as_echo "$as_me: creating $ac_file" >&6;}
-    fi
-    # Neutralize special characters interpreted by sed in replacement strings.
-    case $configure_input in #(
-    *\&* | *\|* | *\\* )
-       ac_sed_conf_input=`$as_echo "$configure_input" |
-       sed 's/[\\\\&|]/\\\\&/g'`;; #(
-    *) ac_sed_conf_input=$configure_input;;
-    esac
-
-    case $ac_tag in
-    *:-:* | *:-) cat >"$tmp/stdin" \
-      || as_fn_error "could not create $ac_file" "$LINENO" 5 ;;
-    esac
-    ;;
-  esac
-
-  ac_dir=`$as_dirname -- "$ac_file" ||
-$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$ac_file" : 'X\(//\)[^/]' \| \
-	 X"$ac_file" : 'X\(//\)$' \| \
-	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$ac_file" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-  as_dir="$ac_dir"; as_fn_mkdir_p
-  ac_builddir=.
-
-case "$ac_dir" in
-.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
-*)
-  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
-  # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
-  case $ac_top_builddir_sub in
-  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
-  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
-  esac ;;
-esac
-ac_abs_top_builddir=$ac_pwd
-ac_abs_builddir=$ac_pwd$ac_dir_suffix
-# for backward compatibility:
-ac_top_builddir=$ac_top_build_prefix
-
-case $srcdir in
-  .)  # We are building in place.
-    ac_srcdir=.
-    ac_top_srcdir=$ac_top_builddir_sub
-    ac_abs_top_srcdir=$ac_pwd ;;
-  [\\/]* | ?:[\\/]* )  # Absolute name.
-    ac_srcdir=$srcdir$ac_dir_suffix;
-    ac_top_srcdir=$srcdir
-    ac_abs_top_srcdir=$srcdir ;;
-  *) # Relative name.
-    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
-    ac_top_srcdir=$ac_top_build_prefix$srcdir
-    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
-esac
-ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
-
-
-  case $ac_mode in
-  :F)
-  #
-  # CONFIG_FILE
-  #
-
-  case $INSTALL in
-  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
-  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
-  esac
-  ac_MKDIR_P=$MKDIR_P
-  case $MKDIR_P in
-  [\\/$]* | ?:[\\/]* ) ;;
-  */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
-  esac
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-# If the template does not know about datarootdir, expand it.
-# FIXME: This hack should be removed a few years after 2.60.
-ac_datarootdir_hack=; ac_datarootdir_seen=
-ac_sed_dataroot='
-/datarootdir/ {
-  p
-  q
-}
-/@datadir@/p
-/@docdir@/p
-/@infodir@/p
-/@localedir@/p
-/@mandir@/p'
-case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
-*datarootdir*) ac_datarootdir_seen=yes;;
-*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
-$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-  ac_datarootdir_hack='
-  s&@datadir@&$datadir&g
-  s&@docdir@&$docdir&g
-  s&@infodir@&$infodir&g
-  s&@localedir@&$localedir&g
-  s&@mandir@&$mandir&g
-  s&\\\${datarootdir}&$datarootdir&g' ;;
-esac
-_ACEOF
-
-# Neutralize VPATH when `$srcdir' = `.'.
-# Shell code in configure.ac might set extrasub.
-# FIXME: do we really want to maintain this feature?
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-ac_sed_extra="$ac_vpsub
-$extrasub
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-:t
-/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
-s|@configure_input@|$ac_sed_conf_input|;t t
-s&@top_builddir@&$ac_top_builddir_sub&;t t
-s&@top_build_prefix@&$ac_top_build_prefix&;t t
-s&@srcdir@&$ac_srcdir&;t t
-s&@abs_srcdir@&$ac_abs_srcdir&;t t
-s&@top_srcdir@&$ac_top_srcdir&;t t
-s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
-s&@builddir@&$ac_builddir&;t t
-s&@abs_builddir@&$ac_abs_builddir&;t t
-s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
-s&@INSTALL@&$ac_INSTALL&;t t
-s&@MKDIR_P@&$ac_MKDIR_P&;t t
-$ac_datarootdir_hack
-"
-eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
-  || as_fn_error "could not create $ac_file" "$LINENO" 5
-
-test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
-  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
-  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&5
-$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&2;}
-
-  rm -f "$tmp/stdin"
-  case $ac_file in
-  -) cat "$tmp/out" && rm -f "$tmp/out";;
-  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
-  esac \
-  || as_fn_error "could not create $ac_file" "$LINENO" 5
- ;;
-
-
-  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
-$as_echo "$as_me: executing $ac_file commands" >&6;}
- ;;
-  esac
-
-
-  case $ac_file$ac_mode in
-    "default-1":C)
-# Only add multilib support code if we just rebuilt the top-level
-# Makefile.
-case " $CONFIG_FILES " in
- *" Makefile "*)
-   ac_file=Makefile . ${multi_basedir}/config-ml.in
-   ;;
-esac ;;
-    "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
-  # Autoconf 2.62 quotes --file arguments for eval, but not when files
-  # are listed without --file.  Let's play safe and only enable the eval
-  # if we detect the quoting.
-  case $CONFIG_FILES in
-  *\'*) eval set x "$CONFIG_FILES" ;;
-  *)   set x $CONFIG_FILES ;;
-  esac
-  shift
-  for mf
-  do
-    # Strip MF so we end up with the name of the file.
-    mf=`echo "$mf" | sed -e 's/:.*$//'`
-    # Check whether this is an Automake generated Makefile or not.
-    # We used to match only the files named `Makefile.in', but
-    # some people rename them; so instead we look at the file content.
-    # Grep'ing the first line is not enough: some people post-process
-    # each Makefile.in and add a new line on top of each file to say so.
-    # Grep'ing the whole file is not good either: AIX grep has a line
-    # limit of 2048, but all sed's we know have understand at least 4000.
-    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
-      dirpart=`$as_dirname -- "$mf" ||
-$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$mf" : 'X\(//\)[^/]' \| \
-	 X"$mf" : 'X\(//\)$' \| \
-	 X"$mf" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$mf" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-    else
-      continue
-    fi
-    # Extract the definition of DEPDIR, am__include, and am__quote
-    # from the Makefile without running `make'.
-    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
-    test -z "$DEPDIR" && continue
-    am__include=`sed -n 's/^am__include = //p' < "$mf"`
-    test -z "am__include" && continue
-    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
-    # When using ansi2knr, U may be empty or an underscore; expand it
-    U=`sed -n 's/^U = //p' < "$mf"`
-    # Find all dependency output files, they are included files with
-    # $(DEPDIR) in their names.  We invoke sed twice because it is the
-    # simplest approach to changing $(DEPDIR) to its actual value in the
-    # expansion.
-    for file in `sed -n "
-      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
-	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
-      # Make sure the directory exists.
-      test -f "$dirpart/$file" && continue
-      fdir=`$as_dirname -- "$file" ||
-$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$file" : 'X\(//\)[^/]' \| \
-	 X"$file" : 'X\(//\)$' \| \
-	 X"$file" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$file" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      as_dir=$dirpart/$fdir; as_fn_mkdir_p
-      # echo "creating $dirpart/$file"
-      echo '# dummy' > "$dirpart/$file"
-    done
-  done
-}
- ;;
-    "libtool":C)
-
-    # See if we are running on zsh, and set the options which allow our
-    # commands through without removal of \ escapes.
-    if test -n "${ZSH_VERSION+set}" ; then
-      setopt NO_GLOB_SUBST
-    fi
-
-    cfgfile="${ofile}T"
-    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
-    $RM "$cfgfile"
-
-    cat <<_LT_EOF >> "$cfgfile"
-#! $SHELL
-
-# `$ECHO "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
-# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION
-# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
-# NOTE: Changes made to this file will be lost: look at ltmain.sh.
-#
-#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
-#                 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
-#   Written by Gordon Matzigkeit, 1996
-#
-#   This file is part of GNU Libtool.
-#
-# GNU Libtool is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# As a special exception to the GNU General Public License,
-# if you distribute this file as part of a program or library that
-# is built using GNU Libtool, you may include this file under the
-# same distribution terms that you use for the rest of that program.
-#
-# GNU Libtool is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with GNU Libtool; see the file COPYING.  If not, a copy
-# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
-# obtained by writing to the Free Software Foundation, Inc.,
-# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-
-
-# The names of the tagged configurations supported by this script.
-available_tags=""
-
-# ### BEGIN LIBTOOL CONFIG
-
-# Which release of libtool.m4 was used?
-macro_version=$macro_version
-macro_revision=$macro_revision
-
-# Whether or not to build shared libraries.
-build_libtool_libs=$enable_shared
-
-# Whether or not to build static libraries.
-build_old_libs=$enable_static
-
-# What type of objects to build.
-pic_mode=$pic_mode
-
-# Whether or not to optimize for fast installation.
-fast_install=$enable_fast_install
-
-# Shell to use when invoking shell scripts.
-SHELL=$lt_SHELL
-
-# An echo program that protects backslashes.
-ECHO=$lt_ECHO
-
-# The host system.
-host_alias=$host_alias
-host=$host
-host_os=$host_os
-
-# The build system.
-build_alias=$build_alias
-build=$build
-build_os=$build_os
-
-# A sed program that does not truncate output.
-SED=$lt_SED
-
-# Sed that helps us avoid accidentally triggering echo(1) options like -n.
-Xsed="\$SED -e 1s/^X//"
-
-# A grep program that handles long lines.
-GREP=$lt_GREP
-
-# An ERE matcher.
-EGREP=$lt_EGREP
-
-# A literal string matcher.
-FGREP=$lt_FGREP
-
-# A BSD- or MS-compatible name lister.
-NM=$lt_NM
-
-# Whether we need soft or hard links.
-LN_S=$lt_LN_S
-
-# What is the maximum length of a command?
-max_cmd_len=$max_cmd_len
-
-# Object file suffix (normally "o").
-objext=$ac_objext
-
-# Executable file suffix (normally "").
-exeext=$exeext
-
-# whether the shell understands "unset".
-lt_unset=$lt_unset
-
-# turn spaces into newlines.
-SP2NL=$lt_lt_SP2NL
-
-# turn newlines into spaces.
-NL2SP=$lt_lt_NL2SP
-
-# An object symbol dumper.
-OBJDUMP=$lt_OBJDUMP
-
-# Method to check whether dependent libraries are shared objects.
-deplibs_check_method=$lt_deplibs_check_method
-
-# Command to use when deplibs_check_method == "file_magic".
-file_magic_cmd=$lt_file_magic_cmd
-
-# The archiver.
-AR=$lt_AR
-AR_FLAGS=$lt_AR_FLAGS
-
-# A symbol stripping program.
-STRIP=$lt_STRIP
-
-# Commands used to install an old-style archive.
-RANLIB=$lt_RANLIB
-old_postinstall_cmds=$lt_old_postinstall_cmds
-old_postuninstall_cmds=$lt_old_postuninstall_cmds
-
-# Whether to use a lock for old archive extraction.
-lock_old_archive_extraction=$lock_old_archive_extraction
-
-# A C compiler.
-LTCC=$lt_CC
-
-# LTCC compiler flags.
-LTCFLAGS=$lt_CFLAGS
-
-# Take the output of nm and produce a listing of raw symbols and C names.
-global_symbol_pipe=$lt_lt_cv_sys_global_symbol_pipe
-
-# Transform the output of nm in a proper C declaration.
-global_symbol_to_cdecl=$lt_lt_cv_sys_global_symbol_to_cdecl
-
-# Transform the output of nm in a C name address pair.
-global_symbol_to_c_name_address=$lt_lt_cv_sys_global_symbol_to_c_name_address
-
-# Transform the output of nm in a C name address pair when lib prefix is needed.
-global_symbol_to_c_name_address_lib_prefix=$lt_lt_cv_sys_global_symbol_to_c_name_address_lib_prefix
-
-# The name of the directory that contains temporary libtool files.
-objdir=$objdir
-
-# Used to examine libraries when file_magic_cmd begins with "file".
-MAGIC_CMD=$MAGIC_CMD
-
-# Must we lock files when doing compilation?
-need_locks=$lt_need_locks
-
-# Tool to manipulate archived DWARF debug symbol files on Mac OS X.
-DSYMUTIL=$lt_DSYMUTIL
-
-# Tool to change global to local symbols on Mac OS X.
-NMEDIT=$lt_NMEDIT
-
-# Tool to manipulate fat objects and archives on Mac OS X.
-LIPO=$lt_LIPO
-
-# ldd/readelf like tool for Mach-O binaries on Mac OS X.
-OTOOL=$lt_OTOOL
-
-# ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4.
-OTOOL64=$lt_OTOOL64
-
-# Old archive suffix (normally "a").
-libext=$libext
-
-# Shared library suffix (normally ".so").
-shrext_cmds=$lt_shrext_cmds
-
-# The commands to extract the exported symbol list from a shared archive.
-extract_expsyms_cmds=$lt_extract_expsyms_cmds
-
-# Variables whose values should be saved in libtool wrapper scripts and
-# restored at link time.
-variables_saved_for_relink=$lt_variables_saved_for_relink
-
-# Do we need the "lib" prefix for modules?
-need_lib_prefix=$need_lib_prefix
-
-# Do we need a version for libraries?
-need_version=$need_version
-
-# Library versioning type.
-version_type=$version_type
-
-# Shared library runtime path variable.
-runpath_var=$runpath_var
-
-# Shared library path variable.
-shlibpath_var=$shlibpath_var
-
-# Is shlibpath searched before the hard-coded library search path?
-shlibpath_overrides_runpath=$shlibpath_overrides_runpath
-
-# Format of library name prefix.
-libname_spec=$lt_libname_spec
-
-# List of archive names.  First name is the real one, the rest are links.
-# The last name is the one that the linker finds with -lNAME
-library_names_spec=$lt_library_names_spec
-
-# The coded name of the library, if different from the real name.
-soname_spec=$lt_soname_spec
-
-# Permission mode override for installation of shared libraries.
-install_override_mode=$lt_install_override_mode
-
-# Command to use after installation of a shared archive.
-postinstall_cmds=$lt_postinstall_cmds
-
-# Command to use after uninstallation of a shared archive.
-postuninstall_cmds=$lt_postuninstall_cmds
-
-# Commands used to finish a libtool library installation in a directory.
-finish_cmds=$lt_finish_cmds
-
-# As "finish_cmds", except a single script fragment to be evaled but
-# not shown.
-finish_eval=$lt_finish_eval
-
-# Whether we should hardcode library paths into libraries.
-hardcode_into_libs=$hardcode_into_libs
-
-# Compile-time system search path for libraries.
-sys_lib_search_path_spec=$lt_sys_lib_search_path_spec
-
-# Run-time system search path for libraries.
-sys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec
-
-# Whether dlopen is supported.
-dlopen_support=$enable_dlopen
-
-# Whether dlopen of programs is supported.
-dlopen_self=$enable_dlopen_self
-
-# Whether dlopen of statically linked programs is supported.
-dlopen_self_static=$enable_dlopen_self_static
-
-# Commands to strip libraries.
-old_striplib=$lt_old_striplib
-striplib=$lt_striplib
-
-
-# The linker used to build libraries.
-LD=$lt_LD
-
-# How to create reloadable object files.
-reload_flag=$lt_reload_flag
-reload_cmds=$lt_reload_cmds
-
-# Commands used to build an old-style archive.
-old_archive_cmds=$lt_old_archive_cmds
-
-# A language specific compiler.
-CC=$lt_compiler
-
-# Is the compiler the GNU compiler?
-with_gcc=$GCC
-
-# Compiler flag to turn off builtin functions.
-no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag
-
-# How to pass a linker flag through the compiler.
-wl=$lt_lt_prog_compiler_wl
-
-# Additional compiler flags for building library objects.
-pic_flag=$lt_lt_prog_compiler_pic
-
-# Compiler flag to prevent dynamic linking.
-link_static_flag=$lt_lt_prog_compiler_static
-
-# Does compiler simultaneously support -c and -o options?
-compiler_c_o=$lt_lt_cv_prog_compiler_c_o
-
-# Whether or not to add -lc for building shared libraries.
-build_libtool_need_lc=$archive_cmds_need_lc
-
-# Whether or not to disallow shared libs when runtime libs are static.
-allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes
-
-# Compiler flag to allow reflexive dlopens.
-export_dynamic_flag_spec=$lt_export_dynamic_flag_spec
-
-# Compiler flag to generate shared objects directly from archives.
-whole_archive_flag_spec=$lt_whole_archive_flag_spec
-
-# Whether the compiler copes with passing no objects directly.
-compiler_needs_object=$lt_compiler_needs_object
-
-# Create an old-style archive from a shared archive.
-old_archive_from_new_cmds=$lt_old_archive_from_new_cmds
-
-# Create a temporary old-style archive to link instead of a shared archive.
-old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds
-
-# Commands used to build a shared archive.
-archive_cmds=$lt_archive_cmds
-archive_expsym_cmds=$lt_archive_expsym_cmds
-
-# Commands used to build a loadable module if different from building
-# a shared archive.
-module_cmds=$lt_module_cmds
-module_expsym_cmds=$lt_module_expsym_cmds
-
-# Whether we are building with GNU ld or not.
-with_gnu_ld=$lt_with_gnu_ld
-
-# Flag that allows shared libraries with undefined symbols to be built.
-allow_undefined_flag=$lt_allow_undefined_flag
-
-# Flag that enforces no undefined symbols.
-no_undefined_flag=$lt_no_undefined_flag
-
-# Flag to hardcode \$libdir into a binary during linking.
-# This must work even if \$libdir does not exist
-hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec
-
-# If ld is used when linking, flag to hardcode \$libdir into a binary
-# during linking.  This must work even if \$libdir does not exist.
-hardcode_libdir_flag_spec_ld=$lt_hardcode_libdir_flag_spec_ld
-
-# Whether we need a single "-rpath" flag with a separated argument.
-hardcode_libdir_separator=$lt_hardcode_libdir_separator
-
-# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
-# DIR into the resulting binary.
-hardcode_direct=$hardcode_direct
-
-# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
-# DIR into the resulting binary and the resulting library dependency is
-# "absolute",i.e impossible to change by setting \${shlibpath_var} if the
-# library is relocated.
-hardcode_direct_absolute=$hardcode_direct_absolute
-
-# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
-# into the resulting binary.
-hardcode_minus_L=$hardcode_minus_L
-
-# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
-# into the resulting binary.
-hardcode_shlibpath_var=$hardcode_shlibpath_var
-
-# Set to "yes" if building a shared library automatically hardcodes DIR
-# into the library and all subsequent libraries and executables linked
-# against it.
-hardcode_automatic=$hardcode_automatic
-
-# Set to yes if linker adds runtime paths of dependent libraries
-# to runtime path list.
-inherit_rpath=$inherit_rpath
-
-# Whether libtool must link a program against all its dependency libraries.
-link_all_deplibs=$link_all_deplibs
-
-# Fix the shell variable \$srcfile for the compiler.
-fix_srcfile_path=$lt_fix_srcfile_path
-
-# Set to "yes" if exported symbols are required.
-always_export_symbols=$always_export_symbols
-
-# The commands to list exported symbols.
-export_symbols_cmds=$lt_export_symbols_cmds
-
-# Symbols that should not be listed in the preloaded symbols.
-exclude_expsyms=$lt_exclude_expsyms
-
-# Symbols that must always be exported.
-include_expsyms=$lt_include_expsyms
-
-# Commands necessary for linking programs (against libraries) with templates.
-prelink_cmds=$lt_prelink_cmds
-
-# Specify filename containing input files.
-file_list_spec=$lt_file_list_spec
-
-# How to hardcode a shared library path into an executable.
-hardcode_action=$hardcode_action
-
-# ### END LIBTOOL CONFIG
-
-_LT_EOF
-
-  case $host_os in
-  aix3*)
-    cat <<\_LT_EOF >> "$cfgfile"
-# AIX sometimes has problems with the GCC collect2 program.  For some
-# reason, if we set the COLLECT_NAMES environment variable, the problems
-# vanish in a puff of smoke.
-if test "X${COLLECT_NAMES+set}" != Xset; then
-  COLLECT_NAMES=
-  export COLLECT_NAMES
-fi
-_LT_EOF
-    ;;
-  esac
-
-
-ltmain="$ac_aux_dir/ltmain.sh"
-
-
-  # We use sed instead of cat because bash on DJGPP gets confused if
-  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
-  # text mode, it properly converts lines to CR/LF.  This bash problem
-  # is reportedly fixed, but why not run on old versions too?
-  sed '/^# Generated shell functions inserted here/q' "$ltmain" >> "$cfgfile" \
-    || (rm -f "$cfgfile"; exit 1)
-
-  case $xsi_shell in
-  yes)
-    cat << \_LT_EOF >> "$cfgfile"
-
-# func_dirname file append nondir_replacement
-# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
-# otherwise set result to NONDIR_REPLACEMENT.
-func_dirname ()
-{
-  case ${1} in
-    */*) func_dirname_result="${1%/*}${2}" ;;
-    *  ) func_dirname_result="${3}" ;;
-  esac
-}
-
-# func_basename file
-func_basename ()
-{
-  func_basename_result="${1##*/}"
-}
-
-# func_dirname_and_basename file append nondir_replacement
-# perform func_basename and func_dirname in a single function
-# call:
-#   dirname:  Compute the dirname of FILE.  If nonempty,
-#             add APPEND to the result, otherwise set result
-#             to NONDIR_REPLACEMENT.
-#             value returned in "$func_dirname_result"
-#   basename: Compute filename of FILE.
-#             value retuned in "$func_basename_result"
-# Implementation must be kept synchronized with func_dirname
-# and func_basename. For efficiency, we do not delegate to
-# those functions but instead duplicate the functionality here.
-func_dirname_and_basename ()
-{
-  case ${1} in
-    */*) func_dirname_result="${1%/*}${2}" ;;
-    *  ) func_dirname_result="${3}" ;;
-  esac
-  func_basename_result="${1##*/}"
-}
-
-# func_stripname prefix suffix name
-# strip PREFIX and SUFFIX off of NAME.
-# PREFIX and SUFFIX must not contain globbing or regex special
-# characters, hashes, percent signs, but SUFFIX may contain a leading
-# dot (in which case that matches only a dot).
-func_stripname ()
-{
-  # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are
-  # positional parameters, so assign one to ordinary parameter first.
-  func_stripname_result=${3}
-  func_stripname_result=${func_stripname_result#"${1}"}
-  func_stripname_result=${func_stripname_result%"${2}"}
-}
-
-# func_opt_split
-func_opt_split ()
-{
-  func_opt_split_opt=${1%%=*}
-  func_opt_split_arg=${1#*=}
-}
-
-# func_lo2o object
-func_lo2o ()
-{
-  case ${1} in
-    *.lo) func_lo2o_result=${1%.lo}.${objext} ;;
-    *)    func_lo2o_result=${1} ;;
-  esac
-}
-
-# func_xform libobj-or-source
-func_xform ()
-{
-  func_xform_result=${1%.*}.lo
-}
-
-# func_arith arithmetic-term...
-func_arith ()
-{
-  func_arith_result=$(( $* ))
-}
-
-# func_len string
-# STRING may not start with a hyphen.
-func_len ()
-{
-  func_len_result=${#1}
-}
-
-_LT_EOF
-    ;;
-  *) # Bourne compatible functions.
-    cat << \_LT_EOF >> "$cfgfile"
-
-# func_dirname file append nondir_replacement
-# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
-# otherwise set result to NONDIR_REPLACEMENT.
-func_dirname ()
-{
-  # Extract subdirectory from the argument.
-  func_dirname_result=`$ECHO "${1}" | $SED "$dirname"`
-  if test "X$func_dirname_result" = "X${1}"; then
-    func_dirname_result="${3}"
-  else
-    func_dirname_result="$func_dirname_result${2}"
-  fi
-}
-
-# func_basename file
-func_basename ()
-{
-  func_basename_result=`$ECHO "${1}" | $SED "$basename"`
-}
-
-
-# func_stripname prefix suffix name
-# strip PREFIX and SUFFIX off of NAME.
-# PREFIX and SUFFIX must not contain globbing or regex special
-# characters, hashes, percent signs, but SUFFIX may contain a leading
-# dot (in which case that matches only a dot).
-# func_strip_suffix prefix name
-func_stripname ()
-{
-  case ${2} in
-    .*) func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%\\\\${2}\$%%"`;;
-    *)  func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%${2}\$%%"`;;
-  esac
-}
-
-# sed scripts:
-my_sed_long_opt='1s/^\(-[^=]*\)=.*/\1/;q'
-my_sed_long_arg='1s/^-[^=]*=//'
-
-# func_opt_split
-func_opt_split ()
-{
-  func_opt_split_opt=`$ECHO "${1}" | $SED "$my_sed_long_opt"`
-  func_opt_split_arg=`$ECHO "${1}" | $SED "$my_sed_long_arg"`
-}
-
-# func_lo2o object
-func_lo2o ()
-{
-  func_lo2o_result=`$ECHO "${1}" | $SED "$lo2o"`
-}
-
-# func_xform libobj-or-source
-func_xform ()
-{
-  func_xform_result=`$ECHO "${1}" | $SED 's/\.[^.]*$/.lo/'`
-}
-
-# func_arith arithmetic-term...
-func_arith ()
-{
-  func_arith_result=`expr "$@"`
-}
-
-# func_len string
-# STRING may not start with a hyphen.
-func_len ()
-{
-  func_len_result=`expr "$1" : ".*" 2>/dev/null || echo $max_cmd_len`
-}
-
-_LT_EOF
-esac
-
-case $lt_shell_append in
-  yes)
-    cat << \_LT_EOF >> "$cfgfile"
-
-# func_append var value
-# Append VALUE to the end of shell variable VAR.
-func_append ()
-{
-  eval "$1+=\$2"
-}
-_LT_EOF
-    ;;
-  *)
-    cat << \_LT_EOF >> "$cfgfile"
-
-# func_append var value
-# Append VALUE to the end of shell variable VAR.
-func_append ()
-{
-  eval "$1=\$$1\$2"
-}
-
-_LT_EOF
-    ;;
-  esac
-
-
-  sed -n '/^# Generated shell functions inserted here/,$p' "$ltmain" >> "$cfgfile" \
-    || (rm -f "$cfgfile"; exit 1)
-
-  mv -f "$cfgfile" "$ofile" ||
-    (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
-  chmod +x "$ofile"
-
- ;;
-
-  esac
-done # for ac_tag
-
-
-as_fn_exit 0
-_ACEOF
-ac_clean_files=$ac_clean_files_save
-
-test $ac_write_fail = 0 ||
-  as_fn_error "write failure creating $CONFIG_STATUS" "$LINENO" 5
-
-
-# configure is writing to config.log, and then calls config.status.
-# config.status does its own redirection, appending to config.log.
-# Unfortunately, on DOS this fails, as config.log is still kept open
-# by configure, so config.status won't be able to write to it; its
-# output is simply discarded.  So we exec the FD to /dev/null,
-# effectively closing config.log, so it can be properly (re)opened and
-# appended to by config.status.  When coming back to configure, we
-# need to make the FD available again.
-if test "$no_create" != yes; then
-  ac_cs_success=:
-  ac_config_status_args=
-  test "$silent" = yes &&
-    ac_config_status_args="$ac_config_status_args --quiet"
-  exec 5>/dev/null
-  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
-  exec 5>>config.log
-  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
-  # would make configure fail if this is the last instruction.
-  $ac_cs_success || as_fn_exit $?
-fi
-if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
-$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
-fi
-
diff -Nbaur gcc-4.6.3/zlib/configure.ac gcc-4.6.3-psp/zlib/configure.ac
--- gcc-4.6.3/zlib/configure.ac	2009-08-24 20:08:51.000000000 +0100
+++ gcc-4.6.3-psp/zlib/configure.ac	1970-01-01 01:00:00.000000000 +0100
@@ -1,123 +0,0 @@
-dnl Process this with autoconf to create configure
-
-AC_PREREQ(2.64)
-AC_INIT
-AC_CONFIG_SRCDIR([zlib.h])
-
-AM_ENABLE_MULTILIB(, ..)
-
-AC_CANONICAL_SYSTEM
-
-# This works around an automake problem.
-mkinstalldirs="`cd $ac_aux_dir && ${PWDCMD-pwd}`/mkinstalldirs"
-AC_SUBST(mkinstalldirs)
-
-AM_INIT_AUTOMAKE(zlib, 1.1.4)
-
-AM_MAINTAINER_MODE
-
-dnl We use these options to decide which functions to include.
-AC_ARG_WITH(target-subdir,
-[  --with-target-subdir=SUBDIR
-                          configuring in a subdirectory])
-
-if test -z "$with_target_subdir" || test "$with_target_subdir" = "."; then
-   COMPPATH=.
-else
-   COMPPATH=..
-fi
-AC_SUBST(COMPPATH)
-
-AC_ARG_WITH(cross-host,
-[  --with-cross-host=HOST  configuring with a cross compiler])
-
-dnl Default to --enable-multilib
-AC_ARG_ENABLE(multilib,
-[  --enable-multilib       build many library versions (default)],
-[case "${enableval}" in
-  yes) multilib=yes ;;
-  no)  multilib=no ;;
-  *)   AC_MSG_ERROR(bad value ${enableval} for multilib option) ;;
- esac], [test -z "$with_target_subdir" && multilib=no || multilib=yes])dnl
-
-AC_ARG_WITH(system-zlib,
-[  --with-system-zlib      use installed libz])
-
-# Make sure we don't test executables when making cross-tools.
-GCC_NO_EXECUTABLES
-
-# The same as in boehm-gc and libstdc++. Have to borrow it from there.
-# We must force CC to /not/ be precious variables; otherwise
-# the wrong, non-multilib-adjusted value will be used in multilibs.
-# As a side effect, we have to subst CFLAGS ourselves.
-
-m4_rename([_AC_ARG_VAR_PRECIOUS],[real_PRECIOUS])
-m4_define([_AC_ARG_VAR_PRECIOUS],[])
-AC_PROG_CC
-m4_rename_force([real_PRECIOUS],[_AC_ARG_VAR_PRECIOUS])
-
-AC_SUBST(CFLAGS)
-
-AC_PROG_LIBTOOL
-
-# Find CPP now so that any conditional tests below won't do it and
-# thereby make the resulting definitions conditional.
-AC_PROG_CPP
-
-if test -n "$with_cross_host"; then
-   # We are being configured with a cross compiler.  AC_REPLACE_FUNCS
-   # may not work correctly, because the compiler may not be able to
-   # link executables.
-
-   # We assume newlib.  This lets us hard-code the functions we know
-   # we'll have.
-   AC_DEFINE(HAVE_MEMCPY)
-   AC_DEFINE(HAVE_STRERROR)
-
-   # We ignore --with-system-zlib in this case.
-   target_all=libzgcj.la
-else
-   AC_FUNC_MMAP
-   AC_CHECK_FUNCS(memcpy strerror)
-
-   if test "$with_system_zlib" = yes; then
-      AC_CHECK_LIB(z, deflate, target_all=, target_all=libzgcj.la)
-   else
-      target_all=libzgcj.la
-   fi
-fi
-
-AC_SUBST(target_all)
-
-AC_CHECK_HEADERS(unistd.h)
-
-if test -n "$with_cross_host" &&
-   test x"$with_cross_host" != x"no"; then
-  toolexecdir='$(exec_prefix)/$(target_alias)'
-  toolexeclibdir='$(toolexecdir)/lib'
-else
-  toolexecdir='$(libdir)/gcc-lib/$(target_alias)'
-  toolexeclibdir='$(libdir)'
-fi
-if test "$GCC" = yes && $CC -print-multi-os-directory > /dev/null 2>&1; then
-  multiosdir=/`$CC -print-multi-os-directory`
-  case $multiosdir in
-    /.) multiosdir= ;; # Avoid trailing /.
-  esac
-else
-  multiosdir=
-fi
-toolexeclibdir=${toolexeclibdir}${multiosdir}
-AC_SUBST(toolexecdir)
-AC_SUBST(toolexeclibdir)
-
-AM_CONDITIONAL(TARGET_LIBRARY, test -n "$with_target_subdir")
-
-if test "${multilib}" = "yes"; then
-  multilib_arg="--enable-multilib"
-else
-  multilib_arg=
-fi
-
-AC_CONFIG_FILES([Makefile])
-AC_OUTPUT
diff -Nbaur gcc-4.6.3/zlib/contrib/ada/buffer_demo.adb gcc-4.6.3-psp/zlib/contrib/ada/buffer_demo.adb
--- gcc-4.6.3/zlib/contrib/ada/buffer_demo.adb	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/ada/buffer_demo.adb	1970-01-01 01:00:00.000000000 +0100
@@ -1,106 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2004 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
---
---  $Id: buffer_demo.adb,v 1.3 2004/09/06 06:55:35 vagul Exp $
-
---  This demo program provided by Dr Steve Sangwine <sjs@essex.ac.uk>
---
---  Demonstration of a problem with Zlib-Ada (already fixed) when a buffer
---  of exactly the correct size is used for decompressed data, and the last
---  few bytes passed in to Zlib are checksum bytes.
-
---  This program compresses a string of text, and then decompresses the
---  compressed text into a buffer of the same size as the original text.
-
-with Ada.Streams; use Ada.Streams;
-with Ada.Text_IO;
-
-with ZLib; use ZLib;
-
-procedure Buffer_Demo is
-   EOL  : Character renames ASCII.LF;
-   Text : constant String
-     := "Four score and seven years ago our fathers brought forth," & EOL &
-        "upon this continent, a new nation, conceived in liberty," & EOL &
-        "and dedicated to the proposition that `all men are created equal'.";
-
-   Source : Stream_Element_Array (1 .. Text'Length);
-   for Source'Address use Text'Address;
-
-begin
-   Ada.Text_IO.Put (Text);
-   Ada.Text_IO.New_Line;
-   Ada.Text_IO.Put_Line
-     ("Uncompressed size : " & Positive'Image (Text'Length) & " bytes");
-
-   declare
-      Compressed_Data : Stream_Element_Array (1 .. Text'Length);
-      L               : Stream_Element_Offset;
-   begin
-      Compress : declare
-         Compressor : Filter_Type;
-         I : Stream_Element_Offset;
-      begin
-         Deflate_Init (Compressor);
-
-         --  Compress the whole of T at once.
-
-         Translate (Compressor, Source, I, Compressed_Data, L, Finish);
-         pragma Assert (I = Source'Last);
-
-         Close (Compressor);
-
-         Ada.Text_IO.Put_Line
-           ("Compressed size :   "
-            & Stream_Element_Offset'Image (L) & " bytes");
-      end Compress;
-
-      --  Now we decompress the data, passing short blocks of data to Zlib
-      --  (because this demonstrates the problem - the last block passed will
-      --  contain checksum information and there will be no output, only a
-      --  check inside Zlib that the checksum is correct).
-
-      Decompress : declare
-         Decompressor : Filter_Type;
-
-         Uncompressed_Data : Stream_Element_Array (1 .. Text'Length);
-
-         Block_Size : constant := 4;
-         --  This makes sure that the last block contains
-         --  only Adler checksum data.
-
-         P : Stream_Element_Offset := Compressed_Data'First - 1;
-         O : Stream_Element_Offset;
-      begin
-         Inflate_Init (Decompressor);
-
-         loop
-            Translate
-              (Decompressor,
-               Compressed_Data
-                 (P + 1 .. Stream_Element_Offset'Min (P + Block_Size, L)),
-               P,
-               Uncompressed_Data
-                 (Total_Out (Decompressor) + 1 .. Uncompressed_Data'Last),
-               O,
-               No_Flush);
-
-               Ada.Text_IO.Put_Line
-                 ("Total in : " & Count'Image (Total_In (Decompressor)) &
-                  ", out : " & Count'Image (Total_Out (Decompressor)));
-
-               exit when P = L;
-         end loop;
-
-         Ada.Text_IO.New_Line;
-         Ada.Text_IO.Put_Line
-           ("Decompressed text matches original text : "
-             & Boolean'Image (Uncompressed_Data = Source));
-      end Decompress;
-   end;
-end Buffer_Demo;
diff -Nbaur gcc-4.6.3/zlib/contrib/ada/mtest.adb gcc-4.6.3-psp/zlib/contrib/ada/mtest.adb
--- gcc-4.6.3/zlib/contrib/ada/mtest.adb	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/ada/mtest.adb	1970-01-01 01:00:00.000000000 +0100
@@ -1,156 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
---  Continuous test for ZLib multithreading. If the test would fail
---  we should provide thread safe allocation routines for the Z_Stream.
---
---  $Id: mtest.adb,v 1.4 2004/07/23 07:49:54 vagul Exp $
-
-with ZLib;
-with Ada.Streams;
-with Ada.Numerics.Discrete_Random;
-with Ada.Text_IO;
-with Ada.Exceptions;
-with Ada.Task_Identification;
-
-procedure MTest is
-   use Ada.Streams;
-   use ZLib;
-
-   Stop : Boolean := False;
-
-   pragma Atomic (Stop);
-
-   subtype Visible_Symbols is Stream_Element range 16#20# .. 16#7E#;
-
-   package Random_Elements is
-      new Ada.Numerics.Discrete_Random (Visible_Symbols);
-
-   task type Test_Task;
-
-   task body Test_Task is
-      Buffer : Stream_Element_Array (1 .. 100_000);
-      Gen : Random_Elements.Generator;
-
-      Buffer_First  : Stream_Element_Offset;
-      Compare_First : Stream_Element_Offset;
-
-      Deflate : Filter_Type;
-      Inflate : Filter_Type;
-
-      procedure Further (Item : in Stream_Element_Array);
-
-      procedure Read_Buffer
-        (Item : out Ada.Streams.Stream_Element_Array;
-         Last : out Ada.Streams.Stream_Element_Offset);
-
-      -------------
-      -- Further --
-      -------------
-
-      procedure Further (Item : in Stream_Element_Array) is
-
-         procedure Compare (Item : in Stream_Element_Array);
-
-         -------------
-         -- Compare --
-         -------------
-
-         procedure Compare (Item : in Stream_Element_Array) is
-            Next_First : Stream_Element_Offset := Compare_First + Item'Length;
-         begin
-            if Buffer (Compare_First .. Next_First - 1) /= Item then
-               raise Program_Error;
-            end if;
-
-            Compare_First := Next_First;
-         end Compare;
-
-         procedure Compare_Write is new ZLib.Write (Write => Compare);
-      begin
-         Compare_Write (Inflate, Item, No_Flush);
-      end Further;
-
-      -----------------
-      -- Read_Buffer --
-      -----------------
-
-      procedure Read_Buffer
-        (Item : out Ada.Streams.Stream_Element_Array;
-         Last : out Ada.Streams.Stream_Element_Offset)
-      is
-         Buff_Diff   : Stream_Element_Offset := Buffer'Last - Buffer_First;
-         Next_First : Stream_Element_Offset;
-      begin
-         if Item'Length <= Buff_Diff then
-            Last := Item'Last;
-
-            Next_First := Buffer_First + Item'Length;
-
-            Item := Buffer (Buffer_First .. Next_First - 1);
-
-            Buffer_First := Next_First;
-         else
-            Last := Item'First + Buff_Diff;
-            Item (Item'First .. Last) := Buffer (Buffer_First .. Buffer'Last);
-            Buffer_First := Buffer'Last + 1;
-         end if;
-      end Read_Buffer;
-
-      procedure Translate is new Generic_Translate
-                                   (Data_In  => Read_Buffer,
-                                    Data_Out => Further);
-
-   begin
-      Random_Elements.Reset (Gen);
-
-      Buffer := (others => 20);
-
-      Main : loop
-         for J in Buffer'Range loop
-            Buffer (J) := Random_Elements.Random (Gen);
-
-            Deflate_Init (Deflate);
-            Inflate_Init (Inflate);
-
-            Buffer_First  := Buffer'First;
-            Compare_First := Buffer'First;
-
-            Translate (Deflate);
-
-            if Compare_First /= Buffer'Last + 1 then
-               raise Program_Error;
-            end if;
-
-            Ada.Text_IO.Put_Line
-              (Ada.Task_Identification.Image
-                 (Ada.Task_Identification.Current_Task)
-               & Stream_Element_Offset'Image (J)
-               & ZLib.Count'Image (Total_Out (Deflate)));
-
-            Close (Deflate);
-            Close (Inflate);
-
-            exit Main when Stop;
-         end loop;
-      end loop Main;
-   exception
-      when E : others =>
-         Ada.Text_IO.Put_Line (Ada.Exceptions.Exception_Information (E));
-         Stop := True;
-   end Test_Task;
-
-   Test : array (1 .. 4) of Test_Task;
-
-   pragma Unreferenced (Test);
-
-   Dummy : Character;
-
-begin
-   Ada.Text_IO.Get_Immediate (Dummy);
-   Stop := True;
-end MTest;
diff -Nbaur gcc-4.6.3/zlib/contrib/ada/read.adb gcc-4.6.3-psp/zlib/contrib/ada/read.adb
--- gcc-4.6.3/zlib/contrib/ada/read.adb	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/ada/read.adb	1970-01-01 01:00:00.000000000 +0100
@@ -1,156 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: read.adb,v 1.8 2004/05/31 10:53:40 vagul Exp $
-
---  Test/demo program for the generic read interface.
-
-with Ada.Numerics.Discrete_Random;
-with Ada.Streams;
-with Ada.Text_IO;
-
-with ZLib;
-
-procedure Read is
-
-   use Ada.Streams;
-
-   ------------------------------------
-   --  Test configuration parameters --
-   ------------------------------------
-
-   File_Size   : Stream_Element_Offset := 100_000;
-
-   Continuous  : constant Boolean          := False;
-   --  If this constant is True, the test would be repeated again and again,
-   --  with increment File_Size for every iteration.
-
-   Header      : constant ZLib.Header_Type := ZLib.Default;
-   --  Do not use Header other than Default in ZLib versions 1.1.4 and older.
-
-   Init_Random : constant := 8;
-   --  We are using the same random sequence, in case of we catch bug,
-   --  so we would be able to reproduce it.
-
-   -- End --
-
-   Pack_Size : Stream_Element_Offset;
-   Offset    : Stream_Element_Offset;
-
-   Filter     : ZLib.Filter_Type;
-
-   subtype Visible_Symbols
-      is Stream_Element range 16#20# .. 16#7E#;
-
-   package Random_Elements is new
-      Ada.Numerics.Discrete_Random (Visible_Symbols);
-
-   Gen : Random_Elements.Generator;
-   Period  : constant Stream_Element_Offset := 200;
-   --  Period constant variable for random generator not to be very random.
-   --  Bigger period, harder random.
-
-   Read_Buffer : Stream_Element_Array (1 .. 2048);
-   Read_First  : Stream_Element_Offset;
-   Read_Last   : Stream_Element_Offset;
-
-   procedure Reset;
-
-   procedure Read
-     (Item : out Stream_Element_Array;
-      Last : out Stream_Element_Offset);
-   --  this procedure is for generic instantiation of
-   --  ZLib.Read
-   --  reading data from the File_In.
-
-   procedure Read is new ZLib.Read
-                           (Read,
-                            Read_Buffer,
-                            Rest_First => Read_First,
-                            Rest_Last  => Read_Last);
-
-   ----------
-   -- Read --
-   ----------
-
-   procedure Read
-     (Item : out Stream_Element_Array;
-      Last : out Stream_Element_Offset) is
-   begin
-      Last := Stream_Element_Offset'Min
-               (Item'Last,
-                Item'First + File_Size - Offset);
-
-      for J in Item'First .. Last loop
-         if J < Item'First + Period then
-            Item (J) := Random_Elements.Random (Gen);
-         else
-            Item (J) := Item (J - Period);
-         end if;
-
-         Offset   := Offset + 1;
-      end loop;
-   end Read;
-
-   -----------
-   -- Reset --
-   -----------
-
-   procedure Reset is
-   begin
-      Random_Elements.Reset (Gen, Init_Random);
-      Pack_Size := 0;
-      Offset := 1;
-      Read_First := Read_Buffer'Last + 1;
-      Read_Last  := Read_Buffer'Last;
-   end Reset;
-
-begin
-   Ada.Text_IO.Put_Line ("ZLib " & ZLib.Version);
-
-   loop
-      for Level in ZLib.Compression_Level'Range loop
-
-         Ada.Text_IO.Put ("Level ="
-            & ZLib.Compression_Level'Image (Level));
-
-         --  Deflate using generic instantiation.
-
-         ZLib.Deflate_Init
-               (Filter,
-                Level,
-                Header => Header);
-
-         Reset;
-
-         Ada.Text_IO.Put
-           (Stream_Element_Offset'Image (File_Size) & " ->");
-
-         loop
-            declare
-               Buffer : Stream_Element_Array (1 .. 1024);
-               Last   : Stream_Element_Offset;
-            begin
-               Read (Filter, Buffer, Last);
-
-               Pack_Size := Pack_Size + Last - Buffer'First + 1;
-
-               exit when Last < Buffer'Last;
-            end;
-         end loop;
-
-         Ada.Text_IO.Put_Line (Stream_Element_Offset'Image (Pack_Size));
-
-         ZLib.Close (Filter);
-      end loop;
-
-      exit when not Continuous;
-
-      File_Size := File_Size + 1;
-   end loop;
-end Read;
diff -Nbaur gcc-4.6.3/zlib/contrib/ada/readme.txt gcc-4.6.3-psp/zlib/contrib/ada/readme.txt
--- gcc-4.6.3/zlib/contrib/ada/readme.txt	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/ada/readme.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,65 +0,0 @@
-                        ZLib for Ada thick binding (ZLib.Ada)
-                        Release 1.3
-
-ZLib.Ada is a thick binding interface to the popular ZLib data
-compression library, available at http://www.gzip.org/zlib/.
-It provides Ada-style access to the ZLib C library.
-
-
-        Here are the main changes since ZLib.Ada 1.2:
-
-- Attension: ZLib.Read generic routine have a initialization requirement
-  for Read_Last parameter now. It is a bit incompartible with previous version,
-  but extends functionality, we could use new parameters Allow_Read_Some and
-  Flush now.
-
-- Added Is_Open routines to ZLib and ZLib.Streams packages.
-
-- Add pragma Assert to check Stream_Element is 8 bit.
-
-- Fix extraction to buffer with exact known decompressed size. Error reported by
-  Steve Sangwine.
-
-- Fix definition of ULong (changed to unsigned_long), fix regression on 64 bits
-  computers. Patch provided by Pascal Obry.
-
-- Add Status_Error exception definition.
-
-- Add pragma Assertion that Ada.Streams.Stream_Element size is 8 bit.
-
-
-        How to build ZLib.Ada under GNAT
-
-You should have the ZLib library already build on your computer, before
-building ZLib.Ada. Make the directory of ZLib.Ada sources current and
-issue the command:
-
-  gnatmake test -largs -L<directory where libz.a is> -lz
-
-Or use the GNAT project file build for GNAT 3.15 or later:
-
-  gnatmake -Pzlib.gpr -L<directory where libz.a is>
-
-
-        How to build ZLib.Ada under Aonix ObjectAda for Win32 7.2.2
-
-1. Make a project with all *.ads and *.adb files from the distribution.
-2. Build the libz.a library from the ZLib C sources.
-3. Rename libz.a to z.lib.
-4. Add the library z.lib to the project.
-5. Add the libc.lib library from the ObjectAda distribution to the project.
-6. Build the executable using test.adb as a main procedure.
-
-
-        How to use ZLib.Ada
-
-The source files test.adb and read.adb are small demo programs that show
-the main functionality of ZLib.Ada.
-
-The routines from the package specifications are commented.
-
-
-Homepage: http://zlib-ada.sourceforge.net/
-Author: Dmitriy Anisimkov <anisimkov@yahoo.com>
-
-Contributors: Pascal Obry <pascal@obry.org>, Steve Sangwine <sjs@essex.ac.uk>
diff -Nbaur gcc-4.6.3/zlib/contrib/ada/test.adb gcc-4.6.3-psp/zlib/contrib/ada/test.adb
--- gcc-4.6.3/zlib/contrib/ada/test.adb	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/ada/test.adb	1970-01-01 01:00:00.000000000 +0100
@@ -1,463 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: test.adb,v 1.17 2003/08/12 12:13:30 vagul Exp $
-
---  The program has a few aims.
---  1. Test ZLib.Ada95 thick binding functionality.
---  2. Show the example of use main functionality of the ZLib.Ada95 binding.
---  3. Build this program automatically compile all ZLib.Ada95 packages under
---     GNAT Ada95 compiler.
-
-with ZLib.Streams;
-with Ada.Streams.Stream_IO;
-with Ada.Numerics.Discrete_Random;
-
-with Ada.Text_IO;
-
-with Ada.Calendar;
-
-procedure Test is
-
-   use Ada.Streams;
-   use Stream_IO;
-
-   ------------------------------------
-   --  Test configuration parameters --
-   ------------------------------------
-
-   File_Size   : Count   := 100_000;
-   Continuous  : constant Boolean := False;
-
-   Header      : constant ZLib.Header_Type := ZLib.Default;
-                                              --  ZLib.None;
-                                              --  ZLib.Auto;
-                                              --  ZLib.GZip;
-   --  Do not use Header other then Default in ZLib versions 1.1.4
-   --  and older.
-
-   Strategy    : constant ZLib.Strategy_Type := ZLib.Default_Strategy;
-   Init_Random : constant := 10;
-
-   -- End --
-
-   In_File_Name  : constant String := "testzlib.in";
-   --  Name of the input file
-
-   Z_File_Name   : constant String := "testzlib.zlb";
-   --  Name of the compressed file.
-
-   Out_File_Name : constant String := "testzlib.out";
-   --  Name of the decompressed file.
-
-   File_In   : File_Type;
-   File_Out  : File_Type;
-   File_Back : File_Type;
-   File_Z    : ZLib.Streams.Stream_Type;
-
-   Filter : ZLib.Filter_Type;
-
-   Time_Stamp : Ada.Calendar.Time;
-
-   procedure Generate_File;
-   --  Generate file of spetsified size with some random data.
-   --  The random data is repeatable, for the good compression.
-
-   procedure Compare_Streams
-     (Left, Right : in out Root_Stream_Type'Class);
-   --  The procedure compearing data in 2 streams.
-   --  It is for compare data before and after compression/decompression.
-
-   procedure Compare_Files (Left, Right : String);
-   --  Compare files. Based on the Compare_Streams.
-
-   procedure Copy_Streams
-     (Source, Target : in out Root_Stream_Type'Class;
-      Buffer_Size    : in     Stream_Element_Offset := 1024);
-   --  Copying data from one stream to another. It is for test stream
-   --  interface of the library.
-
-   procedure Data_In
-     (Item : out Stream_Element_Array;
-      Last : out Stream_Element_Offset);
-   --  this procedure is for generic instantiation of
-   --  ZLib.Generic_Translate.
-   --  reading data from the File_In.
-
-   procedure Data_Out (Item : in Stream_Element_Array);
-   --  this procedure is for generic instantiation of
-   --  ZLib.Generic_Translate.
-   --  writing data to the File_Out.
-
-   procedure Stamp;
-   --  Store the timestamp to the local variable.
-
-   procedure Print_Statistic (Msg : String; Data_Size : ZLib.Count);
-   --  Print the time statistic with the message.
-
-   procedure Translate is new ZLib.Generic_Translate
-                                (Data_In  => Data_In,
-                                 Data_Out => Data_Out);
-   --  This procedure is moving data from File_In to File_Out
-   --  with compression or decompression, depend on initialization of
-   --  Filter parameter.
-
-   -------------------
-   -- Compare_Files --
-   -------------------
-
-   procedure Compare_Files (Left, Right : String) is
-      Left_File, Right_File : File_Type;
-   begin
-      Open (Left_File, In_File, Left);
-      Open (Right_File, In_File, Right);
-      Compare_Streams (Stream (Left_File).all, Stream (Right_File).all);
-      Close (Left_File);
-      Close (Right_File);
-   end Compare_Files;
-
-   ---------------------
-   -- Compare_Streams --
-   ---------------------
-
-   procedure Compare_Streams
-     (Left, Right : in out Ada.Streams.Root_Stream_Type'Class)
-   is
-      Left_Buffer, Right_Buffer : Stream_Element_Array (0 .. 16#FFF#);
-      Left_Last, Right_Last : Stream_Element_Offset;
-   begin
-      loop
-         Read (Left, Left_Buffer, Left_Last);
-         Read (Right, Right_Buffer, Right_Last);
-
-         if Left_Last /= Right_Last then
-            Ada.Text_IO.Put_Line ("Compare error :"
-              & Stream_Element_Offset'Image (Left_Last)
-              & " /= "
-              & Stream_Element_Offset'Image (Right_Last));
-
-            raise Constraint_Error;
-
-         elsif Left_Buffer (0 .. Left_Last)
-               /= Right_Buffer (0 .. Right_Last)
-         then
-            Ada.Text_IO.Put_Line ("ERROR: IN and OUT files is not equal.");
-            raise Constraint_Error;
-
-         end if;
-
-         exit when Left_Last < Left_Buffer'Last;
-      end loop;
-   end Compare_Streams;
-
-   ------------------
-   -- Copy_Streams --
-   ------------------
-
-   procedure Copy_Streams
-     (Source, Target : in out Ada.Streams.Root_Stream_Type'Class;
-      Buffer_Size    : in     Stream_Element_Offset := 1024)
-   is
-      Buffer : Stream_Element_Array (1 .. Buffer_Size);
-      Last   : Stream_Element_Offset;
-   begin
-      loop
-         Read  (Source, Buffer, Last);
-         Write (Target, Buffer (1 .. Last));
-
-         exit when Last < Buffer'Last;
-      end loop;
-   end Copy_Streams;
-
-   -------------
-   -- Data_In --
-   -------------
-
-   procedure Data_In
-     (Item : out Stream_Element_Array;
-      Last : out Stream_Element_Offset) is
-   begin
-      Read (File_In, Item, Last);
-   end Data_In;
-
-   --------------
-   -- Data_Out --
-   --------------
-
-   procedure Data_Out (Item : in Stream_Element_Array) is
-   begin
-      Write (File_Out, Item);
-   end Data_Out;
-
-   -------------------
-   -- Generate_File --
-   -------------------
-
-   procedure Generate_File is
-      subtype Visible_Symbols is Stream_Element range 16#20# .. 16#7E#;
-
-      package Random_Elements is
-         new Ada.Numerics.Discrete_Random (Visible_Symbols);
-
-      Gen    : Random_Elements.Generator;
-      Buffer : Stream_Element_Array := (1 .. 77 => 16#20#) & 10;
-
-      Buffer_Count : constant Count := File_Size / Buffer'Length;
-      --  Number of same buffers in the packet.
-
-      Density : constant Count := 30; --  from 0 to Buffer'Length - 2;
-
-      procedure Fill_Buffer (J, D : in Count);
-      --  Change the part of the buffer.
-
-      -----------------
-      -- Fill_Buffer --
-      -----------------
-
-      procedure Fill_Buffer (J, D : in Count) is
-      begin
-         for K in 0 .. D loop
-            Buffer
-              (Stream_Element_Offset ((J + K) mod (Buffer'Length - 1) + 1))
-             := Random_Elements.Random (Gen);
-
-         end loop;
-      end Fill_Buffer;
-
-   begin
-      Random_Elements.Reset (Gen, Init_Random);
-
-      Create (File_In, Out_File, In_File_Name);
-
-      Fill_Buffer (1, Buffer'Length - 2);
-
-      for J in 1 .. Buffer_Count loop
-         Write (File_In, Buffer);
-
-         Fill_Buffer (J, Density);
-      end loop;
-
-      --  fill remain size.
-
-      Write
-        (File_In,
-         Buffer
-           (1 .. Stream_Element_Offset
-                   (File_Size - Buffer'Length * Buffer_Count)));
-
-      Flush (File_In);
-      Close (File_In);
-   end Generate_File;
-
-   ---------------------
-   -- Print_Statistic --
-   ---------------------
-
-   procedure Print_Statistic (Msg : String; Data_Size : ZLib.Count) is
-      use Ada.Calendar;
-      use Ada.Text_IO;
-
-      package Count_IO is new Integer_IO (ZLib.Count);
-
-      Curr_Dur : Duration := Clock - Time_Stamp;
-   begin
-      Put (Msg);
-
-      Set_Col (20);
-      Ada.Text_IO.Put ("size =");
-
-      Count_IO.Put
-        (Data_Size,
-         Width => Stream_IO.Count'Image (File_Size)'Length);
-
-      Put_Line (" duration =" & Duration'Image (Curr_Dur));
-   end Print_Statistic;
-
-   -----------
-   -- Stamp --
-   -----------
-
-   procedure Stamp is
-   begin
-      Time_Stamp := Ada.Calendar.Clock;
-   end Stamp;
-
-begin
-   Ada.Text_IO.Put_Line ("ZLib " & ZLib.Version);
-
-   loop
-      Generate_File;
-
-      for Level in ZLib.Compression_Level'Range loop
-
-         Ada.Text_IO.Put_Line ("Level ="
-            & ZLib.Compression_Level'Image (Level));
-
-         --  Test generic interface.
-         Open   (File_In, In_File, In_File_Name);
-         Create (File_Out, Out_File, Z_File_Name);
-
-         Stamp;
-
-         --  Deflate using generic instantiation.
-
-         ZLib.Deflate_Init
-               (Filter   => Filter,
-                Level    => Level,
-                Strategy => Strategy,
-                Header   => Header);
-
-         Translate (Filter);
-         Print_Statistic ("Generic compress", ZLib.Total_Out (Filter));
-         ZLib.Close (Filter);
-
-         Close (File_In);
-         Close (File_Out);
-
-         Open   (File_In, In_File, Z_File_Name);
-         Create (File_Out, Out_File, Out_File_Name);
-
-         Stamp;
-
-         --  Inflate using generic instantiation.
-
-         ZLib.Inflate_Init (Filter, Header => Header);
-
-         Translate (Filter);
-         Print_Statistic ("Generic decompress", ZLib.Total_Out (Filter));
-
-         ZLib.Close (Filter);
-
-         Close (File_In);
-         Close (File_Out);
-
-         Compare_Files (In_File_Name, Out_File_Name);
-
-         --  Test stream interface.
-
-         --  Compress to the back stream.
-
-         Open   (File_In, In_File, In_File_Name);
-         Create (File_Back, Out_File, Z_File_Name);
-
-         Stamp;
-
-         ZLib.Streams.Create
-           (Stream          => File_Z,
-            Mode            => ZLib.Streams.Out_Stream,
-            Back            => ZLib.Streams.Stream_Access
-                                 (Stream (File_Back)),
-            Back_Compressed => True,
-            Level           => Level,
-            Strategy        => Strategy,
-            Header          => Header);
-
-         Copy_Streams
-           (Source => Stream (File_In).all,
-            Target => File_Z);
-
-         --  Flushing internal buffers to the back stream.
-
-         ZLib.Streams.Flush (File_Z, ZLib.Finish);
-
-         Print_Statistic ("Write compress",
-                          ZLib.Streams.Write_Total_Out (File_Z));
-
-         ZLib.Streams.Close (File_Z);
-
-         Close (File_In);
-         Close (File_Back);
-
-         --  Compare reading from original file and from
-         --  decompression stream.
-
-         Open (File_In,   In_File, In_File_Name);
-         Open (File_Back, In_File, Z_File_Name);
-
-         ZLib.Streams.Create
-           (Stream          => File_Z,
-            Mode            => ZLib.Streams.In_Stream,
-            Back            => ZLib.Streams.Stream_Access
-                                 (Stream (File_Back)),
-            Back_Compressed => True,
-            Header          => Header);
-
-         Stamp;
-         Compare_Streams (Stream (File_In).all, File_Z);
-
-         Print_Statistic ("Read decompress",
-                          ZLib.Streams.Read_Total_Out (File_Z));
-
-         ZLib.Streams.Close (File_Z);
-         Close (File_In);
-         Close (File_Back);
-
-         --  Compress by reading from compression stream.
-
-         Open (File_Back, In_File, In_File_Name);
-         Create (File_Out, Out_File, Z_File_Name);
-
-         ZLib.Streams.Create
-           (Stream          => File_Z,
-            Mode            => ZLib.Streams.In_Stream,
-            Back            => ZLib.Streams.Stream_Access
-                                 (Stream (File_Back)),
-            Back_Compressed => False,
-            Level           => Level,
-            Strategy        => Strategy,
-            Header          => Header);
-
-         Stamp;
-         Copy_Streams
-           (Source => File_Z,
-            Target => Stream (File_Out).all);
-
-         Print_Statistic ("Read compress",
-                          ZLib.Streams.Read_Total_Out (File_Z));
-
-         ZLib.Streams.Close (File_Z);
-
-         Close (File_Out);
-         Close (File_Back);
-
-         --  Decompress to decompression stream.
-
-         Open   (File_In,   In_File, Z_File_Name);
-         Create (File_Back, Out_File, Out_File_Name);
-
-         ZLib.Streams.Create
-           (Stream          => File_Z,
-            Mode            => ZLib.Streams.Out_Stream,
-            Back            => ZLib.Streams.Stream_Access
-                                 (Stream (File_Back)),
-            Back_Compressed => False,
-            Header          => Header);
-
-         Stamp;
-
-         Copy_Streams
-           (Source => Stream (File_In).all,
-            Target => File_Z);
-
-         Print_Statistic ("Write decompress",
-                          ZLib.Streams.Write_Total_Out (File_Z));
-
-         ZLib.Streams.Close (File_Z);
-         Close (File_In);
-         Close (File_Back);
-
-         Compare_Files (In_File_Name, Out_File_Name);
-      end loop;
-
-      Ada.Text_IO.Put_Line (Count'Image (File_Size) & " Ok.");
-
-      exit when not Continuous;
-
-      File_Size := File_Size + 1;
-   end loop;
-end Test;
diff -Nbaur gcc-4.6.3/zlib/contrib/ada/zlib.adb gcc-4.6.3-psp/zlib/contrib/ada/zlib.adb
--- gcc-4.6.3/zlib/contrib/ada/zlib.adb	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/ada/zlib.adb	1970-01-01 01:00:00.000000000 +0100
@@ -1,701 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2004 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: zlib.adb,v 1.31 2004/09/06 06:53:19 vagul Exp $
-
-with Ada.Exceptions;
-with Ada.Unchecked_Conversion;
-with Ada.Unchecked_Deallocation;
-
-with Interfaces.C.Strings;
-
-with ZLib.Thin;
-
-package body ZLib is
-
-   use type Thin.Int;
-
-   type Z_Stream is new Thin.Z_Stream;
-
-   type Return_Code_Enum is
-      (OK,
-       STREAM_END,
-       NEED_DICT,
-       ERRNO,
-       STREAM_ERROR,
-       DATA_ERROR,
-       MEM_ERROR,
-       BUF_ERROR,
-       VERSION_ERROR);
-
-   type Flate_Step_Function is access
-     function (Strm : in Thin.Z_Streamp; Flush : in Thin.Int) return Thin.Int;
-   pragma Convention (C, Flate_Step_Function);
-
-   type Flate_End_Function is access
-      function (Ctrm : in Thin.Z_Streamp) return Thin.Int;
-   pragma Convention (C, Flate_End_Function);
-
-   type Flate_Type is record
-      Step : Flate_Step_Function;
-      Done : Flate_End_Function;
-   end record;
-
-   subtype Footer_Array is Stream_Element_Array (1 .. 8);
-
-   Simple_GZip_Header : constant Stream_Element_Array (1 .. 10)
-     := (16#1f#, 16#8b#,                 --  Magic header
-         16#08#,                         --  Z_DEFLATED
-         16#00#,                         --  Flags
-         16#00#, 16#00#, 16#00#, 16#00#, --  Time
-         16#00#,                         --  XFlags
-         16#03#                          --  OS code
-        );
-   --  The simplest gzip header is not for informational, but just for
-   --  gzip format compatibility.
-   --  Note that some code below is using assumption
-   --  Simple_GZip_Header'Last > Footer_Array'Last, so do not make
-   --  Simple_GZip_Header'Last <= Footer_Array'Last.
-
-   Return_Code : constant array (Thin.Int range <>) of Return_Code_Enum
-     := (0 => OK,
-         1 => STREAM_END,
-         2 => NEED_DICT,
-        -1 => ERRNO,
-        -2 => STREAM_ERROR,
-        -3 => DATA_ERROR,
-        -4 => MEM_ERROR,
-        -5 => BUF_ERROR,
-        -6 => VERSION_ERROR);
-
-   Flate : constant array (Boolean) of Flate_Type
-     := (True  => (Step => Thin.Deflate'Access,
-                   Done => Thin.DeflateEnd'Access),
-         False => (Step => Thin.Inflate'Access,
-                   Done => Thin.InflateEnd'Access));
-
-   Flush_Finish : constant array (Boolean) of Flush_Mode
-     := (True => Finish, False => No_Flush);
-
-   procedure Raise_Error (Stream : in Z_Stream);
-   pragma Inline (Raise_Error);
-
-   procedure Raise_Error (Message : in String);
-   pragma Inline (Raise_Error);
-
-   procedure Check_Error (Stream : in Z_Stream; Code : in Thin.Int);
-
-   procedure Free is new Ada.Unchecked_Deallocation
-      (Z_Stream, Z_Stream_Access);
-
-   function To_Thin_Access is new Ada.Unchecked_Conversion
-     (Z_Stream_Access, Thin.Z_Streamp);
-
-   procedure Translate_GZip
-     (Filter    : in out Filter_Type;
-      In_Data   : in     Ada.Streams.Stream_Element_Array;
-      In_Last   :    out Ada.Streams.Stream_Element_Offset;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode);
-   --  Separate translate routine for make gzip header.
-
-   procedure Translate_Auto
-     (Filter    : in out Filter_Type;
-      In_Data   : in     Ada.Streams.Stream_Element_Array;
-      In_Last   :    out Ada.Streams.Stream_Element_Offset;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode);
-   --  translate routine without additional headers.
-
-   -----------------
-   -- Check_Error --
-   -----------------
-
-   procedure Check_Error (Stream : in Z_Stream; Code : in Thin.Int) is
-      use type Thin.Int;
-   begin
-      if Code /= Thin.Z_OK then
-         Raise_Error
-            (Return_Code_Enum'Image (Return_Code (Code))
-              & ": " & Last_Error_Message (Stream));
-      end if;
-   end Check_Error;
-
-   -----------
-   -- Close --
-   -----------
-
-   procedure Close
-     (Filter       : in out Filter_Type;
-      Ignore_Error : in     Boolean := False)
-   is
-      Code : Thin.Int;
-   begin
-      if not Ignore_Error and then not Is_Open (Filter) then
-         raise Status_Error;
-      end if;
-
-      Code := Flate (Filter.Compression).Done (To_Thin_Access (Filter.Strm));
-
-      if Ignore_Error or else Code = Thin.Z_OK then
-         Free (Filter.Strm);
-      else
-         declare
-            Error_Message : constant String
-              := Last_Error_Message (Filter.Strm.all);
-         begin
-            Free (Filter.Strm);
-            Ada.Exceptions.Raise_Exception
-               (ZLib_Error'Identity,
-                Return_Code_Enum'Image (Return_Code (Code))
-                  & ": " & Error_Message);
-         end;
-      end if;
-   end Close;
-
-   -----------
-   -- CRC32 --
-   -----------
-
-   function CRC32
-     (CRC  : in Unsigned_32;
-      Data : in Ada.Streams.Stream_Element_Array)
-      return Unsigned_32
-   is
-      use Thin;
-   begin
-      return Unsigned_32 (crc32 (ULong (CRC),
-                                 Data'Address,
-                                 Data'Length));
-   end CRC32;
-
-   procedure CRC32
-     (CRC  : in out Unsigned_32;
-      Data : in     Ada.Streams.Stream_Element_Array) is
-   begin
-      CRC := CRC32 (CRC, Data);
-   end CRC32;
-
-   ------------------
-   -- Deflate_Init --
-   ------------------
-
-   procedure Deflate_Init
-     (Filter       : in out Filter_Type;
-      Level        : in     Compression_Level  := Default_Compression;
-      Strategy     : in     Strategy_Type      := Default_Strategy;
-      Method       : in     Compression_Method := Deflated;
-      Window_Bits  : in     Window_Bits_Type   := Default_Window_Bits;
-      Memory_Level : in     Memory_Level_Type  := Default_Memory_Level;
-      Header       : in     Header_Type        := Default)
-   is
-      use type Thin.Int;
-      Win_Bits : Thin.Int := Thin.Int (Window_Bits);
-   begin
-      if Is_Open (Filter) then
-         raise Status_Error;
-      end if;
-
-      --  We allow ZLib to make header only in case of default header type.
-      --  Otherwise we would either do header by ourselfs, or do not do
-      --  header at all.
-
-      if Header = None or else Header = GZip then
-         Win_Bits := -Win_Bits;
-      end if;
-
-      --  For the GZip CRC calculation and make headers.
-
-      if Header = GZip then
-         Filter.CRC    := 0;
-         Filter.Offset := Simple_GZip_Header'First;
-      else
-         Filter.Offset := Simple_GZip_Header'Last + 1;
-      end if;
-
-      Filter.Strm        := new Z_Stream;
-      Filter.Compression := True;
-      Filter.Stream_End  := False;
-      Filter.Header      := Header;
-
-      if Thin.Deflate_Init
-           (To_Thin_Access (Filter.Strm),
-            Level      => Thin.Int (Level),
-            method     => Thin.Int (Method),
-            windowBits => Win_Bits,
-            memLevel   => Thin.Int (Memory_Level),
-            strategy   => Thin.Int (Strategy)) /= Thin.Z_OK
-      then
-         Raise_Error (Filter.Strm.all);
-      end if;
-   end Deflate_Init;
-
-   -----------
-   -- Flush --
-   -----------
-
-   procedure Flush
-     (Filter    : in out Filter_Type;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode)
-   is
-      No_Data : Stream_Element_Array := (1 .. 0 => 0);
-      Last    : Stream_Element_Offset;
-   begin
-      Translate (Filter, No_Data, Last, Out_Data, Out_Last, Flush);
-   end Flush;
-
-   -----------------------
-   -- Generic_Translate --
-   -----------------------
-
-   procedure Generic_Translate
-     (Filter          : in out ZLib.Filter_Type;
-      In_Buffer_Size  : in     Integer := Default_Buffer_Size;
-      Out_Buffer_Size : in     Integer := Default_Buffer_Size)
-   is
-      In_Buffer  : Stream_Element_Array
-                     (1 .. Stream_Element_Offset (In_Buffer_Size));
-      Out_Buffer : Stream_Element_Array
-                     (1 .. Stream_Element_Offset (Out_Buffer_Size));
-      Last       : Stream_Element_Offset;
-      In_Last    : Stream_Element_Offset;
-      In_First   : Stream_Element_Offset;
-      Out_Last   : Stream_Element_Offset;
-   begin
-      Main : loop
-         Data_In (In_Buffer, Last);
-
-         In_First := In_Buffer'First;
-
-         loop
-            Translate
-              (Filter   => Filter,
-               In_Data  => In_Buffer (In_First .. Last),
-               In_Last  => In_Last,
-               Out_Data => Out_Buffer,
-               Out_Last => Out_Last,
-               Flush    => Flush_Finish (Last < In_Buffer'First));
-
-            if Out_Buffer'First <= Out_Last then
-               Data_Out (Out_Buffer (Out_Buffer'First .. Out_Last));
-            end if;
-
-            exit Main when Stream_End (Filter);
-
-            --  The end of in buffer.
-
-            exit when In_Last = Last;
-
-            In_First := In_Last + 1;
-         end loop;
-      end loop Main;
-
-   end Generic_Translate;
-
-   ------------------
-   -- Inflate_Init --
-   ------------------
-
-   procedure Inflate_Init
-     (Filter      : in out Filter_Type;
-      Window_Bits : in     Window_Bits_Type := Default_Window_Bits;
-      Header      : in     Header_Type      := Default)
-   is
-      use type Thin.Int;
-      Win_Bits : Thin.Int := Thin.Int (Window_Bits);
-
-      procedure Check_Version;
-      --  Check the latest header types compatibility.
-
-      procedure Check_Version is
-      begin
-         if Version <= "1.1.4" then
-            Raise_Error
-              ("Inflate header type " & Header_Type'Image (Header)
-               & " incompatible with ZLib version " & Version);
-         end if;
-      end Check_Version;
-
-   begin
-      if Is_Open (Filter) then
-         raise Status_Error;
-      end if;
-
-      case Header is
-         when None =>
-            Check_Version;
-
-            --  Inflate data without headers determined
-            --  by negative Win_Bits.
-
-            Win_Bits := -Win_Bits;
-         when GZip =>
-            Check_Version;
-
-            --  Inflate gzip data defined by flag 16.
-
-            Win_Bits := Win_Bits + 16;
-         when Auto =>
-            Check_Version;
-
-            --  Inflate with automatic detection
-            --  of gzip or native header defined by flag 32.
-
-            Win_Bits := Win_Bits + 32;
-         when Default => null;
-      end case;
-
-      Filter.Strm        := new Z_Stream;
-      Filter.Compression := False;
-      Filter.Stream_End  := False;
-      Filter.Header      := Header;
-
-      if Thin.Inflate_Init
-         (To_Thin_Access (Filter.Strm), Win_Bits) /= Thin.Z_OK
-      then
-         Raise_Error (Filter.Strm.all);
-      end if;
-   end Inflate_Init;
-
-   -------------
-   -- Is_Open --
-   -------------
-
-   function Is_Open (Filter : in Filter_Type) return Boolean is
-   begin
-      return Filter.Strm /= null;
-   end Is_Open;
-
-   -----------------
-   -- Raise_Error --
-   -----------------
-
-   procedure Raise_Error (Message : in String) is
-   begin
-      Ada.Exceptions.Raise_Exception (ZLib_Error'Identity, Message);
-   end Raise_Error;
-
-   procedure Raise_Error (Stream : in Z_Stream) is
-   begin
-      Raise_Error (Last_Error_Message (Stream));
-   end Raise_Error;
-
-   ----------
-   -- Read --
-   ----------
-
-   procedure Read
-     (Filter : in out Filter_Type;
-      Item   :    out Ada.Streams.Stream_Element_Array;
-      Last   :    out Ada.Streams.Stream_Element_Offset;
-      Flush  : in     Flush_Mode := No_Flush)
-   is
-      In_Last    : Stream_Element_Offset;
-      Item_First : Ada.Streams.Stream_Element_Offset := Item'First;
-      V_Flush    : Flush_Mode := Flush;
-
-   begin
-      pragma Assert (Rest_First in Buffer'First .. Buffer'Last + 1);
-      pragma Assert (Rest_Last in Buffer'First - 1 .. Buffer'Last);
-
-      loop
-         if Rest_Last = Buffer'First - 1 then
-            V_Flush := Finish;
-
-         elsif Rest_First > Rest_Last then
-            Read (Buffer, Rest_Last);
-            Rest_First := Buffer'First;
-
-            if Rest_Last < Buffer'First then
-               V_Flush := Finish;
-            end if;
-         end if;
-
-         Translate
-           (Filter   => Filter,
-            In_Data  => Buffer (Rest_First .. Rest_Last),
-            In_Last  => In_Last,
-            Out_Data => Item (Item_First .. Item'Last),
-            Out_Last => Last,
-            Flush    => V_Flush);
-
-         Rest_First := In_Last + 1;
-
-         exit when Stream_End (Filter)
-           or else Last = Item'Last
-           or else (Last >= Item'First and then Allow_Read_Some);
-
-         Item_First := Last + 1;
-      end loop;
-   end Read;
-
-   ----------------
-   -- Stream_End --
-   ----------------
-
-   function Stream_End (Filter : in Filter_Type) return Boolean is
-   begin
-      if Filter.Header = GZip and Filter.Compression then
-         return Filter.Stream_End
-            and then Filter.Offset = Footer_Array'Last + 1;
-      else
-         return Filter.Stream_End;
-      end if;
-   end Stream_End;
-
-   --------------
-   -- Total_In --
-   --------------
-
-   function Total_In (Filter : in Filter_Type) return Count is
-   begin
-      return Count (Thin.Total_In (To_Thin_Access (Filter.Strm).all));
-   end Total_In;
-
-   ---------------
-   -- Total_Out --
-   ---------------
-
-   function Total_Out (Filter : in Filter_Type) return Count is
-   begin
-      return Count (Thin.Total_Out (To_Thin_Access (Filter.Strm).all));
-   end Total_Out;
-
-   ---------------
-   -- Translate --
-   ---------------
-
-   procedure Translate
-     (Filter    : in out Filter_Type;
-      In_Data   : in     Ada.Streams.Stream_Element_Array;
-      In_Last   :    out Ada.Streams.Stream_Element_Offset;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode) is
-   begin
-      if Filter.Header = GZip and then Filter.Compression then
-         Translate_GZip
-           (Filter   => Filter,
-            In_Data  => In_Data,
-            In_Last  => In_Last,
-            Out_Data => Out_Data,
-            Out_Last => Out_Last,
-            Flush    => Flush);
-      else
-         Translate_Auto
-           (Filter   => Filter,
-            In_Data  => In_Data,
-            In_Last  => In_Last,
-            Out_Data => Out_Data,
-            Out_Last => Out_Last,
-            Flush    => Flush);
-      end if;
-   end Translate;
-
-   --------------------
-   -- Translate_Auto --
-   --------------------
-
-   procedure Translate_Auto
-     (Filter    : in out Filter_Type;
-      In_Data   : in     Ada.Streams.Stream_Element_Array;
-      In_Last   :    out Ada.Streams.Stream_Element_Offset;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode)
-   is
-      use type Thin.Int;
-      Code : Thin.Int;
-
-   begin
-      if not Is_Open (Filter) then
-         raise Status_Error;
-      end if;
-
-      if Out_Data'Length = 0 and then In_Data'Length = 0 then
-         raise Constraint_Error;
-      end if;
-
-      Set_Out (Filter.Strm.all, Out_Data'Address, Out_Data'Length);
-      Set_In  (Filter.Strm.all, In_Data'Address, In_Data'Length);
-
-      Code := Flate (Filter.Compression).Step
-        (To_Thin_Access (Filter.Strm),
-         Thin.Int (Flush));
-
-      if Code = Thin.Z_STREAM_END then
-         Filter.Stream_End := True;
-      else
-         Check_Error (Filter.Strm.all, Code);
-      end if;
-
-      In_Last  := In_Data'Last
-         - Stream_Element_Offset (Avail_In (Filter.Strm.all));
-      Out_Last := Out_Data'Last
-         - Stream_Element_Offset (Avail_Out (Filter.Strm.all));
-   end Translate_Auto;
-
-   --------------------
-   -- Translate_GZip --
-   --------------------
-
-   procedure Translate_GZip
-     (Filter    : in out Filter_Type;
-      In_Data   : in     Ada.Streams.Stream_Element_Array;
-      In_Last   :    out Ada.Streams.Stream_Element_Offset;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode)
-   is
-      Out_First : Stream_Element_Offset;
-
-      procedure Add_Data (Data : in Stream_Element_Array);
-      --  Add data to stream from the Filter.Offset till necessary,
-      --  used for add gzip headr/footer.
-
-      procedure Put_32
-        (Item : in out Stream_Element_Array;
-         Data : in     Unsigned_32);
-      pragma Inline (Put_32);
-
-      --------------
-      -- Add_Data --
-      --------------
-
-      procedure Add_Data (Data : in Stream_Element_Array) is
-         Data_First : Stream_Element_Offset renames Filter.Offset;
-         Data_Last  : Stream_Element_Offset;
-         Data_Len   : Stream_Element_Offset; --  -1
-         Out_Len    : Stream_Element_Offset; --  -1
-      begin
-         Out_First := Out_Last + 1;
-
-         if Data_First > Data'Last then
-            return;
-         end if;
-
-         Data_Len  := Data'Last     - Data_First;
-         Out_Len   := Out_Data'Last - Out_First;
-
-         if Data_Len <= Out_Len then
-            Out_Last  := Out_First  + Data_Len;
-            Data_Last := Data'Last;
-         else
-            Out_Last  := Out_Data'Last;
-            Data_Last := Data_First + Out_Len;
-         end if;
-
-         Out_Data (Out_First .. Out_Last) := Data (Data_First .. Data_Last);
-
-         Data_First := Data_Last + 1;
-         Out_First  := Out_Last + 1;
-      end Add_Data;
-
-      ------------
-      -- Put_32 --
-      ------------
-
-      procedure Put_32
-        (Item : in out Stream_Element_Array;
-         Data : in     Unsigned_32)
-      is
-         D : Unsigned_32 := Data;
-      begin
-         for J in Item'First .. Item'First + 3 loop
-            Item (J) := Stream_Element (D and 16#FF#);
-            D := Shift_Right (D, 8);
-         end loop;
-      end Put_32;
-
-   begin
-      Out_Last := Out_Data'First - 1;
-
-      if not Filter.Stream_End then
-         Add_Data (Simple_GZip_Header);
-
-         Translate_Auto
-           (Filter   => Filter,
-            In_Data  => In_Data,
-            In_Last  => In_Last,
-            Out_Data => Out_Data (Out_First .. Out_Data'Last),
-            Out_Last => Out_Last,
-            Flush    => Flush);
-
-         CRC32 (Filter.CRC, In_Data (In_Data'First .. In_Last));
-      end if;
-
-      if Filter.Stream_End and then Out_Last <= Out_Data'Last then
-         --  This detection method would work only when
-         --  Simple_GZip_Header'Last > Footer_Array'Last
-
-         if Filter.Offset = Simple_GZip_Header'Last + 1 then
-            Filter.Offset := Footer_Array'First;
-         end if;
-
-         declare
-            Footer : Footer_Array;
-         begin
-            Put_32 (Footer, Filter.CRC);
-            Put_32 (Footer (Footer'First + 4 .. Footer'Last),
-                    Unsigned_32 (Total_In (Filter)));
-            Add_Data (Footer);
-         end;
-      end if;
-   end Translate_GZip;
-
-   -------------
-   -- Version --
-   -------------
-
-   function Version return String is
-   begin
-      return Interfaces.C.Strings.Value (Thin.zlibVersion);
-   end Version;
-
-   -----------
-   -- Write --
-   -----------
-
-   procedure Write
-     (Filter : in out Filter_Type;
-      Item   : in     Ada.Streams.Stream_Element_Array;
-      Flush  : in     Flush_Mode := No_Flush)
-   is
-      Buffer   : Stream_Element_Array (1 .. Buffer_Size);
-      In_Last  : Stream_Element_Offset;
-      Out_Last : Stream_Element_Offset;
-      In_First : Stream_Element_Offset := Item'First;
-   begin
-      if Item'Length = 0 and Flush = No_Flush then
-         return;
-      end if;
-
-      loop
-         Translate
-           (Filter   => Filter,
-            In_Data  => Item (In_First .. Item'Last),
-            In_Last  => In_Last,
-            Out_Data => Buffer,
-            Out_Last => Out_Last,
-            Flush    => Flush);
-
-         if Out_Last >= Buffer'First then
-            Write (Buffer (1 .. Out_Last));
-         end if;
-
-         exit when In_Last = Item'Last or Stream_End (Filter);
-
-         In_First := In_Last + 1;
-      end loop;
-   end Write;
-
-end ZLib;
diff -Nbaur gcc-4.6.3/zlib/contrib/ada/zlib.ads gcc-4.6.3-psp/zlib/contrib/ada/zlib.ads
--- gcc-4.6.3/zlib/contrib/ada/zlib.ads	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/ada/zlib.ads	1970-01-01 01:00:00.000000000 +0100
@@ -1,328 +0,0 @@
-------------------------------------------------------------------------------
---                      ZLib for Ada thick binding.                         --
---                                                                          --
---              Copyright (C) 2002-2004 Dmitriy Anisimkov                   --
---                                                                          --
---  This library is free software; you can redistribute it and/or modify    --
---  it under the terms of the GNU General Public License as published by    --
---  the Free Software Foundation; either version 2 of the License, or (at   --
---  your option) any later version.                                         --
---                                                                          --
---  This library is distributed in the hope that it will be useful, but     --
---  WITHOUT ANY WARRANTY; without even the implied warranty of              --
---  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU       --
---  General Public License for more details.                                --
---                                                                          --
---  You should have received a copy of the GNU General Public License       --
---  along with this library; if not, write to the Free Software Foundation, --
---  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.          --
---                                                                          --
---  As a special exception, if other files instantiate generics from this   --
---  unit, or you link this unit with other files to produce an executable,  --
---  this  unit  does not  by itself cause  the resulting executable to be   --
---  covered by the GNU General Public License. This exception does not      --
---  however invalidate any other reasons why the executable file  might be  --
---  covered by the  GNU Public License.                                     --
-------------------------------------------------------------------------------
-
---  $Id: zlib.ads,v 1.26 2004/09/06 06:53:19 vagul Exp $
-
-with Ada.Streams;
-
-with Interfaces;
-
-package ZLib is
-
-   ZLib_Error   : exception;
-   Status_Error : exception;
-
-   type Compression_Level is new Integer range -1 .. 9;
-
-   type Flush_Mode is private;
-
-   type Compression_Method is private;
-
-   type Window_Bits_Type is new Integer range 8 .. 15;
-
-   type Memory_Level_Type is new Integer range 1 .. 9;
-
-   type Unsigned_32 is new Interfaces.Unsigned_32;
-
-   type Strategy_Type is private;
-
-   type Header_Type is (None, Auto, Default, GZip);
-   --  Header type usage have a some limitation for inflate.
-   --  See comment for Inflate_Init.
-
-   subtype Count is Ada.Streams.Stream_Element_Count;
-
-   Default_Memory_Level : constant Memory_Level_Type := 8;
-   Default_Window_Bits  : constant Window_Bits_Type  := 15;
-
-   ----------------------------------
-   -- Compression method constants --
-   ----------------------------------
-
-   Deflated : constant Compression_Method;
-   --  Only one method allowed in this ZLib version
-
-   ---------------------------------
-   -- Compression level constants --
-   ---------------------------------
-
-   No_Compression      : constant Compression_Level := 0;
-   Best_Speed          : constant Compression_Level := 1;
-   Best_Compression    : constant Compression_Level := 9;
-   Default_Compression : constant Compression_Level := -1;
-
-   --------------------------
-   -- Flush mode constants --
-   --------------------------
-
-   No_Flush      : constant Flush_Mode;
-   --  Regular way for compression, no flush
-
-   Partial_Flush : constant Flush_Mode;
-   --  Will be removed, use Z_SYNC_FLUSH instead
-
-   Sync_Flush    : constant Flush_Mode;
-   --  All pending output is flushed to the output buffer and the output
-   --  is aligned on a byte boundary, so that the decompressor can get all
-   --  input data available so far. (In particular avail_in is zero after the
-   --  call if enough output space has been provided  before the call.)
-   --  Flushing may degrade compression for some compression algorithms and so
-   --  it should be used only when necessary.
-
-   Block_Flush   : constant Flush_Mode;
-   --  Z_BLOCK requests that inflate() stop
-   --  if and when it get to the next deflate block boundary. When decoding the
-   --  zlib or gzip format, this will cause inflate() to return immediately
-   --  after the header and before the first block. When doing a raw inflate,
-   --  inflate() will go ahead and process the first block, and will return
-   --  when it gets to the end of that block, or when it runs out of data.
-
-   Full_Flush    : constant Flush_Mode;
-   --  All output is flushed as with SYNC_FLUSH, and the compression state
-   --  is reset so that decompression can restart from this point if previous
-   --  compressed data has been damaged or if random access is desired. Using
-   --  Full_Flush too often can seriously degrade the compression.
-
-   Finish        : constant Flush_Mode;
-   --  Just for tell the compressor that input data is complete.
-
-   ------------------------------------
-   -- Compression strategy constants --
-   ------------------------------------
-
-   --  RLE stategy could be used only in version 1.2.0 and later.
-
-   Filtered         : constant Strategy_Type;
-   Huffman_Only     : constant Strategy_Type;
-   RLE              : constant Strategy_Type;
-   Default_Strategy : constant Strategy_Type;
-
-   Default_Buffer_Size : constant := 4096;
-
-   type Filter_Type is tagged limited private;
-   --  The filter is for compression and for decompression.
-   --  The usage of the type is depend of its initialization.
-
-   function Version return String;
-   pragma Inline (Version);
-   --  Return string representation of the ZLib version.
-
-   procedure Deflate_Init
-     (Filter       : in out Filter_Type;
-      Level        : in     Compression_Level  := Default_Compression;
-      Strategy     : in     Strategy_Type      := Default_Strategy;
-      Method       : in     Compression_Method := Deflated;
-      Window_Bits  : in     Window_Bits_Type   := Default_Window_Bits;
-      Memory_Level : in     Memory_Level_Type  := Default_Memory_Level;
-      Header       : in     Header_Type        := Default);
-   --  Compressor initialization.
-   --  When Header parameter is Auto or Default, then default zlib header
-   --  would be provided for compressed data.
-   --  When Header is GZip, then gzip header would be set instead of
-   --  default header.
-   --  When Header is None, no header would be set for compressed data.
-
-   procedure Inflate_Init
-     (Filter      : in out Filter_Type;
-      Window_Bits : in     Window_Bits_Type := Default_Window_Bits;
-      Header      : in     Header_Type      := Default);
-   --  Decompressor initialization.
-   --  Default header type mean that ZLib default header is expecting in the
-   --  input compressed stream.
-   --  Header type None mean that no header is expecting in the input stream.
-   --  GZip header type mean that GZip header is expecting in the
-   --  input compressed stream.
-   --  Auto header type mean that header type (GZip or Native) would be
-   --  detected automatically in the input stream.
-   --  Note that header types parameter values None, GZip and Auto are
-   --  supported for inflate routine only in ZLib versions 1.2.0.2 and later.
-   --  Deflate_Init is supporting all header types.
-
-   function Is_Open (Filter : in Filter_Type) return Boolean;
-   pragma Inline (Is_Open);
-   --  Is the filter opened for compression or decompression.
-
-   procedure Close
-     (Filter       : in out Filter_Type;
-      Ignore_Error : in     Boolean := False);
-   --  Closing the compression or decompressor.
-   --  If stream is closing before the complete and Ignore_Error is False,
-   --  The exception would be raised.
-
-   generic
-      with procedure Data_In
-        (Item : out Ada.Streams.Stream_Element_Array;
-         Last : out Ada.Streams.Stream_Element_Offset);
-      with procedure Data_Out
-        (Item : in Ada.Streams.Stream_Element_Array);
-   procedure Generic_Translate
-     (Filter          : in out Filter_Type;
-      In_Buffer_Size  : in     Integer := Default_Buffer_Size;
-      Out_Buffer_Size : in     Integer := Default_Buffer_Size);
-   --  Compress/decompress data fetch from Data_In routine and pass the result
-   --  to the Data_Out routine. User should provide Data_In and Data_Out
-   --  for compression/decompression data flow.
-   --  Compression or decompression depend on Filter initialization.
-
-   function Total_In (Filter : in Filter_Type) return Count;
-   pragma Inline (Total_In);
-   --  Returns total number of input bytes read so far
-
-   function Total_Out (Filter : in Filter_Type) return Count;
-   pragma Inline (Total_Out);
-   --  Returns total number of bytes output so far
-
-   function CRC32
-     (CRC    : in Unsigned_32;
-      Data   : in Ada.Streams.Stream_Element_Array)
-      return Unsigned_32;
-   pragma Inline (CRC32);
-   --  Compute CRC32, it could be necessary for make gzip format
-
-   procedure CRC32
-     (CRC  : in out Unsigned_32;
-      Data : in     Ada.Streams.Stream_Element_Array);
-   pragma Inline (CRC32);
-   --  Compute CRC32, it could be necessary for make gzip format
-
-   -------------------------------------------------
-   --  Below is more complex low level routines.  --
-   -------------------------------------------------
-
-   procedure Translate
-     (Filter    : in out Filter_Type;
-      In_Data   : in     Ada.Streams.Stream_Element_Array;
-      In_Last   :    out Ada.Streams.Stream_Element_Offset;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode);
-   --  Compress/decompress the In_Data buffer and place the result into
-   --  Out_Data. In_Last is the index of last element from In_Data accepted by
-   --  the Filter. Out_Last is the last element of the received data from
-   --  Filter. To tell the filter that incoming data are complete put the
-   --  Flush parameter to Finish.
-
-   function Stream_End (Filter : in Filter_Type) return Boolean;
-   pragma Inline (Stream_End);
-   --  Return the true when the stream is complete.
-
-   procedure Flush
-     (Filter    : in out Filter_Type;
-      Out_Data  :    out Ada.Streams.Stream_Element_Array;
-      Out_Last  :    out Ada.Streams.Stream_Element_Offset;
-      Flush     : in     Flush_Mode);
-   pragma Inline (Flush);
-   --  Flushing the data from the compressor.
-
-   generic
-      with procedure Write
-        (Item : in Ada.Streams.Stream_Element_Array);
-      --  User should provide this routine for accept
-      --  compressed/decompressed data.
-
-      Buffer_Size : in Ada.Streams.Stream_Element_Offset
-         := Default_Buffer_Size;
-      --  Buffer size for Write user routine.
-
-   procedure Write
-     (Filter  : in out Filter_Type;
-      Item    : in     Ada.Streams.Stream_Element_Array;
-      Flush   : in     Flush_Mode := No_Flush);
-   --  Compress/Decompress data from Item to the generic parameter procedure
-   --  Write. Output buffer size could be set in Buffer_Size generic parameter.
-
-   generic
-      with procedure Read
-        (Item : out Ada.Streams.Stream_Element_Array;
-         Last : out Ada.Streams.Stream_Element_Offset);
-      --  User should provide data for compression/decompression
-      --  thru this routine.
-
-      Buffer : in out Ada.Streams.Stream_Element_Array;
-      --  Buffer for keep remaining data from the previous
-      --  back read.
-
-      Rest_First, Rest_Last : in out Ada.Streams.Stream_Element_Offset;
-      --  Rest_First have to be initialized to Buffer'Last + 1
-      --  Rest_Last have to be initialized to Buffer'Last
-      --  before usage.
-
-      Allow_Read_Some : in Boolean := False;
-      --  Is it allowed to return Last < Item'Last before end of data.
-
-   procedure Read
-     (Filter : in out Filter_Type;
-      Item   :    out Ada.Streams.Stream_Element_Array;
-      Last   :    out Ada.Streams.Stream_Element_Offset;
-      Flush  : in     Flush_Mode := No_Flush);
-   --  Compress/Decompress data from generic parameter procedure Read to the
-   --  Item. User should provide Buffer and initialized Rest_First, Rest_Last
-   --  indicators. If Allow_Read_Some is True, Read routines could return
-   --  Last < Item'Last only at end of stream.
-
-private
-
-   use Ada.Streams;
-
-   pragma Assert (Ada.Streams.Stream_Element'Size    =    8);
-   pragma Assert (Ada.Streams.Stream_Element'Modulus = 2**8);
-
-   type Flush_Mode is new Integer range 0 .. 5;
-
-   type Compression_Method is new Integer range 8 .. 8;
-
-   type Strategy_Type is new Integer range 0 .. 3;
-
-   No_Flush      : constant Flush_Mode := 0;
-   Partial_Flush : constant Flush_Mode := 1;
-   Sync_Flush    : constant Flush_Mode := 2;
-   Full_Flush    : constant Flush_Mode := 3;
-   Finish        : constant Flush_Mode := 4;
-   Block_Flush   : constant Flush_Mode := 5;
-
-   Filtered         : constant Strategy_Type := 1;
-   Huffman_Only     : constant Strategy_Type := 2;
-   RLE              : constant Strategy_Type := 3;
-   Default_Strategy : constant Strategy_Type := 0;
-
-   Deflated : constant Compression_Method := 8;
-
-   type Z_Stream;
-
-   type Z_Stream_Access is access all Z_Stream;
-
-   type Filter_Type is tagged limited record
-      Strm        : Z_Stream_Access;
-      Compression : Boolean;
-      Stream_End  : Boolean;
-      Header      : Header_Type;
-      CRC         : Unsigned_32;
-      Offset      : Stream_Element_Offset;
-      --  Offset for gzip header/footer output.
-   end record;
-
-end ZLib;
diff -Nbaur gcc-4.6.3/zlib/contrib/ada/zlib.gpr gcc-4.6.3-psp/zlib/contrib/ada/zlib.gpr
--- gcc-4.6.3/zlib/contrib/ada/zlib.gpr	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/ada/zlib.gpr	1970-01-01 01:00:00.000000000 +0100
@@ -1,20 +0,0 @@
-project Zlib is
-
-   for Languages use ("Ada");
-   for Source_Dirs use (".");
-   for Object_Dir use ".";
-   for Main use ("test.adb", "mtest.adb", "read.adb", "buffer_demo");
-
-   package Compiler is
-      for Default_Switches ("ada") use ("-gnatwcfilopru", "-gnatVcdfimorst", "-gnatyabcefhiklmnoprst");
-   end Compiler;
-
-   package Linker is
-      for Default_Switches ("ada") use ("-lz");
-   end Linker;
-
-   package Builder is
-      for Default_Switches ("ada") use ("-s", "-gnatQ");
-   end Builder;
-
-end Zlib;
diff -Nbaur gcc-4.6.3/zlib/contrib/ada/zlib-streams.adb gcc-4.6.3-psp/zlib/contrib/ada/zlib-streams.adb
--- gcc-4.6.3/zlib/contrib/ada/zlib-streams.adb	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/ada/zlib-streams.adb	1970-01-01 01:00:00.000000000 +0100
@@ -1,225 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: zlib-streams.adb,v 1.10 2004/05/31 10:53:40 vagul Exp $
-
-with Ada.Unchecked_Deallocation;
-
-package body ZLib.Streams is
-
-   -----------
-   -- Close --
-   -----------
-
-   procedure Close (Stream : in out Stream_Type) is
-      procedure Free is new Ada.Unchecked_Deallocation
-         (Stream_Element_Array, Buffer_Access);
-   begin
-      if Stream.Mode = Out_Stream or Stream.Mode = Duplex then
-         --  We should flush the data written by the writer.
-
-         Flush (Stream, Finish);
-
-         Close (Stream.Writer);
-      end if;
-
-      if Stream.Mode = In_Stream or Stream.Mode = Duplex then
-         Close (Stream.Reader);
-         Free (Stream.Buffer);
-      end if;
-   end Close;
-
-   ------------
-   -- Create --
-   ------------
-
-   procedure Create
-     (Stream            :    out Stream_Type;
-      Mode              : in     Stream_Mode;
-      Back              : in     Stream_Access;
-      Back_Compressed   : in     Boolean;
-      Level             : in     Compression_Level := Default_Compression;
-      Strategy          : in     Strategy_Type     := Default_Strategy;
-      Header            : in     Header_Type       := Default;
-      Read_Buffer_Size  : in     Ada.Streams.Stream_Element_Offset
-                                    := Default_Buffer_Size;
-      Write_Buffer_Size : in     Ada.Streams.Stream_Element_Offset
-                                    := Default_Buffer_Size)
-   is
-
-      subtype Buffer_Subtype is Stream_Element_Array (1 .. Read_Buffer_Size);
-
-      procedure Init_Filter
-         (Filter   : in out Filter_Type;
-          Compress : in     Boolean);
-
-      -----------------
-      -- Init_Filter --
-      -----------------
-
-      procedure Init_Filter
-         (Filter   : in out Filter_Type;
-          Compress : in     Boolean) is
-      begin
-         if Compress then
-            Deflate_Init
-              (Filter, Level, Strategy, Header => Header);
-         else
-            Inflate_Init (Filter, Header => Header);
-         end if;
-      end Init_Filter;
-
-   begin
-      Stream.Back := Back;
-      Stream.Mode := Mode;
-
-      if Mode = Out_Stream or Mode = Duplex then
-         Init_Filter (Stream.Writer, Back_Compressed);
-         Stream.Buffer_Size := Write_Buffer_Size;
-      else
-         Stream.Buffer_Size := 0;
-      end if;
-
-      if Mode = In_Stream or Mode = Duplex then
-         Init_Filter (Stream.Reader, not Back_Compressed);
-
-         Stream.Buffer     := new Buffer_Subtype;
-         Stream.Rest_First := Stream.Buffer'Last + 1;
-         Stream.Rest_Last  := Stream.Buffer'Last;
-      end if;
-   end Create;
-
-   -----------
-   -- Flush --
-   -----------
-
-   procedure Flush
-     (Stream : in out Stream_Type;
-      Mode   : in     Flush_Mode := Sync_Flush)
-   is
-      Buffer : Stream_Element_Array (1 .. Stream.Buffer_Size);
-      Last   : Stream_Element_Offset;
-   begin
-      loop
-         Flush (Stream.Writer, Buffer, Last, Mode);
-
-         Ada.Streams.Write (Stream.Back.all, Buffer (1 .. Last));
-
-         exit when Last < Buffer'Last;
-      end loop;
-   end Flush;
-
-   -------------
-   -- Is_Open --
-   -------------
-
-   function Is_Open (Stream : Stream_Type) return Boolean is
-   begin
-      return Is_Open (Stream.Reader) or else Is_Open (Stream.Writer);
-   end Is_Open;
-
-   ----------
-   -- Read --
-   ----------
-
-   procedure Read
-     (Stream : in out Stream_Type;
-      Item   :    out Stream_Element_Array;
-      Last   :    out Stream_Element_Offset)
-   is
-
-      procedure Read
-        (Item : out Stream_Element_Array;
-         Last : out Stream_Element_Offset);
-
-      ----------
-      -- Read --
-      ----------
-
-      procedure Read
-        (Item : out Stream_Element_Array;
-         Last : out Stream_Element_Offset) is
-      begin
-         Ada.Streams.Read (Stream.Back.all, Item, Last);
-      end Read;
-
-      procedure Read is new ZLib.Read
-         (Read       => Read,
-          Buffer     => Stream.Buffer.all,
-          Rest_First => Stream.Rest_First,
-          Rest_Last  => Stream.Rest_Last);
-
-   begin
-      Read (Stream.Reader, Item, Last);
-   end Read;
-
-   -------------------
-   -- Read_Total_In --
-   -------------------
-
-   function Read_Total_In (Stream : in Stream_Type) return Count is
-   begin
-      return Total_In (Stream.Reader);
-   end Read_Total_In;
-
-   --------------------
-   -- Read_Total_Out --
-   --------------------
-
-   function Read_Total_Out (Stream : in Stream_Type) return Count is
-   begin
-      return Total_Out (Stream.Reader);
-   end Read_Total_Out;
-
-   -----------
-   -- Write --
-   -----------
-
-   procedure Write
-     (Stream : in out Stream_Type;
-      Item   : in     Stream_Element_Array)
-   is
-
-      procedure Write (Item : in Stream_Element_Array);
-
-      -----------
-      -- Write --
-      -----------
-
-      procedure Write (Item : in Stream_Element_Array) is
-      begin
-         Ada.Streams.Write (Stream.Back.all, Item);
-      end Write;
-
-      procedure Write is new ZLib.Write
-         (Write       => Write,
-          Buffer_Size => Stream.Buffer_Size);
-
-   begin
-      Write (Stream.Writer, Item, No_Flush);
-   end Write;
-
-   --------------------
-   -- Write_Total_In --
-   --------------------
-
-   function Write_Total_In (Stream : in Stream_Type) return Count is
-   begin
-      return Total_In (Stream.Writer);
-   end Write_Total_In;
-
-   ---------------------
-   -- Write_Total_Out --
-   ---------------------
-
-   function Write_Total_Out (Stream : in Stream_Type) return Count is
-   begin
-      return Total_Out (Stream.Writer);
-   end Write_Total_Out;
-
-end ZLib.Streams;
diff -Nbaur gcc-4.6.3/zlib/contrib/ada/zlib-streams.ads gcc-4.6.3-psp/zlib/contrib/ada/zlib-streams.ads
--- gcc-4.6.3/zlib/contrib/ada/zlib-streams.ads	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/ada/zlib-streams.ads	1970-01-01 01:00:00.000000000 +0100
@@ -1,114 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: zlib-streams.ads,v 1.12 2004/05/31 10:53:40 vagul Exp $
-
-package ZLib.Streams is
-
-   type Stream_Mode is (In_Stream, Out_Stream, Duplex);
-
-   type Stream_Access is access all Ada.Streams.Root_Stream_Type'Class;
-
-   type Stream_Type is
-      new Ada.Streams.Root_Stream_Type with private;
-
-   procedure Read
-     (Stream : in out Stream_Type;
-      Item   :    out Ada.Streams.Stream_Element_Array;
-      Last   :    out Ada.Streams.Stream_Element_Offset);
-
-   procedure Write
-     (Stream : in out Stream_Type;
-      Item   : in     Ada.Streams.Stream_Element_Array);
-
-   procedure Flush
-     (Stream : in out Stream_Type;
-      Mode   : in     Flush_Mode := Sync_Flush);
-   --  Flush the written data to the back stream,
-   --  all data placed to the compressor is flushing to the Back stream.
-   --  Should not be used untill necessary, becouse it is decreasing
-   --  compression.
-
-   function Read_Total_In (Stream : in Stream_Type) return Count;
-   pragma Inline (Read_Total_In);
-   --  Return total number of bytes read from back stream so far.
-
-   function Read_Total_Out (Stream : in Stream_Type) return Count;
-   pragma Inline (Read_Total_Out);
-   --  Return total number of bytes read so far.
-
-   function Write_Total_In (Stream : in Stream_Type) return Count;
-   pragma Inline (Write_Total_In);
-   --  Return total number of bytes written so far.
-
-   function Write_Total_Out (Stream : in Stream_Type) return Count;
-   pragma Inline (Write_Total_Out);
-   --  Return total number of bytes written to the back stream.
-
-   procedure Create
-     (Stream            :    out Stream_Type;
-      Mode              : in     Stream_Mode;
-      Back              : in     Stream_Access;
-      Back_Compressed   : in     Boolean;
-      Level             : in     Compression_Level := Default_Compression;
-      Strategy          : in     Strategy_Type     := Default_Strategy;
-      Header            : in     Header_Type       := Default;
-      Read_Buffer_Size  : in     Ada.Streams.Stream_Element_Offset
-                                    := Default_Buffer_Size;
-      Write_Buffer_Size : in     Ada.Streams.Stream_Element_Offset
-                                    := Default_Buffer_Size);
-   --  Create the Comression/Decompression stream.
-   --  If mode is In_Stream then Write operation is disabled.
-   --  If mode is Out_Stream then Read operation is disabled.
-
-   --  If Back_Compressed is true then
-   --  Data written to the Stream is compressing to the Back stream
-   --  and data read from the Stream is decompressed data from the Back stream.
-
-   --  If Back_Compressed is false then
-   --  Data written to the Stream is decompressing to the Back stream
-   --  and data read from the Stream is compressed data from the Back stream.
-
-   --  !!! When the Need_Header is False ZLib-Ada is using undocumented
-   --  ZLib 1.1.4 functionality to do not create/wait for ZLib headers.
-
-   function Is_Open (Stream : Stream_Type) return Boolean;
-
-   procedure Close (Stream : in out Stream_Type);
-
-private
-
-   use Ada.Streams;
-
-   type Buffer_Access is access all Stream_Element_Array;
-
-   type Stream_Type
-     is new Root_Stream_Type with
-   record
-      Mode       : Stream_Mode;
-
-      Buffer     : Buffer_Access;
-      Rest_First : Stream_Element_Offset;
-      Rest_Last  : Stream_Element_Offset;
-      --  Buffer for Read operation.
-      --  We need to have this buffer in the record
-      --  becouse not all read data from back stream
-      --  could be processed during the read operation.
-
-      Buffer_Size : Stream_Element_Offset;
-      --  Buffer size for write operation.
-      --  We do not need to have this buffer
-      --  in the record becouse all data could be
-      --  processed in the write operation.
-
-      Back       : Stream_Access;
-      Reader     : Filter_Type;
-      Writer     : Filter_Type;
-   end record;
-
-end ZLib.Streams;
diff -Nbaur gcc-4.6.3/zlib/contrib/ada/zlib-thin.adb gcc-4.6.3-psp/zlib/contrib/ada/zlib-thin.adb
--- gcc-4.6.3/zlib/contrib/ada/zlib-thin.adb	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/ada/zlib-thin.adb	1970-01-01 01:00:00.000000000 +0100
@@ -1,141 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: zlib-thin.adb,v 1.8 2003/12/14 18:27:31 vagul Exp $
-
-package body ZLib.Thin is
-
-   ZLIB_VERSION  : constant Chars_Ptr := zlibVersion;
-
-   Z_Stream_Size : constant Int := Z_Stream'Size / System.Storage_Unit;
-
-   --------------
-   -- Avail_In --
-   --------------
-
-   function Avail_In (Strm : in Z_Stream) return UInt is
-   begin
-      return Strm.Avail_In;
-   end Avail_In;
-
-   ---------------
-   -- Avail_Out --
-   ---------------
-
-   function Avail_Out (Strm : in Z_Stream) return UInt is
-   begin
-      return Strm.Avail_Out;
-   end Avail_Out;
-
-   ------------------
-   -- Deflate_Init --
-   ------------------
-
-   function Deflate_Init
-     (strm       : Z_Streamp;
-      level      : Int;
-      method     : Int;
-      windowBits : Int;
-      memLevel   : Int;
-      strategy   : Int)
-      return       Int is
-   begin
-      return deflateInit2
-               (strm,
-                level,
-                method,
-                windowBits,
-                memLevel,
-                strategy,
-                ZLIB_VERSION,
-                Z_Stream_Size);
-   end Deflate_Init;
-
-   ------------------
-   -- Inflate_Init --
-   ------------------
-
-   function Inflate_Init (strm : Z_Streamp; windowBits : Int) return Int is
-   begin
-      return inflateInit2 (strm, windowBits, ZLIB_VERSION, Z_Stream_Size);
-   end Inflate_Init;
-
-   ------------------------
-   -- Last_Error_Message --
-   ------------------------
-
-   function Last_Error_Message (Strm : in Z_Stream) return String is
-      use Interfaces.C.Strings;
-   begin
-      if Strm.msg = Null_Ptr then
-         return "";
-      else
-         return Value (Strm.msg);
-      end if;
-   end Last_Error_Message;
-
-   ------------
-   -- Set_In --
-   ------------
-
-   procedure Set_In
-     (Strm   : in out Z_Stream;
-      Buffer : in     Voidp;
-      Size   : in     UInt) is
-   begin
-      Strm.Next_In  := Buffer;
-      Strm.Avail_In := Size;
-   end Set_In;
-
-   ------------------
-   -- Set_Mem_Func --
-   ------------------
-
-   procedure Set_Mem_Func
-     (Strm   : in out Z_Stream;
-      Opaque : in     Voidp;
-      Alloc  : in     alloc_func;
-      Free   : in     free_func) is
-   begin
-      Strm.opaque := Opaque;
-      Strm.zalloc := Alloc;
-      Strm.zfree  := Free;
-   end Set_Mem_Func;
-
-   -------------
-   -- Set_Out --
-   -------------
-
-   procedure Set_Out
-     (Strm   : in out Z_Stream;
-      Buffer : in     Voidp;
-      Size   : in     UInt) is
-   begin
-      Strm.Next_Out  := Buffer;
-      Strm.Avail_Out := Size;
-   end Set_Out;
-
-   --------------
-   -- Total_In --
-   --------------
-
-   function Total_In (Strm : in Z_Stream) return ULong is
-   begin
-      return Strm.Total_In;
-   end Total_In;
-
-   ---------------
-   -- Total_Out --
-   ---------------
-
-   function Total_Out (Strm : in Z_Stream) return ULong is
-   begin
-      return Strm.Total_Out;
-   end Total_Out;
-
-end ZLib.Thin;
diff -Nbaur gcc-4.6.3/zlib/contrib/ada/zlib-thin.ads gcc-4.6.3-psp/zlib/contrib/ada/zlib-thin.ads
--- gcc-4.6.3/zlib/contrib/ada/zlib-thin.ads	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/ada/zlib-thin.ads	1970-01-01 01:00:00.000000000 +0100
@@ -1,450 +0,0 @@
-----------------------------------------------------------------
---  ZLib for Ada thick binding.                               --
---                                                            --
---  Copyright (C) 2002-2003 Dmitriy Anisimkov                 --
---                                                            --
---  Open source license information is in the zlib.ads file.  --
-----------------------------------------------------------------
-
---  $Id: zlib-thin.ads,v 1.11 2004/07/23 06:33:11 vagul Exp $
-
-with Interfaces.C.Strings;
-
-with System;
-
-private package ZLib.Thin is
-
-   --  From zconf.h
-
-   MAX_MEM_LEVEL : constant := 9;         --  zconf.h:105
-                                          --  zconf.h:105
-   MAX_WBITS : constant := 15;      --  zconf.h:115
-                                    --  32K LZ77 window
-                                    --  zconf.h:115
-   SEEK_SET : constant := 8#0000#;  --  zconf.h:244
-                                    --  Seek from beginning of file.
-                                    --  zconf.h:244
-   SEEK_CUR : constant := 1;        --  zconf.h:245
-                                    --  Seek from current position.
-                                    --  zconf.h:245
-   SEEK_END : constant := 2;        --  zconf.h:246
-                                    --  Set file pointer to EOF plus "offset"
-                                    --  zconf.h:246
-
-   type Byte is new Interfaces.C.unsigned_char; --  8 bits
-                                                --  zconf.h:214
-   type UInt is new Interfaces.C.unsigned;      --  16 bits or more
-                                                --  zconf.h:216
-   type Int is new Interfaces.C.int;
-
-   type ULong is new Interfaces.C.unsigned_long;     --  32 bits or more
-                                                     --  zconf.h:217
-   subtype Chars_Ptr is Interfaces.C.Strings.chars_ptr;
-
-   type ULong_Access is access ULong;
-   type Int_Access is access Int;
-
-   subtype Voidp is System.Address;            --  zconf.h:232
-
-   subtype Byte_Access is Voidp;
-
-   Nul : constant Voidp := System.Null_Address;
-   --  end from zconf
-
-   Z_NO_FLUSH : constant := 8#0000#;   --  zlib.h:125
-                                       --  zlib.h:125
-   Z_PARTIAL_FLUSH : constant := 1;       --  zlib.h:126
-                                          --  will be removed, use
-                                          --  Z_SYNC_FLUSH instead
-                                          --  zlib.h:126
-   Z_SYNC_FLUSH : constant := 2;       --  zlib.h:127
-                                       --  zlib.h:127
-   Z_FULL_FLUSH : constant := 3;       --  zlib.h:128
-                                       --  zlib.h:128
-   Z_FINISH : constant := 4;        --  zlib.h:129
-                                    --  zlib.h:129
-   Z_OK : constant := 8#0000#;   --  zlib.h:132
-                                 --  zlib.h:132
-   Z_STREAM_END : constant := 1;       --  zlib.h:133
-                                       --  zlib.h:133
-   Z_NEED_DICT : constant := 2;        --  zlib.h:134
-                                       --  zlib.h:134
-   Z_ERRNO : constant := -1;        --  zlib.h:135
-                                    --  zlib.h:135
-   Z_STREAM_ERROR : constant := -2;       --  zlib.h:136
-                                          --  zlib.h:136
-   Z_DATA_ERROR : constant := -3;      --  zlib.h:137
-                                       --  zlib.h:137
-   Z_MEM_ERROR : constant := -4;       --  zlib.h:138
-                                       --  zlib.h:138
-   Z_BUF_ERROR : constant := -5;       --  zlib.h:139
-                                       --  zlib.h:139
-   Z_VERSION_ERROR : constant := -6;      --  zlib.h:140
-                                          --  zlib.h:140
-   Z_NO_COMPRESSION : constant := 8#0000#;   --  zlib.h:145
-                                             --  zlib.h:145
-   Z_BEST_SPEED : constant := 1;       --  zlib.h:146
-                                       --  zlib.h:146
-   Z_BEST_COMPRESSION : constant := 9;       --  zlib.h:147
-                                             --  zlib.h:147
-   Z_DEFAULT_COMPRESSION : constant := -1;      --  zlib.h:148
-                                                --  zlib.h:148
-   Z_FILTERED : constant := 1;      --  zlib.h:151
-                                    --  zlib.h:151
-   Z_HUFFMAN_ONLY : constant := 2;        --  zlib.h:152
-                                          --  zlib.h:152
-   Z_DEFAULT_STRATEGY : constant := 8#0000#; --  zlib.h:153
-                                             --  zlib.h:153
-   Z_BINARY : constant := 8#0000#;  --  zlib.h:156
-                                    --  zlib.h:156
-   Z_ASCII : constant := 1;      --  zlib.h:157
-                                 --  zlib.h:157
-   Z_UNKNOWN : constant := 2;       --  zlib.h:158
-                                    --  zlib.h:158
-   Z_DEFLATED : constant := 8;      --  zlib.h:161
-                                    --  zlib.h:161
-   Z_NULL : constant := 8#0000#; --  zlib.h:164
-                                 --  for initializing zalloc, zfree, opaque
-                                 --  zlib.h:164
-   type gzFile is new Voidp;                  --  zlib.h:646
-
-   type Z_Stream is private;
-
-   type Z_Streamp is access all Z_Stream;     --  zlib.h:89
-
-   type alloc_func is access function
-     (Opaque : Voidp;
-      Items  : UInt;
-      Size   : UInt)
-      return Voidp; --  zlib.h:63
-
-   type free_func is access procedure (opaque : Voidp; address : Voidp);
-
-   function zlibVersion return Chars_Ptr;
-
-   function Deflate (strm : Z_Streamp; flush : Int) return Int;
-
-   function DeflateEnd (strm : Z_Streamp) return Int;
-
-   function Inflate (strm : Z_Streamp; flush : Int) return Int;
-
-   function InflateEnd (strm : Z_Streamp) return Int;
-
-   function deflateSetDictionary
-     (strm       : Z_Streamp;
-      dictionary : Byte_Access;
-      dictLength : UInt)
-      return       Int;
-
-   function deflateCopy (dest : Z_Streamp; source : Z_Streamp) return Int;
-   --  zlib.h:478
-
-   function deflateReset (strm : Z_Streamp) return Int; -- zlib.h:495
-
-   function deflateParams
-     (strm     : Z_Streamp;
-      level    : Int;
-      strategy : Int)
-      return     Int;       -- zlib.h:506
-
-   function inflateSetDictionary
-     (strm       : Z_Streamp;
-      dictionary : Byte_Access;
-      dictLength : UInt)
-      return       Int; --  zlib.h:548
-
-   function inflateSync (strm : Z_Streamp) return Int;  --  zlib.h:565
-
-   function inflateReset (strm : Z_Streamp) return Int; --  zlib.h:580
-
-   function compress
-     (dest      : Byte_Access;
-      destLen   : ULong_Access;
-      source    : Byte_Access;
-      sourceLen : ULong)
-      return      Int;           -- zlib.h:601
-
-   function compress2
-     (dest      : Byte_Access;
-      destLen   : ULong_Access;
-      source    : Byte_Access;
-      sourceLen : ULong;
-      level     : Int)
-      return      Int;          -- zlib.h:615
-
-   function uncompress
-     (dest      : Byte_Access;
-      destLen   : ULong_Access;
-      source    : Byte_Access;
-      sourceLen : ULong)
-      return      Int;
-
-   function gzopen (path : Chars_Ptr; mode : Chars_Ptr) return gzFile;
-
-   function gzdopen (fd : Int; mode : Chars_Ptr) return gzFile;
-
-   function gzsetparams
-     (file     : gzFile;
-      level    : Int;
-      strategy : Int)
-      return     Int;
-
-   function gzread
-     (file : gzFile;
-      buf  : Voidp;
-      len  : UInt)
-      return Int;
-
-   function gzwrite
-     (file : in gzFile;
-      buf  : in Voidp;
-      len  : in UInt)
-      return Int;
-
-   function gzprintf (file : in gzFile; format : in Chars_Ptr) return Int;
-
-   function gzputs (file : in gzFile; s : in Chars_Ptr) return Int;
-
-   function gzgets
-     (file : gzFile;
-      buf  : Chars_Ptr;
-      len  : Int)
-      return Chars_Ptr;
-
-   function gzputc (file : gzFile; char : Int) return Int;
-
-   function gzgetc (file : gzFile) return Int;
-
-   function gzflush (file : gzFile; flush : Int) return Int;
-
-   function gzseek
-     (file   : gzFile;
-      offset : Int;
-      whence : Int)
-      return   Int;
-
-   function gzrewind (file : gzFile) return Int;
-
-   function gztell (file : gzFile) return Int;
-
-   function gzeof (file : gzFile) return Int;
-
-   function gzclose (file : gzFile) return Int;
-
-   function gzerror (file : gzFile; errnum : Int_Access) return Chars_Ptr;
-
-   function adler32
-     (adler : ULong;
-      buf   : Byte_Access;
-      len   : UInt)
-      return  ULong;
-
-   function crc32
-     (crc  : ULong;
-      buf  : Byte_Access;
-      len  : UInt)
-      return ULong;
-
-   function deflateInit
-     (strm        : Z_Streamp;
-      level       : Int;
-      version     : Chars_Ptr;
-      stream_size : Int)
-      return        Int;
-
-   function deflateInit2
-     (strm        : Z_Streamp;
-      level       : Int;
-      method      : Int;
-      windowBits  : Int;
-      memLevel    : Int;
-      strategy    : Int;
-      version     : Chars_Ptr;
-      stream_size : Int)
-      return        Int;
-
-   function Deflate_Init
-     (strm       : Z_Streamp;
-      level      : Int;
-      method     : Int;
-      windowBits : Int;
-      memLevel   : Int;
-      strategy   : Int)
-      return       Int;
-   pragma Inline (Deflate_Init);
-
-   function inflateInit
-     (strm        : Z_Streamp;
-      version     : Chars_Ptr;
-      stream_size : Int)
-      return        Int;
-
-   function inflateInit2
-     (strm        : in Z_Streamp;
-      windowBits  : in Int;
-      version     : in Chars_Ptr;
-      stream_size : in Int)
-      return      Int;
-
-   function inflateBackInit
-     (strm        : in Z_Streamp;
-      windowBits  : in Int;
-      window      : in Byte_Access;
-      version     : in Chars_Ptr;
-      stream_size : in Int)
-      return      Int;
-   --  Size of window have to be 2**windowBits.
-
-   function Inflate_Init (strm : Z_Streamp; windowBits : Int) return Int;
-   pragma Inline (Inflate_Init);
-
-   function zError (err : Int) return Chars_Ptr;
-
-   function inflateSyncPoint (z : Z_Streamp) return Int;
-
-   function get_crc_table return ULong_Access;
-
-   --  Interface to the available fields of the z_stream structure.
-   --  The application must update next_in and avail_in when avail_in has
-   --  dropped to zero. It must update next_out and avail_out when avail_out
-   --  has dropped to zero. The application must initialize zalloc, zfree and
-   --  opaque before calling the init function.
-
-   procedure Set_In
-     (Strm   : in out Z_Stream;
-      Buffer : in Voidp;
-      Size   : in UInt);
-   pragma Inline (Set_In);
-
-   procedure Set_Out
-     (Strm   : in out Z_Stream;
-      Buffer : in Voidp;
-      Size   : in UInt);
-   pragma Inline (Set_Out);
-
-   procedure Set_Mem_Func
-     (Strm   : in out Z_Stream;
-      Opaque : in Voidp;
-      Alloc  : in alloc_func;
-      Free   : in free_func);
-   pragma Inline (Set_Mem_Func);
-
-   function Last_Error_Message (Strm : in Z_Stream) return String;
-   pragma Inline (Last_Error_Message);
-
-   function Avail_Out (Strm : in Z_Stream) return UInt;
-   pragma Inline (Avail_Out);
-
-   function Avail_In (Strm : in Z_Stream) return UInt;
-   pragma Inline (Avail_In);
-
-   function Total_In (Strm : in Z_Stream) return ULong;
-   pragma Inline (Total_In);
-
-   function Total_Out (Strm : in Z_Stream) return ULong;
-   pragma Inline (Total_Out);
-
-   function inflateCopy
-     (dest   : in Z_Streamp;
-      Source : in Z_Streamp)
-      return Int;
-
-   function compressBound (Source_Len : in ULong) return ULong;
-
-   function deflateBound
-     (Strm       : in Z_Streamp;
-      Source_Len : in ULong)
-      return     ULong;
-
-   function gzungetc (C : in Int; File : in  gzFile) return Int;
-
-   function zlibCompileFlags return ULong;
-
-private
-
-   type Z_Stream is record            -- zlib.h:68
-      Next_In   : Voidp      := Nul;  -- next input byte
-      Avail_In  : UInt       := 0;    -- number of bytes available at next_in
-      Total_In  : ULong      := 0;    -- total nb of input bytes read so far
-      Next_Out  : Voidp      := Nul;  -- next output byte should be put there
-      Avail_Out : UInt       := 0;    -- remaining free space at next_out
-      Total_Out : ULong      := 0;    -- total nb of bytes output so far
-      msg       : Chars_Ptr;          -- last error message, NULL if no error
-      state     : Voidp;              -- not visible by applications
-      zalloc    : alloc_func := null; -- used to allocate the internal state
-      zfree     : free_func  := null; -- used to free the internal state
-      opaque    : Voidp;              -- private data object passed to
-                                      --  zalloc and zfree
-      data_type : Int;                -- best guess about the data type:
-                                      --  ascii or binary
-      adler     : ULong;              -- adler32 value of the uncompressed
-                                      --  data
-      reserved  : ULong;              -- reserved for future use
-   end record;
-
-   pragma Convention (C, Z_Stream);
-
-   pragma Import (C, zlibVersion, "zlibVersion");
-   pragma Import (C, Deflate, "deflate");
-   pragma Import (C, DeflateEnd, "deflateEnd");
-   pragma Import (C, Inflate, "inflate");
-   pragma Import (C, InflateEnd, "inflateEnd");
-   pragma Import (C, deflateSetDictionary, "deflateSetDictionary");
-   pragma Import (C, deflateCopy, "deflateCopy");
-   pragma Import (C, deflateReset, "deflateReset");
-   pragma Import (C, deflateParams, "deflateParams");
-   pragma Import (C, inflateSetDictionary, "inflateSetDictionary");
-   pragma Import (C, inflateSync, "inflateSync");
-   pragma Import (C, inflateReset, "inflateReset");
-   pragma Import (C, compress, "compress");
-   pragma Import (C, compress2, "compress2");
-   pragma Import (C, uncompress, "uncompress");
-   pragma Import (C, gzopen, "gzopen");
-   pragma Import (C, gzdopen, "gzdopen");
-   pragma Import (C, gzsetparams, "gzsetparams");
-   pragma Import (C, gzread, "gzread");
-   pragma Import (C, gzwrite, "gzwrite");
-   pragma Import (C, gzprintf, "gzprintf");
-   pragma Import (C, gzputs, "gzputs");
-   pragma Import (C, gzgets, "gzgets");
-   pragma Import (C, gzputc, "gzputc");
-   pragma Import (C, gzgetc, "gzgetc");
-   pragma Import (C, gzflush, "gzflush");
-   pragma Import (C, gzseek, "gzseek");
-   pragma Import (C, gzrewind, "gzrewind");
-   pragma Import (C, gztell, "gztell");
-   pragma Import (C, gzeof, "gzeof");
-   pragma Import (C, gzclose, "gzclose");
-   pragma Import (C, gzerror, "gzerror");
-   pragma Import (C, adler32, "adler32");
-   pragma Import (C, crc32, "crc32");
-   pragma Import (C, deflateInit, "deflateInit_");
-   pragma Import (C, inflateInit, "inflateInit_");
-   pragma Import (C, deflateInit2, "deflateInit2_");
-   pragma Import (C, inflateInit2, "inflateInit2_");
-   pragma Import (C, zError, "zError");
-   pragma Import (C, inflateSyncPoint, "inflateSyncPoint");
-   pragma Import (C, get_crc_table, "get_crc_table");
-
-   --  since zlib 1.2.0:
-
-   pragma Import (C, inflateCopy, "inflateCopy");
-   pragma Import (C, compressBound, "compressBound");
-   pragma Import (C, deflateBound, "deflateBound");
-   pragma Import (C, gzungetc, "gzungetc");
-   pragma Import (C, zlibCompileFlags, "zlibCompileFlags");
-
-   pragma Import (C, inflateBackInit, "inflateBackInit_");
-
-   --  I stopped binding the inflateBack routines, becouse realize that
-   --  it does not support zlib and gzip headers for now, and have no
-   --  symmetric deflateBack routines.
-   --  ZLib-Ada is symmetric regarding deflate/inflate data transformation
-   --  and has a similar generic callback interface for the
-   --  deflate/inflate transformation based on the regular Deflate/Inflate
-   --  routines.
-
-   --  pragma Import (C, inflateBack, "inflateBack");
-   --  pragma Import (C, inflateBackEnd, "inflateBackEnd");
-
-end ZLib.Thin;
diff -Nbaur gcc-4.6.3/zlib/contrib/asm586/match.S gcc-4.6.3-psp/zlib/contrib/asm586/match.S
--- gcc-4.6.3/zlib/contrib/asm586/match.S	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/asm586/match.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,364 +0,0 @@
-/* match.s -- Pentium-optimized version of longest_match()
- * Written for zlib 1.1.2
- * Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>
- *
- * This is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License.
- */
-
-#ifndef NO_UNDERLINE
-#define	match_init	_match_init
-#define	longest_match	_longest_match
-#endif
-
-#define	MAX_MATCH	(258)
-#define	MIN_MATCH	(3)
-#define	MIN_LOOKAHEAD	(MAX_MATCH + MIN_MATCH + 1)
-#define	MAX_MATCH_8	((MAX_MATCH + 7) & ~7)
-
-/* stack frame offsets */
-
-#define	wmask			0	/* local copy of s->wmask	*/
-#define	window			4	/* local copy of s->window	*/
-#define	windowbestlen		8	/* s->window + bestlen		*/
-#define	chainlenscanend		12	/* high word: current chain len	*/
-					/* low word: last bytes sought	*/
-#define	scanstart		16	/* first two bytes of string	*/
-#define	scanalign		20	/* dword-misalignment of string	*/
-#define	nicematch		24	/* a good enough match size	*/
-#define	bestlen			28	/* size of best match so far	*/
-#define	scan			32	/* ptr to string wanting match	*/
-
-#define	LocalVarsSize		(36)
-/*	saved ebx		36 */
-/*	saved edi		40 */
-/*	saved esi		44 */
-/*	saved ebp		48 */
-/*	return address		52 */
-#define	deflatestate		56	/* the function arguments	*/
-#define	curmatch		60
-
-/* Offsets for fields in the deflate_state structure. These numbers
- * are calculated from the definition of deflate_state, with the
- * assumption that the compiler will dword-align the fields. (Thus,
- * changing the definition of deflate_state could easily cause this
- * program to crash horribly, without so much as a warning at
- * compile time. Sigh.)
- */
-
-/* All the +zlib1222add offsets are due to the addition of fields
- *  in zlib in the deflate_state structure since the asm code was first written
- * (if you compile with zlib 1.0.4 or older, use "zlib1222add equ (-4)").
- * (if you compile with zlib between 1.0.5 and 1.2.2.1, use "zlib1222add equ 0").
- * if you compile with zlib 1.2.2.2 or later , use "zlib1222add equ 8").
- */
-
-#define zlib1222add		(8)
-
-#define	dsWSize			(36+zlib1222add)
-#define	dsWMask			(44+zlib1222add)
-#define	dsWindow		(48+zlib1222add)
-#define	dsPrev			(56+zlib1222add)
-#define	dsMatchLen		(88+zlib1222add)
-#define	dsPrevMatch		(92+zlib1222add)
-#define	dsStrStart		(100+zlib1222add)
-#define	dsMatchStart		(104+zlib1222add)
-#define	dsLookahead		(108+zlib1222add)
-#define	dsPrevLen		(112+zlib1222add)
-#define	dsMaxChainLen		(116+zlib1222add)
-#define	dsGoodMatch		(132+zlib1222add)
-#define	dsNiceMatch		(136+zlib1222add)
-
-
-.file "match.S"
-
-.globl	match_init, longest_match
-
-.text
-
-/* uInt longest_match(deflate_state *deflatestate, IPos curmatch) */
-
-longest_match:
-
-/* Save registers that the compiler may be using, and adjust %esp to	*/
-/* make room for our stack frame.					*/
-
-		pushl	%ebp
-		pushl	%edi
-		pushl	%esi
-		pushl	%ebx
-		subl	$LocalVarsSize, %esp
-
-/* Retrieve the function arguments. %ecx will hold cur_match		*/
-/* throughout the entire function. %edx will hold the pointer to the	*/
-/* deflate_state structure during the function's setup (before		*/
-/* entering the main loop).						*/
-
-		movl	deflatestate(%esp), %edx
-		movl	curmatch(%esp), %ecx
-
-/* if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;	*/
-
-		movl	dsNiceMatch(%edx), %eax
-		movl	dsLookahead(%edx), %ebx
-		cmpl	%eax, %ebx
-		jl	LookaheadLess
-		movl	%eax, %ebx
-LookaheadLess:	movl	%ebx, nicematch(%esp)
-
-/* register Bytef *scan = s->window + s->strstart;			*/
-
-		movl	dsWindow(%edx), %esi
-		movl	%esi, window(%esp)
-		movl	dsStrStart(%edx), %ebp
-		lea	(%esi,%ebp), %edi
-		movl	%edi, scan(%esp)
-
-/* Determine how many bytes the scan ptr is off from being		*/
-/* dword-aligned.							*/
-
-		movl	%edi, %eax
-		negl	%eax
-		andl	$3, %eax
-		movl	%eax, scanalign(%esp)
-
-/* IPos limit = s->strstart > (IPos)MAX_DIST(s) ?			*/
-/*     s->strstart - (IPos)MAX_DIST(s) : NIL;				*/
-
-		movl	dsWSize(%edx), %eax
-		subl	$MIN_LOOKAHEAD, %eax
-		subl	%eax, %ebp
-		jg	LimitPositive
-		xorl	%ebp, %ebp
-LimitPositive:
-
-/* unsigned chain_length = s->max_chain_length;				*/
-/* if (s->prev_length >= s->good_match) {				*/
-/*     chain_length >>= 2;						*/
-/* }									*/
-
-		movl	dsPrevLen(%edx), %eax
-		movl	dsGoodMatch(%edx), %ebx
-		cmpl	%ebx, %eax
-		movl	dsMaxChainLen(%edx), %ebx
-		jl	LastMatchGood
-		shrl	$2, %ebx
-LastMatchGood:
-
-/* chainlen is decremented once beforehand so that the function can	*/
-/* use the sign flag instead of the zero flag for the exit test.	*/
-/* It is then shifted into the high word, to make room for the scanend	*/
-/* scanend value, which it will always accompany.			*/
-
-		decl	%ebx
-		shll	$16, %ebx
-
-/* int best_len = s->prev_length;					*/
-
-		movl	dsPrevLen(%edx), %eax
-		movl	%eax, bestlen(%esp)
-
-/* Store the sum of s->window + best_len in %esi locally, and in %esi.	*/
-
-		addl	%eax, %esi
-		movl	%esi, windowbestlen(%esp)
-
-/* register ush scan_start = *(ushf*)scan;				*/
-/* register ush scan_end   = *(ushf*)(scan+best_len-1);			*/
-
-		movw	(%edi), %bx
-		movw	%bx, scanstart(%esp)
-		movw	-1(%edi,%eax), %bx
-		movl	%ebx, chainlenscanend(%esp)
-
-/* Posf *prev = s->prev;						*/
-/* uInt wmask = s->w_mask;						*/
-
-		movl	dsPrev(%edx), %edi
-		movl	dsWMask(%edx), %edx
-		mov	%edx, wmask(%esp)
-
-/* Jump into the main loop.						*/
-
-		jmp	LoopEntry
-
-.balign 16
-
-/* do {
- *     match = s->window + cur_match;
- *     if (*(ushf*)(match+best_len-1) != scan_end ||
- *         *(ushf*)match != scan_start) continue;
- *     [...]
- * } while ((cur_match = prev[cur_match & wmask]) > limit
- *          && --chain_length != 0);
- *
- * Here is the inner loop of the function. The function will spend the
- * majority of its time in this loop, and majority of that time will
- * be spent in the first ten instructions.
- *
- * Within this loop:
- * %ebx = chainlenscanend - i.e., ((chainlen << 16) | scanend)
- * %ecx = curmatch
- * %edx = curmatch & wmask
- * %esi = windowbestlen - i.e., (window + bestlen)
- * %edi = prev
- * %ebp = limit
- *
- * Two optimization notes on the choice of instructions:
- *
- * The first instruction uses a 16-bit address, which costs an extra,
- * unpairable cycle. This is cheaper than doing a 32-bit access and
- * zeroing the high word, due to the 3-cycle misalignment penalty which
- * would occur half the time. This also turns out to be cheaper than
- * doing two separate 8-bit accesses, as the memory is so rarely in the
- * L1 cache.
- *
- * The window buffer, however, apparently spends a lot of time in the
- * cache, and so it is faster to retrieve the word at the end of the
- * match string with two 8-bit loads. The instructions that test the
- * word at the beginning of the match string, however, are executed
- * much less frequently, and there it was cheaper to use 16-bit
- * instructions, which avoided the necessity of saving off and
- * subsequently reloading one of the other registers.
- */
-LookupLoop:
-							/* 1 U & V  */
-		movw	(%edi,%edx,2), %cx		/* 2 U pipe */
-		movl	wmask(%esp), %edx		/* 2 V pipe */
-		cmpl	%ebp, %ecx			/* 3 U pipe */
-		jbe	LeaveNow			/* 3 V pipe */
-		subl	$0x00010000, %ebx		/* 4 U pipe */
-		js	LeaveNow			/* 4 V pipe */
-LoopEntry:	movb	-1(%esi,%ecx), %al		/* 5 U pipe */
-		andl	%ecx, %edx			/* 5 V pipe */
-		cmpb	%bl, %al			/* 6 U pipe */
-		jnz	LookupLoop			/* 6 V pipe */
-		movb	(%esi,%ecx), %ah
-		cmpb	%bh, %ah
-		jnz	LookupLoop
-		movl	window(%esp), %eax
-		movw	(%eax,%ecx), %ax
-		cmpw	scanstart(%esp), %ax
-		jnz	LookupLoop
-
-/* Store the current value of chainlen.					*/
-
-		movl	%ebx, chainlenscanend(%esp)
-
-/* Point %edi to the string under scrutiny, and %esi to the string we	*/
-/* are hoping to match it up with. In actuality, %esi and %edi are	*/
-/* both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and %edx is	*/
-/* initialized to -(MAX_MATCH_8 - scanalign).				*/
-
-		movl	window(%esp), %esi
-		movl	scan(%esp), %edi
-		addl	%ecx, %esi
-		movl	scanalign(%esp), %eax
-		movl	$(-MAX_MATCH_8), %edx
-		lea	MAX_MATCH_8(%edi,%eax), %edi
-		lea	MAX_MATCH_8(%esi,%eax), %esi
-
-/* Test the strings for equality, 8 bytes at a time. At the end,
- * adjust %edx so that it is offset to the exact byte that mismatched.
- *
- * We already know at this point that the first three bytes of the
- * strings match each other, and they can be safely passed over before
- * starting the compare loop. So what this code does is skip over 0-3
- * bytes, as much as necessary in order to dword-align the %edi
- * pointer. (%esi will still be misaligned three times out of four.)
- *
- * It should be confessed that this loop usually does not represent
- * much of the total running time. Replacing it with a more
- * straightforward "rep cmpsb" would not drastically degrade
- * performance.
- */
-LoopCmps:
-		movl	(%esi,%edx), %eax
-		movl	(%edi,%edx), %ebx
-		xorl	%ebx, %eax
-		jnz	LeaveLoopCmps
-		movl	4(%esi,%edx), %eax
-		movl	4(%edi,%edx), %ebx
-		xorl	%ebx, %eax
-		jnz	LeaveLoopCmps4
-		addl	$8, %edx
-		jnz	LoopCmps
-		jmp	LenMaximum
-LeaveLoopCmps4:	addl	$4, %edx
-LeaveLoopCmps:	testl	$0x0000FFFF, %eax
-		jnz	LenLower
-		addl	$2, %edx
-		shrl	$16, %eax
-LenLower:	subb	$1, %al
-		adcl	$0, %edx
-
-/* Calculate the length of the match. If it is longer than MAX_MATCH,	*/
-/* then automatically accept it as the best possible match and leave.	*/
-
-		lea	(%edi,%edx), %eax
-		movl	scan(%esp), %edi
-		subl	%edi, %eax
-		cmpl	$MAX_MATCH, %eax
-		jge	LenMaximum
-
-/* If the length of the match is not longer than the best match we	*/
-/* have so far, then forget it and return to the lookup loop.		*/
-
-		movl	deflatestate(%esp), %edx
-		movl	bestlen(%esp), %ebx
-		cmpl	%ebx, %eax
-		jg	LongerMatch
-		movl	chainlenscanend(%esp), %ebx
-		movl	windowbestlen(%esp), %esi
-		movl	dsPrev(%edx), %edi
-		movl	wmask(%esp), %edx
-		andl	%ecx, %edx
-		jmp	LookupLoop
-
-/*         s->match_start = cur_match;					*/
-/*         best_len = len;						*/
-/*         if (len >= nice_match) break;				*/
-/*         scan_end = *(ushf*)(scan+best_len-1);			*/
-
-LongerMatch:	movl	nicematch(%esp), %ebx
-		movl	%eax, bestlen(%esp)
-		movl	%ecx, dsMatchStart(%edx)
-		cmpl	%ebx, %eax
-		jge	LeaveNow
-		movl	window(%esp), %esi
-		addl	%eax, %esi
-		movl	%esi, windowbestlen(%esp)
-		movl	chainlenscanend(%esp), %ebx
-		movw	-1(%edi,%eax), %bx
-		movl	dsPrev(%edx), %edi
-		movl	%ebx, chainlenscanend(%esp)
-		movl	wmask(%esp), %edx
-		andl	%ecx, %edx
-		jmp	LookupLoop
-
-/* Accept the current string, with the maximum possible length.		*/
-
-LenMaximum:	movl	deflatestate(%esp), %edx
-		movl	$MAX_MATCH, bestlen(%esp)
-		movl	%ecx, dsMatchStart(%edx)
-
-/* if ((uInt)best_len <= s->lookahead) return (uInt)best_len;		*/
-/* return s->lookahead;							*/
-
-LeaveNow:
-		movl	deflatestate(%esp), %edx
-		movl	bestlen(%esp), %ebx
-		movl	dsLookahead(%edx), %eax
-		cmpl	%eax, %ebx
-		jg	LookaheadRet
-		movl	%ebx, %eax
-LookaheadRet:
-
-/* Restore the stack and return from whence we came.			*/
-
-		addl	$LocalVarsSize, %esp
-		popl	%ebx
-		popl	%esi
-		popl	%edi
-		popl	%ebp
-match_init:	ret
diff -Nbaur gcc-4.6.3/zlib/contrib/asm586/README.586 gcc-4.6.3-psp/zlib/contrib/asm586/README.586
--- gcc-4.6.3/zlib/contrib/asm586/README.586	2004-10-11 18:35:40.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/asm586/README.586	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-This is a patched version of zlib modified to use
-Pentium-optimized assembly code in the deflation algorithm. The files
-changed/added by this patch are:
-
-README.586
-match.S
-
-The effectiveness of these modifications is a bit marginal, as the the
-program's bottleneck seems to be mostly L1-cache contention, for which
-there is no real way to work around without rewriting the basic
-algorithm. The speedup on average is around 5-10% (which is generally
-less than the amount of variance between subsequent executions).
-However, when used at level 9 compression, the cache contention can
-drop enough for the assembly version to achieve 10-20% speedup (and
-sometimes more, depending on the amount of overall redundancy in the
-files). Even here, though, cache contention can still be the limiting
-factor, depending on the nature of the program using the zlib library.
-This may also mean that better improvements will be seen on a Pentium
-with MMX, which suffers much less from L1-cache contention, but I have
-not yet verified this.
-
-Note that this code has been tailored for the Pentium in particular,
-and will not perform well on the Pentium Pro (due to the use of a
-partial register in the inner loop).
-
-If you are using an assembler other than GNU as, you will have to
-translate match.S to use your assembler's syntax. (Have fun.)
-
-Brian Raiter
-breadbox@muppetlabs.com
-April, 1998
-
-
-Added for zlib 1.1.3:
-
-The patches come from
-http://www.muppetlabs.com/~breadbox/software/assembly.html
-
-To compile zlib with this asm file, copy match.S to the zlib directory
-then do:
-
-CFLAGS="-O3 -DASMV" ./configure
-make OBJA=match.o
diff -Nbaur gcc-4.6.3/zlib/contrib/asm686/match.S gcc-4.6.3-psp/zlib/contrib/asm686/match.S
--- gcc-4.6.3/zlib/contrib/asm686/match.S	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/asm686/match.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,329 +0,0 @@
-/* match.s -- Pentium-Pro-optimized version of longest_match()
- * Written for zlib 1.1.2
- * Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>
- *
- * This is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License.
- */
-
-#ifndef NO_UNDERLINE
-#define	match_init	_match_init
-#define	longest_match	_longest_match
-#endif
-
-#define	MAX_MATCH	(258)
-#define	MIN_MATCH	(3)
-#define	MIN_LOOKAHEAD	(MAX_MATCH + MIN_MATCH + 1)
-#define	MAX_MATCH_8	((MAX_MATCH + 7) & ~7)
-
-/* stack frame offsets */
-
-#define	chainlenwmask		0	/* high word: current chain len	*/
-					/* low word: s->wmask		*/
-#define	window			4	/* local copy of s->window	*/
-#define	windowbestlen		8	/* s->window + bestlen		*/
-#define	scanstart		16	/* first two bytes of string	*/
-#define	scanend			12	/* last two bytes of string	*/
-#define	scanalign		20	/* dword-misalignment of string	*/
-#define	nicematch		24	/* a good enough match size	*/
-#define	bestlen			28	/* size of best match so far	*/
-#define	scan			32	/* ptr to string wanting match	*/
-
-#define	LocalVarsSize		(36)
-/*	saved ebx		36 */
-/*	saved edi		40 */
-/*	saved esi		44 */
-/*	saved ebp		48 */
-/*	return address		52 */
-#define	deflatestate		56	/* the function arguments	*/
-#define	curmatch		60
-
-/* All the +zlib1222add offsets are due to the addition of fields
- *  in zlib in the deflate_state structure since the asm code was first written
- * (if you compile with zlib 1.0.4 or older, use "zlib1222add equ (-4)").
- * (if you compile with zlib between 1.0.5 and 1.2.2.1, use "zlib1222add equ 0").
- * if you compile with zlib 1.2.2.2 or later , use "zlib1222add equ 8").
- */
-
-#define zlib1222add		(8)
-
-#define	dsWSize			(36+zlib1222add)
-#define	dsWMask			(44+zlib1222add)
-#define	dsWindow		(48+zlib1222add)
-#define	dsPrev			(56+zlib1222add)
-#define	dsMatchLen		(88+zlib1222add)
-#define	dsPrevMatch		(92+zlib1222add)
-#define	dsStrStart		(100+zlib1222add)
-#define	dsMatchStart		(104+zlib1222add)
-#define	dsLookahead		(108+zlib1222add)
-#define	dsPrevLen		(112+zlib1222add)
-#define	dsMaxChainLen		(116+zlib1222add)
-#define	dsGoodMatch		(132+zlib1222add)
-#define	dsNiceMatch		(136+zlib1222add)
-
-
-.file "match.S"
-
-.globl	match_init, longest_match
-
-.text
-
-/* uInt longest_match(deflate_state *deflatestate, IPos curmatch) */
-
-longest_match:
-
-/* Save registers that the compiler may be using, and adjust %esp to	*/
-/* make room for our stack frame.					*/
-
-		pushl	%ebp
-		pushl	%edi
-		pushl	%esi
-		pushl	%ebx
-		subl	$LocalVarsSize, %esp
-
-/* Retrieve the function arguments. %ecx will hold cur_match		*/
-/* throughout the entire function. %edx will hold the pointer to the	*/
-/* deflate_state structure during the function's setup (before		*/
-/* entering the main loop).						*/
-
-		movl	deflatestate(%esp), %edx
-		movl	curmatch(%esp), %ecx
-
-/* uInt wmask = s->w_mask;						*/
-/* unsigned chain_length = s->max_chain_length;				*/
-/* if (s->prev_length >= s->good_match) {				*/
-/*     chain_length >>= 2;						*/
-/* }									*/
-
-		movl	dsPrevLen(%edx), %eax
-		movl	dsGoodMatch(%edx), %ebx
-		cmpl	%ebx, %eax
-		movl	dsWMask(%edx), %eax
-		movl	dsMaxChainLen(%edx), %ebx
-		jl	LastMatchGood
-		shrl	$2, %ebx
-LastMatchGood:
-
-/* chainlen is decremented once beforehand so that the function can	*/
-/* use the sign flag instead of the zero flag for the exit test.	*/
-/* It is then shifted into the high word, to make room for the wmask	*/
-/* value, which it will always accompany.				*/
-
-		decl	%ebx
-		shll	$16, %ebx
-		orl	%eax, %ebx
-		movl	%ebx, chainlenwmask(%esp)
-
-/* if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;	*/
-
-		movl	dsNiceMatch(%edx), %eax
-		movl	dsLookahead(%edx), %ebx
-		cmpl	%eax, %ebx
-		jl	LookaheadLess
-		movl	%eax, %ebx
-LookaheadLess:	movl	%ebx, nicematch(%esp)
-
-/* register Bytef *scan = s->window + s->strstart;			*/
-
-		movl	dsWindow(%edx), %esi
-		movl	%esi, window(%esp)
-		movl	dsStrStart(%edx), %ebp
-		lea	(%esi,%ebp), %edi
-		movl	%edi, scan(%esp)
-
-/* Determine how many bytes the scan ptr is off from being		*/
-/* dword-aligned.							*/
-
-		movl	%edi, %eax
-		negl	%eax
-		andl	$3, %eax
-		movl	%eax, scanalign(%esp)
-
-/* IPos limit = s->strstart > (IPos)MAX_DIST(s) ?			*/
-/*     s->strstart - (IPos)MAX_DIST(s) : NIL;				*/
-
-		movl	dsWSize(%edx), %eax
-		subl	$MIN_LOOKAHEAD, %eax
-		subl	%eax, %ebp
-		jg	LimitPositive
-		xorl	%ebp, %ebp
-LimitPositive:
-
-/* int best_len = s->prev_length;					*/
-
-		movl	dsPrevLen(%edx), %eax
-		movl	%eax, bestlen(%esp)
-
-/* Store the sum of s->window + best_len in %esi locally, and in %esi.	*/
-
-		addl	%eax, %esi
-		movl	%esi, windowbestlen(%esp)
-
-/* register ush scan_start = *(ushf*)scan;				*/
-/* register ush scan_end   = *(ushf*)(scan+best_len-1);			*/
-/* Posf *prev = s->prev;						*/
-
-		movzwl	(%edi), %ebx
-		movl	%ebx, scanstart(%esp)
-		movzwl	-1(%edi,%eax), %ebx
-		movl	%ebx, scanend(%esp)
-		movl	dsPrev(%edx), %edi
-
-/* Jump into the main loop.						*/
-
-		movl	chainlenwmask(%esp), %edx
-		jmp	LoopEntry
-
-.balign 16
-
-/* do {
- *     match = s->window + cur_match;
- *     if (*(ushf*)(match+best_len-1) != scan_end ||
- *         *(ushf*)match != scan_start) continue;
- *     [...]
- * } while ((cur_match = prev[cur_match & wmask]) > limit
- *          && --chain_length != 0);
- *
- * Here is the inner loop of the function. The function will spend the
- * majority of its time in this loop, and majority of that time will
- * be spent in the first ten instructions.
- *
- * Within this loop:
- * %ebx = scanend
- * %ecx = curmatch
- * %edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)
- * %esi = windowbestlen - i.e., (window + bestlen)
- * %edi = prev
- * %ebp = limit
- */
-LookupLoop:
-		andl	%edx, %ecx
-		movzwl	(%edi,%ecx,2), %ecx
-		cmpl	%ebp, %ecx
-		jbe	LeaveNow
-		subl	$0x00010000, %edx
-		js	LeaveNow
-LoopEntry:	movzwl	-1(%esi,%ecx), %eax
-		cmpl	%ebx, %eax
-		jnz	LookupLoop
-		movl	window(%esp), %eax
-		movzwl	(%eax,%ecx), %eax
-		cmpl	scanstart(%esp), %eax
-		jnz	LookupLoop
-
-/* Store the current value of chainlen.					*/
-
-		movl	%edx, chainlenwmask(%esp)
-
-/* Point %edi to the string under scrutiny, and %esi to the string we	*/
-/* are hoping to match it up with. In actuality, %esi and %edi are	*/
-/* both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and %edx is	*/
-/* initialized to -(MAX_MATCH_8 - scanalign).				*/
-
-		movl	window(%esp), %esi
-		movl	scan(%esp), %edi
-		addl	%ecx, %esi
-		movl	scanalign(%esp), %eax
-		movl	$(-MAX_MATCH_8), %edx
-		lea	MAX_MATCH_8(%edi,%eax), %edi
-		lea	MAX_MATCH_8(%esi,%eax), %esi
-
-/* Test the strings for equality, 8 bytes at a time. At the end,
- * adjust %edx so that it is offset to the exact byte that mismatched.
- *
- * We already know at this point that the first three bytes of the
- * strings match each other, and they can be safely passed over before
- * starting the compare loop. So what this code does is skip over 0-3
- * bytes, as much as necessary in order to dword-align the %edi
- * pointer. (%esi will still be misaligned three times out of four.)
- *
- * It should be confessed that this loop usually does not represent
- * much of the total running time. Replacing it with a more
- * straightforward "rep cmpsb" would not drastically degrade
- * performance.
- */
-LoopCmps:
-		movl	(%esi,%edx), %eax
-		xorl	(%edi,%edx), %eax
-		jnz	LeaveLoopCmps
-		movl	4(%esi,%edx), %eax
-		xorl	4(%edi,%edx), %eax
-		jnz	LeaveLoopCmps4
-		addl	$8, %edx
-		jnz	LoopCmps
-		jmp	LenMaximum
-LeaveLoopCmps4:	addl	$4, %edx
-LeaveLoopCmps:	testl	$0x0000FFFF, %eax
-		jnz	LenLower
-		addl	$2, %edx
-		shrl	$16, %eax
-LenLower:	subb	$1, %al
-		adcl	$0, %edx
-
-/* Calculate the length of the match. If it is longer than MAX_MATCH,	*/
-/* then automatically accept it as the best possible match and leave.	*/
-
-		lea	(%edi,%edx), %eax
-		movl	scan(%esp), %edi
-		subl	%edi, %eax
-		cmpl	$MAX_MATCH, %eax
-		jge	LenMaximum
-
-/* If the length of the match is not longer than the best match we	*/
-/* have so far, then forget it and return to the lookup loop.		*/
-
-		movl	deflatestate(%esp), %edx
-		movl	bestlen(%esp), %ebx
-		cmpl	%ebx, %eax
-		jg	LongerMatch
-		movl	windowbestlen(%esp), %esi
-		movl	dsPrev(%edx), %edi
-		movl	scanend(%esp), %ebx
-		movl	chainlenwmask(%esp), %edx
-		jmp	LookupLoop
-
-/*         s->match_start = cur_match;					*/
-/*         best_len = len;						*/
-/*         if (len >= nice_match) break;				*/
-/*         scan_end = *(ushf*)(scan+best_len-1);			*/
-
-LongerMatch:	movl	nicematch(%esp), %ebx
-		movl	%eax, bestlen(%esp)
-		movl	%ecx, dsMatchStart(%edx)
-		cmpl	%ebx, %eax
-		jge	LeaveNow
-		movl	window(%esp), %esi
-		addl	%eax, %esi
-		movl	%esi, windowbestlen(%esp)
-		movzwl	-1(%edi,%eax), %ebx
-		movl	dsPrev(%edx), %edi
-		movl	%ebx, scanend(%esp)
-		movl	chainlenwmask(%esp), %edx
-		jmp	LookupLoop
-
-/* Accept the current string, with the maximum possible length.		*/
-
-LenMaximum:	movl	deflatestate(%esp), %edx
-		movl	$MAX_MATCH, bestlen(%esp)
-		movl	%ecx, dsMatchStart(%edx)
-
-/* if ((uInt)best_len <= s->lookahead) return (uInt)best_len;		*/
-/* return s->lookahead;							*/
-
-LeaveNow:
-		movl	deflatestate(%esp), %edx
-		movl	bestlen(%esp), %ebx
-		movl	dsLookahead(%edx), %eax
-		cmpl	%eax, %ebx
-		jg	LookaheadRet
-		movl	%ebx, %eax
-LookaheadRet:
-
-/* Restore the stack and return from whence we came.			*/
-
-		addl	$LocalVarsSize, %esp
-		popl	%ebx
-		popl	%esi
-		popl	%edi
-		popl	%ebp
-match_init:	ret
diff -Nbaur gcc-4.6.3/zlib/contrib/asm686/README.686 gcc-4.6.3-psp/zlib/contrib/asm686/README.686
--- gcc-4.6.3/zlib/contrib/asm686/README.686	2004-10-11 18:35:40.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/asm686/README.686	1970-01-01 01:00:00.000000000 +0100
@@ -1,34 +0,0 @@
-This is a patched version of zlib, modified to use
-Pentium-Pro-optimized assembly code in the deflation algorithm. The
-files changed/added by this patch are:
-
-README.686
-match.S
-
-The speedup that this patch provides varies, depending on whether the
-compiler used to build the original version of zlib falls afoul of the
-PPro's speed traps. My own tests show a speedup of around 10-20% at
-the default compression level, and 20-30% using -9, against a version
-compiled using gcc 2.7.2.3. Your mileage may vary.
-
-Note that this code has been tailored for the PPro/PII in particular,
-and will not perform particuarly well on a Pentium.
-
-If you are using an assembler other than GNU as, you will have to
-translate match.S to use your assembler's syntax. (Have fun.)
-
-Brian Raiter
-breadbox@muppetlabs.com
-April, 1998
-
-
-Added for zlib 1.1.3:
-
-The patches come from
-http://www.muppetlabs.com/~breadbox/software/assembly.html
-
-To compile zlib with this asm file, copy match.S to the zlib directory
-then do:
-
-CFLAGS="-O3 -DASMV" ./configure
-make OBJA=match.o
diff -Nbaur gcc-4.6.3/zlib/contrib/blast/blast.c gcc-4.6.3-psp/zlib/contrib/blast/blast.c
--- gcc-4.6.3/zlib/contrib/blast/blast.c	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/blast/blast.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,444 +0,0 @@
-/* blast.c
- * Copyright (C) 2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in blast.h
- * version 1.1, 16 Feb 2003
- *
- * blast.c decompresses data compressed by the PKWare Compression Library.
- * This function provides functionality similar to the explode() function of
- * the PKWare library, hence the name "blast".
- *
- * This decompressor is based on the excellent format description provided by
- * Ben Rudiak-Gould in comp.compression on August 13, 2001.  Interestingly, the
- * example Ben provided in the post is incorrect.  The distance 110001 should
- * instead be 111000.  When corrected, the example byte stream becomes:
- *
- *    00 04 82 24 25 8f 80 7f
- *
- * which decompresses to "AIAIAIAIAIAIA" (without the quotes).
- */
-
-/*
- * Change history:
- *
- * 1.0  12 Feb 2003     - First version
- * 1.1  16 Feb 2003     - Fixed distance check for > 4 GB uncompressed data
- */
-
-#include <setjmp.h>             /* for setjmp(), longjmp(), and jmp_buf */
-#include "blast.h"              /* prototype for blast() */
-
-#define local static            /* for local function definitions */
-#define MAXBITS 13              /* maximum code length */
-#define MAXWIN 4096             /* maximum window size */
-
-/* input and output state */
-struct state {
-    /* input state */
-    blast_in infun;             /* input function provided by user */
-    void *inhow;                /* opaque information passed to infun() */
-    unsigned char *in;          /* next input location */
-    unsigned left;              /* available input at in */
-    int bitbuf;                 /* bit buffer */
-    int bitcnt;                 /* number of bits in bit buffer */
-
-    /* input limit error return state for bits() and decode() */
-    jmp_buf env;
-
-    /* output state */
-    blast_out outfun;           /* output function provided by user */
-    void *outhow;               /* opaque information passed to outfun() */
-    unsigned next;              /* index of next write location in out[] */
-    int first;                  /* true to check distances (for first 4K) */
-    unsigned char out[MAXWIN];  /* output buffer and sliding window */
-};
-
-/*
- * Return need bits from the input stream.  This always leaves less than
- * eight bits in the buffer.  bits() works properly for need == 0.
- *
- * Format notes:
- *
- * - Bits are stored in bytes from the least significant bit to the most
- *   significant bit.  Therefore bits are dropped from the bottom of the bit
- *   buffer, using shift right, and new bytes are appended to the top of the
- *   bit buffer, using shift left.
- */
-local int bits(struct state *s, int need)
-{
-    int val;            /* bit accumulator */
-
-    /* load at least need bits into val */
-    val = s->bitbuf;
-    while (s->bitcnt < need) {
-        if (s->left == 0) {
-            s->left = s->infun(s->inhow, &(s->in));
-            if (s->left == 0) longjmp(s->env, 1);       /* out of input */
-        }
-        val |= (int)(*(s->in)++) << s->bitcnt;          /* load eight bits */
-        s->left--;
-        s->bitcnt += 8;
-    }
-
-    /* drop need bits and update buffer, always zero to seven bits left */
-    s->bitbuf = val >> need;
-    s->bitcnt -= need;
-
-    /* return need bits, zeroing the bits above that */
-    return val & ((1 << need) - 1);
-}
-
-/*
- * Huffman code decoding tables.  count[1..MAXBITS] is the number of symbols of
- * each length, which for a canonical code are stepped through in order.
- * symbol[] are the symbol values in canonical order, where the number of
- * entries is the sum of the counts in count[].  The decoding process can be
- * seen in the function decode() below.
- */
-struct huffman {
-    short *count;       /* number of symbols of each length */
-    short *symbol;      /* canonically ordered symbols */
-};
-
-/*
- * Decode a code from the stream s using huffman table h.  Return the symbol or
- * a negative value if there is an error.  If all of the lengths are zero, i.e.
- * an empty code, or if the code is incomplete and an invalid code is received,
- * then -9 is returned after reading MAXBITS bits.
- *
- * Format notes:
- *
- * - The codes as stored in the compressed data are bit-reversed relative to
- *   a simple integer ordering of codes of the same lengths.  Hence below the
- *   bits are pulled from the compressed data one at a time and used to
- *   build the code value reversed from what is in the stream in order to
- *   permit simple integer comparisons for decoding.
- *
- * - The first code for the shortest length is all ones.  Subsequent codes of
- *   the same length are simply integer decrements of the previous code.  When
- *   moving up a length, a one bit is appended to the code.  For a complete
- *   code, the last code of the longest length will be all zeros.  To support
- *   this ordering, the bits pulled during decoding are inverted to apply the
- *   more "natural" ordering starting with all zeros and incrementing.
- */
-local int decode(struct state *s, struct huffman *h)
-{
-    int len;            /* current number of bits in code */
-    int code;           /* len bits being decoded */
-    int first;          /* first code of length len */
-    int count;          /* number of codes of length len */
-    int index;          /* index of first code of length len in symbol table */
-    int bitbuf;         /* bits from stream */
-    int left;           /* bits left in next or left to process */
-    short *next;        /* next number of codes */
-
-    bitbuf = s->bitbuf;
-    left = s->bitcnt;
-    code = first = index = 0;
-    len = 1;
-    next = h->count + 1;
-    while (1) {
-        while (left--) {
-            code |= (bitbuf & 1) ^ 1;   /* invert code */
-            bitbuf >>= 1;
-            count = *next++;
-            if (code < first + count) { /* if length len, return symbol */
-                s->bitbuf = bitbuf;
-                s->bitcnt = (s->bitcnt - len) & 7;
-                return h->symbol[index + (code - first)];
-            }
-            index += count;             /* else update for next length */
-            first += count;
-            first <<= 1;
-            code <<= 1;
-            len++;
-        }
-        left = (MAXBITS+1) - len;
-        if (left == 0) break;
-        if (s->left == 0) {
-            s->left = s->infun(s->inhow, &(s->in));
-            if (s->left == 0) longjmp(s->env, 1);       /* out of input */
-        }
-        bitbuf = *(s->in)++;
-        s->left--;
-        if (left > 8) left = 8;
-    }
-    return -9;                          /* ran out of codes */
-}
-
-/*
- * Given a list of repeated code lengths rep[0..n-1], where each byte is a
- * count (high four bits + 1) and a code length (low four bits), generate the
- * list of code lengths.  This compaction reduces the size of the object code.
- * Then given the list of code lengths length[0..n-1] representing a canonical
- * Huffman code for n symbols, construct the tables required to decode those
- * codes.  Those tables are the number of codes of each length, and the symbols
- * sorted by length, retaining their original order within each length.  The
- * return value is zero for a complete code set, negative for an over-
- * subscribed code set, and positive for an incomplete code set.  The tables
- * can be used if the return value is zero or positive, but they cannot be used
- * if the return value is negative.  If the return value is zero, it is not
- * possible for decode() using that table to return an error--any stream of
- * enough bits will resolve to a symbol.  If the return value is positive, then
- * it is possible for decode() using that table to return an error for received
- * codes past the end of the incomplete lengths.
- */
-local int construct(struct huffman *h, const unsigned char *rep, int n)
-{
-    int symbol;         /* current symbol when stepping through length[] */
-    int len;            /* current length when stepping through h->count[] */
-    int left;           /* number of possible codes left of current length */
-    short offs[MAXBITS+1];      /* offsets in symbol table for each length */
-    short length[256];  /* code lengths */
-
-    /* convert compact repeat counts into symbol bit length list */
-    symbol = 0;
-    do {
-        len = *rep++;
-        left = (len >> 4) + 1;
-        len &= 15;
-        do {
-            length[symbol++] = len;
-        } while (--left);
-    } while (--n);
-    n = symbol;
-
-    /* count number of codes of each length */
-    for (len = 0; len <= MAXBITS; len++)
-        h->count[len] = 0;
-    for (symbol = 0; symbol < n; symbol++)
-        (h->count[length[symbol]])++;   /* assumes lengths are within bounds */
-    if (h->count[0] == n)               /* no codes! */
-        return 0;                       /* complete, but decode() will fail */
-
-    /* check for an over-subscribed or incomplete set of lengths */
-    left = 1;                           /* one possible code of zero length */
-    for (len = 1; len <= MAXBITS; len++) {
-        left <<= 1;                     /* one more bit, double codes left */
-        left -= h->count[len];          /* deduct count from possible codes */
-        if (left < 0) return left;      /* over-subscribed--return negative */
-    }                                   /* left > 0 means incomplete */
-
-    /* generate offsets into symbol table for each length for sorting */
-    offs[1] = 0;
-    for (len = 1; len < MAXBITS; len++)
-        offs[len + 1] = offs[len] + h->count[len];
-
-    /*
-     * put symbols in table sorted by length, by symbol order within each
-     * length
-     */
-    for (symbol = 0; symbol < n; symbol++)
-        if (length[symbol] != 0)
-            h->symbol[offs[length[symbol]]++] = symbol;
-
-    /* return zero for complete set, positive for incomplete set */
-    return left;
-}
-
-/*
- * Decode PKWare Compression Library stream.
- *
- * Format notes:
- *
- * - First byte is 0 if literals are uncoded or 1 if they are coded.  Second
- *   byte is 4, 5, or 6 for the number of extra bits in the distance code.
- *   This is the base-2 logarithm of the dictionary size minus six.
- *
- * - Compressed data is a combination of literals and length/distance pairs
- *   terminated by an end code.  Literals are either Huffman coded or
- *   uncoded bytes.  A length/distance pair is a coded length followed by a
- *   coded distance to represent a string that occurs earlier in the
- *   uncompressed data that occurs again at the current location.
- *
- * - A bit preceding a literal or length/distance pair indicates which comes
- *   next, 0 for literals, 1 for length/distance.
- *
- * - If literals are uncoded, then the next eight bits are the literal, in the
- *   normal bit order in th stream, i.e. no bit-reversal is needed. Similarly,
- *   no bit reversal is needed for either the length extra bits or the distance
- *   extra bits.
- *
- * - Literal bytes are simply written to the output.  A length/distance pair is
- *   an instruction to copy previously uncompressed bytes to the output.  The
- *   copy is from distance bytes back in the output stream, copying for length
- *   bytes.
- *
- * - Distances pointing before the beginning of the output data are not
- *   permitted.
- *
- * - Overlapped copies, where the length is greater than the distance, are
- *   allowed and common.  For example, a distance of one and a length of 518
- *   simply copies the last byte 518 times.  A distance of four and a length of
- *   twelve copies the last four bytes three times.  A simple forward copy
- *   ignoring whether the length is greater than the distance or not implements
- *   this correctly.
- */
-local int decomp(struct state *s)
-{
-    int lit;            /* true if literals are coded */
-    int dict;           /* log2(dictionary size) - 6 */
-    int symbol;         /* decoded symbol, extra bits for distance */
-    int len;            /* length for copy */
-    int dist;           /* distance for copy */
-    int copy;           /* copy counter */
-    unsigned char *from, *to;   /* copy pointers */
-    static int virgin = 1;                              /* build tables once */
-    static short litcnt[MAXBITS+1], litsym[256];        /* litcode memory */
-    static short lencnt[MAXBITS+1], lensym[16];         /* lencode memory */
-    static short distcnt[MAXBITS+1], distsym[64];       /* distcode memory */
-    static struct huffman litcode = {litcnt, litsym};   /* length code */
-    static struct huffman lencode = {lencnt, lensym};   /* length code */
-    static struct huffman distcode = {distcnt, distsym};/* distance code */
-        /* bit lengths of literal codes */
-    static const unsigned char litlen[] = {
-        11, 124, 8, 7, 28, 7, 188, 13, 76, 4, 10, 8, 12, 10, 12, 10, 8, 23, 8,
-        9, 7, 6, 7, 8, 7, 6, 55, 8, 23, 24, 12, 11, 7, 9, 11, 12, 6, 7, 22, 5,
-        7, 24, 6, 11, 9, 6, 7, 22, 7, 11, 38, 7, 9, 8, 25, 11, 8, 11, 9, 12,
-        8, 12, 5, 38, 5, 38, 5, 11, 7, 5, 6, 21, 6, 10, 53, 8, 7, 24, 10, 27,
-        44, 253, 253, 253, 252, 252, 252, 13, 12, 45, 12, 45, 12, 61, 12, 45,
-        44, 173};
-        /* bit lengths of length codes 0..15 */
-    static const unsigned char lenlen[] = {2, 35, 36, 53, 38, 23};
-        /* bit lengths of distance codes 0..63 */
-    static const unsigned char distlen[] = {2, 20, 53, 230, 247, 151, 248};
-    static const short base[16] = {     /* base for length codes */
-        3, 2, 4, 5, 6, 7, 8, 9, 10, 12, 16, 24, 40, 72, 136, 264};
-    static const char extra[16] = {     /* extra bits for length codes */
-        0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8};
-
-    /* set up decoding tables (once--might not be thread-safe) */
-    if (virgin) {
-        construct(&litcode, litlen, sizeof(litlen));
-        construct(&lencode, lenlen, sizeof(lenlen));
-        construct(&distcode, distlen, sizeof(distlen));
-        virgin = 0;
-    }
-
-    /* read header */
-    lit = bits(s, 8);
-    if (lit > 1) return -1;
-    dict = bits(s, 8);
-    if (dict < 4 || dict > 6) return -2;
-
-    /* decode literals and length/distance pairs */
-    do {
-        if (bits(s, 1)) {
-            /* get length */
-            symbol = decode(s, &lencode);
-            len = base[symbol] + bits(s, extra[symbol]);
-            if (len == 519) break;              /* end code */
-
-            /* get distance */
-            symbol = len == 2 ? 2 : dict;
-            dist = decode(s, &distcode) << symbol;
-            dist += bits(s, symbol);
-            dist++;
-            if (s->first && dist > s->next)
-                return -3;              /* distance too far back */
-
-            /* copy length bytes from distance bytes back */
-            do {
-                to = s->out + s->next;
-                from = to - dist;
-                copy = MAXWIN;
-                if (s->next < dist) {
-                    from += copy;
-                    copy = dist;
-                }
-                copy -= s->next;
-                if (copy > len) copy = len;
-                len -= copy;
-                s->next += copy;
-                do {
-                    *to++ = *from++;
-                } while (--copy);
-                if (s->next == MAXWIN) {
-                    if (s->outfun(s->outhow, s->out, s->next)) return 1;
-                    s->next = 0;
-                    s->first = 0;
-                }
-            } while (len != 0);
-        }
-        else {
-            /* get literal and write it */
-            symbol = lit ? decode(s, &litcode) : bits(s, 8);
-            s->out[s->next++] = symbol;
-            if (s->next == MAXWIN) {
-                if (s->outfun(s->outhow, s->out, s->next)) return 1;
-                s->next = 0;
-                s->first = 0;
-            }
-        }
-    } while (1);
-    return 0;
-}
-
-/* See comments in blast.h */
-int blast(blast_in infun, void *inhow, blast_out outfun, void *outhow)
-{
-    struct state s;             /* input/output state */
-    int err;                    /* return value */
-
-    /* initialize input state */
-    s.infun = infun;
-    s.inhow = inhow;
-    s.left = 0;
-    s.bitbuf = 0;
-    s.bitcnt = 0;
-
-    /* initialize output state */
-    s.outfun = outfun;
-    s.outhow = outhow;
-    s.next = 0;
-    s.first = 1;
-
-    /* return if bits() or decode() tries to read past available input */
-    if (setjmp(s.env) != 0)             /* if came back here via longjmp(), */
-        err = 2;                        /*  then skip decomp(), return error */
-    else
-        err = decomp(&s);               /* decompress */
-
-    /* write any leftover output and update the error code if needed */
-    if (err != 1 && s.next && s.outfun(s.outhow, s.out, s.next) && err == 0)
-        err = 1;
-    return err;
-}
-
-#ifdef TEST
-/* Example of how to use blast() */
-#include <stdio.h>
-#include <stdlib.h>
-
-#define CHUNK 16384
-
-local unsigned inf(void *how, unsigned char **buf)
-{
-    static unsigned char hold[CHUNK];
-
-    *buf = hold;
-    return fread(hold, 1, CHUNK, (FILE *)how);
-}
-
-local int outf(void *how, unsigned char *buf, unsigned len)
-{
-    return fwrite(buf, 1, len, (FILE *)how) != len;
-}
-
-/* Decompress a PKWare Compression Library stream from stdin to stdout */
-int main(void)
-{
-    int ret, n;
-
-    /* decompress to stdout */
-    ret = blast(inf, stdin, outf, stdout);
-    if (ret != 0) fprintf(stderr, "blast error: %d\n", ret);
-
-    /* see if there are any leftover bytes */
-    n = 0;
-    while (getchar() != EOF) n++;
-    if (n) fprintf(stderr, "blast warning: %d unused bytes of input\n", n);
-
-    /* return blast() error code */
-    return ret;
-}
-#endif
diff -Nbaur gcc-4.6.3/zlib/contrib/blast/blast.h gcc-4.6.3-psp/zlib/contrib/blast/blast.h
--- gcc-4.6.3/zlib/contrib/blast/blast.h	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/blast/blast.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,71 +0,0 @@
-/* blast.h -- interface for blast.c
-  Copyright (C) 2003 Mark Adler
-  version 1.1, 16 Feb 2003
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Mark Adler    madler@alumni.caltech.edu
- */
-
-
-/*
- * blast() decompresses the PKWare Data Compression Library (DCL) compressed
- * format.  It provides the same functionality as the explode() function in
- * that library.  (Note: PKWare overused the "implode" verb, and the format
- * used by their library implode() function is completely different and
- * incompatible with the implode compression method supported by PKZIP.)
- */
-
-
-typedef unsigned (*blast_in)(void *how, unsigned char **buf);
-typedef int (*blast_out)(void *how, unsigned char *buf, unsigned len);
-/* Definitions for input/output functions passed to blast().  See below for
- * what the provided functions need to do.
- */
-
-
-int blast(blast_in infun, void *inhow, blast_out outfun, void *outhow);
-/* Decompress input to output using the provided infun() and outfun() calls.
- * On success, the return value of blast() is zero.  If there is an error in
- * the source data, i.e. it is not in the proper format, then a negative value
- * is returned.  If there is not enough input available or there is not enough
- * output space, then a positive error is returned.
- *
- * The input function is invoked: len = infun(how, &buf), where buf is set by
- * infun() to point to the input buffer, and infun() returns the number of
- * available bytes there.  If infun() returns zero, then blast() returns with
- * an input error.  (blast() only asks for input if it needs it.)  inhow is for
- * use by the application to pass an input descriptor to infun(), if desired.
- *
- * The output function is invoked: err = outfun(how, buf, len), where the bytes
- * to be written are buf[0..len-1].  If err is not zero, then blast() returns
- * with an output error.  outfun() is always called with len <= 4096.  outhow
- * is for use by the application to pass an output descriptor to outfun(), if
- * desired.
- *
- * The return codes are:
- *
- *   2:  ran out of input before completing decompression
- *   1:  output error before completing decompression
- *   0:  successful decompression
- *  -1:  literal flag not zero or one
- *  -2:  dictionary size not in 4..6
- *  -3:  distance is too far back
- *
- * At the bottom of blast.c is an example program that uses blast() that can be
- * compiled to produce a command-line decompression filter by defining TEST.
- */
diff -Nbaur gcc-4.6.3/zlib/contrib/blast/Makefile gcc-4.6.3-psp/zlib/contrib/blast/Makefile
--- gcc-4.6.3/zlib/contrib/blast/Makefile	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/blast/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-blast: blast.c blast.h
-	cc -DTEST -o blast blast.c
-
-test: blast
-	blast < test.pk | cmp - test.txt
-
-clean:
-	rm -f blast blast.o
diff -Nbaur gcc-4.6.3/zlib/contrib/blast/README gcc-4.6.3-psp/zlib/contrib/blast/README
--- gcc-4.6.3/zlib/contrib/blast/README	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/blast/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-Read blast.h for purpose and usage.
-
-Mark Adler
-madler@alumni.caltech.edu
diff -Nbaur gcc-4.6.3/zlib/contrib/blast/test.pk gcc-4.6.3-psp/zlib/contrib/blast/test.pk
--- gcc-4.6.3/zlib/contrib/blast/test.pk	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/blast/test.pk	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
- $%
\ No newline at end of file
diff -Nbaur gcc-4.6.3/zlib/contrib/blast/test.txt gcc-4.6.3-psp/zlib/contrib/blast/test.txt
--- gcc-4.6.3/zlib/contrib/blast/test.txt	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/blast/test.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-AIAIAIAIAIAIA
\ No newline at end of file
diff -Nbaur gcc-4.6.3/zlib/contrib/delphi/readme.txt gcc-4.6.3-psp/zlib/contrib/delphi/readme.txt
--- gcc-4.6.3/zlib/contrib/delphi/readme.txt	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/delphi/readme.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-
-Overview
-========
-
-This directory contains an update to the ZLib interface unit,
-distributed by Borland as a Delphi supplemental component.
-
-The original ZLib unit is Copyright (c) 1997,99 Borland Corp.,
-and is based on zlib version 1.0.4.  There are a series of bugs
-and security problems associated with that old zlib version, and
-we recommend the users to update their ZLib unit.
-
-
-Summary of modifications
-========================
-
-- Improved makefile, adapted to zlib version 1.2.1.
-
-- Some field types from TZStreamRec are changed from Integer to
-  Longint, for consistency with the zlib.h header, and for 64-bit
-  readiness.
-
-- The zlib_version constant is updated.
-
-- The new Z_RLE strategy has its corresponding symbolic constant.
-
-- The allocation and deallocation functions and function types
-  (TAlloc, TFree, zlibAllocMem and zlibFreeMem) are now cdecl,
-  and _malloc and _free are added as C RTL stubs.  As a result,
-  the original C sources of zlib can be compiled out of the box,
-  and linked to the ZLib unit.
-
-
-Suggestions for improvements
-============================
-
-Currently, the ZLib unit provides only a limited wrapper around
-the zlib library, and much of the original zlib functionality is
-missing.  Handling compressed file formats like ZIP/GZIP or PNG
-cannot be implemented without having this functionality.
-Applications that handle these formats are either using their own,
-duplicated code, or not using the ZLib unit at all.
-
-Here are a few suggestions:
-
-- Checksum class wrappers around adler32() and crc32(), similar
-  to the Java classes that implement the java.util.zip.Checksum
-  interface.
-
-- The ability to read and write raw deflate streams, without the
-  zlib stream header and trailer.  Raw deflate streams are used
-  in the ZIP file format.
-
-- The ability to read and write gzip streams, used in the GZIP
-  file format, and normally produced by the gzip program.
-
-- The ability to select a different compression strategy, useful
-  to PNG and MNG image compression, and to multimedia compression
-  in general.  Besides the compression level
-
-    TCompressionLevel = (clNone, clFastest, clDefault, clMax);
-
-  which, in fact, could have used the 'z' prefix and avoided
-  TColor-like symbols
-
-    TCompressionLevel = (zcNone, zcFastest, zcDefault, zcMax);
-
-  there could be a compression strategy
-
-    TCompressionStrategy = (zsDefault, zsFiltered, zsHuffmanOnly, zsRle);
-
-- ZIP and GZIP stream handling via TStreams.
-
-
---
-Cosmin Truta <cosmint@cs.ubbcluj.ro>
diff -Nbaur gcc-4.6.3/zlib/contrib/delphi/ZLibConst.pas gcc-4.6.3-psp/zlib/contrib/delphi/ZLibConst.pas
--- gcc-4.6.3/zlib/contrib/delphi/ZLibConst.pas	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/delphi/ZLibConst.pas	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
-unit ZLibConst;
-
-interface
-
-resourcestring
-  sTargetBufferTooSmall = 'ZLib error: target buffer may be too small';
-  sInvalidStreamOp = 'Invalid stream operation';
-
-implementation
-
-end.
diff -Nbaur gcc-4.6.3/zlib/contrib/delphi/zlibd32.mak gcc-4.6.3-psp/zlib/contrib/delphi/zlibd32.mak
--- gcc-4.6.3/zlib/contrib/delphi/zlibd32.mak	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/delphi/zlibd32.mak	1970-01-01 01:00:00.000000000 +0100
@@ -1,93 +0,0 @@
-# Makefile for zlib
-# For use with Delphi and C++ Builder under Win32
-# Updated for zlib 1.2.x by Cosmin Truta
-
-# ------------ Borland C++ ------------
-
-# This project uses the Delphi (fastcall/register) calling convention:
-LOC = -DZEXPORT=__fastcall -DZEXPORTVA=__cdecl
-
-CC = bcc32
-LD = bcc32
-AR = tlib
-# do not use "-pr" in CFLAGS
-CFLAGS = -a -d -k- -O2 $(LOC)
-LDFLAGS =
-
-
-# variables
-ZLIB_LIB = zlib.lib
-
-OBJ1 = adler32.obj compress.obj crc32.obj deflate.obj gzio.obj infback.obj
-OBJ2 = inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj
-OBJP1 = +adler32.obj+compress.obj+crc32.obj+deflate.obj+gzio.obj+infback.obj
-OBJP2 = +inffast.obj+inflate.obj+inftrees.obj+trees.obj+uncompr.obj+zutil.obj
-
-
-# targets
-all: $(ZLIB_LIB) example.exe minigzip.exe
-
-.c.obj:
-	$(CC) -c $(CFLAGS) $*.c
-
-adler32.obj: adler32.c zlib.h zconf.h
-
-compress.obj: compress.c zlib.h zconf.h
-
-crc32.obj: crc32.c zlib.h zconf.h crc32.h
-
-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h
-
-gzio.obj: gzio.c zutil.h zlib.h zconf.h
-
-infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h
-
-inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h
-
-trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h
-
-uncompr.obj: uncompr.c zlib.h zconf.h
-
-zutil.obj: zutil.c zutil.h zlib.h zconf.h
-
-example.obj: example.c zlib.h zconf.h
-
-minigzip.obj: minigzip.c zlib.h zconf.h
-
-
-# For the sake of the old Borland make,
-# the command line is cut to fit in the MS-DOS 128 byte limit:
-$(ZLIB_LIB): $(OBJ1) $(OBJ2)
-	-del $(ZLIB_LIB)
-	$(AR) $(ZLIB_LIB) $(OBJP1)
-	$(AR) $(ZLIB_LIB) $(OBJP2)
-
-
-# testing
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d
-
-example.exe: example.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) example.obj $(ZLIB_LIB)
-
-minigzip.exe: minigzip.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) minigzip.obj $(ZLIB_LIB)
-
-
-# cleanup
-clean:
-	-del *.obj
-	-del *.exe
-	-del *.lib
-	-del *.tds
-	-del zlib.bak
-	-del foo.gz
-
diff -Nbaur gcc-4.6.3/zlib/contrib/delphi/ZLib.pas gcc-4.6.3-psp/zlib/contrib/delphi/ZLib.pas
--- gcc-4.6.3/zlib/contrib/delphi/ZLib.pas	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/delphi/ZLib.pas	1970-01-01 01:00:00.000000000 +0100
@@ -1,557 +0,0 @@
-{*******************************************************}
-{                                                       }
-{       Borland Delphi Supplemental Components          }
-{       ZLIB Data Compression Interface Unit            }
-{                                                       }
-{       Copyright (c) 1997,99 Borland Corporation       }
-{                                                       }
-{*******************************************************}
-
-{ Updated for zlib 1.2.x by Cosmin Truta <cosmint@cs.ubbcluj.ro> }
-
-unit ZLib;
-
-interface
-
-uses SysUtils, Classes;
-
-type
-  TAlloc = function (AppData: Pointer; Items, Size: Integer): Pointer; cdecl;
-  TFree = procedure (AppData, Block: Pointer); cdecl;
-
-  // Internal structure.  Ignore.
-  TZStreamRec = packed record
-    next_in: PChar;       // next input byte
-    avail_in: Integer;    // number of bytes available at next_in
-    total_in: Longint;    // total nb of input bytes read so far
-
-    next_out: PChar;      // next output byte should be put here
-    avail_out: Integer;   // remaining free space at next_out
-    total_out: Longint;   // total nb of bytes output so far
-
-    msg: PChar;           // last error message, NULL if no error
-    internal: Pointer;    // not visible by applications
-
-    zalloc: TAlloc;       // used to allocate the internal state
-    zfree: TFree;         // used to free the internal state
-    AppData: Pointer;     // private data object passed to zalloc and zfree
-
-    data_type: Integer;   // best guess about the data type: ascii or binary
-    adler: Longint;       // adler32 value of the uncompressed data
-    reserved: Longint;    // reserved for future use
-  end;
-
-  // Abstract ancestor class
-  TCustomZlibStream = class(TStream)
-  private
-    FStrm: TStream;
-    FStrmPos: Integer;
-    FOnProgress: TNotifyEvent;
-    FZRec: TZStreamRec;
-    FBuffer: array [Word] of Char;
-  protected
-    procedure Progress(Sender: TObject); dynamic;
-    property OnProgress: TNotifyEvent read FOnProgress write FOnProgress;
-    constructor Create(Strm: TStream);
-  end;
-
-{ TCompressionStream compresses data on the fly as data is written to it, and
-  stores the compressed data to another stream.
-
-  TCompressionStream is write-only and strictly sequential. Reading from the
-  stream will raise an exception. Using Seek to move the stream pointer
-  will raise an exception.
-
-  Output data is cached internally, written to the output stream only when
-  the internal output buffer is full.  All pending output data is flushed
-  when the stream is destroyed.
-
-  The Position property returns the number of uncompressed bytes of
-  data that have been written to the stream so far.
-
-  CompressionRate returns the on-the-fly percentage by which the original
-  data has been compressed:  (1 - (CompressedBytes / UncompressedBytes)) * 100
-  If raw data size = 100 and compressed data size = 25, the CompressionRate
-  is 75%
-
-  The OnProgress event is called each time the output buffer is filled and
-  written to the output stream.  This is useful for updating a progress
-  indicator when you are writing a large chunk of data to the compression
-  stream in a single call.}
-
-
-  TCompressionLevel = (clNone, clFastest, clDefault, clMax);
-
-  TCompressionStream = class(TCustomZlibStream)
-  private
-    function GetCompressionRate: Single;
-  public
-    constructor Create(CompressionLevel: TCompressionLevel; Dest: TStream);
-    destructor Destroy; override;
-    function Read(var Buffer; Count: Longint): Longint; override;
-    function Write(const Buffer; Count: Longint): Longint; override;
-    function Seek(Offset: Longint; Origin: Word): Longint; override;
-    property CompressionRate: Single read GetCompressionRate;
-    property OnProgress;
-  end;
-
-{ TDecompressionStream decompresses data on the fly as data is read from it.
-
-  Compressed data comes from a separate source stream.  TDecompressionStream
-  is read-only and unidirectional; you can seek forward in the stream, but not
-  backwards.  The special case of setting the stream position to zero is
-  allowed.  Seeking forward decompresses data until the requested position in
-  the uncompressed data has been reached.  Seeking backwards, seeking relative
-  to the end of the stream, requesting the size of the stream, and writing to
-  the stream will raise an exception.
-
-  The Position property returns the number of bytes of uncompressed data that
-  have been read from the stream so far.
-
-  The OnProgress event is called each time the internal input buffer of
-  compressed data is exhausted and the next block is read from the input stream.
-  This is useful for updating a progress indicator when you are reading a
-  large chunk of data from the decompression stream in a single call.}
-
-  TDecompressionStream = class(TCustomZlibStream)
-  public
-    constructor Create(Source: TStream);
-    destructor Destroy; override;
-    function Read(var Buffer; Count: Longint): Longint; override;
-    function Write(const Buffer; Count: Longint): Longint; override;
-    function Seek(Offset: Longint; Origin: Word): Longint; override;
-    property OnProgress;
-  end;
-
-
-
-{ CompressBuf compresses data, buffer to buffer, in one call.
-   In: InBuf = ptr to compressed data
-       InBytes = number of bytes in InBuf
-  Out: OutBuf = ptr to newly allocated buffer containing decompressed data
-       OutBytes = number of bytes in OutBuf   }
-procedure CompressBuf(const InBuf: Pointer; InBytes: Integer;
-                      out OutBuf: Pointer; out OutBytes: Integer);
-
-
-{ DecompressBuf decompresses data, buffer to buffer, in one call.
-   In: InBuf = ptr to compressed data
-       InBytes = number of bytes in InBuf
-       OutEstimate = zero, or est. size of the decompressed data
-  Out: OutBuf = ptr to newly allocated buffer containing decompressed data
-       OutBytes = number of bytes in OutBuf   }
-procedure DecompressBuf(const InBuf: Pointer; InBytes: Integer;
- OutEstimate: Integer; out OutBuf: Pointer; out OutBytes: Integer);
-
-{ DecompressToUserBuf decompresses data, buffer to buffer, in one call.
-   In: InBuf = ptr to compressed data
-       InBytes = number of bytes in InBuf
-  Out: OutBuf = ptr to user-allocated buffer to contain decompressed data
-       BufSize = number of bytes in OutBuf   }
-procedure DecompressToUserBuf(const InBuf: Pointer; InBytes: Integer;
-  const OutBuf: Pointer; BufSize: Integer);
-
-const
-  zlib_version = '1.2.3';
-
-type
-  EZlibError = class(Exception);
-  ECompressionError = class(EZlibError);
-  EDecompressionError = class(EZlibError);
-
-implementation
-
-uses ZLibConst;
-
-const
-  Z_NO_FLUSH      = 0;
-  Z_PARTIAL_FLUSH = 1;
-  Z_SYNC_FLUSH    = 2;
-  Z_FULL_FLUSH    = 3;
-  Z_FINISH        = 4;
-
-  Z_OK            = 0;
-  Z_STREAM_END    = 1;
-  Z_NEED_DICT     = 2;
-  Z_ERRNO         = (-1);
-  Z_STREAM_ERROR  = (-2);
-  Z_DATA_ERROR    = (-3);
-  Z_MEM_ERROR     = (-4);
-  Z_BUF_ERROR     = (-5);
-  Z_VERSION_ERROR = (-6);
-
-  Z_NO_COMPRESSION       =   0;
-  Z_BEST_SPEED           =   1;
-  Z_BEST_COMPRESSION     =   9;
-  Z_DEFAULT_COMPRESSION  = (-1);
-
-  Z_FILTERED            = 1;
-  Z_HUFFMAN_ONLY        = 2;
-  Z_RLE                 = 3;
-  Z_DEFAULT_STRATEGY    = 0;
-
-  Z_BINARY   = 0;
-  Z_ASCII    = 1;
-  Z_UNKNOWN  = 2;
-
-  Z_DEFLATED = 8;
-
-
-{$L adler32.obj}
-{$L compress.obj}
-{$L crc32.obj}
-{$L deflate.obj}
-{$L infback.obj}
-{$L inffast.obj}
-{$L inflate.obj}
-{$L inftrees.obj}
-{$L trees.obj}
-{$L uncompr.obj}
-{$L zutil.obj}
-
-procedure adler32; external;
-procedure compressBound; external;
-procedure crc32; external;
-procedure deflateInit2_; external;
-procedure deflateParams; external;
-
-function _malloc(Size: Integer): Pointer; cdecl;
-begin
-  Result := AllocMem(Size);
-end;
-
-procedure _free(Block: Pointer); cdecl;
-begin
-  FreeMem(Block);
-end;
-
-procedure _memset(P: Pointer; B: Byte; count: Integer); cdecl;
-begin
-  FillChar(P^, count, B);
-end;
-
-procedure _memcpy(dest, source: Pointer; count: Integer); cdecl;
-begin
-  Move(source^, dest^, count);
-end;
-
-
-
-// deflate compresses data
-function deflateInit_(var strm: TZStreamRec; level: Integer; version: PChar;
-  recsize: Integer): Integer; external;
-function deflate(var strm: TZStreamRec; flush: Integer): Integer; external;
-function deflateEnd(var strm: TZStreamRec): Integer; external;
-
-// inflate decompresses data
-function inflateInit_(var strm: TZStreamRec; version: PChar;
-  recsize: Integer): Integer; external;
-function inflate(var strm: TZStreamRec; flush: Integer): Integer; external;
-function inflateEnd(var strm: TZStreamRec): Integer; external;
-function inflateReset(var strm: TZStreamRec): Integer; external;
-
-
-function zlibAllocMem(AppData: Pointer; Items, Size: Integer): Pointer; cdecl;
-begin
-//  GetMem(Result, Items*Size);
-  Result := AllocMem(Items * Size);
-end;
-
-procedure zlibFreeMem(AppData, Block: Pointer); cdecl;
-begin
-  FreeMem(Block);
-end;
-
-{function zlibCheck(code: Integer): Integer;
-begin
-  Result := code;
-  if code < 0 then
-    raise EZlibError.Create('error');    //!!
-end;}
-
-function CCheck(code: Integer): Integer;
-begin
-  Result := code;
-  if code < 0 then
-    raise ECompressionError.Create('error'); //!!
-end;
-
-function DCheck(code: Integer): Integer;
-begin
-  Result := code;
-  if code < 0 then
-    raise EDecompressionError.Create('error');  //!!
-end;
-
-procedure CompressBuf(const InBuf: Pointer; InBytes: Integer;
-                      out OutBuf: Pointer; out OutBytes: Integer);
-var
-  strm: TZStreamRec;
-  P: Pointer;
-begin
-  FillChar(strm, sizeof(strm), 0);
-  strm.zalloc := zlibAllocMem;
-  strm.zfree := zlibFreeMem;
-  OutBytes := ((InBytes + (InBytes div 10) + 12) + 255) and not 255;
-  GetMem(OutBuf, OutBytes);
-  try
-    strm.next_in := InBuf;
-    strm.avail_in := InBytes;
-    strm.next_out := OutBuf;
-    strm.avail_out := OutBytes;
-    CCheck(deflateInit_(strm, Z_BEST_COMPRESSION, zlib_version, sizeof(strm)));
-    try
-      while CCheck(deflate(strm, Z_FINISH)) <> Z_STREAM_END do
-      begin
-        P := OutBuf;
-        Inc(OutBytes, 256);
-        ReallocMem(OutBuf, OutBytes);
-        strm.next_out := PChar(Integer(OutBuf) + (Integer(strm.next_out) - Integer(P)));
-        strm.avail_out := 256;
-      end;
-    finally
-      CCheck(deflateEnd(strm));
-    end;
-    ReallocMem(OutBuf, strm.total_out);
-    OutBytes := strm.total_out;
-  except
-    FreeMem(OutBuf);
-    raise
-  end;
-end;
-
-
-procedure DecompressBuf(const InBuf: Pointer; InBytes: Integer;
-  OutEstimate: Integer; out OutBuf: Pointer; out OutBytes: Integer);
-var
-  strm: TZStreamRec;
-  P: Pointer;
-  BufInc: Integer;
-begin
-  FillChar(strm, sizeof(strm), 0);
-  strm.zalloc := zlibAllocMem;
-  strm.zfree := zlibFreeMem;
-  BufInc := (InBytes + 255) and not 255;
-  if OutEstimate = 0 then
-    OutBytes := BufInc
-  else
-    OutBytes := OutEstimate;
-  GetMem(OutBuf, OutBytes);
-  try
-    strm.next_in := InBuf;
-    strm.avail_in := InBytes;
-    strm.next_out := OutBuf;
-    strm.avail_out := OutBytes;
-    DCheck(inflateInit_(strm, zlib_version, sizeof(strm)));
-    try
-      while DCheck(inflate(strm, Z_NO_FLUSH)) <> Z_STREAM_END do
-      begin
-        P := OutBuf;
-        Inc(OutBytes, BufInc);
-        ReallocMem(OutBuf, OutBytes);
-        strm.next_out := PChar(Integer(OutBuf) + (Integer(strm.next_out) - Integer(P)));
-        strm.avail_out := BufInc;
-      end;
-    finally
-      DCheck(inflateEnd(strm));
-    end;
-    ReallocMem(OutBuf, strm.total_out);
-    OutBytes := strm.total_out;
-  except
-    FreeMem(OutBuf);
-    raise
-  end;
-end;
-
-procedure DecompressToUserBuf(const InBuf: Pointer; InBytes: Integer;
-  const OutBuf: Pointer; BufSize: Integer);
-var
-  strm: TZStreamRec;
-begin
-  FillChar(strm, sizeof(strm), 0);
-  strm.zalloc := zlibAllocMem;
-  strm.zfree := zlibFreeMem;
-  strm.next_in := InBuf;
-  strm.avail_in := InBytes;
-  strm.next_out := OutBuf;
-  strm.avail_out := BufSize;
-  DCheck(inflateInit_(strm, zlib_version, sizeof(strm)));
-  try
-    if DCheck(inflate(strm, Z_FINISH)) <> Z_STREAM_END then
-      raise EZlibError.CreateRes(@sTargetBufferTooSmall);
-  finally
-    DCheck(inflateEnd(strm));
-  end;
-end;
-
-// TCustomZlibStream
-
-constructor TCustomZLibStream.Create(Strm: TStream);
-begin
-  inherited Create;
-  FStrm := Strm;
-  FStrmPos := Strm.Position;
-  FZRec.zalloc := zlibAllocMem;
-  FZRec.zfree := zlibFreeMem;
-end;
-
-procedure TCustomZLibStream.Progress(Sender: TObject);
-begin
-  if Assigned(FOnProgress) then FOnProgress(Sender);
-end;
-
-
-// TCompressionStream
-
-constructor TCompressionStream.Create(CompressionLevel: TCompressionLevel;
-  Dest: TStream);
-const
-  Levels: array [TCompressionLevel] of ShortInt =
-    (Z_NO_COMPRESSION, Z_BEST_SPEED, Z_DEFAULT_COMPRESSION, Z_BEST_COMPRESSION);
-begin
-  inherited Create(Dest);
-  FZRec.next_out := FBuffer;
-  FZRec.avail_out := sizeof(FBuffer);
-  CCheck(deflateInit_(FZRec, Levels[CompressionLevel], zlib_version, sizeof(FZRec)));
-end;
-
-destructor TCompressionStream.Destroy;
-begin
-  FZRec.next_in := nil;
-  FZRec.avail_in := 0;
-  try
-    if FStrm.Position <> FStrmPos then FStrm.Position := FStrmPos;
-    while (CCheck(deflate(FZRec, Z_FINISH)) <> Z_STREAM_END)
-      and (FZRec.avail_out = 0) do
-    begin
-      FStrm.WriteBuffer(FBuffer, sizeof(FBuffer));
-      FZRec.next_out := FBuffer;
-      FZRec.avail_out := sizeof(FBuffer);
-    end;
-    if FZRec.avail_out < sizeof(FBuffer) then
-      FStrm.WriteBuffer(FBuffer, sizeof(FBuffer) - FZRec.avail_out);
-  finally
-    deflateEnd(FZRec);
-  end;
-  inherited Destroy;
-end;
-
-function TCompressionStream.Read(var Buffer; Count: Longint): Longint;
-begin
-  raise ECompressionError.CreateRes(@sInvalidStreamOp);
-end;
-
-function TCompressionStream.Write(const Buffer; Count: Longint): Longint;
-begin
-  FZRec.next_in := @Buffer;
-  FZRec.avail_in := Count;
-  if FStrm.Position <> FStrmPos then FStrm.Position := FStrmPos;
-  while (FZRec.avail_in > 0) do
-  begin
-    CCheck(deflate(FZRec, 0));
-    if FZRec.avail_out = 0 then
-    begin
-      FStrm.WriteBuffer(FBuffer, sizeof(FBuffer));
-      FZRec.next_out := FBuffer;
-      FZRec.avail_out := sizeof(FBuffer);
-      FStrmPos := FStrm.Position;
-      Progress(Self);
-    end;
-  end;
-  Result := Count;
-end;
-
-function TCompressionStream.Seek(Offset: Longint; Origin: Word): Longint;
-begin
-  if (Offset = 0) and (Origin = soFromCurrent) then
-    Result := FZRec.total_in
-  else
-    raise ECompressionError.CreateRes(@sInvalidStreamOp);
-end;
-
-function TCompressionStream.GetCompressionRate: Single;
-begin
-  if FZRec.total_in = 0 then
-    Result := 0
-  else
-    Result := (1.0 - (FZRec.total_out / FZRec.total_in)) * 100.0;
-end;
-
-
-// TDecompressionStream
-
-constructor TDecompressionStream.Create(Source: TStream);
-begin
-  inherited Create(Source);
-  FZRec.next_in := FBuffer;
-  FZRec.avail_in := 0;
-  DCheck(inflateInit_(FZRec, zlib_version, sizeof(FZRec)));
-end;
-
-destructor TDecompressionStream.Destroy;
-begin
-  FStrm.Seek(-FZRec.avail_in, 1);
-  inflateEnd(FZRec);
-  inherited Destroy;
-end;
-
-function TDecompressionStream.Read(var Buffer; Count: Longint): Longint;
-begin
-  FZRec.next_out := @Buffer;
-  FZRec.avail_out := Count;
-  if FStrm.Position <> FStrmPos then FStrm.Position := FStrmPos;
-  while (FZRec.avail_out > 0) do
-  begin
-    if FZRec.avail_in = 0 then
-    begin
-      FZRec.avail_in := FStrm.Read(FBuffer, sizeof(FBuffer));
-      if FZRec.avail_in = 0 then
-      begin
-        Result := Count - FZRec.avail_out;
-        Exit;
-      end;
-      FZRec.next_in := FBuffer;
-      FStrmPos := FStrm.Position;
-      Progress(Self);
-    end;
-    CCheck(inflate(FZRec, 0));
-  end;
-  Result := Count;
-end;
-
-function TDecompressionStream.Write(const Buffer; Count: Longint): Longint;
-begin
-  raise EDecompressionError.CreateRes(@sInvalidStreamOp);
-end;
-
-function TDecompressionStream.Seek(Offset: Longint; Origin: Word): Longint;
-var
-  I: Integer;
-  Buf: array [0..4095] of Char;
-begin
-  if (Offset = 0) and (Origin = soFromBeginning) then
-  begin
-    DCheck(inflateReset(FZRec));
-    FZRec.next_in := FBuffer;
-    FZRec.avail_in := 0;
-    FStrm.Position := 0;
-    FStrmPos := 0;
-  end
-  else if ( (Offset >= 0) and (Origin = soFromCurrent)) or
-          ( ((Offset - FZRec.total_out) > 0) and (Origin = soFromBeginning)) then
-  begin
-    if Origin = soFromBeginning then Dec(Offset, FZRec.total_out);
-    if Offset > 0 then
-    begin
-      for I := 1 to Offset div sizeof(Buf) do
-        ReadBuffer(Buf, sizeof(Buf));
-      ReadBuffer(Buf, Offset mod sizeof(Buf));
-    end;
-  end
-  else
-    raise EDecompressionError.CreateRes(@sInvalidStreamOp);
-  Result := FZRec.total_out;
-end;
-
-
-end.
diff -Nbaur gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/AssemblyInfo.cs gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/AssemblyInfo.cs
--- gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/AssemblyInfo.cs	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/AssemblyInfo.cs	1970-01-01 01:00:00.000000000 +0100
@@ -1,58 +0,0 @@
-using System.Reflection;
-using System.Runtime.CompilerServices;
-
-//
-// General Information about an assembly is controlled through the following 
-// set of attributes. Change these attribute values to modify the information
-// associated with an assembly.
-//
-[assembly: AssemblyTitle("DotZLib")]
-[assembly: AssemblyDescription(".Net bindings for ZLib compression dll 1.2.x")]
-[assembly: AssemblyConfiguration("")]
-[assembly: AssemblyCompany("Henrik Ravn")]
-[assembly: AssemblyProduct("")]
-[assembly: AssemblyCopyright("(c) 2004 by Henrik Ravn")]
-[assembly: AssemblyTrademark("")]
-[assembly: AssemblyCulture("")]		
-
-//
-// Version information for an assembly consists of the following four values:
-//
-//      Major Version
-//      Minor Version 
-//      Build Number
-//      Revision
-//
-// You can specify all the values or you can default the Revision and Build Numbers 
-// by using the '*' as shown below:
-
-[assembly: AssemblyVersion("1.0.*")]
-
-//
-// In order to sign your assembly you must specify a key to use. Refer to the 
-// Microsoft .NET Framework documentation for more information on assembly signing.
-//
-// Use the attributes below to control which key is used for signing. 
-//
-// Notes: 
-//   (*) If no key is specified, the assembly is not signed.
-//   (*) KeyName refers to a key that has been installed in the Crypto Service
-//       Provider (CSP) on your machine. KeyFile refers to a file which contains
-//       a key.
-//   (*) If the KeyFile and the KeyName values are both specified, the 
-//       following processing occurs:
-//       (1) If the KeyName can be found in the CSP, that key is used.
-//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
-//           in the KeyFile is installed into the CSP and used.
-//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
-//       When specifying the KeyFile, the location of the KeyFile should be
-//       relative to the project output directory which is
-//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
-//       located in the project directory, you would specify the AssemblyKeyFile 
-//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
-//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
-//       documentation for more information on this.
-//
-[assembly: AssemblyDelaySign(false)]
-[assembly: AssemblyKeyFile("")]
-[assembly: AssemblyKeyName("")]
diff -Nbaur gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/ChecksumImpl.cs gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/ChecksumImpl.cs
--- gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/ChecksumImpl.cs	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/ChecksumImpl.cs	1970-01-01 01:00:00.000000000 +0100
@@ -1,202 +0,0 @@
-//
-//  Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.Runtime.InteropServices;
-using System.Text;
-
-
-namespace DotZLib
-{
-    #region ChecksumGeneratorBase
-    /// <summary>
-    /// Implements the common functionality needed for all <see cref="ChecksumGenerator"/>s
-    /// </summary>
-    /// <example></example>
-    public abstract class ChecksumGeneratorBase : ChecksumGenerator
-    {
-        /// <summary>
-        /// The value of the current checksum
-        /// </summary>
-        protected uint _current;
-
-        /// <summary>
-        /// Initializes a new instance of the checksum generator base - the current checksum is 
-        /// set to zero
-        /// </summary>
-        public ChecksumGeneratorBase()
-        {
-            _current = 0;
-        }
-
-        /// <summary>
-        /// Initializes a new instance of the checksum generator basewith a specified value
-        /// </summary>
-        /// <param name="initialValue">The value to set the current checksum to</param>
-        public ChecksumGeneratorBase(uint initialValue)
-        {
-            _current = initialValue;
-        }
-
-        /// <summary>
-        /// Resets the current checksum to zero
-        /// </summary>
-        public void Reset() { _current = 0; }
-
-        /// <summary>
-        /// Gets the current checksum value
-        /// </summary>
-        public uint Value { get { return _current; } }
-
-        /// <summary>
-        /// Updates the current checksum with part of an array of bytes
-        /// </summary>
-        /// <param name="data">The data to update the checksum with</param>
-        /// <param name="offset">Where in <c>data</c> to start updating</param>
-        /// <param name="count">The number of bytes from <c>data</c> to use</param>
-        /// <exception cref="ArgumentException">The sum of offset and count is larger than the length of <c>data</c></exception>
-        /// <exception cref="NullReferenceException"><c>data</c> is a null reference</exception>
-        /// <exception cref="ArgumentOutOfRangeException">Offset or count is negative.</exception>
-        /// <remarks>All the other <c>Update</c> methods are implmeneted in terms of this one. 
-        /// This is therefore the only method a derived class has to implement</remarks>
-        public abstract void Update(byte[] data, int offset, int count);
-
-        /// <summary>
-        /// Updates the current checksum with an array of bytes.
-        /// </summary>
-        /// <param name="data">The data to update the checksum with</param>
-        public void Update(byte[] data)
-        {
-            Update(data, 0, data.Length);
-        }
-
-        /// <summary>
-        /// Updates the current checksum with the data from a string
-        /// </summary>
-        /// <param name="data">The string to update the checksum with</param>
-        /// <remarks>The characters in the string are converted by the UTF-8 encoding</remarks>
-        public void Update(string data)
-        {
-			Update(Encoding.UTF8.GetBytes(data));
-        }
-
-        /// <summary>
-        /// Updates the current checksum with the data from a string, using a specific encoding
-        /// </summary>
-        /// <param name="data">The string to update the checksum with</param>
-        /// <param name="encoding">The encoding to use</param>
-        public void Update(string data, Encoding encoding)
-        {
-            Update(encoding.GetBytes(data));
-        }
-
-    }
-    #endregion
-
-    #region CRC32
-    /// <summary>
-    /// Implements a CRC32 checksum generator
-    /// </summary>
-    public sealed class CRC32Checksum : ChecksumGeneratorBase    
-    {
-        #region DLL imports
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern uint crc32(uint crc, int data, uint length);
-
-        #endregion
-
-        /// <summary>
-        /// Initializes a new instance of the CRC32 checksum generator
-        /// </summary>
-        public CRC32Checksum() : base() {}
-
-        /// <summary>
-        /// Initializes a new instance of the CRC32 checksum generator with a specified value
-        /// </summary>
-        /// <param name="initialValue">The value to set the current checksum to</param>
-        public CRC32Checksum(uint initialValue) : base(initialValue) {}
-
-        /// <summary>
-        /// Updates the current checksum with part of an array of bytes
-        /// </summary>
-        /// <param name="data">The data to update the checksum with</param>
-        /// <param name="offset">Where in <c>data</c> to start updating</param>
-        /// <param name="count">The number of bytes from <c>data</c> to use</param>
-        /// <exception cref="ArgumentException">The sum of offset and count is larger than the length of <c>data</c></exception>
-        /// <exception cref="NullReferenceException"><c>data</c> is a null reference</exception>
-        /// <exception cref="ArgumentOutOfRangeException">Offset or count is negative.</exception>
-        public override void Update(byte[] data, int offset, int count)
-        {
-            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();
-            if ((offset+count) > data.Length) throw new ArgumentException();
-            GCHandle hData = GCHandle.Alloc(data, GCHandleType.Pinned);
-            try
-            {
-                _current = crc32(_current, hData.AddrOfPinnedObject().ToInt32()+offset, (uint)count);
-            }
-            finally
-            {
-                hData.Free();
-            }
-        }
-
-    }
-    #endregion
-
-    #region Adler
-    /// <summary>
-    /// Implements a checksum generator that computes the Adler checksum on data
-    /// </summary>
-    public sealed class AdlerChecksum : ChecksumGeneratorBase    
-    {
-        #region DLL imports
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern uint adler32(uint adler, int data, uint length);
-
-        #endregion
-
-        /// <summary>
-        /// Initializes a new instance of the Adler checksum generator
-        /// </summary>
-        public AdlerChecksum() : base() {}
-
-        /// <summary>
-        /// Initializes a new instance of the Adler checksum generator with a specified value
-        /// </summary>
-        /// <param name="initialValue">The value to set the current checksum to</param>
-        public AdlerChecksum(uint initialValue) : base(initialValue) {}
-
-        /// <summary>
-        /// Updates the current checksum with part of an array of bytes
-        /// </summary>
-        /// <param name="data">The data to update the checksum with</param>
-        /// <param name="offset">Where in <c>data</c> to start updating</param>
-        /// <param name="count">The number of bytes from <c>data</c> to use</param>
-        /// <exception cref="ArgumentException">The sum of offset and count is larger than the length of <c>data</c></exception>
-        /// <exception cref="NullReferenceException"><c>data</c> is a null reference</exception>
-        /// <exception cref="ArgumentOutOfRangeException">Offset or count is negative.</exception>
-        public override void Update(byte[] data, int offset, int count)
-        {
-            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();
-            if ((offset+count) > data.Length) throw new ArgumentException();
-            GCHandle hData = GCHandle.Alloc(data, GCHandleType.Pinned);
-            try
-            {
-                _current = adler32(_current, hData.AddrOfPinnedObject().ToInt32()+offset, (uint)count);
-            }
-            finally
-            {
-                hData.Free();
-            }
-        }
-
-    }
-    #endregion
-
-}
\ No newline at end of file
diff -Nbaur gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/CircularBuffer.cs gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/CircularBuffer.cs
--- gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/CircularBuffer.cs	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/CircularBuffer.cs	1970-01-01 01:00:00.000000000 +0100
@@ -1,83 +0,0 @@
-//
-//  Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.Diagnostics;
-
-namespace DotZLib
-{
-
-	/// <summary>
-	/// This class implements a circular buffer
-	/// </summary>
-	internal class CircularBuffer
-	{
-        #region Private data
-        private int _capacity;
-        private int _head;
-        private int _tail;
-        private int _size;
-        private byte[] _buffer;
-        #endregion
-
-        public CircularBuffer(int capacity)
-        {    
-            Debug.Assert( capacity > 0 );
-            _buffer = new byte[capacity];
-            _capacity = capacity;
-            _head = 0;
-            _tail = 0;
-            _size = 0;
-        }
-
-        public int Size { get { return _size; } }
-
-        public int Put(byte[] source, int offset, int count)
-        {
-            Debug.Assert( count > 0 );
-            int trueCount = Math.Min(count, _capacity - Size);
-            for (int i = 0; i < trueCount; ++i)
-                _buffer[(_tail+i) % _capacity] = source[offset+i];
-            _tail += trueCount;
-            _tail %= _capacity;
-            _size += trueCount;
-            return trueCount;
-        }
-
-        public bool Put(byte b)
-        {
-            if (Size == _capacity) // no room
-                return false;
-            _buffer[_tail++] = b;
-            _tail %= _capacity;
-            ++_size;
-            return true;
-        }
-
-        public int Get(byte[] destination, int offset, int count)
-        {
-            int trueCount = Math.Min(count,Size);
-            for (int i = 0; i < trueCount; ++i)
-                destination[offset + i] = _buffer[(_head+i) % _capacity];
-            _head += trueCount;
-            _head %= _capacity;
-            _size -= trueCount;
-            return trueCount;
-        }
-
-        public int Get()
-        {
-            if (Size == 0)
-                return -1;
-
-            int result = (int)_buffer[_head++ % _capacity];
-            --_size;
-            return result;
-        }
-
-    }
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/CodecBase.cs gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/CodecBase.cs
--- gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/CodecBase.cs	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/CodecBase.cs	1970-01-01 01:00:00.000000000 +0100
@@ -1,198 +0,0 @@
-//
-//  Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.Runtime.InteropServices;
-
-namespace DotZLib
-{
-	/// <summary>
-	/// Implements the common functionality needed for all <see cref="Codec"/>s
-	/// </summary>
-	public abstract class CodecBase : Codec, IDisposable
-	{
-
-        #region Data members
-
-        /// <summary>
-        /// Instance of the internal zlib buffer structure that is 
-        /// passed to all functions in the zlib dll
-        /// </summary>
-        internal ZStream _ztream = new ZStream();
-
-        /// <summary>
-        /// True if the object instance has been disposed, false otherwise
-        /// </summary>
-        protected bool _isDisposed = false;
-
-        /// <summary>
-        /// The size of the internal buffers
-        /// </summary>
-        protected const int kBufferSize = 16384;
-
-        private byte[] _outBuffer = new byte[kBufferSize];
-        private byte[] _inBuffer = new byte[kBufferSize];
-
-        private GCHandle _hInput;
-        private GCHandle _hOutput;
-
-        private uint _checksum = 0;
-
-        #endregion
-
-        /// <summary>
-        /// Initializes a new instance of the <c>CodeBase</c> class. 
-        /// </summary>
-		public CodecBase()
-		{
-            try
-            {
-                _hInput = GCHandle.Alloc(_inBuffer, GCHandleType.Pinned);
-                _hOutput = GCHandle.Alloc(_outBuffer, GCHandleType.Pinned);
-            }
-            catch (Exception)
-            {
-                CleanUp(false);
-                throw;
-            }
-        }
-
-
-        #region Codec Members
-
-        /// <summary>
-        /// Occurs when more processed data are available.
-        /// </summary>
-        public event DataAvailableHandler DataAvailable;
-
-        /// <summary>
-        /// Fires the <see cref="DataAvailable"/> event
-        /// </summary>
-        protected void OnDataAvailable()
-        {
-            if (_ztream.total_out > 0)
-            {
-                if (DataAvailable != null)
-                    DataAvailable( _outBuffer, 0, (int)_ztream.total_out); 
-                resetOutput();
-            }
-        }
-
-        /// <summary>
-        /// Adds more data to the codec to be processed.
-        /// </summary>
-        /// <param name="data">Byte array containing the data to be added to the codec</param>
-        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
-        public void Add(byte[] data)
-        {
-            Add(data,0,data.Length);
-        }
-
-        /// <summary>
-        /// Adds more data to the codec to be processed.
-        /// </summary>
-        /// <param name="data">Byte array containing the data to be added to the codec</param>
-        /// <param name="offset">The index of the first byte to add from <c>data</c></param>
-        /// <param name="count">The number of bytes to add</param>
-        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
-        /// <remarks>This must be implemented by a derived class</remarks>
-        public abstract void Add(byte[] data, int offset, int count);
-
-        /// <summary>
-        /// Finishes up any pending data that needs to be processed and handled.
-        /// </summary>
-        /// <remarks>This must be implemented by a derived class</remarks>
-        public abstract void Finish();
-
-        /// <summary>
-        /// Gets the checksum of the data that has been added so far
-        /// </summary>
-        public uint Checksum { get { return _checksum; } }
-
-        #endregion
-
-        #region Destructor & IDisposable stuff
-
-        /// <summary>
-        /// Destroys this instance
-        /// </summary>
-        ~CodecBase()
-        {
-            CleanUp(false);
-        }
-
-        /// <summary>
-        /// Releases any unmanaged resources and calls the <see cref="CleanUp()"/> method of the derived class
-        /// </summary>
-        public void Dispose()
-        {
-            CleanUp(true);
-        }
-
-        /// <summary>
-        /// Performs any codec specific cleanup
-        /// </summary>
-        /// <remarks>This must be implemented by a derived class</remarks>
-        protected abstract void CleanUp();
-
-        // performs the release of the handles and calls the dereived CleanUp()
-        private void CleanUp(bool isDisposing)
-        {
-            if (!_isDisposed)
-            {
-                CleanUp();
-                if (_hInput.IsAllocated)
-                    _hInput.Free();
-                if (_hOutput.IsAllocated)
-                    _hOutput.Free();
-
-                _isDisposed = true;
-            }
-        }
-
-
-        #endregion
-
-        #region Helper methods
-
-        /// <summary>
-        /// Copies a number of bytes to the internal codec buffer - ready for proccesing
-        /// </summary>
-        /// <param name="data">The byte array that contains the data to copy</param>
-        /// <param name="startIndex">The index of the first byte to copy</param>
-        /// <param name="count">The number of bytes to copy from <c>data</c></param>
-        protected void copyInput(byte[] data, int startIndex, int count)
-        {
-            Array.Copy(data, startIndex, _inBuffer,0, count);
-            _ztream.next_in = _hInput.AddrOfPinnedObject();
-            _ztream.total_in = 0;
-            _ztream.avail_in = (uint)count;
-
-        }
-
-        /// <summary>
-        /// Resets the internal output buffers to a known state - ready for processing
-        /// </summary>
-        protected void resetOutput()
-        {
-            _ztream.total_out = 0;
-            _ztream.avail_out = kBufferSize;
-            _ztream.next_out = _hOutput.AddrOfPinnedObject();
-        }
-
-        /// <summary>
-        /// Updates the running checksum property
-        /// </summary>
-        /// <param name="newSum">The new checksum value</param>
-        protected void setChecksum(uint newSum)
-        {
-            _checksum = newSum;
-        }
-        #endregion
-
-    }
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/Deflater.cs gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/Deflater.cs
--- gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/Deflater.cs	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/Deflater.cs	1970-01-01 01:00:00.000000000 +0100
@@ -1,106 +0,0 @@
-//
-//  Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.Diagnostics;
-using System.Runtime.InteropServices;
-
-namespace DotZLib
-{
-
-    /// <summary>
-    /// Implements a data compressor, using the deflate algorithm in the ZLib dll
-    /// </summary>
-	public sealed class Deflater : CodecBase
-	{
-        #region Dll imports
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl, CharSet=CharSet.Ansi)]
-        private static extern int deflateInit_(ref ZStream sz, int level, string vs, int size);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int deflate(ref ZStream sz, int flush);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int deflateReset(ref ZStream sz);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int deflateEnd(ref ZStream sz);
-        #endregion
-
-        /// <summary>
-        /// Constructs an new instance of the <c>Deflater</c>
-        /// </summary>
-        /// <param name="level">The compression level to use for this <c>Deflater</c></param>
-		public Deflater(CompressLevel level) : base()
-		{
-            int retval = deflateInit_(ref _ztream, (int)level, Info.Version, Marshal.SizeOf(_ztream));
-            if (retval != 0)
-                throw new ZLibException(retval, "Could not initialize deflater");
-
-            resetOutput();
-		}
-
-        /// <summary>
-        /// Adds more data to the codec to be processed.
-        /// </summary>
-        /// <param name="data">Byte array containing the data to be added to the codec</param>
-        /// <param name="offset">The index of the first byte to add from <c>data</c></param>
-        /// <param name="count">The number of bytes to add</param>
-        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
-        public override void Add(byte[] data, int offset, int count)
-        {
-            if (data == null) throw new ArgumentNullException();
-            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();
-            if ((offset+count) > data.Length) throw new ArgumentException();
-            
-            int total = count;
-            int inputIndex = offset;
-            int err = 0;
-
-            while (err >= 0 && inputIndex < total)
-            {
-                copyInput(data, inputIndex, Math.Min(total - inputIndex, kBufferSize));
-                while (err >= 0 && _ztream.avail_in > 0)
-                {
-                    err = deflate(ref _ztream, (int)FlushTypes.None);
-                    if (err == 0)
-                        while (_ztream.avail_out == 0)
-                        {
-                            OnDataAvailable();
-                            err = deflate(ref _ztream, (int)FlushTypes.None);
-                        }
-                    inputIndex += (int)_ztream.total_in;
-                }
-            }
-            setChecksum( _ztream.adler );
-        }
-
-
-        /// <summary>
-        /// Finishes up any pending data that needs to be processed and handled.
-        /// </summary>
-        public override void Finish()
-        {
-            int err;
-            do 
-            {
-                err = deflate(ref _ztream, (int)FlushTypes.Finish);
-                OnDataAvailable();
-            }
-            while (err == 0);
-            setChecksum( _ztream.adler );
-            deflateReset(ref _ztream);
-            resetOutput();
-        }
-
-        /// <summary>
-        /// Closes the internal zlib deflate stream
-        /// </summary>
-        protected override void CleanUp() { deflateEnd(ref _ztream); }
-
-    }
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/DotZLib.cs gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/DotZLib.cs
--- gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/DotZLib.cs	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/DotZLib.cs	1970-01-01 01:00:00.000000000 +0100
@@ -1,288 +0,0 @@
-//
-//  Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.IO;
-using System.Runtime.InteropServices;
-using System.Text;
-
-
-namespace DotZLib
-{
-
-    #region Internal types
-
-    /// <summary>
-    /// Defines constants for the various flush types used with zlib
-    /// </summary>
-    internal enum FlushTypes 
-    {
-        None,  Partial,  Sync,  Full,  Finish,  Block
-    }
-
-    #region ZStream structure
-    // internal mapping of the zlib zstream structure for marshalling
-    [StructLayoutAttribute(LayoutKind.Sequential, Pack=4, Size=0, CharSet=CharSet.Ansi)]
-    internal struct ZStream
-    {
-        public IntPtr next_in;
-        public uint avail_in;
-        public uint total_in;
-
-        public IntPtr next_out;
-        public uint avail_out;
-        public uint total_out;
-
-        [MarshalAs(UnmanagedType.LPStr)]
-        string msg; 
-        uint state;
-
-        uint zalloc;
-        uint zfree;
-        uint opaque;
-
-        int data_type;
-        public uint adler;
-        uint reserved;
-    }
-
-    #endregion
-    
-    #endregion
-
-    #region Public enums
-    /// <summary>
-    /// Defines constants for the available compression levels in zlib
-    /// </summary>
-    public enum CompressLevel : int
-    {
-        /// <summary>
-        /// The default compression level with a reasonable compromise between compression and speed
-        /// </summary>
-        Default = -1,   
-        /// <summary>
-        /// No compression at all. The data are passed straight through.
-        /// </summary>
-        None = 0,
-        /// <summary>
-        /// The maximum compression rate available.
-        /// </summary>
-        Best = 9,   
-        /// <summary>
-        /// The fastest available compression level.
-        /// </summary>
-        Fastest = 1
-    }
-    #endregion
-
-    #region Exception classes
-    /// <summary>
-    /// The exception that is thrown when an error occurs on the zlib dll
-    /// </summary>
-    public class ZLibException : ApplicationException
-    {
-        /// <summary>
-        /// Initializes a new instance of the <see cref="ZLibException"/> class with a specified 
-        /// error message and error code
-        /// </summary>
-        /// <param name="errorCode">The zlib error code that caused the exception</param>
-        /// <param name="msg">A message that (hopefully) describes the error</param>
-        public ZLibException(int errorCode, string msg) : base(String.Format("ZLib error {0} {1}", errorCode, msg))
-        {
-        }
-
-        /// <summary>
-        /// Initializes a new instance of the <see cref="ZLibException"/> class with a specified 
-        /// error code
-        /// </summary>
-        /// <param name="errorCode">The zlib error code that caused the exception</param>
-        public ZLibException(int errorCode) : base(String.Format("ZLib error {0}", errorCode))
-        {
-        }
-    }
-    #endregion
-
-    #region Interfaces
-
-    /// <summary>
-    /// Declares methods and properties that enables a running checksum to be calculated 
-    /// </summary>
-    public interface ChecksumGenerator
-    {
-        /// <summary>
-        /// Gets the current value of the checksum
-        /// </summary>
-        uint Value { get; }
-
-        /// <summary>
-        /// Clears the current checksum to 0
-        /// </summary>
-        void Reset();
-
-        /// <summary>
-        /// Updates the current checksum with an array of bytes
-        /// </summary>
-        /// <param name="data">The data to update the checksum with</param>
-        void Update(byte[] data);
-
-        /// <summary>
-        /// Updates the current checksum with part of an array of bytes
-        /// </summary>
-        /// <param name="data">The data to update the checksum with</param>
-        /// <param name="offset">Where in <c>data</c> to start updating</param>
-        /// <param name="count">The number of bytes from <c>data</c> to use</param>
-        /// <exception cref="ArgumentException">The sum of offset and count is larger than the length of <c>data</c></exception>
-        /// <exception cref="ArgumentNullException"><c>data</c> is a null reference</exception>
-        /// <exception cref="ArgumentOutOfRangeException">Offset or count is negative.</exception>
-        void Update(byte[] data, int offset, int count);
-
-        /// <summary>
-        /// Updates the current checksum with the data from a string
-        /// </summary>
-        /// <param name="data">The string to update the checksum with</param>
-        /// <remarks>The characters in the string are converted by the UTF-8 encoding</remarks>
-        void Update(string data);
-
-        /// <summary>
-        /// Updates the current checksum with the data from a string, using a specific encoding
-        /// </summary>
-        /// <param name="data">The string to update the checksum with</param>
-        /// <param name="encoding">The encoding to use</param>
-        void Update(string data, Encoding encoding);
-    }
-
-
-    /// <summary>
-    /// Represents the method that will be called from a codec when new data
-    /// are available.
-    /// </summary>
-    /// <paramref name="data">The byte array containing the processed data</paramref>
-    /// <paramref name="startIndex">The index of the first processed byte in <c>data</c></paramref>
-    /// <paramref name="count">The number of processed bytes available</paramref>
-    /// <remarks>On return from this method, the data may be overwritten, so grab it while you can. 
-    /// You cannot assume that startIndex will be zero.
-    /// </remarks>
-    public delegate void DataAvailableHandler(byte[] data, int startIndex, int count);
-
-    /// <summary>
-    /// Declares methods and events for implementing compressors/decompressors
-    /// </summary>
-    public interface Codec
-    {
-        /// <summary>
-        /// Occurs when more processed data are available.
-        /// </summary>
-        event DataAvailableHandler DataAvailable;
-
-        /// <summary>
-        /// Adds more data to the codec to be processed.
-        /// </summary>
-        /// <param name="data">Byte array containing the data to be added to the codec</param>
-        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
-        void Add(byte[] data);
-
-        /// <summary>
-        /// Adds more data to the codec to be processed.
-        /// </summary>
-        /// <param name="data">Byte array containing the data to be added to the codec</param>
-        /// <param name="offset">The index of the first byte to add from <c>data</c></param>
-        /// <param name="count">The number of bytes to add</param>
-        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
-        void Add(byte[] data, int offset, int count);
-
-        /// <summary>
-        /// Finishes up any pending data that needs to be processed and handled.
-        /// </summary>
-        void Finish();
-
-        /// <summary>
-        /// Gets the checksum of the data that has been added so far
-        /// </summary>
-        uint Checksum { get; }
-
-
-    }
-
-    #endregion
-
-    #region Classes
-    /// <summary>
-    /// Encapsulates general information about the ZLib library
-    /// </summary>
-    public class Info
-    {
-        #region DLL imports
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern uint zlibCompileFlags();
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern string zlibVersion();
-        #endregion
-
-        #region Private stuff
-        private uint _flags;
-
-        // helper function that unpacks a bitsize mask
-        private static int bitSize(uint bits)
-        {
-            switch (bits)
-            {
-                case 0: return 16;
-                case 1: return 32;
-                case 2: return 64;
-            }
-            return -1;
-        }
-        #endregion
-
-        /// <summary>
-        /// Constructs an instance of the <c>Info</c> class.
-        /// </summary>
-        public Info()
-        {
-            _flags = zlibCompileFlags();
-        }
-
-        /// <summary>
-        /// True if the library is compiled with debug info
-        /// </summary>
-        public bool HasDebugInfo { get { return 0 != (_flags & 0x100); } }
-
-        /// <summary>
-        /// True if the library is compiled with assembly optimizations
-        /// </summary>
-        public bool UsesAssemblyCode { get { return 0 != (_flags & 0x200); } }
-
-        /// <summary>
-        /// Gets the size of the unsigned int that was compiled into Zlib
-        /// </summary>
-        public int SizeOfUInt { get { return bitSize(_flags & 3); } }
-
-        /// <summary>
-        /// Gets the size of the unsigned long that was compiled into Zlib
-        /// </summary>
-        public int SizeOfULong { get { return bitSize((_flags >> 2) & 3); } }
-
-        /// <summary>
-        /// Gets the size of the pointers that were compiled into Zlib
-        /// </summary>
-        public int SizeOfPointer { get { return bitSize((_flags >> 4) & 3); } }
-
-        /// <summary>
-        /// Gets the size of the z_off_t type that was compiled into Zlib
-        /// </summary>
-        public int SizeOfOffset { get { return bitSize((_flags >> 6) & 3); } }
-
-        /// <summary>
-        /// Gets the version of ZLib as a string, e.g. "1.2.1"
-        /// </summary>
-        public static string Version { get { return zlibVersion(); } }
-    }
-
-    #endregion
-
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/DotZLib.csproj gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/DotZLib.csproj
--- gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/DotZLib.csproj	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/DotZLib.csproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,141 +0,0 @@
-<VisualStudioProject>
-    <CSHARP
-        ProjectType = "Local"
-        ProductVersion = "7.10.3077"
-        SchemaVersion = "2.0"
-        ProjectGuid = "{BB1EE0B1-1808-46CB-B786-949D91117FC5}"
-    >
-        <Build>
-            <Settings
-                ApplicationIcon = ""
-                AssemblyKeyContainerName = ""
-                AssemblyName = "DotZLib"
-                AssemblyOriginatorKeyFile = ""
-                DefaultClientScript = "JScript"
-                DefaultHTMLPageLayout = "Grid"
-                DefaultTargetSchema = "IE50"
-                DelaySign = "false"
-                OutputType = "Library"
-                PreBuildEvent = ""
-                PostBuildEvent = ""
-                RootNamespace = "DotZLib"
-                RunPostBuildEvent = "OnBuildSuccess"
-                StartupObject = ""
-            >
-                <Config
-                    Name = "Debug"
-                    AllowUnsafeBlocks = "false"
-                    BaseAddress = "285212672"
-                    CheckForOverflowUnderflow = "false"
-                    ConfigurationOverrideFile = ""
-                    DefineConstants = "DEBUG;TRACE"
-                    DocumentationFile = "docs\DotZLib.xml"
-                    DebugSymbols = "true"
-                    FileAlignment = "4096"
-                    IncrementalBuild = "false"
-                    NoStdLib = "false"
-                    NoWarn = "1591"
-                    Optimize = "false"
-                    OutputPath = "bin\Debug\"
-                    RegisterForComInterop = "false"
-                    RemoveIntegerChecks = "false"
-                    TreatWarningsAsErrors = "false"
-                    WarningLevel = "4"
-                />
-                <Config
-                    Name = "Release"
-                    AllowUnsafeBlocks = "false"
-                    BaseAddress = "285212672"
-                    CheckForOverflowUnderflow = "false"
-                    ConfigurationOverrideFile = ""
-                    DefineConstants = "TRACE"
-                    DocumentationFile = "docs\DotZLib.xml"
-                    DebugSymbols = "false"
-                    FileAlignment = "4096"
-                    IncrementalBuild = "false"
-                    NoStdLib = "false"
-                    NoWarn = ""
-                    Optimize = "true"
-                    OutputPath = "bin\Release\"
-                    RegisterForComInterop = "false"
-                    RemoveIntegerChecks = "false"
-                    TreatWarningsAsErrors = "false"
-                    WarningLevel = "4"
-                />
-            </Settings>
-            <References>
-                <Reference
-                    Name = "System"
-                    AssemblyName = "System"
-                    HintPath = "C:\WINNT\Microsoft.NET\Framework\v1.1.4322\System.dll"
-                />
-                <Reference
-                    Name = "System.Data"
-                    AssemblyName = "System.Data"
-                    HintPath = "C:\WINNT\Microsoft.NET\Framework\v1.1.4322\System.Data.dll"
-                />
-                <Reference
-                    Name = "System.XML"
-                    AssemblyName = "System.Xml"
-                    HintPath = "C:\WINNT\Microsoft.NET\Framework\v1.1.4322\System.XML.dll"
-                />
-                <Reference
-                    Name = "nunit.framework"
-                    AssemblyName = "nunit.framework"
-                    HintPath = "E:\apps\NUnit V2.1\\bin\nunit.framework.dll"
-                    AssemblyFolderKey = "hklm\dn\nunit.framework"
-                />
-            </References>
-        </Build>
-        <Files>
-            <Include>
-                <File
-                    RelPath = "AssemblyInfo.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "ChecksumImpl.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "CircularBuffer.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "CodecBase.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "Deflater.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "DotZLib.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "GZipStream.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "Inflater.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-                <File
-                    RelPath = "UnitTests.cs"
-                    SubType = "Code"
-                    BuildAction = "Compile"
-                />
-            </Include>
-        </Files>
-    </CSHARP>
-</VisualStudioProject>
-
diff -Nbaur gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/GZipStream.cs gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/GZipStream.cs
--- gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/GZipStream.cs	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/GZipStream.cs	1970-01-01 01:00:00.000000000 +0100
@@ -1,301 +0,0 @@
-//
-//  Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.IO;
-using System.Runtime.InteropServices;
-
-namespace DotZLib
-{
-	/// <summary>
-	/// Implements a compressed <see cref="Stream"/>, in GZip (.gz) format.
-	/// </summary>
-	public class GZipStream : Stream, IDisposable
-	{
-        #region Dll Imports
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl, CharSet=CharSet.Ansi)]
-        private static extern IntPtr gzopen(string name, string mode);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int gzclose(IntPtr gzFile);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int gzwrite(IntPtr gzFile, int data, int length);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int gzread(IntPtr gzFile, int data, int length);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int gzgetc(IntPtr gzFile);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int gzputc(IntPtr gzFile, int c);
-
-        #endregion
-
-        #region Private data
-        private IntPtr _gzFile;
-        private bool _isDisposed = false;
-        private bool _isWriting;
-        #endregion
-
-        #region Constructors
-        /// <summary>
-        /// Creates a new file as a writeable GZipStream
-        /// </summary>
-        /// <param name="fileName">The name of the compressed file to create</param>
-        /// <param name="level">The compression level to use when adding data</param>
-        /// <exception cref="ZLibException">If an error occurred in the internal zlib function</exception>
-		public GZipStream(string fileName, CompressLevel level)
-		{
-            _isWriting = true;
-            _gzFile = gzopen(fileName, String.Format("wb{0}", (int)level));
-            if (_gzFile == IntPtr.Zero)
-                throw new ZLibException(-1, "Could not open " + fileName);
-		}
-
-        /// <summary>
-        /// Opens an existing file as a readable GZipStream
-        /// </summary>
-        /// <param name="fileName">The name of the file to open</param>
-        /// <exception cref="ZLibException">If an error occurred in the internal zlib function</exception>
-        public GZipStream(string fileName)
-        {
-            _isWriting = false;
-            _gzFile = gzopen(fileName, "rb");
-            if (_gzFile == IntPtr.Zero)
-                throw new ZLibException(-1, "Could not open " + fileName);
-
-        }
-        #endregion
-
-        #region Access properties
-        /// <summary>
-        /// Returns true of this stream can be read from, false otherwise
-        /// </summary>
-        public override bool CanRead
-        {
-            get
-            {
-                return !_isWriting;
-            }
-        }
-    
-
-        /// <summary>
-        /// Returns false.
-        /// </summary>
-        public override bool CanSeek
-        {
-            get
-            {
-                return false;
-            }
-        }
-    
-        /// <summary>
-        /// Returns true if this tsream is writeable, false otherwise
-        /// </summary>
-        public override bool CanWrite
-        {
-            get
-            {
-                return _isWriting;
-            }
-        }
-        #endregion
-    
-        #region Destructor & IDispose stuff
-
-        /// <summary>
-        /// Destroys this instance
-        /// </summary>
-        ~GZipStream()
-        {
-            cleanUp(false);
-        }
-
-        /// <summary>
-        /// Closes the external file handle
-        /// </summary>
-        public void Dispose()
-        {
-            cleanUp(true);
-        }
-
-        // Does the actual closing of the file handle.
-        private void cleanUp(bool isDisposing)
-        {
-            if (!_isDisposed)
-            {
-                gzclose(_gzFile);
-                _isDisposed = true;
-            }
-        }
-        #endregion
-    
-        #region Basic reading and writing
-        /// <summary>
-        /// Attempts to read a number of bytes from the stream.
-        /// </summary>
-        /// <param name="buffer">The destination data buffer</param>
-        /// <param name="offset">The index of the first destination byte in <c>buffer</c></param>
-        /// <param name="count">The number of bytes requested</param>
-        /// <returns>The number of bytes read</returns>
-        /// <exception cref="ArgumentNullException">If <c>buffer</c> is null</exception>
-        /// <exception cref="ArgumentOutOfRangeException">If <c>count</c> or <c>offset</c> are negative</exception>
-        /// <exception cref="ArgumentException">If <c>offset</c>  + <c>count</c> is &gt; buffer.Length</exception>
-        /// <exception cref="NotSupportedException">If this stream is not readable.</exception>
-        /// <exception cref="ObjectDisposedException">If this stream has been disposed.</exception>
-        public override int Read(byte[] buffer, int offset, int count)
-        {
-            if (!CanRead) throw new NotSupportedException();
-            if (buffer == null) throw new ArgumentNullException();
-            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();
-            if ((offset+count) > buffer.Length) throw new ArgumentException();
-            if (_isDisposed) throw new ObjectDisposedException("GZipStream");
-
-            GCHandle h = GCHandle.Alloc(buffer, GCHandleType.Pinned);
-            int result;
-            try
-            {
-                result = gzread(_gzFile, h.AddrOfPinnedObject().ToInt32() + offset, count);
-                if (result < 0)
-                    throw new IOException();
-            }
-            finally
-            {
-                h.Free();
-            }
-            return result;
-        }
-
-        /// <summary>
-        /// Attempts to read a single byte from the stream.
-        /// </summary>
-        /// <returns>The byte that was read, or -1 in case of error or End-Of-File</returns>
-        public override int ReadByte()
-        {
-            if (!CanRead) throw new NotSupportedException();
-            if (_isDisposed) throw new ObjectDisposedException("GZipStream");
-            return gzgetc(_gzFile);
-        }
-
-        /// <summary>
-        /// Writes a number of bytes to the stream
-        /// </summary>
-        /// <param name="buffer"></param>
-        /// <param name="offset"></param>
-        /// <param name="count"></param>
-        /// <exception cref="ArgumentNullException">If <c>buffer</c> is null</exception>
-        /// <exception cref="ArgumentOutOfRangeException">If <c>count</c> or <c>offset</c> are negative</exception>
-        /// <exception cref="ArgumentException">If <c>offset</c>  + <c>count</c> is &gt; buffer.Length</exception>
-        /// <exception cref="NotSupportedException">If this stream is not writeable.</exception>
-        /// <exception cref="ObjectDisposedException">If this stream has been disposed.</exception>
-        public override void Write(byte[] buffer, int offset, int count)
-        {
-            if (!CanWrite) throw new NotSupportedException();
-            if (buffer == null) throw new ArgumentNullException();
-            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();
-            if ((offset+count) > buffer.Length) throw new ArgumentException();
-            if (_isDisposed) throw new ObjectDisposedException("GZipStream");
-
-            GCHandle h = GCHandle.Alloc(buffer, GCHandleType.Pinned);
-            try
-            {
-                int result = gzwrite(_gzFile, h.AddrOfPinnedObject().ToInt32() + offset, count);
-                if (result < 0)
-                    throw new IOException();
-            }
-            finally
-            {
-                h.Free();
-            }
-        }
-
-        /// <summary>
-        /// Writes a single byte to the stream
-        /// </summary>
-        /// <param name="value">The byte to add to the stream.</param>
-        /// <exception cref="NotSupportedException">If this stream is not writeable.</exception>
-        /// <exception cref="ObjectDisposedException">If this stream has been disposed.</exception>
-        public override void WriteByte(byte value)
-        {
-            if (!CanWrite) throw new NotSupportedException();
-            if (_isDisposed) throw new ObjectDisposedException("GZipStream");
-
-            int result = gzputc(_gzFile, (int)value);
-            if (result < 0)
-                throw new IOException();
-        }
-        #endregion
-
-        #region Position & length stuff
-        /// <summary>
-        /// Not supported.
-        /// </summary>
-        /// <param name="value"></param>
-        /// <exception cref="NotSupportedException">Always thrown</exception>
-        public override void SetLength(long value)
-        {
-            throw new NotSupportedException();
-        }
-    
-        /// <summary>
-        ///  Not suppported.
-        /// </summary>
-        /// <param name="offset"></param>
-        /// <param name="origin"></param>
-        /// <returns></returns>
-        /// <exception cref="NotSupportedException">Always thrown</exception>
-        public override long Seek(long offset, SeekOrigin origin)
-        {
-            throw new NotSupportedException();
-        }
-    
-        /// <summary>
-        /// Flushes the <c>GZipStream</c>.
-        /// </summary>
-        /// <remarks>In this implementation, this method does nothing. This is because excessive
-        /// flushing may degrade the achievable compression rates.</remarks>
-        public override void Flush()
-        {
-            // left empty on purpose
-        }
-    
-        /// <summary>
-        /// Gets/sets the current position in the <c>GZipStream</c>. Not suppported.
-        /// </summary>
-        /// <remarks>In this implementation this property is not supported</remarks>
-        /// <exception cref="NotSupportedException">Always thrown</exception>
-        public override long Position
-        {
-            get
-            {
-                throw new NotSupportedException();
-            }
-            set
-            {
-                throw new NotSupportedException();
-            }
-        }
-    
-        /// <summary>
-        /// Gets the size of the stream. Not suppported.
-        /// </summary>
-        /// <remarks>In this implementation this property is not supported</remarks>
-        /// <exception cref="NotSupportedException">Always thrown</exception>
-        public override long Length
-        {
-            get
-            {
-                throw new NotSupportedException();
-            }
-        }
-        #endregion
-    }
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/Inflater.cs gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/Inflater.cs
--- gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/Inflater.cs	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/Inflater.cs	1970-01-01 01:00:00.000000000 +0100
@@ -1,105 +0,0 @@
-//
-//  Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.Diagnostics;
-using System.Runtime.InteropServices;
-
-namespace DotZLib
-{
-    
-    /// <summary>
-    /// Implements a data decompressor, using the inflate algorithm in the ZLib dll
-    /// </summary>
-    public class Inflater : CodecBase
-	{
-        #region Dll imports
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl, CharSet=CharSet.Ansi)]
-        private static extern int inflateInit_(ref ZStream sz, string vs, int size);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int inflate(ref ZStream sz, int flush);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int inflateReset(ref ZStream sz);
-
-        [DllImport("ZLIB1.dll", CallingConvention=CallingConvention.Cdecl)]
-        private static extern int inflateEnd(ref ZStream sz);
-        #endregion
-
-        /// <summary>
-        /// Constructs an new instance of the <c>Inflater</c>
-        /// </summary>
-        public Inflater() : base()
-		{
-            int retval = inflateInit_(ref _ztream, Info.Version, Marshal.SizeOf(_ztream));
-            if (retval != 0)
-                throw new ZLibException(retval, "Could not initialize inflater");
-
-            resetOutput();
-        }
-
-
-        /// <summary>
-        /// Adds more data to the codec to be processed.
-        /// </summary>
-        /// <param name="data">Byte array containing the data to be added to the codec</param>
-        /// <param name="offset">The index of the first byte to add from <c>data</c></param>
-        /// <param name="count">The number of bytes to add</param>
-        /// <remarks>Adding data may, or may not, raise the <c>DataAvailable</c> event</remarks>
-        public override void Add(byte[] data, int offset, int count)
-        {
-            if (data == null) throw new ArgumentNullException();
-            if (offset < 0 || count < 0) throw new ArgumentOutOfRangeException();
-            if ((offset+count) > data.Length) throw new ArgumentException();
-
-            int total = count;
-            int inputIndex = offset;
-            int err = 0;
-
-            while (err >= 0 && inputIndex < total)
-            {
-                copyInput(data, inputIndex, Math.Min(total - inputIndex, kBufferSize));
-                err = inflate(ref _ztream, (int)FlushTypes.None);
-                if (err == 0)
-                    while (_ztream.avail_out == 0)
-                    {
-                        OnDataAvailable();
-                        err = inflate(ref _ztream, (int)FlushTypes.None);
-                    }
-
-                inputIndex += (int)_ztream.total_in;
-            }
-            setChecksum( _ztream.adler );
-        }
-
-
-        /// <summary>
-        /// Finishes up any pending data that needs to be processed and handled.
-        /// </summary>
-        public override void Finish()
-        {
-            int err;
-            do 
-            {
-                err = inflate(ref _ztream, (int)FlushTypes.Finish);
-                OnDataAvailable();
-            }
-            while (err == 0);
-            setChecksum( _ztream.adler );
-            inflateReset(ref _ztream);
-            resetOutput();
-        }
-
-        /// <summary>
-        /// Closes the internal zlib inflate stream
-        /// </summary>
-        protected override void CleanUp() { inflateEnd(ref _ztream); }
-
-
-	}
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/UnitTests.cs gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/UnitTests.cs
--- gcc-4.6.3/zlib/contrib/dotzlib/DotZLib/UnitTests.cs	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib/UnitTests.cs	1970-01-01 01:00:00.000000000 +0100
@@ -1,274 +0,0 @@
-//
-//  Copyright Henrik Ravn 2004
-//
-// Use, modification and distribution are subject to the Boost Software License, Version 1.0. 
-// (See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-//
-
-using System;
-using System.Collections;
-using System.IO;
-
-// uncomment the define below to include unit tests
-//#define nunit
-#if nunit
-using NUnit.Framework;
-
-// Unit tests for the DotZLib class library
-// ----------------------------------------
-//
-// Use this with NUnit 2 from http://www.nunit.org
-//
-
-namespace DotZLibTests
-{
-    using DotZLib;
-
-    // helper methods
-    internal class Utils
-    {
-        public static bool byteArrEqual( byte[] lhs, byte[] rhs )
-        {
-            if (lhs.Length != rhs.Length)
-                return false;
-            for (int i = lhs.Length-1; i >= 0; --i)
-                if (lhs[i] != rhs[i])
-                    return false;
-            return true;
-        }
-
-    }
-
-
-    [TestFixture]
-    public class CircBufferTests
-    {
-        #region Circular buffer tests
-        [Test]
-        public void SinglePutGet()
-        {
-            CircularBuffer buf = new CircularBuffer(10);
-            Assert.AreEqual( 0, buf.Size );
-            Assert.AreEqual( -1, buf.Get() );
-
-            Assert.IsTrue(buf.Put( 1 ));
-            Assert.AreEqual( 1, buf.Size );
-            Assert.AreEqual( 1, buf.Get() );
-            Assert.AreEqual( 0, buf.Size );
-            Assert.AreEqual( -1, buf.Get() );
-        }
-
-        [Test]
-        public void BlockPutGet()
-        {
-            CircularBuffer buf = new CircularBuffer(10);
-            byte[] arr = {1,2,3,4,5,6,7,8,9,10};
-            Assert.AreEqual( 10, buf.Put(arr,0,10) );
-            Assert.AreEqual( 10, buf.Size );
-            Assert.IsFalse( buf.Put(11) );
-            Assert.AreEqual( 1, buf.Get() );
-            Assert.IsTrue( buf.Put(11) );
-
-            byte[] arr2 = (byte[])arr.Clone();
-            Assert.AreEqual( 9, buf.Get(arr2,1,9) );
-            Assert.IsTrue( Utils.byteArrEqual(arr,arr2) );
-        }
-
-        #endregion
-    }
-
-    [TestFixture]
-    public class ChecksumTests
-    {
-        #region CRC32 Tests
-        [Test]
-        public void CRC32_Null()
-        {
-            CRC32Checksum crc32 = new CRC32Checksum();
-            Assert.AreEqual( 0, crc32.Value );
-
-            crc32 = new CRC32Checksum(1);
-            Assert.AreEqual( 1, crc32.Value );
-
-            crc32 = new CRC32Checksum(556);
-            Assert.AreEqual( 556, crc32.Value );
-        }
-
-        [Test]
-        public void CRC32_Data()
-        {
-            CRC32Checksum crc32 = new CRC32Checksum();
-            byte[] data = { 1,2,3,4,5,6,7 };
-            crc32.Update(data);
-            Assert.AreEqual( 0x70e46888, crc32.Value  );
-
-            crc32 = new CRC32Checksum();
-            crc32.Update("penguin");
-            Assert.AreEqual( 0x0e5c1a120, crc32.Value );
-
-            crc32 = new CRC32Checksum(1);
-            crc32.Update("penguin");
-            Assert.AreEqual(0x43b6aa94, crc32.Value);
-
-        }
-        #endregion
-
-        #region Adler tests
-
-        [Test]
-        public void Adler_Null()
-        {
-            AdlerChecksum adler = new AdlerChecksum();
-            Assert.AreEqual(0, adler.Value);
-
-            adler = new AdlerChecksum(1);
-            Assert.AreEqual( 1, adler.Value );
-
-            adler = new AdlerChecksum(556);
-            Assert.AreEqual( 556, adler.Value );
-        }
-
-        [Test]
-        public void Adler_Data()
-        {
-            AdlerChecksum adler = new AdlerChecksum(1);
-            byte[] data = { 1,2,3,4,5,6,7 };
-            adler.Update(data);
-            Assert.AreEqual( 0x5b001d, adler.Value  );
-
-            adler = new AdlerChecksum();
-            adler.Update("penguin");
-            Assert.AreEqual(0x0bcf02f6, adler.Value );
-
-            adler = new AdlerChecksum(1);
-            adler.Update("penguin");
-            Assert.AreEqual(0x0bd602f7, adler.Value);
-
-        }
-        #endregion
-    }
-
-    [TestFixture]
-    public class InfoTests
-    {
-        #region Info tests
-        [Test]
-        public void Info_Version()
-        {
-            Info info = new Info();
-            Assert.AreEqual("1.2.3", Info.Version);
-            Assert.AreEqual(32, info.SizeOfUInt);
-            Assert.AreEqual(32, info.SizeOfULong);
-            Assert.AreEqual(32, info.SizeOfPointer);
-            Assert.AreEqual(32, info.SizeOfOffset);
-        }
-        #endregion
-    }
-
-    [TestFixture]
-    public class DeflateInflateTests
-    {
-        #region Deflate tests
-        [Test]
-        public void Deflate_Init()
-        {
-            using (Deflater def = new Deflater(CompressLevel.Default))
-            {
-            }
-        }
-
-        private ArrayList compressedData = new ArrayList();
-        private uint adler1;
-
-        private ArrayList uncompressedData = new ArrayList();
-        private uint adler2;
-
-        public void CDataAvail(byte[] data, int startIndex, int count)
-        {
-            for (int i = 0; i < count; ++i)
-                compressedData.Add(data[i+startIndex]);
-        }
-
-        [Test]
-        public void Deflate_Compress()
-        {
-            compressedData.Clear();
-
-            byte[] testData = new byte[35000];
-            for (int i = 0; i < testData.Length; ++i)
-                testData[i] = 5;
-
-            using (Deflater def = new Deflater((CompressLevel)5))
-            {
-                def.DataAvailable += new DataAvailableHandler(CDataAvail);
-                def.Add(testData);
-                def.Finish();
-                adler1 = def.Checksum;
-            }
-        }
-        #endregion
-
-        #region Inflate tests
-        [Test]
-        public void Inflate_Init()
-        {
-            using (Inflater inf = new Inflater())
-            {
-            }
-        }
-
-        private void DDataAvail(byte[] data, int startIndex, int count)
-        {
-            for (int i = 0; i < count; ++i)
-                uncompressedData.Add(data[i+startIndex]);
-        }
-
-        [Test]
-        public void Inflate_Expand()
-        { 
-            uncompressedData.Clear();
-
-            using (Inflater inf = new Inflater())
-            {
-                inf.DataAvailable += new DataAvailableHandler(DDataAvail);
-                inf.Add((byte[])compressedData.ToArray(typeof(byte)));
-                inf.Finish();
-                adler2 = inf.Checksum;
-            }
-            Assert.AreEqual( adler1, adler2 );
-        }
-        #endregion
-    }
-
-    [TestFixture]
-    public class GZipStreamTests
-    {
-        #region GZipStream test
-        [Test]
-        public void GZipStream_WriteRead()
-        {
-            using (GZipStream gzOut = new GZipStream("gzstream.gz", CompressLevel.Best))
-            {
-                BinaryWriter writer = new BinaryWriter(gzOut);
-                writer.Write("hi there");
-                writer.Write(Math.PI);
-                writer.Write(42);
-            }
-
-            using (GZipStream gzIn = new GZipStream("gzstream.gz"))
-            {
-                BinaryReader reader = new BinaryReader(gzIn);
-                string s = reader.ReadString();
-                Assert.AreEqual("hi there",s);
-                double d = reader.ReadDouble();
-                Assert.AreEqual(Math.PI, d);
-                int i = reader.ReadInt32();
-                Assert.AreEqual(42,i);
-            }
-
-        }
-        #endregion
-	}
-}
-
-#endif
\ No newline at end of file
diff -Nbaur gcc-4.6.3/zlib/contrib/dotzlib/DotZLib.build gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib.build
--- gcc-4.6.3/zlib/contrib/dotzlib/DotZLib.build	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib.build	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="utf-8" ?>
-<project name="DotZLib" default="build" basedir="./DotZLib">
-	<description>A .Net wrapper library around ZLib1.dll</description>
-
-	<property name="nunit.location" value="c:/program files/NUnit V2.1/bin" />
-	<property name="build.root" value="bin" />
-	
-	<property name="debug" value="true" />
-	<property name="nunit" value="true" />
-
-	<property name="build.folder" value="${build.root}/debug/" if="${debug}" />
-	<property name="build.folder" value="${build.root}/release/" unless="${debug}" />
-
-	<target name="clean" description="Remove all generated files">
-		<delete dir="${build.root}" failonerror="false" />
-	</target>
-
-	<target name="build" description="compiles the source code">
-		
-		<mkdir dir="${build.folder}" />
-		<csc target="library" output="${build.folder}DotZLib.dll" debug="${debug}">
-			<references basedir="${nunit.location}">
-				<includes if="${nunit}" name="nunit.framework.dll" />
-			</references>
-			<sources>
-				<includes name="*.cs" />
-				<excludes name="UnitTests.cs" unless="${nunit}" />
-			</sources>
-			<arg value="/d:nunit" if="${nunit}" />
-		</csc>
-	</target>
-
-</project>
\ No newline at end of file
diff -Nbaur gcc-4.6.3/zlib/contrib/dotzlib/DotZLib.chm gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib.chm
--- gcc-4.6.3/zlib/contrib/dotzlib/DotZLib.chm	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib.chm	1970-01-01 01:00:00.000000000 +0100
@@ -1,213 +0,0 @@
-ITSF   `      LZ  |{ "|{ "`              x       T0      0                         ITSP   T   
-                         	  j].! "T   PMGLA          /   /#IDXHDRy /#ITBITS   	/#STRINGSs/#SYSTEM ,/#TOPICSy`/#URLSTR!R/#URLTBLYH	/#WINDOWS"L/$FIftiMaini	/$OBJINST*?/$WWAssociativeLinks/   /$WWAssociativeLinks/Property&/$WWKeywordLinks/   /$WWKeywordLinks/BTreenL/$WWKeywordLinks/Data:z/$WWKeywordLinks/Map4R/$WWKeywordLinks/Property /Documentation.hhcEx/Documentation.hhk=A/DotZLib.AdlerChecksum.htmlB-/DotZLib.AdlerChecksum.Update_overload_3.htmlyU,/DotZLib.AdlerChecksum.Update_overloads.htmlz&/DotZLib.AdlerChecksumConstructor.html '/DotZLib.AdlerChecksumConstructor1.html?S'/DotZLib.AdlerChecksumConstructor2.htmlm"/DotZLib.AdlerChecksumMembers.htmlXG"/DotZLib.AdlerChecksumMethods.html{/DotZLib.ChecksumGenerator.htmlNL%/DotZLib.ChecksumGenerator.Reset.htmlJ:1/DotZLib.ChecksumGenerator.Update_overload_1.html1/DotZLib.ChecksumGenerator.Update_overload_2.htmlv1/DotZLib.ChecksumGenerator.Update_overload_3.html_1/DotZLib.ChecksumGenerator.Update_overload_4.htmll+0/DotZLib.ChecksumGenerator.Update_overloads.htmlh%/DotZLib.ChecksumGenerator.Value.html<V,/DotZLib.ChecksumGeneratorBase._current.html0d#/DotZLib.ChecksumGeneratorBase.html)L)/DotZLib.ChecksumGeneratorBase.Reset.htmlB5/DotZLib.ChecksumGeneratorBase.Update_overload_1.html<55/DotZLib.ChecksumGeneratorBase.Update_overload_2.html
-25/DotZLib.ChecksumGeneratorBase.Update_overload_3.htmlAI5/DotZLib.ChecksumGeneratorBase.Update_overload_4.html{F4/DotZLib.ChecksumGeneratorBase.Update_overloads.htmlO,)/DotZLib.ChecksumGeneratorBase.Value.htmlXT./DotZLib.ChecksumGeneratorBaseConstructor.htmlND//DotZLib.ChecksumGeneratorBaseConstructor1.html>//DotZLib.ChecksumGeneratorBaseConstructor2.htmlP#)/DotZLib.ChecksumGeneratorBaseFields.htmls=*/DotZLib.ChecksumGeneratorBaseMembers.htmluY*/DotZLib.ChecksumGeneratorBaseMethods.html,a-/DotZLib.ChecksumGeneratorBaseProperties.htmlD&/DotZLib.ChecksumGeneratorMembers.htmlo&/DotZLib.ChecksumGeneratorMethods.html8)/DotZLib.ChecksumGeneratorProperties.html	3"/DotZLib.Codec.Add_overload_1.htmlb"/DotZLib.Codec.Add_overload_2.htmlJK!/DotZLib.Codec.Add_overloads.html!)/DotZLib.Codec.Checksum.html'A!/DotZLib.Codec.DataAvailable.htmlt&/DotZLib.Codec.Finish.htmlw1/DotZLib.Codec.htmlqm#/DotZLib.CodecBase._isDisposed.htmlI[&/DotZLib.CodecBase.Add_overload_1.htmlz&/DotZLib.CodecBase.Add_overload_2.html3G%/DotZLib.CodecBase.Add_overloads.html`S /DotZLib.CodecBase.Checksum.html\4/DotZLib.CodecBase.CleanUp.html!/DotZLib.CodecBase.copyInput.htmlJ%/DotZLib.CodecBase.DataAvailable.htmla#/DotZLib.CodecBase.Dispose.htmlZ# /DotZLib.CodecBase.Finalize.html}*/DotZLib.CodecBase.Finish.html'y/DotZLib.CodecBase.html1#/DotZLib.CodecBase.kBufferSize.html$A'/DotZLib.CodecBase.OnDataAvailable.html o#/DotZLib.CodecBase.resetOutput.html]#/DotZLib.CodecBase.setChecksum.htmll"/DotZLib.CodecBaseConstructor.htmla/DotZLib.CodecBaseEvents.html}d/DotZLib.CodecBaseFields.htmluT/DotZLib.CodecBaseMembers.htmlKI/DotZLib.CodecBaseMethods.htmlP!/DotZLib.CodecBaseProperties.htmlew/DotZLib.CodecEvents.html(L/DotZLib.CodecMembers.html^j/DotZLib.CodecMethods.htmlh9/DotZLib.CodecProperties.htmlH_/DotZLib.CompressLevel.html/DotZLib.CRC32Checksum.htmls-/DotZLib.CRC32Checksum.Update_overload_3.html3U,/DotZLib.CRC32Checksum.Update_overloads.html4&/DotZLib.CRC32ChecksumConstructor.htmlY '/DotZLib.CRC32ChecksumConstructor1.htmlyS'/DotZLib.CRC32ChecksumConstructor2.htmlLm"/DotZLib.CRC32ChecksumMembers.htmlG"/DotZLib.CRC32ChecksumMethods.html9{"/DotZLib.DataAvailableHandler.html<%/DotZLib.Deflater.Add_overload_1.htmlb$/DotZLib.Deflater.Add_overloads.htmlLD/DotZLib.Deflater.CleanUp.htmlr4/DotZLib.Deflater.Finish.html&&                       b@q
-	+	fwuVaJx > f PMGL,          /DotZLib.Deflater.htmlDK!/DotZLib.DeflaterConstructor.html/DotZLib.DeflaterMembers.html/DotZLib.DeflaterMethods.html/ /DotZLib.GZipStream.CanRead.html3f /DotZLib.GZipStream.CanSeek.html7!/DotZLib.GZipStream.CanWrite.htmlPe /DotZLib.GZipStream.Dispose.html|G!/DotZLib.GZipStream.Finalize.htmlC./DotZLib.GZipStream.Flush.htmlqc/DotZLib.GZipStream.htmlLZ/DotZLib.GZipStream.Length.html56!/DotZLib.GZipStream.Position.htmlkd/DotZLib.GZipStream.Read.htmlT7!/DotZLib.GZipStream.ReadByte.html*/DotZLib.GZipStream.Seek.html55"/DotZLib.GZipStream.SetLength.htmljs/DotZLib.GZipStream.Write.html]w"/DotZLib.GZipStream.WriteByte.htmlT#/DotZLib.GZipStreamConstructor.html{`$/DotZLib.GZipStreamConstructor1.html[P$/DotZLib.GZipStreamConstructor2.html+/DotZLib.GZipStreamMembers.html&U/DotZLib.GZipStreamMethods.htmlO-"/DotZLib.GZipStreamProperties.html9z/DotZLib.html9	%/DotZLib.Inflater.Add_overload_1.html`b$/DotZLib.Inflater.Add_overloads.htmlD/DotZLib.Inflater.CleanUp.htmlB4/DotZLib.Inflater.Finish.htmlv&/DotZLib.Inflater.htmlnE!/DotZLib.InflaterConstructor.html9F/DotZLib.InflaterMembers.html3/DotZLib.InflaterMethods.html/DotZLib.Info.HasDebugInfo.html4E/DotZLib.Info.htmlG/DotZLib.Info.SizeOfOffset.htmlyP /DotZLib.Info.SizeOfPointer.htmlIP/DotZLib.Info.SizeOfUInt.htmlJ/DotZLib.Info.SizeOfULong.htmlcN#/DotZLib.Info.UsesAssemblyCode.html1]/DotZLib.Info.Version.htmlB/DotZLib.InfoConstructor.html?/DotZLib.InfoMembers.htmlc;/DotZLib.InfoProperties.html]W/DotZLib.ZLibException.htmlP8&/DotZLib.ZLibExceptionConstructor.html '/DotZLib.ZLibExceptionConstructor1.html$'/DotZLib.ZLibExceptionConstructor2.html&"/DotZLib.ZLibExceptionMembers.html|	/MSDN.css+w/privmethod.gif/protfield.gift/protmethod.gif/protproperty.gif/pubevent.gife/pubmethod.gif~y/pubproperty.gifw}/static.gifw::DataSpace/NameList  <(::DataSpace/Storage/MSCompressed/Content B
-,::DataSpace/Storage/MSCompressed/ControlData j)::DataSpace/Storage/MSCompressed/SpanInfo b/::DataSpace/Storage/MSCompressed/Transform/List <&_::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/   i::DataSpace/Storage/MSCompressed/Transform/{7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/InstanceData/ResetTable otZLib.CodecBase.Add_overload_2.html3G%/DotZLib.CodecBase.Add_overloads.html`S /DotZLib.CodecBase.Checksum.html\4/DotZLib.CodecBase.CleanUp.html!/DotZLib.CodecBase.copyInput.htmlJ%/DotZLib.CodecBase.DataAvailable.htmla#/DotZLib.CodecBase.Dispose.htmlZ# /DotZLib.CodecBase.Finalize.html}*/DotZLib.CodecBase.Finish.html'y/DotZLib.CodecBase.html1#/DotZLib.CodecBase.kBufferSize.html$A'/DotZLib.CodecBase.OnDataAvailable.html o#/DotZLib.CodecBase.resetOutput.html]#/DotZLib.CodecBase.setChecksum.htmll"/DotZLib.CodecBaseConstructor.htmla/DotZLib.CodecBaseEvents.html}d/DotZLib.CodecBaseFields.htmluT/DotZLib.CodecBaseMembers.htmlKI/DotZLib.CodecBaseMethods.htmlP!/DotZLib.CodecBaseProperties.htmlew/DotZLib.CodecEvents.html(L/DotZLib.CodecMembers.html^j/DotZLib.CodecMethods.htmlh9/DotZLib.CodecProperties.htmlH_/DotZLib.CompressLevel.html/DotZLib.CRC32Checksum.htmls-/DotZLib.CRC32Checksum.Update_overload_3.html3U,/DotZLib.CRC32Checksum.Update_overloads.html4&/DotZLib.CRC32ChecksumConstructor.htmlY '/DotZLib.CRC32ChecksumConstructor1.htmlyS'/DotZLib.CRC32ChecksumConstructor2.htmlLm"/DotZLib.CRC32ChecksumMembers.htmlG"/DotZLib.CRC32ChecksumMethods.html9{"/DotZLib.DataAvailableHandler.html<%/DotZLib.Deflater.Add_overload_1.htmlb$/DotZLib.Deflater.Add_overloads.htmlLD/DotZLib.Deflater.CleanUp.htmlr4/DotZLib.Deflater.Finish.html&&                       b@q
-Q	/\'t0w B PMGI  / /DotZLib.Deflater.html                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               U n c o m p r e s s e d    M S C o m p r e s s e d   { 7 F C 2 8 9 4 0 - 9 D 3 1 - 1 1 D 0 s        LZXC                         (   s                                 r            z$      1      6      4C      H      V      _      v      T         
-  eLA	  HHA Version 4.74.8702  $ 	                W          DotZLib.html   Documentation   documentation  	 MsdnHelp   c        T#SM"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          3@3  U i?	eM0qC`Y-,1"4o+XG0  #2`E I %eNVB$KKFI,y 'K(([s._(lt)\`vEU AUn	]K  3 53 `o@{m$9v[{lYX6inZ44H"|lcBhI!1@@&@$\ #@D piLqZK!A'KpuIvc`w'F%,`%3Zged2>	$%TfYq5 |;M98VR:TTzxM~{kUIupr[ c>'W&s%5a{V 8@Z OA6 
-H\:&@j!Kja?"pj\UU&Meo
-w6vRP'B8Vr [b3oX"B6Fn@		m BDt=:OQ7Eh5]_7<@Jh=o#O}|mteU)wX#`O3rdR^8Q//xlK%R4!IhV"9%5.K*2Mo5	>?{>af`?>`;z('1 r
-n\No:%aY)`O2%UMMo)HdK	
-Z)|=IId@':!gV%0])
- 1Z1Z;jMR\:DdONxcBcU.l jXAG&|F;)%o$M3p@|vA+P96@}u2X(=)-]ZR-Gm7zrw"&X, XM_on^
-$mJM+Zl6o[^"e1NnX0GJ,z7tU`}VS"QyN/,DX/.	FrQ	4hfD_NdCjo!E0|NhpV,ZpxYZH
- /[/0bX_4|SiFHV'MD4#mI_C0)P`rRRP.Lbn/mn<,
-1~n U7w;a*b#zE:J PEFK+nz]CmF:mz}hjHf,MV	xKd$Qxu2fW!x^ =Q(jq['y{SH2H!QXs$ypk']++CZ8)1]qIUO	n%eIK5gwo@i<;c4e&>uF'b>
-[jB:D@)gZM`..#$&|8-tpTvIXi[5W%i0V^lpsPdroL/vZIGYt/XHoL\c:H{X^PUO1>n?1H([fWvrLz
-+D]+1/_)]\Y,Y\V[4EE1X[mIP.5-[FeXXB	KEhs+:eU rfr#{HKAnFl`g-=Fxrg7&@[:gb2T2&Qu7:q+Z~rPO0$\XH"sxzoI,v;o=T'-K]wvyz)bGiV	R:YOm-YWxgu!]0`$~] LMWsd)Uv_r~7wM{vrjv6@h]vtH	OJu1qj7`7?)$HU-gAbly_E7^g&9 m Nfe`CNpuxgV%7|bD9;3D
-UWs.,7&Q\RbOeVJ& 6Nr|GJ"ETIGKs8=6l"v
-1,;Kf/D~f+:5H/{}x'#"-x>C]Nr7D"O-	U=SK+qE
-}<P~F1cSveQl>A{O@r0HD.\*StVE bC0P|p2'{]>)-g8.i/rqT.nD)'fxc_r{2*g"ua`{i`-J2;HU;eekT]K$%E(X[zoiz,`))7Wg-<MNz<BlBLl`wrz-
-E6{
-I h &J$l0Do4))1B1-+$P.v]M/3+T_A
-gd%Wx	:c1pa>8W/
-boY ~uAmM>nY-:Wu|A%	4t;W>*{	+5>,6=BPRMG-M$/Z+x6a{/=fUrg |wU{O9bB_REnpwIdj]+T1{X%3kTPg64:~\	7d77A|Q]r>=?O)'+T4R( WY@GBC}	mOM;^xXdTn1Z8P_a=2nerGCw*	f"\(WF=2E;Npa+JO-;@]G[v{Y|.%u1A\o!QAp!hJJ]t0ysJBcH-qNptH3 I53G~r"BC)s)"mi2n fF6:5b6<Lc#r}7X_1@.U:d{
-m7 [lTaf@z
-c<eH5tCQ
-D@oaIj3Wc(Qd*yn
-w|:}u|m-Ii]B1fIle1EjQXTn,J@N|!%6r5^Op[i9qh7hx;`hA?nWOcO:
-Ar?7u=}	:l2DHWTP&xo=z7;^3mzF7R#G{j%: 7WsO{%Q_)R\+L W!'	5{58/*K^Z^mVf7p=^6w$TQTw1UHPiRRKyq"grzo (
-Ly~pCo=rEh"z>PPFd@{%mRM+|PP0j#T +?ezX(q[a.{iN*Wb)`:&0#6
-8
-V>TL*^u'?NQn!A:bLgR
-J|QdT|Y|[JqZoI`->qD<XA6q"C>|@i$z:0f^:[Dl
- Q,LT(Ls[G-m~{_Q(a/"p1XtO*4I)HR>BD>z*Ax\ZPA- _A2RQ:./8<Y?*#5P(6
-DoNFQ8<""^h#G	4. 7e&\aL>`D(aYv(}D&6^&ev/ZE-<K?@7$K.H>"	v%f~@y@C9`)x@U(p!Rh68   3@3  oeLAqn1Y-~AvfG   H`+>rCo]vXvwjmk/<ZmxWgn@  !  10?SeYnkiTM3-[tf*4Lx	2 ? ? s)B54cv7'fnj&Q3.YSgf@?AC=y-yZz	E4ej"ZE~tMPv@els; ;\{#D
-RbmC:,^MJ:_{M'	mvZZO902{.-@gT"J
-[K9Yv<';(<qbWBqzDA	P}Cx`YCKE8y/vrIe#Z|&W[s1Z_<GtP!cPc.Pp474;&Tc|+K'VDN:KAVabm/b+;lH!kUO>ccxv[OI:K) 
-Ngt'ZvvX3tbhTV%@
-h8h>$-fM`'1U)+fvbQ!M_bc\svD27g~y5/G3v#Sk7=Fj*~q-#zfV6;gAZh+3g93'A]8F[;Kie`s	1KM?j!@F*,1	=BE7d#t2 :3='$L_Mv;j_?Q1I.<Q"WM:5O8gj3dk|O^	eNCUN%l(S)ph
-D}Vj/ q4Au6F\A/m|cw9/^[/
-<2Yi;l&"]A9Qi1<Ih2s[?1;,~<RLE" *{`>Ga;hL$^OEq"6e-'F=gGw[P1RbG<Q%s8cbKh-8Hm/maXZFKcf$V!E'$)8uR9R0|1YgQ[CU"z^a5bN#Wy\/^TFbVw5$*"'cj>?"0=a3MP~Ep,pT"'P	)Fz@	=oP7GFFX}{a$_Y=!x=hWvGmiIf{5&,LYc2YQ1T4fn YOopL5O`}ePkS!&.e%%\-i2(9s@% ?1$1+*$`!lsB5_Bj8!EL1"Phg4B  $/yR!7y6.B]bKKK"XB|bv|zm-*e:x9ltt~ eDNH:h"i#gK W?=JGSE;h1<-M	dx	%cDR5*K/( t  @   c* @ S.NFnA$u/E.}3n/RjQ>1c[Uw0WR!O`"p.j5L8P&<mZ':h<ZP1x7*69[xnr/F'(3@=/&nw	}JC/^uR<>#L	8Lef}v\r^g]-C
-	'2}cEptAc%5#Axh
-H=I#'	B&t/gkPzAdT43rbzzBE#yZfi7ztn=g8~Ncb&:?o}0MJoBR-O<mE}8t);<j7/c(*
-MF=cVL{g&_o{Qy$ 3kL<w|(b~^l%GK8.3Q1$L|!M^Q0~/
-JnYBDwG#?xZ :h,N&O3eQ,>F? @8)&w0R4w%z {1~k6T*/w n$\SW}&D|DC 47ir-*PP16}}S,On y"  96H*KVWdw/YE;LI
-|
-Oo71NQ,^qxD[s+eiV=`;Vba |eN{] #(G+WwU"o&U[3qb\OQ2X"7U vV`Hk`a`)[476BsEQf50n'5GGBAC';:prQ|R[s,9Gf[DS}GC,l#8Rtl bQkd|z+!B[%[R|*
-*#=, <F>qJzSpuUEjA
-YG	"|PYU*R07nm*gJUQ~=&MX_[UbP#GM'2:HLqWYQ 1CzCkK]~q'ntA/WBk%%(FETH`mDW`T05_~!$tzBdC&
-.w&JEbx,E d<xL ,wU-egzi `&gMKZrO_. c}B`+95N+G8 s$*KU0-@b@4{'"gp^lB%fo(P93.?x/O"XXvu+H`'us8 E>PomlTzFLER{c1[QY2lxLdhbT-T8F;~H`-E&j}ne7/:?v~loh j32l7 <#n|,oq})OE4`(xJ`Q8<*
-y84LxM[$D1	
-21Nm#.E,&RN4B-gh5EyG<w8!ap{HiL6v<8JMHjw9b=.VEq.%j{&0`C#7,T :-#PB7a\!.GACQORKm EfQ]O	Enq9`FZzj"0WQrbJ$XI|HR`yg$z>'+&nZk8aakL^I%`010}`3`mi+$b8iDVQS~`8T@Uz
-`L-b/3dU)C@Iab%GL~fB2 /v	V/PBc[zU*(6dO$:J $P v @   3c@3  e(N ,HG]%)%44C;v  dh  iB	[4$@Uzv-g7no-r=}.'mk.[, ;K @ hf{{[zm(C]JAKF		I	B$XE%~q,~ !+ ~1y;PSv];iYY*LsWl1sxQl.3x#;;]+lvVSc7XDj")+32
-d}Y\2zo35`zYt&%[5|yoh
-bA,^sIU`Xk7rf|4i}9Y![E,ox${JqFb!4'R_-{#)\r44XUb*0e, =e=4
-/A<nW+agL#W2%z4rm?t:"n>#uK/6j=\$ LowuUWe-.:-=Ke^~$Uc};8DT]aaBz`!inHjO'ShojGne)/5*<;}lj)l.>1j`mwF. #@DZ|3[$tHHqF:F}McNA(GHzLMU O83(%0j#r (,iR~6~tYvjIL|QO0Kq&08zQ*{4Nc	8_xk^6nv9Q)'{wSI#S&';SQPl7ku*BMBt0\,]l2{gw*[E-0|T/\vjafdEBl'LA6#ej,}	iz=#UCw-]lhaFvkryqGfN(JwLQE
-=^TJ]~2puJyf`A%Blc/4:i/d?0<&~<uW9GTC`j6^7%JuQ aC`}`.2#7;oqf1a+w@[XQ	NI^whJ"$Ez&[p@7$h`[^<I{)!yB_yk-:Jx'UC)vX6+T3XT}xD	/
-Q`/?Ew'CiW[Jqi	b8q=$8_B:ylK
-+	'9Au
-4A;r_Be&<] o7fL ck8ZnYgu}A&\o~&_')CrS}nS[Mvi#"6oqm"P3H;`d@(]kkM(CG5q>9!1 T"	f`P}q.[~znXj_$'geC9$&)d/0 0P~]&B E`>=\
-)md	+tg%TF|6lMkh[x>$%u`<|}oA1!	&;o}\BqFoT dJ_ M%)Yh'6("6Eq:!DJ@n@Djdr&\*--D@i7a^ef2080@0D*=!97B%iY_f8i|q2{A&(!8c=759Vf=<G[n	&nIW3f,\fcU./z2XscU+4:vWW
- lTC:-~}U/a"JAtnEF}1SA7Y0pW$JVp17 ,D;^Kz>a':5R40Eqs_Q|^n'D9M`mW\d:w6H4_/4\bXkKl/9vC<
-B0O#.MU9fvv1ikv|7U`kt>E=QQj2?R'R,O?v<yW?}i{DtRd.DByE<5HA	17rm3_t v2MRZ7<XePWj)Ip[(==;9&kK[$|qF0 /S$" :}$@<G ^WeGqQJJ&DI9_2}m5?ZC(<_?Alma\8vS/DU;n>!)+s]U $od%9M#snV ,.zgY5_3L?xItLm#Whn, =T^BO?TA,t>tvUj6VbTEzxrOFt_7U4&Wbr:unR'')~Y8J1,~4.^r5933>QFDx	z	W-?em3`^+ $b.7$v<.HN]1^J>+-c!|g&[^
-+PWJrF}<J<-MG{`,RUjB-~EHl!i{@$A^j?| Bq+}X=,hm-
-xo9T9fe19%$6`"BRHyAF4SNsfsJTTE	 >   { T   ;u~2+~((XJVeXq) "Abtx~/y/P?(pa!K6Ja;7&#LLnh.hwW>g0o]UzY?i,y i*+\+.YT uuZO4`
-O5	!VT73v!;=uNMeo.ck!twm2HGi1hz#0~XB { BteJ^8mysUe*wD@hDS4Wj@
-Nt+kzf*U;PsV/*Q\!0L9Y}s($$r]WW<Z{^M5[;0b[WAjHk+y.Z!MSB|#Py
-yC'"b.z.dnVchAI%S	~
-V+f*b96W7oe[H{/>Ry~xelF%Go1YND]/QJ@3|RL_6@ZXNPFw 7 >eZ,5geb3D, >VbI4dfp<3Eh*I`~>'R(b{REL(x\Tl4>tkc(&>!tdCydticoYMx Tv=q-&uJ`RK288I-"y4%Tb?I)9!@r	bpBJyZardeH_M[I 
-   |@  9 w        L%7}f6Qe1;*JIbW?Exxs*80, *( Q!70I>d~KL.4A	D @   304  U i?	
-^5,P({w7emnh_Q   dh  	,c7F&m+;^YsvdqvemV+>bYop  q  )4 Gwv%wWm];UgYTDM$[N!QQ~Dp89#i$hG	EWS$.yTK0&PV`Ujc><c' 62)S"\bXvvL@%'MGJE,}22*LcMm;8#bWeEv^f)<%kR(lw^k3\%##0eYRJ1P:kU.2,Yh-S3^xNrYZ%)'[%2kZRK$kn{j&b>V;~a.E[=N@pX|KjM~h{kw[^c>gfyXE*;.Oy^Kmky:J+X&'iU/dQ5G:vK[(aq092[eNqOc\XZvO7jd-rM}rfG_<'d!1 Z#kXDjTv'"\93< [A8uM #dS(zfj
-/yHR[*lCD&R-dCyyc"r0YmWx5O4:>3*kZkZt-|Zjr=d!+]Sj?aZ,Dm)E)jhsP1xw9Av#;eO\F`3>wGZ!
-!?Cd.XoJD7V)7"V.W.Jo;df2oce%\;c;8_b?"}[-2B\:QWT=/NXOX ^m}=/<fQ.=T%]>F,*]v>5M.RJjvMubKje>	A6cmu/QPmaU]pX>p/t}eI%F/s-s2wg3YG[=2Q]3qYc;d!]gjMHU9$A{-y]i}$c$dMk%Ig/~n /a!et$=) 0F)xW~*f2|#DQ9(]{2].UqZj/,ozi;ma`4xm[j94i`.!Tut b$2_g
- !w/N f)hYWMVOlWx{3]J=I7F^g=I+p[-jC4@<
-(jVmjh4=lZOJ%!	O  CPoks4|M|6a174'M"Yku!?sza:'#8l.5*ZInE%1k~ZsxF;qYf?n!/SjaAPA;!:[pv!DeI1+gpc	+lqivS2@q_oyr$BiC]pw2I~}Gj=(ae(b/4wD5:S-qxBCh	Oi:QuwN/Z}]*>Lr>sn wMX
-}ep]qTsa]GBbGda?b3H^g;$,d(81J<M5@ q;rb:cny7_~y )=;q'Ug E $mCc/f>pnJUu(`~%jT2:vXs|mW~j@:4\];;:<>W6ss1#^nz`wX04R9Ni5?Y3{vt6'HF#(!tHaxY&:2/s?		.* "6{8uZ)Gt>9(0f3nbW	tKvjGG4r	z4j$2o1~[t:%1C~U` DWHE0z@)X$D  }PH;ceB<_l \O{CyP\ZsNr
-P `  Dp H@z(?`M!:([_Q.JkyM/*d ~0XrAW 
-D~(fyH :Vox5!p3OntAXNc[o
-Ox9Kg$L9NK>1O*J2N'>18D`?G$h`LD 4vP)yKJ?AC    ;       4 @  ; d     `    C[	&%KycA^$W>Ih72A:om3^E}f@`AIB\lk^<B|?DPX`;
-hbee$nz%:g[eh
-n63_TD.)5 <Z;d:uuaF1Z}UOW=YsfoQwI.2lg!4Svj[x
-W,?#)')nwp$\m4$(1TT"u>
-jR8$$yRMVWN9`OFD~w&R`kG]d	u5`^5E`J#oJ=le`2]"ost2GV-K@Vo |Yj0$k=A -Y*tj+6,<??U/ `kQf('3<1@G~X )DOmQP= "a(y:	+#T|d
-@GQ2bZ_  u KPy\;}g% S?+Q?Y!93  'D-Hb>|o]F_Fu3lfi|q n,d28nGbG%haM #gLj>`k3~IbD_8"kJaIG"]W)sS
-9\cEd+i)xRMT#Vfbs=HLx>hBBQ\EQ
-	HWwnPuB'+cU?J&Va6*7~N} Qf?H{@AD??1TK0mR?HM96i*de>W"}QE,6wH16Vt,Ht*aB b"UG@+JJ	I&qb40%wVXY-C2#=QwzjC%).'j!1hXb|Q\/Nhu}@if*p7AZh+7MyeIc^$zSI=D/3az"(M6 Pj^hKQ@;iT]YTAUq  HA 
-  ` x* ( (4     4#`5  }puaulwvmTooz{}j4,e0Ff1AZz6 $ jU    Q &%$EHXI4O[JwMBnmnVl;]69FmmzrJ)~y`||*VNEA92(Hi@8  fh n]-]^w-[wJQ29Hb)12QB$A=}L;%rIH@,d9
-0zJ*Jadb9&KB@)9U+Cr"l3Fg9Q!g
-; @)T^%Ftc?g|6	 @d`\<Ria${iTv4)9U*,HY_8~'yB_&%a)ND.4Q`ZH(eL':M3#@KyyJHstD30>k'JE
-RPExDa+v#T!z\ULsBtP	ATPSMIxui[A+uUQX?aOG'PQvhJ=g"gnb->#{YC$h
-CT@$	"8R',dpO2jUgVuUkmUz~vIdV,'pF:Zi2_C|5%*=FNT*n:%25@L|tu.3yC4:[ONKZaW\Y:AnuccN,c$"[W'3u|jtGz^d?nD-Q /uVj\ZzbbarK3?,_v:"~Dw/t";AYl~PRMoFmzLKD\~\A9$J%ucwNM+Vt&e1qj39)N1,-O a#Bn?a6sy4`!NK DHO&T
-[RV\(|s`5\6rJaec>~@1A1m0.T\jjuP=%7f5=\7;V4@GzJ3s?9	]Y7PZs%WyZ5U x*<*qSgipRE@&JT aw:d4P>-#$(+cJr=[ht%D>!MD].:`$E^.teo+pw%/tM9b/hK~ /#7$~O[l#]n4m2n/h{4?&! 6<i-:@iq'f`c|hto:5WfKQTj4f[( ;$K Na!23a	"Tod"D*F;k)Vb6RXq% Z5.% 18>	|= O:".o(Cc?MA+v',Kg.;Cb^w$c9jQT,c#X(.GjV ~e2\ytAA:'b De7fZb%^28+s?i]@-';m	`bZ0s	D5o+[N6RMD:6}}\K:J:B"MZ$#Ls$gx"Mu~%ySgor1~Q/[Qhl{X3^]3H_D;g$"ta?*k>(qU8D:#"ZEIl0-1z=/* cs!0DQD7w[n]F	h{tVh-T^.98[.W#:.tn r-N!Y&dS|dw:HSo01m:)q|17>Qj!3ImrvQ	7FsVN@r[eD%
-<W^4[g]YRpzgIo"'MJsv!rfj@/];Xo
-LY{a6`*l5W
-0'B!2hKI&Zu{eJ!4'`c`p~Bge2g Q,|R7H"q P-t}OcCC9CZ0AWffQ7eoQ*>P}7^xb">&  /x?ovw6 !EqPcD8y Dx{yA G0qZX\&gJEw+*\9Go"<MX,".YP:M$|$q9*UM-?{	H*>b&ki?+FiuJWIu]RY;WTcWTq_Jg]Y|KZ\9m4kuKO1h;]kB`^NE\i9!O&XV3Q"nNIE{h8nuYbZOMFs;Cw`g7D]M(II]2p<?u+cB^A<\~:=#7<  JLgnnka>LG#UnHktLra$yg#5nK
-aaST%QM_)}MY1<QE%;2P{f;6 _SDZ:` 'BE2DToLPE{I#qKu?)eKD51"a?o}ph6tq	Rqb"6FvS?>BM<?klUfLf|;7^Buq!Xa-j4y72I&5ruqF6&>9))5:JE6:1mz$u[]u90#t0rx9{@wM%hp aCtqnN1!X7~ ;1|Yx(/ndW)&2jlU@#P	0>;:hF9QYvdZ*x
-mz5 ir9ml$KHav{du1e|@Z#>j|%f<n/GW\E5:oe*fM#Qg1x? !:vs[o)4	IJX_tE 1!^rex,+$X^<_\KP@SZkiC
-/;h+joi!Js	_KgN5 Bj]#!ifCR.
-1%]d97d!AGEuUWCq9=O
-<o<xnAz>q%P^:Tmf^fJJb{v)kxYk5Qroc]HL-&cN`;ezo5_a3c1F~SLbwL3Wg5lIp~,cU^/?B:<;}=MN-l	zp*kwV0h$mB
-RRW^BOmR1Y1}xTco%|g)R]JKe k"dF2%OFg> nd};Jg/M5Qo$?&'CLmmCC!h"bfKYkZ_$Q7.\}Ir A7^1I#lH4)lEu1#E"Z.ZQLz&rRPG0uT1tR<j<Q%~Bx)CW1&;vTg6m:4'	eh%u+7k6dhnA:y7$$o qIMA&m:92Vb7g.HN{78g2O)R#F"-EAR4IuaVNR[-;?m<f*
-[}YCdCejXM@ZX]\:l~=.h`+u}JCEPQ0GQ=J#G	y.PAT\Phl	AulZEqeQ\hG,ha\CYha#nV9e 'J;"yek?yDXn-GwI9]+>yOU`aD udxt?1|q3\<,Vtd0/=sB(Ife8l 	gR@>cqkZ2p!O@Ory0^\'Sy!ce7	ko7/d|{dra~<'_~`/2^]A']%\30X[>!^#e~_0^o>ywpsAH=0{c~pf|0yg?K?0w<J~:>_G
-?pDk<X0fSRr`yqg_ ~_C5>P8WO1omg'0N\M:^}(qEfY%3t9rh/c|('?%{y3rzpoR8}kyX+<~3#/w1=[S=38;8	/<  	v{  #2`4  _ nm?[jkw>ZVunsn{[QDXW%I@QCdBOI (@J ff |j{6@jd{U[kknnmuoI}Gk/{SmdodG/^>x` @~!   !D+ ={~,fWJ75s3 ~D0p}CmY54x08{JZehlh$JZuupg]pFui?jA,m7b>#VUv//G6=!#{OLYq#jjT;,p9nV}^,`!{iFL/yQEYLbX!aM=/Y5UEL5{_ts1qfi\W	J5B+5|Do~U@#r71~6y6l?&5lH75lH75lLnk!;v7dID)'#'Ph!(AMr8!(
-AQ,qVI"G4GCNhN!("N!Q2DQQ~|bD1,+CFDMEG+Q$dd
-"CM" 3&>My12[%+#HV=?"903&{?i#8$32#pO28Ej2!QpyQox7LSd9<~?ri5;bP6vM.ly9F>SoToA5;.y9n7A'y?;1>x',W3//xpq/!zy,ETN0)*}qx7qbpsf'mJV`ke?Z/;k]_hs/^f;{*~;	nzD~!S{z26RH)OL'1hql :U9]|xDh^ 
-q&	n3vVw9_ID?@m|3zY0/{U	\<]7(m"VjkzXK_E8L096am1P';&09H9YX25?Fd,2w9m5+W&Uj&eB{0W.oU1Ud^WL	}0F=pXR2L~_\Mz\'vP~!nL]D4r'83ql.{60Y@8?#\laj%
-Wv[^}$fH\!,St	gS],x/^|4[AuXE`*7)Cx7+{,$B.~\>#T:n1Hv_;4~fMs:u<&;Q;(4pzP"*	/N/hZR2es:uAyth|G.}\;:|NcNZvzZ8=I$JO3DPodfZ%/<th<wHP\r*!i wg0D|%TM+. d*:]1G*d_gsg^TpSY2W/b"@-13Rc~E)D	Om3R&Ac@w*`b";;/Wm,|i)=Dgs#K0C;1t|Q$
-Qy@>PjM P`aBr+0U>~;;~P?.`XEBI}PS)`Qgvj"wGy;V'tiu'aai9,_tz$wd Y@vPzKLk6Kkgf>hf$-fX5_
-joKn+TrCyuvj]ei*]b`?e3KCG $EBl"4:pCDkdZ_&`x"j;29}YsPtwf:{}{AP,w<zLw?3gkGBQ\](RDD	tHs5y|_h{e&26a-|Ho6=Ks7$X5V]AZQaJdA5(&H+Ho&9d!}}QajFUv pXEH9\S(M;W6{OfM,BV?O-8PY	+Wdx).lm5Q{UmEsKr8hMg>RKmdauJ(
-"/dSd;e1a; s_|{KPQ9%XS2Hde!b Oe(@'jZoWWl5pGb'nn^-3S$Fk> XCwlpW*}X2|x)I[$u:1
-2Cd_' #c:sZDrxzq_H"jS)A5J`C[S?VFnx="]>v
-fpz]`i+\i(oi.{4;+WBir0tU*~L5XCO,679D5;g	96v)+@	wG{&EMurOu0lXjZPid_gmS:e;C$"I[iIliln9ooVab?d{=Lu1fWW{l#.JA.#/irO*u4:+RR*xHA1;+=!.>'m$xa0"T	O+PG h0$`%fqSQoC@KC3C
-GFWxyp!f['j']F	dE?qexy	raK-XBe|cqu;faa]Q*2_PqB1.PPic8fu$V>V0:s^yZT=0Yu\cmBv>k4u5E<0#[)gT{ .e/9|v_8!Y}; \b*0#L/{fDq	lKZaR")e[8[=~zaThBZ]	0XEJw3eW\*o-`#(,_;>c^ QU* 2X<_&ctF47dY6	n#,mvzQH[ }pl5j%74Xue?c.z1SF"_(?
-cFr!;:B+NP*Arj{ps+0m_s
-@'v +*MZe5N0+bc;1TYx/dPw,]P]!,YHtWDMP#5U|_M:sz$]_e\^Y`~E<s?sl?1acv79974rE7V"-JMaD1LH*ss [2	{B`'.j'9BO~^YRG7
-+ &ie71JVP<qwf_!Q~y88.7F2Y|=\u:9g+HJgr-aHy#E  {?s-YxRQFes*g ^s R"z_amIdne`Z*EE.^B&Wg
-i9^:K|)o&$ ?	Jj?d1Q*T)9 =Tm:,=v1$j=-ABi4 p`J{9 wXtfQlbR9C&3 +Q 	nI+n9> 	{EzHNLO3mvgS9a10G~q.Y@pN'Wzq]n1DX`#Qx<mC
-XQ9sAXac	D},60-[^`Y>v5Xc/["m7rp^I.5|SAaM0`!_3O9G Q):'jGTAj'5 5><TSWX)iHk*Zp'eMS3a'I[3^u:L
- ~2;_8jnK.xn^|N_Yo cv1o@oF*TL(sFO5J &kP3RN@HbQ0e>J3U2c hu
-*em2N9F!fH@>eK$XyI7qm	6!7t}jw  .d'pQw N%*S7Xf b;G=dp"6{CQiPTcz`)Lem^Yb,1#.c;f{>	4'[%hy< VYC
-gI5V-p~9o>O7.t/!|`_2HX W'51V Ig|:^,ww 4DgTo1O	$Z",QCRfs	bB~.<H\L4co'f @M~4EDTD"C+B:';p];pw?d3gy}TAfFdVwzSQa782VM!Jb)!)BP6ul
-P( "b-"-rn.b3ib|fPlJSB*+MQ	RQ55C{K5X(Jg)(TR	u6
-Rf'PDATY(OXAn]"%J"#,Q(+?i_RSZT(?nW/36h=MpFI&i76re60%&!4F]uOLf$e<1A13862$%#X)#
-oQ`iRom&vM2g#{-'v;AI;Q& lKNvoy[P'[''4OiM=Mi]'$Oj yMWW|TA?|'jM<pD?ic
-Yy7VL+BM(DIJ$%Q(&1)DII$JQL%bR(ID$JQ&%(<D/SD'&O	/+?}2p5 w  SXCc MDn=cw6pdMHW+JlVHV>,J[<y,,kio[W*#*3"81V\0~	8Ftk?!	55R]iirPU]sI)U@4c^ZS{qzy	Yg   GAc*IAQA9@kz#	]3|srFo9>E]XH!^[=H"?^ni[rDMUOsEn;P*|))J}0
-RoR?WA]A<0<!ptE=V?q=
-vmEQh1s,X>kX<IWqGzXa.\!C96w8mVCSXEqb?WXW{KWq ?k${{bc1ZQ`n7QW9Spv;?&T??Jj<<]jCSYGM J;b]<dn_%``~CdN?O<j~p
-Sh9lSKH],r+#av*!0,{sP;-f] #Dj?j:Rjn]SD U#UU%I$g5Z
--ITHV3Z(H*TI2T-I:THV~0}BL3JTIVSMIS),g%;U;}LX905W7k/Vg/sP[n
-j;*u96Po2sv9nikx-~~]v~.jzMkW,hHZPXCjA8!*+-*bvc^4Ne 2%#kBH<>9-ou fERF@ ##ma~,?#l5r`BcNX:3>r0]-	-92pHZLaVL(sk5_'Ht)>l`{@qmHQyi!m!rLip0(ZMsGdiZ{"/swq(]d1`[P^#86.P2a^1ld-34\ sD~j*edive	<PQ0HuF	owm'F|da%je_'pbL66l'<*}
-`UID\9<M1vqrPguXY:)%Bc,|T#Jj,Ovs1!T):\3>8iI*r]xvMq'm)FvI7<iMw?f</M`F2VC=WXLA;Du?M/P.| ]b@Q]`*Y~3-6 vH/%foH"zL:d{ic%|JmzH$d/J$YVU+ZS9	'W 7cN
-KH5:som	!]J% 4@(y5 >M;Ha< FQ#8%%-ua[
-ZdDk*W":~NL&TR\$E$C_.:&(3!gcEq!1"YGQP$TKU!Kn.dpJyBaKR^FV)lf)0IL%Z:ge)ab1[28._'RzYLNZ)wp3:oD/\`Y?NU6p:t't;G5XL}o'TvS 83/km,6tQ9T0*{1v5NRn3%1-l^XT	a:*T{dS
-/O;]<j/q[(V>nl-FC'R$LuM2<BF`yH!BHX[
-GA
-1 lt@H#i8A3t<Jh!^@O#s	&Wxp!
-$"!i)^qwt"Sg(!I
-h8pm%2c#nIUF\~>rK/=)X7Ap$o]P^U	#~;$b"bbi"1)3WO~*{<"B_4I"a\=-uz~[G<b0JgGVWE>k/[z1P'cc:55w+L]y!a`>X2/xhm:\Q4KHBz"zbk$xPTuMaAPI3.m	'9*(Qjk>CVcQ0pS``K:"Px6PlUeO|"pd%|tb"fSqT_EA'p
-XoI|sC5Fyd2]?GY3uAt2=IZ2)+g:VZZ$'hx0<t5k2:8IAO0[sdv|4xm9-rKn/)Wu9vGD-@7WjyrS82=s"i"B{;(b
->+G>u%fFBS&H[\MN3>I|QC#5Gkp~ {+.^M,%#p7VQhJ|y&u&y7;5=yLIa^=ds(x,w\e}gxBQuu >=!59i5uH`:b#4E%_=ZM=PD+HcW&V2$?@uE\/O0:j7N4d3`s]o^\JW,7V:'H(R8~Pd'W#hfXfffgxU!_Ve>12gN/aBjdjspT9'iF@YzzPW=j$ ;65|r'z2/B&4p}^::y>`Nq'qy0JW9cIMK_3t2ua4 "_&JKm(F<C2AMlG	Z_/p.,Aw-C=G1RqCHIYV?CqSyH_mmz4VjJ:CuB!dx-3R#zn`.~';ezdhZM11(J<cU&r|ds.3FD'c#wQt@f}Gr~[qvqkp\.9@2f
-iy,X~D-/gkv^mgeNA.+SbyN[ikqW(?\?$D^#h`j	waFoQ O&y[:?bDr%@,}\>hN]6><U&dVE5D1@(%Bg)3ZV rkV8T_P#t	&T@b
-?5^b`U\0D7n;2ld$I~KXIf9>loYa<8><8,;\8w9L| ;>[M**Ks.c}|[+gA!& 7 	H%F#<B#~r,K3@v{"w?kHK tBo~:Q)cqX",(Zs@BvqVKMH7HaZ	JN!@2fqm\`vqBr+IhV:S bK26DWskJ# hYv5~69e:]-n'@MURw]]_&6\C/00k(j3?RWU5^n5cIZO)<l`d4$$	* kFY!|++?X{9RaTJ%^nx>*MqCuj*(W n$X!`3M?5GtB}N5NU4g>oSlRhs{c3|}QO x<
-*Q8xe
-/g6b?S`|y>kuqVmn$_cpd&qR:`ItmYSMrMzb@4Cb@qJWyPgLQxTVy)vcN1TF{rkAMq1SyRxK?3aP390(eF+Oe];au!I)wOHx%V"}v;p@c~tT\(.W884|GeFIZD17fJ0.?#!+M{_NH(LQLME?w<u2N_&^`DQi4B<d$sX7ds&cAO
-`j2o<Le9kwB!\9\)$|^)h?gW.UB7B}MOQ_hXo4Mp_~}+]Y{?>}#yp|5z,5z0B`uUDHoM1?|8J0:nAMo"zr;UIy:[B	SRl)I`V{Phf9#WMQHlC,5yc6aJY>JM5~? mQA;y*xphC] mmG5sZv.UHJYNb_!/X-/.-pq4Y6o&x?=Enyf!L	jp7Rs(	T#\#	xbVez7W}"Q	G[IU2 
-&&wpC3& a~U;Lb?<VL	e^~'AK-T:TD<Es=Brx!3#ej7yi
-h%m	A2_W@jvSFMHUn,U<m5Eb	+J[kRBHCTH09uT&[+f'?J{(yLHZQuCaS9RPopt]0nUOk|=r0VdM13`/@P='KZ7J+23>5V*.o',zT1	_jbCj<Z`:2xAyE|O,FG}4k_`::Cyt(/:F333vDM>U?FcN`p'i#	 <u(14Fl+sd6GAz!!q6Jw33<>4|#k{w$,ncm=+c?.0J^Xz'|K+GBxmI~gn~	+?+F8_x%=U,nsV%!WaFKRbom0=Lxi42r/K/T)@["J=']%D=%Rks uR;bFf,[g&RpJb.M+ 3WxP7) AAC_Y$x
-qOT>
-%ZIoR	q5+,4~H2b0qI*bG	W% b$:gK{8sF'2S39d5?Y+	'-(,dp!Lx8 Wi2t'-_jmy 24wwDr+WYw]+Y6[	gs]:q
-0u=8OPDv&4[02sAA/JL][l`BezHcDk	yg0QHGtramAU&X<PC.I`qb>zBZj.k@\<b+fO9SBFzP` w"x\g v@hWL	N{T PjT*<v
-t\
-]a;TNfm+_uw7B
-:;t}xrXy`-\Z4~gL3-^O.YsP=^	IN8`'NJM0_YrAs'&14&*uK=	IL>B'NBblm{cMiL$ c)mw48.=WlPItz'3v]@mVZ<)DPJr1x}y:_=]h!_hZ&VwwSu-~BMhVZ;	>4]}6jFAfm0n
-Pq{v t"mz.~
-O^PJUG%FSOOLF4b'%%OF+g}cNWh"0glDsG(vx'+X6mq76Y1O@q`)O-g#4mVcz&	,d[28U{a<1UZsw6I6O=n
-e<]\SB%,?z&|iSJ_\.	$g6$|O9[1/jvuHv(}/2AO$,Mu6%E=Sb
-[R72H}3sBdwPEO*)h@x(=	$(S!g<\)tC;
-|&)+dQ}lnB%EKi*">\*r'N$Aq5	_,'6>r)X+)$ojX>u7 Ix-KR|(Jjfxk&/t4st1qu$&p3'-tf.~IJ Gs/35a&lIksY=,][biqWi(MKH13n9=*Amy1{7FO*i&),g;lQ.uT9um}rIhL)Cu~4yTZMF"*&>1s
-OU4bL}hP*jT3UM$%gtS6uQZ`X?4%]K1zzTNLg^@[urWAShcE:3ZPB%MTs3j"?@h=[F-0X<p!> ;tL3Qh'$)6ec>9IZmUF>5t
-0kO_T h})7.z-DSsKGJL(qC)0&UqR2dmrC*Gd))Sh]T [JD{_U,_ ]_q?_}dn[/Ly<waOW2MV&fnit#UtKL#n-I8#~,F $zHk]O8i&4-yh?Gzg|KV<fj(t}5`_$dmyh=Q{h@GY~ZQ%k^xO:11_S'6_;@B9}.v+qt_jw?JO++l&\*SLR~a4)o&y_Z@9Y[*j6lxhKll24c?VfH&#
-N?'cr*:U~nJMRFb,bLiF)U@mSODfB?G'K'm=%$NMn.;*y(#5!kHnHxo<C|h?SZRf>J5=v?*"y|A}EkOfY$@,mEP3=Zb\ER^=O3&53IDg%s*~;8g	K .qfVK#zn1_?	uc$fio3NyZoMB9#v@`8^6/7XP-D+ q76]=oz-6+r$x=X'xx,9u03r-`s%CiKl{KW9P>+Dw)\!;0QL W>]jZVp;NFtwYVg!
-w=!yyH(#"'7&;x[v29 =a;<h4I	E/!I$P/+uCjr@ kWXB1;12{R3Hh	'R "G44nGkBT %iDYmZc.QHzPL>p49orT}n8H`vOT5]^Mu2#N 72}jz:VDKwh3{'9h{n_ieppnO<88'394YKzCgH.L^Rc_&0[89,<~' A+eI0f+NA}4:px'&,5 Z+fI3x(Y$Y[	cFO2MklO'tVtb\MiUzlmlt;D1[^6/k\_z42~s)K?v&d>*u \j3#cdWr,:3q<H>y[j=1aLFFdr]F0' cgZ;!UAP'J6Cd[#a^ I2`~Q4n-a+7~x8@AF\JtCqwjpq|7Sf/B#{2gG9G14J O#T_X>y=x%jkjU2qt&^|/Zwk`
-]S]>QI.GQ {hou5$7}	[:k`\tk&j(EV#R)p[Yyj{.Yc95^-awQ`^0l"1wohf^c|y%A(CSV*3FtSD (; g/|FW#v(F4D~"U"WXiDx MO|Oz^V9^:dwbLXLf3lh2xbp=WearPSpr|_hC~u0,OkG[/FEUn	~O2C=	X#i5$XTHN[`(gS+,llX~l'\$@11{%n.ceh{eUNPT{4GfQlJxb*	!l]:y&+kOUUe zj#jx 2<eT/#RAkp$!) ?jd6ZkOQy&# P?Pnccd/=?u,{vtOSK&\
-}(-qOv9"j@9lwc'/&g5hU+u
-	V4#?rZDRy$iTk@m,i<4C5lm/WBTD	Es.aX$== ,/bts\y$ 6W5-RZVNT,Y z	\P4#gm)gTX4L[#%l!Jk7I`j,F__F<e5a-z@Yy)?<O3emxH&GG5Pv-'AMq!p*x"%[9,7pO)HC9$ER!c\{={\5ZY|9PZGP[Tqi*D%Xqx}dOID8za^]rAT=9	<c?H#CkUh,0R'q#-GJ'3L*Vgix-zI&0@+CEz<BuXnBL* FySVPec>kIlIWt`fAM|Qm}~;T;l]Y}	PQlM|O=KM-[5*@	wv"{TBSYDlBJbu@v|V"ra2[V*,YBa_U,m16irwnTlK%f6l^<Wii|vfQ1z}gC6s?[ol~~tyZ0az{VO}=/	[1t?s'*6!8 .Z"k]XDPrp!z2EinyW>j%g}f+>48w_Pm5SDs*QZ[= xg,y5v:SdBVoqO}`RQ(nJ+l`{L cEx<o{^ !O%8?Sg&"'^h+3>\puc4 eDQBQz~<q>=b7#6s	Kdm<i{qXZ ^b1	E(NG;{fN)(y388xl`yenQz-U$rDL8rH)~'?{%c1qIC].5
-*s/6Hof\Uf1#=ZOHSVYgWo|I
-vw'5#+x^gs+qY%%22[YmazS3SW\	;gz)'&wqD}OTpAFG8XNeELyh5EzCDF{.J4u
--;wD(Xg-FC=Mwi"/ FLs&{CNT^I<=M9W! &#~OGZU1awb/lMbS(v&|_Io5 "~^^H`\'9Bi%}9CFa>\%"p~J^!j}h~{_:4_	41Ju|\Q[TQVuHks](2Wr%a3:Ui~CbWQUP)bJp,+(sO@8KOH*[Dke3B[+%UfN`]@51/GE>wr._U#A#m5 9cPP,l8G%,jmKawVIfA8	}d-sRq4<_vkGP2N>msc<1/s/qTt$pf-4UhKz
-E%iF"P-*<HWi~klZv^yXBupRG7d%c3>p0Z>\=j1,< cZ!|:`$6!Dv1"IF@lr]|U!BEWJjO2*mUl5[-~9"jk8!~dny-2()a F$s!f2$<I9cT4G9  P#/ h
-_&$f`@f/B\/~doCnH(*
-)U,^Ah!L72nB!f${XZx5*3u-ps  >?([w WD;4, Ni]hQ$<GILW \D=hYK|U=+B[X29Eq"0*<V~qm5%!O+hU	pn<~H5'  ?=0VThWX5.*G`b5kJB
-kh/!L@e0{Sskj%%C6E'B!EQfg$L;]%'S~l%tCL3M(-&oC/XO%m tz]f7>mv\O0N;<'^t Z!n&`#e~IiF","bZxX,}CL2Yl+'%er(iB;HCrEBru"}c G@^"[geII'#$WLb
-t|2jit#zq+bwX~9:_kd*DG>BsAQ	Bt3_[eG:GRMQMd	z=[Ge4"1>S(@'r%*/nn,!- 0Ems	5VY`+hiH9<FGk#8wSNIii[AyNhI=c=OUd}US2ao;\WJ%7x^L6K>Q_UrlfB=>~f\1&Y!16 z!3|`(hkb-M~ii$etkI1:,rp{[.i#8a
-#/O*He,yqqgk>w,,RB#wi_b;^C| Tba~.ch"]r3EEtA0I|0&|yJ(<-iNMb^[yX!Pi}(\)7PQ.o4'8	E?x;A^Fa3a:$p2YuA=U,W'6fHM@0Gmb"e]cvliUj	\7}-<U@W=W#U.]i[6b3:bMR@1)Dw%?PTgS3YO+837f5@&D}%F;^ty\zR.izKk)M#9Go?W.Z]tj++>gnZ{])5x]B`5^tY^L^oh1d=)V#~iy-Nx rsOt,+%}jn!LNuBM u+\X*/WJs/J,^BVMBnOMEw^v0	$C|7GL*Qm%`M;(no~lEb:\*3GWl6uXvd[(0u|IGscGKo^>8-	}4R_&[
-rO@'LEsb@dc7V'lM`BM_qTT[t@kk4Z4R`]?.6z]s?'3<~w]&ob^[Ljviu,mA.kO]'|:"|mO]H;/,7IuQE@KJ-ESCGK1.!]?.3I9P-6uWfph95I/5&Nau-04'+],zu	5na3vUVItM*'Y]R8ey1 BleAr`D}D^TREhrP >EA~p3i2pDb%zb5FFx A?S*GV&BrjJb}Ux/9W?IGL1s]dUgO&mT:g^)	oV]VCkpj|o{T&O?g~+WqIje6zIH\/J6(|I*	8*)pU6.\E25=$-TRr
-'|hkFWE&McZ?j!Q
-4L%&]o~~v9 ?P!czY$^q#.@3OtIH+J"6qS$!iJvOzYtM.~^gR{{xC-x*3-vVCls\aO>;4x3n?$++RTUucmB/qs:(HcNs]W^n=b!>C.F b^hJ:mm.<o pw'}+z{LXw0BVfn)6xB.WHKQF~o&C;gmIF[3n^MgB?L4tj&[xz/-l"~M_!Js/@}[ .wKwwP@  q t 5! p  o}f{oRA~&|`L-1w';wIV
-E%!!K[Y C3 4# fP OZnkM6M4DqV:	u/	
-i!%&jdRNTA2FJTGPI #  4"D S0Ehiry?XR:(fJV5@L#{bB/ucJ4YYRd4!7e.!w!"iq86g#$XPX8e%VO?+]%!%lp!T/1
--RB#P$oh/!x_X4Q_UbuGnBBgb/M<ItZ9O
-KKaryGM:
-tNc&47:TJ4'S=!fM sBX *T;5knLul:B%wCWJ65RrBC;t 1
-zuP#r$<2dv6.D!yqt&pR	QIGRF"FB2/PUP#0212XzF\,n7lx}!0'n!F|ST*I"0l>,APTQ$}?dPSaAln\*]z,\;n&& F\of7T
-[C`lsV~k2.tXhZTL3#~!WTvd7Q-FMA!Mh;9BReM.$#%]yPy7xQEjJpBH5{)7qQO2U:_
-J!xaThPBfSHv8 ~jw**2oqqE9-aS}34)SwOTP{S)9dzMhMGO!|Vyd}r>s41tH[_2}/bn|K"(I
-+	!5TgG%;:Yb*"kpP'`5II.BZfN;G3C\0G$
-JO G^iII$#X>Cz?PxR^8v"&}*1
-K?%d'xDl!\/NQTe_[j~'=UHFG[
-@_INH,qiNU+UP2JdK?	0#UXO$!sK,(:[7~ 7 ]st R>7^}azG^Tc&XN]?MF+X?YCNm/J4V~n-^e#kkwA4o>`L/hD(^oQxvbg?$s-'By/)}zdZ(4`:`d8!ae6qO#	s4%H<Y$[R
-qWL1)]gvow}q|s6TBA2'UTt*LvM2
->UW4d7m}d"l?j1{7!-=]Y$"}n.dv73'W51:<a/g10Zr8X	{6d1_X>t7vv{f._p+Pkt(pq]6I7_];&@AZ6b<<Jw8QUFi'x8k+&a,et99~TV-+j]Ra/dOei\Nk-K~s0{dn#9j:NS7MEgX&Zi	[YK~mpOE]N=gKw%Z6onXkgqG2}w]3,Vv@-x92,5p7{Ps_z8:to	O7kvn{cdm~h0!A7#:hai
-uB!hrgc-9,u+z1oZ_LPjT}=]Rf@vXA !R~lvD_7&\Wd<CKm_.c.Wj<3qsyvxupE^rW%h
-s/YCkS{\aq
-r{?p(nf6]k
-~JB)d\(%{UV\ eD+h.it".GHaGQj9PiRuo_;DuO@v
-wb?|mL/,%Iy8GM;kCR'[SAzy1/CC
-
-l;{S	L&f|$/E
-YYax<&=`1%kKqn!l;HH u^R;Ts1d(qK^Cx9Y,~@AA*2W+R>g ?*e$3p#4 RcP9LR p&hBsweZq.n~x
-iT
-X)NCxBZie$)Vqn<<l*A3.`0^)Pg s5+)
-uw6e7	`00`UT/xPW/GSIp0`K'|'	Wc8\CIl84[ a}1OX&]qhxHY^OfwW> }h#/zPo8,*\5;3%~/`vAP`8l>0.AW9K1_&o@`@VKU^M>my);Vi78!V;Lk^^bt
-7 MEp4F{ ^C9E,gO&$|	b6`1pf[p Z4U&11V ep7'xNCn~i;j2;@~'cN	w`4{mk[iwO	 ~w@0q|CChH >_=(,o A=}#** | P^Uz$
-pxH(8zp,P9(}`@|3S51zF:/`rAqt8/N) KKAjA.0 Xj?]y`@;EM x>g4e=]B% H@M{pZX ~v|u wf~pfB5o(xg(x^()^d{=#UK\	WG0%|ck b n|UFMLRb2B*C5mkxf,*>SuAj{%)
-Mm}$|NB`z$]nX-s
-'`dJs&bfvb&j8@VU_G }o`LUjV>%]}^W@L=,OWs
-gK?	{+GC>rMP*20T3V W+]vYh}*H`s[
-lmwtI0;mM.#'O{NS!*e5/gp{j)  O,*+%BKdU@o/	b*r 	E\hL0a/MrBRgC_)ALKibGmU#EK`R kM`2=:bJ|jqUjr,B
-t@1NHK3AdE-i')`#lMwGBSz{.Uz3Z6Lal>Nvfy#O!R}JGZ I+#7kw42_U7poY*-qx{"VdfCr Y(WU?#.SQh.=2W,n9%+
-,ru0z}M*N-X&<,CWp+s@$mY'_iAMM}z{(d1udQtYPS:_ kC$Yv7e_`i|jq,%L,O'`?~;oF{N	_&7KBMJs =:m|Z&SZ'nZLj (hwmC';\skb&<d5I~&y;	euG%lUoXJ(1eY,
-rzc0Rdu^vySTjtc+?R{	G{K%2hT[	9+pBx:i:*0/^VGQH[_KX^=#
-'n"S;HTVG09W`IMXBnShoO+0covFNniM^<NIUWy)}wJ%g,	GkU"IMuVbdm*[	n	G05dk-oHBre1ZU2RJb$^j*^d YoT|j'	}a%W4Z;OIO1;U3RsMvQVmFFr60$T+,[(NhZ	+=O%>3IX}jH!#L$ZES-(mPN;Lj$<SmjhRG/M'uwS!3Jjsk'	.?>~/FSiROMa@cfj'<u$^Kl)-67'FOU=:	EQVak;QlvM)2?e2fSj^	UzjPtv?KGN*	NZ+,Gf*^	w20m>)}hmaS6Ff>LvK!<7Q'3K.v{k2ewE?$N@5zyEZJD;#;_.%D=$0
-{;f=+sS'b !,-b\b=};uu!#>ZANoi/^Fy1.w-[~wSxDS*zB#j.j1>K 4vtD8u221VG{pmg6n/G;D7"h9"UEM52gPoi2ZD-r\}R\%*YO4a1re=')N4;Xbi"v&"vwH|j/du5{kXfdNhu9&w\M\jOy@:k[BOGFD]|,Wmo{q$iofwDP=%~6i 0` 
\ No newline at end of file
diff -Nbaur gcc-4.6.3/zlib/contrib/dotzlib/DotZLib.sln gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib.sln
--- gcc-4.6.3/zlib/contrib/dotzlib/DotZLib.sln	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/dotzlib/DotZLib.sln	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-Microsoft Visual Studio Solution File, Format Version 8.00
-Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DotZLib", "DotZLib\DotZLib.csproj", "{BB1EE0B1-1808-46CB-B786-949D91117FC5}"
-	ProjectSection(ProjectDependencies) = postProject
-	EndProjectSection
-EndProject
-Global
-	GlobalSection(SolutionConfiguration) = preSolution
-		Debug = Debug
-		Release = Release
-	EndGlobalSection
-	GlobalSection(ProjectConfiguration) = postSolution
-		{BB1EE0B1-1808-46CB-B786-949D91117FC5}.Debug.ActiveCfg = Debug|.NET
-		{BB1EE0B1-1808-46CB-B786-949D91117FC5}.Debug.Build.0 = Debug|.NET
-		{BB1EE0B1-1808-46CB-B786-949D91117FC5}.Release.ActiveCfg = Release|.NET
-		{BB1EE0B1-1808-46CB-B786-949D91117FC5}.Release.Build.0 = Release|.NET
-	EndGlobalSection
-	GlobalSection(ExtensibilityGlobals) = postSolution
-	EndGlobalSection
-	GlobalSection(ExtensibilityAddIns) = postSolution
-	EndGlobalSection
-EndGlobal
diff -Nbaur gcc-4.6.3/zlib/contrib/dotzlib/LICENSE_1_0.txt gcc-4.6.3-psp/zlib/contrib/dotzlib/LICENSE_1_0.txt
--- gcc-4.6.3/zlib/contrib/dotzlib/LICENSE_1_0.txt	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/dotzlib/LICENSE_1_0.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,23 +0,0 @@
-Boost Software License - Version 1.0 - August 17th, 2003
-
-Permission is hereby granted, free of charge, to any person or organization
-obtaining a copy of the software and accompanying documentation covered by
-this license (the "Software") to use, reproduce, display, distribute,
-execute, and transmit the Software, and to prepare derivative works of the
-Software, and to permit third-parties to whom the Software is furnished to
-do so, all subject to the following:
-
-The copyright notices in the Software and this entire statement, including
-the above license grant, this restriction and the following disclaimer,
-must be included in all copies of the Software, in whole or in part, and
-all derivative works of the Software, unless such copies or derivative
-works are solely in the form of machine-executable object code generated by
-a source language processor.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
-SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
-FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
-ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.
\ No newline at end of file
diff -Nbaur gcc-4.6.3/zlib/contrib/dotzlib/readme.txt gcc-4.6.3-psp/zlib/contrib/dotzlib/readme.txt
--- gcc-4.6.3/zlib/contrib/dotzlib/readme.txt	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/dotzlib/readme.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,58 +0,0 @@
-This directory contains a .Net wrapper class library for the ZLib1.dll
-
-The wrapper includes support for inflating/deflating memory buffers, 
-.Net streaming wrappers for the gz streams part of zlib, and wrappers
-for the checksum parts of zlib. See DotZLib/UnitTests.cs for examples.
-
-Directory structure:
---------------------
-
-LICENSE_1_0.txt       - License file.
-readme.txt            - This file.
-DotZLib.chm           - Class library documentation
-DotZLib.build         - NAnt build file
-DotZLib.sln           - Microsoft Visual Studio 2003 solution file
-
-DotZLib\*.cs          - Source files for the class library
-
-Unit tests:
------------
-The file DotZLib/UnitTests.cs contains unit tests for use with NUnit 2.1 or higher.
-To include unit tests in the build, define nunit before building.
-
-
-Build instructions:
--------------------
-
-1. Using Visual Studio.Net 2003:
-   Open DotZLib.sln in VS.Net and build from there. Output file (DotZLib.dll)
-   will be found ./DotZLib/bin/release or ./DotZLib/bin/debug, depending on 
-   you are building the release or debug version of the library. Check 
-   DotZLib/UnitTests.cs for instructions on how to include unit tests in the
-   build.
-   
-2. Using NAnt:
-   Open a command prompt with access to the build environment and run nant
-   in the same directory as the DotZLib.build file.
-   You can define 2 properties on the nant command-line to control the build:
-   debug={true|false} to toggle between release/debug builds (default=true).
-   nunit={true|false} to include or esclude unit tests (default=true).
-   Also the target clean will remove binaries.
-   Output file (DotZLib.dll) will be found in either ./DotZLib/bin/release 
-   or ./DotZLib/bin/debug, depending on whether you are building the release 
-   or debug version of the library.
-
-   Examples: 
-     nant -D:debug=false -D:nunit=false
-       will build a release mode version of the library without unit tests.
-     nant
-       will build a debug version of the library with unit tests 
-     nant clean
-       will remove all previously built files.
-
-
----------------------------------
-Copyright (c) Henrik Ravn 2004
-
-Use, modification and distribution are subject to the Boost Software License, Version 1.0. 
-(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
diff -Nbaur gcc-4.6.3/zlib/contrib/infback9/infback9.c gcc-4.6.3-psp/zlib/contrib/infback9/infback9.c
--- gcc-4.6.3/zlib/contrib/infback9/infback9.c	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/infback9/infback9.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,608 +0,0 @@
-/* infback9.c -- inflate deflate64 data using a call-back interface
- * Copyright (C) 1995-2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "infback9.h"
-#include "inftree9.h"
-#include "inflate9.h"
-
-#define WSIZE 65536UL
-
-/*
-   strm provides memory allocation functions in zalloc and zfree, or
-   Z_NULL to use the library memory allocation functions.
-
-   window is a user-supplied window and output buffer that is 64K bytes.
- */
-int ZEXPORT inflateBack9Init_(strm, window, version, stream_size)
-z_stream FAR *strm;
-unsigned char FAR *window;
-const char *version;
-int stream_size;
-{
-    struct inflate_state FAR *state;
-
-    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
-        stream_size != (int)(sizeof(z_stream)))
-        return Z_VERSION_ERROR;
-    if (strm == Z_NULL || window == Z_NULL)
-        return Z_STREAM_ERROR;
-    strm->msg = Z_NULL;                 /* in case we return an error */
-    if (strm->zalloc == (alloc_func)0) {
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-    }
-    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
-    state = (struct inflate_state FAR *)ZALLOC(strm, 1,
-                                               sizeof(struct inflate_state));
-    if (state == Z_NULL) return Z_MEM_ERROR;
-    Tracev((stderr, "inflate: allocated\n"));
-    strm->state = (voidpf)state;
-    state->window = window;
-    return Z_OK;
-}
-
-/*
-   Build and output length and distance decoding tables for fixed code
-   decoding.
- */
-#ifdef MAKEFIXED
-#include <stdio.h>
-
-void makefixed9(void)
-{
-    unsigned sym, bits, low, size;
-    code *next, *lenfix, *distfix;
-    struct inflate_state state;
-    code fixed[544];
-
-    /* literal/length table */
-    sym = 0;
-    while (sym < 144) state.lens[sym++] = 8;
-    while (sym < 256) state.lens[sym++] = 9;
-    while (sym < 280) state.lens[sym++] = 7;
-    while (sym < 288) state.lens[sym++] = 8;
-    next = fixed;
-    lenfix = next;
-    bits = 9;
-    inflate_table9(LENS, state.lens, 288, &(next), &(bits), state.work);
-
-    /* distance table */
-    sym = 0;
-    while (sym < 32) state.lens[sym++] = 5;
-    distfix = next;
-    bits = 5;
-    inflate_table9(DISTS, state.lens, 32, &(next), &(bits), state.work);
-
-    /* write tables */
-    puts("    /* inffix9.h -- table for decoding deflate64 fixed codes");
-    puts("     * Generated automatically by makefixed9().");
-    puts("     */");
-    puts("");
-    puts("    /* WARNING: this file should *not* be used by applications.");
-    puts("       It is part of the implementation of this library and is");
-    puts("       subject to change. Applications should only use zlib.h.");
-    puts("     */");
-    puts("");
-    size = 1U << 9;
-    printf("    static const code lenfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 6) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", lenfix[low].op, lenfix[low].bits,
-               lenfix[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-    size = 1U << 5;
-    printf("\n    static const code distfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 5) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", distfix[low].op, distfix[low].bits,
-               distfix[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-}
-#endif /* MAKEFIXED */
-
-/* Macros for inflateBack(): */
-
-/* Clear the input bit accumulator */
-#define INITBITS() \
-    do { \
-        hold = 0; \
-        bits = 0; \
-    } while (0)
-
-/* Assure that some input is available.  If input is requested, but denied,
-   then return a Z_BUF_ERROR from inflateBack(). */
-#define PULL() \
-    do { \
-        if (have == 0) { \
-            have = in(in_desc, &next); \
-            if (have == 0) { \
-                next = Z_NULL; \
-                ret = Z_BUF_ERROR; \
-                goto inf_leave; \
-            } \
-        } \
-    } while (0)
-
-/* Get a byte of input into the bit accumulator, or return from inflateBack()
-   with an error if there is no input available. */
-#define PULLBYTE() \
-    do { \
-        PULL(); \
-        have--; \
-        hold += (unsigned long)(*next++) << bits; \
-        bits += 8; \
-    } while (0)
-
-/* Assure that there are at least n bits in the bit accumulator.  If there is
-   not enough available input to do that, then return from inflateBack() with
-   an error. */
-#define NEEDBITS(n) \
-    do { \
-        while (bits < (unsigned)(n)) \
-            PULLBYTE(); \
-    } while (0)
-
-/* Return the low n bits of the bit accumulator (n <= 16) */
-#define BITS(n) \
-    ((unsigned)hold & ((1U << (n)) - 1))
-
-/* Remove n bits from the bit accumulator */
-#define DROPBITS(n) \
-    do { \
-        hold >>= (n); \
-        bits -= (unsigned)(n); \
-    } while (0)
-
-/* Remove zero to seven bits as needed to go to a byte boundary */
-#define BYTEBITS() \
-    do { \
-        hold >>= bits & 7; \
-        bits -= bits & 7; \
-    } while (0)
-
-/* Assure that some output space is available, by writing out the window
-   if it's full.  If the write fails, return from inflateBack() with a
-   Z_BUF_ERROR. */
-#define ROOM() \
-    do { \
-        if (left == 0) { \
-            put = window; \
-            left = WSIZE; \
-            wrap = 1; \
-            if (out(out_desc, put, (unsigned)left)) { \
-                ret = Z_BUF_ERROR; \
-                goto inf_leave; \
-            } \
-        } \
-    } while (0)
-
-/*
-   strm provides the memory allocation functions and window buffer on input,
-   and provides information on the unused input on return.  For Z_DATA_ERROR
-   returns, strm will also provide an error message.
-
-   in() and out() are the call-back input and output functions.  When
-   inflateBack() needs more input, it calls in().  When inflateBack() has
-   filled the window with output, or when it completes with data in the
-   window, it calls out() to write out the data.  The application must not
-   change the provided input until in() is called again or inflateBack()
-   returns.  The application must not change the window/output buffer until
-   inflateBack() returns.
-
-   in() and out() are called with a descriptor parameter provided in the
-   inflateBack() call.  This parameter can be a structure that provides the
-   information required to do the read or write, as well as accumulated
-   information on the input and output such as totals and check values.
-
-   in() should return zero on failure.  out() should return non-zero on
-   failure.  If either in() or out() fails, than inflateBack() returns a
-   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it
-   was in() or out() that caused in the error.  Otherwise,  inflateBack()
-   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
-   error, or Z_MEM_ERROR if it could not allocate memory for the state.
-   inflateBack() can also return Z_STREAM_ERROR if the input parameters
-   are not correct, i.e. strm is Z_NULL or the state was not initialized.
- */
-int ZEXPORT inflateBack9(strm, in, in_desc, out, out_desc)
-z_stream FAR *strm;
-in_func in;
-void FAR *in_desc;
-out_func out;
-void FAR *out_desc;
-{
-    struct inflate_state FAR *state;
-    unsigned char FAR *next;    /* next input */
-    unsigned char FAR *put;     /* next output */
-    unsigned have;              /* available input */
-    unsigned long left;         /* available output */
-    inflate_mode mode;          /* current inflate mode */
-    int lastblock;              /* true if processing last block */
-    int wrap;                   /* true if the window has wrapped */
-    unsigned long write;        /* window write index */
-    unsigned char FAR *window;  /* allocated sliding window, if needed */
-    unsigned long hold;         /* bit buffer */
-    unsigned bits;              /* bits in bit buffer */
-    unsigned extra;             /* extra bits needed */
-    unsigned long length;       /* literal or length of data to copy */
-    unsigned long offset;       /* distance back to copy string from */
-    unsigned long copy;         /* number of stored or match bytes to copy */
-    unsigned char FAR *from;    /* where to copy match bytes from */
-    code const FAR *lencode;    /* starting table for length/literal codes */
-    code const FAR *distcode;   /* starting table for distance codes */
-    unsigned lenbits;           /* index bits for lencode */
-    unsigned distbits;          /* index bits for distcode */
-    code this;                  /* current decoding table entry */
-    code last;                  /* parent table entry */
-    unsigned len;               /* length to copy for repeats, bits to drop */
-    int ret;                    /* return code */
-    static const unsigned short order[19] = /* permutation of code lengths */
-        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-#include "inffix9.h"
-
-    /* Check that the strm exists and that the state was initialized */
-    if (strm == Z_NULL || strm->state == Z_NULL)
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-
-    /* Reset the state */
-    strm->msg = Z_NULL;
-    mode = TYPE;
-    lastblock = 0;
-    write = 0;
-    wrap = 0;
-    window = state->window;
-    next = strm->next_in;
-    have = next != Z_NULL ? strm->avail_in : 0;
-    hold = 0;
-    bits = 0;
-    put = window;
-    left = WSIZE;
-    lencode = Z_NULL;
-    distcode = Z_NULL;
-
-    /* Inflate until end of block marked as last */
-    for (;;)
-        switch (mode) {
-        case TYPE:
-            /* determine and dispatch block type */
-            if (lastblock) {
-                BYTEBITS();
-                mode = DONE;
-                break;
-            }
-            NEEDBITS(3);
-            lastblock = BITS(1);
-            DROPBITS(1);
-            switch (BITS(2)) {
-            case 0:                             /* stored block */
-                Tracev((stderr, "inflate:     stored block%s\n",
-                        lastblock ? " (last)" : ""));
-                mode = STORED;
-                break;
-            case 1:                             /* fixed block */
-                lencode = lenfix;
-                lenbits = 9;
-                distcode = distfix;
-                distbits = 5;
-                Tracev((stderr, "inflate:     fixed codes block%s\n",
-                        lastblock ? " (last)" : ""));
-                mode = LEN;                     /* decode codes */
-                break;
-            case 2:                             /* dynamic block */
-                Tracev((stderr, "inflate:     dynamic codes block%s\n",
-                        lastblock ? " (last)" : ""));
-                mode = TABLE;
-                break;
-            case 3:
-                strm->msg = (char *)"invalid block type";
-                mode = BAD;
-            }
-            DROPBITS(2);
-            break;
-
-        case STORED:
-            /* get and verify stored block length */
-            BYTEBITS();                         /* go to byte boundary */
-            NEEDBITS(32);
-            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
-                strm->msg = (char *)"invalid stored block lengths";
-                mode = BAD;
-                break;
-            }
-            length = (unsigned)hold & 0xffff;
-            Tracev((stderr, "inflate:       stored length %lu\n",
-                    length));
-            INITBITS();
-
-            /* copy stored block from input to output */
-            while (length != 0) {
-                copy = length;
-                PULL();
-                ROOM();
-                if (copy > have) copy = have;
-                if (copy > left) copy = left;
-                zmemcpy(put, next, copy);
-                have -= copy;
-                next += copy;
-                left -= copy;
-                put += copy;
-                length -= copy;
-            }
-            Tracev((stderr, "inflate:       stored end\n"));
-            mode = TYPE;
-            break;
-
-        case TABLE:
-            /* get dynamic table entries descriptor */
-            NEEDBITS(14);
-            state->nlen = BITS(5) + 257;
-            DROPBITS(5);
-            state->ndist = BITS(5) + 1;
-            DROPBITS(5);
-            state->ncode = BITS(4) + 4;
-            DROPBITS(4);
-            if (state->nlen > 286) {
-                strm->msg = (char *)"too many length symbols";
-                mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       table sizes ok\n"));
-
-            /* get code length code lengths (not a typo) */
-            state->have = 0;
-            while (state->have < state->ncode) {
-                NEEDBITS(3);
-                state->lens[order[state->have++]] = (unsigned short)BITS(3);
-                DROPBITS(3);
-            }
-            while (state->have < 19)
-                state->lens[order[state->have++]] = 0;
-            state->next = state->codes;
-            lencode = (code const FAR *)(state->next);
-            lenbits = 7;
-            ret = inflate_table9(CODES, state->lens, 19, &(state->next),
-                                &(lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid code lengths set";
-                mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       code lengths ok\n"));
-
-            /* get length and distance code code lengths */
-            state->have = 0;
-            while (state->have < state->nlen + state->ndist) {
-                for (;;) {
-                    this = lencode[BITS(lenbits)];
-                    if ((unsigned)(this.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                if (this.val < 16) {
-                    NEEDBITS(this.bits);
-                    DROPBITS(this.bits);
-                    state->lens[state->have++] = this.val;
-                }
-                else {
-                    if (this.val == 16) {
-                        NEEDBITS(this.bits + 2);
-                        DROPBITS(this.bits);
-                        if (state->have == 0) {
-                            strm->msg = (char *)"invalid bit length repeat";
-                            mode = BAD;
-                            break;
-                        }
-                        len = (unsigned)(state->lens[state->have - 1]);
-                        copy = 3 + BITS(2);
-                        DROPBITS(2);
-                    }
-                    else if (this.val == 17) {
-                        NEEDBITS(this.bits + 3);
-                        DROPBITS(this.bits);
-                        len = 0;
-                        copy = 3 + BITS(3);
-                        DROPBITS(3);
-                    }
-                    else {
-                        NEEDBITS(this.bits + 7);
-                        DROPBITS(this.bits);
-                        len = 0;
-                        copy = 11 + BITS(7);
-                        DROPBITS(7);
-                    }
-                    if (state->have + copy > state->nlen + state->ndist) {
-                        strm->msg = (char *)"invalid bit length repeat";
-                        mode = BAD;
-                        break;
-                    }
-                    while (copy--)
-                        state->lens[state->have++] = (unsigned short)len;
-                }
-            }
-
-            /* handle error breaks in while */
-            if (mode == BAD) break;
-
-            /* build code tables */
-            state->next = state->codes;
-            lencode = (code const FAR *)(state->next);
-            lenbits = 9;
-            ret = inflate_table9(LENS, state->lens, state->nlen,
-                            &(state->next), &(lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid literal/lengths set";
-                mode = BAD;
-                break;
-            }
-            distcode = (code const FAR *)(state->next);
-            distbits = 6;
-            ret = inflate_table9(DISTS, state->lens + state->nlen,
-                            state->ndist, &(state->next), &(distbits),
-                            state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid distances set";
-                mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       codes ok\n"));
-            mode = LEN;
-
-        case LEN:
-            /* get a literal, length, or end-of-block code */
-            for (;;) {
-                this = lencode[BITS(lenbits)];
-                if ((unsigned)(this.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if (this.op && (this.op & 0xf0) == 0) {
-                last = this;
-                for (;;) {
-                    this = lencode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + this.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-            }
-            DROPBITS(this.bits);
-            length = (unsigned)this.val;
-
-            /* process literal */
-            if (this.op == 0) {
-                Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
-                        "inflate:         literal '%c'\n" :
-                        "inflate:         literal 0x%02x\n", this.val));
-                ROOM();
-                *put++ = (unsigned char)(length);
-                left--;
-                mode = LEN;
-                break;
-            }
-
-            /* process end of block */
-            if (this.op & 32) {
-                Tracevv((stderr, "inflate:         end of block\n"));
-                mode = TYPE;
-                break;
-            }
-
-            /* invalid code */
-            if (this.op & 64) {
-                strm->msg = (char *)"invalid literal/length code";
-                mode = BAD;
-                break;
-            }
-
-            /* length code -- get extra bits, if any */
-            extra = (unsigned)(this.op) & 31;
-            if (extra != 0) {
-                NEEDBITS(extra);
-                length += BITS(extra);
-                DROPBITS(extra);
-            }
-            Tracevv((stderr, "inflate:         length %lu\n", length));
-
-            /* get distance code */
-            for (;;) {
-                this = distcode[BITS(distbits)];
-                if ((unsigned)(this.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if ((this.op & 0xf0) == 0) {
-                last = this;
-                for (;;) {
-                    this = distcode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + this.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-            }
-            DROPBITS(this.bits);
-            if (this.op & 64) {
-                strm->msg = (char *)"invalid distance code";
-                mode = BAD;
-                break;
-            }
-            offset = (unsigned)this.val;
-
-            /* get distance extra bits, if any */
-            extra = (unsigned)(this.op) & 15;
-            if (extra != 0) {
-                NEEDBITS(extra);
-                offset += BITS(extra);
-                DROPBITS(extra);
-            }
-            if (offset > WSIZE - (wrap ? 0: left)) {
-                strm->msg = (char *)"invalid distance too far back";
-                mode = BAD;
-                break;
-            }
-            Tracevv((stderr, "inflate:         distance %lu\n", offset));
-
-            /* copy match from window to output */
-            do {
-                ROOM();
-                copy = WSIZE - offset;
-                if (copy < left) {
-                    from = put + copy;
-                    copy = left - copy;
-                }
-                else {
-                    from = put - offset;
-                    copy = left;
-                }
-                if (copy > length) copy = length;
-                length -= copy;
-                left -= copy;
-                do {
-                    *put++ = *from++;
-                } while (--copy);
-            } while (length != 0);
-            break;
-
-        case DONE:
-            /* inflate stream terminated properly -- write leftover output */
-            ret = Z_STREAM_END;
-            if (left < WSIZE) {
-                if (out(out_desc, window, (unsigned)(WSIZE - left)))
-                    ret = Z_BUF_ERROR;
-            }
-            goto inf_leave;
-
-        case BAD:
-            ret = Z_DATA_ERROR;
-            goto inf_leave;
-
-        default:                /* can't happen, but makes compilers happy */
-            ret = Z_STREAM_ERROR;
-            goto inf_leave;
-        }
-
-    /* Return unused input */
-  inf_leave:
-    strm->next_in = next;
-    strm->avail_in = have;
-    return ret;
-}
-
-int ZEXPORT inflateBack9End(strm)
-z_stream FAR *strm;
-{
-    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
-        return Z_STREAM_ERROR;
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-    Tracev((stderr, "inflate: end\n"));
-    return Z_OK;
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/infback9/infback9.h gcc-4.6.3-psp/zlib/contrib/infback9/infback9.h
--- gcc-4.6.3/zlib/contrib/infback9/infback9.h	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/infback9/infback9.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
-/* infback9.h -- header for using inflateBack9 functions
- * Copyright (C) 2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- * This header file and associated patches provide a decoder for PKWare's
- * undocumented deflate64 compression method (method 9).  Use with infback9.c,
- * inftree9.h, inftree9.c, and inffix9.h.  These patches are not supported.
- * This should be compiled with zlib, since it uses zutil.h and zutil.o.
- * This code has not yet been tested on 16-bit architectures.  See the
- * comments in zlib.h for inflateBack() usage.  These functions are used
- * identically, except that there is no windowBits parameter, and a 64K
- * window must be provided.  Also if int's are 16 bits, then a zero for
- * the third parameter of the "out" function actually means 65536UL.
- * zlib.h must be included before this header file.
- */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-ZEXTERN int ZEXPORT inflateBack9 OF((z_stream FAR *strm,
-                                    in_func in, void FAR *in_desc,
-                                    out_func out, void FAR *out_desc));
-ZEXTERN int ZEXPORT inflateBack9End OF((z_stream FAR *strm));
-ZEXTERN int ZEXPORT inflateBack9Init_ OF((z_stream FAR *strm,
-                                         unsigned char FAR *window,
-                                         const char *version,
-                                         int stream_size));
-#define inflateBack9Init(strm, window) \
-        inflateBack9Init_((strm), (window), \
-        ZLIB_VERSION, sizeof(z_stream))
-
-#ifdef __cplusplus
-}
-#endif
diff -Nbaur gcc-4.6.3/zlib/contrib/infback9/inffix9.h gcc-4.6.3-psp/zlib/contrib/infback9/inffix9.h
--- gcc-4.6.3/zlib/contrib/infback9/inffix9.h	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/infback9/inffix9.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,107 +0,0 @@
-    /* inffix9.h -- table for decoding deflate64 fixed codes
-     * Generated automatically by makefixed9().
-     */
-
-    /* WARNING: this file should *not* be used by applications.
-       It is part of the implementation of this library and is
-       subject to change. Applications should only use zlib.h.
-     */
-
-    static const code lenfix[512] = {
-        {96,7,0},{0,8,80},{0,8,16},{132,8,115},{130,7,31},{0,8,112},
-        {0,8,48},{0,9,192},{128,7,10},{0,8,96},{0,8,32},{0,9,160},
-        {0,8,0},{0,8,128},{0,8,64},{0,9,224},{128,7,6},{0,8,88},
-        {0,8,24},{0,9,144},{131,7,59},{0,8,120},{0,8,56},{0,9,208},
-        {129,7,17},{0,8,104},{0,8,40},{0,9,176},{0,8,8},{0,8,136},
-        {0,8,72},{0,9,240},{128,7,4},{0,8,84},{0,8,20},{133,8,227},
-        {131,7,43},{0,8,116},{0,8,52},{0,9,200},{129,7,13},{0,8,100},
-        {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},
-        {128,7,8},{0,8,92},{0,8,28},{0,9,152},{132,7,83},{0,8,124},
-        {0,8,60},{0,9,216},{130,7,23},{0,8,108},{0,8,44},{0,9,184},
-        {0,8,12},{0,8,140},{0,8,76},{0,9,248},{128,7,3},{0,8,82},
-        {0,8,18},{133,8,163},{131,7,35},{0,8,114},{0,8,50},{0,9,196},
-        {129,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},{0,8,130},
-        {0,8,66},{0,9,228},{128,7,7},{0,8,90},{0,8,26},{0,9,148},
-        {132,7,67},{0,8,122},{0,8,58},{0,9,212},{130,7,19},{0,8,106},
-        {0,8,42},{0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},
-        {128,7,5},{0,8,86},{0,8,22},{65,8,0},{131,7,51},{0,8,118},
-        {0,8,54},{0,9,204},{129,7,15},{0,8,102},{0,8,38},{0,9,172},
-        {0,8,6},{0,8,134},{0,8,70},{0,9,236},{128,7,9},{0,8,94},
-        {0,8,30},{0,9,156},{132,7,99},{0,8,126},{0,8,62},{0,9,220},
-        {130,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},
-        {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{133,8,131},
-        {130,7,31},{0,8,113},{0,8,49},{0,9,194},{128,7,10},{0,8,97},
-        {0,8,33},{0,9,162},{0,8,1},{0,8,129},{0,8,65},{0,9,226},
-        {128,7,6},{0,8,89},{0,8,25},{0,9,146},{131,7,59},{0,8,121},
-        {0,8,57},{0,9,210},{129,7,17},{0,8,105},{0,8,41},{0,9,178},
-        {0,8,9},{0,8,137},{0,8,73},{0,9,242},{128,7,4},{0,8,85},
-        {0,8,21},{144,8,3},{131,7,43},{0,8,117},{0,8,53},{0,9,202},
-        {129,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},
-        {0,8,69},{0,9,234},{128,7,8},{0,8,93},{0,8,29},{0,9,154},
-        {132,7,83},{0,8,125},{0,8,61},{0,9,218},{130,7,23},{0,8,109},
-        {0,8,45},{0,9,186},{0,8,13},{0,8,141},{0,8,77},{0,9,250},
-        {128,7,3},{0,8,83},{0,8,19},{133,8,195},{131,7,35},{0,8,115},
-        {0,8,51},{0,9,198},{129,7,11},{0,8,99},{0,8,35},{0,9,166},
-        {0,8,3},{0,8,131},{0,8,67},{0,9,230},{128,7,7},{0,8,91},
-        {0,8,27},{0,9,150},{132,7,67},{0,8,123},{0,8,59},{0,9,214},
-        {130,7,19},{0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},
-        {0,8,75},{0,9,246},{128,7,5},{0,8,87},{0,8,23},{77,8,0},
-        {131,7,51},{0,8,119},{0,8,55},{0,9,206},{129,7,15},{0,8,103},
-        {0,8,39},{0,9,174},{0,8,7},{0,8,135},{0,8,71},{0,9,238},
-        {128,7,9},{0,8,95},{0,8,31},{0,9,158},{132,7,99},{0,8,127},
-        {0,8,63},{0,9,222},{130,7,27},{0,8,111},{0,8,47},{0,9,190},
-        {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},
-        {0,8,16},{132,8,115},{130,7,31},{0,8,112},{0,8,48},{0,9,193},
-        {128,7,10},{0,8,96},{0,8,32},{0,9,161},{0,8,0},{0,8,128},
-        {0,8,64},{0,9,225},{128,7,6},{0,8,88},{0,8,24},{0,9,145},
-        {131,7,59},{0,8,120},{0,8,56},{0,9,209},{129,7,17},{0,8,104},
-        {0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},{0,9,241},
-        {128,7,4},{0,8,84},{0,8,20},{133,8,227},{131,7,43},{0,8,116},
-        {0,8,52},{0,9,201},{129,7,13},{0,8,100},{0,8,36},{0,9,169},
-        {0,8,4},{0,8,132},{0,8,68},{0,9,233},{128,7,8},{0,8,92},
-        {0,8,28},{0,9,153},{132,7,83},{0,8,124},{0,8,60},{0,9,217},
-        {130,7,23},{0,8,108},{0,8,44},{0,9,185},{0,8,12},{0,8,140},
-        {0,8,76},{0,9,249},{128,7,3},{0,8,82},{0,8,18},{133,8,163},
-        {131,7,35},{0,8,114},{0,8,50},{0,9,197},{129,7,11},{0,8,98},
-        {0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},
-        {128,7,7},{0,8,90},{0,8,26},{0,9,149},{132,7,67},{0,8,122},
-        {0,8,58},{0,9,213},{130,7,19},{0,8,106},{0,8,42},{0,9,181},
-        {0,8,10},{0,8,138},{0,8,74},{0,9,245},{128,7,5},{0,8,86},
-        {0,8,22},{65,8,0},{131,7,51},{0,8,118},{0,8,54},{0,9,205},
-        {129,7,15},{0,8,102},{0,8,38},{0,9,173},{0,8,6},{0,8,134},
-        {0,8,70},{0,9,237},{128,7,9},{0,8,94},{0,8,30},{0,9,157},
-        {132,7,99},{0,8,126},{0,8,62},{0,9,221},{130,7,27},{0,8,110},
-        {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},
-        {96,7,0},{0,8,81},{0,8,17},{133,8,131},{130,7,31},{0,8,113},
-        {0,8,49},{0,9,195},{128,7,10},{0,8,97},{0,8,33},{0,9,163},
-        {0,8,1},{0,8,129},{0,8,65},{0,9,227},{128,7,6},{0,8,89},
-        {0,8,25},{0,9,147},{131,7,59},{0,8,121},{0,8,57},{0,9,211},
-        {129,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},{0,8,137},
-        {0,8,73},{0,9,243},{128,7,4},{0,8,85},{0,8,21},{144,8,3},
-        {131,7,43},{0,8,117},{0,8,53},{0,9,203},{129,7,13},{0,8,101},
-        {0,8,37},{0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},
-        {128,7,8},{0,8,93},{0,8,29},{0,9,155},{132,7,83},{0,8,125},
-        {0,8,61},{0,9,219},{130,7,23},{0,8,109},{0,8,45},{0,9,187},
-        {0,8,13},{0,8,141},{0,8,77},{0,9,251},{128,7,3},{0,8,83},
-        {0,8,19},{133,8,195},{131,7,35},{0,8,115},{0,8,51},{0,9,199},
-        {129,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},
-        {0,8,67},{0,9,231},{128,7,7},{0,8,91},{0,8,27},{0,9,151},
-        {132,7,67},{0,8,123},{0,8,59},{0,9,215},{130,7,19},{0,8,107},
-        {0,8,43},{0,9,183},{0,8,11},{0,8,139},{0,8,75},{0,9,247},
-        {128,7,5},{0,8,87},{0,8,23},{77,8,0},{131,7,51},{0,8,119},
-        {0,8,55},{0,9,207},{129,7,15},{0,8,103},{0,8,39},{0,9,175},
-        {0,8,7},{0,8,135},{0,8,71},{0,9,239},{128,7,9},{0,8,95},
-        {0,8,31},{0,9,159},{132,7,99},{0,8,127},{0,8,63},{0,9,223},
-        {130,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},
-        {0,8,79},{0,9,255}
-    };
-
-    static const code distfix[32] = {
-        {128,5,1},{135,5,257},{131,5,17},{139,5,4097},{129,5,5},
-        {137,5,1025},{133,5,65},{141,5,16385},{128,5,3},{136,5,513},
-        {132,5,33},{140,5,8193},{130,5,9},{138,5,2049},{134,5,129},
-        {142,5,32769},{128,5,2},{135,5,385},{131,5,25},{139,5,6145},
-        {129,5,7},{137,5,1537},{133,5,97},{141,5,24577},{128,5,4},
-        {136,5,769},{132,5,49},{140,5,12289},{130,5,13},{138,5,3073},
-        {134,5,193},{142,5,49153}
-    };
diff -Nbaur gcc-4.6.3/zlib/contrib/infback9/inflate9.h gcc-4.6.3-psp/zlib/contrib/infback9/inflate9.h
--- gcc-4.6.3/zlib/contrib/infback9/inflate9.h	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/infback9/inflate9.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,47 +0,0 @@
-/* inflate9.h -- internal inflate state definition
- * Copyright (C) 1995-2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* Possible inflate modes between inflate() calls */
-typedef enum {
-        TYPE,       /* i: waiting for type bits, including last-flag bit */
-        STORED,     /* i: waiting for stored size (length and complement) */
-        TABLE,      /* i: waiting for dynamic block table lengths */
-            LEN,        /* i: waiting for length/lit code */
-    DONE,       /* finished check, done -- remain here until reset */
-    BAD         /* got a data error -- remain here until reset */
-} inflate_mode;
-
-/*
-    State transitions between above modes -
-
-    (most modes can go to the BAD mode -- not shown for clarity)
-
-    Read deflate blocks:
-            TYPE -> STORED or TABLE or LEN or DONE
-            STORED -> TYPE
-            TABLE -> LENLENS -> CODELENS -> LEN
-    Read deflate codes:
-                LEN -> LEN or TYPE
- */
-
-/* state maintained between inflate() calls.  Approximately 7K bytes. */
-struct inflate_state {
-        /* sliding window */
-    unsigned char FAR *window;  /* allocated sliding window, if needed */
-        /* dynamic table building */
-    unsigned ncode;             /* number of code length code lengths */
-    unsigned nlen;              /* number of length code lengths */
-    unsigned ndist;             /* number of distance code lengths */
-    unsigned have;              /* number of code lengths in lens[] */
-    code FAR *next;             /* next available space in codes[] */
-    unsigned short lens[320];   /* temporary storage for code lengths */
-    unsigned short work[288];   /* work area for code table building */
-    code codes[ENOUGH];         /* space for code tables */
-};
diff -Nbaur gcc-4.6.3/zlib/contrib/infback9/inftree9.c gcc-4.6.3-psp/zlib/contrib/infback9/inftree9.c
--- gcc-4.6.3/zlib/contrib/infback9/inftree9.c	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/infback9/inftree9.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,323 +0,0 @@
-/* inftree9.c -- generate Huffman trees for efficient decoding
- * Copyright (C) 1995-2005 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "inftree9.h"
-
-#define MAXBITS 15
-
-const char inflate9_copyright[] =
-   " inflate9 1.2.3 Copyright 1995-2005 Mark Adler ";
-/*
-  If you use the zlib library in a product, an acknowledgment is welcome
-  in the documentation of your product. If for some reason you cannot
-  include such an acknowledgment, I would appreciate that you keep this
-  copyright string in the executable of your product.
- */
-
-/*
-   Build a set of tables to decode the provided canonical Huffman code.
-   The code lengths are lens[0..codes-1].  The result starts at *table,
-   whose indices are 0..2^bits-1.  work is a writable array of at least
-   lens shorts, which is used as a work area.  type is the type of code
-   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
-   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
-   on return points to the next available entry's address.  bits is the
-   requested root table index bits, and on return it is the actual root
-   table index bits.  It will differ if the request is greater than the
-   longest code or if it is less than the shortest code.
- */
-int inflate_table9(type, lens, codes, table, bits, work)
-codetype type;
-unsigned short FAR *lens;
-unsigned codes;
-code FAR * FAR *table;
-unsigned FAR *bits;
-unsigned short FAR *work;
-{
-    unsigned len;               /* a code's length in bits */
-    unsigned sym;               /* index of code symbols */
-    unsigned min, max;          /* minimum and maximum code lengths */
-    unsigned root;              /* number of index bits for root table */
-    unsigned curr;              /* number of index bits for current table */
-    unsigned drop;              /* code bits to drop for sub-table */
-    int left;                   /* number of prefix codes available */
-    unsigned used;              /* code entries in table used */
-    unsigned huff;              /* Huffman code */
-    unsigned incr;              /* for incrementing code, index */
-    unsigned fill;              /* index for replicating entries */
-    unsigned low;               /* low bits for current root entry */
-    unsigned mask;              /* mask for low root bits */
-    code this;                  /* table entry for duplication */
-    code FAR *next;             /* next available space in table */
-    const unsigned short FAR *base;     /* base value table to use */
-    const unsigned short FAR *extra;    /* extra bits table to use */
-    int end;                    /* use base and extra for symbol > end */
-    unsigned short count[MAXBITS+1];    /* number of codes of each length */
-    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
-    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
-        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17,
-        19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115,
-        131, 163, 195, 227, 3, 0, 0};
-    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
-        128, 128, 128, 128, 128, 128, 128, 128, 129, 129, 129, 129,
-        130, 130, 130, 130, 131, 131, 131, 131, 132, 132, 132, 132,
-        133, 133, 133, 133, 144, 201, 196};
-    static const unsigned short dbase[32] = { /* Distance codes 0..31 base */
-        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49,
-        65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073,
-        4097, 6145, 8193, 12289, 16385, 24577, 32769, 49153};
-    static const unsigned short dext[32] = { /* Distance codes 0..31 extra */
-        128, 128, 128, 128, 129, 129, 130, 130, 131, 131, 132, 132,
-        133, 133, 134, 134, 135, 135, 136, 136, 137, 137, 138, 138,
-        139, 139, 140, 140, 141, 141, 142, 142};
-
-    /*
-       Process a set of code lengths to create a canonical Huffman code.  The
-       code lengths are lens[0..codes-1].  Each length corresponds to the
-       symbols 0..codes-1.  The Huffman code is generated by first sorting the
-       symbols by length from short to long, and retaining the symbol order
-       for codes with equal lengths.  Then the code starts with all zero bits
-       for the first code of the shortest length, and the codes are integer
-       increments for the same length, and zeros are appended as the length
-       increases.  For the deflate format, these bits are stored backwards
-       from their more natural integer increment ordering, and so when the
-       decoding tables are built in the large loop below, the integer codes
-       are incremented backwards.
-
-       This routine assumes, but does not check, that all of the entries in
-       lens[] are in the range 0..MAXBITS.  The caller must assure this.
-       1..MAXBITS is interpreted as that code length.  zero means that that
-       symbol does not occur in this code.
-
-       The codes are sorted by computing a count of codes for each length,
-       creating from that a table of starting indices for each length in the
-       sorted table, and then entering the symbols in order in the sorted
-       table.  The sorted table is work[], with that space being provided by
-       the caller.
-
-       The length counts are used for other purposes as well, i.e. finding
-       the minimum and maximum length codes, determining if there are any
-       codes at all, checking for a valid set of lengths, and looking ahead
-       at length counts to determine sub-table sizes when building the
-       decoding tables.
-     */
-
-    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
-    for (len = 0; len <= MAXBITS; len++)
-        count[len] = 0;
-    for (sym = 0; sym < codes; sym++)
-        count[lens[sym]]++;
-
-    /* bound code lengths, force root to be within code lengths */
-    root = *bits;
-    for (max = MAXBITS; max >= 1; max--)
-        if (count[max] != 0) break;
-    if (root > max) root = max;
-    if (max == 0) return -1;            /* no codes! */
-    for (min = 1; min <= MAXBITS; min++)
-        if (count[min] != 0) break;
-    if (root < min) root = min;
-
-    /* check for an over-subscribed or incomplete set of lengths */
-    left = 1;
-    for (len = 1; len <= MAXBITS; len++) {
-        left <<= 1;
-        left -= count[len];
-        if (left < 0) return -1;        /* over-subscribed */
-    }
-    if (left > 0 && (type == CODES || max != 1))
-        return -1;                      /* incomplete set */
-
-    /* generate offsets into symbol table for each length for sorting */
-    offs[1] = 0;
-    for (len = 1; len < MAXBITS; len++)
-        offs[len + 1] = offs[len] + count[len];
-
-    /* sort symbols by length, by symbol order within each length */
-    for (sym = 0; sym < codes; sym++)
-        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
-
-    /*
-       Create and fill in decoding tables.  In this loop, the table being
-       filled is at next and has curr index bits.  The code being used is huff
-       with length len.  That code is converted to an index by dropping drop
-       bits off of the bottom.  For codes where len is less than drop + curr,
-       those top drop + curr - len bits are incremented through all values to
-       fill the table with replicated entries.
-
-       root is the number of index bits for the root table.  When len exceeds
-       root, sub-tables are created pointed to by the root entry with an index
-       of the low root bits of huff.  This is saved in low to check for when a
-       new sub-table should be started.  drop is zero when the root table is
-       being filled, and drop is root when sub-tables are being filled.
-
-       When a new sub-table is needed, it is necessary to look ahead in the
-       code lengths to determine what size sub-table is needed.  The length
-       counts are used for this, and so count[] is decremented as codes are
-       entered in the tables.
-
-       used keeps track of how many table entries have been allocated from the
-       provided *table space.  It is checked when a LENS table is being made
-       against the space in *table, ENOUGH, minus the maximum space needed by
-       the worst case distance code, MAXD.  This should never happen, but the
-       sufficiency of ENOUGH has not been proven exhaustively, hence the check.
-       This assumes that when type == LENS, bits == 9.
-
-       sym increments through all symbols, and the loop terminates when
-       all codes of length max, i.e. all codes, have been processed.  This
-       routine permits incomplete codes, so another loop after this one fills
-       in the rest of the decoding tables with invalid code markers.
-     */
-
-    /* set up for code type */
-    switch (type) {
-    case CODES:
-        base = extra = work;    /* dummy value--not used */
-        end = 19;
-        break;
-    case LENS:
-        base = lbase;
-        base -= 257;
-        extra = lext;
-        extra -= 257;
-        end = 256;
-        break;
-    default:            /* DISTS */
-        base = dbase;
-        extra = dext;
-        end = -1;
-    }
-
-    /* initialize state for loop */
-    huff = 0;                   /* starting code */
-    sym = 0;                    /* starting code symbol */
-    len = min;                  /* starting code length */
-    next = *table;              /* current table to fill in */
-    curr = root;                /* current table index bits */
-    drop = 0;                   /* current bits to drop from code for index */
-    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
-    used = 1U << root;          /* use root table entries */
-    mask = used - 1;            /* mask for comparing low */
-
-    /* check available table space */
-    if (type == LENS && used >= ENOUGH - MAXD)
-        return 1;
-
-    /* process all codes and make table entries */
-    for (;;) {
-        /* create table entry */
-        this.bits = (unsigned char)(len - drop);
-        if ((int)(work[sym]) < end) {
-            this.op = (unsigned char)0;
-            this.val = work[sym];
-        }
-        else if ((int)(work[sym]) > end) {
-            this.op = (unsigned char)(extra[work[sym]]);
-            this.val = base[work[sym]];
-        }
-        else {
-            this.op = (unsigned char)(32 + 64);         /* end of block */
-            this.val = 0;
-        }
-
-        /* replicate for those indices with low len bits equal to huff */
-        incr = 1U << (len - drop);
-        fill = 1U << curr;
-        do {
-            fill -= incr;
-            next[(huff >> drop) + fill] = this;
-        } while (fill != 0);
-
-        /* backwards increment the len-bit code huff */
-        incr = 1U << (len - 1);
-        while (huff & incr)
-            incr >>= 1;
-        if (incr != 0) {
-            huff &= incr - 1;
-            huff += incr;
-        }
-        else
-            huff = 0;
-
-        /* go to next symbol, update count, len */
-        sym++;
-        if (--(count[len]) == 0) {
-            if (len == max) break;
-            len = lens[work[sym]];
-        }
-
-        /* create new sub-table if needed */
-        if (len > root && (huff & mask) != low) {
-            /* if first time, transition to sub-tables */
-            if (drop == 0)
-                drop = root;
-
-            /* increment past last table */
-            next += 1U << curr;
-
-            /* determine length of next table */
-            curr = len - drop;
-            left = (int)(1 << curr);
-            while (curr + drop < max) {
-                left -= count[curr + drop];
-                if (left <= 0) break;
-                curr++;
-                left <<= 1;
-            }
-
-            /* check for enough space */
-            used += 1U << curr;
-            if (type == LENS && used >= ENOUGH - MAXD)
-                return 1;
-
-            /* point entry in root table to sub-table */
-            low = huff & mask;
-            (*table)[low].op = (unsigned char)curr;
-            (*table)[low].bits = (unsigned char)root;
-            (*table)[low].val = (unsigned short)(next - *table);
-        }
-    }
-
-    /*
-       Fill in rest of table for incomplete codes.  This loop is similar to the
-       loop above in incrementing huff for table indices.  It is assumed that
-       len is equal to curr + drop, so there is no loop needed to increment
-       through high index bits.  When the current sub-table is filled, the loop
-       drops back to the root table to fill in any remaining entries there.
-     */
-    this.op = (unsigned char)64;                /* invalid code marker */
-    this.bits = (unsigned char)(len - drop);
-    this.val = (unsigned short)0;
-    while (huff != 0) {
-        /* when done with sub-table, drop back to root table */
-        if (drop != 0 && (huff & mask) != low) {
-            drop = 0;
-            len = root;
-            next = *table;
-            curr = root;
-            this.bits = (unsigned char)len;
-        }
-
-        /* put invalid code marker in table */
-        next[huff >> drop] = this;
-
-        /* backwards increment the len-bit code huff */
-        incr = 1U << (len - 1);
-        while (huff & incr)
-            incr >>= 1;
-        if (incr != 0) {
-            huff &= incr - 1;
-            huff += incr;
-        }
-        else
-            huff = 0;
-    }
-
-    /* set return parameters */
-    *table += used;
-    *bits = root;
-    return 0;
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/infback9/inftree9.h gcc-4.6.3-psp/zlib/contrib/infback9/inftree9.h
--- gcc-4.6.3/zlib/contrib/infback9/inftree9.h	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/infback9/inftree9.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,55 +0,0 @@
-/* inftree9.h -- header to use inftree9.c
- * Copyright (C) 1995-2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* Structure for decoding tables.  Each entry provides either the
-   information needed to do the operation requested by the code that
-   indexed that table entry, or it provides a pointer to another
-   table that indexes more bits of the code.  op indicates whether
-   the entry is a pointer to another table, a literal, a length or
-   distance, an end-of-block, or an invalid code.  For a table
-   pointer, the low four bits of op is the number of index bits of
-   that table.  For a length or distance, the low four bits of op
-   is the number of extra bits to get after the code.  bits is
-   the number of bits in this code or part of the code to drop off
-   of the bit buffer.  val is the actual byte to output in the case
-   of a literal, the base length or distance, or the offset from
-   the current table to the next table.  Each entry is four bytes. */
-typedef struct {
-    unsigned char op;           /* operation, extra bits, table bits */
-    unsigned char bits;         /* bits in this part of the code */
-    unsigned short val;         /* offset in table or code value */
-} code;
-
-/* op values as set by inflate_table():
-    00000000 - literal
-    0000tttt - table link, tttt != 0 is the number of table index bits
-    100eeeee - length or distance, eeee is the number of extra bits
-    01100000 - end of block
-    01000000 - invalid code
- */
-
-/* Maximum size of dynamic tree.  The maximum found in a long but non-
-   exhaustive search was 1444 code structures (852 for length/literals
-   and 592 for distances, the latter actually the result of an
-   exhaustive search).  The true maximum is not known, but the value
-   below is more than safe. */
-#define ENOUGH 2048
-#define MAXD 592
-
-/* Type of code to build for inftable() */
-typedef enum {
-    CODES,
-    LENS,
-    DISTS
-} codetype;
-
-extern int inflate_table9 OF((codetype type, unsigned short FAR *lens,
-                             unsigned codes, code FAR * FAR *table,
-                             unsigned FAR *bits, unsigned short FAR *work));
diff -Nbaur gcc-4.6.3/zlib/contrib/infback9/README gcc-4.6.3-psp/zlib/contrib/infback9/README
--- gcc-4.6.3/zlib/contrib/infback9/README	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/infback9/README	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-See infback9.h for what this is and how to use it.
diff -Nbaur gcc-4.6.3/zlib/contrib/inflate86/inffas86.c gcc-4.6.3-psp/zlib/contrib/inflate86/inffas86.c
--- gcc-4.6.3/zlib/contrib/inflate86/inffas86.c	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/inflate86/inffas86.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1157 +0,0 @@
-/* inffas86.c is a hand tuned assembler version of
- *
- * inffast.c -- fast decoding
- * Copyright (C) 1995-2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * Copyright (C) 2003 Chris Anderson <christop@charm.net>
- * Please use the copyright conditions above.
- *
- * Dec-29-2003 -- I added AMD64 inflate asm support.  This version is also
- * slightly quicker on x86 systems because, instead of using rep movsb to copy
- * data, it uses rep movsw, which moves data in 2-byte chunks instead of single
- * bytes.  I've tested the AMD64 code on a Fedora Core 1 + the x86_64 updates
- * from http://fedora.linux.duke.edu/fc1_x86_64
- * which is running on an Athlon 64 3000+ / Gigabyte GA-K8VT800M system with
- * 1GB ram.  The 64-bit version is about 4% faster than the 32-bit version,
- * when decompressing mozilla-source-1.3.tar.gz.
- *
- * Mar-13-2003 -- Most of this is derived from inffast.S which is derived from
- * the gcc -S output of zlib-1.2.0/inffast.c.  Zlib-1.2.0 is in beta release at
- * the moment.  I have successfully compiled and tested this code with gcc2.96,
- * gcc3.2, icc5.0, msvc6.0.  It is very close to the speed of inffast.S
- * compiled with gcc -DNO_MMX, but inffast.S is still faster on the P3 with MMX
- * enabled.  I will attempt to merge the MMX code into this version.  Newer
- * versions of this and inffast.S can be found at
- * http://www.eetbeetee.com/zlib/ and http://www.charm.net/~christop/zlib/
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-
-/* Mark Adler's comments from inffast.c: */
-
-/*
-   Decode literal, length, and distance codes and write out the resulting
-   literal and match bytes until either not enough input or output is
-   available, an end-of-block is encountered, or a data error is encountered.
-   When large enough input and output buffers are supplied to inflate(), for
-   example, a 16K input buffer and a 64K output buffer, more than 95% of the
-   inflate execution time is spent in this routine.
-
-   Entry assumptions:
-
-        state->mode == LEN
-        strm->avail_in >= 6
-        strm->avail_out >= 258
-        start >= strm->avail_out
-        state->bits < 8
-
-   On return, state->mode is one of:
-
-        LEN -- ran out of enough output space or enough available input
-        TYPE -- reached end of block code, inflate() to interpret next block
-        BAD -- error in block data
-
-   Notes:
-
-    - The maximum input bits used by a length/distance pair is 15 bits for the
-      length code, 5 bits for the length extra, 15 bits for the distance code,
-      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
-      Therefore if strm->avail_in >= 6, then there is enough input to avoid
-      checking for available input while decoding.
-
-    - The maximum bytes that a single length/distance pair can output is 258
-      bytes, which is the maximum length that can be coded.  inflate_fast()
-      requires strm->avail_out >= 258 for each loop to avoid checking for
-      output space.
- */
-void inflate_fast(strm, start)
-z_streamp strm;
-unsigned start;         /* inflate()'s starting value for strm->avail_out */
-{
-    struct inflate_state FAR *state;
-    struct inffast_ar {
-/* 64   32                               x86  x86_64 */
-/* ar offset                              register */
-/*  0    0 */ void *esp;                /* esp save */
-/*  8    4 */ void *ebp;                /* ebp save */
-/* 16    8 */ unsigned char FAR *in;    /* esi rsi  local strm->next_in */
-/* 24   12 */ unsigned char FAR *last;  /*     r9   while in < last */
-/* 32   16 */ unsigned char FAR *out;   /* edi rdi  local strm->next_out */
-/* 40   20 */ unsigned char FAR *beg;   /*          inflate()'s init next_out */
-/* 48   24 */ unsigned char FAR *end;   /*     r10  while out < end */
-/* 56   28 */ unsigned char FAR *window;/*          size of window, wsize!=0 */
-/* 64   32 */ code const FAR *lcode;    /* ebp rbp  local strm->lencode */
-/* 72   36 */ code const FAR *dcode;    /*     r11  local strm->distcode */
-/* 80   40 */ unsigned long hold;       /* edx rdx  local strm->hold */
-/* 88   44 */ unsigned bits;            /* ebx rbx  local strm->bits */
-/* 92   48 */ unsigned wsize;           /*          window size */
-/* 96   52 */ unsigned write;           /*          window write index */
-/*100   56 */ unsigned lmask;           /*     r12  mask for lcode */
-/*104   60 */ unsigned dmask;           /*     r13  mask for dcode */
-/*108   64 */ unsigned len;             /*     r14  match length */
-/*112   68 */ unsigned dist;            /*     r15  match distance */
-/*116   72 */ unsigned status;          /*          set when state chng*/
-    } ar;
-
-#if defined( __GNUC__ ) && defined( __amd64__ ) && ! defined( __i386 )
-#define PAD_AVAIL_IN 6
-#define PAD_AVAIL_OUT 258
-#else
-#define PAD_AVAIL_IN 5
-#define PAD_AVAIL_OUT 257
-#endif
-
-    /* copy state to local variables */
-    state = (struct inflate_state FAR *)strm->state;
-    ar.in = strm->next_in;
-    ar.last = ar.in + (strm->avail_in - PAD_AVAIL_IN);
-    ar.out = strm->next_out;
-    ar.beg = ar.out - (start - strm->avail_out);
-    ar.end = ar.out + (strm->avail_out - PAD_AVAIL_OUT);
-    ar.wsize = state->wsize;
-    ar.write = state->write;
-    ar.window = state->window;
-    ar.hold = state->hold;
-    ar.bits = state->bits;
-    ar.lcode = state->lencode;
-    ar.dcode = state->distcode;
-    ar.lmask = (1U << state->lenbits) - 1;
-    ar.dmask = (1U << state->distbits) - 1;
-
-    /* decode literals and length/distances until end-of-block or not enough
-       input data or output space */
-
-    /* align in on 1/2 hold size boundary */
-    while (((unsigned long)(void *)ar.in & (sizeof(ar.hold) / 2 - 1)) != 0) {
-        ar.hold += (unsigned long)*ar.in++ << ar.bits;
-        ar.bits += 8;
-    }
-
-#if defined( __GNUC__ ) && defined( __amd64__ ) && ! defined( __i386 )
-    __asm__ __volatile__ (
-"        leaq    %0, %%rax\n"
-"        movq    %%rbp, 8(%%rax)\n"       /* save regs rbp and rsp */
-"        movq    %%rsp, (%%rax)\n"
-"        movq    %%rax, %%rsp\n"          /* make rsp point to &ar */
-"        movq    16(%%rsp), %%rsi\n"      /* rsi  = in */
-"        movq    32(%%rsp), %%rdi\n"      /* rdi  = out */
-"        movq    24(%%rsp), %%r9\n"       /* r9   = last */
-"        movq    48(%%rsp), %%r10\n"      /* r10  = end */
-"        movq    64(%%rsp), %%rbp\n"      /* rbp  = lcode */
-"        movq    72(%%rsp), %%r11\n"      /* r11  = dcode */
-"        movq    80(%%rsp), %%rdx\n"      /* rdx  = hold */
-"        movl    88(%%rsp), %%ebx\n"      /* ebx  = bits */
-"        movl    100(%%rsp), %%r12d\n"    /* r12d = lmask */
-"        movl    104(%%rsp), %%r13d\n"    /* r13d = dmask */
-                                          /* r14d = len */
-                                          /* r15d = dist */
-"        cld\n"
-"        cmpq    %%rdi, %%r10\n"
-"        je      .L_one_time\n"           /* if only one decode left */
-"        cmpq    %%rsi, %%r9\n"
-"        je      .L_one_time\n"
-"        jmp     .L_do_loop\n"
-
-".L_one_time:\n"
-"        movq    %%r12, %%r8\n"           /* r8 = lmask */
-"        cmpb    $32, %%bl\n"
-"        ja      .L_get_length_code_one_time\n"
-
-"        lodsl\n"                         /* eax = *(uint *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $32, %%bl\n"             /* bits += 32 */
-"        shlq    %%cl, %%rax\n"
-"        orq     %%rax, %%rdx\n"          /* hold |= *((uint *)in)++ << bits */
-"        jmp     .L_get_length_code_one_time\n"
-
-".align 32,0x90\n"
-".L_while_test:\n"
-"        cmpq    %%rdi, %%r10\n"
-"        jbe     .L_break_loop\n"
-"        cmpq    %%rsi, %%r9\n"
-"        jbe     .L_break_loop\n"
-
-".L_do_loop:\n"
-"        movq    %%r12, %%r8\n"           /* r8 = lmask */
-"        cmpb    $32, %%bl\n"
-"        ja      .L_get_length_code\n"    /* if (32 < bits) */
-
-"        lodsl\n"                         /* eax = *(uint *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $32, %%bl\n"             /* bits += 32 */
-"        shlq    %%cl, %%rax\n"
-"        orq     %%rax, %%rdx\n"          /* hold |= *((uint *)in)++ << bits */
-
-".L_get_length_code:\n"
-"        andq    %%rdx, %%r8\n"            /* r8 &= hold */
-"        movl    (%%rbp,%%r8,4), %%eax\n"  /* eax = lcode[hold & lmask] */
-
-"        movb    %%ah, %%cl\n"            /* cl = this.bits */
-"        subb    %%ah, %%bl\n"            /* bits -= this.bits */
-"        shrq    %%cl, %%rdx\n"           /* hold >>= this.bits */
-
-"        testb   %%al, %%al\n"
-"        jnz     .L_test_for_length_base\n" /* if (op != 0) 45.7% */
-
-"        movq    %%r12, %%r8\n"            /* r8 = lmask */
-"        shrl    $16, %%eax\n"            /* output this.val char */
-"        stosb\n"
-
-".L_get_length_code_one_time:\n"
-"        andq    %%rdx, %%r8\n"            /* r8 &= hold */
-"        movl    (%%rbp,%%r8,4), %%eax\n" /* eax = lcode[hold & lmask] */
-
-".L_dolen:\n"
-"        movb    %%ah, %%cl\n"            /* cl = this.bits */
-"        subb    %%ah, %%bl\n"            /* bits -= this.bits */
-"        shrq    %%cl, %%rdx\n"           /* hold >>= this.bits */
-
-"        testb   %%al, %%al\n"
-"        jnz     .L_test_for_length_base\n" /* if (op != 0) 45.7% */
-
-"        shrl    $16, %%eax\n"            /* output this.val char */
-"        stosb\n"
-"        jmp     .L_while_test\n"
-
-".align 32,0x90\n"
-".L_test_for_length_base:\n"
-"        movl    %%eax, %%r14d\n"         /* len = this */
-"        shrl    $16, %%r14d\n"           /* len = this.val */
-"        movb    %%al, %%cl\n"
-
-"        testb   $16, %%al\n"
-"        jz      .L_test_for_second_level_length\n" /* if ((op & 16) == 0) 8% */
-"        andb    $15, %%cl\n"             /* op &= 15 */
-"        jz      .L_decode_distance\n"    /* if (!op) */
-
-".L_add_bits_to_len:\n"
-"        subb    %%cl, %%bl\n"
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"
-"        andl    %%edx, %%eax\n"          /* eax &= hold */
-"        shrq    %%cl, %%rdx\n"
-"        addl    %%eax, %%r14d\n"         /* len += hold & mask[op] */
-
-".L_decode_distance:\n"
-"        movq    %%r13, %%r8\n"           /* r8 = dmask */
-"        cmpb    $32, %%bl\n"
-"        ja      .L_get_distance_code\n"  /* if (32 < bits) */
-
-"        lodsl\n"                         /* eax = *(uint *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $32, %%bl\n"             /* bits += 32 */
-"        shlq    %%cl, %%rax\n"
-"        orq     %%rax, %%rdx\n"          /* hold |= *((uint *)in)++ << bits */
-
-".L_get_distance_code:\n"
-"        andq    %%rdx, %%r8\n"           /* r8 &= hold */
-"        movl    (%%r11,%%r8,4), %%eax\n" /* eax = dcode[hold & dmask] */
-
-".L_dodist:\n"
-"        movl    %%eax, %%r15d\n"         /* dist = this */
-"        shrl    $16, %%r15d\n"           /* dist = this.val */
-"        movb    %%ah, %%cl\n"
-"        subb    %%ah, %%bl\n"            /* bits -= this.bits */
-"        shrq    %%cl, %%rdx\n"           /* hold >>= this.bits */
-"        movb    %%al, %%cl\n"            /* cl = this.op */
-
-"        testb   $16, %%al\n"             /* if ((op & 16) == 0) */
-"        jz      .L_test_for_second_level_dist\n"
-"        andb    $15, %%cl\n"             /* op &= 15 */
-"        jz      .L_check_dist_one\n"
-
-".L_add_bits_to_dist:\n"
-"        subb    %%cl, %%bl\n"
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"                 /* (1 << op) - 1 */
-"        andl    %%edx, %%eax\n"          /* eax &= hold */
-"        shrq    %%cl, %%rdx\n"
-"        addl    %%eax, %%r15d\n"         /* dist += hold & ((1 << op) - 1) */
-
-".L_check_window:\n"
-"        movq    %%rsi, %%r8\n"           /* save in so from can use it's reg */
-"        movq    %%rdi, %%rax\n"
-"        subq    40(%%rsp), %%rax\n"      /* nbytes = out - beg */
-
-"        cmpl    %%r15d, %%eax\n"
-"        jb      .L_clip_window\n"        /* if (dist > nbytes) 4.2% */
-
-"        movl    %%r14d, %%ecx\n"         /* ecx = len */
-"        movq    %%rdi, %%rsi\n"
-"        subq    %%r15, %%rsi\n"          /* from = out - dist */
-
-"        sarl    %%ecx\n"
-"        jnc     .L_copy_two\n"           /* if len % 2 == 0 */
-
-"        rep     movsw\n"
-"        movb    (%%rsi), %%al\n"
-"        movb    %%al, (%%rdi)\n"
-"        incq    %%rdi\n"
-
-"        movq    %%r8, %%rsi\n"           /* move in back to %rsi, toss from */
-"        jmp     .L_while_test\n"
-
-".L_copy_two:\n"
-"        rep     movsw\n"
-"        movq    %%r8, %%rsi\n"           /* move in back to %rsi, toss from */
-"        jmp     .L_while_test\n"
-
-".align 32,0x90\n"
-".L_check_dist_one:\n"
-"        cmpl    $1, %%r15d\n"            /* if dist 1, is a memset */
-"        jne     .L_check_window\n"
-"        cmpq    %%rdi, 40(%%rsp)\n"      /* if out == beg, outside window */
-"        je      .L_check_window\n"
-
-"        movl    %%r14d, %%ecx\n"         /* ecx = len */
-"        movb    -1(%%rdi), %%al\n"
-"        movb    %%al, %%ah\n"
-
-"        sarl    %%ecx\n"
-"        jnc     .L_set_two\n"
-"        movb    %%al, (%%rdi)\n"
-"        incq    %%rdi\n"
-
-".L_set_two:\n"
-"        rep     stosw\n"
-"        jmp     .L_while_test\n"
-
-".align 32,0x90\n"
-".L_test_for_second_level_length:\n"
-"        testb   $64, %%al\n"
-"        jnz     .L_test_for_end_of_block\n" /* if ((op & 64) != 0) */
-
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"
-"        andl    %%edx, %%eax\n"         /* eax &= hold */
-"        addl    %%r14d, %%eax\n"        /* eax += len */
-"        movl    (%%rbp,%%rax,4), %%eax\n" /* eax = lcode[val+(hold&mask[op])]*/
-"        jmp     .L_dolen\n"
-
-".align 32,0x90\n"
-".L_test_for_second_level_dist:\n"
-"        testb   $64, %%al\n"
-"        jnz     .L_invalid_distance_code\n" /* if ((op & 64) != 0) */
-
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"
-"        andl    %%edx, %%eax\n"         /* eax &= hold */
-"        addl    %%r15d, %%eax\n"        /* eax += dist */
-"        movl    (%%r11,%%rax,4), %%eax\n" /* eax = dcode[val+(hold&mask[op])]*/
-"        jmp     .L_dodist\n"
-
-".align 32,0x90\n"
-".L_clip_window:\n"
-"        movl    %%eax, %%ecx\n"         /* ecx = nbytes */
-"        movl    92(%%rsp), %%eax\n"     /* eax = wsize, prepare for dist cmp */
-"        negl    %%ecx\n"                /* nbytes = -nbytes */
-
-"        cmpl    %%r15d, %%eax\n"
-"        jb      .L_invalid_distance_too_far\n" /* if (dist > wsize) */
-
-"        addl    %%r15d, %%ecx\n"         /* nbytes = dist - nbytes */
-"        cmpl    $0, 96(%%rsp)\n"
-"        jne     .L_wrap_around_window\n" /* if (write != 0) */
-
-"        movq    56(%%rsp), %%rsi\n"     /* from  = window */
-"        subl    %%ecx, %%eax\n"         /* eax  -= nbytes */
-"        addq    %%rax, %%rsi\n"         /* from += wsize - nbytes */
-
-"        movl    %%r14d, %%eax\n"        /* eax = len */
-"        cmpl    %%ecx, %%r14d\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* eax -= nbytes */
-"        rep     movsb\n"
-"        movq    %%rdi, %%rsi\n"
-"        subq    %%r15, %%rsi\n"         /* from = &out[ -dist ] */
-"        jmp     .L_do_copy\n"
-
-".align 32,0x90\n"
-".L_wrap_around_window:\n"
-"        movl    96(%%rsp), %%eax\n"     /* eax = write */
-"        cmpl    %%eax, %%ecx\n"
-"        jbe     .L_contiguous_in_window\n" /* if (write >= nbytes) */
-
-"        movl    92(%%rsp), %%esi\n"     /* from  = wsize */
-"        addq    56(%%rsp), %%rsi\n"     /* from += window */
-"        addq    %%rax, %%rsi\n"         /* from += write */
-"        subq    %%rcx, %%rsi\n"         /* from -= nbytes */
-"        subl    %%eax, %%ecx\n"         /* nbytes -= write */
-
-"        movl    %%r14d, %%eax\n"        /* eax = len */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movq    56(%%rsp), %%rsi\n"     /* from = window */
-"        movl    96(%%rsp), %%ecx\n"     /* nbytes = write */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movq    %%rdi, %%rsi\n"
-"        subq    %%r15, %%rsi\n"         /* from = out - dist */
-"        jmp     .L_do_copy\n"
-
-".align 32,0x90\n"
-".L_contiguous_in_window:\n"
-"        movq    56(%%rsp), %%rsi\n"     /* rsi = window */
-"        addq    %%rax, %%rsi\n"
-"        subq    %%rcx, %%rsi\n"         /* from += write - nbytes */
-
-"        movl    %%r14d, %%eax\n"        /* eax = len */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movq    %%rdi, %%rsi\n"
-"        subq    %%r15, %%rsi\n"         /* from = out - dist */
-"        jmp     .L_do_copy\n"           /* if (nbytes >= len) */
-
-".align 32,0x90\n"
-".L_do_copy:\n"
-"        movl    %%eax, %%ecx\n"         /* ecx = len */
-"        rep     movsb\n"
-
-"        movq    %%r8, %%rsi\n"          /* move in back to %esi, toss from */
-"        jmp     .L_while_test\n"
-
-".L_test_for_end_of_block:\n"
-"        testb   $32, %%al\n"
-"        jz      .L_invalid_literal_length_code\n"
-"        movl    $1, 116(%%rsp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_invalid_literal_length_code:\n"
-"        movl    $2, 116(%%rsp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_invalid_distance_code:\n"
-"        movl    $3, 116(%%rsp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_invalid_distance_too_far:\n"
-"        movl    $4, 116(%%rsp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_break_loop:\n"
-"        movl    $0, 116(%%rsp)\n"
-
-".L_break_loop_with_status:\n"
-/* put in, out, bits, and hold back into ar and pop esp */
-"        movq    %%rsi, 16(%%rsp)\n"     /* in */
-"        movq    %%rdi, 32(%%rsp)\n"     /* out */
-"        movl    %%ebx, 88(%%rsp)\n"     /* bits */
-"        movq    %%rdx, 80(%%rsp)\n"     /* hold */
-"        movq    (%%rsp), %%rax\n"       /* restore rbp and rsp */
-"        movq    8(%%rsp), %%rbp\n"
-"        movq    %%rax, %%rsp\n"
-          :
-          : "m" (ar)
-          : "memory", "%rax", "%rbx", "%rcx", "%rdx", "%rsi", "%rdi",
-            "%r8", "%r9", "%r10", "%r11", "%r12", "%r13", "%r14", "%r15"
-    );
-#elif ( defined( __GNUC__ ) || defined( __ICC ) ) && defined( __i386 )
-    __asm__ __volatile__ (
-"        leal    %0, %%eax\n"
-"        movl    %%esp, (%%eax)\n"        /* save esp, ebp */
-"        movl    %%ebp, 4(%%eax)\n"
-"        movl    %%eax, %%esp\n"
-"        movl    8(%%esp), %%esi\n"       /* esi = in */
-"        movl    16(%%esp), %%edi\n"      /* edi = out */
-"        movl    40(%%esp), %%edx\n"      /* edx = hold */
-"        movl    44(%%esp), %%ebx\n"      /* ebx = bits */
-"        movl    32(%%esp), %%ebp\n"      /* ebp = lcode */
-
-"        cld\n"
-"        jmp     .L_do_loop\n"
-
-".align 32,0x90\n"
-".L_while_test:\n"
-"        cmpl    %%edi, 24(%%esp)\n"      /* out < end */
-"        jbe     .L_break_loop\n"
-"        cmpl    %%esi, 12(%%esp)\n"      /* in < last */
-"        jbe     .L_break_loop\n"
-
-".L_do_loop:\n"
-"        cmpb    $15, %%bl\n"
-"        ja      .L_get_length_code\n"    /* if (15 < bits) */
-
-"        xorl    %%eax, %%eax\n"
-"        lodsw\n"                         /* al = *(ushort *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $16, %%bl\n"             /* bits += 16 */
-"        shll    %%cl, %%eax\n"
-"        orl     %%eax, %%edx\n"        /* hold |= *((ushort *)in)++ << bits */
-
-".L_get_length_code:\n"
-"        movl    56(%%esp), %%eax\n"      /* eax = lmask */
-"        andl    %%edx, %%eax\n"          /* eax &= hold */
-"        movl    (%%ebp,%%eax,4), %%eax\n" /* eax = lcode[hold & lmask] */
-
-".L_dolen:\n"
-"        movb    %%ah, %%cl\n"            /* cl = this.bits */
-"        subb    %%ah, %%bl\n"            /* bits -= this.bits */
-"        shrl    %%cl, %%edx\n"           /* hold >>= this.bits */
-
-"        testb   %%al, %%al\n"
-"        jnz     .L_test_for_length_base\n" /* if (op != 0) 45.7% */
-
-"        shrl    $16, %%eax\n"            /* output this.val char */
-"        stosb\n"
-"        jmp     .L_while_test\n"
-
-".align 32,0x90\n"
-".L_test_for_length_base:\n"
-"        movl    %%eax, %%ecx\n"          /* len = this */
-"        shrl    $16, %%ecx\n"            /* len = this.val */
-"        movl    %%ecx, 64(%%esp)\n"      /* save len */
-"        movb    %%al, %%cl\n"
-
-"        testb   $16, %%al\n"
-"        jz      .L_test_for_second_level_length\n" /* if ((op & 16) == 0) 8% */
-"        andb    $15, %%cl\n"             /* op &= 15 */
-"        jz      .L_decode_distance\n"    /* if (!op) */
-"        cmpb    %%cl, %%bl\n"
-"        jae     .L_add_bits_to_len\n"    /* if (op <= bits) */
-
-"        movb    %%cl, %%ch\n"            /* stash op in ch, freeing cl */
-"        xorl    %%eax, %%eax\n"
-"        lodsw\n"                         /* al = *(ushort *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $16, %%bl\n"             /* bits += 16 */
-"        shll    %%cl, %%eax\n"
-"        orl     %%eax, %%edx\n"         /* hold |= *((ushort *)in)++ << bits */
-"        movb    %%ch, %%cl\n"            /* move op back to ecx */
-
-".L_add_bits_to_len:\n"
-"        subb    %%cl, %%bl\n"
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"
-"        andl    %%edx, %%eax\n"          /* eax &= hold */
-"        shrl    %%cl, %%edx\n"
-"        addl    %%eax, 64(%%esp)\n"      /* len += hold & mask[op] */
-
-".L_decode_distance:\n"
-"        cmpb    $15, %%bl\n"
-"        ja      .L_get_distance_code\n"  /* if (15 < bits) */
-
-"        xorl    %%eax, %%eax\n"
-"        lodsw\n"                         /* al = *(ushort *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $16, %%bl\n"             /* bits += 16 */
-"        shll    %%cl, %%eax\n"
-"        orl     %%eax, %%edx\n"         /* hold |= *((ushort *)in)++ << bits */
-
-".L_get_distance_code:\n"
-"        movl    60(%%esp), %%eax\n"      /* eax = dmask */
-"        movl    36(%%esp), %%ecx\n"      /* ecx = dcode */
-"        andl    %%edx, %%eax\n"          /* eax &= hold */
-"        movl    (%%ecx,%%eax,4), %%eax\n"/* eax = dcode[hold & dmask] */
-
-".L_dodist:\n"
-"        movl    %%eax, %%ebp\n"          /* dist = this */
-"        shrl    $16, %%ebp\n"            /* dist = this.val */
-"        movb    %%ah, %%cl\n"
-"        subb    %%ah, %%bl\n"            /* bits -= this.bits */
-"        shrl    %%cl, %%edx\n"           /* hold >>= this.bits */
-"        movb    %%al, %%cl\n"            /* cl = this.op */
-
-"        testb   $16, %%al\n"             /* if ((op & 16) == 0) */
-"        jz      .L_test_for_second_level_dist\n"
-"        andb    $15, %%cl\n"             /* op &= 15 */
-"        jz      .L_check_dist_one\n"
-"        cmpb    %%cl, %%bl\n"
-"        jae     .L_add_bits_to_dist\n"   /* if (op <= bits) 97.6% */
-
-"        movb    %%cl, %%ch\n"            /* stash op in ch, freeing cl */
-"        xorl    %%eax, %%eax\n"
-"        lodsw\n"                         /* al = *(ushort *)in++ */
-"        movb    %%bl, %%cl\n"            /* cl = bits, needs it for shifting */
-"        addb    $16, %%bl\n"             /* bits += 16 */
-"        shll    %%cl, %%eax\n"
-"        orl     %%eax, %%edx\n"        /* hold |= *((ushort *)in)++ << bits */
-"        movb    %%ch, %%cl\n"            /* move op back to ecx */
-
-".L_add_bits_to_dist:\n"
-"        subb    %%cl, %%bl\n"
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"                 /* (1 << op) - 1 */
-"        andl    %%edx, %%eax\n"          /* eax &= hold */
-"        shrl    %%cl, %%edx\n"
-"        addl    %%eax, %%ebp\n"          /* dist += hold & ((1 << op) - 1) */
-
-".L_check_window:\n"
-"        movl    %%esi, 8(%%esp)\n"       /* save in so from can use it's reg */
-"        movl    %%edi, %%eax\n"
-"        subl    20(%%esp), %%eax\n"      /* nbytes = out - beg */
-
-"        cmpl    %%ebp, %%eax\n"
-"        jb      .L_clip_window\n"        /* if (dist > nbytes) 4.2% */
-
-"        movl    64(%%esp), %%ecx\n"      /* ecx = len */
-"        movl    %%edi, %%esi\n"
-"        subl    %%ebp, %%esi\n"          /* from = out - dist */
-
-"        sarl    %%ecx\n"
-"        jnc     .L_copy_two\n"           /* if len % 2 == 0 */
-
-"        rep     movsw\n"
-"        movb    (%%esi), %%al\n"
-"        movb    %%al, (%%edi)\n"
-"        incl    %%edi\n"
-
-"        movl    8(%%esp), %%esi\n"       /* move in back to %esi, toss from */
-"        movl    32(%%esp), %%ebp\n"      /* ebp = lcode */
-"        jmp     .L_while_test\n"
-
-".L_copy_two:\n"
-"        rep     movsw\n"
-"        movl    8(%%esp), %%esi\n"       /* move in back to %esi, toss from */
-"        movl    32(%%esp), %%ebp\n"      /* ebp = lcode */
-"        jmp     .L_while_test\n"
-
-".align 32,0x90\n"
-".L_check_dist_one:\n"
-"        cmpl    $1, %%ebp\n"            /* if dist 1, is a memset */
-"        jne     .L_check_window\n"
-"        cmpl    %%edi, 20(%%esp)\n"
-"        je      .L_check_window\n"      /* out == beg, if outside window */
-
-"        movl    64(%%esp), %%ecx\n"      /* ecx = len */
-"        movb    -1(%%edi), %%al\n"
-"        movb    %%al, %%ah\n"
-
-"        sarl    %%ecx\n"
-"        jnc     .L_set_two\n"
-"        movb    %%al, (%%edi)\n"
-"        incl    %%edi\n"
-
-".L_set_two:\n"
-"        rep     stosw\n"
-"        movl    32(%%esp), %%ebp\n"      /* ebp = lcode */
-"        jmp     .L_while_test\n"
-
-".align 32,0x90\n"
-".L_test_for_second_level_length:\n"
-"        testb   $64, %%al\n"
-"        jnz     .L_test_for_end_of_block\n" /* if ((op & 64) != 0) */
-
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"
-"        andl    %%edx, %%eax\n"         /* eax &= hold */
-"        addl    64(%%esp), %%eax\n"     /* eax += len */
-"        movl    (%%ebp,%%eax,4), %%eax\n" /* eax = lcode[val+(hold&mask[op])]*/
-"        jmp     .L_dolen\n"
-
-".align 32,0x90\n"
-".L_test_for_second_level_dist:\n"
-"        testb   $64, %%al\n"
-"        jnz     .L_invalid_distance_code\n" /* if ((op & 64) != 0) */
-
-"        xorl    %%eax, %%eax\n"
-"        incl    %%eax\n"
-"        shll    %%cl, %%eax\n"
-"        decl    %%eax\n"
-"        andl    %%edx, %%eax\n"         /* eax &= hold */
-"        addl    %%ebp, %%eax\n"         /* eax += dist */
-"        movl    36(%%esp), %%ecx\n"     /* ecx = dcode */
-"        movl    (%%ecx,%%eax,4), %%eax\n" /* eax = dcode[val+(hold&mask[op])]*/
-"        jmp     .L_dodist\n"
-
-".align 32,0x90\n"
-".L_clip_window:\n"
-"        movl    %%eax, %%ecx\n"
-"        movl    48(%%esp), %%eax\n"     /* eax = wsize */
-"        negl    %%ecx\n"                /* nbytes = -nbytes */
-"        movl    28(%%esp), %%esi\n"     /* from = window */
-
-"        cmpl    %%ebp, %%eax\n"
-"        jb      .L_invalid_distance_too_far\n" /* if (dist > wsize) */
-
-"        addl    %%ebp, %%ecx\n"         /* nbytes = dist - nbytes */
-"        cmpl    $0, 52(%%esp)\n"
-"        jne     .L_wrap_around_window\n" /* if (write != 0) */
-
-"        subl    %%ecx, %%eax\n"
-"        addl    %%eax, %%esi\n"         /* from += wsize - nbytes */
-
-"        movl    64(%%esp), %%eax\n"     /* eax = len */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movl    %%edi, %%esi\n"
-"        subl    %%ebp, %%esi\n"         /* from = out - dist */
-"        jmp     .L_do_copy\n"
-
-".align 32,0x90\n"
-".L_wrap_around_window:\n"
-"        movl    52(%%esp), %%eax\n"     /* eax = write */
-"        cmpl    %%eax, %%ecx\n"
-"        jbe     .L_contiguous_in_window\n" /* if (write >= nbytes) */
-
-"        addl    48(%%esp), %%esi\n"     /* from += wsize */
-"        addl    %%eax, %%esi\n"         /* from += write */
-"        subl    %%ecx, %%esi\n"         /* from -= nbytes */
-"        subl    %%eax, %%ecx\n"         /* nbytes -= write */
-
-"        movl    64(%%esp), %%eax\n"     /* eax = len */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movl    28(%%esp), %%esi\n"     /* from = window */
-"        movl    52(%%esp), %%ecx\n"     /* nbytes = write */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movl    %%edi, %%esi\n"
-"        subl    %%ebp, %%esi\n"         /* from = out - dist */
-"        jmp     .L_do_copy\n"
-
-".align 32,0x90\n"
-".L_contiguous_in_window:\n"
-"        addl    %%eax, %%esi\n"
-"        subl    %%ecx, %%esi\n"         /* from += write - nbytes */
-
-"        movl    64(%%esp), %%eax\n"     /* eax = len */
-"        cmpl    %%ecx, %%eax\n"
-"        jbe     .L_do_copy\n"           /* if (nbytes >= len) */
-
-"        subl    %%ecx, %%eax\n"         /* len -= nbytes */
-"        rep     movsb\n"
-"        movl    %%edi, %%esi\n"
-"        subl    %%ebp, %%esi\n"         /* from = out - dist */
-"        jmp     .L_do_copy\n"           /* if (nbytes >= len) */
-
-".align 32,0x90\n"
-".L_do_copy:\n"
-"        movl    %%eax, %%ecx\n"
-"        rep     movsb\n"
-
-"        movl    8(%%esp), %%esi\n"      /* move in back to %esi, toss from */
-"        movl    32(%%esp), %%ebp\n"     /* ebp = lcode */
-"        jmp     .L_while_test\n"
-
-".L_test_for_end_of_block:\n"
-"        testb   $32, %%al\n"
-"        jz      .L_invalid_literal_length_code\n"
-"        movl    $1, 72(%%esp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_invalid_literal_length_code:\n"
-"        movl    $2, 72(%%esp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_invalid_distance_code:\n"
-"        movl    $3, 72(%%esp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_invalid_distance_too_far:\n"
-"        movl    8(%%esp), %%esi\n"
-"        movl    $4, 72(%%esp)\n"
-"        jmp     .L_break_loop_with_status\n"
-
-".L_break_loop:\n"
-"        movl    $0, 72(%%esp)\n"
-
-".L_break_loop_with_status:\n"
-/* put in, out, bits, and hold back into ar and pop esp */
-"        movl    %%esi, 8(%%esp)\n"      /* save in */
-"        movl    %%edi, 16(%%esp)\n"     /* save out */
-"        movl    %%ebx, 44(%%esp)\n"     /* save bits */
-"        movl    %%edx, 40(%%esp)\n"     /* save hold */
-"        movl    4(%%esp), %%ebp\n"      /* restore esp, ebp */
-"        movl    (%%esp), %%esp\n"
-          :
-          : "m" (ar)
-          : "memory", "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi"
-    );
-#elif defined( _MSC_VER ) && ! defined( _M_AMD64 )
-    __asm {
-	lea	eax, ar
-	mov	[eax], esp         /* save esp, ebp */
-	mov	[eax+4], ebp
-	mov	esp, eax
-	mov	esi, [esp+8]       /* esi = in */
-	mov	edi, [esp+16]      /* edi = out */
-	mov	edx, [esp+40]      /* edx = hold */
-	mov	ebx, [esp+44]      /* ebx = bits */
-	mov	ebp, [esp+32]      /* ebp = lcode */
-
-	cld
-	jmp	L_do_loop
-
-ALIGN 4
-L_while_test:
-	cmp	[esp+24], edi
-	jbe	L_break_loop
-	cmp	[esp+12], esi
-	jbe	L_break_loop
-
-L_do_loop:
-	cmp	bl, 15
-	ja	L_get_length_code    /* if (15 < bits) */
-
-	xor	eax, eax
-	lodsw                         /* al = *(ushort *)in++ */
-	mov	cl, bl            /* cl = bits, needs it for shifting */
-	add	bl, 16             /* bits += 16 */
-	shl	eax, cl
-	or	edx, eax        /* hold |= *((ushort *)in)++ << bits */
-
-L_get_length_code:
-	mov	eax, [esp+56]      /* eax = lmask */
-	and	eax, edx          /* eax &= hold */
-	mov	eax, [ebp+eax*4] /* eax = lcode[hold & lmask] */
-
-L_dolen:
-	mov	cl, ah            /* cl = this.bits */
-	sub	bl, ah            /* bits -= this.bits */
-	shr	edx, cl           /* hold >>= this.bits */
-
-	test	al, al
-	jnz	L_test_for_length_base /* if (op != 0) 45.7% */
-
-	shr	eax, 16            /* output this.val char */
-	stosb
-	jmp	L_while_test
-
-ALIGN 4
-L_test_for_length_base:
-	mov	ecx, eax          /* len = this */
-	shr	ecx, 16            /* len = this.val */
-	mov	[esp+64], ecx      /* save len */
-	mov	cl, al
-
-	test	al, 16
-	jz	L_test_for_second_level_length /* if ((op & 16) == 0) 8% */
-	and	cl, 15             /* op &= 15 */
-	jz	L_decode_distance    /* if (!op) */
-	cmp	bl, cl
-	jae	L_add_bits_to_len    /* if (op <= bits) */
-
-	mov	ch, cl            /* stash op in ch, freeing cl */
-	xor	eax, eax
-	lodsw                         /* al = *(ushort *)in++ */
-	mov	cl, bl            /* cl = bits, needs it for shifting */
-	add	bl, 16             /* bits += 16 */
-	shl	eax, cl
-	or	edx, eax         /* hold |= *((ushort *)in)++ << bits */
-	mov	cl, ch            /* move op back to ecx */
-
-L_add_bits_to_len:
-	sub	bl, cl
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax
-	and	eax, edx          /* eax &= hold */
-	shr	edx, cl
-	add	[esp+64], eax      /* len += hold & mask[op] */
-
-L_decode_distance:
-	cmp	bl, 15
-	ja	L_get_distance_code  /* if (15 < bits) */
-
-	xor	eax, eax
-	lodsw                         /* al = *(ushort *)in++ */
-	mov	cl, bl            /* cl = bits, needs it for shifting */
-	add	bl, 16             /* bits += 16 */
-	shl	eax, cl
-	or	edx, eax         /* hold |= *((ushort *)in)++ << bits */
-
-L_get_distance_code:
-	mov	eax, [esp+60]      /* eax = dmask */
-	mov	ecx, [esp+36]      /* ecx = dcode */
-	and	eax, edx          /* eax &= hold */
-	mov	eax, [ecx+eax*4]/* eax = dcode[hold & dmask] */
-
-L_dodist:
-	mov	ebp, eax          /* dist = this */
-	shr	ebp, 16            /* dist = this.val */
-	mov	cl, ah
-	sub	bl, ah            /* bits -= this.bits */
-	shr	edx, cl           /* hold >>= this.bits */
-	mov	cl, al            /* cl = this.op */
-
-	test	al, 16             /* if ((op & 16) == 0) */
-	jz	L_test_for_second_level_dist
-	and	cl, 15             /* op &= 15 */
-	jz	L_check_dist_one
-	cmp	bl, cl
-	jae	L_add_bits_to_dist   /* if (op <= bits) 97.6% */
-
-	mov	ch, cl            /* stash op in ch, freeing cl */
-	xor	eax, eax
-	lodsw                         /* al = *(ushort *)in++ */
-	mov	cl, bl            /* cl = bits, needs it for shifting */
-	add	bl, 16             /* bits += 16 */
-	shl	eax, cl
-	or	edx, eax        /* hold |= *((ushort *)in)++ << bits */
-	mov	cl, ch            /* move op back to ecx */
-
-L_add_bits_to_dist:
-	sub	bl, cl
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax                 /* (1 << op) - 1 */
-	and	eax, edx          /* eax &= hold */
-	shr	edx, cl
-	add	ebp, eax          /* dist += hold & ((1 << op) - 1) */
-
-L_check_window:
-	mov	[esp+8], esi       /* save in so from can use it's reg */
-	mov	eax, edi
-	sub	eax, [esp+20]      /* nbytes = out - beg */
-
-	cmp	eax, ebp
-	jb	L_clip_window        /* if (dist > nbytes) 4.2% */
-
-	mov	ecx, [esp+64]      /* ecx = len */
-	mov	esi, edi
-	sub	esi, ebp          /* from = out - dist */
-
-	sar	ecx, 1
-	jnc	L_copy_two
-
-	rep     movsw
-	mov	al, [esi]
-	mov	[edi], al
-	inc	edi
-
-	mov	esi, [esp+8]      /* move in back to %esi, toss from */
-	mov	ebp, [esp+32]     /* ebp = lcode */
-	jmp	L_while_test
-
-L_copy_two:
-	rep     movsw
-	mov	esi, [esp+8]      /* move in back to %esi, toss from */
-	mov	ebp, [esp+32]     /* ebp = lcode */
-	jmp	L_while_test
-
-ALIGN 4
-L_check_dist_one:
-	cmp	ebp, 1            /* if dist 1, is a memset */
-	jne	L_check_window
-	cmp	[esp+20], edi
-	je	L_check_window    /* out == beg, if outside window */
-
-	mov	ecx, [esp+64]     /* ecx = len */
-	mov	al, [edi-1]
-	mov	ah, al
-
-	sar	ecx, 1
-	jnc	L_set_two
-	mov	[edi], al         /* memset out with from[-1] */
-	inc	edi
-
-L_set_two:
-	rep     stosw
-	mov	ebp, [esp+32]     /* ebp = lcode */
-	jmp	L_while_test
-
-ALIGN 4
-L_test_for_second_level_length:
-	test	al, 64
-	jnz	L_test_for_end_of_block /* if ((op & 64) != 0) */
-
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax
-	and	eax, edx         /* eax &= hold */
-	add	eax, [esp+64]     /* eax += len */
-	mov	eax, [ebp+eax*4] /* eax = lcode[val+(hold&mask[op])]*/
-	jmp	L_dolen
-
-ALIGN 4
-L_test_for_second_level_dist:
-	test	al, 64
-	jnz	L_invalid_distance_code /* if ((op & 64) != 0) */
-
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax
-	and	eax, edx         /* eax &= hold */
-	add	eax, ebp         /* eax += dist */
-	mov	ecx, [esp+36]     /* ecx = dcode */
-	mov	eax, [ecx+eax*4] /* eax = dcode[val+(hold&mask[op])]*/
-	jmp	L_dodist
-
-ALIGN 4
-L_clip_window:
-	mov	ecx, eax
-	mov	eax, [esp+48]     /* eax = wsize */
-	neg	ecx                /* nbytes = -nbytes */
-	mov	esi, [esp+28]     /* from = window */
-
-	cmp	eax, ebp
-	jb	L_invalid_distance_too_far /* if (dist > wsize) */
-
-	add	ecx, ebp         /* nbytes = dist - nbytes */
-	cmp	dword ptr [esp+52], 0
-	jne	L_wrap_around_window /* if (write != 0) */
-
-	sub	eax, ecx
-	add	esi, eax         /* from += wsize - nbytes */
-
-	mov	eax, [esp+64]    /* eax = len */
-	cmp	eax, ecx
-	jbe	L_do_copy          /* if (nbytes >= len) */
-
-	sub	eax, ecx         /* len -= nbytes */
-	rep     movsb
-	mov	esi, edi
-	sub	esi, ebp         /* from = out - dist */
-	jmp	L_do_copy
-
-ALIGN 4
-L_wrap_around_window:
-	mov	eax, [esp+52]    /* eax = write */
-	cmp	ecx, eax
-	jbe	L_contiguous_in_window /* if (write >= nbytes) */
-
-	add	esi, [esp+48]    /* from += wsize */
-	add	esi, eax         /* from += write */
-	sub	esi, ecx         /* from -= nbytes */
-	sub	ecx, eax         /* nbytes -= write */
-
-	mov	eax, [esp+64]    /* eax = len */
-	cmp	eax, ecx
-	jbe	L_do_copy          /* if (nbytes >= len) */
-
-	sub	eax, ecx         /* len -= nbytes */
-	rep     movsb
-	mov	esi, [esp+28]     /* from = window */
-	mov	ecx, [esp+52]     /* nbytes = write */
-	cmp	eax, ecx
-	jbe	L_do_copy          /* if (nbytes >= len) */
-
-	sub	eax, ecx         /* len -= nbytes */
-	rep     movsb
-	mov	esi, edi
-	sub	esi, ebp         /* from = out - dist */
-	jmp	L_do_copy
-
-ALIGN 4
-L_contiguous_in_window:
-	add	esi, eax
-	sub	esi, ecx         /* from += write - nbytes */
-
-	mov	eax, [esp+64]    /* eax = len */
-	cmp	eax, ecx
-	jbe	L_do_copy          /* if (nbytes >= len) */
-
-	sub	eax, ecx         /* len -= nbytes */
-	rep     movsb
-	mov	esi, edi
-	sub	esi, ebp         /* from = out - dist */
-	jmp	L_do_copy
-
-ALIGN 4
-L_do_copy:
-	mov	ecx, eax
-	rep     movsb
-
-	mov	esi, [esp+8]      /* move in back to %esi, toss from */
-	mov	ebp, [esp+32]     /* ebp = lcode */
-	jmp	L_while_test
-
-L_test_for_end_of_block:
-	test	al, 32
-	jz	L_invalid_literal_length_code
-	mov	dword ptr [esp+72], 1
-	jmp	L_break_loop_with_status
-
-L_invalid_literal_length_code:
-	mov	dword ptr [esp+72], 2
-	jmp	L_break_loop_with_status
-
-L_invalid_distance_code:
-	mov	dword ptr [esp+72], 3
-	jmp	L_break_loop_with_status
-
-L_invalid_distance_too_far:
-	mov	esi, [esp+4]
-	mov	dword ptr [esp+72], 4
-	jmp	L_break_loop_with_status
-
-L_break_loop:
-	mov	dword ptr [esp+72], 0
-
-L_break_loop_with_status:
-/* put in, out, bits, and hold back into ar and pop esp */
-	mov	[esp+8], esi     /* save in */
-	mov	[esp+16], edi    /* save out */
-	mov	[esp+44], ebx    /* save bits */
-	mov	[esp+40], edx    /* save hold */
-	mov	ebp, [esp+4]     /* restore esp, ebp */
-	mov	esp, [esp]
-    }
-#else
-#error "x86 architecture not defined"
-#endif
-
-    if (ar.status > 1) {
-        if (ar.status == 2)
-            strm->msg = "invalid literal/length code";
-        else if (ar.status == 3)
-            strm->msg = "invalid distance code";
-        else
-            strm->msg = "invalid distance too far back";
-        state->mode = BAD;
-    }
-    else if ( ar.status == 1 ) {
-        state->mode = TYPE;
-    }
-
-    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
-    ar.len = ar.bits >> 3;
-    ar.in -= ar.len;
-    ar.bits -= ar.len << 3;
-    ar.hold &= (1U << ar.bits) - 1;
-
-    /* update state and return */
-    strm->next_in = ar.in;
-    strm->next_out = ar.out;
-    strm->avail_in = (unsigned)(ar.in < ar.last ?
-                                PAD_AVAIL_IN + (ar.last - ar.in) :
-                                PAD_AVAIL_IN - (ar.in - ar.last));
-    strm->avail_out = (unsigned)(ar.out < ar.end ?
-                                 PAD_AVAIL_OUT + (ar.end - ar.out) :
-                                 PAD_AVAIL_OUT - (ar.out - ar.end));
-    state->hold = ar.hold;
-    state->bits = ar.bits;
-    return;
-}
-
diff -Nbaur gcc-4.6.3/zlib/contrib/inflate86/inffast.S gcc-4.6.3-psp/zlib/contrib/inflate86/inffast.S
--- gcc-4.6.3/zlib/contrib/inflate86/inffast.S	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/inflate86/inffast.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,1368 +0,0 @@
-/*
- * inffast.S is a hand tuned assembler version of:
- *
- * inffast.c -- fast decoding
- * Copyright (C) 1995-2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * Copyright (C) 2003 Chris Anderson <christop@charm.net>
- * Please use the copyright conditions above.
- *
- * This version (Jan-23-2003) of inflate_fast was coded and tested under
- * GNU/Linux on a pentium 3, using the gcc-3.2 compiler distribution.  On that
- * machine, I found that gzip style archives decompressed about 20% faster than
- * the gcc-3.2 -O3 -fomit-frame-pointer compiled version.  Your results will
- * depend on how large of a buffer is used for z_stream.next_in & next_out
- * (8K-32K worked best for my 256K cpu cache) and how much overhead there is in
- * stream processing I/O and crc32/addler32.  In my case, this routine used
- * 70% of the cpu time and crc32 used 20%.
- *
- * I am confident that this version will work in the general case, but I have
- * not tested a wide variety of datasets or a wide variety of platforms.
- *
- * Jan-24-2003 -- Added -DUSE_MMX define for slightly faster inflating.
- * It should be a runtime flag instead of compile time flag...
- *
- * Jan-26-2003 -- Added runtime check for MMX support with cpuid instruction.
- * With -DUSE_MMX, only MMX code is compiled.  With -DNO_MMX, only non-MMX code
- * is compiled.  Without either option, runtime detection is enabled.  Runtime
- * detection should work on all modern cpus and the recomended algorithm (flip
- * ID bit on eflags and then use the cpuid instruction) is used in many
- * multimedia applications.  Tested under win2k with gcc-2.95 and gas-2.12
- * distributed with cygwin3.  Compiling with gcc-2.95 -c inffast.S -o
- * inffast.obj generates a COFF object which can then be linked with MSVC++
- * compiled code.  Tested under FreeBSD 4.7 with gcc-2.95.
- *
- * Jan-28-2003 -- Tested Athlon XP... MMX mode is slower than no MMX (and
- * slower than compiler generated code).  Adjusted cpuid check to use the MMX
- * code only for Pentiums < P4 until I have more data on the P4.  Speed
- * improvment is only about 15% on the Athlon when compared with code generated
- * with MSVC++.  Not sure yet, but I think the P4 will also be slower using the
- * MMX mode because many of it's x86 ALU instructions execute in .5 cycles and
- * have less latency than MMX ops.  Added code to buffer the last 11 bytes of
- * the input stream since the MMX code grabs bits in chunks of 32, which
- * differs from the inffast.c algorithm.  I don't think there would have been
- * read overruns where a page boundary was crossed (a segfault), but there
- * could have been overruns when next_in ends on unaligned memory (unintialized
- * memory read).
- *
- * Mar-13-2003 -- P4 MMX is slightly slower than P4 NO_MMX.  I created a C
- * version of the non-MMX code so that it doesn't depend on zstrm and zstate
- * structure offsets which are hard coded in this file.  This was last tested
- * with zlib-1.2.0 which is currently in beta testing, newer versions of this
- * and inffas86.c can be found at http://www.eetbeetee.com/zlib/ and
- * http://www.charm.net/~christop/zlib/
- */
-
-
-/*
- * if you have underscore linking problems (_inflate_fast undefined), try
- * using -DGAS_COFF
- */
-#if ! defined( GAS_COFF ) && ! defined( GAS_ELF )
-
-#if defined( WIN32 ) || defined( __CYGWIN__ )
-#define GAS_COFF /* windows object format */
-#else
-#define GAS_ELF
-#endif
-
-#endif /* ! GAS_COFF && ! GAS_ELF */
-
-
-#if defined( GAS_COFF )
-
-/* coff externals have underscores */
-#define inflate_fast _inflate_fast
-#define inflate_fast_use_mmx _inflate_fast_use_mmx
-
-#endif /* GAS_COFF */
-
-
-.file "inffast.S"
-
-.globl inflate_fast
-
-.text
-.align 4,0
-.L_invalid_literal_length_code_msg:
-.string "invalid literal/length code"
-
-.align 4,0
-.L_invalid_distance_code_msg:
-.string "invalid distance code"
-
-.align 4,0
-.L_invalid_distance_too_far_msg:
-.string "invalid distance too far back"
-
-#if ! defined( NO_MMX )
-.align 4,0
-.L_mask: /* mask[N] = ( 1 << N ) - 1 */
-.long 0
-.long 1
-.long 3
-.long 7
-.long 15
-.long 31
-.long 63
-.long 127
-.long 255
-.long 511
-.long 1023
-.long 2047
-.long 4095
-.long 8191
-.long 16383
-.long 32767
-.long 65535
-.long 131071
-.long 262143
-.long 524287
-.long 1048575
-.long 2097151
-.long 4194303
-.long 8388607
-.long 16777215
-.long 33554431
-.long 67108863
-.long 134217727
-.long 268435455
-.long 536870911
-.long 1073741823
-.long 2147483647
-.long 4294967295
-#endif /* NO_MMX */
-
-.text
-
-/*
- * struct z_stream offsets, in zlib.h
- */
-#define next_in_strm   0   /* strm->next_in */
-#define avail_in_strm  4   /* strm->avail_in */
-#define next_out_strm  12  /* strm->next_out */
-#define avail_out_strm 16  /* strm->avail_out */
-#define msg_strm       24  /* strm->msg */
-#define state_strm     28  /* strm->state */
-
-/*
- * struct inflate_state offsets, in inflate.h
- */
-#define mode_state     0   /* state->mode */
-#define wsize_state    32  /* state->wsize */
-#define write_state    40  /* state->write */
-#define window_state   44  /* state->window */
-#define hold_state     48  /* state->hold */
-#define bits_state     52  /* state->bits */
-#define lencode_state  68  /* state->lencode */
-#define distcode_state 72  /* state->distcode */
-#define lenbits_state  76  /* state->lenbits */
-#define distbits_state 80  /* state->distbits */
-
-/*
- * inflate_fast's activation record
- */
-#define local_var_size 64 /* how much local space for vars */
-#define strm_sp        88 /* first arg: z_stream * (local_var_size + 24) */
-#define start_sp       92 /* second arg: unsigned int (local_var_size + 28) */
-
-/*
- * offsets for local vars on stack
- */
-#define out            60  /* unsigned char* */
-#define window         56  /* unsigned char* */
-#define wsize          52  /* unsigned int */
-#define write          48  /* unsigned int */
-#define in             44  /* unsigned char* */
-#define beg            40  /* unsigned char* */
-#define buf            28  /* char[ 12 ] */
-#define len            24  /* unsigned int */
-#define last           20  /* unsigned char* */
-#define end            16  /* unsigned char* */
-#define dcode          12  /* code* */
-#define lcode           8  /* code* */
-#define dmask           4  /* unsigned int */
-#define lmask           0  /* unsigned int */
-
-/*
- * typedef enum inflate_mode consts, in inflate.h
- */
-#define INFLATE_MODE_TYPE 11  /* state->mode flags enum-ed in inflate.h */
-#define INFLATE_MODE_BAD  26
-
-
-#if ! defined( USE_MMX ) && ! defined( NO_MMX )
-
-#define RUN_TIME_MMX
-
-#define CHECK_MMX    1
-#define DO_USE_MMX   2
-#define DONT_USE_MMX 3
-
-.globl inflate_fast_use_mmx
-
-.data
-
-.align 4,0
-inflate_fast_use_mmx: /* integer flag for run time control 1=check,2=mmx,3=no */
-.long CHECK_MMX
-
-#if defined( GAS_ELF )
-/* elf info */
-.type   inflate_fast_use_mmx,@object
-.size   inflate_fast_use_mmx,4
-#endif
-
-#endif /* RUN_TIME_MMX */
-
-#if defined( GAS_COFF )
-/* coff info: scl 2 = extern, type 32 = function */
-.def inflate_fast; .scl 2; .type 32; .endef
-#endif
-
-.text
-
-.align 32,0x90
-inflate_fast:
-        pushl   %edi
-        pushl   %esi
-        pushl   %ebp
-        pushl   %ebx
-        pushf   /* save eflags (strm_sp, state_sp assumes this is 32 bits) */
-        subl    $local_var_size, %esp
-        cld
-
-#define strm_r  %esi
-#define state_r %edi
-
-        movl    strm_sp(%esp), strm_r
-        movl    state_strm(strm_r), state_r
-
-        /* in = strm->next_in;
-         * out = strm->next_out;
-         * last = in + strm->avail_in - 11;
-         * beg = out - (start - strm->avail_out);
-         * end = out + (strm->avail_out - 257);
-         */
-        movl    avail_in_strm(strm_r), %edx
-        movl    next_in_strm(strm_r), %eax
-
-        addl    %eax, %edx      /* avail_in += next_in */
-        subl    $11, %edx       /* avail_in -= 11 */
-
-        movl    %eax, in(%esp)
-        movl    %edx, last(%esp)
-
-        movl    start_sp(%esp), %ebp
-        movl    avail_out_strm(strm_r), %ecx
-        movl    next_out_strm(strm_r), %ebx
-
-        subl    %ecx, %ebp      /* start -= avail_out */
-        negl    %ebp            /* start = -start */
-        addl    %ebx, %ebp      /* start += next_out */
-
-        subl    $257, %ecx      /* avail_out -= 257 */
-        addl    %ebx, %ecx      /* avail_out += out */
-
-        movl    %ebx, out(%esp)
-        movl    %ebp, beg(%esp)
-        movl    %ecx, end(%esp)
-
-        /* wsize = state->wsize;
-         * write = state->write;
-         * window = state->window;
-         * hold = state->hold;
-         * bits = state->bits;
-         * lcode = state->lencode;
-         * dcode = state->distcode;
-         * lmask = ( 1 << state->lenbits ) - 1;
-         * dmask = ( 1 << state->distbits ) - 1;
-         */
-
-        movl    lencode_state(state_r), %eax
-        movl    distcode_state(state_r), %ecx
-
-        movl    %eax, lcode(%esp)
-        movl    %ecx, dcode(%esp)
-
-        movl    $1, %eax
-        movl    lenbits_state(state_r), %ecx
-        shll    %cl, %eax
-        decl    %eax
-        movl    %eax, lmask(%esp)
-
-        movl    $1, %eax
-        movl    distbits_state(state_r), %ecx
-        shll    %cl, %eax
-        decl    %eax
-        movl    %eax, dmask(%esp)
-
-        movl    wsize_state(state_r), %eax
-        movl    write_state(state_r), %ecx
-        movl    window_state(state_r), %edx
-
-        movl    %eax, wsize(%esp)
-        movl    %ecx, write(%esp)
-        movl    %edx, window(%esp)
-
-        movl    hold_state(state_r), %ebp
-        movl    bits_state(state_r), %ebx
-
-#undef strm_r
-#undef state_r
-
-#define in_r       %esi
-#define from_r     %esi
-#define out_r      %edi
-
-        movl    in(%esp), in_r
-        movl    last(%esp), %ecx
-        cmpl    in_r, %ecx
-        ja      .L_align_long           /* if in < last */
-
-        addl    $11, %ecx               /* ecx = &in[ avail_in ] */
-        subl    in_r, %ecx              /* ecx = avail_in */
-        movl    $12, %eax
-        subl    %ecx, %eax              /* eax = 12 - avail_in */
-        leal    buf(%esp), %edi
-        rep     movsb                   /* memcpy( buf, in, avail_in ) */
-        movl    %eax, %ecx
-        xorl    %eax, %eax
-        rep     stosb         /* memset( &buf[ avail_in ], 0, 12 - avail_in ) */
-        leal    buf(%esp), in_r         /* in = buf */
-        movl    in_r, last(%esp)        /* last = in, do just one iteration */
-        jmp     .L_is_aligned
-
-        /* align in_r on long boundary */
-.L_align_long:
-        testl   $3, in_r
-        jz      .L_is_aligned
-        xorl    %eax, %eax
-        movb    (in_r), %al
-        incl    in_r
-        movl    %ebx, %ecx
-        addl    $8, %ebx
-        shll    %cl, %eax
-        orl     %eax, %ebp
-        jmp     .L_align_long
-
-.L_is_aligned:
-        movl    out(%esp), out_r
-
-#if defined( NO_MMX )
-        jmp     .L_do_loop
-#endif
-
-#if defined( USE_MMX )
-        jmp     .L_init_mmx
-#endif
-
-/*** Runtime MMX check ***/
-
-#if defined( RUN_TIME_MMX )
-.L_check_mmx:
-        cmpl    $DO_USE_MMX, inflate_fast_use_mmx
-        je      .L_init_mmx
-        ja      .L_do_loop /* > 2 */
-
-        pushl   %eax
-        pushl   %ebx
-        pushl   %ecx
-        pushl   %edx
-        pushf
-        movl    (%esp), %eax      /* copy eflags to eax */
-        xorl    $0x200000, (%esp) /* try toggling ID bit of eflags (bit 21)
-                                   * to see if cpu supports cpuid...
-                                   * ID bit method not supported by NexGen but
-                                   * bios may load a cpuid instruction and
-                                   * cpuid may be disabled on Cyrix 5-6x86 */
-        popf
-        pushf
-        popl    %edx              /* copy new eflags to edx */
-        xorl    %eax, %edx        /* test if ID bit is flipped */
-        jz      .L_dont_use_mmx   /* not flipped if zero */
-        xorl    %eax, %eax
-        cpuid
-        cmpl    $0x756e6547, %ebx /* check for GenuineIntel in ebx,ecx,edx */
-        jne     .L_dont_use_mmx
-        cmpl    $0x6c65746e, %ecx
-        jne     .L_dont_use_mmx
-        cmpl    $0x49656e69, %edx
-        jne     .L_dont_use_mmx
-        movl    $1, %eax
-        cpuid                     /* get cpu features */
-        shrl    $8, %eax
-        andl    $15, %eax
-        cmpl    $6, %eax          /* check for Pentium family, is 0xf for P4 */
-        jne     .L_dont_use_mmx
-        testl   $0x800000, %edx   /* test if MMX feature is set (bit 23) */
-        jnz     .L_use_mmx
-        jmp     .L_dont_use_mmx
-.L_use_mmx:
-        movl    $DO_USE_MMX, inflate_fast_use_mmx
-        jmp     .L_check_mmx_pop
-.L_dont_use_mmx:
-        movl    $DONT_USE_MMX, inflate_fast_use_mmx
-.L_check_mmx_pop:
-        popl    %edx
-        popl    %ecx
-        popl    %ebx
-        popl    %eax
-        jmp     .L_check_mmx
-#endif
-
-
-/*** Non-MMX code ***/
-
-#if defined ( NO_MMX ) || defined( RUN_TIME_MMX )
-
-#define hold_r     %ebp
-#define bits_r     %bl
-#define bitslong_r %ebx
-
-.align 32,0x90
-.L_while_test:
-        /* while (in < last && out < end)
-         */
-        cmpl    out_r, end(%esp)
-        jbe     .L_break_loop           /* if (out >= end) */
-
-        cmpl    in_r, last(%esp)
-        jbe     .L_break_loop
-
-.L_do_loop:
-        /* regs: %esi = in, %ebp = hold, %bl = bits, %edi = out
-         *
-         * do {
-         *   if (bits < 15) {
-         *     hold |= *((unsigned short *)in)++ << bits;
-         *     bits += 16
-         *   }
-         *   this = lcode[hold & lmask]
-         */
-        cmpb    $15, bits_r
-        ja      .L_get_length_code      /* if (15 < bits) */
-
-        xorl    %eax, %eax
-        lodsw                           /* al = *(ushort *)in++ */
-        movb    bits_r, %cl             /* cl = bits, needs it for shifting */
-        addb    $16, bits_r             /* bits += 16 */
-        shll    %cl, %eax
-        orl     %eax, hold_r            /* hold |= *((ushort *)in)++ << bits */
-
-.L_get_length_code:
-        movl    lmask(%esp), %edx       /* edx = lmask */
-        movl    lcode(%esp), %ecx       /* ecx = lcode */
-        andl    hold_r, %edx            /* edx &= hold */
-        movl    (%ecx,%edx,4), %eax     /* eax = lcode[hold & lmask] */
-
-.L_dolen:
-        /* regs: %esi = in, %ebp = hold, %bl = bits, %edi = out
-         *
-         * dolen:
-         *    bits -= this.bits;
-         *    hold >>= this.bits
-         */
-        movb    %ah, %cl                /* cl = this.bits */
-        subb    %ah, bits_r             /* bits -= this.bits */
-        shrl    %cl, hold_r             /* hold >>= this.bits */
-
-        /* check if op is a literal
-         * if (op == 0) {
-         *    PUP(out) = this.val;
-         *  }
-         */
-        testb   %al, %al
-        jnz     .L_test_for_length_base /* if (op != 0) 45.7% */
-
-        shrl    $16, %eax               /* output this.val char */
-        stosb
-        jmp     .L_while_test
-
-.L_test_for_length_base:
-        /* regs: %esi = in, %ebp = hold, %bl = bits, %edi = out, %edx = len
-         *
-         * else if (op & 16) {
-         *   len = this.val
-         *   op &= 15
-         *   if (op) {
-         *     if (op > bits) {
-         *       hold |= *((unsigned short *)in)++ << bits;
-         *       bits += 16
-         *     }
-         *     len += hold & mask[op];
-         *     bits -= op;
-         *     hold >>= op;
-         *   }
-         */
-#define len_r %edx
-        movl    %eax, len_r             /* len = this */
-        shrl    $16, len_r              /* len = this.val */
-        movb    %al, %cl
-
-        testb   $16, %al
-        jz      .L_test_for_second_level_length /* if ((op & 16) == 0) 8% */
-        andb    $15, %cl                /* op &= 15 */
-        jz      .L_save_len             /* if (!op) */
-        cmpb    %cl, bits_r
-        jae     .L_add_bits_to_len      /* if (op <= bits) */
-
-        movb    %cl, %ch                /* stash op in ch, freeing cl */
-        xorl    %eax, %eax
-        lodsw                           /* al = *(ushort *)in++ */
-        movb    bits_r, %cl             /* cl = bits, needs it for shifting */
-        addb    $16, bits_r             /* bits += 16 */
-        shll    %cl, %eax
-        orl     %eax, hold_r            /* hold |= *((ushort *)in)++ << bits */
-        movb    %ch, %cl                /* move op back to ecx */
-
-.L_add_bits_to_len:
-        movl    $1, %eax
-        shll    %cl, %eax
-        decl    %eax
-        subb    %cl, bits_r
-        andl    hold_r, %eax            /* eax &= hold */
-        shrl    %cl, hold_r
-        addl    %eax, len_r             /* len += hold & mask[op] */
-
-.L_save_len:
-        movl    len_r, len(%esp)        /* save len */
-#undef  len_r
-
-.L_decode_distance:
-        /* regs: %esi = in, %ebp = hold, %bl = bits, %edi = out, %edx = dist
-         *
-         *   if (bits < 15) {
-         *     hold |= *((unsigned short *)in)++ << bits;
-         *     bits += 16
-         *   }
-         *   this = dcode[hold & dmask];
-         * dodist:
-         *   bits -= this.bits;
-         *   hold >>= this.bits;
-         *   op = this.op;
-         */
-
-        cmpb    $15, bits_r
-        ja      .L_get_distance_code    /* if (15 < bits) */
-
-        xorl    %eax, %eax
-        lodsw                           /* al = *(ushort *)in++ */
-        movb    bits_r, %cl             /* cl = bits, needs it for shifting */
-        addb    $16, bits_r             /* bits += 16 */
-        shll    %cl, %eax
-        orl     %eax, hold_r            /* hold |= *((ushort *)in)++ << bits */
-
-.L_get_distance_code:
-        movl    dmask(%esp), %edx       /* edx = dmask */
-        movl    dcode(%esp), %ecx       /* ecx = dcode */
-        andl    hold_r, %edx            /* edx &= hold */
-        movl    (%ecx,%edx,4), %eax     /* eax = dcode[hold & dmask] */
-
-#define dist_r %edx
-.L_dodist:
-        movl    %eax, dist_r            /* dist = this */
-        shrl    $16, dist_r             /* dist = this.val */
-        movb    %ah, %cl
-        subb    %ah, bits_r             /* bits -= this.bits */
-        shrl    %cl, hold_r             /* hold >>= this.bits */
-
-        /* if (op & 16) {
-         *   dist = this.val
-         *   op &= 15
-         *   if (op > bits) {
-         *     hold |= *((unsigned short *)in)++ << bits;
-         *     bits += 16
-         *   }
-         *   dist += hold & mask[op];
-         *   bits -= op;
-         *   hold >>= op;
-         */
-        movb    %al, %cl                /* cl = this.op */
-
-        testb   $16, %al                /* if ((op & 16) == 0) */
-        jz      .L_test_for_second_level_dist
-        andb    $15, %cl                /* op &= 15 */
-        jz      .L_check_dist_one
-        cmpb    %cl, bits_r
-        jae     .L_add_bits_to_dist     /* if (op <= bits) 97.6% */
-
-        movb    %cl, %ch                /* stash op in ch, freeing cl */
-        xorl    %eax, %eax
-        lodsw                           /* al = *(ushort *)in++ */
-        movb    bits_r, %cl             /* cl = bits, needs it for shifting */
-        addb    $16, bits_r             /* bits += 16 */
-        shll    %cl, %eax
-        orl     %eax, hold_r            /* hold |= *((ushort *)in)++ << bits */
-        movb    %ch, %cl                /* move op back to ecx */
-
-.L_add_bits_to_dist:
-        movl    $1, %eax
-        shll    %cl, %eax
-        decl    %eax                    /* (1 << op) - 1 */
-        subb    %cl, bits_r
-        andl    hold_r, %eax            /* eax &= hold */
-        shrl    %cl, hold_r
-        addl    %eax, dist_r            /* dist += hold & ((1 << op) - 1) */
-        jmp     .L_check_window
-
-.L_check_window:
-        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist
-         *       %ecx = nbytes
-         *
-         * nbytes = out - beg;
-         * if (dist <= nbytes) {
-         *   from = out - dist;
-         *   do {
-         *     PUP(out) = PUP(from);
-         *   } while (--len > 0) {
-         * }
-         */
-
-        movl    in_r, in(%esp)          /* save in so from can use it's reg */
-        movl    out_r, %eax
-        subl    beg(%esp), %eax         /* nbytes = out - beg */
-
-        cmpl    dist_r, %eax
-        jb      .L_clip_window          /* if (dist > nbytes) 4.2% */
-
-        movl    len(%esp), %ecx
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-
-        subl    $3, %ecx
-        movb    (from_r), %al
-        movb    %al, (out_r)
-        movb    1(from_r), %al
-        movb    2(from_r), %dl
-        addl    $3, from_r
-        movb    %al, 1(out_r)
-        movb    %dl, 2(out_r)
-        addl    $3, out_r
-        rep     movsb
-
-        movl    in(%esp), in_r          /* move in back to %esi, toss from */
-        jmp     .L_while_test
-
-.align 16,0x90
-.L_check_dist_one:
-        cmpl    $1, dist_r
-        jne     .L_check_window
-        cmpl    out_r, beg(%esp)
-        je      .L_check_window
-
-        decl    out_r
-        movl    len(%esp), %ecx
-        movb    (out_r), %al
-        subl    $3, %ecx
-
-        movb    %al, 1(out_r)
-        movb    %al, 2(out_r)
-        movb    %al, 3(out_r)
-        addl    $4, out_r
-        rep     stosb
-
-        jmp     .L_while_test
-
-.align 16,0x90
-.L_test_for_second_level_length:
-        /* else if ((op & 64) == 0) {
-         *   this = lcode[this.val + (hold & mask[op])];
-         * }
-         */
-        testb   $64, %al
-        jnz     .L_test_for_end_of_block  /* if ((op & 64) != 0) */
-
-        movl    $1, %eax
-        shll    %cl, %eax
-        decl    %eax
-        andl    hold_r, %eax            /* eax &= hold */
-        addl    %edx, %eax              /* eax += this.val */
-        movl    lcode(%esp), %edx       /* edx = lcode */
-        movl    (%edx,%eax,4), %eax     /* eax = lcode[val + (hold&mask[op])] */
-        jmp     .L_dolen
-
-.align 16,0x90
-.L_test_for_second_level_dist:
-        /* else if ((op & 64) == 0) {
-         *   this = dcode[this.val + (hold & mask[op])];
-         * }
-         */
-        testb   $64, %al
-        jnz     .L_invalid_distance_code  /* if ((op & 64) != 0) */
-
-        movl    $1, %eax
-        shll    %cl, %eax
-        decl    %eax
-        andl    hold_r, %eax            /* eax &= hold */
-        addl    %edx, %eax              /* eax += this.val */
-        movl    dcode(%esp), %edx       /* edx = dcode */
-        movl    (%edx,%eax,4), %eax     /* eax = dcode[val + (hold&mask[op])] */
-        jmp     .L_dodist
-
-.align 16,0x90
-.L_clip_window:
-        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist
-         *       %ecx = nbytes
-         *
-         * else {
-         *   if (dist > wsize) {
-         *     invalid distance
-         *   }
-         *   from = window;
-         *   nbytes = dist - nbytes;
-         *   if (write == 0) {
-         *     from += wsize - nbytes;
-         */
-#define nbytes_r %ecx
-        movl    %eax, nbytes_r
-        movl    wsize(%esp), %eax       /* prepare for dist compare */
-        negl    nbytes_r                /* nbytes = -nbytes */
-        movl    window(%esp), from_r    /* from = window */
-
-        cmpl    dist_r, %eax
-        jb      .L_invalid_distance_too_far /* if (dist > wsize) */
-
-        addl    dist_r, nbytes_r        /* nbytes = dist - nbytes */
-        cmpl    $0, write(%esp)
-        jne     .L_wrap_around_window   /* if (write != 0) */
-
-        subl    nbytes_r, %eax
-        addl    %eax, from_r            /* from += wsize - nbytes */
-
-        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist
-         *       %ecx = nbytes, %eax = len
-         *
-         *     if (nbytes < len) {
-         *       len -= nbytes;
-         *       do {
-         *         PUP(out) = PUP(from);
-         *       } while (--nbytes);
-         *       from = out - dist;
-         *     }
-         *   }
-         */
-#define len_r %eax
-        movl    len(%esp), len_r
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1             /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-        jmp     .L_do_copy1
-
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1             /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-        jmp     .L_do_copy1
-
-.L_wrap_around_window:
-        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist
-         *       %ecx = nbytes, %eax = write, %eax = len
-         *
-         *   else if (write < nbytes) {
-         *     from += wsize + write - nbytes;
-         *     nbytes -= write;
-         *     if (nbytes < len) {
-         *       len -= nbytes;
-         *       do {
-         *         PUP(out) = PUP(from);
-         *       } while (--nbytes);
-         *       from = window;
-         *       nbytes = write;
-         *       if (nbytes < len) {
-         *         len -= nbytes;
-         *         do {
-         *           PUP(out) = PUP(from);
-         *         } while(--nbytes);
-         *         from = out - dist;
-         *       }
-         *     }
-         *   }
-         */
-#define write_r %eax
-        movl    write(%esp), write_r
-        cmpl    write_r, nbytes_r
-        jbe     .L_contiguous_in_window /* if (write >= nbytes) */
-
-        addl    wsize(%esp), from_r
-        addl    write_r, from_r
-        subl    nbytes_r, from_r        /* from += wsize + write - nbytes */
-        subl    write_r, nbytes_r       /* nbytes -= write */
-#undef write_r
-
-        movl    len(%esp), len_r
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1             /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    window(%esp), from_r    /* from = window */
-        movl    write(%esp), nbytes_r   /* nbytes = write */
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1             /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-        jmp     .L_do_copy1
-
-.L_contiguous_in_window:
-        /* regs: %esi = from, %ebp = hold, %bl = bits, %edi = out, %edx = dist
-         *       %ecx = nbytes, %eax = write, %eax = len
-         *
-         *   else {
-         *     from += write - nbytes;
-         *     if (nbytes < len) {
-         *       len -= nbytes;
-         *       do {
-         *         PUP(out) = PUP(from);
-         *       } while (--nbytes);
-         *       from = out - dist;
-         *     }
-         *   }
-         */
-#define write_r %eax
-        addl    write_r, from_r
-        subl    nbytes_r, from_r        /* from += write - nbytes */
-#undef write_r
-
-        movl    len(%esp), len_r
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1             /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-
-.L_do_copy1:
-        /* regs: %esi = from, %esi = in, %ebp = hold, %bl = bits, %edi = out
-         *       %eax = len
-         *
-         *     while (len > 0) {
-         *       PUP(out) = PUP(from);
-         *       len--;
-         *     }
-         *   }
-         * } while (in < last && out < end);
-         */
-#undef nbytes_r
-#define in_r %esi
-        movl    len_r, %ecx
-        rep     movsb
-
-        movl    in(%esp), in_r          /* move in back to %esi, toss from */
-        jmp     .L_while_test
-
-#undef len_r
-#undef dist_r
-
-#endif /* NO_MMX || RUN_TIME_MMX */
-
-
-/*** MMX code ***/
-
-#if defined( USE_MMX ) || defined( RUN_TIME_MMX )
-
-.align 32,0x90
-.L_init_mmx:
-        emms
-
-#undef  bits_r
-#undef  bitslong_r
-#define bitslong_r %ebp
-#define hold_mm    %mm0
-        movd    %ebp, hold_mm
-        movl    %ebx, bitslong_r
-
-#define used_mm   %mm1
-#define dmask2_mm %mm2
-#define lmask2_mm %mm3
-#define lmask_mm  %mm4
-#define dmask_mm  %mm5
-#define tmp_mm    %mm6
-
-        movd    lmask(%esp), lmask_mm
-        movq    lmask_mm, lmask2_mm
-        movd    dmask(%esp), dmask_mm
-        movq    dmask_mm, dmask2_mm
-        pxor    used_mm, used_mm
-        movl    lcode(%esp), %ebx       /* ebx = lcode */
-        jmp     .L_do_loop_mmx
-
-.align 32,0x90
-.L_while_test_mmx:
-        /* while (in < last && out < end)
-         */
-        cmpl    out_r, end(%esp)
-        jbe     .L_break_loop           /* if (out >= end) */
-
-        cmpl    in_r, last(%esp)
-        jbe     .L_break_loop
-
-.L_do_loop_mmx:
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-
-        cmpl    $32, bitslong_r
-        ja      .L_get_length_code_mmx  /* if (32 < bits) */
-
-        movd    bitslong_r, tmp_mm
-        movd    (in_r), %mm7
-        addl    $4, in_r
-        psllq   tmp_mm, %mm7
-        addl    $32, bitslong_r
-        por     %mm7, hold_mm           /* hold_mm |= *((uint *)in)++ << bits */
-
-.L_get_length_code_mmx:
-        pand    hold_mm, lmask_mm
-        movd    lmask_mm, %eax
-        movq    lmask2_mm, lmask_mm
-        movl    (%ebx,%eax,4), %eax     /* eax = lcode[hold & lmask] */
-
-.L_dolen_mmx:
-        movzbl  %ah, %ecx               /* ecx = this.bits */
-        movd    %ecx, used_mm
-        subl    %ecx, bitslong_r        /* bits -= this.bits */
-
-        testb   %al, %al
-        jnz     .L_test_for_length_base_mmx /* if (op != 0) 45.7% */
-
-        shrl    $16, %eax               /* output this.val char */
-        stosb
-        jmp     .L_while_test_mmx
-
-.L_test_for_length_base_mmx:
-#define len_r  %edx
-        movl    %eax, len_r             /* len = this */
-        shrl    $16, len_r              /* len = this.val */
-
-        testb   $16, %al
-        jz      .L_test_for_second_level_length_mmx /* if ((op & 16) == 0) 8% */
-        andl    $15, %eax               /* op &= 15 */
-        jz      .L_decode_distance_mmx  /* if (!op) */
-
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-        movd    %eax, used_mm
-        movd    hold_mm, %ecx
-        subl    %eax, bitslong_r
-        andl    .L_mask(,%eax,4), %ecx
-        addl    %ecx, len_r             /* len += hold & mask[op] */
-
-.L_decode_distance_mmx:
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-
-        cmpl    $32, bitslong_r
-        ja      .L_get_dist_code_mmx    /* if (32 < bits) */
-
-        movd    bitslong_r, tmp_mm
-        movd    (in_r), %mm7
-        addl    $4, in_r
-        psllq   tmp_mm, %mm7
-        addl    $32, bitslong_r
-        por     %mm7, hold_mm           /* hold_mm |= *((uint *)in)++ << bits */
-
-.L_get_dist_code_mmx:
-        movl    dcode(%esp), %ebx       /* ebx = dcode */
-        pand    hold_mm, dmask_mm
-        movd    dmask_mm, %eax
-        movq    dmask2_mm, dmask_mm
-        movl    (%ebx,%eax,4), %eax     /* eax = dcode[hold & lmask] */
-
-.L_dodist_mmx:
-#define dist_r %ebx
-        movzbl  %ah, %ecx               /* ecx = this.bits */
-        movl    %eax, dist_r
-        shrl    $16, dist_r             /* dist  = this.val */
-        subl    %ecx, bitslong_r        /* bits -= this.bits */
-        movd    %ecx, used_mm
-
-        testb   $16, %al                /* if ((op & 16) == 0) */
-        jz      .L_test_for_second_level_dist_mmx
-        andl    $15, %eax               /* op &= 15 */
-        jz      .L_check_dist_one_mmx
-
-.L_add_bits_to_dist_mmx:
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-        movd    %eax, used_mm           /* save bit length of current op */
-        movd    hold_mm, %ecx           /* get the next bits on input stream */
-        subl    %eax, bitslong_r        /* bits -= op bits */
-        andl    .L_mask(,%eax,4), %ecx  /* ecx   = hold & mask[op] */
-        addl    %ecx, dist_r            /* dist += hold & mask[op] */
-
-.L_check_window_mmx:
-        movl    in_r, in(%esp)          /* save in so from can use it's reg */
-        movl    out_r, %eax
-        subl    beg(%esp), %eax         /* nbytes = out - beg */
-
-        cmpl    dist_r, %eax
-        jb      .L_clip_window_mmx      /* if (dist > nbytes) 4.2% */
-
-        movl    len_r, %ecx
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-
-        subl    $3, %ecx
-        movb    (from_r), %al
-        movb    %al, (out_r)
-        movb    1(from_r), %al
-        movb    2(from_r), %dl
-        addl    $3, from_r
-        movb    %al, 1(out_r)
-        movb    %dl, 2(out_r)
-        addl    $3, out_r
-        rep     movsb
-
-        movl    in(%esp), in_r          /* move in back to %esi, toss from */
-        movl    lcode(%esp), %ebx       /* move lcode back to %ebx, toss dist */
-        jmp     .L_while_test_mmx
-
-.align 16,0x90
-.L_check_dist_one_mmx:
-        cmpl    $1, dist_r
-        jne     .L_check_window_mmx
-        cmpl    out_r, beg(%esp)
-        je      .L_check_window_mmx
-
-        decl    out_r
-        movl    len_r, %ecx
-        movb    (out_r), %al
-        subl    $3, %ecx
-
-        movb    %al, 1(out_r)
-        movb    %al, 2(out_r)
-        movb    %al, 3(out_r)
-        addl    $4, out_r
-        rep     stosb
-
-        movl    lcode(%esp), %ebx       /* move lcode back to %ebx, toss dist */
-        jmp     .L_while_test_mmx
-
-.align 16,0x90
-.L_test_for_second_level_length_mmx:
-        testb   $64, %al
-        jnz     .L_test_for_end_of_block  /* if ((op & 64) != 0) */
-
-        andl    $15, %eax
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-        movd    hold_mm, %ecx
-        andl    .L_mask(,%eax,4), %ecx
-        addl    len_r, %ecx
-        movl    (%ebx,%ecx,4), %eax     /* eax = lcode[hold & lmask] */
-        jmp     .L_dolen_mmx
-
-.align 16,0x90
-.L_test_for_second_level_dist_mmx:
-        testb   $64, %al
-        jnz     .L_invalid_distance_code  /* if ((op & 64) != 0) */
-
-        andl    $15, %eax
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-        movd    hold_mm, %ecx
-        andl    .L_mask(,%eax,4), %ecx
-        movl    dcode(%esp), %eax       /* ecx = dcode */
-        addl    dist_r, %ecx
-        movl    (%eax,%ecx,4), %eax     /* eax = lcode[hold & lmask] */
-        jmp     .L_dodist_mmx
-
-.align 16,0x90
-.L_clip_window_mmx:
-#define nbytes_r %ecx
-        movl    %eax, nbytes_r
-        movl    wsize(%esp), %eax       /* prepare for dist compare */
-        negl    nbytes_r                /* nbytes = -nbytes */
-        movl    window(%esp), from_r    /* from = window */
-
-        cmpl    dist_r, %eax
-        jb      .L_invalid_distance_too_far /* if (dist > wsize) */
-
-        addl    dist_r, nbytes_r        /* nbytes = dist - nbytes */
-        cmpl    $0, write(%esp)
-        jne     .L_wrap_around_window_mmx /* if (write != 0) */
-
-        subl    nbytes_r, %eax
-        addl    %eax, from_r            /* from += wsize - nbytes */
-
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-        jmp     .L_do_copy1_mmx
-
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-        jmp     .L_do_copy1_mmx
-
-.L_wrap_around_window_mmx:
-#define write_r %eax
-        movl    write(%esp), write_r
-        cmpl    write_r, nbytes_r
-        jbe     .L_contiguous_in_window_mmx /* if (write >= nbytes) */
-
-        addl    wsize(%esp), from_r
-        addl    write_r, from_r
-        subl    nbytes_r, from_r        /* from += wsize + write - nbytes */
-        subl    write_r, nbytes_r       /* nbytes -= write */
-#undef write_r
-
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    window(%esp), from_r    /* from = window */
-        movl    write(%esp), nbytes_r   /* nbytes = write */
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-        jmp     .L_do_copy1_mmx
-
-.L_contiguous_in_window_mmx:
-#define write_r %eax
-        addl    write_r, from_r
-        subl    nbytes_r, from_r        /* from += write - nbytes */
-#undef write_r
-
-        cmpl    nbytes_r, len_r
-        jbe     .L_do_copy1_mmx         /* if (nbytes >= len) */
-
-        subl    nbytes_r, len_r         /* len -= nbytes */
-        rep     movsb
-        movl    out_r, from_r
-        subl    dist_r, from_r          /* from = out - dist */
-
-.L_do_copy1_mmx:
-#undef nbytes_r
-#define in_r %esi
-        movl    len_r, %ecx
-        rep     movsb
-
-        movl    in(%esp), in_r          /* move in back to %esi, toss from */
-        movl    lcode(%esp), %ebx       /* move lcode back to %ebx, toss dist */
-        jmp     .L_while_test_mmx
-
-#undef hold_r
-#undef bitslong_r
-
-#endif /* USE_MMX || RUN_TIME_MMX */
-
-
-/*** USE_MMX, NO_MMX, and RUNTIME_MMX from here on ***/
-
-.L_invalid_distance_code:
-        /* else {
-         *   strm->msg = "invalid distance code";
-         *   state->mode = BAD;
-         * }
-         */
-        movl    $.L_invalid_distance_code_msg, %ecx
-        movl    $INFLATE_MODE_BAD, %edx
-        jmp     .L_update_stream_state
-
-.L_test_for_end_of_block:
-        /* else if (op & 32) {
-         *   state->mode = TYPE;
-         *   break;
-         * }
-         */
-        testb   $32, %al
-        jz      .L_invalid_literal_length_code  /* if ((op & 32) == 0) */
-
-        movl    $0, %ecx
-        movl    $INFLATE_MODE_TYPE, %edx
-        jmp     .L_update_stream_state
-
-.L_invalid_literal_length_code:
-        /* else {
-         *   strm->msg = "invalid literal/length code";
-         *   state->mode = BAD;
-         * }
-         */
-        movl    $.L_invalid_literal_length_code_msg, %ecx
-        movl    $INFLATE_MODE_BAD, %edx
-        jmp     .L_update_stream_state
-
-.L_invalid_distance_too_far:
-        /* strm->msg = "invalid distance too far back";
-         * state->mode = BAD;
-         */
-        movl    in(%esp), in_r          /* from_r has in's reg, put in back */
-        movl    $.L_invalid_distance_too_far_msg, %ecx
-        movl    $INFLATE_MODE_BAD, %edx
-        jmp     .L_update_stream_state
-
-.L_update_stream_state:
-        /* set strm->msg = %ecx, strm->state->mode = %edx */
-        movl    strm_sp(%esp), %eax
-        testl   %ecx, %ecx              /* if (msg != NULL) */
-        jz      .L_skip_msg
-        movl    %ecx, msg_strm(%eax)    /* strm->msg = msg */
-.L_skip_msg:
-        movl    state_strm(%eax), %eax  /* state = strm->state */
-        movl    %edx, mode_state(%eax)  /* state->mode = edx (BAD | TYPE) */
-        jmp     .L_break_loop
-
-.align 32,0x90
-.L_break_loop:
-
-/*
- * Regs:
- *
- * bits = %ebp when mmx, and in %ebx when non-mmx
- * hold = %hold_mm when mmx, and in %ebp when non-mmx
- * in   = %esi
- * out  = %edi
- */
-
-#if defined( USE_MMX ) || defined( RUN_TIME_MMX )
-
-#if defined( RUN_TIME_MMX )
-
-        cmpl    $DO_USE_MMX, inflate_fast_use_mmx
-        jne     .L_update_next_in
-
-#endif /* RUN_TIME_MMX */
-
-        movl    %ebp, %ebx
-
-.L_update_next_in:
-
-#endif
-
-#define strm_r  %eax
-#define state_r %edx
-
-        /* len = bits >> 3;
-         * in -= len;
-         * bits -= len << 3;
-         * hold &= (1U << bits) - 1;
-         * state->hold = hold;
-         * state->bits = bits;
-         * strm->next_in = in;
-         * strm->next_out = out;
-         */
-        movl    strm_sp(%esp), strm_r
-        movl    %ebx, %ecx
-        movl    state_strm(strm_r), state_r
-        shrl    $3, %ecx
-        subl    %ecx, in_r
-        shll    $3, %ecx
-        subl    %ecx, %ebx
-        movl    out_r, next_out_strm(strm_r)
-        movl    %ebx, bits_state(state_r)
-        movl    %ebx, %ecx
-
-        leal    buf(%esp), %ebx
-        cmpl    %ebx, last(%esp)
-        jne     .L_buf_not_used         /* if buf != last */
-
-        subl    %ebx, in_r              /* in -= buf */
-        movl    next_in_strm(strm_r), %ebx
-        movl    %ebx, last(%esp)        /* last = strm->next_in */
-        addl    %ebx, in_r              /* in += strm->next_in */
-        movl    avail_in_strm(strm_r), %ebx
-        subl    $11, %ebx
-        addl    %ebx, last(%esp)    /* last = &strm->next_in[ avail_in - 11 ] */
-
-.L_buf_not_used:
-        movl    in_r, next_in_strm(strm_r)
-
-        movl    $1, %ebx
-        shll    %cl, %ebx
-        decl    %ebx
-
-#if defined( USE_MMX ) || defined( RUN_TIME_MMX )
-
-#if defined( RUN_TIME_MMX )
-
-        cmpl    $DO_USE_MMX, inflate_fast_use_mmx
-        jne     .L_update_hold
-
-#endif /* RUN_TIME_MMX */
-
-        psrlq   used_mm, hold_mm        /* hold_mm >>= last bit length */
-        movd    hold_mm, %ebp
-
-        emms
-
-.L_update_hold:
-
-#endif /* USE_MMX || RUN_TIME_MMX */
-
-        andl    %ebx, %ebp
-        movl    %ebp, hold_state(state_r)
-
-#define last_r %ebx
-
-        /* strm->avail_in = in < last ? 11 + (last - in) : 11 - (in - last) */
-        movl    last(%esp), last_r
-        cmpl    in_r, last_r
-        jbe     .L_last_is_smaller     /* if (in >= last) */
-
-        subl    in_r, last_r           /* last -= in */
-        addl    $11, last_r            /* last += 11 */
-        movl    last_r, avail_in_strm(strm_r)
-        jmp     .L_fixup_out
-.L_last_is_smaller:
-        subl    last_r, in_r           /* in -= last */
-        negl    in_r                   /* in = -in */
-        addl    $11, in_r              /* in += 11 */
-        movl    in_r, avail_in_strm(strm_r)
-
-#undef last_r
-#define end_r %ebx
-
-.L_fixup_out:
-        /* strm->avail_out = out < end ? 257 + (end - out) : 257 - (out - end)*/
-        movl    end(%esp), end_r
-        cmpl    out_r, end_r
-        jbe     .L_end_is_smaller      /* if (out >= end) */
-
-        subl    out_r, end_r           /* end -= out */
-        addl    $257, end_r            /* end += 257 */
-        movl    end_r, avail_out_strm(strm_r)
-        jmp     .L_done
-.L_end_is_smaller:
-        subl    end_r, out_r           /* out -= end */
-        negl    out_r                  /* out = -out */
-        addl    $257, out_r            /* out += 257 */
-        movl    out_r, avail_out_strm(strm_r)
-
-#undef end_r
-#undef strm_r
-#undef state_r
-
-.L_done:
-        addl    $local_var_size, %esp
-        popf
-        popl    %ebx
-        popl    %ebp
-        popl    %esi
-        popl    %edi
-        ret
-
-#if defined( GAS_ELF )
-/* elf info */
-.type inflate_fast,@function
-.size inflate_fast,.-inflate_fast
-#endif
diff -Nbaur gcc-4.6.3/zlib/contrib/iostream/test.cpp gcc-4.6.3-psp/zlib/contrib/iostream/test.cpp
--- gcc-4.6.3/zlib/contrib/iostream/test.cpp	2004-10-11 18:35:40.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/iostream/test.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,24 +0,0 @@
-
-#include "zfstream.h"
-
-int main() {
-
-  // Construct a stream object with this filebuffer.  Anything sent
-  // to this stream will go to standard out.
-  gzofstream os( 1, ios::out );
-
-  // This text is getting compressed and sent to stdout.
-  // To prove this, run 'test | zcat'.
-  os << "Hello, Mommy" << endl;
-
-  os << setcompressionlevel( Z_NO_COMPRESSION );
-  os << "hello, hello, hi, ho!" << endl;
-
-  setcompressionlevel( os, Z_DEFAULT_COMPRESSION )
-    << "I'm compressing again" << endl;
-
-  os.close();
-
-  return 0;
-
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/iostream/zfstream.cpp gcc-4.6.3-psp/zlib/contrib/iostream/zfstream.cpp
--- gcc-4.6.3/zlib/contrib/iostream/zfstream.cpp	2004-10-11 19:45:43.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/iostream/zfstream.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,329 +0,0 @@
-
-#include "zfstream.h"
-
-gzfilebuf::gzfilebuf() :
-  file(NULL),
-  mode(0),
-  own_file_descriptor(0)
-{ }
-
-gzfilebuf::~gzfilebuf() {
-
-  sync();
-  if ( own_file_descriptor )
-    close();
-
-}
-
-gzfilebuf *gzfilebuf::open( const char *name,
-                            int io_mode ) {
-
-  if ( is_open() )
-    return NULL;
-
-  char char_mode[10];
-  char *p = char_mode;
-
-  if ( io_mode & ios::in ) {
-    mode = ios::in;
-    *p++ = 'r';
-  } else if ( io_mode & ios::app ) {
-    mode = ios::app;
-    *p++ = 'a';
-  } else {
-    mode = ios::out;
-    *p++ = 'w';
-  }
-
-  if ( io_mode & ios::binary ) {
-    mode |= ios::binary;
-    *p++ = 'b';
-  }
-
-  // Hard code the compression level
-  if ( io_mode & (ios::out|ios::app )) {
-    *p++ = '9';
-  }
-
-  // Put the end-of-string indicator
-  *p = '\0';
-
-  if ( (file = gzopen(name, char_mode)) == NULL )
-    return NULL;
-
-  own_file_descriptor = 1;
-
-  return this;
-
-}
-
-gzfilebuf *gzfilebuf::attach( int file_descriptor,
-                              int io_mode ) {
-
-  if ( is_open() )
-    return NULL;
-
-  char char_mode[10];
-  char *p = char_mode;
-
-  if ( io_mode & ios::in ) {
-    mode = ios::in;
-    *p++ = 'r';
-  } else if ( io_mode & ios::app ) {
-    mode = ios::app;
-    *p++ = 'a';
-  } else {
-    mode = ios::out;
-    *p++ = 'w';
-  }
-
-  if ( io_mode & ios::binary ) {
-    mode |= ios::binary;
-    *p++ = 'b';
-  }
-
-  // Hard code the compression level
-  if ( io_mode & (ios::out|ios::app )) {
-    *p++ = '9';
-  }
-
-  // Put the end-of-string indicator
-  *p = '\0';
-
-  if ( (file = gzdopen(file_descriptor, char_mode)) == NULL )
-    return NULL;
-
-  own_file_descriptor = 0;
-
-  return this;
-
-}
-
-gzfilebuf *gzfilebuf::close() {
-
-  if ( is_open() ) {
-
-    sync();
-    gzclose( file );
-    file = NULL;
-
-  }
-
-  return this;
-
-}
-
-int gzfilebuf::setcompressionlevel( int comp_level ) {
-
-  return gzsetparams(file, comp_level, -2);
-
-}
-
-int gzfilebuf::setcompressionstrategy( int comp_strategy ) {
-
-  return gzsetparams(file, -2, comp_strategy);
-
-}
-
-
-streampos gzfilebuf::seekoff( streamoff off, ios::seek_dir dir, int which ) {
-
-  return streampos(EOF);
-
-}
-
-int gzfilebuf::underflow() {
-
-  // If the file hasn't been opened for reading, error.
-  if ( !is_open() || !(mode & ios::in) )
-    return EOF;
-
-  // if a buffer doesn't exists, allocate one.
-  if ( !base() ) {
-
-    if ( (allocate()) == EOF )
-      return EOF;
-    setp(0,0);
-
-  } else {
-
-    if ( in_avail() )
-      return (unsigned char) *gptr();
-
-    if ( out_waiting() ) {
-      if ( flushbuf() == EOF )
-        return EOF;
-    }
-
-  }
-
-  // Attempt to fill the buffer.
-
-  int result = fillbuf();
-  if ( result == EOF ) {
-    // disable get area
-    setg(0,0,0);
-    return EOF;
-  }
-
-  return (unsigned char) *gptr();
-
-}
-
-int gzfilebuf::overflow( int c ) {
-
-  if ( !is_open() || !(mode & ios::out) )
-    return EOF;
-
-  if ( !base() ) {
-    if ( allocate() == EOF )
-      return EOF;
-    setg(0,0,0);
-  } else {
-    if (in_avail()) {
-        return EOF;
-    }
-    if (out_waiting()) {
-      if (flushbuf() == EOF)
-        return EOF;
-    }
-  }
-
-  int bl = blen();
-  setp( base(), base() + bl);
-
-  if ( c != EOF ) {
-
-    *pptr() = c;
-    pbump(1);
-
-  }
-
-  return 0;
-
-}
-
-int gzfilebuf::sync() {
-
-  if ( !is_open() )
-    return EOF;
-
-  if ( out_waiting() )
-    return flushbuf();
-
-  return 0;
-
-}
-
-int gzfilebuf::flushbuf() {
-
-  int n;
-  char *q;
-
-  q = pbase();
-  n = pptr() - q;
-
-  if ( gzwrite( file, q, n) < n )
-    return EOF;
-
-  setp(0,0);
-
-  return 0;
-
-}
-
-int gzfilebuf::fillbuf() {
-
-  int required;
-  char *p;
-
-  p = base();
-
-  required = blen();
-
-  int t = gzread( file, p, required );
-
-  if ( t <= 0) return EOF;
-
-  setg( base(), base(), base()+t);
-
-  return t;
-
-}
-
-gzfilestream_common::gzfilestream_common() :
-  ios( gzfilestream_common::rdbuf() )
-{ }
-
-gzfilestream_common::~gzfilestream_common()
-{ }
-
-void gzfilestream_common::attach( int fd, int io_mode ) {
-
-  if ( !buffer.attach( fd, io_mode) )
-    clear( ios::failbit | ios::badbit );
-  else
-    clear();
-
-}
-
-void gzfilestream_common::open( const char *name, int io_mode ) {
-
-  if ( !buffer.open( name, io_mode ) )
-    clear( ios::failbit | ios::badbit );
-  else
-    clear();
-
-}
-
-void gzfilestream_common::close() {
-
-  if ( !buffer.close() )
-    clear( ios::failbit | ios::badbit );
-
-}
-
-gzfilebuf *gzfilestream_common::rdbuf()
-{
-  return &buffer;
-}
-
-gzifstream::gzifstream() :
-  ios( gzfilestream_common::rdbuf() )
-{
-  clear( ios::badbit );
-}
-
-gzifstream::gzifstream( const char *name, int io_mode ) :
-  ios( gzfilestream_common::rdbuf() )
-{
-  gzfilestream_common::open( name, io_mode );
-}
-
-gzifstream::gzifstream( int fd, int io_mode ) :
-  ios( gzfilestream_common::rdbuf() )
-{
-  gzfilestream_common::attach( fd, io_mode );
-}
-
-gzifstream::~gzifstream() { }
-
-gzofstream::gzofstream() :
-  ios( gzfilestream_common::rdbuf() )
-{
-  clear( ios::badbit );
-}
-
-gzofstream::gzofstream( const char *name, int io_mode ) :
-  ios( gzfilestream_common::rdbuf() )
-{
-  gzfilestream_common::open( name, io_mode );
-}
-
-gzofstream::gzofstream( int fd, int io_mode ) :
-  ios( gzfilestream_common::rdbuf() )
-{
-  gzfilestream_common::attach( fd, io_mode );
-}
-
-gzofstream::~gzofstream() { }
diff -Nbaur gcc-4.6.3/zlib/contrib/iostream/zfstream.h gcc-4.6.3-psp/zlib/contrib/iostream/zfstream.h
--- gcc-4.6.3/zlib/contrib/iostream/zfstream.h	2004-10-11 19:45:43.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/iostream/zfstream.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,128 +0,0 @@
-
-#ifndef zfstream_h
-#define zfstream_h
-
-#include <fstream.h>
-#include "zlib.h"
-
-class gzfilebuf : public streambuf {
-
-public:
-
-  gzfilebuf( );
-  virtual ~gzfilebuf();
-
-  gzfilebuf *open( const char *name, int io_mode );
-  gzfilebuf *attach( int file_descriptor, int io_mode );
-  gzfilebuf *close();
-
-  int setcompressionlevel( int comp_level );
-  int setcompressionstrategy( int comp_strategy );
-
-  inline int is_open() const { return (file !=NULL); }
-
-  virtual streampos seekoff( streamoff, ios::seek_dir, int );
-
-  virtual int sync();
-
-protected:
-
-  virtual int underflow();
-  virtual int overflow( int = EOF );
-
-private:
-
-  gzFile file;
-  short mode;
-  short own_file_descriptor;
-
-  int flushbuf();
-  int fillbuf();
-
-};
-
-class gzfilestream_common : virtual public ios {
-
-  friend class gzifstream;
-  friend class gzofstream;
-  friend gzofstream &setcompressionlevel( gzofstream &, int );
-  friend gzofstream &setcompressionstrategy( gzofstream &, int );
-
-public:
-  virtual ~gzfilestream_common();
-
-  void attach( int fd, int io_mode );
-  void open( const char *name, int io_mode );
-  void close();
-
-protected:
-  gzfilestream_common();
-
-private:
-  gzfilebuf *rdbuf();
-
-  gzfilebuf buffer;
-
-};
-
-class gzifstream : public gzfilestream_common, public istream {
-
-public:
-
-  gzifstream();
-  gzifstream( const char *name, int io_mode = ios::in );
-  gzifstream( int fd, int io_mode = ios::in );
-
-  virtual ~gzifstream();
-
-};
-
-class gzofstream : public gzfilestream_common, public ostream {
-
-public:
-
-  gzofstream();
-  gzofstream( const char *name, int io_mode = ios::out );
-  gzofstream( int fd, int io_mode = ios::out );
-
-  virtual ~gzofstream();
-
-};
-
-template<class T> class gzomanip {
-  friend gzofstream &operator<<(gzofstream &, const gzomanip<T> &);
-public:
-  gzomanip(gzofstream &(*f)(gzofstream &, T), T v) : func(f), val(v) { }
-private:
-  gzofstream &(*func)(gzofstream &, T);
-  T val;
-};
-
-template<class T> gzofstream &operator<<(gzofstream &s, const gzomanip<T> &m)
-{
-  return (*m.func)(s, m.val);
-}
-
-inline gzofstream &setcompressionlevel( gzofstream &s, int l )
-{
-  (s.rdbuf())->setcompressionlevel(l);
-  return s;
-}
-
-inline gzofstream &setcompressionstrategy( gzofstream &s, int l )
-{
-  (s.rdbuf())->setcompressionstrategy(l);
-  return s;
-}
-
-inline gzomanip<int> setcompressionlevel(int l)
-{
-  return gzomanip<int>(&setcompressionlevel,l);
-}
-
-inline gzomanip<int> setcompressionstrategy(int l)
-{
-  return gzomanip<int>(&setcompressionstrategy,l);
-}
-
-#endif
diff -Nbaur gcc-4.6.3/zlib/contrib/iostream2/zstream.h gcc-4.6.3-psp/zlib/contrib/iostream2/zstream.h
--- gcc-4.6.3/zlib/contrib/iostream2/zstream.h	2004-10-11 18:35:40.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/iostream2/zstream.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,307 +0,0 @@
-/*
- *
- * Copyright (c) 1997
- * Christian Michelsen Research AS
- * Advanced Computing
- * Fantoftvegen 38, 5036 BERGEN, Norway
- * http://www.cmr.no
- *
- * Permission to use, copy, modify, distribute and sell this software
- * and its documentation for any purpose is hereby granted without fee,
- * provided that the above copyright notice appear in all copies and
- * that both that copyright notice and this permission notice appear
- * in supporting documentation.  Christian Michelsen Research AS makes no
- * representations about the suitability of this software for any
- * purpose.  It is provided "as is" without express or implied warranty.
- *
- */
-
-#ifndef ZSTREAM__H
-#define ZSTREAM__H
-
-/*
- * zstream.h - C++ interface to the 'zlib' general purpose compression library
- * $Id: zstream.h,v 1.1 1999/05/04 19:30:27 tromey Exp $
- */
-
-#include <strstream.h>
-#include <string.h>
-#include <stdio.h>
-#include "zlib.h"
-
-#if defined(_WIN32)
-#   include <fcntl.h>
-#   include <io.h>
-#   define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
-#else
-#   define SET_BINARY_MODE(file)
-#endif
-
-class zstringlen {
-public:
-    zstringlen(class izstream&);
-    zstringlen(class ozstream&, const char*);
-    size_t value() const { return val.word; }
-private:
-    struct Val { unsigned char byte; size_t word; } val;
-};
-
-//  ----------------------------- izstream -----------------------------
-
-class izstream
-{
-    public:
-        izstream() : m_fp(0) {}
-        izstream(FILE* fp) : m_fp(0) { open(fp); }
-        izstream(const char* name) : m_fp(0) { open(name); }
-        ~izstream() { close(); }
-
-        /* Opens a gzip (.gz) file for reading.
-         * open() can be used to read a file which is not in gzip format;
-         * in this case read() will directly read from the file without
-         * decompression. errno can be checked to distinguish two error
-         * cases (if errno is zero, the zlib error is Z_MEM_ERROR).
-         */
-        void open(const char* name) {
-            if (m_fp) close();
-            m_fp = ::gzopen(name, "rb");
-        }
-
-        void open(FILE* fp) {
-            SET_BINARY_MODE(fp);
-            if (m_fp) close();
-            m_fp = ::gzdopen(fileno(fp), "rb");
-        }
-
-        /* Flushes all pending input if necessary, closes the compressed file
-         * and deallocates all the (de)compression state. The return value is
-         * the zlib error number (see function error() below).
-         */
-        int close() {
-            int r = ::gzclose(m_fp);
-            m_fp = 0; return r;
-        }
-
-        /* Binary read the given number of bytes from the compressed file.
-         */
-        int read(void* buf, size_t len) {
-            return ::gzread(m_fp, buf, len);
-        }
-
-        /* Returns the error message for the last error which occurred on the
-         * given compressed file. errnum is set to zlib error number. If an
-         * error occurred in the file system and not in the compression library,
-         * errnum is set to Z_ERRNO and the application may consult errno
-         * to get the exact error code.
-         */
-        const char* error(int* errnum) {
-            return ::gzerror(m_fp, errnum);
-        }
-
-        gzFile fp() { return m_fp; }
-
-    private:
-        gzFile m_fp;
-};
-
-/*
- * Binary read the given (array of) object(s) from the compressed file.
- * If the input file was not in gzip format, read() copies the objects number
- * of bytes into the buffer.
- * returns the number of uncompressed bytes actually read
- * (0 for end of file, -1 for error).
- */
-template <class T, class Items>
-inline int read(izstream& zs, T* x, Items items) {
-    return ::gzread(zs.fp(), x, items*sizeof(T));
-}
-
-/*
- * Binary input with the '>' operator.
- */
-template <class T>
-inline izstream& operator>(izstream& zs, T& x) {
-    ::gzread(zs.fp(), &x, sizeof(T));
-    return zs;
-}
-
-
-inline zstringlen::zstringlen(izstream& zs) {
-    zs > val.byte;
-    if (val.byte == 255) zs > val.word;
-    else val.word = val.byte;
-}
-
-/*
- * Read length of string + the string with the '>' operator.
- */
-inline izstream& operator>(izstream& zs, char* x) {
-    zstringlen len(zs);
-    ::gzread(zs.fp(), x, len.value());
-    x[len.value()] = '\0';
-    return zs;
-}
-
-inline char* read_string(izstream& zs) {
-    zstringlen len(zs);
-    char* x = new char[len.value()+1];
-    ::gzread(zs.fp(), x, len.value());
-    x[len.value()] = '\0';
-    return x;
-}
-
-// ----------------------------- ozstream -----------------------------
-
-class ozstream
-{
-    public:
-        ozstream() : m_fp(0), m_os(0) {
-        }
-        ozstream(FILE* fp, int level = Z_DEFAULT_COMPRESSION)
-            : m_fp(0), m_os(0) {
-            open(fp, level);
-        }
-        ozstream(const char* name, int level = Z_DEFAULT_COMPRESSION)
-            : m_fp(0), m_os(0) {
-            open(name, level);
-        }
-        ~ozstream() {
-            close();
-        }
-
-        /* Opens a gzip (.gz) file for writing.
-         * The compression level parameter should be in 0..9
-         * errno can be checked to distinguish two error cases
-         * (if errno is zero, the zlib error is Z_MEM_ERROR).
-         */
-        void open(const char* name, int level = Z_DEFAULT_COMPRESSION) {
-            char mode[4] = "wb\0";
-            if (level != Z_DEFAULT_COMPRESSION) mode[2] = '0'+level;
-            if (m_fp) close();
-            m_fp = ::gzopen(name, mode);
-        }
-
-        /* open from a FILE pointer.
-         */
-        void open(FILE* fp, int level = Z_DEFAULT_COMPRESSION) {
-            SET_BINARY_MODE(fp);
-            char mode[4] = "wb\0";
-            if (level != Z_DEFAULT_COMPRESSION) mode[2] = '0'+level;
-            if (m_fp) close();
-            m_fp = ::gzdopen(fileno(fp), mode);
-        }
-
-        /* Flushes all pending output if necessary, closes the compressed file
-         * and deallocates all the (de)compression state. The return value is
-         * the zlib error number (see function error() below).
-         */
-        int close() {
-            if (m_os) {
-                ::gzwrite(m_fp, m_os->str(), m_os->pcount());
-                delete[] m_os->str(); delete m_os; m_os = 0;
-            }
-            int r = ::gzclose(m_fp); m_fp = 0; return r;
-        }
-
-        /* Binary write the given number of bytes into the compressed file.
-         */
-        int write(const void* buf, size_t len) {
-            return ::gzwrite(m_fp, (voidp) buf, len);
-        }
-
-        /* Flushes all pending output into the compressed file. The parameter
-         * _flush is as in the deflate() function. The return value is the zlib
-         * error number (see function gzerror below). flush() returns Z_OK if
-         * the flush_ parameter is Z_FINISH and all output could be flushed.
-         * flush() should be called only when strictly necessary because it can
-         * degrade compression.
-         */
-        int flush(int _flush) {
-            os_flush();
-            return ::gzflush(m_fp, _flush);
-        }
-
-        /* Returns the error message for the last error which occurred on the
-         * given compressed file. errnum is set to zlib error number. If an
-         * error occurred in the file system and not in the compression library,
-         * errnum is set to Z_ERRNO and the application may consult errno
-         * to get the exact error code.
-         */
-        const char* error(int* errnum) {
-            return ::gzerror(m_fp, errnum);
-        }
-
-        gzFile fp() { return m_fp; }
-
-        ostream& os() {
-            if (m_os == 0) m_os = new ostrstream;
-            return *m_os;
-        }
-
-        void os_flush() {
-            if (m_os && m_os->pcount()>0) {
-                ostrstream* oss = new ostrstream;
-                oss->fill(m_os->fill());
-                oss->flags(m_os->flags());
-                oss->precision(m_os->precision());
-                oss->width(m_os->width());
-                ::gzwrite(m_fp, m_os->str(), m_os->pcount());
-                delete[] m_os->str(); delete m_os; m_os = oss;
-            }
-        }
-
-    private:
-        gzFile m_fp;
-        ostrstream* m_os;
-};
-
-/*
- * Binary write the given (array of) object(s) into the compressed file.
- * returns the number of uncompressed bytes actually written
- * (0 in case of error).
- */
-template <class T, class Items>
-inline int write(ozstream& zs, const T* x, Items items) {
-    return ::gzwrite(zs.fp(), (voidp) x, items*sizeof(T));
-}
-
-/*
- * Binary output with the '<' operator.
- */
-template <class T>
-inline ozstream& operator<(ozstream& zs, const T& x) {
-    ::gzwrite(zs.fp(), (voidp) &x, sizeof(T));
-    return zs;
-}
-
-inline zstringlen::zstringlen(ozstream& zs, const char* x) {
-    val.byte = 255;  val.word = ::strlen(x);
-    if (val.word < 255) zs < (val.byte = val.word);
-    else zs < val;
-}
-
-/*
- * Write length of string + the string with the '<' operator.
- */
-inline ozstream& operator<(ozstream& zs, const char* x) {
-    zstringlen len(zs, x);
-    ::gzwrite(zs.fp(), (voidp) x, len.value());
-    return zs;
-}
-
-#ifdef _MSC_VER
-inline ozstream& operator<(ozstream& zs, char* const& x) {
-    return zs < (const char*) x;
-}
-#endif
-
-/*
- * Ascii write with the << operator;
- */
-template <class T>
-inline ostream& operator<<(ozstream& zs, const T& x) {
-    zs.os_flush();
-    return zs.os() << x;
-}
-
-#endif
diff -Nbaur gcc-4.6.3/zlib/contrib/iostream2/zstream_test.cpp gcc-4.6.3-psp/zlib/contrib/iostream2/zstream_test.cpp
--- gcc-4.6.3/zlib/contrib/iostream2/zstream_test.cpp	2004-10-11 19:45:43.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/iostream2/zstream_test.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-#include "zstream.h"
-#include <math.h>
-#include <stdlib.h>
-#include <iomanip.h>
-
-void main() {
-    char h[256] = "Hello";
-    char* g = "Goodbye";
-    ozstream out("temp.gz");
-    out < "This works well" < h < g;
-    out.close();
-
-    izstream in("temp.gz"); // read it back
-    char *x = read_string(in), *y = new char[256], z[256];
-    in > y > z;
-    in.close();
-    cout << x << endl << y << endl << z << endl;
-
-    out.open("temp.gz"); // try ascii output; zcat temp.gz to see the results
-    out << setw(50) << setfill('#') << setprecision(20) << x << endl << y << endl << z << endl;
-    out << z << endl << y << endl << x << endl;
-    out << 1.1234567890123456789 << endl;
-
-    delete[] x; delete[] y;
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/iostream3/README gcc-4.6.3-psp/zlib/contrib/iostream3/README
--- gcc-4.6.3/zlib/contrib/iostream3/README	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/iostream3/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,35 +0,0 @@
-These classes provide a C++ stream interface to the zlib library. It allows you
-to do things like:
-
-  gzofstream outf("blah.gz");
-  outf << "These go into the gzip file " << 123 << endl;
-
-It does this by deriving a specialized stream buffer for gzipped files, which is
-the way Stroustrup would have done it. :->
-
-The gzifstream and gzofstream classes were originally written by Kevin Ruland
-and made available in the zlib contrib/iostream directory. The older version still
-compiles under gcc 2.xx, but not under gcc 3.xx, which sparked the development of
-this version.
-
-The new classes are as standard-compliant as possible, closely following the
-approach of the standard library's fstream classes. It compiles under gcc versions
-3.2 and 3.3, but not under gcc 2.xx. This is mainly due to changes in the standard
-library naming scheme. The new version of gzifstream/gzofstream/gzfilebuf differs
-from the previous one in the following respects:
-- added showmanyc
-- added setbuf, with support for unbuffered output via setbuf(0,0)
-- a few bug fixes of stream behavior
-- gzipped output file opened with default compression level instead of maximum level
-- setcompressionlevel()/strategy() members replaced by single setcompression()
-
-The code is provided "as is", with the permission to use, copy, modify, distribute
-and sell it for any purpose without fee.
-
-Ludwig Schwardt
-<schwardt@sun.ac.za>
-
-DSP Lab
-Electrical & Electronic Engineering Department
-University of Stellenbosch
-South Africa
diff -Nbaur gcc-4.6.3/zlib/contrib/iostream3/test.cc gcc-4.6.3-psp/zlib/contrib/iostream3/test.cc
--- gcc-4.6.3/zlib/contrib/iostream3/test.cc	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/iostream3/test.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,50 +0,0 @@
-/*
- * Test program for gzifstream and gzofstream
- *
- * by Ludwig Schwardt <schwardt@sun.ac.za>
- * original version by Kevin Ruland <kevin@rodin.wustl.edu>
- */
-
-#include "zfstream.h"
-#include <iostream>      // for cout
-
-int main() {
-
-  gzofstream outf;
-  gzifstream inf;
-  char buf[80];
-
-  outf.open("test1.txt.gz");
-  outf << "The quick brown fox sidestepped the lazy canine\n"
-       << 1.3 << "\nPlan " << 9 << std::endl;
-  outf.close();
-  std::cout << "Wrote the following message to 'test1.txt.gz' (check with zcat or zless):\n"
-            << "The quick brown fox sidestepped the lazy canine\n"
-            << 1.3 << "\nPlan " << 9 << std::endl;
-
-  std::cout << "\nReading 'test1.txt.gz' (buffered) produces:\n";
-  inf.open("test1.txt.gz");
-  while (inf.getline(buf,80,'\n')) {
-    std::cout << buf << "\t(" << inf.rdbuf()->in_avail() << " chars left in buffer)\n";
-  }
-  inf.close();
-
-  outf.rdbuf()->pubsetbuf(0,0);
-  outf.open("test2.txt.gz");
-  outf << setcompression(Z_NO_COMPRESSION)
-       << "The quick brown fox sidestepped the lazy canine\n"
-       << 1.3 << "\nPlan " << 9 << std::endl;
-  outf.close();
-  std::cout << "\nWrote the same message to 'test2.txt.gz' in uncompressed form";
-
-  std::cout << "\nReading 'test2.txt.gz' (unbuffered) produces:\n";
-  inf.rdbuf()->pubsetbuf(0,0);
-  inf.open("test2.txt.gz");
-  while (inf.getline(buf,80,'\n')) {
-    std::cout << buf << "\t(" << inf.rdbuf()->in_avail() << " chars left in buffer)\n";
-  }
-  inf.close();
-
-  return 0;
-
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/iostream3/TODO gcc-4.6.3-psp/zlib/contrib/iostream3/TODO
--- gcc-4.6.3/zlib/contrib/iostream3/TODO	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/iostream3/TODO	1970-01-01 01:00:00.000000000 +0100
@@ -1,17 +0,0 @@
-Possible upgrades to gzfilebuf:
-
-- The ability to do putback (e.g. putbackfail)
-
-- The ability to seek (zlib supports this, but could be slow/tricky)
-
-- Simultaneous read/write access (does it make sense?)
-
-- Support for ios_base::ate open mode
-
-- Locale support?
-
-- Check public interface to see which calls give problems
-  (due to dependence on library internals)
-
-- Override operator<<(ostream&, gzfilebuf*) to allow direct copying
-  of stream buffer to stream ( i.e. os << is.rdbuf(); )
diff -Nbaur gcc-4.6.3/zlib/contrib/iostream3/zfstream.cc gcc-4.6.3-psp/zlib/contrib/iostream3/zfstream.cc
--- gcc-4.6.3/zlib/contrib/iostream3/zfstream.cc	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/iostream3/zfstream.cc	1970-01-01 01:00:00.000000000 +0100
@@ -1,479 +0,0 @@
-/*
- * A C++ I/O streams interface to the zlib gz* functions
- *
- * by Ludwig Schwardt <schwardt@sun.ac.za>
- * original version by Kevin Ruland <kevin@rodin.wustl.edu>
- *
- * This version is standard-compliant and compatible with gcc 3.x.
- */
-
-#include "zfstream.h"
-#include <cstring>          // for strcpy, strcat, strlen (mode strings)
-#include <cstdio>           // for BUFSIZ
-
-// Internal buffer sizes (default and "unbuffered" versions)
-#define BIGBUFSIZE BUFSIZ
-#define SMALLBUFSIZE 1
-
-/*****************************************************************************/
-
-// Default constructor
-gzfilebuf::gzfilebuf()
-: file(NULL), io_mode(std::ios_base::openmode(0)), own_fd(false),
-  buffer(NULL), buffer_size(BIGBUFSIZE), own_buffer(true)
-{
-  // No buffers to start with
-  this->disable_buffer();
-}
-
-// Destructor
-gzfilebuf::~gzfilebuf()
-{
-  // Sync output buffer and close only if responsible for file
-  // (i.e. attached streams should be left open at this stage)
-  this->sync();
-  if (own_fd)
-    this->close();
-  // Make sure internal buffer is deallocated
-  this->disable_buffer();
-}
-
-// Set compression level and strategy
-int
-gzfilebuf::setcompression(int comp_level,
-                          int comp_strategy)
-{
-  return gzsetparams(file, comp_level, comp_strategy);
-}
-
-// Open gzipped file
-gzfilebuf*
-gzfilebuf::open(const char *name,
-                std::ios_base::openmode mode)
-{
-  // Fail if file already open
-  if (this->is_open())
-    return NULL;
-  // Don't support simultaneous read/write access (yet)
-  if ((mode & std::ios_base::in) && (mode & std::ios_base::out))
-    return NULL;
-
-  // Build mode string for gzopen and check it [27.8.1.3.2]
-  char char_mode[6] = "\0\0\0\0\0";
-  if (!this->open_mode(mode, char_mode))
-    return NULL;
-
-  // Attempt to open file
-  if ((file = gzopen(name, char_mode)) == NULL)
-    return NULL;
-
-  // On success, allocate internal buffer and set flags
-  this->enable_buffer();
-  io_mode = mode;
-  own_fd = true;
-  return this;
-}
-
-// Attach to gzipped file
-gzfilebuf*
-gzfilebuf::attach(int fd,
-                  std::ios_base::openmode mode)
-{
-  // Fail if file already open
-  if (this->is_open())
-    return NULL;
-  // Don't support simultaneous read/write access (yet)
-  if ((mode & std::ios_base::in) && (mode & std::ios_base::out))
-    return NULL;
-
-  // Build mode string for gzdopen and check it [27.8.1.3.2]
-  char char_mode[6] = "\0\0\0\0\0";
-  if (!this->open_mode(mode, char_mode))
-    return NULL;
-
-  // Attempt to attach to file
-  if ((file = gzdopen(fd, char_mode)) == NULL)
-    return NULL;
-
-  // On success, allocate internal buffer and set flags
-  this->enable_buffer();
-  io_mode = mode;
-  own_fd = false;
-  return this;
-}
-
-// Close gzipped file
-gzfilebuf*
-gzfilebuf::close()
-{
-  // Fail immediately if no file is open
-  if (!this->is_open())
-    return NULL;
-  // Assume success
-  gzfilebuf* retval = this;
-  // Attempt to sync and close gzipped file
-  if (this->sync() == -1)
-    retval = NULL;
-  if (gzclose(file) < 0)
-    retval = NULL;
-  // File is now gone anyway (postcondition [27.8.1.3.8])
-  file = NULL;
-  own_fd = false;
-  // Destroy internal buffer if it exists
-  this->disable_buffer();
-  return retval;
-}
-
-/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
-
-// Convert int open mode to mode string
-bool
-gzfilebuf::open_mode(std::ios_base::openmode mode,
-                     char* c_mode) const
-{
-  bool testb = mode & std::ios_base::binary;
-  bool testi = mode & std::ios_base::in;
-  bool testo = mode & std::ios_base::out;
-  bool testt = mode & std::ios_base::trunc;
-  bool testa = mode & std::ios_base::app;
-
-  // Check for valid flag combinations - see [27.8.1.3.2] (Table 92)
-  // Original zfstream hardcoded the compression level to maximum here...
-  // Double the time for less than 1% size improvement seems
-  // excessive though - keeping it at the default level
-  // To change back, just append "9" to the next three mode strings
-  if (!testi && testo && !testt && !testa)
-    strcpy(c_mode, "w");
-  if (!testi && testo && !testt && testa)
-    strcpy(c_mode, "a");
-  if (!testi && testo && testt && !testa)
-    strcpy(c_mode, "w");
-  if (testi && !testo && !testt && !testa)
-    strcpy(c_mode, "r");
-  // No read/write mode yet
-//  if (testi && testo && !testt && !testa)
-//    strcpy(c_mode, "r+");
-//  if (testi && testo && testt && !testa)
-//    strcpy(c_mode, "w+");
-
-  // Mode string should be empty for invalid combination of flags
-  if (strlen(c_mode) == 0)
-    return false;
-  if (testb)
-    strcat(c_mode, "b");
-  return true;
-}
-
-// Determine number of characters in internal get buffer
-std::streamsize
-gzfilebuf::showmanyc()
-{
-  // Calls to underflow will fail if file not opened for reading
-  if (!this->is_open() || !(io_mode & std::ios_base::in))
-    return -1;
-  // Make sure get area is in use
-  if (this->gptr() && (this->gptr() < this->egptr()))
-    return std::streamsize(this->egptr() - this->gptr());
-  else
-    return 0;
-}
-
-// Fill get area from gzipped file
-gzfilebuf::int_type
-gzfilebuf::underflow()
-{
-  // If something is left in the get area by chance, return it
-  // (this shouldn't normally happen, as underflow is only supposed
-  // to be called when gptr >= egptr, but it serves as error check)
-  if (this->gptr() && (this->gptr() < this->egptr()))
-    return traits_type::to_int_type(*(this->gptr()));
-
-  // If the file hasn't been opened for reading, produce error
-  if (!this->is_open() || !(io_mode & std::ios_base::in))
-    return traits_type::eof();
-
-  // Attempt to fill internal buffer from gzipped file
-  // (buffer must be guaranteed to exist...)
-  int bytes_read = gzread(file, buffer, buffer_size);
-  // Indicates error or EOF
-  if (bytes_read <= 0)
-  {
-    // Reset get area
-    this->setg(buffer, buffer, buffer);
-    return traits_type::eof();
-  }
-  // Make all bytes read from file available as get area
-  this->setg(buffer, buffer, buffer + bytes_read);
-
-  // Return next character in get area
-  return traits_type::to_int_type(*(this->gptr()));
-}
-
-// Write put area to gzipped file
-gzfilebuf::int_type
-gzfilebuf::overflow(int_type c)
-{
-  // Determine whether put area is in use
-  if (this->pbase())
-  {
-    // Double-check pointer range
-    if (this->pptr() > this->epptr() || this->pptr() < this->pbase())
-      return traits_type::eof();
-    // Add extra character to buffer if not EOF
-    if (!traits_type::eq_int_type(c, traits_type::eof()))
-    {
-      *(this->pptr()) = traits_type::to_char_type(c);
-      this->pbump(1);
-    }
-    // Number of characters to write to file
-    int bytes_to_write = this->pptr() - this->pbase();
-    // Overflow doesn't fail if nothing is to be written
-    if (bytes_to_write > 0)
-    {
-      // If the file hasn't been opened for writing, produce error
-      if (!this->is_open() || !(io_mode & std::ios_base::out))
-        return traits_type::eof();
-      // If gzipped file won't accept all bytes written to it, fail
-      if (gzwrite(file, this->pbase(), bytes_to_write) != bytes_to_write)
-        return traits_type::eof();
-      // Reset next pointer to point to pbase on success
-      this->pbump(-bytes_to_write);
-    }
-  }
-  // Write extra character to file if not EOF
-  else if (!traits_type::eq_int_type(c, traits_type::eof()))
-  {
-    // If the file hasn't been opened for writing, produce error
-    if (!this->is_open() || !(io_mode & std::ios_base::out))
-      return traits_type::eof();
-    // Impromptu char buffer (allows "unbuffered" output)
-    char_type last_char = traits_type::to_char_type(c);
-    // If gzipped file won't accept this character, fail
-    if (gzwrite(file, &last_char, 1) != 1)
-      return traits_type::eof();
-  }
-
-  // If you got here, you have succeeded (even if c was EOF)
-  // The return value should therefore be non-EOF
-  if (traits_type::eq_int_type(c, traits_type::eof()))
-    return traits_type::not_eof(c);
-  else
-    return c;
-}
-
-// Assign new buffer
-std::streambuf*
-gzfilebuf::setbuf(char_type* p,
-                  std::streamsize n)
-{
-  // First make sure stuff is sync'ed, for safety
-  if (this->sync() == -1)
-    return NULL;
-  // If buffering is turned off on purpose via setbuf(0,0), still allocate one...
-  // "Unbuffered" only really refers to put [27.8.1.4.10], while get needs at
-  // least a buffer of size 1 (very inefficient though, therefore make it bigger?)
-  // This follows from [27.5.2.4.3]/12 (gptr needs to point at something, it seems)
-  if (!p || !n)
-  {
-    // Replace existing buffer (if any) with small internal buffer
-    this->disable_buffer();
-    buffer = NULL;
-    buffer_size = 0;
-    own_buffer = true;
-    this->enable_buffer();
-  }
-  else
-  {
-    // Replace existing buffer (if any) with external buffer
-    this->disable_buffer();
-    buffer = p;
-    buffer_size = n;
-    own_buffer = false;
-    this->enable_buffer();
-  }
-  return this;
-}
-
-// Write put area to gzipped file (i.e. ensures that put area is empty)
-int
-gzfilebuf::sync()
-{
-  return traits_type::eq_int_type(this->overflow(), traits_type::eof()) ? -1 : 0;
-}
-
-/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
-
-// Allocate internal buffer
-void
-gzfilebuf::enable_buffer()
-{
-  // If internal buffer required, allocate one
-  if (own_buffer && !buffer)
-  {
-    // Check for buffered vs. "unbuffered"
-    if (buffer_size > 0)
-    {
-      // Allocate internal buffer
-      buffer = new char_type[buffer_size];
-      // Get area starts empty and will be expanded by underflow as need arises
-      this->setg(buffer, buffer, buffer);
-      // Setup entire internal buffer as put area.
-      // The one-past-end pointer actually points to the last element of the buffer,
-      // so that overflow(c) can safely add the extra character c to the sequence.
-      // These pointers remain in place for the duration of the buffer
-      this->setp(buffer, buffer + buffer_size - 1);
-    }
-    else
-    {
-      // Even in "unbuffered" case, (small?) get buffer is still required
-      buffer_size = SMALLBUFSIZE;
-      buffer = new char_type[buffer_size];
-      this->setg(buffer, buffer, buffer);
-      // "Unbuffered" means no put buffer
-      this->setp(0, 0);
-    }
-  }
-  else
-  {
-    // If buffer already allocated, reset buffer pointers just to make sure no
-    // stale chars are lying around
-    this->setg(buffer, buffer, buffer);
-    this->setp(buffer, buffer + buffer_size - 1);
-  }
-}
-
-// Destroy internal buffer
-void
-gzfilebuf::disable_buffer()
-{
-  // If internal buffer exists, deallocate it
-  if (own_buffer && buffer)
-  {
-    // Preserve unbuffered status by zeroing size
-    if (!this->pbase())
-      buffer_size = 0;
-    delete[] buffer;
-    buffer = NULL;
-    this->setg(0, 0, 0);
-    this->setp(0, 0);
-  }
-  else
-  {
-    // Reset buffer pointers to initial state if external buffer exists
-    this->setg(buffer, buffer, buffer);
-    if (buffer)
-      this->setp(buffer, buffer + buffer_size - 1);
-    else
-      this->setp(0, 0);
-  }
-}
-
-/*****************************************************************************/
-
-// Default constructor initializes stream buffer
-gzifstream::gzifstream()
-: std::istream(NULL), sb()
-{ this->init(&sb); }
-
-// Initialize stream buffer and open file
-gzifstream::gzifstream(const char* name,
-                       std::ios_base::openmode mode)
-: std::istream(NULL), sb()
-{
-  this->init(&sb);
-  this->open(name, mode);
-}
-
-// Initialize stream buffer and attach to file
-gzifstream::gzifstream(int fd,
-                       std::ios_base::openmode mode)
-: std::istream(NULL), sb()
-{
-  this->init(&sb);
-  this->attach(fd, mode);
-}
-
-// Open file and go into fail() state if unsuccessful
-void
-gzifstream::open(const char* name,
-                 std::ios_base::openmode mode)
-{
-  if (!sb.open(name, mode | std::ios_base::in))
-    this->setstate(std::ios_base::failbit);
-  else
-    this->clear();
-}
-
-// Attach to file and go into fail() state if unsuccessful
-void
-gzifstream::attach(int fd,
-                   std::ios_base::openmode mode)
-{
-  if (!sb.attach(fd, mode | std::ios_base::in))
-    this->setstate(std::ios_base::failbit);
-  else
-    this->clear();
-}
-
-// Close file
-void
-gzifstream::close()
-{
-  if (!sb.close())
-    this->setstate(std::ios_base::failbit);
-}
-
-/*****************************************************************************/
-
-// Default constructor initializes stream buffer
-gzofstream::gzofstream()
-: std::ostream(NULL), sb()
-{ this->init(&sb); }
-
-// Initialize stream buffer and open file
-gzofstream::gzofstream(const char* name,
-                       std::ios_base::openmode mode)
-: std::ostream(NULL), sb()
-{
-  this->init(&sb);
-  this->open(name, mode);
-}
-
-// Initialize stream buffer and attach to file
-gzofstream::gzofstream(int fd,
-                       std::ios_base::openmode mode)
-: std::ostream(NULL), sb()
-{
-  this->init(&sb);
-  this->attach(fd, mode);
-}
-
-// Open file and go into fail() state if unsuccessful
-void
-gzofstream::open(const char* name,
-                 std::ios_base::openmode mode)
-{
-  if (!sb.open(name, mode | std::ios_base::out))
-    this->setstate(std::ios_base::failbit);
-  else
-    this->clear();
-}
-
-// Attach to file and go into fail() state if unsuccessful
-void
-gzofstream::attach(int fd,
-                   std::ios_base::openmode mode)
-{
-  if (!sb.attach(fd, mode | std::ios_base::out))
-    this->setstate(std::ios_base::failbit);
-  else
-    this->clear();
-}
-
-// Close file
-void
-gzofstream::close()
-{
-  if (!sb.close())
-    this->setstate(std::ios_base::failbit);
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/iostream3/zfstream.h gcc-4.6.3-psp/zlib/contrib/iostream3/zfstream.h
--- gcc-4.6.3/zlib/contrib/iostream3/zfstream.h	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/iostream3/zfstream.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,466 +0,0 @@
-/*
- * A C++ I/O streams interface to the zlib gz* functions
- *
- * by Ludwig Schwardt <schwardt@sun.ac.za>
- * original version by Kevin Ruland <kevin@rodin.wustl.edu>
- *
- * This version is standard-compliant and compatible with gcc 3.x.
- */
-
-#ifndef ZFSTREAM_H
-#define ZFSTREAM_H
-
-#include <istream>  // not iostream, since we don't need cin/cout
-#include <ostream>
-#include "zlib.h"
-
-/*****************************************************************************/
-
-/**
- *  @brief  Gzipped file stream buffer class.
- *
- *  This class implements basic_filebuf for gzipped files. It doesn't yet support
- *  seeking (allowed by zlib but slow/limited), putback and read/write access
- *  (tricky). Otherwise, it attempts to be a drop-in replacement for the standard
- *  file streambuf.
-*/
-class gzfilebuf : public std::streambuf
-{
-public:
-  //  Default constructor.
-  gzfilebuf();
-
-  //  Destructor.
-  virtual
-  ~gzfilebuf();
-
-  /**
-   *  @brief  Set compression level and strategy on the fly.
-   *  @param  comp_level  Compression level (see zlib.h for allowed values)
-   *  @param  comp_strategy  Compression strategy (see zlib.h for allowed values)
-   *  @return  Z_OK on success, Z_STREAM_ERROR otherwise.
-   *
-   *  Unfortunately, these parameters cannot be modified separately, as the
-   *  previous zfstream version assumed. Since the strategy is seldom changed,
-   *  it can default and setcompression(level) then becomes like the old
-   *  setcompressionlevel(level).
-  */
-  int
-  setcompression(int comp_level,
-                 int comp_strategy = Z_DEFAULT_STRATEGY);
-
-  /**
-   *  @brief  Check if file is open.
-   *  @return  True if file is open.
-  */
-  bool
-  is_open() const { return (file != NULL); }
-
-  /**
-   *  @brief  Open gzipped file.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags.
-   *  @return  @c this on success, NULL on failure.
-  */
-  gzfilebuf*
-  open(const char* name,
-       std::ios_base::openmode mode);
-
-  /**
-   *  @brief  Attach to already open gzipped file.
-   *  @param  fd  File descriptor.
-   *  @param  mode  Open mode flags.
-   *  @return  @c this on success, NULL on failure.
-  */
-  gzfilebuf*
-  attach(int fd,
-         std::ios_base::openmode mode);
-
-  /**
-   *  @brief  Close gzipped file.
-   *  @return  @c this on success, NULL on failure.
-  */
-  gzfilebuf*
-  close();
-
-protected:
-  /**
-   *  @brief  Convert ios open mode int to mode string used by zlib.
-   *  @return  True if valid mode flag combination.
-  */
-  bool
-  open_mode(std::ios_base::openmode mode,
-            char* c_mode) const;
-
-  /**
-   *  @brief  Number of characters available in stream buffer.
-   *  @return  Number of characters.
-   *
-   *  This indicates number of characters in get area of stream buffer.
-   *  These characters can be read without accessing the gzipped file.
-  */
-  virtual std::streamsize
-  showmanyc();
-
-  /**
-   *  @brief  Fill get area from gzipped file.
-   *  @return  First character in get area on success, EOF on error.
-   *
-   *  This actually reads characters from gzipped file to stream
-   *  buffer. Always buffered.
-  */
-  virtual int_type
-  underflow();
-
-  /**
-   *  @brief  Write put area to gzipped file.
-   *  @param  c  Extra character to add to buffer contents.
-   *  @return  Non-EOF on success, EOF on error.
-   *
-   *  This actually writes characters in stream buffer to
-   *  gzipped file. With unbuffered output this is done one
-   *  character at a time.
-  */
-  virtual int_type
-  overflow(int_type c = traits_type::eof());
-
-  /**
-   *  @brief  Installs external stream buffer.
-   *  @param  p  Pointer to char buffer.
-   *  @param  n  Size of external buffer.
-   *  @return  @c this on success, NULL on failure.
-   *
-   *  Call setbuf(0,0) to enable unbuffered output.
-  */
-  virtual std::streambuf*
-  setbuf(char_type* p,
-         std::streamsize n);
-
-  /**
-   *  @brief  Flush stream buffer to file.
-   *  @return  0 on success, -1 on error.
-   *
-   *  This calls underflow(EOF) to do the job.
-  */
-  virtual int
-  sync();
-
-//
-// Some future enhancements
-//
-//  virtual int_type uflow();
-//  virtual int_type pbackfail(int_type c = traits_type::eof());
-//  virtual pos_type
-//  seekoff(off_type off,
-//          std::ios_base::seekdir way,
-//          std::ios_base::openmode mode = std::ios_base::in|std::ios_base::out);
-//  virtual pos_type
-//  seekpos(pos_type sp,
-//          std::ios_base::openmode mode = std::ios_base::in|std::ios_base::out);
-
-private:
-  /**
-   *  @brief  Allocate internal buffer.
-   *
-   *  This function is safe to call multiple times. It will ensure
-   *  that a proper internal buffer exists if it is required. If the
-   *  buffer already exists or is external, the buffer pointers will be
-   *  reset to their original state.
-  */
-  void
-  enable_buffer();
-
-  /**
-   *  @brief  Destroy internal buffer.
-   *
-   *  This function is safe to call multiple times. It will ensure
-   *  that the internal buffer is deallocated if it exists. In any
-   *  case, it will also reset the buffer pointers.
-  */
-  void
-  disable_buffer();
-
-  /**
-   *  Underlying file pointer.
-  */
-  gzFile file;
-
-  /**
-   *  Mode in which file was opened.
-  */
-  std::ios_base::openmode io_mode;
-
-  /**
-   *  @brief  True if this object owns file descriptor.
-   *
-   *  This makes the class responsible for closing the file
-   *  upon destruction.
-  */
-  bool own_fd;
-
-  /**
-   *  @brief  Stream buffer.
-   *
-   *  For simplicity this remains allocated on the free store for the
-   *  entire life span of the gzfilebuf object, unless replaced by setbuf.
-  */
-  char_type* buffer;
-
-  /**
-   *  @brief  Stream buffer size.
-   *
-   *  Defaults to system default buffer size (typically 8192 bytes).
-   *  Modified by setbuf.
-  */
-  std::streamsize buffer_size;
-
-  /**
-   *  @brief  True if this object owns stream buffer.
-   *
-   *  This makes the class responsible for deleting the buffer
-   *  upon destruction.
-  */
-  bool own_buffer;
-};
-
-/*****************************************************************************/
-
-/**
- *  @brief  Gzipped file input stream class.
- *
- *  This class implements ifstream for gzipped files. Seeking and putback
- *  is not supported yet.
-*/
-class gzifstream : public std::istream
-{
-public:
-  //  Default constructor
-  gzifstream();
-
-  /**
-   *  @brief  Construct stream on gzipped file to be opened.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags (forced to contain ios::in).
-  */
-  explicit
-  gzifstream(const char* name,
-             std::ios_base::openmode mode = std::ios_base::in);
-
-  /**
-   *  @brief  Construct stream on already open gzipped file.
-   *  @param  fd    File descriptor.
-   *  @param  mode  Open mode flags (forced to contain ios::in).
-  */
-  explicit
-  gzifstream(int fd,
-             std::ios_base::openmode mode = std::ios_base::in);
-
-  /**
-   *  Obtain underlying stream buffer.
-  */
-  gzfilebuf*
-  rdbuf() const
-  { return const_cast<gzfilebuf*>(&sb); }
-
-  /**
-   *  @brief  Check if file is open.
-   *  @return  True if file is open.
-  */
-  bool
-  is_open() { return sb.is_open(); }
-
-  /**
-   *  @brief  Open gzipped file.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags (forced to contain ios::in).
-   *
-   *  Stream will be in state good() if file opens successfully;
-   *  otherwise in state fail(). This differs from the behavior of
-   *  ifstream, which never sets the state to good() and therefore
-   *  won't allow you to reuse the stream for a second file unless
-   *  you manually clear() the state. The choice is a matter of
-   *  convenience.
-  */
-  void
-  open(const char* name,
-       std::ios_base::openmode mode = std::ios_base::in);
-
-  /**
-   *  @brief  Attach to already open gzipped file.
-   *  @param  fd  File descriptor.
-   *  @param  mode  Open mode flags (forced to contain ios::in).
-   *
-   *  Stream will be in state good() if attach succeeded; otherwise
-   *  in state fail().
-  */
-  void
-  attach(int fd,
-         std::ios_base::openmode mode = std::ios_base::in);
-
-  /**
-   *  @brief  Close gzipped file.
-   *
-   *  Stream will be in state fail() if close failed.
-  */
-  void
-  close();
-
-private:
-  /**
-   *  Underlying stream buffer.
-  */
-  gzfilebuf sb;
-};
-
-/*****************************************************************************/
-
-/**
- *  @brief  Gzipped file output stream class.
- *
- *  This class implements ofstream for gzipped files. Seeking and putback
- *  is not supported yet.
-*/
-class gzofstream : public std::ostream
-{
-public:
-  //  Default constructor
-  gzofstream();
-
-  /**
-   *  @brief  Construct stream on gzipped file to be opened.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags (forced to contain ios::out).
-  */
-  explicit
-  gzofstream(const char* name,
-             std::ios_base::openmode mode = std::ios_base::out);
-
-  /**
-   *  @brief  Construct stream on already open gzipped file.
-   *  @param  fd    File descriptor.
-   *  @param  mode  Open mode flags (forced to contain ios::out).
-  */
-  explicit
-  gzofstream(int fd,
-             std::ios_base::openmode mode = std::ios_base::out);
-
-  /**
-   *  Obtain underlying stream buffer.
-  */
-  gzfilebuf*
-  rdbuf() const
-  { return const_cast<gzfilebuf*>(&sb); }
-
-  /**
-   *  @brief  Check if file is open.
-   *  @return  True if file is open.
-  */
-  bool
-  is_open() { return sb.is_open(); }
-
-  /**
-   *  @brief  Open gzipped file.
-   *  @param  name  File name.
-   *  @param  mode  Open mode flags (forced to contain ios::out).
-   *
-   *  Stream will be in state good() if file opens successfully;
-   *  otherwise in state fail(). This differs from the behavior of
-   *  ofstream, which never sets the state to good() and therefore
-   *  won't allow you to reuse the stream for a second file unless
-   *  you manually clear() the state. The choice is a matter of
-   *  convenience.
-  */
-  void
-  open(const char* name,
-       std::ios_base::openmode mode = std::ios_base::out);
-
-  /**
-   *  @brief  Attach to already open gzipped file.
-   *  @param  fd  File descriptor.
-   *  @param  mode  Open mode flags (forced to contain ios::out).
-   *
-   *  Stream will be in state good() if attach succeeded; otherwise
-   *  in state fail().
-  */
-  void
-  attach(int fd,
-         std::ios_base::openmode mode = std::ios_base::out);
-
-  /**
-   *  @brief  Close gzipped file.
-   *
-   *  Stream will be in state fail() if close failed.
-  */
-  void
-  close();
-
-private:
-  /**
-   *  Underlying stream buffer.
-  */
-  gzfilebuf sb;
-};
-
-/*****************************************************************************/
-
-/**
- *  @brief  Gzipped file output stream manipulator class.
- *
- *  This class defines a two-argument manipulator for gzofstream. It is used
- *  as base for the setcompression(int,int) manipulator.
-*/
-template<typename T1, typename T2>
-  class gzomanip2
-  {
-  public:
-    // Allows insertor to peek at internals
-    template <typename Ta, typename Tb>
-      friend gzofstream&
-      operator<<(gzofstream&,
-                 const gzomanip2<Ta,Tb>&);
-
-    // Constructor
-    gzomanip2(gzofstream& (*f)(gzofstream&, T1, T2),
-              T1 v1,
-              T2 v2);
-  private:
-    // Underlying manipulator function
-    gzofstream&
-    (*func)(gzofstream&, T1, T2);
-
-    // Arguments for manipulator function
-    T1 val1;
-    T2 val2;
-  };
-
-/*****************************************************************************/
-
-// Manipulator function thunks through to stream buffer
-inline gzofstream&
-setcompression(gzofstream &gzs, int l, int s = Z_DEFAULT_STRATEGY)
-{
-  (gzs.rdbuf())->setcompression(l, s);
-  return gzs;
-}
-
-// Manipulator constructor stores arguments
-template<typename T1, typename T2>
-  inline
-  gzomanip2<T1,T2>::gzomanip2(gzofstream &(*f)(gzofstream &, T1, T2),
-                              T1 v1,
-                              T2 v2)
-  : func(f), val1(v1), val2(v2)
-  { }
-
-// Insertor applies underlying manipulator function to stream
-template<typename T1, typename T2>
-  inline gzofstream&
-  operator<<(gzofstream& s, const gzomanip2<T1,T2>& m)
-  { return (*m.func)(s, m.val1, m.val2); }
-
-// Insert this onto stream to simplify setting of compression level
-inline gzomanip2<int,int>
-setcompression(int l, int s = Z_DEFAULT_STRATEGY)
-{ return gzomanip2<int,int>(&setcompression, l, s); }
-
-#endif // ZFSTREAM_H
diff -Nbaur gcc-4.6.3/zlib/contrib/masm686/match.asm gcc-4.6.3-psp/zlib/contrib/masm686/match.asm
--- gcc-4.6.3/zlib/contrib/masm686/match.asm	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/masm686/match.asm	1970-01-01 01:00:00.000000000 +0100
@@ -1,413 +0,0 @@
-
-; match.asm -- Pentium-Pro optimized version of longest_match()
-;
-; Updated for zlib 1.1.3 and converted to MASM 6.1x
-; Copyright (C) 2000 Dan Higdon <hdan@kinesoft.com>
-;                    and Chuck Walbourn <chuckw@kinesoft.com>
-; Corrections by Cosmin Truta <cosmint@cs.ubbcluj.ro>
-;
-; This is free software; you can redistribute it and/or modify it
-; under the terms of the GNU General Public License.
-
-; Based on match.S
-; Written for zlib 1.1.2
-; Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>
-;
-; Modified by Gilles Vollant (2005) for add gzhead and gzindex
-
-	.686P
-	.MODEL	FLAT
-
-;===========================================================================
-; EQUATES
-;===========================================================================
-
-MAX_MATCH	EQU 258
-MIN_MATCH	EQU 3
-MIN_LOOKAHEAD	EQU (MAX_MATCH + MIN_MATCH + 1)
-MAX_MATCH_8	EQU ((MAX_MATCH + 7) AND (NOT 7))
-
-;===========================================================================
-; STRUCTURES
-;===========================================================================
-
-; This STRUCT assumes a 4-byte alignment
-
-DEFLATE_STATE	STRUCT
-ds_strm			dd ?
-ds_status		dd ?
-ds_pending_buf		dd ?
-ds_pending_buf_size	dd ?
-ds_pending_out		dd ?
-ds_pending		dd ?
-ds_wrap			dd ?
-; gzhead and gzindex are added in zlib 1.2.2.2 (see deflate.h)
-ds_gzhead               dd ?
-ds_gzindex              dd ?
-ds_data_type		db ?
-ds_method		db ?
-			db ?	; padding
-			db ?	; padding
-ds_last_flush		dd ?
-ds_w_size		dd ?	; used
-ds_w_bits		dd ?
-ds_w_mask		dd ?	; used
-ds_window		dd ?	; used
-ds_window_size		dd ?
-ds_prev			dd ?	; used
-ds_head			dd ?
-ds_ins_h		dd ?
-ds_hash_size		dd ?
-ds_hash_bits		dd ?
-ds_hash_mask		dd ?
-ds_hash_shift		dd ?
-ds_block_start		dd ?
-ds_match_length		dd ?	; used
-ds_prev_match		dd ?	; used
-ds_match_available	dd ?
-ds_strstart		dd ?	; used
-ds_match_start		dd ?	; used
-ds_lookahead		dd ?	; used
-ds_prev_length		dd ?	; used
-ds_max_chain_length	dd ?	; used
-ds_max_laxy_match	dd ?
-ds_level		dd ?
-ds_strategy		dd ?
-ds_good_match		dd ?	; used
-ds_nice_match		dd ?	; used
-
-; Don't need anymore of the struct for match
-DEFLATE_STATE	ENDS
-
-;===========================================================================
-; CODE
-;===========================================================================
-_TEXT	SEGMENT
-
-;---------------------------------------------------------------------------
-; match_init
-;---------------------------------------------------------------------------
-	ALIGN	4
-PUBLIC	_match_init
-_match_init	PROC
-	; no initialization needed
-	ret
-_match_init	ENDP
-
-;---------------------------------------------------------------------------
-; uInt longest_match(deflate_state *deflatestate, IPos curmatch)
-;---------------------------------------------------------------------------
-	ALIGN	4
-
-PUBLIC	_longest_match
-_longest_match	PROC
-
-; Since this code uses EBP for a scratch register, the stack frame must
-; be manually constructed and referenced relative to the ESP register.
-
-; Stack image
-; Variables
-chainlenwmask	=  0	; high word: current chain len
-			; low word: s->wmask
-window		=  4	; local copy of s->window
-windowbestlen	=  8	; s->window + bestlen
-scanend		= 12	; last two bytes of string
-scanstart	= 16	; first two bytes of string
-scanalign	= 20	; dword-misalignment of string
-nicematch	= 24	; a good enough match size
-bestlen		= 28	; size of best match so far
-scan		= 32	; ptr to string wanting match
-varsize		= 36	; number of bytes (also offset to last saved register)
-
-; Saved Registers (actually pushed into place)
-ebx_save	= 36
-edi_save	= 40
-esi_save	= 44
-ebp_save	= 48
-
-; Parameters
-retaddr		= 52
-deflatestate	= 56
-curmatch	= 60
-
-; Save registers that the compiler may be using
-	push	ebp
-	push	edi
-	push	esi
-	push	ebx
-
-; Allocate local variable space
-	sub	esp,varsize
-
-; Retrieve the function arguments. ecx will hold cur_match
-; throughout the entire function. edx will hold the pointer to the
-; deflate_state structure during the function's setup (before
-; entering the main loop).
-
-	mov	edx, [esp+deflatestate]
-ASSUME	edx:PTR DEFLATE_STATE
-
-	mov	ecx, [esp+curmatch]
-
-; uInt wmask = s->w_mask;
-; unsigned chain_length = s->max_chain_length;
-; if (s->prev_length >= s->good_match) {
-;     chain_length >>= 2;
-; }
-
-	mov	eax, [edx].ds_prev_length
-	mov	ebx, [edx].ds_good_match
-	cmp	eax, ebx
-	mov	eax, [edx].ds_w_mask
-	mov	ebx, [edx].ds_max_chain_length
-	jl	SHORT LastMatchGood
-	shr	ebx, 2
-LastMatchGood:
-
-; chainlen is decremented once beforehand so that the function can
-; use the sign flag instead of the zero flag for the exit test.
-; It is then shifted into the high word, to make room for the wmask
-; value, which it will always accompany.
-
-	dec	ebx
-	shl	ebx, 16
-	or	ebx, eax
-	mov	[esp+chainlenwmask], ebx
-
-; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
-
-	mov	eax, [edx].ds_nice_match
-	mov	ebx, [edx].ds_lookahead
-	cmp	ebx, eax
-	jl	SHORT LookaheadLess
-	mov	ebx, eax
-LookaheadLess:
-	mov	[esp+nicematch], ebx
-
-;/* register Bytef *scan = s->window + s->strstart;                     */
-
-	mov	esi, [edx].ds_window
-	mov	[esp+window], esi
-	mov	ebp, [edx].ds_strstart
-	lea	edi, [esi+ebp]
-	mov	[esp+scan],edi
-
-;/* Determine how many bytes the scan ptr is off from being             */
-;/* dword-aligned.                                                      */
-
-	mov	eax, edi
-	neg	eax
-	and	eax, 3
-	mov	[esp+scanalign], eax
-
-;/* IPos limit = s->strstart > (IPos)MAX_DIST(s) ?                      */
-;/*     s->strstart - (IPos)MAX_DIST(s) : NIL;                          */
-
-	mov	eax, [edx].ds_w_size
-	sub	eax, MIN_LOOKAHEAD
-	sub	ebp, eax
-	jg	SHORT LimitPositive
-	xor	ebp, ebp
-LimitPositive:
-
-;/* int best_len = s->prev_length;                                      */
-
-	mov	eax, [edx].ds_prev_length
-	mov	[esp+bestlen], eax
-
-;/* Store the sum of s->window + best_len in %esi locally, and in %esi. */
-
-	add	esi, eax
-	mov	[esp+windowbestlen], esi
-
-;/* register ush scan_start = *(ushf*)scan;                             */
-;/* register ush scan_end   = *(ushf*)(scan+best_len-1);                */
-;/* Posf *prev = s->prev;                                               */
-
-	movzx	ebx, WORD PTR[edi]
-	mov	[esp+scanstart], ebx
-	movzx	ebx, WORD PTR[eax+edi-1]
-	mov	[esp+scanend], ebx
-	mov	edi, [edx].ds_prev
-
-;/* Jump into the main loop.                                            */
-
-	mov	edx, [esp+chainlenwmask]
-	jmp	SHORT LoopEntry
-
-;/* do {
-; *     match = s->window + cur_match;
-; *     if (*(ushf*)(match+best_len-1) != scan_end ||
-; *         *(ushf*)match != scan_start) continue;
-; *     [...]
-; * } while ((cur_match = prev[cur_match & wmask]) > limit
-; *          && --chain_length != 0);
-; *
-; * Here is the inner loop of the function. The function will spend the
-; * majority of its time in this loop, and majority of that time will
-; * be spent in the first ten instructions.
-; *
-; * Within this loop:
-; * %ebx = scanend
-; * %ecx = curmatch
-; * %edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)
-; * %esi = windowbestlen - i.e., (window + bestlen)
-; * %edi = prev
-; * %ebp = limit
-; */
-
-	ALIGN	4
-LookupLoop:
-	and	ecx, edx
-	movzx	ecx, WORD PTR[edi+ecx*2]
-	cmp	ecx, ebp
-	jbe	LeaveNow
-	sub	edx, 000010000H
-	js	LeaveNow
-
-LoopEntry:
-	movzx	eax, WORD PTR[esi+ecx-1]
-	cmp	eax, ebx
-	jnz	SHORT LookupLoop
-
-	mov	eax, [esp+window]
-	movzx	eax, WORD PTR[eax+ecx]
-	cmp	eax, [esp+scanstart]
-	jnz	SHORT LookupLoop
-
-;/* Store the current value of chainlen.                                */
-
-	mov	[esp+chainlenwmask], edx
-
-;/* Point %edi to the string under scrutiny, and %esi to the string we  */
-;/* are hoping to match it up with. In actuality, %esi and %edi are     */
-;/* both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and %edx is     */
-;/* initialized to -(MAX_MATCH_8 - scanalign).                          */
-
-	mov	esi, [esp+window]
-	mov	edi, [esp+scan]
-	add	esi, ecx
-	mov	eax, [esp+scanalign]
-	mov	edx, -MAX_MATCH_8
-	lea	edi, [edi+eax+MAX_MATCH_8]
-	lea	esi, [esi+eax+MAX_MATCH_8]
-
-;/* Test the strings for equality, 8 bytes at a time. At the end,
-; * adjust %edx so that it is offset to the exact byte that mismatched.
-; *
-; * We already know at this point that the first three bytes of the
-; * strings match each other, and they can be safely passed over before
-; * starting the compare loop. So what this code does is skip over 0-3
-; * bytes, as much as necessary in order to dword-align the %edi
-; * pointer. (%esi will still be misaligned three times out of four.)
-; *
-; * It should be confessed that this loop usually does not represent
-; * much of the total running time. Replacing it with a more
-; * straightforward "rep cmpsb" would not drastically degrade
-; * performance.
-; */
-
-LoopCmps:
-	mov	eax, DWORD PTR[esi+edx]
-	xor	eax, DWORD PTR[edi+edx]
-	jnz	SHORT LeaveLoopCmps
-
-	mov	eax, DWORD PTR[esi+edx+4]
-	xor	eax, DWORD PTR[edi+edx+4]
-	jnz	SHORT LeaveLoopCmps4
-
-	add	edx, 8
-	jnz	SHORT LoopCmps
-	jmp	LenMaximum
-	ALIGN	4
-
-LeaveLoopCmps4:
-	add	edx, 4
-
-LeaveLoopCmps:
-	test	eax, 00000FFFFH
-	jnz	SHORT LenLower
-
-	add	edx, 2
-	shr	eax, 16
-
-LenLower:
-	sub	al, 1
-	adc	edx, 0
-
-;/* Calculate the length of the match. If it is longer than MAX_MATCH,  */
-;/* then automatically accept it as the best possible match and leave.  */
-
-	lea	eax, [edi+edx]
-	mov	edi, [esp+scan]
-	sub	eax, edi
-	cmp	eax, MAX_MATCH
-	jge	SHORT LenMaximum
-
-;/* If the length of the match is not longer than the best match we     */
-;/* have so far, then forget it and return to the lookup loop.          */
-
-	mov	edx, [esp+deflatestate]
-	mov	ebx, [esp+bestlen]
-	cmp	eax, ebx
-	jg	SHORT LongerMatch
-	mov	esi, [esp+windowbestlen]
-	mov	edi, [edx].ds_prev
-	mov	ebx, [esp+scanend]
-	mov	edx, [esp+chainlenwmask]
-	jmp	LookupLoop
-	ALIGN	4
-
-;/*         s->match_start = cur_match;                                 */
-;/*         best_len = len;                                             */
-;/*         if (len >= nice_match) break;                               */
-;/*         scan_end = *(ushf*)(scan+best_len-1);                       */
-
-LongerMatch:
-	mov	ebx, [esp+nicematch]
-	mov	[esp+bestlen], eax
-	mov	[edx].ds_match_start, ecx
-	cmp	eax, ebx
-	jge	SHORT LeaveNow
-	mov	esi, [esp+window]
-	add	esi, eax
-	mov	[esp+windowbestlen], esi
-	movzx	ebx, WORD PTR[edi+eax-1]
-	mov	edi, [edx].ds_prev
-	mov	[esp+scanend], ebx
-	mov	edx, [esp+chainlenwmask]
-	jmp	LookupLoop
-	ALIGN	4
-
-;/* Accept the current string, with the maximum possible length.        */
-
-LenMaximum:
-	mov	edx, [esp+deflatestate]
-	mov	DWORD PTR[esp+bestlen], MAX_MATCH
-	mov	[edx].ds_match_start, ecx
-
-;/* if ((uInt)best_len <= s->lookahead) return (uInt)best_len;          */
-;/* return s->lookahead;                                                */
-
-LeaveNow:
-	mov	edx, [esp+deflatestate]
-	mov	ebx, [esp+bestlen]
-	mov	eax, [edx].ds_lookahead
-	cmp	ebx, eax
-	jg	SHORT LookaheadRet
-	mov	eax, ebx
-LookaheadRet:
-
-; Restore the stack and return from whence we came.
-
-	add	esp, varsize
-	pop	ebx
-	pop	esi
-	pop	edi
-	pop	ebp
-	ret
-
-_longest_match	ENDP
-
-_TEXT	ENDS
-END
diff -Nbaur gcc-4.6.3/zlib/contrib/masmx64/bld_ml64.bat gcc-4.6.3-psp/zlib/contrib/masmx64/bld_ml64.bat
--- gcc-4.6.3/zlib/contrib/masmx64/bld_ml64.bat	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/masmx64/bld_ml64.bat	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-ml64.exe /Flinffasx64 /c /Zi inffasx64.asm
-ml64.exe /Flgvmat64   /c /Zi gvmat64.asm
diff -Nbaur gcc-4.6.3/zlib/contrib/masmx64/gvmat64.asm gcc-4.6.3-psp/zlib/contrib/masmx64/gvmat64.asm
--- gcc-4.6.3/zlib/contrib/masmx64/gvmat64.asm	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/masmx64/gvmat64.asm	1970-01-01 01:00:00.000000000 +0100
@@ -1,513 +0,0 @@
-;uInt longest_match_x64(
-;    deflate_state *s,
-;    IPos cur_match);                             /* current match */
-
-; gvmat64.asm -- Asm portion of the optimized longest_match for 32 bits x86
-; Copyright (C) 1995-2005 Jean-loup Gailly, Brian Raiter and Gilles Vollant.
-;
-; File written by Gilles Vollant, by converting to assembly the longest_match
-;  from Jean-loup Gailly in deflate.c of zLib and infoZip zip.
-;
-;  and by taking inspiration on asm686 with masm, optimised assembly code
-;        from Brian Raiter, written 1998
-;
-;         http://www.zlib.net
-;         http://www.winimage.com/zLibDll
-;         http://www.muppetlabs.com/~breadbox/software/assembly.html
-;
-; to compile this file for infozip Zip, I use option:
-;   ml64.exe /Flgvmat64 /c /Zi /DINFOZIP gvmat64.asm
-;
-; to compile this file for zLib, I use option:
-;   ml64.exe /Flgvmat64 /c /Zi gvmat64.asm
-; Be carrefull to adapt zlib1222add below to your version of zLib
-;   (if you use a version of zLib before 1.0.4 or after 1.2.2.2, change
-;    value of zlib1222add later)
-;
-; This file compile with Microsoft Macro Assembler (x64) for AMD64
-;
-;   ml64.exe is given with Visual Studio 2005 and Windows 2003 server DDK
-;
-;   (you can get Windows 2003 server DDK with ml64 and cl for AMD64 from
-;      http://www.microsoft.com/whdc/devtools/ddk/default.mspx for low price)
-;
-
-
-;uInt longest_match(s, cur_match)
-;    deflate_state *s;
-;    IPos cur_match;                             /* current match */
-.code
-longest_match PROC
-
-
-;LocalVarsSize   equ 88
- LocalVarsSize   equ 72
-
-; register used : rax,rbx,rcx,rdx,rsi,rdi,r8,r9,r10,r11,r12
-; free register :  r14,r15
-; register can be saved : rsp
-
- chainlenwmask   equ  rsp + 8 - LocalVarsSize    ; high word: current chain len
-                                                 ; low word: s->wmask
-;window          equ  rsp + xx - LocalVarsSize   ; local copy of s->window ; stored in r10
-;windowbestlen   equ  rsp + xx - LocalVarsSize   ; s->window + bestlen , use r10+r11
-;scanstart       equ  rsp + xx - LocalVarsSize   ; first two bytes of string ; stored in r12w
-;scanend         equ  rsp + xx - LocalVarsSize   ; last two bytes of string use ebx
-;scanalign       equ  rsp + xx - LocalVarsSize   ; dword-misalignment of string r13
-;bestlen         equ  rsp + xx - LocalVarsSize   ; size of best match so far -> r11d
-;scan            equ  rsp + xx - LocalVarsSize   ; ptr to string wanting match -> r9
-IFDEF INFOZIP
-ELSE
- nicematch       equ  (rsp + 16 - LocalVarsSize) ; a good enough match size
-ENDIF
-
-save_rdi        equ  rsp + 24 - LocalVarsSize
-save_rsi        equ  rsp + 32 - LocalVarsSize
-save_rbx        equ  rsp + 40 - LocalVarsSize
-save_rbp        equ  rsp + 48 - LocalVarsSize
-save_r12        equ  rsp + 56 - LocalVarsSize
-save_r13        equ  rsp + 64 - LocalVarsSize
-;save_r14        equ  rsp + 72 - LocalVarsSize
-;save_r15        equ  rsp + 80 - LocalVarsSize
-
-
-
-;  all the +4 offsets are due to the addition of pending_buf_size (in zlib
-;  in the deflate_state structure since the asm code was first written
-;  (if you compile with zlib 1.0.4 or older, remove the +4).
-;  Note : these value are good with a 8 bytes boundary pack structure
-
-
-    MAX_MATCH           equ     258
-    MIN_MATCH           equ     3
-    MIN_LOOKAHEAD       equ     (MAX_MATCH+MIN_MATCH+1)
-
-
-;;; Offsets for fields in the deflate_state structure. These numbers
-;;; are calculated from the definition of deflate_state, with the
-;;; assumption that the compiler will dword-align the fields. (Thus,
-;;; changing the definition of deflate_state could easily cause this
-;;; program to crash horribly, without so much as a warning at
-;;; compile time. Sigh.)
-
-;  all the +zlib1222add offsets are due to the addition of fields
-;  in zlib in the deflate_state structure since the asm code was first written
-;  (if you compile with zlib 1.0.4 or older, use "zlib1222add equ (-4)").
-;  (if you compile with zlib between 1.0.5 and 1.2.2.1, use "zlib1222add equ 0").
-;  if you compile with zlib 1.2.2.2 or later , use "zlib1222add equ 8").
-
-
-IFDEF INFOZIP
-
-_DATA   SEGMENT
-COMM    window_size:DWORD
-; WMask ; 7fff
-COMM    window:BYTE:010040H
-COMM    prev:WORD:08000H
-; MatchLen : unused
-; PrevMatch : unused
-COMM    strstart:DWORD
-COMM    match_start:DWORD
-; Lookahead : ignore
-COMM    prev_length:DWORD ; PrevLen
-COMM    max_chain_length:DWORD
-COMM    good_match:DWORD
-COMM    nice_match:DWORD
-prev_ad equ OFFSET prev
-window_ad equ OFFSET window
-nicematch equ nice_match
-_DATA ENDS
-WMask equ 07fffh
-
-ELSE
-
-  IFNDEF zlib1222add
-    zlib1222add equ 8
-  ENDIF
-dsWSize         equ 56+zlib1222add+(zlib1222add/2)
-dsWMask         equ 64+zlib1222add+(zlib1222add/2)
-dsWindow        equ 72+zlib1222add
-dsPrev          equ 88+zlib1222add
-dsMatchLen      equ 128+zlib1222add
-dsPrevMatch     equ 132+zlib1222add
-dsStrStart      equ 140+zlib1222add
-dsMatchStart    equ 144+zlib1222add
-dsLookahead     equ 148+zlib1222add
-dsPrevLen       equ 152+zlib1222add
-dsMaxChainLen   equ 156+zlib1222add
-dsGoodMatch     equ 172+zlib1222add
-dsNiceMatch     equ 176+zlib1222add
-
-window_size     equ [ rcx + dsWSize]
-WMask           equ [ rcx + dsWMask]
-window_ad       equ [ rcx + dsWindow]
-prev_ad         equ [ rcx + dsPrev]
-strstart        equ [ rcx + dsStrStart]
-match_start     equ [ rcx + dsMatchStart]
-Lookahead       equ [ rcx + dsLookahead] ; 0ffffffffh on infozip
-prev_length     equ [ rcx + dsPrevLen]
-max_chain_length equ [ rcx + dsMaxChainLen]
-good_match      equ [ rcx + dsGoodMatch]
-nice_match      equ [ rcx + dsNiceMatch]
-ENDIF
-
-; parameter 1 in r8(deflate state s), param 2 in rdx (cur match)
-
-; see http://weblogs.asp.net/oldnewthing/archive/2004/01/14/58579.aspx and
-; http://msdn.microsoft.com/library/en-us/kmarch/hh/kmarch/64bitAMD_8e951dd2-ee77-4728-8702-55ce4b5dd24a.xml.asp
-;
-; All registers must be preserved across the call, except for
-;   rax, rcx, rdx, r8, r9, r10, and r11, which are scratch.
-
-
-
-;;; Save registers that the compiler may be using, and adjust esp to
-;;; make room for our stack frame.
-
-
-;;; Retrieve the function arguments. r8d will hold cur_match
-;;; throughout the entire function. edx will hold the pointer to the
-;;; deflate_state structure during the function's setup (before
-;;; entering the main loop.
-
-; parameter 1 in rcx (deflate_state* s), param 2 in edx -> r8 (cur match)
-
-; this clear high 32 bits of r8, which can be garbage in both r8 and rdx
-
-        mov [save_rdi],rdi
-        mov [save_rsi],rsi
-        mov [save_rbx],rbx
-        mov [save_rbp],rbp
-IFDEF INFOZIP
-        mov r8d,ecx
-ELSE
-        mov r8d,edx
-ENDIF
-        mov [save_r12],r12
-        mov [save_r13],r13
-;        mov [save_r14],r14
-;        mov [save_r15],r15
-
-
-;;; uInt wmask = s->w_mask;
-;;; unsigned chain_length = s->max_chain_length;
-;;; if (s->prev_length >= s->good_match) {
-;;;     chain_length >>= 2;
-;;; }
-
-        mov edi, prev_length
-        mov esi, good_match
-        mov eax, WMask
-        mov ebx, max_chain_length
-        cmp edi, esi
-        jl  LastMatchGood
-        shr ebx, 2
-LastMatchGood:
-
-;;; chainlen is decremented once beforehand so that the function can
-;;; use the sign flag instead of the zero flag for the exit test.
-;;; It is then shifted into the high word, to make room for the wmask
-;;; value, which it will always accompany.
-
-        dec ebx
-        shl ebx, 16
-        or  ebx, eax
-
-;;; on zlib only
-;;; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
-
-IFDEF INFOZIP
-        mov [chainlenwmask], ebx
-; on infozip nice_match = [nice_match]
-ELSE
-        mov eax, nice_match
-        mov [chainlenwmask], ebx
-        mov r10d, Lookahead
-        cmp r10d, eax
-        cmovnl r10d, eax
-        mov [nicematch],r10d
-ENDIF
-
-;;; register Bytef *scan = s->window + s->strstart;
-        mov r10, window_ad
-        mov ebp, strstart
-        lea r13, [r10 + rbp]
-
-;;; Determine how many bytes the scan ptr is off from being
-;;; dword-aligned.
-
-         mov r9,r13
-         neg r13
-         and r13,3
-
-;;; IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
-;;;     s->strstart - (IPos)MAX_DIST(s) : NIL;
-IFDEF INFOZIP
-        mov eax,07efah ; MAX_DIST = (WSIZE-MIN_LOOKAHEAD) (0x8000-(3+8+1))
-ELSE
-        mov eax, window_size
-        sub eax, MIN_LOOKAHEAD
-ENDIF
-        xor edi,edi
-        sub ebp, eax
-
-        mov r11d, prev_length
-
-        cmovng ebp,edi
-
-;;; int best_len = s->prev_length;
-
-
-;;; Store the sum of s->window + best_len in esi locally, and in esi.
-
-       lea  rsi,[r10+r11]
-
-;;; register ush scan_start = *(ushf*)scan;
-;;; register ush scan_end   = *(ushf*)(scan+best_len-1);
-;;; Posf *prev = s->prev;
-
-        movzx r12d,word ptr [r9]
-        movzx ebx, word ptr [r9 + r11 - 1]
-
-        mov rdi, prev_ad
-
-;;; Jump into the main loop.
-
-        mov edx, [chainlenwmask]
-
-        cmp bx,word ptr [rsi + r8 - 1]
-        jz  LookupLoopIsZero
-
-LookupLoop1:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-        jbe LeaveNow
-        sub edx, 00010000h
-        js  LeaveNow
-
-LoopEntry1:
-        cmp bx,word ptr [rsi + r8 - 1]
-        jz  LookupLoopIsZero
-
-LookupLoop2:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-        jbe LeaveNow
-        sub edx, 00010000h
-        js  LeaveNow
-
-LoopEntry2:
-        cmp bx,word ptr [rsi + r8 - 1]
-        jz  LookupLoopIsZero
-
-LookupLoop4:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-        jbe LeaveNow
-        sub edx, 00010000h
-        js  LeaveNow
-
-LoopEntry4:
-
-        cmp bx,word ptr [rsi + r8 - 1]
-        jnz LookupLoop1
-        jmp LookupLoopIsZero
-
-
-;;; do {
-;;;     match = s->window + cur_match;
-;;;     if (*(ushf*)(match+best_len-1) != scan_end ||
-;;;         *(ushf*)match != scan_start) continue;
-;;;     [...]
-;;; } while ((cur_match = prev[cur_match & wmask]) > limit
-;;;          && --chain_length != 0);
-;;;
-;;; Here is the inner loop of the function. The function will spend the
-;;; majority of its time in this loop, and majority of that time will
-;;; be spent in the first ten instructions.
-;;;
-;;; Within this loop:
-;;; ebx = scanend
-;;; r8d = curmatch
-;;; edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)
-;;; esi = windowbestlen - i.e., (window + bestlen)
-;;; edi = prev
-;;; ebp = limit
-
-LookupLoop:
-        and r8d, edx
-
-        movzx   r8d, word ptr [rdi + r8*2]
-        cmp r8d, ebp
-        jbe LeaveNow
-        sub edx, 00010000h
-        js  LeaveNow
-
-LoopEntry:
-
-        cmp bx,word ptr [rsi + r8 - 1]
-        jnz LookupLoop1
-LookupLoopIsZero:
-        cmp     r12w, word ptr [r10 + r8]
-        jnz LookupLoop1
-
-
-;;; Store the current value of chainlen.
-        mov [chainlenwmask], edx
-
-;;; Point edi to the string under scrutiny, and esi to the string we
-;;; are hoping to match it up with. In actuality, esi and edi are
-;;; both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and edx is
-;;; initialized to -(MAX_MATCH_8 - scanalign).
-
-        lea rsi,[r8+r10]
-        mov rdx, 0fffffffffffffef8h; -(MAX_MATCH_8)
-        lea rsi, [rsi + r13 + 0108h] ;MAX_MATCH_8]
-        lea rdi, [r9 + r13 + 0108h] ;MAX_MATCH_8]
-
-        prefetcht1 [rsi+rdx]
-        prefetcht1 [rdi+rdx]
-
-
-;;; Test the strings for equality, 8 bytes at a time. At the end,
-;;; adjust rdx so that it is offset to the exact byte that mismatched.
-;;;
-;;; We already know at this point that the first three bytes of the
-;;; strings match each other, and they can be safely passed over before
-;;; starting the compare loop. So what this code does is skip over 0-3
-;;; bytes, as much as necessary in order to dword-align the edi
-;;; pointer. (rsi will still be misaligned three times out of four.)
-;;;
-;;; It should be confessed that this loop usually does not represent
-;;; much of the total running time. Replacing it with a more
-;;; straightforward "rep cmpsb" would not drastically degrade
-;;; performance.
-
-
-LoopCmps:
-        mov rax, [rsi + rdx]
-        xor rax, [rdi + rdx]
-        jnz LeaveLoopCmps
-
-        mov rax, [rsi + rdx + 8]
-        xor rax, [rdi + rdx + 8]
-        jnz LeaveLoopCmps8
-
-
-        mov rax, [rsi + rdx + 8+8]
-        xor rax, [rdi + rdx + 8+8]
-        jnz LeaveLoopCmps16
-
-        add rdx,8+8+8
-
-        jmp short LoopCmps
-LeaveLoopCmps16: add rdx,8
-LeaveLoopCmps8: add rdx,8
-LeaveLoopCmps:
-
-        test    eax, 0000FFFFh
-        jnz LenLower
-
-        test eax,0ffffffffh
-
-        jnz LenLower32
-
-        add rdx,4
-        shr rax,32
-        or ax,ax
-        jnz LenLower
-
-LenLower32:
-        shr eax,16
-        add rdx,2
-LenLower:   sub al, 1
-        adc rdx, 0
-;;; Calculate the length of the match. If it is longer than MAX_MATCH,
-;;; then automatically accept it as the best possible match and leave.
-
-        lea rax, [rdi + rdx]
-        sub rax, r9
-        cmp eax, MAX_MATCH
-        jge LenMaximum
-
-;;; If the length of the match is not longer than the best match we
-;;; have so far, then forget it and return to the lookup loop.
-;///////////////////////////////////
-
-        cmp eax, r11d
-        jg  LongerMatch
-
-        lea rsi,[r10+r11]
-
-        mov rdi, prev_ad
-        mov edx, [chainlenwmask]
-        jmp LookupLoop
-
-;;;         s->match_start = cur_match;
-;;;         best_len = len;
-;;;         if (len >= nice_match) break;
-;;;         scan_end = *(ushf*)(scan+best_len-1);
-
-LongerMatch:
-        mov r11d, eax
-        mov match_start, r8d
-        cmp eax, [nicematch]
-        jge LeaveNow
-
-        lea rsi,[r10+rax]
-
-        movzx   ebx, word ptr [r9 + rax - 1]
-        mov rdi, prev_ad
-        mov edx, [chainlenwmask]
-        jmp LookupLoop
-
-;;; Accept the current string, with the maximum possible length.
-
-LenMaximum:
-        mov r11d,MAX_MATCH
-        mov match_start, r8d
-
-;;; if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
-;;; return s->lookahead;
-
-LeaveNow:
-IFDEF INFOZIP
-        mov eax,r11d
-ELSE
-        mov eax, Lookahead
-        cmp r11d, eax
-        cmovng eax, r11d
-ENDIF
-
-;;; Restore the stack and return from whence we came.
-
-
-        mov rsi,[save_rsi]
-        mov rdi,[save_rdi]
-        mov rbx,[save_rbx]
-        mov rbp,[save_rbp]
-        mov r12,[save_r12]
-        mov r13,[save_r13]
-;        mov r14,[save_r14]
-;        mov r15,[save_r15]
-
-
-        ret 0
-; please don't remove this string !
-; Your can freely use gvmat64 in any free or commercial app
-; but it is far better don't remove the string in the binary!
-    db     0dh,0ah,"asm686 with masm, optimised assembly code from Brian Raiter, written 1998, converted to amd 64 by Gilles Vollant 2005",0dh,0ah,0
-longest_match   ENDP
-
-match_init PROC
-  ret 0
-match_init ENDP
-
-
-END
diff -Nbaur gcc-4.6.3/zlib/contrib/masmx64/gvmat64.obj gcc-4.6.3-psp/zlib/contrib/masmx64/gvmat64.obj
--- gcc-4.6.3/zlib/contrib/masmx64/gvmat64.obj	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/masmx64/gvmat64.obj	1970-01-01 01:00:00.000000000 +0100
@@ -1,28 +0,0 @@
-d fB         .text                              P`.data                               @ P.debug$S                  ,   @ B.debug$T        <                 @ BH|$Ht$H\$Hl$DLd$Ll$      AL   ;|   \$D   D;DMDT$LQP   Nl MIIAD-  3+D   NK4E!C\Hy`T$fA;\0   D#FGD;n     b  fA;\0tuD#FGD;I     =  fA;\0tPD#FGD;$       fA;\0u)D#FGD;         fA;\0ffG;$[T$K4HI5  K  2:H2H3:u&HD2H3D:uHD2H3D:uHHH  uuHH fuH,H H:I+=  }=A;K4Hy`T$&DD   ;D$}$J4B\Hy`T$A  D      D;ANHt$H|$H\$Hl$Ld$Ll$
-asm686 with masm, optimised assembly code from Brian Raiter, written 1998, converted to amd 64 by Gilles Vollant 2005
-       *    X:\modifzLib\contrib\masmx64\gvmat64.asm            T-`%*+U                              (             
-                         !     '     -     0     6     8     :     =     ?     B     D     J     N     U     X     \     a     e     k     p     s     v     z     }                                                                                 #    $    '    )    *    +    ,    -    0    1    4    6   7   8   9   :   >   ? !  @ #  X &  Z +  [ .  \ 4  ] :  ^ @  b F  c L  e Q  f W  j [  q _  r i  s q  t y  v }  w                                                                                                                                      $   *   1   7   :   >   C   H   M   R   W   \              /     X:\modifzLib\contrib\masmx64\gvmat64.obj 4              vMicrosoft (R) Macro Assembler   0                                match_init   3                             longest_match         LastMatchGood         LookupLoop1         LoopEntry1         LookupLoop2         LoopEntry2         LookupLoop4         LoopEntry4         LookupLoop         LoopEntry         LookupLoopIsZero         LoopCmps         LeaveLoopCmps16         LeaveLoopCmps8         LeaveLoopCmps         LenLower32         LenLower         LongerMatch         LenMaximum         LeaveNow     `       d      
-   
-      
-   
-   	      	   
-            
-            
-            
-            
- +      /     
- A      E     
- X      \     
- n      r     
-            
-            
-            
-            
-            
-            
-            
- -      1     
- A      E     
- X      \     
- n      r     
-                                      @comp.idv}    .text                          .data                            .debug$S         ,             .debug$T       <                                             $$000000               =           +              7              B              N              Y              e             p   #          {   @             L      LoopCmps                                                          LenLower                          $      LeaveNow1         longest_match match_init LastMatchGood LookupLoop1 LoopEntry1 LookupLoop2 LoopEntry2 LookupLoop4 LoopEntry4 LookupLoop LoopEntry LookupLoopIsZero LeaveLoopCmps16 LeaveLoopCmps8 LeaveLoopCmps LenLower32 LongerMatch LenMaximum 
\ No newline at end of file
diff -Nbaur gcc-4.6.3/zlib/contrib/masmx64/inffas8664.c gcc-4.6.3-psp/zlib/contrib/masmx64/inffas8664.c
--- gcc-4.6.3/zlib/contrib/masmx64/inffas8664.c	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/masmx64/inffas8664.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,186 +0,0 @@
-/* inffas8664.c is a hand tuned assembler version of inffast.c - fast decoding
- * version for AMD64 on Windows using Microsoft C compiler
- *
- * Copyright (C) 1995-2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * Copyright (C) 2003 Chris Anderson <christop@charm.net>
- * Please use the copyright conditions above.
- *
- * 2005 - Adaptation to Microsoft C Compiler for AMD64 by Gilles Vollant
- *
- * inffas8664.c call function inffas8664fnc in inffasx64.asm
- *  inffasx64.asm is automatically convert from AMD64 portion of inffas86.c
- *
- * Dec-29-2003 -- I added AMD64 inflate asm support.  This version is also
- * slightly quicker on x86 systems because, instead of using rep movsb to copy
- * data, it uses rep movsw, which moves data in 2-byte chunks instead of single
- * bytes.  I've tested the AMD64 code on a Fedora Core 1 + the x86_64 updates
- * from http://fedora.linux.duke.edu/fc1_x86_64
- * which is running on an Athlon 64 3000+ / Gigabyte GA-K8VT800M system with
- * 1GB ram.  The 64-bit version is about 4% faster than the 32-bit version,
- * when decompressing mozilla-source-1.3.tar.gz.
- *
- * Mar-13-2003 -- Most of this is derived from inffast.S which is derived from
- * the gcc -S output of zlib-1.2.0/inffast.c.  Zlib-1.2.0 is in beta release at
- * the moment.  I have successfully compiled and tested this code with gcc2.96,
- * gcc3.2, icc5.0, msvc6.0.  It is very close to the speed of inffast.S
- * compiled with gcc -DNO_MMX, but inffast.S is still faster on the P3 with MMX
- * enabled.  I will attempt to merge the MMX code into this version.  Newer
- * versions of this and inffast.S can be found at
- * http://www.eetbeetee.com/zlib/ and http://www.charm.net/~christop/zlib/
- *
- */
-
-#include <stdio.h>
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-
-/* Mark Adler's comments from inffast.c: */
-
-/*
-   Decode literal, length, and distance codes and write out the resulting
-   literal and match bytes until either not enough input or output is
-   available, an end-of-block is encountered, or a data error is encountered.
-   When large enough input and output buffers are supplied to inflate(), for
-   example, a 16K input buffer and a 64K output buffer, more than 95% of the
-   inflate execution time is spent in this routine.
-
-   Entry assumptions:
-
-        state->mode == LEN
-        strm->avail_in >= 6
-        strm->avail_out >= 258
-        start >= strm->avail_out
-        state->bits < 8
-
-   On return, state->mode is one of:
-
-        LEN -- ran out of enough output space or enough available input
-        TYPE -- reached end of block code, inflate() to interpret next block
-        BAD -- error in block data
-
-   Notes:
-
-    - The maximum input bits used by a length/distance pair is 15 bits for the
-      length code, 5 bits for the length extra, 15 bits for the distance code,
-      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
-      Therefore if strm->avail_in >= 6, then there is enough input to avoid
-      checking for available input while decoding.
-
-    - The maximum bytes that a single length/distance pair can output is 258
-      bytes, which is the maximum length that can be coded.  inflate_fast()
-      requires strm->avail_out >= 258 for each loop to avoid checking for
-      output space.
- */
-
-
-
-    typedef struct inffast_ar {
-/* 64   32                               x86  x86_64 */
-/* ar offset                              register */
-/*  0    0 */ void *esp;                /* esp save */
-/*  8    4 */ void *ebp;                /* ebp save */
-/* 16    8 */ unsigned char FAR *in;    /* esi rsi  local strm->next_in */
-/* 24   12 */ unsigned char FAR *last;  /*     r9   while in < last */
-/* 32   16 */ unsigned char FAR *out;   /* edi rdi  local strm->next_out */
-/* 40   20 */ unsigned char FAR *beg;   /*          inflate()'s init next_out */
-/* 48   24 */ unsigned char FAR *end;   /*     r10  while out < end */
-/* 56   28 */ unsigned char FAR *window;/*          size of window, wsize!=0 */
-/* 64   32 */ code const FAR *lcode;    /* ebp rbp  local strm->lencode */
-/* 72   36 */ code const FAR *dcode;    /*     r11  local strm->distcode */
-/* 80   40 */ size_t /*unsigned long */hold;       /* edx rdx  local strm->hold */
-/* 88   44 */ unsigned bits;            /* ebx rbx  local strm->bits */
-/* 92   48 */ unsigned wsize;           /*          window size */
-/* 96   52 */ unsigned write;           /*          window write index */
-/*100   56 */ unsigned lmask;           /*     r12  mask for lcode */
-/*104   60 */ unsigned dmask;           /*     r13  mask for dcode */
-/*108   64 */ unsigned len;             /*     r14  match length */
-/*112   68 */ unsigned dist;            /*     r15  match distance */
-/*116   72 */ unsigned status;          /*          set when state chng*/
-    } type_ar;
-#ifdef ASMINF
-
-void inflate_fast(strm, start)
-z_streamp strm;
-unsigned start;         /* inflate()'s starting value for strm->avail_out */
-{
-    struct inflate_state FAR *state;
-    type_ar ar;
-    void inffas8664fnc(struct inffast_ar * par);
-
-    
-
-#if (defined( __GNUC__ ) && defined( __amd64__ ) && ! defined( __i386 )) || (defined(_MSC_VER) && defined(_M_AMD64))
-#define PAD_AVAIL_IN 6
-#define PAD_AVAIL_OUT 258    
-#else
-#define PAD_AVAIL_IN 5
-#define PAD_AVAIL_OUT 257
-#endif
-
-    /* copy state to local variables */
-    state = (struct inflate_state FAR *)strm->state;
-
-    ar.in = strm->next_in;
-    ar.last = ar.in + (strm->avail_in - PAD_AVAIL_IN);
-    ar.out = strm->next_out;
-    ar.beg = ar.out - (start - strm->avail_out);
-    ar.end = ar.out + (strm->avail_out - PAD_AVAIL_OUT);
-    ar.wsize = state->wsize;
-    ar.write = state->write;
-    ar.window = state->window;
-    ar.hold = state->hold;
-    ar.bits = state->bits;
-    ar.lcode = state->lencode;
-    ar.dcode = state->distcode;
-    ar.lmask = (1U << state->lenbits) - 1;
-    ar.dmask = (1U << state->distbits) - 1;
-
-    /* decode literals and length/distances until end-of-block or not enough
-       input data or output space */
-
-    /* align in on 1/2 hold size boundary */
-    while (((size_t)(void *)ar.in & (sizeof(ar.hold) / 2 - 1)) != 0) {
-        ar.hold += (unsigned long)*ar.in++ << ar.bits;
-        ar.bits += 8;
-    }
-
-    inffas8664fnc(&ar);
-
-    if (ar.status > 1) {
-        if (ar.status == 2)
-            strm->msg = "invalid literal/length code";
-        else if (ar.status == 3)
-            strm->msg = "invalid distance code";
-        else
-            strm->msg = "invalid distance too far back";
-        state->mode = BAD;
-    }
-    else if ( ar.status == 1 ) {
-        state->mode = TYPE;
-    }
-
-    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
-    ar.len = ar.bits >> 3;
-    ar.in -= ar.len;
-    ar.bits -= ar.len << 3;
-    ar.hold &= (1U << ar.bits) - 1;
-
-    /* update state and return */
-    strm->next_in = ar.in;
-    strm->next_out = ar.out;
-    strm->avail_in = (unsigned)(ar.in < ar.last ?
-                                PAD_AVAIL_IN + (ar.last - ar.in) :
-                                PAD_AVAIL_IN - (ar.in - ar.last));
-    strm->avail_out = (unsigned)(ar.out < ar.end ?
-                                 PAD_AVAIL_OUT + (ar.end - ar.out) :
-                                 PAD_AVAIL_OUT - (ar.out - ar.end));
-    state->hold = (unsigned long)ar.hold;
-    state->bits = ar.bits;
-    return;
-}
-
-#endif
diff -Nbaur gcc-4.6.3/zlib/contrib/masmx64/inffasx64.asm gcc-4.6.3-psp/zlib/contrib/masmx64/inffasx64.asm
--- gcc-4.6.3/zlib/contrib/masmx64/inffasx64.asm	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/masmx64/inffasx64.asm	1970-01-01 01:00:00.000000000 +0100
@@ -1,392 +0,0 @@
-; inffasx64.asm is a hand tuned assembler version of inffast.c - fast decoding
-; version for AMD64 on Windows using Microsoft C compiler
-;
-; inffasx64.asm is automatically convert from AMD64 portion of inffas86.c
-; inffasx64.asm is called by inffas8664.c, which contain more info.
-
-
-; to compile this file, I use option
-;   ml64.exe /Flinffasx64 /c /Zi inffasx64.asm
-;   with Microsoft Macro Assembler (x64) for AMD64
-;
-;   ml64.exe is given with Visual Studio 2005, Windows 2003 server DDK
-;
-;   (you can get Windows 2003 server DDK with ml64 and cl.exe for AMD64 from 
-;      http://www.microsoft.com/whdc/devtools/ddk/default.mspx for low price)
-;
-
-.code
-inffas8664fnc PROC
-
-; see http://weblogs.asp.net/oldnewthing/archive/2004/01/14/58579.aspx and
-; http://msdn.microsoft.com/library/en-us/kmarch/hh/kmarch/64bitAMD_8e951dd2-ee77-4728-8702-55ce4b5dd24a.xml.asp
-;
-; All registers must be preserved across the call, except for
-;   rax, rcx, rdx, r8, r-9, r10, and r11, which are scratch.
-
-
-	mov [rsp-8],rsi
-	mov [rsp-16],rdi
-	mov [rsp-24],r12
-	mov [rsp-32],r13
-	mov [rsp-40],r14
-	mov [rsp-48],r15
-	mov [rsp-56],rbx
-
-	mov rax,rcx
-
-	mov	[rax+8], rbp       ; /* save regs rbp and rsp */
-	mov	[rax], rsp
-
-	mov	rsp, rax          ; /* make rsp point to &ar */
-
-	mov	rsi, [rsp+16]      ; /* rsi  = in */
-	mov	rdi, [rsp+32]      ; /* rdi  = out */
-	mov	r9, [rsp+24]       ; /* r9   = last */
-	mov	r10, [rsp+48]      ; /* r10  = end */
-	mov	rbp, [rsp+64]      ; /* rbp  = lcode */
-	mov	r11, [rsp+72]      ; /* r11  = dcode */
-	mov	rdx, [rsp+80]      ; /* rdx  = hold */
-	mov	ebx, [rsp+88]      ; /* ebx  = bits */
-	mov	r12d, [rsp+100]    ; /* r12d = lmask */
-	mov	r13d, [rsp+104]    ; /* r13d = dmask */
-                                          ; /* r14d = len */
-                                          ; /* r15d = dist */
-
-
-	cld
-	cmp	r10, rdi
-	je	L_one_time           ; /* if only one decode left */
-	cmp	r9, rsi
-
-    jne L_do_loop
-
-
-L_one_time:
-	mov	r8, r12           ; /* r8 = lmask */
-	cmp	bl, 32
-	ja	L_get_length_code_one_time
-
-	lodsd                         ; /* eax = *(uint *)in++ */
-	mov	cl, bl            ; /* cl = bits, needs it for shifting */
-	add	bl, 32             ; /* bits += 32 */
-	shl	rax, cl
-	or	rdx, rax          ; /* hold |= *((uint *)in)++ << bits */
-	jmp	L_get_length_code_one_time
-
-ALIGN 4
-L_while_test:
-	cmp	r10, rdi
-	jbe	L_break_loop
-	cmp	r9, rsi
-	jbe	L_break_loop
-
-L_do_loop:
-	mov	r8, r12           ; /* r8 = lmask */
-	cmp	bl, 32
-	ja	L_get_length_code    ; /* if (32 < bits) */
-
-	lodsd                         ; /* eax = *(uint *)in++ */
-	mov	cl, bl            ; /* cl = bits, needs it for shifting */
-	add	bl, 32             ; /* bits += 32 */
-	shl	rax, cl
-	or	rdx, rax          ; /* hold |= *((uint *)in)++ << bits */
-
-L_get_length_code:
-	and	r8, rdx            ; /* r8 &= hold */
-	mov	eax, [rbp+r8*4]  ; /* eax = lcode[hold & lmask] */
-
-	mov	cl, ah            ; /* cl = this.bits */
-	sub	bl, ah            ; /* bits -= this.bits */
-	shr	rdx, cl           ; /* hold >>= this.bits */
-
-	test	al, al
-	jnz	L_test_for_length_base ; /* if (op != 0) 45.7% */
-
-	mov	r8, r12            ; /* r8 = lmask */
-	shr	eax, 16            ; /* output this.val char */
-	stosb
-
-L_get_length_code_one_time:
-	and	r8, rdx            ; /* r8 &= hold */
-	mov	eax, [rbp+r8*4] ; /* eax = lcode[hold & lmask] */
-
-L_dolen:
-	mov	cl, ah            ; /* cl = this.bits */
-	sub	bl, ah            ; /* bits -= this.bits */
-	shr	rdx, cl           ; /* hold >>= this.bits */
-
-	test	al, al
-	jnz	L_test_for_length_base ; /* if (op != 0) 45.7% */
-
-	shr	eax, 16            ; /* output this.val char */
-	stosb
-	jmp	L_while_test
-
-ALIGN 4
-L_test_for_length_base:
-	mov	r14d, eax         ; /* len = this */
-	shr	r14d, 16           ; /* len = this.val */
-	mov	cl, al
-
-	test	al, 16
-	jz	L_test_for_second_level_length ; /* if ((op & 16) == 0) 8% */
-	and	cl, 15             ; /* op &= 15 */
-	jz	L_decode_distance    ; /* if (!op) */
-
-L_add_bits_to_len:
-	sub	bl, cl
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax
-	and	eax, edx          ; /* eax &= hold */
-	shr	rdx, cl
-	add	r14d, eax         ; /* len += hold & mask[op] */
-
-L_decode_distance:
-	mov	r8, r13           ; /* r8 = dmask */
-	cmp	bl, 32
-	ja	L_get_distance_code  ; /* if (32 < bits) */
-
-	lodsd                         ; /* eax = *(uint *)in++ */
-	mov	cl, bl            ; /* cl = bits, needs it for shifting */
-	add	bl, 32             ; /* bits += 32 */
-	shl	rax, cl
-	or	rdx, rax          ; /* hold |= *((uint *)in)++ << bits */
-
-L_get_distance_code:
-	and	r8, rdx           ; /* r8 &= hold */
-	mov	eax, [r11+r8*4] ; /* eax = dcode[hold & dmask] */
-
-L_dodist:
-	mov	r15d, eax         ; /* dist = this */
-	shr	r15d, 16           ; /* dist = this.val */
-	mov	cl, ah
-	sub	bl, ah            ; /* bits -= this.bits */
-	shr	rdx, cl           ; /* hold >>= this.bits */
-	mov	cl, al            ; /* cl = this.op */
-
-	test	al, 16             ; /* if ((op & 16) == 0) */
-	jz	L_test_for_second_level_dist
-	and	cl, 15             ; /* op &= 15 */
-	jz	L_check_dist_one
-
-L_add_bits_to_dist:
-	sub	bl, cl
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax                 ; /* (1 << op) - 1 */
-	and	eax, edx          ; /* eax &= hold */
-	shr	rdx, cl
-	add	r15d, eax         ; /* dist += hold & ((1 << op) - 1) */
-
-L_check_window:
-	mov	r8, rsi           ; /* save in so from can use it's reg */
-	mov	rax, rdi
-	sub	rax, [rsp+40]      ; /* nbytes = out - beg */
-
-	cmp	eax, r15d
-	jb	L_clip_window        ; /* if (dist > nbytes) 4.2% */
-
-	mov	ecx, r14d         ; /* ecx = len */
-	mov	rsi, rdi
-	sub	rsi, r15          ; /* from = out - dist */
-
-	sar	ecx, 1
-	jnc	L_copy_two           ; /* if len % 2 == 0 */
-
-	rep     movsw
-	mov	al, [rsi]
-	mov	[rdi], al
-	inc	rdi
-
-	mov	rsi, r8           ; /* move in back to %rsi, toss from */
-	jmp	L_while_test
-
-L_copy_two:
-	rep     movsw
-	mov	rsi, r8           ; /* move in back to %rsi, toss from */
-	jmp	L_while_test
-
-ALIGN 4
-L_check_dist_one:
-	cmp	r15d, 1            ; /* if dist 1, is a memset */
-	jne	L_check_window
-	cmp	[rsp+40], rdi      ; /* if out == beg, outside window */
-	je	L_check_window
-
-	mov	ecx, r14d         ; /* ecx = len */
-	mov	al, [rdi-1]
-	mov	ah, al
-
-	sar	ecx, 1
-	jnc	L_set_two
-	mov	[rdi], al
-	inc	rdi
-
-L_set_two:
-	rep     stosw
-	jmp	L_while_test
-
-ALIGN 4
-L_test_for_second_level_length:
-	test	al, 64
-	jnz	L_test_for_end_of_block ; /* if ((op & 64) != 0) */
-
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax
-	and	eax, edx         ; /* eax &= hold */
-	add	eax, r14d        ; /* eax += len */
-	mov	eax, [rbp+rax*4] ; /* eax = lcode[val+(hold&mask[op])]*/
-	jmp	L_dolen
-
-ALIGN 4
-L_test_for_second_level_dist:
-	test	al, 64
-	jnz	L_invalid_distance_code ; /* if ((op & 64) != 0) */
-
-	xor	eax, eax
-	inc	eax
-	shl	eax, cl
-	dec	eax
-	and	eax, edx         ; /* eax &= hold */
-	add	eax, r15d        ; /* eax += dist */
-	mov	eax, [r11+rax*4] ; /* eax = dcode[val+(hold&mask[op])]*/
-	jmp	L_dodist
-
-ALIGN 4
-L_clip_window:
-	mov	ecx, eax         ; /* ecx = nbytes */
-	mov	eax, [rsp+92]     ; /* eax = wsize, prepare for dist cmp */
-	neg	ecx                ; /* nbytes = -nbytes */
-
-	cmp	eax, r15d
-	jb	L_invalid_distance_too_far ; /* if (dist > wsize) */
-
-	add	ecx, r15d         ; /* nbytes = dist - nbytes */
-	cmp	dword ptr [rsp+96], 0
-	jne	L_wrap_around_window ; /* if (write != 0) */
-
-	mov	rsi, [rsp+56]     ; /* from  = window */
-	sub	eax, ecx         ; /* eax  -= nbytes */
-	add	rsi, rax         ; /* from += wsize - nbytes */
-
-	mov	eax, r14d        ; /* eax = len */
-	cmp	r14d, ecx
-	jbe	L_do_copy           ; /* if (nbytes >= len) */
-
-	sub	eax, ecx         ; /* eax -= nbytes */
-	rep     movsb
-	mov	rsi, rdi
-	sub	rsi, r15         ; /* from = &out[ -dist ] */
-	jmp	L_do_copy
-
-ALIGN 4
-L_wrap_around_window:
-	mov	eax, [rsp+96]     ; /* eax = write */
-	cmp	ecx, eax
-	jbe	L_contiguous_in_window ; /* if (write >= nbytes) */
-
-	mov	esi, [rsp+92]     ; /* from  = wsize */
-	add	rsi, [rsp+56]     ; /* from += window */
-	add	rsi, rax         ; /* from += write */
-	sub	rsi, rcx         ; /* from -= nbytes */
-	sub	ecx, eax         ; /* nbytes -= write */
-
-	mov	eax, r14d        ; /* eax = len */
-	cmp	eax, ecx
-	jbe	L_do_copy           ; /* if (nbytes >= len) */
-
-	sub	eax, ecx         ; /* len -= nbytes */
-	rep     movsb
-	mov	rsi, [rsp+56]     ; /* from = window */
-	mov	ecx, [rsp+96]     ; /* nbytes = write */
-	cmp	eax, ecx
-	jbe	L_do_copy           ; /* if (nbytes >= len) */
-
-	sub	eax, ecx         ; /* len -= nbytes */
-	rep     movsb
-	mov	rsi, rdi
-	sub	rsi, r15         ; /* from = out - dist */
-	jmp	L_do_copy
-
-ALIGN 4
-L_contiguous_in_window:
-	mov	rsi, [rsp+56]     ; /* rsi = window */
-	add	rsi, rax
-	sub	rsi, rcx         ; /* from += write - nbytes */
-
-	mov	eax, r14d        ; /* eax = len */
-	cmp	eax, ecx
-	jbe	L_do_copy           ; /* if (nbytes >= len) */
-
-	sub	eax, ecx         ; /* len -= nbytes */
-	rep     movsb
-	mov	rsi, rdi
-	sub	rsi, r15         ; /* from = out - dist */
-	jmp	L_do_copy           ; /* if (nbytes >= len) */
-
-ALIGN 4
-L_do_copy:
-	mov	ecx, eax         ; /* ecx = len */
-	rep     movsb
-
-	mov	rsi, r8          ; /* move in back to %esi, toss from */
-	jmp	L_while_test
-
-L_test_for_end_of_block:
-	test	al, 32
-	jz	L_invalid_literal_length_code
-	mov	dword ptr [rsp+116], 1
-	jmp	L_break_loop_with_status
-
-L_invalid_literal_length_code:
-	mov	dword ptr [rsp+116], 2
-	jmp	L_break_loop_with_status
-
-L_invalid_distance_code:
-	mov	dword ptr [rsp+116], 3
-	jmp	L_break_loop_with_status
-
-L_invalid_distance_too_far:
-	mov	dword ptr [rsp+116], 4
-	jmp	L_break_loop_with_status
-
-L_break_loop:
-	mov	dword ptr [rsp+116], 0
-
-L_break_loop_with_status:
-; /* put in, out, bits, and hold back into ar and pop esp */
-	mov	[rsp+16], rsi     ; /* in */
-	mov	[rsp+32], rdi     ; /* out */
-	mov	[rsp+88], ebx     ; /* bits */
-	mov	[rsp+80], rdx     ; /* hold */
-
-	mov	rax, [rsp]       ; /* restore rbp and rsp */
-	mov	rbp, [rsp+8]
-	mov	rsp, rax
-
-
-
-	mov rsi,[rsp-8]
-	mov rdi,[rsp-16]
-	mov r12,[rsp-24]
-	mov r13,[rsp-32]
-	mov r14,[rsp-40]
-	mov r15,[rsp-48]
-	mov rbx,[rsp-56]
-	
-    ret 0
-;          :
-;          : "m" (ar)
-;          : "memory", "%rax", "%rbx", "%rcx", "%rdx", "%rsi", "%rdi",
-;            "%r8", "%r9", "%r10", "%r11", "%r12", "%r13", "%r14", "%r15"
-;    );
-
-inffas8664fnc 	ENDP
-;_TEXT	ENDS
-END
diff -Nbaur gcc-4.6.3/zlib/contrib/masmx64/inffasx64.obj gcc-4.6.3-psp/zlib/contrib/masmx64/inffasx64.obj
--- gcc-4.6.3/zlib/contrib/masmx64/inffasx64.obj	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/masmx64/inffasx64.obj	1970-01-01 01:00:00.000000000 +0100
@@ -1,52 +0,0 @@
-d BT  '       .text                              P`.data                               @ P.debug$S                  <   @ B.debug$T        $   0              @ BHt$H|$Ld$Ll$Lt$L|$H\$HHhH HHt$H|$ LL$LT$0Hl$@L\$HHT$P\$XDd$dDl$hL;tL;u*M wP HHBfL;?  L;6  M w HHL#BD *Hu#ML#BD *Hu	ffDA   t*3#HDM w HHL#CDA*H   tP*3#HDLHH+D$(A;   AHI+sfHIfIAuH9|$(tAGsHff@   3#AD f@   3#AA-fD$\A;   A|$` u!Ht$8+HAD;vo+HI+cffD$`;v8t$\Ht$8HH++A;v@+Ht$8L$`;v/+HI+#ffHt$8HH+A;v+HI+fI t
-D$t   &D$t   D$t   D$t   D$t    Ht$H|$ \$XHT$PH$Hl$HHt$H|$Ld$Ll$Lt$L|$H\$      /    O:\zlib-1.2.2.2\contrib\masmx64\inffasx64.asm           Ju,}
-                                           
-                   !     "  #   $  &   &  *   '  -   )  0   +  5   ,  :   -  ?   .  D   /  I   0  N   1  S   2  W   3  \   4  a   9  b   :  e   ;  g   <  j   >  l   B  o   C  r   D  t   F  u   G  w   H  z   I  }   J     K     O     P     Q     R     U     V     W     Y     Z     [     \     ]     `     a     c     d     e     g     h     j     k     l     o     p     s     t     u     w     x     z     {     |                                                                                                                   #    &    *    ,    .    1    3    5    ;    >    @    B    D    F    H    J    L    O    R    U    X    ]    `    f    i    l    o    q    s    v    x    z    }                                                                                                                                                             	        	                         #   %   '   )   ,   /   4  " 8  # :  $ <  & @  ' E  ( H  ) K  * M  , P  - R  . T  0 V  1 X  2 ]  3 a  4 c  5 e  7 g  8 i  9 l  : o  ; t  ? y  @ |  A   C   D   E   G   H   I   J   K   O   P   R   S   V   W   X   Y   \   ]   `   a   d   e   h   l   m   n   o   q   r   s   w   x   y   z   {   |   }         4     O:\zlib-1.2.2.2\contrib\masmx64\inffasx64.obj 4              Microsoft (R) Macro Assembler   3                             inffas8664fnc         L_one_time         L_while_test         L_do_loop         L_get_length_code $        L_get_length_code_one_time         L_dolen          L_test_for_length_base         L_add_bits_to_len         L_decode_distance         L_get_distance_code         L_dodist         L_add_bits_to_dist         L_check_window         L_copy_two         L_check_dist_one         L_set_two (        L_test_for_second_level_length &        L_test_for_second_level_dist         L_clip_window         L_wrap_around_window          L_contiguous_in_window         L_do_copy !        L_test_for_end_of_block '        L_invalid_literal_length_code !        L_invalid_distance_code $        L_invalid_distance_too_far         L_break_loop "        L_break_loop_with_status     d   
-    h   
-   
-   	      	   
-            
-            
-       	     
- 	      	     
- 1	      5	     
- W	      [	     
- j	      n	     
- 	      	     
- 	      	     
- 	      	     
- 	      	     
- 	      	     
- 
-      
-     
- 1
-      5
-     
- G
-      K
-     
- c
-      g
-     
- x
-      |
-     
- 
-      
-     
- 
-      
-     
- 
-      
-     
-            
- %       )      
- :  !    >  !   
- ]  "    a  "   
-   #      #   
-   $      $   
-   %      %   
-   &      &   
-                       @comp.id}    .text                          .data                            .debug$S         <             .debug$T       $                                $$000000               l                         *              4              F          L_dolen            a              x                                    L_dodist#             @             R                                                                          4            B  4          W  t          n            x                                                                      inffas8664fnc L_one_time L_while_test L_do_loop L_get_length_code L_get_length_code_one_time L_test_for_length_base L_add_bits_to_len L_decode_distance L_get_distance_code L_add_bits_to_dist L_check_window L_copy_two L_check_dist_one L_set_two L_test_for_second_level_length L_test_for_second_level_dist L_clip_window L_wrap_around_window L_contiguous_in_window L_do_copy L_test_for_end_of_block L_invalid_literal_length_code L_invalid_distance_code L_invalid_distance_too_far L_break_loop L_break_loop_with_status 
\ No newline at end of file
diff -Nbaur gcc-4.6.3/zlib/contrib/masmx64/readme.txt gcc-4.6.3-psp/zlib/contrib/masmx64/readme.txt
--- gcc-4.6.3/zlib/contrib/masmx64/readme.txt	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/masmx64/readme.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,28 +0,0 @@
-Summary
--------
-This directory contains ASM implementations of the functions
-longest_match() and inflate_fast(), for 64 bits x86 (both AMD64 and Intel EM64t),
-for use with Microsoft Macro Assembler (x64) for AMD64 and Microsoft C++ 64 bits.
-
-gvmat64.asm is written by Gilles Vollant (2005), by using Brian Raiter 686/32 bits
-   assembly optimized version from Jean-loup Gailly original longest_match function
-
-inffasx64.asm and inffas8664.c were written by Chris Anderson, by optimizing
-   original function from Mark Adler
-
-Use instructions
-----------------
-Copy these files into the zlib source directory.
-
-define ASMV and ASMINF in your project. Include inffas8664.c in your source tree,
-and inffasx64.obj and gvmat64.obj as object to link.
-
-
-Build instructions
-------------------
-run bld_64.bat with Microsoft Macro Assembler (x64) for AMD64 (ml64.exe)
-
-ml64.exe is given with Visual Studio 2005, Windows 2003 server DDK
-
-You can get Windows 2003 server DDK with ml64 and cl for AMD64 from 
-  http://www.microsoft.com/whdc/devtools/ddk/default.mspx for low price)
diff -Nbaur gcc-4.6.3/zlib/contrib/masmx86/bld_ml32.bat gcc-4.6.3-psp/zlib/contrib/masmx86/bld_ml32.bat
--- gcc-4.6.3/zlib/contrib/masmx86/bld_ml32.bat	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/masmx86/bld_ml32.bat	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-ml /coff /Zi /c /Flgvmat32.lst  gvmat32.asm 
-ml /coff /Zi /c /Flinffas32.lst inffas32.asm 
diff -Nbaur gcc-4.6.3/zlib/contrib/masmx86/gvmat32.asm gcc-4.6.3-psp/zlib/contrib/masmx86/gvmat32.asm
--- gcc-4.6.3/zlib/contrib/masmx86/gvmat32.asm	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/masmx86/gvmat32.asm	1970-01-01 01:00:00.000000000 +0100
@@ -1,972 +0,0 @@
-; gvmat32.asm -- Asm portion of the optimized longest_match for 32 bits x86
-; Copyright (C) 1995-1996 Jean-loup Gailly and Gilles Vollant.
-; File written by Gilles Vollant, by modifiying the longest_match
-;  from Jean-loup Gailly in deflate.c
-;
-;         http://www.zlib.net
-;         http://www.winimage.com/zLibDll
-;         http://www.muppetlabs.com/~breadbox/software/assembly.html
-;
-; For Visual C++ 4.x and higher and ML 6.x and higher
-;   ml.exe is in directory \MASM611C of Win95 DDK
-;   ml.exe is also distributed in http://www.masm32.com/masmdl.htm
-;    and in VC++2003 toolkit at http://msdn.microsoft.com/visualc/vctoolkit2003/
-;
-; this file contain two implementation of longest_match
-;
-;  longest_match_7fff : written 1996 by Gilles Vollant optimized for 
-;            first Pentium. Assume s->w_mask == 0x7fff
-;  longest_match_686 : written by Brian raiter (1998), optimized for Pentium Pro
-;
-;  for using an seembly version of longest_match, you need define ASMV in project
-;  There is two way in using gvmat32.asm
-;
-;  A) Suggested method
-;    if you want include both longest_match_7fff and longest_match_686
-;    compile the asm file running
-;           ml /coff /Zi /Flgvmat32.lst /c gvmat32.asm
-;    and include gvmat32c.c in your project
-;    if you have an old cpu (386,486 or first Pentium) and s->w_mask==0x7fff,
-;        longest_match_7fff will be used
-;    if you have a more modern CPU (Pentium Pro, II and higher)
-;        longest_match_686 will be used
-;    on old cpu with s->w_mask!=0x7fff, longest_match_686 will be used,
-;        but this is not a sitation you'll find often
-;
-;  B) Alternative
-;    if you are not interresed in old cpu performance and want the smaller
-;       binaries possible
-;
-;    compile the asm file running
-;           ml /coff /Zi /c /Flgvmat32.lst /DNOOLDPENTIUMCODE gvmat32.asm
-;    and do not include gvmat32c.c in your project (ou define also 
-;              NOOLDPENTIUMCODE)
-;
-; note : as I known, longest_match_686 is very faster than longest_match_7fff
-;        on pentium Pro/II/III, faster (but less) in P4, but it seem
-;        longest_match_7fff can be faster (very very litte) on AMD Athlon64/K8
-;
-; see below : zlib1222add must be adjuster if you use a zlib version < 1.2.2.2
-
-;uInt longest_match_7fff(s, cur_match)
-;    deflate_state *s;
-;    IPos cur_match;                             /* current match */
-
-    NbStack         equ     76
-    cur_match       equ     dword ptr[esp+NbStack-0]
-    str_s           equ     dword ptr[esp+NbStack-4]
-; 5 dword on top (ret,ebp,esi,edi,ebx)
-    adrret          equ     dword ptr[esp+NbStack-8]
-    pushebp         equ     dword ptr[esp+NbStack-12]
-    pushedi         equ     dword ptr[esp+NbStack-16]
-    pushesi         equ     dword ptr[esp+NbStack-20]
-    pushebx         equ     dword ptr[esp+NbStack-24]
-
-    chain_length    equ     dword ptr [esp+NbStack-28]
-    limit           equ     dword ptr [esp+NbStack-32]
-    best_len        equ     dword ptr [esp+NbStack-36]
-    window          equ     dword ptr [esp+NbStack-40]
-    prev            equ     dword ptr [esp+NbStack-44]
-    scan_start      equ      word ptr [esp+NbStack-48]
-    wmask           equ     dword ptr [esp+NbStack-52]
-    match_start_ptr equ     dword ptr [esp+NbStack-56]
-    nice_match      equ     dword ptr [esp+NbStack-60]
-    scan            equ     dword ptr [esp+NbStack-64]
-
-    windowlen       equ     dword ptr [esp+NbStack-68]
-    match_start     equ     dword ptr [esp+NbStack-72]
-    strend          equ     dword ptr [esp+NbStack-76]
-    NbStackAdd      equ     (NbStack-24)
-
-    .386p
-
-    name    gvmatch
-    .MODEL  FLAT
-
-
-
-;  all the +zlib1222add offsets are due to the addition of fields
-;  in zlib in the deflate_state structure since the asm code was first written
-;  (if you compile with zlib 1.0.4 or older, use "zlib1222add equ (-4)").
-;  (if you compile with zlib between 1.0.5 and 1.2.2.1, use "zlib1222add equ 0").
-;  if you compile with zlib 1.2.2.2 or later , use "zlib1222add equ 8").
-
-    zlib1222add         equ     8
-
-;  Note : these value are good with a 8 bytes boundary pack structure
-    dep_chain_length    equ     74h+zlib1222add
-    dep_window          equ     30h+zlib1222add
-    dep_strstart        equ     64h+zlib1222add
-    dep_prev_length     equ     70h+zlib1222add
-    dep_nice_match      equ     88h+zlib1222add
-    dep_w_size          equ     24h+zlib1222add
-    dep_prev            equ     38h+zlib1222add
-    dep_w_mask          equ     2ch+zlib1222add
-    dep_good_match      equ     84h+zlib1222add
-    dep_match_start     equ     68h+zlib1222add
-    dep_lookahead       equ     6ch+zlib1222add
-
-
-_TEXT                   segment
-
-IFDEF NOUNDERLINE
-   IFDEF NOOLDPENTIUMCODE
-            public  longest_match
-            public  match_init
-   ELSE            
-            public  longest_match_7fff
-            public  cpudetect32
-            public  longest_match_686
-   ENDIF
-ELSE
-   IFDEF NOOLDPENTIUMCODE
-            public  _longest_match
-            public  _match_init
-   ELSE
-            public  _longest_match_7fff
-            public  _cpudetect32
-            public  _longest_match_686
-   ENDIF
-ENDIF
-
-    MAX_MATCH           equ     258
-    MIN_MATCH           equ     3
-    MIN_LOOKAHEAD       equ     (MAX_MATCH+MIN_MATCH+1)
-
-
-
-IFNDEF NOOLDPENTIUMCODE
-IFDEF NOUNDERLINE
-longest_match_7fff   proc near
-ELSE
-_longest_match_7fff  proc near
-ENDIF
-
-    mov     edx,[esp+4]
-
-
-
-    push    ebp
-    push    edi
-    push    esi
-    push    ebx
-
-    sub     esp,NbStackAdd
-
-; initialize or check the variables used in match.asm.
-    mov     ebp,edx
-
-; chain_length = s->max_chain_length
-; if (prev_length>=good_match) chain_length >>= 2
-    mov     edx,[ebp+dep_chain_length]
-    mov     ebx,[ebp+dep_prev_length]
-    cmp     [ebp+dep_good_match],ebx
-    ja      noshr
-    shr     edx,2
-noshr:
-; we increment chain_length because in the asm, the --chain_lenght is in the beginning of the loop
-    inc     edx
-    mov     edi,[ebp+dep_nice_match]
-    mov     chain_length,edx
-    mov     eax,[ebp+dep_lookahead]
-    cmp     eax,edi
-; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
-    jae     nolookaheadnicematch
-    mov     edi,eax
-nolookaheadnicematch:
-; best_len = s->prev_length
-    mov     best_len,ebx
-
-; window = s->window
-    mov     esi,[ebp+dep_window]
-    mov     ecx,[ebp+dep_strstart]
-    mov     window,esi
-
-    mov     nice_match,edi
-; scan = window + strstart
-    add     esi,ecx
-    mov     scan,esi
-; dx = *window
-    mov     dx,word ptr [esi]
-; bx = *(window+best_len-1)
-    mov     bx,word ptr [esi+ebx-1]
-    add     esi,MAX_MATCH-1
-; scan_start = *scan
-    mov     scan_start,dx
-; strend = scan + MAX_MATCH-1
-    mov     strend,esi
-; bx = scan_end = *(window+best_len-1)
-
-;    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
-;        s->strstart - (IPos)MAX_DIST(s) : NIL;
-
-    mov     esi,[ebp+dep_w_size]
-    sub     esi,MIN_LOOKAHEAD
-; here esi = MAX_DIST(s)
-    sub     ecx,esi
-    ja      nodist
-    xor     ecx,ecx
-nodist:
-    mov     limit,ecx
-
-; prev = s->prev
-    mov     edx,[ebp+dep_prev]
-    mov     prev,edx
-
-;
-    mov     edx,dword ptr [ebp+dep_match_start]
-    mov     bp,scan_start
-    mov     eax,cur_match
-    mov     match_start,edx
-
-    mov     edx,window
-    mov     edi,edx
-    add     edi,best_len
-    mov     esi,prev
-    dec     edi
-; windowlen = window + best_len -1
-    mov     windowlen,edi
-
-    jmp     beginloop2
-    align   4
-
-; here, in the loop
-;       eax = ax = cur_match
-;       ecx = limit
-;        bx = scan_end
-;        bp = scan_start
-;       edi = windowlen (window + best_len -1)
-;       esi = prev
-
-
-;// here; chain_length <=16
-normalbeg0add16:
-    add     chain_length,16
-    jz      exitloop
-normalbeg0:
-    cmp     word ptr[edi+eax],bx
-    je      normalbeg2noroll
-rcontlabnoroll:
-; cur_match = prev[cur_match & wmask]
-    and     eax,7fffh
-    mov     ax,word ptr[esi+eax*2]
-; if cur_match > limit, go to exitloop
-    cmp     ecx,eax
-    jnb     exitloop
-; if --chain_length != 0, go to exitloop
-    dec     chain_length
-    jnz     normalbeg0
-    jmp     exitloop
-
-normalbeg2noroll:
-; if (scan_start==*(cur_match+window)) goto normalbeg2
-    cmp     bp,word ptr[edx+eax]
-    jne     rcontlabnoroll
-    jmp     normalbeg2
-
-contloop3:
-    mov     edi,windowlen
-
-; cur_match = prev[cur_match & wmask]
-    and     eax,7fffh
-    mov     ax,word ptr[esi+eax*2]
-; if cur_match > limit, go to exitloop
-    cmp     ecx,eax
-jnbexitloopshort1:
-    jnb     exitloop
-; if --chain_length != 0, go to exitloop
-
-
-; begin the main loop
-beginloop2:
-    sub     chain_length,16+1
-; if chain_length <=16, don't use the unrolled loop
-    jna     normalbeg0add16
-
-do16:
-    cmp     word ptr[edi+eax],bx
-    je      normalbeg2dc0
-
-maccn   MACRO   lab
-    and     eax,7fffh
-    mov     ax,word ptr[esi+eax*2]
-    cmp     ecx,eax
-    jnb     exitloop
-    cmp     word ptr[edi+eax],bx
-    je      lab
-    ENDM
-
-rcontloop0:
-    maccn   normalbeg2dc1
-
-rcontloop1:
-    maccn   normalbeg2dc2
-
-rcontloop2:
-    maccn   normalbeg2dc3
-
-rcontloop3:
-    maccn   normalbeg2dc4
-
-rcontloop4:
-    maccn   normalbeg2dc5
-
-rcontloop5:
-    maccn   normalbeg2dc6
-
-rcontloop6:
-    maccn   normalbeg2dc7
-
-rcontloop7:
-    maccn   normalbeg2dc8
-
-rcontloop8:
-    maccn   normalbeg2dc9
-
-rcontloop9:
-    maccn   normalbeg2dc10
-
-rcontloop10:
-    maccn   short normalbeg2dc11
-
-rcontloop11:
-    maccn   short normalbeg2dc12
-
-rcontloop12:
-    maccn   short normalbeg2dc13
-
-rcontloop13:
-    maccn   short normalbeg2dc14
-
-rcontloop14:
-    maccn   short normalbeg2dc15
-
-rcontloop15:
-    and     eax,7fffh
-    mov     ax,word ptr[esi+eax*2]
-    cmp     ecx,eax
-    jnb     exitloop
-
-    sub     chain_length,16
-    ja      do16
-    jmp     normalbeg0add16
-
-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
-
-normbeg MACRO   rcontlab,valsub
-; if we are here, we know that *(match+best_len-1) == scan_end
-    cmp     bp,word ptr[edx+eax]
-; if (match != scan_start) goto rcontlab
-    jne     rcontlab
-; calculate the good chain_length, and we'll compare scan and match string
-    add     chain_length,16-valsub
-    jmp     iseq
-    ENDM
-
-
-normalbeg2dc11:
-    normbeg rcontloop11,11
-
-normalbeg2dc12:
-    normbeg short rcontloop12,12
-
-normalbeg2dc13:
-    normbeg short rcontloop13,13
-
-normalbeg2dc14:
-    normbeg short rcontloop14,14
-
-normalbeg2dc15:
-    normbeg short rcontloop15,15
-
-normalbeg2dc10:
-    normbeg rcontloop10,10
-
-normalbeg2dc9:
-    normbeg rcontloop9,9
-
-normalbeg2dc8:
-    normbeg rcontloop8,8
-
-normalbeg2dc7:
-    normbeg rcontloop7,7
-
-normalbeg2dc6:
-    normbeg rcontloop6,6
-
-normalbeg2dc5:
-    normbeg rcontloop5,5
-
-normalbeg2dc4:
-    normbeg rcontloop4,4
-
-normalbeg2dc3:
-    normbeg rcontloop3,3
-
-normalbeg2dc2:
-    normbeg rcontloop2,2
-
-normalbeg2dc1:
-    normbeg rcontloop1,1
-
-normalbeg2dc0:
-    normbeg rcontloop0,0
-
-
-; we go in normalbeg2 because *(ushf*)(match+best_len-1) == scan_end
-
-normalbeg2:
-    mov     edi,window
-
-    cmp     bp,word ptr[edi+eax]
-    jne     contloop3                   ; if *(ushf*)match != scan_start, continue
-
-iseq:
-; if we are here, we know that *(match+best_len-1) == scan_end
-; and (match == scan_start)
-
-    mov     edi,edx
-    mov     esi,scan                    ; esi = scan
-    add     edi,eax                     ; edi = window + cur_match = match
-
-    mov     edx,[esi+3]                 ; compare manually dword at match+3
-    xor     edx,[edi+3]                 ; and scan +3
-
-    jz      begincompare                ; if equal, go to long compare
-
-; we will determine the unmatch byte and calculate len (in esi)
-    or      dl,dl
-    je      eq1rr
-    mov     esi,3
-    jmp     trfinval
-eq1rr:
-    or      dx,dx
-    je      eq1
-
-    mov     esi,4
-    jmp     trfinval
-eq1:
-    and     edx,0ffffffh
-    jz      eq11
-    mov     esi,5
-    jmp     trfinval
-eq11:
-    mov     esi,6
-    jmp     trfinval
-
-begincompare:
-    ; here we now scan and match begin same
-    add     edi,6
-    add     esi,6
-    mov     ecx,(MAX_MATCH-(2+4))/4     ; scan for at most MAX_MATCH bytes
-    repe    cmpsd                       ; loop until mismatch
-
-    je      trfin                       ; go to trfin if not unmatch
-; we determine the unmatch byte
-    sub     esi,4
-    mov     edx,[edi-4]
-    xor     edx,[esi]
-
-    or      dl,dl
-    jnz     trfin
-    inc     esi
-
-    or      dx,dx
-    jnz     trfin
-    inc     esi
-
-    and     edx,0ffffffh
-    jnz     trfin
-    inc     esi
-
-trfin:
-    sub     esi,scan          ; esi = len
-trfinval:
-; here we have finised compare, and esi contain len of equal string
-    cmp     esi,best_len        ; if len > best_len, go newbestlen
-    ja      short newbestlen
-; now we restore edx, ecx and esi, for the big loop
-    mov     esi,prev
-    mov     ecx,limit
-    mov     edx,window
-    jmp     contloop3
-
-newbestlen:
-    mov     best_len,esi        ; len become best_len
-
-    mov     match_start,eax     ; save new position as match_start
-    cmp     esi,nice_match      ; if best_len >= nice_match, exit
-    jae     exitloop
-    mov     ecx,scan
-    mov     edx,window          ; restore edx=window
-    add     ecx,esi
-    add     esi,edx
-
-    dec     esi
-    mov     windowlen,esi       ; windowlen = window + best_len-1
-    mov     bx,[ecx-1]          ; bx = *(scan+best_len-1) = scan_end
-
-; now we restore ecx and esi, for the big loop :
-    mov     esi,prev
-    mov     ecx,limit
-    jmp     contloop3
-
-exitloop:
-; exit : s->match_start=match_start
-    mov     ebx,match_start
-    mov     ebp,str_s
-    mov     ecx,best_len
-    mov     dword ptr [ebp+dep_match_start],ebx
-    mov     eax,dword ptr [ebp+dep_lookahead]
-    cmp     ecx,eax
-    ja      minexlo
-    mov     eax,ecx
-minexlo:
-; return min(best_len,s->lookahead)
-
-; restore stack and register ebx,esi,edi,ebp
-    add     esp,NbStackAdd
-
-    pop     ebx
-    pop     esi
-    pop     edi
-    pop     ebp
-    ret
-InfoAuthor:
-; please don't remove this string !
-; Your are free use gvmat32 in any fre or commercial apps if you don't remove the string in the binary!
-    db     0dh,0ah,"GVMat32 optimised assembly code written 1996-98 by Gilles Vollant",0dh,0ah
-
-
-
-IFDEF NOUNDERLINE
-longest_match_7fff   endp
-ELSE
-_longest_match_7fff  endp
-ENDIF
-
-
-IFDEF NOUNDERLINE
-cpudetect32     proc near
-ELSE
-_cpudetect32    proc near
-ENDIF
-
-    push    ebx
-
-    pushfd                  ; push original EFLAGS
-    pop     eax             ; get original EFLAGS
-    mov     ecx, eax        ; save original EFLAGS
-    xor     eax, 40000h     ; flip AC bit in EFLAGS
-    push    eax             ; save new EFLAGS value on stack
-    popfd                   ; replace current EFLAGS value
-    pushfd                  ; get new EFLAGS
-    pop     eax             ; store new EFLAGS in EAX
-    xor     eax, ecx        ; cant toggle AC bit, processor=80386
-    jz      end_cpu_is_386  ; jump if 80386 processor
-    push    ecx
-    popfd                   ; restore AC bit in EFLAGS first
-
-    pushfd
-    pushfd
-    pop     ecx
-
-    mov     eax, ecx        ; get original EFLAGS
-    xor     eax, 200000h    ; flip ID bit in EFLAGS
-    push    eax             ; save new EFLAGS value on stack
-    popfd                   ; replace current EFLAGS value
-    pushfd                  ; get new EFLAGS
-    pop     eax             ; store new EFLAGS in EAX
-    popfd                   ; restore original EFLAGS
-    xor     eax, ecx        ; cant toggle ID bit,
-    je      is_old_486      ; processor=old
-
-    mov     eax,1
-    db      0fh,0a2h        ;CPUID
-
-exitcpudetect:
-    pop ebx
-    ret
-
-end_cpu_is_386:
-    mov     eax,0300h
-    jmp     exitcpudetect
-
-is_old_486:
-    mov     eax,0400h
-    jmp     exitcpudetect
-
-IFDEF NOUNDERLINE
-cpudetect32     endp
-ELSE
-_cpudetect32    endp
-ENDIF
-ENDIF
-
-MAX_MATCH       equ     258
-MIN_MATCH       equ     3
-MIN_LOOKAHEAD   equ     (MAX_MATCH + MIN_MATCH + 1)
-MAX_MATCH_8_     equ     ((MAX_MATCH + 7) AND 0FFF0h)
-
-
-;;; stack frame offsets
-
-chainlenwmask   equ  esp + 0    ; high word: current chain len
-                    ; low word: s->wmask
-window      equ  esp + 4    ; local copy of s->window
-windowbestlen   equ  esp + 8    ; s->window + bestlen
-scanstart   equ  esp + 16   ; first two bytes of string
-scanend     equ  esp + 12   ; last two bytes of string
-scanalign   equ  esp + 20   ; dword-misalignment of string
-nicematch   equ  esp + 24   ; a good enough match size
-bestlen     equ  esp + 28   ; size of best match so far
-scan        equ  esp + 32   ; ptr to string wanting match
-
-LocalVarsSize   equ 36
-;   saved ebx   byte esp + 36
-;   saved edi   byte esp + 40
-;   saved esi   byte esp + 44
-;   saved ebp   byte esp + 48
-;   return address  byte esp + 52
-deflatestate    equ  esp + 56   ; the function arguments
-curmatch    equ  esp + 60
-
-;;; Offsets for fields in the deflate_state structure. These numbers
-;;; are calculated from the definition of deflate_state, with the
-;;; assumption that the compiler will dword-align the fields. (Thus,
-;;; changing the definition of deflate_state could easily cause this
-;;; program to crash horribly, without so much as a warning at
-;;; compile time. Sigh.)
-
-dsWSize     equ 36+zlib1222add
-dsWMask     equ 44+zlib1222add
-dsWindow    equ 48+zlib1222add
-dsPrev      equ 56+zlib1222add
-dsMatchLen  equ 88+zlib1222add
-dsPrevMatch equ 92+zlib1222add
-dsStrStart  equ 100+zlib1222add
-dsMatchStart    equ 104+zlib1222add
-dsLookahead equ 108+zlib1222add
-dsPrevLen   equ 112+zlib1222add
-dsMaxChainLen   equ 116+zlib1222add
-dsGoodMatch equ 132+zlib1222add
-dsNiceMatch equ 136+zlib1222add
-
-
-;;; match.asm -- Pentium-Pro-optimized version of longest_match()
-;;; Written for zlib 1.1.2
-;;; Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>
-;;; You can look at http://www.muppetlabs.com/~breadbox/software/assembly.html
-;;;
-;;; This is free software; you can redistribute it and/or modify it
-;;; under the terms of the GNU General Public License.
-
-;GLOBAL _longest_match, _match_init
-
-
-;SECTION    .text
-
-;;; uInt longest_match(deflate_state *deflatestate, IPos curmatch)
-
-;_longest_match:
-IFDEF NOOLDPENTIUMCODE
-    IFDEF NOUNDERLINE
-    longest_match       proc near
-    ELSE
-    _longest_match      proc near
-    ENDIF
-ELSE
-    IFDEF NOUNDERLINE
-    longest_match_686   proc near
-    ELSE
-    _longest_match_686  proc near
-    ENDIF
-ENDIF
-
-;;; Save registers that the compiler may be using, and adjust esp to
-;;; make room for our stack frame.
-
-        push    ebp
-        push    edi
-        push    esi
-        push    ebx
-        sub esp, LocalVarsSize
-
-;;; Retrieve the function arguments. ecx will hold cur_match
-;;; throughout the entire function. edx will hold the pointer to the
-;;; deflate_state structure during the function's setup (before
-;;; entering the main loop.
-
-        mov edx, [deflatestate]
-        mov ecx, [curmatch]
-
-;;; uInt wmask = s->w_mask;
-;;; unsigned chain_length = s->max_chain_length;
-;;; if (s->prev_length >= s->good_match) {
-;;;     chain_length >>= 2;
-;;; }
-
-        mov eax, [edx + dsPrevLen]
-        mov ebx, [edx + dsGoodMatch]
-        cmp eax, ebx
-        mov eax, [edx + dsWMask]
-        mov ebx, [edx + dsMaxChainLen]
-        jl  LastMatchGood
-        shr ebx, 2
-LastMatchGood:
-
-;;; chainlen is decremented once beforehand so that the function can
-;;; use the sign flag instead of the zero flag for the exit test.
-;;; It is then shifted into the high word, to make room for the wmask
-;;; value, which it will always accompany.
-
-        dec ebx
-        shl ebx, 16
-        or  ebx, eax
-        mov [chainlenwmask], ebx
-
-;;; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
-
-        mov eax, [edx + dsNiceMatch]
-        mov ebx, [edx + dsLookahead]
-        cmp ebx, eax
-        jl  LookaheadLess
-        mov ebx, eax
-LookaheadLess:  mov [nicematch], ebx
-
-;;; register Bytef *scan = s->window + s->strstart;
-
-        mov esi, [edx + dsWindow]
-        mov [window], esi
-        mov ebp, [edx + dsStrStart]
-        lea edi, [esi + ebp]
-        mov [scan], edi
-
-;;; Determine how many bytes the scan ptr is off from being
-;;; dword-aligned.
-
-        mov eax, edi
-        neg eax
-        and eax, 3
-        mov [scanalign], eax
-
-;;; IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
-;;;     s->strstart - (IPos)MAX_DIST(s) : NIL;
-
-        mov eax, [edx + dsWSize]
-        sub eax, MIN_LOOKAHEAD
-        sub ebp, eax
-        jg  LimitPositive
-        xor ebp, ebp
-LimitPositive:
-
-;;; int best_len = s->prev_length;
-
-        mov eax, [edx + dsPrevLen]
-        mov [bestlen], eax
-
-;;; Store the sum of s->window + best_len in esi locally, and in esi.
-
-        add esi, eax
-        mov [windowbestlen], esi
-
-;;; register ush scan_start = *(ushf*)scan;
-;;; register ush scan_end   = *(ushf*)(scan+best_len-1);
-;;; Posf *prev = s->prev;
-
-        movzx   ebx, word ptr [edi]
-        mov [scanstart], ebx
-        movzx   ebx, word ptr [edi + eax - 1]
-        mov [scanend], ebx
-        mov edi, [edx + dsPrev]
-
-;;; Jump into the main loop.
-
-        mov edx, [chainlenwmask]
-        jmp short LoopEntry
-
-align 4
-
-;;; do {
-;;;     match = s->window + cur_match;
-;;;     if (*(ushf*)(match+best_len-1) != scan_end ||
-;;;         *(ushf*)match != scan_start) continue;
-;;;     [...]
-;;; } while ((cur_match = prev[cur_match & wmask]) > limit
-;;;          && --chain_length != 0);
-;;;
-;;; Here is the inner loop of the function. The function will spend the
-;;; majority of its time in this loop, and majority of that time will
-;;; be spent in the first ten instructions.
-;;;
-;;; Within this loop:
-;;; ebx = scanend
-;;; ecx = curmatch
-;;; edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)
-;;; esi = windowbestlen - i.e., (window + bestlen)
-;;; edi = prev
-;;; ebp = limit
-
-LookupLoop:
-        and ecx, edx
-        movzx   ecx, word ptr [edi + ecx*2]
-        cmp ecx, ebp
-        jbe LeaveNow
-        sub edx, 00010000h
-        js  LeaveNow
-LoopEntry:  movzx   eax, word ptr [esi + ecx - 1]
-        cmp eax, ebx
-        jnz LookupLoop
-        mov eax, [window]
-        movzx   eax, word ptr [eax + ecx]
-        cmp eax, [scanstart]
-        jnz LookupLoop
-
-;;; Store the current value of chainlen.
-
-        mov [chainlenwmask], edx
-
-;;; Point edi to the string under scrutiny, and esi to the string we
-;;; are hoping to match it up with. In actuality, esi and edi are
-;;; both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and edx is
-;;; initialized to -(MAX_MATCH_8 - scanalign).
-
-        mov esi, [window]
-        mov edi, [scan]
-        add esi, ecx
-        mov eax, [scanalign]
-        mov edx, 0fffffef8h; -(MAX_MATCH_8)
-        lea edi, [edi + eax + 0108h] ;MAX_MATCH_8]
-        lea esi, [esi + eax + 0108h] ;MAX_MATCH_8]
-
-;;; Test the strings for equality, 8 bytes at a time. At the end,
-;;; adjust edx so that it is offset to the exact byte that mismatched.
-;;;
-;;; We already know at this point that the first three bytes of the
-;;; strings match each other, and they can be safely passed over before
-;;; starting the compare loop. So what this code does is skip over 0-3
-;;; bytes, as much as necessary in order to dword-align the edi
-;;; pointer. (esi will still be misaligned three times out of four.)
-;;;
-;;; It should be confessed that this loop usually does not represent
-;;; much of the total running time. Replacing it with a more
-;;; straightforward "rep cmpsb" would not drastically degrade
-;;; performance.
-
-LoopCmps:
-        mov eax, [esi + edx]
-        xor eax, [edi + edx]
-        jnz LeaveLoopCmps
-        mov eax, [esi + edx + 4]
-        xor eax, [edi + edx + 4]
-        jnz LeaveLoopCmps4
-        add edx, 8
-        jnz LoopCmps
-        jmp short LenMaximum
-LeaveLoopCmps4: add edx, 4
-LeaveLoopCmps:  test    eax, 0000FFFFh
-        jnz LenLower
-        add edx,  2
-        shr eax, 16
-LenLower:   sub al, 1
-        adc edx, 0
-
-;;; Calculate the length of the match. If it is longer than MAX_MATCH,
-;;; then automatically accept it as the best possible match and leave.
-
-        lea eax, [edi + edx]
-        mov edi, [scan]
-        sub eax, edi
-        cmp eax, MAX_MATCH
-        jge LenMaximum
-
-;;; If the length of the match is not longer than the best match we
-;;; have so far, then forget it and return to the lookup loop.
-
-        mov edx, [deflatestate]
-        mov ebx, [bestlen]
-        cmp eax, ebx
-        jg  LongerMatch
-        mov esi, [windowbestlen]
-        mov edi, [edx + dsPrev]
-        mov ebx, [scanend]
-        mov edx, [chainlenwmask]
-        jmp LookupLoop
-
-;;;         s->match_start = cur_match;
-;;;         best_len = len;
-;;;         if (len >= nice_match) break;
-;;;         scan_end = *(ushf*)(scan+best_len-1);
-
-LongerMatch:    mov ebx, [nicematch]
-        mov [bestlen], eax
-        mov [edx + dsMatchStart], ecx
-        cmp eax, ebx
-        jge LeaveNow
-        mov esi, [window]
-        add esi, eax
-        mov [windowbestlen], esi
-        movzx   ebx, word ptr [edi + eax - 1]
-        mov edi, [edx + dsPrev]
-        mov [scanend], ebx
-        mov edx, [chainlenwmask]
-        jmp LookupLoop
-
-;;; Accept the current string, with the maximum possible length.
-
-LenMaximum: mov edx, [deflatestate]
-        mov dword ptr [bestlen], MAX_MATCH
-        mov [edx + dsMatchStart], ecx
-
-;;; if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
-;;; return s->lookahead;
-
-LeaveNow:
-        mov edx, [deflatestate]
-        mov ebx, [bestlen]
-        mov eax, [edx + dsLookahead]
-        cmp ebx, eax
-        jg  LookaheadRet
-        mov eax, ebx
-LookaheadRet:
-
-;;; Restore the stack and return from whence we came.
-
-        add esp, LocalVarsSize
-        pop ebx
-        pop esi
-        pop edi
-        pop ebp
-
-        ret
-; please don't remove this string !
-; Your can freely use gvmat32 in any free or commercial app if you don't remove the string in the binary!
-    db     0dh,0ah,"asm686 with masm, optimised assembly code from Brian Raiter, written 1998",0dh,0ah
-
-
-IFDEF NOOLDPENTIUMCODE
-    IFDEF NOUNDERLINE
-    longest_match       endp
-    ELSE
-    _longest_match      endp
-    ENDIF
-
-    IFDEF NOUNDERLINE
-    match_init      proc near
-                    ret
-    match_init      endp
-    ELSE
-    _match_init     proc near
-                    ret
-    _match_init     endp
-    ENDIF    
-ELSE
-    IFDEF NOUNDERLINE
-    longest_match_686   endp
-    ELSE
-    _longest_match_686  endp
-    ENDIF
-ENDIF
-
-_TEXT   ends
-end
diff -Nbaur gcc-4.6.3/zlib/contrib/masmx86/gvmat32c.c gcc-4.6.3-psp/zlib/contrib/masmx86/gvmat32c.c
--- gcc-4.6.3/zlib/contrib/masmx86/gvmat32c.c	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/masmx86/gvmat32c.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,62 +0,0 @@
-/* gvmat32.c -- C portion of the optimized longest_match for 32 bits x86
- * Copyright (C) 1995-1996 Jean-loup Gailly and Gilles Vollant.
- * File written by Gilles Vollant, by modifiying the longest_match
- *  from Jean-loup Gailly in deflate.c
- *  it prepare all parameters and call the assembly longest_match_gvasm
- *  longest_match execute standard C code is wmask != 0x7fff
- *     (assembly code is faster with a fixed wmask)
- *
- * Read comment at beginning of gvmat32.asm for more information
- */
-
-#if defined(ASMV) && (!defined(NOOLDPENTIUMCODE))
-#include "deflate.h"
-
-/* if your C compiler don't add underline before function name,
-        define ADD_UNDERLINE_ASMFUNC */
-#ifdef ADD_UNDERLINE_ASMFUNC
-#define longest_match_7fff _longest_match_7fff
-#define longest_match_686  _longest_match_686
-#define cpudetect32        _cpudetect32
-#endif
-
-
-unsigned long cpudetect32();
-
-uInt longest_match_c(
-    deflate_state *s,
-    IPos cur_match);                             /* current match */
-
-
-uInt longest_match_7fff(
-    deflate_state *s,
-    IPos cur_match);                             /* current match */
-
-uInt longest_match_686(
-    deflate_state *s,
-    IPos cur_match);                             /* current match */
-
-
-static uInt iIsPPro=2;
-
-void match_init ()
-{
-    iIsPPro = (((cpudetect32()/0x100)&0xf)>=6) ? 1 : 0;
-}
-
-uInt longest_match(
-    deflate_state *s,
-    IPos cur_match)                             /* current match */
-{
-    if (iIsPPro!=0)
-        return longest_match_686(s,cur_match);
-
-    if (s->w_mask != 0x7fff)
-        return longest_match_686(s,cur_match);
-
-    /* now ((s->w_mask == 0x7fff) && (iIsPPro==0)) */
-        return longest_match_7fff(s,cur_match);
-}
-
-
-#endif /* defined(ASMV) && (!defined(NOOLDPENTIUMCODE)) */
diff -Nbaur gcc-4.6.3/zlib/contrib/masmx86/gvmat32.obj gcc-4.6.3-psp/zlib/contrib/masmx86/gvmat32.obj
--- gcc-4.6.3/zlib/contrib/masmx86/gvmat32.obj	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/masmx86/gvmat32.obj	1970-01-01 01:00:00.000000000 +0100
@@ -1,87 +0,0 @@
-L .B~  i       .text                        ]  0`.data                             @ 0.debug$S      |    b         @ B.debug$T      T   *              @ BT$UWVS4U|]x9   wB   T$0Et;s\$(u8Mlt$$|$t$ff\3  fT$4$u,  +w3L$,U@T$ Upfl$D$LT$T$$|$(t$ O|$ND$0  f98t%  fF;  L$0u  f;,u  |$%  fF;  l$0vf98  %  fF;m  f98  %  fF;R  f98T  %  fF;7  f98(  %  fF;  f98  %  fF;  f98  %  fF;  f98  %  fF;  f98u  %  fF;  f98F  %  fF;  f98  %  fF;z  f98   %  fF;_  f98t}%  fF;H  f98tz%  fF;1  f98ts%  fF;  f98tl%  fF;  f98te%  fF;  l$0Y f;,yD$0  f;,uD$0  f;,uD$0   f;,uD$0   f;,uD$0   f;,D$0   f;,D$0   f;,D$0   f;,D$0	   f;,RD$0
-tf;,&D$0cf;,D$0Rf;,D$0Af;,D$00f;,vD$0f;,JD$0|$$f;,8t$V3Wt-
-t   Qft   E t   6   /?   tW3
-uFfu
-F uF+t$;t$(wt$ L$,T$$t$(D$;t$s"L$T$$Nt$fYt$ L$,\\$l$HL$(]pEt;w4[^_]
-GVMat32 optimised assembly code written 1996-98 by Gilles Vollant
-SX5   PX3tQY5    PX3t   [      UWVS$T$8L$<Bx   ;B4Z||K$   Zt;|\$r8t$jl|5 |$ D$B,-  +3BxD$t$\$\8\$z@$#O;         D1;uD$;D$u$t$|$ D$8  0  23:uD23D:uuq  u, :|$ +=  }LT$8\$;t$z@\$$N\$D$Jp;}-t$t$\8z@\$$!T$8D$  JpT$8\$Bt;$[^_]
-asm686 with masm, optimised assembly code from Brian Raiter, written 1998
-                     	    
-                                     %    )    ,    .     0   ! 2   $ 6   ' 9   ( <   ) @   + D   - F   . J   0 M   2 R   3 X   5 ]   7 `   = c   > i   @ k   A m   B o   D s   G v   H z   K }   L    M    N    P    Q    R    S    T    V    X    f    g    i    j    m    n    p    q    s    t    u    y    z    {    ~                                        4   O   j                     #   :   Q   h                                                0   D   U   f  w    	                   "  #  %  (  )  *  +  -  .  0  1  3  4  5  6  8  9  =	  >  ?  @  B  D  E  F  H  I!  J"  L%  M'  N(  P.  Q0  R1  U5  X9  Y;  [?  \C  ]G  ^L  aP  cT  dX  eZ  f^  gb  hd  if  kg  lk  mo  ps  qw  r|  v  w  x  y  z  {  |  }                                  	   
-                                                              $   %   (   )   ,   -             !  	 "  
- #   &   *   .   1   7   9   <   ?    A  ! D  ) E  * H  + J  , M  0 S  1 V  2 X  3 Z  4 \  5 `  9 c  : g  ; j  < n  = r  B t  C v  D y  E }  J   K   L   M   N   S   T   X   Y   _   `   a   b   c   g   h                                                                                              !   &   (   +   .   0   3   6   :   <   A   C   G   K   M   O   S   V   Z   ]   b   f   j   m   o   q   u   w   {                                                                    ,     O:\updasm\contrib\masmx86\gvmat32.obj 4            
- Microsoft (R) Macro Assembler   8                             _longest_match_686         LastMatchGood         LookaheadLess         LimitPositive         LookupLoop         LoopEntry         LoopCmps         LeaveLoopCmps4         LeaveLoopCmps         LenLower         LongerMatch         LenMaximum         LeaveNow         LookaheadRet   2             >      >            _cpudetect32         exitcpudetect         end_cpu_is_386         is_old_486   9                             _longest_match_7fff         noshr         nolookaheadnicematch         nodist         normalbeg0add16         normalbeg0         rcontlabnoroll         normalbeg2noroll         contloop3         jnbexitloopshort1         beginloop2         do16         rcontloop0         rcontloop1         rcontloop2         rcontloop3         rcontloop4         rcontloop5         rcontloop6         rcontloop7         rcontloop8         rcontloop9         rcontloop10         rcontloop11         rcontloop12         rcontloop13         rcontloop14         rcontloop15         normalbeg2dc11         normalbeg2dc12         normalbeg2dc13         normalbeg2dc14         normalbeg2dc15         normalbeg2dc10         normalbeg2dc9         normalbeg2dc8         normalbeg2dc7         normalbeg2dc6         normalbeg2dc5         normalbeg2dc4         normalbeg2dc3         normalbeg2dc2         normalbeg2dc1         normalbeg2dc0         normalbeg2         iseq         eq1rr         eq1         eq11         begincompare         trfin         trfinval         newbestlen         exitloop         minexlo         InfoAuthor                
-    "       "   
-    #       #   
-    $       $   
-    %       %   
-   &      &   
- $  '    (  '   
- 8  (    <  (   
- R  )    V  )   
- k  *    o  *   
-   +      +   
-   ,      ,   
-   -      -   
-   .      .   
-            
-   /      /   
- )  0    -  0   
- C  1    G  1   
- y      }     
-   2      2   
-   3      3   
-   4      4   
-   5      5   
-   6      6   
-   7      7   
- &  8    *  8   
- B  9    F  9   
- W  :    [  :   
- t  ;    x  ;   
-   <      <   
-   =      =   
-   >      >   
-   ?      ?   
-   @      @   
-   A      A   
-   B      B   
-   C    "  C   
- 4  D    8  D   
- J  E    N  E   
- `  F    d  F   
- v  G    z  G   
-   H      H   
-   I      I   
-   J      J   
-   K      K   
-   L      L   
-    M      M   
-   N      N   
- 4  O    8  O   
- N  P    R  P   
- h  Q    l  Q   
-   R      R   
-   S      S   
-   T      T   
-   U      U   
-   V      V   
-    W      W   
-   X      X   
- 2  Y    6  Y   
- K  Z    O  Z   
- d  [    h  [   
- }  \      \   
-   ]      ]   
-   ^      ^   
-   _      _   
-   `      `   
-   a      a   
-   b      b   
-   c      c   
-   d      d   
- )  e    -  e   
- ?  f    C  f   
- S  g    W  g   
- f  h    j  h   
-                          }              \          .file         gO:\updasm\contrib\masmx86\gvmat32.asm                 @comp.id    .text              ]          .data                            .debug$S       |               .debug$T       T                                           .bf            e                .lf           e .ef          e                               >          .bf          e    (           .lf     !      e .ef          e    U                %                     .bf          e                .lf           e .ef          e                    8   D          F   \          T             b             m         LoopCmps          w                !      LenLower.             b                   LeaveNow                                                          noshr                 2       nodist  o                                                                0             :             L         do16               W             b            m  4          x  O            j                                                                                    #            :            Q            h                                              +            :            I            X            g            u              0            D            U            f            w                                                      iseq          eq1rr         eq1           eq11                      trfin   1      trfinval5            L      exitloop|      minexlo                   !  _longest_match_7fff _cpudetect32 _longest_match_686 LastMatchGood LookaheadLess LimitPositive LookupLoop LoopEntry LeaveLoopCmps4 LeaveLoopCmps LongerMatch LenMaximum LookaheadRet exitcpudetect end_cpu_is_386 is_old_486 nolookaheadnicematch normalbeg0add16 normalbeg0 rcontlabnoroll normalbeg2noroll contloop3 jnbexitloopshort1 beginloop2 rcontloop0 rcontloop1 rcontloop2 rcontloop3 rcontloop4 rcontloop5 rcontloop6 rcontloop7 rcontloop8 rcontloop9 rcontloop10 rcontloop11 rcontloop12 rcontloop13 rcontloop14 rcontloop15 normalbeg2dc11 normalbeg2dc12 normalbeg2dc13 normalbeg2dc14 normalbeg2dc15 normalbeg2dc10 normalbeg2dc9 normalbeg2dc8 normalbeg2dc7 normalbeg2dc6 normalbeg2dc5 normalbeg2dc4 normalbeg2dc3 normalbeg2dc2 normalbeg2dc1 normalbeg2dc0 normalbeg2 begincompare newbestlen InfoAuthor 
\ No newline at end of file
diff -Nbaur gcc-4.6.3/zlib/contrib/masmx86/inffas32.asm gcc-4.6.3-psp/zlib/contrib/masmx86/inffas32.asm
--- gcc-4.6.3/zlib/contrib/masmx86/inffas32.asm	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/masmx86/inffas32.asm	1970-01-01 01:00:00.000000000 +0100
@@ -1,1083 +0,0 @@
-;/* inffas32.asm is a hand tuned assembler version of inffast.c -- fast decoding
-; *
-; * inffas32.asm is derivated from inffas86.c, with translation of assembly code
-; *
-; * Copyright (C) 1995-2003 Mark Adler
-; * For conditions of distribution and use, see copyright notice in zlib.h
-; *
-; * Copyright (C) 2003 Chris Anderson <christop@charm.net>
-; * Please use the copyright conditions above.
-; *
-; * Mar-13-2003 -- Most of this is derived from inffast.S which is derived from
-; * the gcc -S output of zlib-1.2.0/inffast.c.  Zlib-1.2.0 is in beta release at
-; * the moment.  I have successfully compiled and tested this code with gcc2.96,
-; * gcc3.2, icc5.0, msvc6.0.  It is very close to the speed of inffast.S
-; * compiled with gcc -DNO_MMX, but inffast.S is still faster on the P3 with MMX
-; * enabled.  I will attempt to merge the MMX code into this version.  Newer
-; * versions of this and inffast.S can be found at
-; * http://www.eetbeetee.com/zlib/ and http://www.charm.net/~christop/zlib/
-; * 
-; * 2005 : modification by Gilles Vollant
-; */
-; For Visual C++ 4.x and higher and ML 6.x and higher
-;   ml.exe is in directory \MASM611C of Win95 DDK
-;   ml.exe is also distributed in http://www.masm32.com/masmdl.htm
-;    and in VC++2003 toolkit at http://msdn.microsoft.com/visualc/vctoolkit2003/
-;
-;
-;   compile with command line option
-;   ml  /coff /Zi /c /Flinffas32.lst inffas32.asm
-
-;   if you define NO_GZIP (see inflate.h), compile with
-;   ml  /coff /Zi /c /Flinffas32.lst /DNO_GUNZIP inffas32.asm
-
-
-; zlib122sup is 0 fort zlib 1.2.2.1 and lower
-; zlib122sup is 8 fort zlib 1.2.2.2 and more (with addition of dmax and head 
-;        in inflate_state in inflate.h)
-zlib1222sup      equ    8
-
-
-IFDEF GUNZIP
-  INFLATE_MODE_TYPE    equ 11
-  INFLATE_MODE_BAD     equ 26
-ELSE
-  IFNDEF NO_GUNZIP
-    INFLATE_MODE_TYPE    equ 11
-    INFLATE_MODE_BAD     equ 26
-  ELSE
-    INFLATE_MODE_TYPE    equ 3
-    INFLATE_MODE_BAD     equ 17
-  ENDIF
-ENDIF
-
-
-; 75 "inffast.S"
-;FILE "inffast.S"
-
-;;;GLOBAL _inflate_fast
-
-;;;SECTION .text
-
-
-
-	.586p
-	.mmx
-
-	name	inflate_fast_x86
-	.MODEL	FLAT
-
-_DATA			segment
-inflate_fast_use_mmx:
-	dd	1
-
-
-_TEXT			segment
-PUBLIC _inflate_fast
-
-ALIGN 4
-_inflate_fast:
-	jmp inflate_fast_entry
-
-
-
-ALIGN 4
-	db	'Fast decoding Code from Chris Anderson'
-	db	0
-
-ALIGN 4
-invalid_literal_length_code_msg:
-	db	'invalid literal/length code'
-	db	0
-
-ALIGN 4
-invalid_distance_code_msg:
-	db	'invalid distance code'
-	db	0
-
-ALIGN 4
-invalid_distance_too_far_msg:
-	db	'invalid distance too far back'
-	db	0
-
-
-ALIGN 4
-inflate_fast_mask:
-dd	0
-dd	1
-dd	3
-dd	7
-dd	15
-dd	31
-dd	63
-dd	127
-dd	255
-dd	511
-dd	1023
-dd	2047
-dd	4095
-dd	8191
-dd	16383
-dd	32767
-dd	65535
-dd	131071
-dd	262143
-dd	524287
-dd	1048575
-dd	2097151
-dd	4194303
-dd	8388607
-dd	16777215
-dd	33554431
-dd	67108863
-dd	134217727
-dd	268435455
-dd	536870911
-dd	1073741823
-dd	2147483647
-dd	4294967295
-
-
-mode_state	 equ	0	;/* state->mode	*/
-wsize_state	 equ	(32+zlib1222sup)	;/* state->wsize */
-write_state	 equ	(36+4+zlib1222sup)	;/* state->write */
-window_state	 equ	(40+4+zlib1222sup)	;/* state->window */
-hold_state	 equ	(44+4+zlib1222sup)	;/* state->hold	*/
-bits_state	 equ	(48+4+zlib1222sup)	;/* state->bits	*/
-lencode_state	 equ	(64+4+zlib1222sup)	;/* state->lencode */
-distcode_state	 equ	(68+4+zlib1222sup)	;/* state->distcode */
-lenbits_state	 equ	(72+4+zlib1222sup)	;/* state->lenbits */
-distbits_state	 equ	(76+4+zlib1222sup)	;/* state->distbits */
-
-
-;;SECTION .text
-; 205 "inffast.S"
-;GLOBAL	inflate_fast_use_mmx
-
-;SECTION .data
-
-
-; GLOBAL inflate_fast_use_mmx:object
-;.size inflate_fast_use_mmx, 4
-; 226 "inffast.S"
-;SECTION .text
-
-ALIGN 4
-inflate_fast_entry:
-	push  edi
-	push  esi
-	push  ebp
-	push  ebx
-	pushfd
-	sub  esp,64
-	cld
-
-
-
-
-	mov  esi, [esp+88]
-	mov  edi, [esi+28]
-
-
-
-
-
-
-
-	mov  edx, [esi+4]
-	mov  eax, [esi+0]
-
-	add  edx,eax
-	sub  edx,11
-
-	mov  [esp+44],eax
-	mov  [esp+20],edx
-
-	mov  ebp, [esp+92]
-	mov  ecx, [esi+16]
-	mov  ebx, [esi+12]
-
-	sub  ebp,ecx
-	neg  ebp
-	add  ebp,ebx
-
-	sub  ecx,257
-	add  ecx,ebx
-
-	mov  [esp+60],ebx
-	mov  [esp+40],ebp
-	mov  [esp+16],ecx
-; 285 "inffast.S"
-	mov  eax, [edi+lencode_state]
-	mov  ecx, [edi+distcode_state]
-
-	mov  [esp+8],eax
-	mov  [esp+12],ecx
-
-	mov  eax,1
-	mov  ecx, [edi+lenbits_state]
-	shl  eax,cl
-	dec  eax
-	mov  [esp+0],eax
-
-	mov  eax,1
-	mov  ecx, [edi+distbits_state]
-	shl  eax,cl
-	dec  eax
-	mov  [esp+4],eax
-
-	mov  eax, [edi+wsize_state]
-	mov  ecx, [edi+write_state]
-	mov  edx, [edi+window_state]
-
-	mov  [esp+52],eax
-	mov  [esp+48],ecx
-	mov  [esp+56],edx
-
-	mov  ebp, [edi+hold_state]
-	mov  ebx, [edi+bits_state]
-; 321 "inffast.S"
-	mov  esi, [esp+44]
-	mov  ecx, [esp+20]
-	cmp  ecx,esi
-	ja   L_align_long
-
-	add  ecx,11
-	sub  ecx,esi
-	mov  eax,12
-	sub  eax,ecx
-	lea  edi, [esp+28]
-	rep movsb
-	mov  ecx,eax
-	xor  eax,eax
-	rep stosb
-	lea  esi, [esp+28]
-	mov  [esp+20],esi
-	jmp  L_is_aligned
-
-
-L_align_long:
-	test  esi,3
-	jz   L_is_aligned
-	xor  eax,eax
-	mov  al, [esi]
-	inc  esi
-	mov  ecx,ebx
-	add  ebx,8
-	shl  eax,cl
-	or  ebp,eax
-	jmp L_align_long
-
-L_is_aligned:
-	mov  edi, [esp+60]
-; 366 "inffast.S"
-L_check_mmx:
-	cmp  dword ptr [inflate_fast_use_mmx],2
-	je   L_init_mmx
-	ja   L_do_loop
-
-	push  eax
-	push  ebx
-	push  ecx
-	push  edx
-	pushfd
-	mov  eax, [esp]
-	xor  dword ptr [esp],0200000h
-
-
-
-
-	popfd
-	pushfd
-	pop  edx
-	xor  edx,eax
-	jz   L_dont_use_mmx
-	xor  eax,eax
-	cpuid
-	cmp  ebx,0756e6547h
-	jne  L_dont_use_mmx
-	cmp  ecx,06c65746eh
-	jne  L_dont_use_mmx
-	cmp  edx,049656e69h
-	jne  L_dont_use_mmx
-	mov  eax,1
-	cpuid
-	shr  eax,8
-	and  eax,15
-	cmp  eax,6
-	jne  L_dont_use_mmx
-	test  edx,0800000h
-	jnz  L_use_mmx
-	jmp  L_dont_use_mmx
-L_use_mmx:
-	mov  dword ptr [inflate_fast_use_mmx],2
-	jmp  L_check_mmx_pop
-L_dont_use_mmx:
-	mov  dword ptr [inflate_fast_use_mmx],3
-L_check_mmx_pop:
-	pop  edx
-	pop  ecx
-	pop  ebx
-	pop  eax
-	jmp  L_check_mmx
-; 426 "inffast.S"
-ALIGN 4
-L_do_loop:
-; 437 "inffast.S"
-	cmp  bl,15
-	ja   L_get_length_code
-
-	xor  eax,eax
-	lodsw
-	mov  cl,bl
-	add  bl,16
-	shl  eax,cl
-	or  ebp,eax
-
-L_get_length_code:
-	mov  edx, [esp+0]
-	mov  ecx, [esp+8]
-	and  edx,ebp
-	mov  eax, [ecx+edx*4]
-
-L_dolen:
-
-
-
-
-
-
-	mov  cl,ah
-	sub  bl,ah
-	shr  ebp,cl
-
-
-
-
-
-
-	test  al,al
-	jnz   L_test_for_length_base
-
-	shr  eax,16
-	stosb
-
-L_while_test:
-
-
-	cmp  [esp+16],edi
-	jbe  L_break_loop
-
-	cmp  [esp+20],esi
-	ja   L_do_loop
-	jmp  L_break_loop
-
-L_test_for_length_base:
-; 502 "inffast.S"
-	mov  edx,eax
-	shr  edx,16
-	mov  cl,al
-
-	test  al,16
-	jz   L_test_for_second_level_length
-	and  cl,15
-	jz   L_save_len
-	cmp  bl,cl
-	jae  L_add_bits_to_len
-
-	mov  ch,cl
-	xor  eax,eax
-	lodsw
-	mov  cl,bl
-	add  bl,16
-	shl  eax,cl
-	or  ebp,eax
-	mov  cl,ch
-
-L_add_bits_to_len:
-	mov  eax,1
-	shl  eax,cl
-	dec  eax
-	sub  bl,cl
-	and  eax,ebp
-	shr  ebp,cl
-	add  edx,eax
-
-L_save_len:
-	mov  [esp+24],edx
-
-
-L_decode_distance:
-; 549 "inffast.S"
-	cmp  bl,15
-	ja   L_get_distance_code
-
-	xor  eax,eax
-	lodsw
-	mov  cl,bl
-	add  bl,16
-	shl  eax,cl
-	or  ebp,eax
-
-L_get_distance_code:
-	mov  edx, [esp+4]
-	mov  ecx, [esp+12]
-	and  edx,ebp
-	mov  eax, [ecx+edx*4]
-
-
-L_dodist:
-	mov  edx,eax
-	shr  edx,16
-	mov  cl,ah
-	sub  bl,ah
-	shr  ebp,cl
-; 584 "inffast.S"
-	mov  cl,al
-
-	test  al,16
-	jz  L_test_for_second_level_dist
-	and  cl,15
-	jz  L_check_dist_one
-	cmp  bl,cl
-	jae  L_add_bits_to_dist
-
-	mov  ch,cl
-	xor  eax,eax
-	lodsw
-	mov  cl,bl
-	add  bl,16
-	shl  eax,cl
-	or  ebp,eax
-	mov  cl,ch
-
-L_add_bits_to_dist:
-	mov  eax,1
-	shl  eax,cl
-	dec  eax
-	sub  bl,cl
-	and  eax,ebp
-	shr  ebp,cl
-	add  edx,eax
-	jmp  L_check_window
-
-L_check_window:
-; 625 "inffast.S"
-	mov  [esp+44],esi
-	mov  eax,edi
-	sub  eax, [esp+40]
-
-	cmp  eax,edx
-	jb   L_clip_window
-
-	mov  ecx, [esp+24]
-	mov  esi,edi
-	sub  esi,edx
-
-	sub  ecx,3
-	mov  al, [esi]
-	mov  [edi],al
-	mov  al, [esi+1]
-	mov  dl, [esi+2]
-	add  esi,3
-	mov  [edi+1],al
-	mov  [edi+2],dl
-	add  edi,3
-	rep movsb
-
-	mov  esi, [esp+44]
-	jmp  L_while_test
-
-ALIGN 4
-L_check_dist_one:
-	cmp  edx,1
-	jne  L_check_window
-	cmp  [esp+40],edi
-	je  L_check_window
-
-	dec  edi
-	mov  ecx, [esp+24]
-	mov  al, [edi]
-	sub  ecx,3
-
-	mov  [edi+1],al
-	mov  [edi+2],al
-	mov  [edi+3],al
-	add  edi,4
-	rep stosb
-
-	jmp  L_while_test
-
-ALIGN 4
-L_test_for_second_level_length:
-
-
-
-
-	test  al,64
-	jnz   L_test_for_end_of_block
-
-	mov  eax,1
-	shl  eax,cl
-	dec  eax
-	and  eax,ebp
-	add  eax,edx
-	mov  edx, [esp+8]
-	mov  eax, [edx+eax*4]
-	jmp  L_dolen
-
-ALIGN 4
-L_test_for_second_level_dist:
-
-
-
-
-	test  al,64
-	jnz   L_invalid_distance_code
-
-	mov  eax,1
-	shl  eax,cl
-	dec  eax
-	and  eax,ebp
-	add  eax,edx
-	mov  edx, [esp+12]
-	mov  eax, [edx+eax*4]
-	jmp  L_dodist
-
-ALIGN 4
-L_clip_window:
-; 721 "inffast.S"
-	mov  ecx,eax
-	mov  eax, [esp+52]
-	neg  ecx
-	mov  esi, [esp+56]
-
-	cmp  eax,edx
-	jb   L_invalid_distance_too_far
-
-	add  ecx,edx
-	cmp  dword ptr [esp+48],0
-	jne  L_wrap_around_window
-
-	sub  eax,ecx
-	add  esi,eax
-; 749 "inffast.S"
-	mov  eax, [esp+24]
-	cmp  eax,ecx
-	jbe  L_do_copy1
-
-	sub  eax,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,edx
-	jmp  L_do_copy1
-
-	cmp  eax,ecx
-	jbe  L_do_copy1
-
-	sub  eax,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,edx
-	jmp  L_do_copy1
-
-L_wrap_around_window:
-; 793 "inffast.S"
-	mov  eax, [esp+48]
-	cmp  ecx,eax
-	jbe  L_contiguous_in_window
-
-	add  esi, [esp+52]
-	add  esi,eax
-	sub  esi,ecx
-	sub  ecx,eax
-
-
-	mov  eax, [esp+24]
-	cmp  eax,ecx
-	jbe  L_do_copy1
-
-	sub  eax,ecx
-	rep movsb
-	mov  esi, [esp+56]
-	mov  ecx, [esp+48]
-	cmp  eax,ecx
-	jbe  L_do_copy1
-
-	sub  eax,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,edx
-	jmp  L_do_copy1
-
-L_contiguous_in_window:
-; 836 "inffast.S"
-	add  esi,eax
-	sub  esi,ecx
-
-
-	mov  eax, [esp+24]
-	cmp  eax,ecx
-	jbe  L_do_copy1
-
-	sub  eax,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,edx
-
-L_do_copy1:
-; 862 "inffast.S"
-	mov  ecx,eax
-	rep movsb
-
-	mov  esi, [esp+44]
-	jmp  L_while_test
-; 878 "inffast.S"
-ALIGN 4
-L_init_mmx:
-	emms
-
-
-
-
-
-	movd mm0,ebp
-	mov  ebp,ebx
-; 896 "inffast.S"
-	movd mm4,[esp+0]
-	movq mm3,mm4
-	movd mm5,[esp+4]
-	movq mm2,mm5
-	pxor mm1,mm1
-	mov  ebx, [esp+8]
-	jmp  L_do_loop_mmx
-
-ALIGN 4
-L_do_loop_mmx:
-	psrlq mm0,mm1
-
-	cmp  ebp,32
-	ja  L_get_length_code_mmx
-
-	movd mm6,ebp
-	movd mm7,[esi]
-	add  esi,4
-	psllq mm7,mm6
-	add  ebp,32
-	por mm0,mm7
-
-L_get_length_code_mmx:
-	pand mm4,mm0
-	movd eax,mm4
-	movq mm4,mm3
-	mov  eax, [ebx+eax*4]
-
-L_dolen_mmx:
-	movzx  ecx,ah
-	movd mm1,ecx
-	sub  ebp,ecx
-
-	test  al,al
-	jnz L_test_for_length_base_mmx
-
-	shr  eax,16
-	stosb
-
-L_while_test_mmx:
-
-
-	cmp  [esp+16],edi
-	jbe L_break_loop
-
-	cmp  [esp+20],esi
-	ja L_do_loop_mmx
-	jmp L_break_loop
-
-L_test_for_length_base_mmx:
-
-	mov  edx,eax
-	shr  edx,16
-
-	test  al,16
-	jz  L_test_for_second_level_length_mmx
-	and  eax,15
-	jz L_decode_distance_mmx
-
-	psrlq mm0,mm1
-	movd mm1,eax
-	movd ecx,mm0
-	sub  ebp,eax
-	and  ecx, [inflate_fast_mask+eax*4]
-	add  edx,ecx
-
-L_decode_distance_mmx:
-	psrlq mm0,mm1
-
-	cmp  ebp,32
-	ja L_get_dist_code_mmx
-
-	movd mm6,ebp
-	movd mm7,[esi]
-	add  esi,4
-	psllq mm7,mm6
-	add  ebp,32
-	por mm0,mm7
-
-L_get_dist_code_mmx:
-	mov  ebx, [esp+12]
-	pand mm5,mm0
-	movd eax,mm5
-	movq mm5,mm2
-	mov  eax, [ebx+eax*4]
-
-L_dodist_mmx:
-
-	movzx  ecx,ah
-	mov  ebx,eax
-	shr  ebx,16
-	sub  ebp,ecx
-	movd mm1,ecx
-
-	test  al,16
-	jz L_test_for_second_level_dist_mmx
-	and  eax,15
-	jz L_check_dist_one_mmx
-
-L_add_bits_to_dist_mmx:
-	psrlq mm0,mm1
-	movd mm1,eax
-	movd ecx,mm0
-	sub  ebp,eax
-	and  ecx, [inflate_fast_mask+eax*4]
-	add  ebx,ecx
-
-L_check_window_mmx:
-	mov  [esp+44],esi
-	mov  eax,edi
-	sub  eax, [esp+40]
-
-	cmp  eax,ebx
-	jb L_clip_window_mmx
-
-	mov  ecx,edx
-	mov  esi,edi
-	sub  esi,ebx
-
-	sub  ecx,3
-	mov  al, [esi]
-	mov  [edi],al
-	mov  al, [esi+1]
-	mov  dl, [esi+2]
-	add  esi,3
-	mov  [edi+1],al
-	mov  [edi+2],dl
-	add  edi,3
-	rep movsb
-
-	mov  esi, [esp+44]
-	mov  ebx, [esp+8]
-	jmp  L_while_test_mmx
-
-ALIGN 4
-L_check_dist_one_mmx:
-	cmp  ebx,1
-	jne  L_check_window_mmx
-	cmp  [esp+40],edi
-	je   L_check_window_mmx
-
-	dec  edi
-	mov  ecx,edx
-	mov  al, [edi]
-	sub  ecx,3
-
-	mov  [edi+1],al
-	mov  [edi+2],al
-	mov  [edi+3],al
-	add  edi,4
-	rep stosb
-
-	mov  ebx, [esp+8]
-	jmp  L_while_test_mmx
-
-ALIGN 4
-L_test_for_second_level_length_mmx:
-	test  al,64
-	jnz L_test_for_end_of_block
-
-	and  eax,15
-	psrlq mm0,mm1
-	movd ecx,mm0
-	and  ecx, [inflate_fast_mask+eax*4]
-	add  ecx,edx
-	mov  eax, [ebx+ecx*4]
-	jmp L_dolen_mmx
-
-ALIGN 4
-L_test_for_second_level_dist_mmx:
-	test  al,64
-	jnz L_invalid_distance_code
-
-	and  eax,15
-	psrlq mm0,mm1
-	movd ecx,mm0
-	and  ecx, [inflate_fast_mask+eax*4]
-	mov  eax, [esp+12]
-	add  ecx,ebx
-	mov  eax, [eax+ecx*4]
-	jmp  L_dodist_mmx
-
-ALIGN 4
-L_clip_window_mmx:
-
-	mov  ecx,eax
-	mov  eax, [esp+52]
-	neg  ecx
-	mov  esi, [esp+56]
-
-	cmp  eax,ebx
-	jb  L_invalid_distance_too_far
-
-	add  ecx,ebx
-	cmp  dword ptr [esp+48],0
-	jne  L_wrap_around_window_mmx
-
-	sub  eax,ecx
-	add  esi,eax
-
-	cmp  edx,ecx
-	jbe  L_do_copy1_mmx
-
-	sub  edx,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,ebx
-	jmp  L_do_copy1_mmx
-
-	cmp  edx,ecx
-	jbe  L_do_copy1_mmx
-
-	sub  edx,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,ebx
-	jmp  L_do_copy1_mmx
-
-L_wrap_around_window_mmx:
-
-	mov  eax, [esp+48]
-	cmp  ecx,eax
-	jbe  L_contiguous_in_window_mmx
-
-	add  esi, [esp+52]
-	add  esi,eax
-	sub  esi,ecx
-	sub  ecx,eax
-
-
-	cmp  edx,ecx
-	jbe  L_do_copy1_mmx
-
-	sub  edx,ecx
-	rep movsb
-	mov  esi, [esp+56]
-	mov  ecx, [esp+48]
-	cmp  edx,ecx
-	jbe  L_do_copy1_mmx
-
-	sub  edx,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,ebx
-	jmp  L_do_copy1_mmx
-
-L_contiguous_in_window_mmx:
-
-	add  esi,eax
-	sub  esi,ecx
-
-
-	cmp  edx,ecx
-	jbe  L_do_copy1_mmx
-
-	sub  edx,ecx
-	rep movsb
-	mov  esi,edi
-	sub  esi,ebx
-
-L_do_copy1_mmx:
-
-
-	mov  ecx,edx
-	rep movsb
-
-	mov  esi, [esp+44]
-	mov  ebx, [esp+8]
-	jmp  L_while_test_mmx
-; 1174 "inffast.S"
-L_invalid_distance_code:
-
-
-
-
-
-	mov  ecx, invalid_distance_code_msg
-	mov  edx,INFLATE_MODE_BAD
-	jmp  L_update_stream_state
-
-L_test_for_end_of_block:
-
-
-
-
-
-	test  al,32
-	jz  L_invalid_literal_length_code
-
-	mov  ecx,0
-	mov  edx,INFLATE_MODE_TYPE
-	jmp  L_update_stream_state
-
-L_invalid_literal_length_code:
-
-
-
-
-
-	mov  ecx, invalid_literal_length_code_msg
-	mov  edx,INFLATE_MODE_BAD
-	jmp  L_update_stream_state
-
-L_invalid_distance_too_far:
-
-
-
-	mov  esi, [esp+44]
-	mov  ecx, invalid_distance_too_far_msg
-	mov  edx,INFLATE_MODE_BAD
-	jmp  L_update_stream_state
-
-L_update_stream_state:
-
-	mov  eax, [esp+88]
-	test  ecx,ecx
-	jz  L_skip_msg
-	mov  [eax+24],ecx
-L_skip_msg:
-	mov  eax, [eax+28]
-	mov  [eax+mode_state],edx
-	jmp  L_break_loop
-
-ALIGN 4
-L_break_loop:
-; 1243 "inffast.S"
-	cmp  dword ptr [inflate_fast_use_mmx],2
-	jne  L_update_next_in
-
-
-
-	mov  ebx,ebp
-
-L_update_next_in:
-; 1266 "inffast.S"
-	mov  eax, [esp+88]
-	mov  ecx,ebx
-	mov  edx, [eax+28]
-	shr  ecx,3
-	sub  esi,ecx
-	shl  ecx,3
-	sub  ebx,ecx
-	mov  [eax+12],edi
-	mov  [edx+bits_state],ebx
-	mov  ecx,ebx
-
-	lea  ebx, [esp+28]
-	cmp  [esp+20],ebx
-	jne  L_buf_not_used
-
-	sub  esi,ebx
-	mov  ebx, [eax+0]
-	mov  [esp+20],ebx
-	add  esi,ebx
-	mov  ebx, [eax+4]
-	sub  ebx,11
-	add  [esp+20],ebx
-
-L_buf_not_used:
-	mov  [eax+0],esi
-
-	mov  ebx,1
-	shl  ebx,cl
-	dec  ebx
-
-
-
-
-
-	cmp  dword ptr [inflate_fast_use_mmx],2
-	jne  L_update_hold
-
-
-
-	psrlq mm0,mm1
-	movd ebp,mm0
-
-	emms
-
-L_update_hold:
-
-
-
-	and  ebp,ebx
-	mov  [edx+hold_state],ebp
-
-
-
-
-	mov  ebx, [esp+20]
-	cmp  ebx,esi
-	jbe  L_last_is_smaller
-
-	sub  ebx,esi
-	add  ebx,11
-	mov  [eax+4],ebx
-	jmp  L_fixup_out
-L_last_is_smaller:
-	sub  esi,ebx
-	neg  esi
-	add  esi,11
-	mov  [eax+4],esi
-
-
-
-
-L_fixup_out:
-
-	mov  ebx, [esp+16]
-	cmp  ebx,edi
-	jbe  L_end_is_smaller
-
-	sub  ebx,edi
-	add  ebx,257
-	mov  [eax+16],ebx
-	jmp  L_done
-L_end_is_smaller:
-	sub  edi,ebx
-	neg  edi
-	add  edi,257
-	mov  [eax+16],edi
-
-
-
-
-
-L_done:
-	add  esp,64
-	popfd
-	pop  ebx
-	pop  ebp
-	pop  esi
-	pop  edi
-	ret
-
-_TEXT	ends
-end
diff -Nbaur gcc-4.6.3/zlib/contrib/masmx86/inffas32.obj gcc-4.6.3-psp/zlib/contrib/masmx86/inffas32.obj
--- gcc-4.6.3/zlib/contrib/masmx86/inffas32.obj	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/masmx86/inffas32.obj	1970-01-01 01:00:00.000000000 +0100
@@ -1,158 +0,0 @@
-L vB/  R       .text                P     Q  P`.data                          @ P.debug$S          %         @ B.debug$T          /              @ B  I Fast decoding Code from Chris Anderson invalid literal/length code invalid distance code invalid distance too far back                    ?                   ?           ?   ?WVUS@t$X~VD$,T$l$\N^+  \$<l$(L$GLOPD$L$   OTH$   OXHD$G(O0W4D$4L$0T$8o8_<t$,L$;w"+   +|$3t$t$   t3F|$<=      wkPSQR$4$    Z3tD3Genuu8ntelu0ineIu(   u   u       
-       ZY[Xw3f$L$#*u9|$b  9t$wW     t%8s3f   H*#T$w3fT$L$#*   te8s3f   H*# t$,+D$(;   L$+FVGWt$,u9|$(tOL$GGG@     H#T$@     H#T$D$4t$8;  |$0 u$+D$;v`++V;vR++HD$0;v,t$4++D$;v.+t$8L$0;v+++D$;v++t$,wnn$$nl$\$ wnn> ~n+u9|$  9t$w     tn~+#     wnn> \$~+n   tWn~+#    t$,+D$(;   +FVGWt$,\$-I u9|$(tOGGG\$ @   ~#    @   ~#    D$D$4t$8;   |$0 u +;vX++N;vJ++@D$0;v(t$4++;v*+t$8L$0;v+++;v++t$,\$$       , t              t$,        D$XtH@ =    uD$XP++xZ<\$9\$u+\$X\$0   K=    u~w#j8\$;v
-+X
-+p\$;v+  X+  x@[]^_       =      I            W                                          @             W 	  X 
-  Y   Z   [   \   ]   b   c   k   l   n   o "  q &  r *  t .  u 1  v 4  x 6  y 8  z :  | @  } B   F   J   N   Q   T   X   \   a   d   f   g   j   o   r   t   u   y   |                                                                                                                                                                              $   &   )   ,   /   1   7   9   ;   E   G   Q   R   S   T   U   X   [   ]   _   a   c   f   h   j  m  q  s  v  x  z  |  ~           !  #  $  %  )  *  +  -  .  /  0  1  2  4  5  6  7  8  9  :  ;  >  ?  @  A  B  C  D  G  L  M  O  P  Q  R  S  T  W  X  Y  Z  ^  _  `  a  b   d  f  g
-  h  i  j  k  m  n  o  p  q  r   s"  t$  w)  x+  y,  z.  {0  |2  }4  ~6  :  <  @  B  H  L  N  P  S  U  W  Z  ]  `  c  f  i  k  o  t  w  y  }                                                                                              	                      !  #  %  )  +   -  /  3  5  7  9  	;  
-?  C  E  G  I  K  M  O  Q  S  U  Y  [  ]  _   a  !c  "e  &g  'i  )m  *t  .v  4y  5{  7  8  9  :  ;  <  =  A  C  D  F  G  H  I  J  K  N  O  P  Q  T  U  V  X  Y  [  \  a  b  d  e  f  j  k  m  n  o  p  r  s  t  u  v  w  z  |  }              #  &  )  ,  /  2  4  7  9  <  >  D  G  I  L  O  R  T  [  ]  a  c  g  i  o  q  s  u  x  z  |                                                                                                 $  &  ,  .  3  5  7  9  ;   =  ?  A  C  E  G  I  	K  M  O  Q  S  U  Y  [  ]  a  c  e  g  i  k   m  !o  "s  #w  $y  %{  '}  (  )  *  +  /  0  3  4  6  7  8  9  >  ?  A  B  C  K  L  M  U  V  X  Y  Z  b  c  d  j  k  l  m  q  r  s  t  v  w  x  }  ~            	                   "  $  (  *  -  0  4  6  ;  =  >  E  G  J  M  O  Q  T  X  Z  \  ^  a  d  f  h  j  m  p  t  v  x  z                                   	    inffas32.obj6    /Microsoft (R) Macro Assembler Version 6.14.8444  	       L_test_for_length_base$ 	       L_invalid_distance_too_far 	       L_check_dist_one_mmx 	       L_do_copy1_mmx 	       L_wrap_around_window 	       
-L_do_copy1 	       L_add_bits_to_len 	       	L_do_loop' 	       L_invalid_literal_length_code# 	       invalid_distance_code_msg 	       L_get_length_code_mmx 	       _inflate_fast 	       
-L_init_mmx( 	       L_test_for_second_level_length 	       
-L_save_len  	       L_add_bits_to_dist_mmx 	       inflate_fast_mask 	       L_update_next_in 	       L_dodist 	       
-L_skip_msg 	       L_get_distance_code" 	       L_wrap_around_window_mmx 	       L_do_loop_mmx! 	       L_invalid_distance_code& 	       L_test_for_second_level_dist! 	       L_test_for_end_of_block) 	       invalid_literal_length_code_msg* 	        L_test_for_second_level_dist_mmx 	       L_clip_window_mmx 	       L_dolen_mmx 	       	L_use_mmx 	       L_break_loop 	       L_get_length_code 	       L_add_bits_to_dist 	       L_fixup_out 	       L_get_dist_code_mmx 	       L_clip_window,                           $$$00001) 	       invalid_literal_length_code_msg# 	       invalid_distance_code_msg& 	       invalid_distance_too_far_msg 	       inflate_fast_mask 	       inflate_fast_entry 	       L_align_long 	       L_is_aligned 	       L_check_mmx 	       	L_use_mmx 	       L_dont_use_mmx 	       L_check_mmx_pop 	       	L_do_loop 	       L_get_length_code 	       L_dolen 	       L_while_test  	       L_test_for_length_base 	       L_add_bits_to_len 	       
-L_save_len 	       L_decode_distance 	       L_get_distance_code 	       L_dodist 	       L_add_bits_to_dist 	       L_check_window 	       L_check_dist_one( 	       L_test_for_second_level_length& 	       L_test_for_second_level_dist 	       L_clip_window 	       L_wrap_around_window  	       L_contiguous_in_window 	       
-L_do_copy1 	       
-L_init_mmx 	       L_do_loop_mmx 	       L_get_length_code_mmx 	       L_dolen_mmx 	       L_while_test_mmx$ 	       L_test_for_length_base_mmx 	       L_decode_distance_mmx 	       L_get_dist_code_mmx 	       L_dodist_mmx  	       L_add_bits_to_dist_mmx 	       L_check_window_mmx 	       L_check_dist_one_mmx, 	       "L_test_for_second_level_length_mmx* 	        L_test_for_second_level_dist_mmx 	       L_clip_window_mmx" 	       L_wrap_around_window_mmx$ 	       L_contiguous_in_window_mmx 	       L_do_copy1_mmx! 	       L_invalid_distance_code! 	       L_test_for_end_of_block' 	       L_invalid_literal_length_code$ 	       L_invalid_distance_too_far 	       L_update_stream_state 	       
-L_skip_msg 	       L_break_loop 	       L_update_next_in 	       L_buf_not_used 	       L_update_hold 	       L_last_is_smaller 	       L_fixup_out 	       L_end_is_smaller 	       L_done   	       L_check_mmx 	       L_decode_distance_mmx 	       L_dont_use_mmx 	       L_is_aligned 	       L_check_window  	       L_contiguous_in_window 	       L_buf_not_used 	       L_update_stream_state 	       L_decode_distance 	       L_while_test 	       inflate_fast_use_mmx, 	       "L_test_for_second_level_length_mmx 	       L_check_dist_one 	       L_end_is_smaller 	       L_check_window_mmx 	       L_while_test_mmx 	       L_update_hold$ 	       L_test_for_length_base_mmx 	       L_dodist_mmx 	       L_align_long 	       inflate_fast_entry 	       L_dolen 	       L_last_is_smaller 	       L_check_mmx_pop 	       L_done$ 	       L_contiguous_in_window_mmx& 	       invalid_distance_too_far_msgU       Y      
- w       {      
-              
-              
-              
-              
-            
- *      .     
- ?       C      
- h      l     
-   !      !   
-            
-   "      "   
-   #      #   
-   $      $   
-   %    !  %   
- ?      C     
- \  &    `  &   
- x  '    |  '   
-   (      (   
-   )      )   
-   *      *   
-   +      +   
-   ,      ,   
- !  -    %  -   
- I  .    M  .   
- l      p     
-   /      /   
-   0      0   
-   1      1   
-   2      2   
-   3      3   
- $  4    (  4   
- A  5    E  5   
- _  6    c  6   
- v  7    z  7   
-   8      8   
-            
-            
-            
- ,      0     
- T      X     
- q  9    u  9   
-   :      :   
-   ;      ;   
-   <      <   
-   2      2   
-   =      =   
-   >    	  >   
-        $     
- 5  4    9  4   
- R  ?    V  ?   
- e  @    i  @   
- }           
-            
-   $      $   
-   A      A   
-   )      )   
-   '      '   
- "  5    &  5   
- @  B    D  B   
- Z  C    ^  C   
- v  #    z  #   
-   -      -   
-   8      8   
-            
-   D      D   
- #      '     
- 9  "    =  "   
- O  +    S  +   
- h  !    l  !   
-   1      1   
-   E      E   
-   F      F   
-   G      G   
- 	  7    	  7   
- "	  H    &	  H   
- :	  %    >	  %   
- \	  I    `	  I   
- z	      ~	     
- 	  J    	  J   
- 	  /    	  /   
- 	  0    	  0   
- 
-  *    
-  *   
- 5
-  K    9
-  K   
- [
-      _
-     
- u
-  ,    y
-  ,   
- 
-  .    
-  .   
- 
-       
-      
- 
-      
-     
- 
-  L      L   
- +  (    /  (   
- A  3    E  3   
- Y  &    ]  &   
- u  M    y  M   
-   N      N   
-   O      O   
-   6      6   
-   P      P   
-   Q      Q   
-   <      <   
- %  G    )  G   
- F  =    J  =   
- `  ;    d  ;   
- x  B    |  B   
-   D      D   
-   M      M   
-   L      L   
-   A      A   
-   @      @   
- $      (     
- D  J    H  J   
- r  C    v  C   
-   P      P   
-   I      I   
-   E      E   
-   N      N   
-   F      F   
- #  H    '  H   
- ;  :    ?  :   
- S  9    W  9   
- q  ?    u  ?   
-   O      O   
-   >      >   
-   Q      Q   
-   K      K   
-            
-        
-          .file         ginffas32.asm      @comp.id     .text             Q          .data                           .debug$S                      .debug$T                                L                          ,              >   0           ^               s   d       $$$00001                    .bf            e    P             .lf     Q     e .ef          e    8                                                                                    e                        X          "            @            V  t          a                          I                  L_dodist                                    U                                              .            F            g            y              ;                        j            $            p                                                                                  (  G          7  Q      L_dolen v          G            T            f  6          u  t            Q                                                /            ]                      "            =            S  4          b  O          p  f                  L_done          invalid_distance_code_msg _inflate_fast inflate_fast_mask invalid_literal_length_code_msg inflate_fast_use_mmx invalid_distance_too_far_msg L_test_for_length_base L_invalid_distance_too_far L_check_dist_one_mmx L_do_copy1_mmx L_wrap_around_window L_do_copy1 L_add_bits_to_len L_do_loop L_invalid_literal_length_code L_get_length_code_mmx L_init_mmx L_test_for_second_level_length L_save_len L_add_bits_to_dist_mmx L_update_next_in L_skip_msg L_get_distance_code L_wrap_around_window_mmx L_do_loop_mmx L_invalid_distance_code L_test_for_second_level_dist L_test_for_end_of_block L_test_for_second_level_dist_mmx L_clip_window_mmx L_dolen_mmx L_use_mmx L_break_loop L_get_length_code L_add_bits_to_dist L_fixup_out L_get_dist_code_mmx L_clip_window inflate_fast_entry L_align_long L_is_aligned L_check_mmx L_dont_use_mmx L_check_mmx_pop L_while_test L_decode_distance L_check_window L_check_dist_one L_contiguous_in_window L_while_test_mmx L_test_for_length_base_mmx L_decode_distance_mmx L_dodist_mmx L_check_window_mmx L_test_for_second_level_length_mmx L_contiguous_in_window_mmx L_update_stream_state L_buf_not_used L_update_hold L_last_is_smaller L_end_is_smaller 
\ No newline at end of file
diff -Nbaur gcc-4.6.3/zlib/contrib/masmx86/mkasm.bat gcc-4.6.3-psp/zlib/contrib/masmx86/mkasm.bat
--- gcc-4.6.3/zlib/contrib/masmx86/mkasm.bat	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/masmx86/mkasm.bat	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-cl /DASMV /I..\.. /O2 /c gvmat32c.c
-ml /coff /Zi /c /Flgvmat32.lst gvmat32.asm
-ml /coff /Zi /c /Flinffas32.lst inffas32.asm
diff -Nbaur gcc-4.6.3/zlib/contrib/masmx86/readme.txt gcc-4.6.3-psp/zlib/contrib/masmx86/readme.txt
--- gcc-4.6.3/zlib/contrib/masmx86/readme.txt	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/masmx86/readme.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-
-Summary
--------
-This directory contains ASM implementations of the functions
-longest_match() and inflate_fast().
-
-
-Use instructions
-----------------
-Copy these files into the zlib source directory, then run the
-appropriate makefile, as suggested below.
-
-
-Build instructions
-------------------
-* With Microsoft C and MASM:
-nmake -f win32/Makefile.msc LOC="-DASMV -DASMINF" OBJA="gvmat32c.obj gvmat32.obj inffas32.obj"
-
-* With Borland C and TASM:
-make -f win32/Makefile.bor LOCAL_ZLIB="-DASMV -DASMINF" OBJA="gvmat32c.obj gvmat32.obj inffas32.obj" OBJPA="+gvmat32c.obj+gvmat32.obj+inffas32.obj"
-
diff -Nbaur gcc-4.6.3/zlib/contrib/minizip/ChangeLogUnzip gcc-4.6.3-psp/zlib/contrib/minizip/ChangeLogUnzip
--- gcc-4.6.3/zlib/contrib/minizip/ChangeLogUnzip	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/minizip/ChangeLogUnzip	1970-01-01 01:00:00.000000000 +0100
@@ -1,67 +0,0 @@
-Change in 1.01e (12 feb 05)
-- Fix in zipOpen2 for globalcomment (Rolf Kalbermatter)
-- Fix possible memory leak in unzip.c (Zoran Stevanovic)
-
-Change in 1.01b (20 may 04)
-- Integrate patch from Debian package (submited by Mark Brown)
-- Add tools mztools from Xavier Roche
-
-Change in 1.01 (8 may 04)
-- fix buffer overrun risk in unzip.c (Xavier Roche)
-- fix a minor buffer insecurity in minizip.c (Mike Whittaker)
-
-Change in 1.00: (10 sept 03)
-- rename to 1.00
-- cosmetic code change
-
-Change in 0.22: (19 May 03)
-- crypting support (unless you define NOCRYPT)
-- append file in existing zipfile
-
-Change in 0.21: (10 Mar 03)
-- bug fixes
-
-Change in 0.17: (27 Jan 02)
-- bug fixes
-
-Change in 0.16: (19 Jan 02)
-- Support of ioapi for virtualize zip file access
-
-Change in 0.15: (19 Mar 98)
-- fix memory leak in minizip.c
-
-Change in 0.14: (10 Mar 98)
-- fix bugs in minizip.c sample for zipping big file
-- fix problem in month in date handling
-- fix bug in unzlocal_GetCurrentFileInfoInternal in unzip.c for
-    comment handling
-
-Change in 0.13: (6 Mar 98)
-- fix bugs in zip.c
-- add real minizip sample
-
-Change in 0.12: (4 Mar 98)
-- add zip.c and zip.h for creates .zip file
-- fix change_file_date in miniunz.c for Unix (Jean-loup Gailly)
-- fix miniunz.c for file without specific record for directory
-
-Change in 0.11: (3 Mar 98)
-- fix bug in unzGetCurrentFileInfo for get extra field and comment
-- enhance miniunz sample, remove the bad unztst.c sample
-
-Change in 0.10: (2 Mar 98)
-- fix bug in unzReadCurrentFile
-- rename unzip* to unz* function and structure
-- remove Windows-like hungary notation variable name
-- modify some structure in unzip.h
-- add somes comment in source
-- remove unzipGetcCurrentFile function
-- replace ZUNZEXPORT by ZEXPORT
-- add unzGetLocalExtrafield for get the local extrafield info
-- add a new sample, miniunz.c
-
-Change in 0.4: (25 Feb 98)
-- suppress the type unzipFileInZip.
-  Only on file in the zipfile can be open at the same time
-- fix somes typo in code
-- added tm_unz structure in unzip_file_info (date/time in readable format)
diff -Nbaur gcc-4.6.3/zlib/contrib/minizip/crypt.h gcc-4.6.3-psp/zlib/contrib/minizip/crypt.h
--- gcc-4.6.3/zlib/contrib/minizip/crypt.h	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/minizip/crypt.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,132 +0,0 @@
-/* crypt.h -- base code for crypt/uncrypt ZIPfile
-
-
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-
-   This code is a modified version of crypting code in Infozip distribution
-
-   The encryption/decryption parts of this source code (as opposed to the
-   non-echoing password parts) were originally written in Europe.  The
-   whole source package can be freely distributed, including from the USA.
-   (Prior to January 2000, re-export from the US was a violation of US law.)
-
-   This encryption code is a direct transcription of the algorithm from
-   Roger Schlafly, described by Phil Katz in the file appnote.txt.  This
-   file (appnote.txt) is distributed with the PKZIP program (even in the
-   version without encryption capabilities).
-
-   If you don't need crypting in your application, just define symbols
-   NOCRYPT and NOUNCRYPT.
-
-   This code support the "Traditional PKWARE Encryption".
-
-   The new AES encryption added on Zip format by Winzip (see the page
-   http://www.winzip.com/aes_info.htm ) and PKWare PKZip 5.x Strong
-   Encryption is not supported.
-*/
-
-#define CRC32(c, b) ((*(pcrc_32_tab+(((int)(c) ^ (b)) & 0xff))) ^ ((c) >> 8))
-
-/***********************************************************************
- * Return the next byte in the pseudo-random sequence
- */
-static int decrypt_byte(unsigned long* pkeys, const unsigned long* pcrc_32_tab)
-{
-    unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an
-                     * unpredictable manner on 16-bit systems; not a problem
-                     * with any known compiler so far, though */
-
-    temp = ((unsigned)(*(pkeys+2)) & 0xffff) | 2;
-    return (int)(((temp * (temp ^ 1)) >> 8) & 0xff);
-}
-
-/***********************************************************************
- * Update the encryption keys with the next byte of plain text
- */
-static int update_keys(unsigned long* pkeys,const unsigned long* pcrc_32_tab,int c)
-{
-    (*(pkeys+0)) = CRC32((*(pkeys+0)), c);
-    (*(pkeys+1)) += (*(pkeys+0)) & 0xff;
-    (*(pkeys+1)) = (*(pkeys+1)) * 134775813L + 1;
-    {
-      register int keyshift = (int)((*(pkeys+1)) >> 24);
-      (*(pkeys+2)) = CRC32((*(pkeys+2)), keyshift);
-    }
-    return c;
-}
-
-
-/***********************************************************************
- * Initialize the encryption keys and the random header according to
- * the given password.
- */
-static void init_keys(const char* passwd,unsigned long* pkeys,const unsigned long* pcrc_32_tab)
-{
-    *(pkeys+0) = 305419896L;
-    *(pkeys+1) = 591751049L;
-    *(pkeys+2) = 878082192L;
-    while (*passwd != '\0') {
-        update_keys(pkeys,pcrc_32_tab,(int)*passwd);
-        passwd++;
-    }
-}
-
-#define zdecode(pkeys,pcrc_32_tab,c) \
-    (update_keys(pkeys,pcrc_32_tab,c ^= decrypt_byte(pkeys,pcrc_32_tab)))
-
-#define zencode(pkeys,pcrc_32_tab,c,t) \
-    (t=decrypt_byte(pkeys,pcrc_32_tab), update_keys(pkeys,pcrc_32_tab,c), t^(c))
-
-#ifdef INCLUDECRYPTINGCODE_IFCRYPTALLOWED
-
-#define RAND_HEAD_LEN  12
-   /* "last resort" source for second part of crypt seed pattern */
-#  ifndef ZCR_SEED2
-#    define ZCR_SEED2 3141592654UL     /* use PI as default pattern */
-#  endif
-
-static int crypthead(passwd, buf, bufSize, pkeys, pcrc_32_tab, crcForCrypting)
-    const char *passwd;         /* password string */
-    unsigned char *buf;         /* where to write header */
-    int bufSize;
-    unsigned long* pkeys;
-    const unsigned long* pcrc_32_tab;
-    unsigned long crcForCrypting;
-{
-    int n;                       /* index in random header */
-    int t;                       /* temporary */
-    int c;                       /* random byte */
-    unsigned char header[RAND_HEAD_LEN-2]; /* random header */
-    static unsigned calls = 0;   /* ensure different random header each time */
-
-    if (bufSize<RAND_HEAD_LEN)
-      return 0;
-
-    /* First generate RAND_HEAD_LEN-2 random bytes. We encrypt the
-     * output of rand() to get less predictability, since rand() is
-     * often poorly implemented.
-     */
-    if (++calls == 1)
-    {
-        srand((unsigned)(time(NULL) ^ ZCR_SEED2));
-    }
-    init_keys(passwd, pkeys, pcrc_32_tab);
-    for (n = 0; n < RAND_HEAD_LEN-2; n++)
-    {
-        c = (rand() >> 7) & 0xff;
-        header[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, c, t);
-    }
-    /* Encrypt random header (last two bytes is high word of crc) */
-    init_keys(passwd, pkeys, pcrc_32_tab);
-    for (n = 0; n < RAND_HEAD_LEN-2; n++)
-    {
-        buf[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, header[n], t);
-    }
-    buf[n++] = zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 16) & 0xff, t);
-    buf[n++] = zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 24) & 0xff, t);
-    return n;
-}
-
-#endif
diff -Nbaur gcc-4.6.3/zlib/contrib/minizip/ioapi.c gcc-4.6.3-psp/zlib/contrib/minizip/ioapi.c
--- gcc-4.6.3/zlib/contrib/minizip/ioapi.c	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/minizip/ioapi.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,177 +0,0 @@
-/* ioapi.c -- IO base function header for compress/uncompress .zip
-   files using zlib + zip or unzip API
-
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "zlib.h"
-#include "ioapi.h"
-
-
-
-/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */
-
-#ifndef SEEK_CUR
-#define SEEK_CUR    1
-#endif
-
-#ifndef SEEK_END
-#define SEEK_END    2
-#endif
-
-#ifndef SEEK_SET
-#define SEEK_SET    0
-#endif
-
-voidpf ZCALLBACK fopen_file_func OF((
-   voidpf opaque,
-   const char* filename,
-   int mode));
-
-uLong ZCALLBACK fread_file_func OF((
-   voidpf opaque,
-   voidpf stream,
-   void* buf,
-   uLong size));
-
-uLong ZCALLBACK fwrite_file_func OF((
-   voidpf opaque,
-   voidpf stream,
-   const void* buf,
-   uLong size));
-
-long ZCALLBACK ftell_file_func OF((
-   voidpf opaque,
-   voidpf stream));
-
-long ZCALLBACK fseek_file_func OF((
-   voidpf opaque,
-   voidpf stream,
-   uLong offset,
-   int origin));
-
-int ZCALLBACK fclose_file_func OF((
-   voidpf opaque,
-   voidpf stream));
-
-int ZCALLBACK ferror_file_func OF((
-   voidpf opaque,
-   voidpf stream));
-
-
-voidpf ZCALLBACK fopen_file_func (opaque, filename, mode)
-   voidpf opaque;
-   const char* filename;
-   int mode;
-{
-    FILE* file = NULL;
-    const char* mode_fopen = NULL;
-    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)
-        mode_fopen = "rb";
-    else
-    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
-        mode_fopen = "r+b";
-    else
-    if (mode & ZLIB_FILEFUNC_MODE_CREATE)
-        mode_fopen = "wb";
-
-    if ((filename!=NULL) && (mode_fopen != NULL))
-        file = fopen(filename, mode_fopen);
-    return file;
-}
-
-
-uLong ZCALLBACK fread_file_func (opaque, stream, buf, size)
-   voidpf opaque;
-   voidpf stream;
-   void* buf;
-   uLong size;
-{
-    uLong ret;
-    ret = (uLong)fread(buf, 1, (size_t)size, (FILE *)stream);
-    return ret;
-}
-
-
-uLong ZCALLBACK fwrite_file_func (opaque, stream, buf, size)
-   voidpf opaque;
-   voidpf stream;
-   const void* buf;
-   uLong size;
-{
-    uLong ret;
-    ret = (uLong)fwrite(buf, 1, (size_t)size, (FILE *)stream);
-    return ret;
-}
-
-long ZCALLBACK ftell_file_func (opaque, stream)
-   voidpf opaque;
-   voidpf stream;
-{
-    long ret;
-    ret = ftell((FILE *)stream);
-    return ret;
-}
-
-long ZCALLBACK fseek_file_func (opaque, stream, offset, origin)
-   voidpf opaque;
-   voidpf stream;
-   uLong offset;
-   int origin;
-{
-    int fseek_origin=0;
-    long ret;
-    switch (origin)
-    {
-    case ZLIB_FILEFUNC_SEEK_CUR :
-        fseek_origin = SEEK_CUR;
-        break;
-    case ZLIB_FILEFUNC_SEEK_END :
-        fseek_origin = SEEK_END;
-        break;
-    case ZLIB_FILEFUNC_SEEK_SET :
-        fseek_origin = SEEK_SET;
-        break;
-    default: return -1;
-    }
-    ret = 0;
-    fseek((FILE *)stream, offset, fseek_origin);
-    return ret;
-}
-
-int ZCALLBACK fclose_file_func (opaque, stream)
-   voidpf opaque;
-   voidpf stream;
-{
-    int ret;
-    ret = fclose((FILE *)stream);
-    return ret;
-}
-
-int ZCALLBACK ferror_file_func (opaque, stream)
-   voidpf opaque;
-   voidpf stream;
-{
-    int ret;
-    ret = ferror((FILE *)stream);
-    return ret;
-}
-
-void fill_fopen_filefunc (pzlib_filefunc_def)
-  zlib_filefunc_def* pzlib_filefunc_def;
-{
-    pzlib_filefunc_def->zopen_file = fopen_file_func;
-    pzlib_filefunc_def->zread_file = fread_file_func;
-    pzlib_filefunc_def->zwrite_file = fwrite_file_func;
-    pzlib_filefunc_def->ztell_file = ftell_file_func;
-    pzlib_filefunc_def->zseek_file = fseek_file_func;
-    pzlib_filefunc_def->zclose_file = fclose_file_func;
-    pzlib_filefunc_def->zerror_file = ferror_file_func;
-    pzlib_filefunc_def->opaque = NULL;
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/minizip/ioapi.h gcc-4.6.3-psp/zlib/contrib/minizip/ioapi.h
--- gcc-4.6.3/zlib/contrib/minizip/ioapi.h	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/minizip/ioapi.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,75 +0,0 @@
-/* ioapi.h -- IO base function header for compress/uncompress .zip
-   files using zlib + zip or unzip API
-
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-*/
-
-#ifndef _ZLIBIOAPI_H
-#define _ZLIBIOAPI_H
-
-
-#define ZLIB_FILEFUNC_SEEK_CUR (1)
-#define ZLIB_FILEFUNC_SEEK_END (2)
-#define ZLIB_FILEFUNC_SEEK_SET (0)
-
-#define ZLIB_FILEFUNC_MODE_READ      (1)
-#define ZLIB_FILEFUNC_MODE_WRITE     (2)
-#define ZLIB_FILEFUNC_MODE_READWRITEFILTER (3)
-
-#define ZLIB_FILEFUNC_MODE_EXISTING (4)
-#define ZLIB_FILEFUNC_MODE_CREATE   (8)
-
-
-#ifndef ZCALLBACK
-
-#if (defined(WIN32) || defined (WINDOWS) || defined (_WINDOWS)) && defined(CALLBACK) && defined (USEWINDOWS_CALLBACK)
-#define ZCALLBACK CALLBACK
-#else
-#define ZCALLBACK
-#endif
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef voidpf (ZCALLBACK *open_file_func) OF((voidpf opaque, const char* filename, int mode));
-typedef uLong  (ZCALLBACK *read_file_func) OF((voidpf opaque, voidpf stream, void* buf, uLong size));
-typedef uLong  (ZCALLBACK *write_file_func) OF((voidpf opaque, voidpf stream, const void* buf, uLong size));
-typedef long   (ZCALLBACK *tell_file_func) OF((voidpf opaque, voidpf stream));
-typedef long   (ZCALLBACK *seek_file_func) OF((voidpf opaque, voidpf stream, uLong offset, int origin));
-typedef int    (ZCALLBACK *close_file_func) OF((voidpf opaque, voidpf stream));
-typedef int    (ZCALLBACK *testerror_file_func) OF((voidpf opaque, voidpf stream));
-
-typedef struct zlib_filefunc_def_s
-{
-    open_file_func      zopen_file;
-    read_file_func      zread_file;
-    write_file_func     zwrite_file;
-    tell_file_func      ztell_file;
-    seek_file_func      zseek_file;
-    close_file_func     zclose_file;
-    testerror_file_func zerror_file;
-    voidpf              opaque;
-} zlib_filefunc_def;
-
-
-
-void fill_fopen_filefunc OF((zlib_filefunc_def* pzlib_filefunc_def));
-
-#define ZREAD(filefunc,filestream,buf,size) ((*((filefunc).zread_file))((filefunc).opaque,filestream,buf,size))
-#define ZWRITE(filefunc,filestream,buf,size) ((*((filefunc).zwrite_file))((filefunc).opaque,filestream,buf,size))
-#define ZTELL(filefunc,filestream) ((*((filefunc).ztell_file))((filefunc).opaque,filestream))
-#define ZSEEK(filefunc,filestream,pos,mode) ((*((filefunc).zseek_file))((filefunc).opaque,filestream,pos,mode))
-#define ZCLOSE(filefunc,filestream) ((*((filefunc).zclose_file))((filefunc).opaque,filestream))
-#define ZERROR(filefunc,filestream) ((*((filefunc).zerror_file))((filefunc).opaque,filestream))
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
diff -Nbaur gcc-4.6.3/zlib/contrib/minizip/iowin32.c gcc-4.6.3-psp/zlib/contrib/minizip/iowin32.c
--- gcc-4.6.3/zlib/contrib/minizip/iowin32.c	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/minizip/iowin32.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,270 +0,0 @@
-/* iowin32.c -- IO base function header for compress/uncompress .zip
-   files using zlib + zip or unzip API
-   This IO API version uses the Win32 API (for Microsoft Windows)
-
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-*/
-
-#include <stdlib.h>
-
-#include "zlib.h"
-#include "ioapi.h"
-#include "iowin32.h"
-
-#ifndef INVALID_HANDLE_VALUE
-#define INVALID_HANDLE_VALUE (0xFFFFFFFF)
-#endif
-
-#ifndef INVALID_SET_FILE_POINTER
-#define INVALID_SET_FILE_POINTER ((DWORD)-1)
-#endif
-
-voidpf ZCALLBACK win32_open_file_func OF((
-   voidpf opaque,
-   const char* filename,
-   int mode));
-
-uLong ZCALLBACK win32_read_file_func OF((
-   voidpf opaque,
-   voidpf stream,
-   void* buf,
-   uLong size));
-
-uLong ZCALLBACK win32_write_file_func OF((
-   voidpf opaque,
-   voidpf stream,
-   const void* buf,
-   uLong size));
-
-long ZCALLBACK win32_tell_file_func OF((
-   voidpf opaque,
-   voidpf stream));
-
-long ZCALLBACK win32_seek_file_func OF((
-   voidpf opaque,
-   voidpf stream,
-   uLong offset,
-   int origin));
-
-int ZCALLBACK win32_close_file_func OF((
-   voidpf opaque,
-   voidpf stream));
-
-int ZCALLBACK win32_error_file_func OF((
-   voidpf opaque,
-   voidpf stream));
-
-typedef struct
-{
-    HANDLE hf;
-    int error;
-} WIN32FILE_IOWIN;
-
-voidpf ZCALLBACK win32_open_file_func (opaque, filename, mode)
-   voidpf opaque;
-   const char* filename;
-   int mode;
-{
-    const char* mode_fopen = NULL;
-    DWORD dwDesiredAccess,dwCreationDisposition,dwShareMode,dwFlagsAndAttributes ;
-    HANDLE hFile = 0;
-    voidpf ret=NULL;
-
-    dwDesiredAccess = dwShareMode = dwFlagsAndAttributes = 0;
-
-    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)
-    {
-        dwDesiredAccess = GENERIC_READ;
-        dwCreationDisposition = OPEN_EXISTING;
-        dwShareMode = FILE_SHARE_READ;
-    }
-    else
-    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
-    {
-        dwDesiredAccess = GENERIC_WRITE | GENERIC_READ;
-        dwCreationDisposition = OPEN_EXISTING;
-    }
-    else
-    if (mode & ZLIB_FILEFUNC_MODE_CREATE)
-    {
-        dwDesiredAccess = GENERIC_WRITE | GENERIC_READ;
-        dwCreationDisposition = CREATE_ALWAYS;
-    }
-
-    if ((filename!=NULL) && (dwDesiredAccess != 0))
-        hFile = CreateFile((LPCTSTR)filename, dwDesiredAccess, dwShareMode, NULL,
-                      dwCreationDisposition, dwFlagsAndAttributes, NULL);
-
-    if (hFile == INVALID_HANDLE_VALUE)
-        hFile = NULL;
-
-    if (hFile != NULL)
-    {
-        WIN32FILE_IOWIN w32fiow;
-        w32fiow.hf = hFile;
-        w32fiow.error = 0;
-        ret = malloc(sizeof(WIN32FILE_IOWIN));
-        if (ret==NULL)
-            CloseHandle(hFile);
-        else *((WIN32FILE_IOWIN*)ret) = w32fiow;
-    }
-    return ret;
-}
-
-
-uLong ZCALLBACK win32_read_file_func (opaque, stream, buf, size)
-   voidpf opaque;
-   voidpf stream;
-   void* buf;
-   uLong size;
-{
-    uLong ret=0;
-    HANDLE hFile = NULL;
-    if (stream!=NULL)
-        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;
-    if (hFile != NULL)
-        if (!ReadFile(hFile, buf, size, &ret, NULL))
-        {
-            DWORD dwErr = GetLastError();
-            if (dwErr == ERROR_HANDLE_EOF)
-                dwErr = 0;
-            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;
-        }
-
-    return ret;
-}
-
-
-uLong ZCALLBACK win32_write_file_func (opaque, stream, buf, size)
-   voidpf opaque;
-   voidpf stream;
-   const void* buf;
-   uLong size;
-{
-    uLong ret=0;
-    HANDLE hFile = NULL;
-    if (stream!=NULL)
-        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;
-
-    if (hFile !=NULL)
-        if (!WriteFile(hFile, buf, size, &ret, NULL))
-        {
-            DWORD dwErr = GetLastError();
-            if (dwErr == ERROR_HANDLE_EOF)
-                dwErr = 0;
-            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;
-        }
-
-    return ret;
-}
-
-long ZCALLBACK win32_tell_file_func (opaque, stream)
-   voidpf opaque;
-   voidpf stream;
-{
-    long ret=-1;
-    HANDLE hFile = NULL;
-    if (stream!=NULL)
-        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;
-    if (hFile != NULL)
-    {
-        DWORD dwSet = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);
-        if (dwSet == INVALID_SET_FILE_POINTER)
-        {
-            DWORD dwErr = GetLastError();
-            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;
-            ret = -1;
-        }
-        else
-            ret=(long)dwSet;
-    }
-    return ret;
-}
-
-long ZCALLBACK win32_seek_file_func (opaque, stream, offset, origin)
-   voidpf opaque;
-   voidpf stream;
-   uLong offset;
-   int origin;
-{
-    DWORD dwMoveMethod=0xFFFFFFFF;
-    HANDLE hFile = NULL;
-
-    long ret=-1;
-    if (stream!=NULL)
-        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;
-    switch (origin)
-    {
-    case ZLIB_FILEFUNC_SEEK_CUR :
-        dwMoveMethod = FILE_CURRENT;
-        break;
-    case ZLIB_FILEFUNC_SEEK_END :
-        dwMoveMethod = FILE_END;
-        break;
-    case ZLIB_FILEFUNC_SEEK_SET :
-        dwMoveMethod = FILE_BEGIN;
-        break;
-    default: return -1;
-    }
-
-    if (hFile != NULL)
-    {
-        DWORD dwSet = SetFilePointer(hFile, offset, NULL, dwMoveMethod);
-        if (dwSet == INVALID_SET_FILE_POINTER)
-        {
-            DWORD dwErr = GetLastError();
-            ((WIN32FILE_IOWIN*)stream) -> error=(int)dwErr;
-            ret = -1;
-        }
-        else
-            ret=0;
-    }
-    return ret;
-}
-
-int ZCALLBACK win32_close_file_func (opaque, stream)
-   voidpf opaque;
-   voidpf stream;
-{
-    int ret=-1;
-
-    if (stream!=NULL)
-    {
-        HANDLE hFile;
-        hFile = ((WIN32FILE_IOWIN*)stream) -> hf;
-        if (hFile != NULL)
-        {
-            CloseHandle(hFile);
-            ret=0;
-        }
-        free(stream);
-    }
-    return ret;
-}
-
-int ZCALLBACK win32_error_file_func (opaque, stream)
-   voidpf opaque;
-   voidpf stream;
-{
-    int ret=-1;
-    if (stream!=NULL)
-    {
-        ret = ((WIN32FILE_IOWIN*)stream) -> error;
-    }
-    return ret;
-}
-
-void fill_win32_filefunc (pzlib_filefunc_def)
-  zlib_filefunc_def* pzlib_filefunc_def;
-{
-    pzlib_filefunc_def->zopen_file = win32_open_file_func;
-    pzlib_filefunc_def->zread_file = win32_read_file_func;
-    pzlib_filefunc_def->zwrite_file = win32_write_file_func;
-    pzlib_filefunc_def->ztell_file = win32_tell_file_func;
-    pzlib_filefunc_def->zseek_file = win32_seek_file_func;
-    pzlib_filefunc_def->zclose_file = win32_close_file_func;
-    pzlib_filefunc_def->zerror_file = win32_error_file_func;
-    pzlib_filefunc_def->opaque=NULL;
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/minizip/iowin32.h gcc-4.6.3-psp/zlib/contrib/minizip/iowin32.h
--- gcc-4.6.3/zlib/contrib/minizip/iowin32.h	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/minizip/iowin32.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-/* iowin32.h -- IO base function header for compress/uncompress .zip
-   files using zlib + zip or unzip API
-   This IO API version uses the Win32 API (for Microsoft Windows)
-
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-*/
-
-#include <windows.h>
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-void fill_win32_filefunc OF((zlib_filefunc_def* pzlib_filefunc_def));
-
-#ifdef __cplusplus
-}
-#endif
diff -Nbaur gcc-4.6.3/zlib/contrib/minizip/Makefile gcc-4.6.3-psp/zlib/contrib/minizip/Makefile
--- gcc-4.6.3/zlib/contrib/minizip/Makefile	2004-10-11 19:45:43.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/minizip/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
-CC=cc
-CFLAGS=-O -I../..
-
-UNZ_OBJS = miniunz.o unzip.o ioapi.o ../../libz.a
-ZIP_OBJS = minizip.o zip.o   ioapi.o ../../libz.a
-
-.c.o:
-	$(CC) -c $(CFLAGS) $*.c
-
-all: miniunz minizip
-
-miniunz:  $(UNZ_OBJS)
-	$(CC) $(CFLAGS) -o $@ $(UNZ_OBJS)
-
-minizip:  $(ZIP_OBJS)
-	$(CC) $(CFLAGS) -o $@ $(ZIP_OBJS)
-
-test:	miniunz minizip
-	./minizip test readme.txt
-	./miniunz -l test.zip
-	mv readme.txt readme.old
-	./miniunz test.zip
-
-clean:
-	/bin/rm -f *.o *~ minizip miniunz
diff -Nbaur gcc-4.6.3/zlib/contrib/minizip/miniunz.c gcc-4.6.3-psp/zlib/contrib/minizip/miniunz.c
--- gcc-4.6.3/zlib/contrib/minizip/miniunz.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/minizip/miniunz.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,585 +0,0 @@
-/*
-   miniunz.c
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-*/
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <errno.h>
-#include <fcntl.h>
-
-#ifdef unix
-# include <unistd.h>
-# include <utime.h>
-#else
-# include <direct.h>
-# include <io.h>
-#endif
-
-#include "unzip.h"
-
-#define CASESENSITIVITY (0)
-#define WRITEBUFFERSIZE (8192)
-#define MAXFILENAME (256)
-
-#ifdef WIN32
-#define USEWIN32IOAPI
-#include "iowin32.h"
-#endif
-/*
-  mini unzip, demo of unzip package
-
-  usage :
-  Usage : miniunz [-exvlo] file.zip [file_to_extract] [-d extractdir]
-
-  list the file in the zipfile, and print the content of FILE_ID.ZIP or README.TXT
-    if it exists
-*/
-
-
-/* change_file_date : change the date/time of a file
-    filename : the filename of the file where date/time must be modified
-    dosdate : the new date at the MSDos format (4 bytes)
-    tmu_date : the SAME new date at the tm_unz format */
-void change_file_date(filename,dosdate,tmu_date)
-    const char *filename;
-    uLong dosdate;
-    tm_unz tmu_date;
-{
-#ifdef WIN32
-  HANDLE hFile;
-  FILETIME ftm,ftLocal,ftCreate,ftLastAcc,ftLastWrite;
-
-  hFile = CreateFile(filename,GENERIC_READ | GENERIC_WRITE,
-                      0,NULL,OPEN_EXISTING,0,NULL);
-  GetFileTime(hFile,&ftCreate,&ftLastAcc,&ftLastWrite);
-  DosDateTimeToFileTime((WORD)(dosdate>>16),(WORD)dosdate,&ftLocal);
-  LocalFileTimeToFileTime(&ftLocal,&ftm);
-  SetFileTime(hFile,&ftm,&ftLastAcc,&ftm);
-  CloseHandle(hFile);
-#else
-#ifdef unix
-  struct utimbuf ut;
-  struct tm newdate;
-  newdate.tm_sec = tmu_date.tm_sec;
-  newdate.tm_min=tmu_date.tm_min;
-  newdate.tm_hour=tmu_date.tm_hour;
-  newdate.tm_mday=tmu_date.tm_mday;
-  newdate.tm_mon=tmu_date.tm_mon;
-  if (tmu_date.tm_year > 1900)
-      newdate.tm_year=tmu_date.tm_year - 1900;
-  else
-      newdate.tm_year=tmu_date.tm_year ;
-  newdate.tm_isdst=-1;
-
-  ut.actime=ut.modtime=mktime(&newdate);
-  utime(filename,&ut);
-#endif
-#endif
-}
-
-
-/* mymkdir and change_file_date are not 100 % portable
-   As I don't know well Unix, I wait feedback for the unix portion */
-
-int mymkdir(dirname)
-    const char* dirname;
-{
-    int ret=0;
-#ifdef WIN32
-    ret = mkdir(dirname);
-#else
-#ifdef unix
-    ret = mkdir (dirname,0775);
-#endif
-#endif
-    return ret;
-}
-
-int makedir (newdir)
-    char *newdir;
-{
-  char *buffer ;
-  char *p;
-  int  len = (int)strlen(newdir);
-
-  if (len <= 0)
-    return 0;
-
-  buffer = (char*)malloc(len+1);
-  strcpy(buffer,newdir);
-
-  if (buffer[len-1] == '/') {
-    buffer[len-1] = '\0';
-  }
-  if (mymkdir(buffer) == 0)
-    {
-      free(buffer);
-      return 1;
-    }
-
-  p = buffer+1;
-  while (1)
-    {
-      char hold;
-
-      while(*p && *p != '\\' && *p != '/')
-        p++;
-      hold = *p;
-      *p = 0;
-      if ((mymkdir(buffer) == -1) && (errno == ENOENT))
-        {
-          printf("couldn't create directory %s\n",buffer);
-          free(buffer);
-          return 0;
-        }
-      if (hold == 0)
-        break;
-      *p++ = hold;
-    }
-  free(buffer);
-  return 1;
-}
-
-void do_banner()
-{
-    printf("MiniUnz 1.01b, demo of zLib + Unz package written by Gilles Vollant\n");
-    printf("more info at http://www.winimage.com/zLibDll/unzip.html\n\n");
-}
-
-void do_help()
-{
-    printf("Usage : miniunz [-e] [-x] [-v] [-l] [-o] [-p password] file.zip [file_to_extr.] [-d extractdir]\n\n" \
-           "  -e  Extract without pathname (junk paths)\n" \
-           "  -x  Extract with pathname\n" \
-           "  -v  list files\n" \
-           "  -l  list files\n" \
-           "  -d  directory to extract into\n" \
-           "  -o  overwrite files without prompting\n" \
-           "  -p  extract crypted file using password\n\n");
-}
-
-
-int do_list(uf)
-    unzFile uf;
-{
-    uLong i;
-    unz_global_info gi;
-    int err;
-
-    err = unzGetGlobalInfo (uf,&gi);
-    if (err!=UNZ_OK)
-        printf("error %d with zipfile in unzGetGlobalInfo \n",err);
-    printf(" Length  Method   Size  Ratio   Date    Time   CRC-32     Name\n");
-    printf(" ------  ------   ----  -----   ----    ----   ------     ----\n");
-    for (i=0;i<gi.number_entry;i++)
-    {
-        char filename_inzip[256];
-        unz_file_info file_info;
-        uLong ratio=0;
-        const char *string_method;
-        char charCrypt=' ';
-        err = unzGetCurrentFileInfo(uf,&file_info,filename_inzip,sizeof(filename_inzip),NULL,0,NULL,0);
-        if (err!=UNZ_OK)
-        {
-            printf("error %d with zipfile in unzGetCurrentFileInfo\n",err);
-            break;
-        }
-        if (file_info.uncompressed_size>0)
-            ratio = (file_info.compressed_size*100)/file_info.uncompressed_size;
-
-        /* display a '*' if the file is crypted */
-        if ((file_info.flag & 1) != 0)
-            charCrypt='*';
-
-        if (file_info.compression_method==0)
-            string_method="Stored";
-        else
-        if (file_info.compression_method==Z_DEFLATED)
-        {
-            uInt iLevel=(uInt)((file_info.flag & 0x6)/2);
-            if (iLevel==0)
-              string_method="Defl:N";
-            else if (iLevel==1)
-              string_method="Defl:X";
-            else if ((iLevel==2) || (iLevel==3))
-              string_method="Defl:F"; /* 2:fast , 3 : extra fast*/
-        }
-        else
-            string_method="Unkn. ";
-
-        printf("%7lu  %6s%c%7lu %3lu%%  %2.2lu-%2.2lu-%2.2lu  %2.2lu:%2.2lu  %8.8lx   %s\n",
-                file_info.uncompressed_size,string_method,
-                charCrypt,
-                file_info.compressed_size,
-                ratio,
-                (uLong)file_info.tmu_date.tm_mon + 1,
-                (uLong)file_info.tmu_date.tm_mday,
-                (uLong)file_info.tmu_date.tm_year % 100,
-                (uLong)file_info.tmu_date.tm_hour,(uLong)file_info.tmu_date.tm_min,
-                (uLong)file_info.crc,filename_inzip);
-        if ((i+1)<gi.number_entry)
-        {
-            err = unzGoToNextFile(uf);
-            if (err!=UNZ_OK)
-            {
-                printf("error %d with zipfile in unzGoToNextFile\n",err);
-                break;
-            }
-        }
-    }
-
-    return 0;
-}
-
-
-int do_extract_currentfile(uf,popt_extract_without_path,popt_overwrite,password)
-    unzFile uf;
-    const int* popt_extract_without_path;
-    int* popt_overwrite;
-    const char* password;
-{
-    char filename_inzip[256];
-    char* filename_withoutpath;
-    char* p;
-    int err=UNZ_OK;
-    FILE *fout=NULL;
-    void* buf;
-    uInt size_buf;
-
-    unz_file_info file_info;
-    uLong ratio=0;
-    err = unzGetCurrentFileInfo(uf,&file_info,filename_inzip,sizeof(filename_inzip),NULL,0,NULL,0);
-
-    if (err!=UNZ_OK)
-    {
-        printf("error %d with zipfile in unzGetCurrentFileInfo\n",err);
-        return err;
-    }
-
-    size_buf = WRITEBUFFERSIZE;
-    buf = (void*)malloc(size_buf);
-    if (buf==NULL)
-    {
-        printf("Error allocating memory\n");
-        return UNZ_INTERNALERROR;
-    }
-
-    p = filename_withoutpath = filename_inzip;
-    while ((*p) != '\0')
-    {
-        if (((*p)=='/') || ((*p)=='\\'))
-            filename_withoutpath = p+1;
-        p++;
-    }
-
-    if ((*filename_withoutpath)=='\0')
-    {
-        if ((*popt_extract_without_path)==0)
-        {
-            printf("creating directory: %s\n",filename_inzip);
-            mymkdir(filename_inzip);
-        }
-    }
-    else
-    {
-        const char* write_filename;
-        int skip=0;
-
-        if ((*popt_extract_without_path)==0)
-            write_filename = filename_inzip;
-        else
-            write_filename = filename_withoutpath;
-
-        err = unzOpenCurrentFilePassword(uf,password);
-        if (err!=UNZ_OK)
-        {
-            printf("error %d with zipfile in unzOpenCurrentFilePassword\n",err);
-        }
-
-        if (((*popt_overwrite)==0) && (err==UNZ_OK))
-        {
-            char rep=0;
-            FILE* ftestexist;
-            ftestexist = fopen(write_filename,"rb");
-            if (ftestexist!=NULL)
-            {
-                fclose(ftestexist);
-                do
-                {
-                    char answer[128];
-                    int ret;
-
-                    printf("The file %s exists. Overwrite ? [y]es, [n]o, [A]ll: ",write_filename);
-                    ret = scanf("%1s",answer);
-                    if (ret != 1) 
-                    {
-                       exit(EXIT_FAILURE);
-                    }
-                    rep = answer[0] ;
-                    if ((rep>='a') && (rep<='z'))
-                        rep -= 0x20;
-                }
-                while ((rep!='Y') && (rep!='N') && (rep!='A'));
-            }
-
-            if (rep == 'N')
-                skip = 1;
-
-            if (rep == 'A')
-                *popt_overwrite=1;
-        }
-
-        if ((skip==0) && (err==UNZ_OK))
-        {
-            fout=fopen(write_filename,"wb");
-
-            /* some zipfile don't contain directory alone before file */
-            if ((fout==NULL) && ((*popt_extract_without_path)==0) &&
-                                (filename_withoutpath!=(char*)filename_inzip))
-            {
-                char c=*(filename_withoutpath-1);
-                *(filename_withoutpath-1)='\0';
-                makedir(write_filename);
-                *(filename_withoutpath-1)=c;
-                fout=fopen(write_filename,"wb");
-            }
-
-            if (fout==NULL)
-            {
-                printf("error opening %s\n",write_filename);
-            }
-        }
-
-        if (fout!=NULL)
-        {
-            printf(" extracting: %s\n",write_filename);
-
-            do
-            {
-                err = unzReadCurrentFile(uf,buf,size_buf);
-                if (err<0)
-                {
-                    printf("error %d with zipfile in unzReadCurrentFile\n",err);
-                    break;
-                }
-                if (err>0)
-                    if (fwrite(buf,err,1,fout)!=1)
-                    {
-                        printf("error in writing extracted file\n");
-                        err=UNZ_ERRNO;
-                        break;
-                    }
-            }
-            while (err>0);
-            if (fout)
-                    fclose(fout);
-
-            if (err==0)
-                change_file_date(write_filename,file_info.dosDate,
-                                 file_info.tmu_date);
-        }
-
-        if (err==UNZ_OK)
-        {
-            err = unzCloseCurrentFile (uf);
-            if (err!=UNZ_OK)
-            {
-                printf("error %d with zipfile in unzCloseCurrentFile\n",err);
-            }
-        }
-        else
-            unzCloseCurrentFile(uf); /* don't lose the error */
-    }
-
-    free(buf);
-    return err;
-}
-
-
-int do_extract(uf,opt_extract_without_path,opt_overwrite,password)
-    unzFile uf;
-    int opt_extract_without_path;
-    int opt_overwrite;
-    const char* password;
-{
-    uLong i;
-    unz_global_info gi;
-    int err;
-    FILE* fout=NULL;
-
-    err = unzGetGlobalInfo (uf,&gi);
-    if (err!=UNZ_OK)
-        printf("error %d with zipfile in unzGetGlobalInfo \n",err);
-
-    for (i=0;i<gi.number_entry;i++)
-    {
-        if (do_extract_currentfile(uf,&opt_extract_without_path,
-                                      &opt_overwrite,
-                                      password) != UNZ_OK)
-            break;
-
-        if ((i+1)<gi.number_entry)
-        {
-            err = unzGoToNextFile(uf);
-            if (err!=UNZ_OK)
-            {
-                printf("error %d with zipfile in unzGoToNextFile\n",err);
-                break;
-            }
-        }
-    }
-
-    return 0;
-}
-
-int do_extract_onefile(uf,filename,opt_extract_without_path,opt_overwrite,password)
-    unzFile uf;
-    const char* filename;
-    int opt_extract_without_path;
-    int opt_overwrite;
-    const char* password;
-{
-    int err = UNZ_OK;
-    if (unzLocateFile(uf,filename,CASESENSITIVITY)!=UNZ_OK)
-    {
-        printf("file %s not found in the zipfile\n",filename);
-        return 2;
-    }
-
-    if (do_extract_currentfile(uf,&opt_extract_without_path,
-                                      &opt_overwrite,
-                                      password) == UNZ_OK)
-        return 0;
-    else
-        return 1;
-}
-
-
-int main(argc,argv)
-    int argc;
-    char *argv[];
-{
-    const char *zipfilename=NULL;
-    const char *filename_to_extract=NULL;
-    const char *password=NULL;
-    char filename_try[MAXFILENAME+16] = "";
-    int i;
-    int opt_do_list=0;
-    int opt_do_extract=1;
-    int opt_do_extract_withoutpath=0;
-    int opt_overwrite=0;
-    int opt_extractdir=0;
-    const char *dirname=NULL;
-    unzFile uf=NULL;
-
-    do_banner();
-    if (argc==1)
-    {
-        do_help();
-        return 0;
-    }
-    else
-    {
-        for (i=1;i<argc;i++)
-        {
-            if ((*argv[i])=='-')
-            {
-                const char *p=argv[i]+1;
-
-                while ((*p)!='\0')
-                {
-                    char c=*(p++);;
-                    if ((c=='l') || (c=='L'))
-                        opt_do_list = 1;
-                    if ((c=='v') || (c=='V'))
-                        opt_do_list = 1;
-                    if ((c=='x') || (c=='X'))
-                        opt_do_extract = 1;
-                    if ((c=='e') || (c=='E'))
-                        opt_do_extract = opt_do_extract_withoutpath = 1;
-                    if ((c=='o') || (c=='O'))
-                        opt_overwrite=1;
-                    if ((c=='d') || (c=='D'))
-                    {
-                        opt_extractdir=1;
-                        dirname=argv[i+1];
-                    }
-
-                    if (((c=='p') || (c=='P')) && (i+1<argc))
-                    {
-                        password=argv[i+1];
-                        i++;
-                    }
-                }
-            }
-            else
-            {
-                if (zipfilename == NULL)
-                    zipfilename = argv[i];
-                else if ((filename_to_extract==NULL) && (!opt_extractdir))
-                        filename_to_extract = argv[i] ;
-            }
-        }
-    }
-
-    if (zipfilename!=NULL)
-    {
-
-#        ifdef USEWIN32IOAPI
-        zlib_filefunc_def ffunc;
-#        endif
-
-        strncpy(filename_try, zipfilename,MAXFILENAME-1);
-        /* strncpy doesnt append the trailing NULL, of the string is too long. */
-        filename_try[ MAXFILENAME ] = '\0';
-
-#        ifdef USEWIN32IOAPI
-        fill_win32_filefunc(&ffunc);
-        uf = unzOpen2(zipfilename,&ffunc);
-#        else
-        uf = unzOpen(zipfilename);
-#        endif
-        if (uf==NULL)
-        {
-            strcat(filename_try,".zip");
-#            ifdef USEWIN32IOAPI
-            uf = unzOpen2(filename_try,&ffunc);
-#            else
-            uf = unzOpen(filename_try);
-#            endif
-        }
-    }
-
-    if (uf==NULL)
-    {
-        printf("Cannot open %s or %s.zip\n",zipfilename,zipfilename);
-        return 1;
-    }
-    printf("%s opened\n",filename_try);
-
-    if (opt_do_list==1)
-        return do_list(uf);
-    else if (opt_do_extract==1)
-    {
-        if (opt_extractdir && chdir(dirname)) 
-        {
-          printf("Error changing into %s, aborting\n", dirname);
-          exit(-1);
-        }
-
-        if (filename_to_extract == NULL)
-            return do_extract(uf,opt_do_extract_withoutpath,opt_overwrite,password);
-        else
-            return do_extract_onefile(uf,filename_to_extract,
-                                      opt_do_extract_withoutpath,opt_overwrite,password);
-    }
-    unzCloseCurrentFile(uf);
-
-    return 0;
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/minizip/minizip.c gcc-4.6.3-psp/zlib/contrib/minizip/minizip.c
--- gcc-4.6.3/zlib/contrib/minizip/minizip.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/minizip/minizip.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,420 +0,0 @@
-/*
-   minizip.c
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <errno.h>
-#include <fcntl.h>
-
-#ifdef unix
-# include <unistd.h>
-# include <utime.h>
-# include <sys/types.h>
-# include <sys/stat.h>
-#else
-# include <direct.h>
-# include <io.h>
-#endif
-
-#include "zip.h"
-
-#ifdef WIN32
-#define USEWIN32IOAPI
-#include "iowin32.h"
-#endif
-
-
-
-#define WRITEBUFFERSIZE (16384)
-#define MAXFILENAME (256)
-
-#ifdef WIN32
-uLong filetime(f, tmzip, dt)
-    char *f;                /* name of file to get info on */
-    tm_zip *tmzip;             /* return value: access, modific. and creation times */
-    uLong *dt;             /* dostime */
-{
-  int ret = 0;
-  {
-      FILETIME ftLocal;
-      HANDLE hFind;
-      WIN32_FIND_DATA  ff32;
-
-      hFind = FindFirstFile(f,&ff32);
-      if (hFind != INVALID_HANDLE_VALUE)
-      {
-        FileTimeToLocalFileTime(&(ff32.ftLastWriteTime),&ftLocal);
-        FileTimeToDosDateTime(&ftLocal,((LPWORD)dt)+1,((LPWORD)dt)+0);
-        FindClose(hFind);
-        ret = 1;
-      }
-  }
-  return ret;
-}
-#else
-#ifdef unix
-uLong filetime(f, tmzip, dt)
-    char *f;               /* name of file to get info on */
-    tm_zip *tmzip;         /* return value: access, modific. and creation times */
-    uLong *dt;             /* dostime */
-{
-  int ret=0;
-  struct stat s;        /* results of stat() */
-  struct tm* filedate;
-  time_t tm_t=0;
-
-  if (strcmp(f,"-")!=0)
-  {
-    char name[MAXFILENAME+1];
-    int len = strlen(f);
-    if (len > MAXFILENAME)
-      len = MAXFILENAME;
-
-    strncpy(name, f,MAXFILENAME-1);
-    /* strncpy doesnt append the trailing NULL, of the string is too long. */
-    name[ MAXFILENAME ] = '\0';
-
-    if (name[len - 1] == '/')
-      name[len - 1] = '\0';
-    /* not all systems allow stat'ing a file with / appended */
-    if (stat(name,&s)==0)
-    {
-      tm_t = s.st_mtime;
-      ret = 1;
-    }
-  }
-  filedate = localtime(&tm_t);
-
-  tmzip->tm_sec  = filedate->tm_sec;
-  tmzip->tm_min  = filedate->tm_min;
-  tmzip->tm_hour = filedate->tm_hour;
-  tmzip->tm_mday = filedate->tm_mday;
-  tmzip->tm_mon  = filedate->tm_mon ;
-  tmzip->tm_year = filedate->tm_year;
-
-  return ret;
-}
-#else
-uLong filetime(f, tmzip, dt)
-    char *f;                /* name of file to get info on */
-    tm_zip *tmzip;             /* return value: access, modific. and creation times */
-    uLong *dt;             /* dostime */
-{
-    return 0;
-}
-#endif
-#endif
-
-
-
-
-int check_exist_file(filename)
-    const char* filename;
-{
-    FILE* ftestexist;
-    int ret = 1;
-    ftestexist = fopen(filename,"rb");
-    if (ftestexist==NULL)
-        ret = 0;
-    else
-        fclose(ftestexist);
-    return ret;
-}
-
-void do_banner()
-{
-    printf("MiniZip 1.01b, demo of zLib + Zip package written by Gilles Vollant\n");
-    printf("more info at http://www.winimage.com/zLibDll/unzip.html\n\n");
-}
-
-void do_help()
-{
-    printf("Usage : minizip [-o] [-a] [-0 to -9] [-p password] file.zip [files_to_add]\n\n" \
-           "  -o  Overwrite existing file.zip\n" \
-           "  -a  Append to existing file.zip\n" \
-           "  -0  Store only\n" \
-           "  -1  Compress faster\n" \
-           "  -9  Compress better\n\n");
-}
-
-/* calculate the CRC32 of a file,
-   because to encrypt a file, we need known the CRC32 of the file before */
-int getFileCrc(const char* filenameinzip,void*buf,unsigned long size_buf,unsigned long* result_crc)
-{
-   unsigned long calculate_crc=0;
-   int err=ZIP_OK;
-   FILE * fin = fopen(filenameinzip,"rb");
-   unsigned long size_read = 0;
-   unsigned long total_read = 0;
-   if (fin==NULL)
-   {
-       err = ZIP_ERRNO;
-   }
-
-    if (err == ZIP_OK)
-        do
-        {
-            err = ZIP_OK;
-            size_read = (int)fread(buf,1,size_buf,fin);
-            if (size_read < size_buf)
-                if (feof(fin)==0)
-            {
-                printf("error in reading %s\n",filenameinzip);
-                err = ZIP_ERRNO;
-            }
-
-            if (size_read>0)
-                calculate_crc = crc32(calculate_crc,buf,size_read);
-            total_read += size_read;
-
-        } while ((err == ZIP_OK) && (size_read>0));
-
-    if (fin)
-        fclose(fin);
-
-    *result_crc=calculate_crc;
-    printf("file %s crc %x\n",filenameinzip,calculate_crc);
-    return err;
-}
-
-int main(argc,argv)
-    int argc;
-    char *argv[];
-{
-    int i;
-    int opt_overwrite=0;
-    int opt_compress_level=Z_DEFAULT_COMPRESSION;
-    int zipfilenamearg = 0;
-    char filename_try[MAXFILENAME+16];
-    int zipok;
-    int err=0;
-    int size_buf=0;
-    void* buf=NULL;
-    const char* password=NULL;
-
-
-    do_banner();
-    if (argc==1)
-    {
-        do_help();
-        return 0;
-    }
-    else
-    {
-        for (i=1;i<argc;i++)
-        {
-            if ((*argv[i])=='-')
-            {
-                const char *p=argv[i]+1;
-
-                while ((*p)!='\0')
-                {
-                    char c=*(p++);;
-                    if ((c=='o') || (c=='O'))
-                        opt_overwrite = 1;
-                    if ((c=='a') || (c=='A'))
-                        opt_overwrite = 2;
-                    if ((c>='0') && (c<='9'))
-                        opt_compress_level = c-'0';
-
-                    if (((c=='p') || (c=='P')) && (i+1<argc))
-                    {
-                        password=argv[i+1];
-                        i++;
-                    }
-                }
-            }
-            else
-                if (zipfilenamearg == 0)
-                    zipfilenamearg = i ;
-        }
-    }
-
-    size_buf = WRITEBUFFERSIZE;
-    buf = (void*)malloc(size_buf);
-    if (buf==NULL)
-    {
-        printf("Error allocating memory\n");
-        return ZIP_INTERNALERROR;
-    }
-
-    if (zipfilenamearg==0)
-        zipok=0;
-    else
-    {
-        int i,len;
-        int dot_found=0;
-
-        zipok = 1 ;
-        strncpy(filename_try, argv[zipfilenamearg],MAXFILENAME-1);
-        /* strncpy doesnt append the trailing NULL, of the string is too long. */
-        filename_try[ MAXFILENAME ] = '\0';
-
-        len=(int)strlen(filename_try);
-        for (i=0;i<len;i++)
-            if (filename_try[i]=='.')
-                dot_found=1;
-
-        if (dot_found==0)
-            strcat(filename_try,".zip");
-
-        if (opt_overwrite==2)
-        {
-            /* if the file don't exist, we not append file */
-            if (check_exist_file(filename_try)==0)
-                opt_overwrite=1;
-        }
-        else
-        if (opt_overwrite==0)
-            if (check_exist_file(filename_try)!=0)
-            {
-                char rep=0;
-                do
-                {
-                    char answer[128];
-                    int ret;
-                    printf("The file %s exists. Overwrite ? [y]es, [n]o, [a]ppend : ",filename_try);
-                    ret = scanf("%1s",answer);
-                    if (ret != 1)
-                    {
-                       exit(EXIT_FAILURE);
-                    }
-                    rep = answer[0] ;
-                    if ((rep>='a') && (rep<='z'))
-                        rep -= 0x20;
-                }
-                while ((rep!='Y') && (rep!='N') && (rep!='A'));
-                if (rep=='N')
-                    zipok = 0;
-                if (rep=='A')
-                    opt_overwrite = 2;
-            }
-    }
-
-    if (zipok==1)
-    {
-        zipFile zf;
-        int errclose;
-#        ifdef USEWIN32IOAPI
-        zlib_filefunc_def ffunc;
-        fill_win32_filefunc(&ffunc);
-        zf = zipOpen2(filename_try,(opt_overwrite==2) ? 2 : 0,NULL,&ffunc);
-#        else
-        zf = zipOpen(filename_try,(opt_overwrite==2) ? 2 : 0);
-#        endif
-
-        if (zf == NULL)
-        {
-            printf("error opening %s\n",filename_try);
-            err= ZIP_ERRNO;
-        }
-        else
-            printf("creating %s\n",filename_try);
-
-        for (i=zipfilenamearg+1;(i<argc) && (err==ZIP_OK);i++)
-        {
-            if (!((((*(argv[i]))=='-') || ((*(argv[i]))=='/')) &&
-                  ((argv[i][1]=='o') || (argv[i][1]=='O') ||
-                   (argv[i][1]=='a') || (argv[i][1]=='A') ||
-                   (argv[i][1]=='p') || (argv[i][1]=='P') ||
-                   ((argv[i][1]>='0') || (argv[i][1]<='9'))) &&
-                  (strlen(argv[i]) == 2)))
-            {
-                FILE * fin;
-                int size_read;
-                const char* filenameinzip = argv[i];
-                zip_fileinfo zi;
-                unsigned long crcFile=0;
-
-                zi.tmz_date.tm_sec = zi.tmz_date.tm_min = zi.tmz_date.tm_hour =
-                zi.tmz_date.tm_mday = zi.tmz_date.tm_mon = zi.tmz_date.tm_year = 0;
-                zi.dosDate = 0;
-                zi.internal_fa = 0;
-                zi.external_fa = 0;
-                filetime(filenameinzip,&zi.tmz_date,&zi.dosDate);
-
-/*
-                err = zipOpenNewFileInZip(zf,filenameinzip,&zi,
-                                 NULL,0,NULL,0,NULL / * comment * /,
-                                 (opt_compress_level != 0) ? Z_DEFLATED : 0,
-                                 opt_compress_level);
-*/
-                if ((password != NULL) && (err==ZIP_OK))
-                    err = getFileCrc(filenameinzip,buf,size_buf,&crcFile);
-
-                err = zipOpenNewFileInZip3(zf,filenameinzip,&zi,
-                                 NULL,0,NULL,0,NULL /* comment*/,
-                                 (opt_compress_level != 0) ? Z_DEFLATED : 0,
-                                 opt_compress_level,0,
-                                 /* -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY, */
-                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
-                                 password,crcFile);
-
-                if (err != ZIP_OK)
-                    printf("error in opening %s in zipfile\n",filenameinzip);
-                else
-                {
-                    fin = fopen(filenameinzip,"rb");
-                    if (fin==NULL)
-                    {
-                        err=ZIP_ERRNO;
-                        printf("error in opening %s for reading\n",filenameinzip);
-                    }
-                }
-
-                if (err == ZIP_OK)
-                    do
-                    {
-                        err = ZIP_OK;
-                        size_read = (int)fread(buf,1,size_buf,fin);
-                        if (size_read < size_buf)
-                            if (feof(fin)==0)
-                        {
-                            printf("error in reading %s\n",filenameinzip);
-                            err = ZIP_ERRNO;
-                        }
-
-                        if (size_read>0)
-                        {
-                            err = zipWriteInFileInZip (zf,buf,size_read);
-                            if (err<0)
-                            {
-                                printf("error in writing %s in the zipfile\n",
-                                                 filenameinzip);
-                            }
-
-                        }
-                    } while ((err == ZIP_OK) && (size_read>0));
-
-                if (fin)
-                    fclose(fin);
-
-                if (err<0)
-                    err=ZIP_ERRNO;
-                else
-                {
-                    err = zipCloseFileInZip(zf);
-                    if (err!=ZIP_OK)
-                        printf("error in closing %s in the zipfile\n",
-                                    filenameinzip);
-                }
-            }
-        }
-        errclose = zipClose(zf,NULL);
-        if (errclose != ZIP_OK)
-            printf("error in closing %s\n",filename_try);
-    }
-    else
-    {
-       do_help();
-    }
-
-    free(buf);
-    return 0;
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/minizip/mztools.c gcc-4.6.3-psp/zlib/contrib/minizip/mztools.c
--- gcc-4.6.3/zlib/contrib/minizip/mztools.c	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/minizip/mztools.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,281 +0,0 @@
-/*
-  Additional tools for Minizip
-  Code: Xavier Roche '2004
-  License: Same as ZLIB (www.gzip.org)
-*/
-
-/* Code */
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "zlib.h"
-#include "unzip.h"
-
-#define READ_8(adr)  ((unsigned char)*(adr))
-#define READ_16(adr) ( READ_8(adr) | (READ_8(adr+1) << 8) )
-#define READ_32(adr) ( READ_16(adr) | (READ_16((adr)+2) << 16) )
-
-#define WRITE_8(buff, n) do { \
-  *((unsigned char*)(buff)) = (unsigned char) ((n) & 0xff); \
-} while(0)
-#define WRITE_16(buff, n) do { \
-  WRITE_8((unsigned char*)(buff), n); \
-  WRITE_8(((unsigned char*)(buff)) + 1, (n) >> 8); \
-} while(0)
-#define WRITE_32(buff, n) do { \
-  WRITE_16((unsigned char*)(buff), (n) & 0xffff); \
-  WRITE_16((unsigned char*)(buff) + 2, (n) >> 16); \
-} while(0)
-
-extern int ZEXPORT unzRepair(file, fileOut, fileOutTmp, nRecovered, bytesRecovered)
-const char* file;
-const char* fileOut;
-const char* fileOutTmp;
-uLong* nRecovered;
-uLong* bytesRecovered;
-{
-  int err = Z_OK;
-  FILE* fpZip = fopen(file, "rb");
-  FILE* fpOut = fopen(fileOut, "wb");
-  FILE* fpOutCD = fopen(fileOutTmp, "wb");
-  if (fpZip != NULL &&  fpOut != NULL) {
-    int entries = 0;
-    uLong totalBytes = 0;
-    char header[30];
-    char filename[256];
-    char extra[1024];
-    int offset = 0;
-    int offsetCD = 0;
-    while ( fread(header, 1, 30, fpZip) == 30 ) {
-      int currentOffset = offset;
-
-      /* File entry */
-      if (READ_32(header) == 0x04034b50) {
-        unsigned int version = READ_16(header + 4);
-        unsigned int gpflag = READ_16(header + 6);
-        unsigned int method = READ_16(header + 8);
-        unsigned int filetime = READ_16(header + 10);
-        unsigned int filedate = READ_16(header + 12);
-        unsigned int crc = READ_32(header + 14); /* crc */
-        unsigned int cpsize = READ_32(header + 18); /* compressed size */
-        unsigned int uncpsize = READ_32(header + 22); /* uncompressed sz */
-        unsigned int fnsize = READ_16(header + 26); /* file name length */
-        unsigned int extsize = READ_16(header + 28); /* extra field length */
-        filename[0] = extra[0] = '\0';
-        
-        /* Header */
-        if (fwrite(header, 1, 30, fpOut) == 30) {
-          offset += 30;
-        } else {
-          err = Z_ERRNO;
-          break;
-        }
-        
-        /* Filename */
-        if (fnsize > 0) {
-          if (fread(filename, 1, fnsize, fpZip) == fnsize) {
-            if (fwrite(filename, 1, fnsize, fpOut) == fnsize) {
-              offset += fnsize;
-            } else {
-              err = Z_ERRNO;
-              break;
-            }
-          } else {
-            err = Z_ERRNO;
-            break;
-          }
-        } else {
-          err = Z_STREAM_ERROR;
-          break;
-        }
-
-        /* Extra field */
-        if (extsize > 0) {
-          if (fread(extra, 1, extsize, fpZip) == extsize) {
-            if (fwrite(extra, 1, extsize, fpOut) == extsize) {
-              offset += extsize;
-            } else {
-              err = Z_ERRNO;
-              break;
-            }
-          } else {
-            err = Z_ERRNO;
-            break;
-          }
-        }
-        
-        /* Data */
-        {
-          int dataSize = cpsize;
-          if (dataSize == 0) {
-            dataSize = uncpsize;
-          }
-          if (dataSize > 0) {
-            char* data = malloc(dataSize);
-            if (data != NULL) {
-              if ((int)fread(data, 1, dataSize, fpZip) == dataSize) {
-                if ((int)fwrite(data, 1, dataSize, fpOut) == dataSize) {
-                  offset += dataSize;
-                  totalBytes += dataSize;
-                } else {
-                  err = Z_ERRNO;
-                }
-              } else {
-                err = Z_ERRNO;
-              }
-              free(data);
-              if (err != Z_OK) {
-                break;
-              }
-            } else {
-              err = Z_MEM_ERROR;
-              break;
-            }
-          }
-        }
-        
-        /* Central directory entry */
-        {
-          char header[46];
-          char* comment = "";
-          int comsize = (int) strlen(comment);
-          WRITE_32(header, 0x02014b50);
-          WRITE_16(header + 4, version);
-          WRITE_16(header + 6, version);
-          WRITE_16(header + 8, gpflag);
-          WRITE_16(header + 10, method);
-          WRITE_16(header + 12, filetime);
-          WRITE_16(header + 14, filedate);
-          WRITE_32(header + 16, crc);
-          WRITE_32(header + 20, cpsize);
-          WRITE_32(header + 24, uncpsize);
-          WRITE_16(header + 28, fnsize);
-          WRITE_16(header + 30, extsize);
-          WRITE_16(header + 32, comsize);
-          WRITE_16(header + 34, 0);     /* disk # */
-          WRITE_16(header + 36, 0);     /* int attrb */
-          WRITE_32(header + 38, 0);     /* ext attrb */
-          WRITE_32(header + 42, currentOffset);
-          /* Header */
-          if (fwrite(header, 1, 46, fpOutCD) == 46) {
-            offsetCD += 46;
-            
-            /* Filename */
-            if (fnsize > 0) {
-              if (fwrite(filename, 1, fnsize, fpOutCD) == fnsize) {
-                offsetCD += fnsize;
-              } else {
-                err = Z_ERRNO;
-                break;
-              }
-            } else {
-              err = Z_STREAM_ERROR;
-              break;
-            }
-            
-            /* Extra field */
-            if (extsize > 0) {
-              if (fwrite(extra, 1, extsize, fpOutCD) == extsize) {
-                offsetCD += extsize;
-              } else {
-                err = Z_ERRNO;
-                break;
-              }
-            }
-            
-            /* Comment field */
-            if (comsize > 0) {
-              if ((int)fwrite(comment, 1, comsize, fpOutCD) == comsize) {
-                offsetCD += comsize;
-              } else {
-                err = Z_ERRNO;
-                break;
-              }
-            }
-            
-            
-          } else {
-            err = Z_ERRNO;
-            break;
-          }
-        }
-
-        /* Success */
-        entries++;
-
-      } else {
-        break;
-      }
-    }
-
-    /* Final central directory  */
-    {
-      int entriesZip = entries;
-      char header[22];
-      char* comment = ""; // "ZIP File recovered by zlib/minizip/mztools";
-      int comsize = (int) strlen(comment);
-      if (entriesZip > 0xffff) {
-        entriesZip = 0xffff;
-      }
-      WRITE_32(header, 0x06054b50);
-      WRITE_16(header + 4, 0);    /* disk # */
-      WRITE_16(header + 6, 0);    /* disk # */
-      WRITE_16(header + 8, entriesZip);   /* hack */
-      WRITE_16(header + 10, entriesZip);  /* hack */
-      WRITE_32(header + 12, offsetCD);    /* size of CD */
-      WRITE_32(header + 16, offset);      /* offset to CD */
-      WRITE_16(header + 20, comsize);     /* comment */
-      
-      /* Header */
-      if (fwrite(header, 1, 22, fpOutCD) == 22) {
-        
-        /* Comment field */
-        if (comsize > 0) {
-          if ((int)fwrite(comment, 1, comsize, fpOutCD) != comsize) {
-            err = Z_ERRNO;
-          }
-        }
-        
-      } else {
-        err = Z_ERRNO;
-      }
-    }
-
-    /* Final merge (file + central directory) */
-    fclose(fpOutCD);
-    if (err == Z_OK) {
-      fpOutCD = fopen(fileOutTmp, "rb");
-      if (fpOutCD != NULL) {
-        int nRead;
-        char buffer[8192];
-        while ( (nRead = (int)fread(buffer, 1, sizeof(buffer), fpOutCD)) > 0) {
-          if ((int)fwrite(buffer, 1, nRead, fpOut) != nRead) {
-            err = Z_ERRNO;
-            break;
-          }
-        }
-        fclose(fpOutCD);
-      }
-    }
-    
-    /* Close */
-    fclose(fpZip);
-    fclose(fpOut);
-    
-    /* Wipe temporary file */
-    (void)remove(fileOutTmp);
-    
-    /* Number of recovered entries */
-    if (err == Z_OK) {
-      if (nRecovered != NULL) {
-        *nRecovered = entries;
-      }
-      if (bytesRecovered != NULL) {
-        *bytesRecovered = totalBytes;
-      }
-    }
-  } else {
-    err = Z_STREAM_ERROR;
-  }
-  return err;
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/minizip/mztools.h gcc-4.6.3-psp/zlib/contrib/minizip/mztools.h
--- gcc-4.6.3/zlib/contrib/minizip/mztools.h	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/minizip/mztools.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,31 +0,0 @@
-/*
-  Additional tools for Minizip
-  Code: Xavier Roche '2004
-  License: Same as ZLIB (www.gzip.org)
-*/
-
-#ifndef _zip_tools_H
-#define _zip_tools_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef _ZLIB_H
-#include "zlib.h"
-#endif
-
-#include "unzip.h"
-
-/* Repair a ZIP file (missing central directory) 
-   file: file to recover
-   fileOut: output file after recovery
-   fileOutTmp: temporary file name used for recovery
-*/
-extern int ZEXPORT unzRepair(const char* file, 
-                             const char* fileOut, 
-                             const char* fileOutTmp, 
-                             uLong* nRecovered,
-                             uLong* bytesRecovered);
-
-#endif
diff -Nbaur gcc-4.6.3/zlib/contrib/minizip/unzip.c gcc-4.6.3-psp/zlib/contrib/minizip/unzip.c
--- gcc-4.6.3/zlib/contrib/minizip/unzip.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/minizip/unzip.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1598 +0,0 @@
-/* unzip.c -- IO for uncompress .zip files using zlib
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-
-   Read unzip.h for more info
-*/
-
-/* Decryption code comes from crypt.c by Info-ZIP but has been greatly reduced in terms of
-compatibility with older software. The following is from the original crypt.c. Code
-woven in by Terry Thorsen 1/2003.
-*/
-/*
-  Copyright (c) 1990-2000 Info-ZIP.  All rights reserved.
-
-  See the accompanying file LICENSE, version 2000-Apr-09 or later
-  (the contents of which are also included in zip.h) for terms of use.
-  If, for some reason, all these files are missing, the Info-ZIP license
-  also may be found at:  ftp://ftp.info-zip.org/pub/infozip/license.html
-*/
-/*
-  crypt.c (full version) by Info-ZIP.      Last revised:  [see crypt.h]
-
-  The encryption/decryption parts of this source code (as opposed to the
-  non-echoing password parts) were originally written in Europe.  The
-  whole source package can be freely distributed, including from the USA.
-  (Prior to January 2000, re-export from the US was a violation of US law.)
- */
-
-/*
-  This encryption code is a direct transcription of the algorithm from
-  Roger Schlafly, described by Phil Katz in the file appnote.txt.  This
-  file (appnote.txt) is distributed with the PKZIP program (even in the
-  version without encryption capabilities).
- */
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "zlib.h"
-#include "unzip.h"
-
-#ifdef STDC
-#  include <stddef.h>
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-#ifdef NO_ERRNO_H
-    extern int errno;
-#else
-#   include <errno.h>
-#endif
-
-
-#ifndef local
-#  define local static
-#endif
-/* compile with -Dlocal if your debugger can't find static symbols */
-
-
-#ifndef CASESENSITIVITYDEFAULT_NO
-#  if !defined(unix) && !defined(CASESENSITIVITYDEFAULT_YES)
-#    define CASESENSITIVITYDEFAULT_NO
-#  endif
-#endif
-
-
-#ifndef UNZ_BUFSIZE
-#define UNZ_BUFSIZE (16384)
-#endif
-
-#ifndef UNZ_MAXFILENAMEINZIP
-#define UNZ_MAXFILENAMEINZIP (256)
-#endif
-
-#ifndef ALLOC
-# define ALLOC(size) (malloc(size))
-#endif
-#ifndef TRYFREE
-# define TRYFREE(p) {if (p) free(p);}
-#endif
-
-#define SIZECENTRALDIRITEM (0x2e)
-#define SIZEZIPLOCALHEADER (0x1e)
-
-
-
-
-const char unz_copyright[] =
-   " unzip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll";
-
-/* unz_file_info_interntal contain internal info about a file in zipfile*/
-typedef struct unz_file_info_internal_s
-{
-    uLong offset_curfile;/* relative offset of local header 4 bytes */
-} unz_file_info_internal;
-
-
-/* file_in_zip_read_info_s contain internal information about a file in zipfile,
-    when reading and decompress it */
-typedef struct
-{
-    char  *read_buffer;         /* internal buffer for compressed data */
-    z_stream stream;            /* zLib stream structure for inflate */
-
-    uLong pos_in_zipfile;       /* position in byte on the zipfile, for fseek*/
-    uLong stream_initialised;   /* flag set if stream structure is initialised*/
-
-    uLong offset_local_extrafield;/* offset of the local extra field */
-    uInt  size_local_extrafield;/* size of the local extra field */
-    uLong pos_local_extrafield;   /* position in the local extra field in read*/
-
-    uLong crc32;                /* crc32 of all data uncompressed */
-    uLong crc32_wait;           /* crc32 we must obtain after decompress all */
-    uLong rest_read_compressed; /* number of byte to be decompressed */
-    uLong rest_read_uncompressed;/*number of byte to be obtained after decomp*/
-    zlib_filefunc_def z_filefunc;
-    voidpf filestream;        /* io structore of the zipfile */
-    uLong compression_method;   /* compression method (0==store) */
-    uLong byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
-    int   raw;
-} file_in_zip_read_info_s;
-
-
-/* unz_s contain internal information about the zipfile
-*/
-typedef struct
-{
-    zlib_filefunc_def z_filefunc;
-    voidpf filestream;        /* io structore of the zipfile */
-    unz_global_info gi;       /* public global information */
-    uLong byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
-    uLong num_file;             /* number of the current file in the zipfile*/
-    uLong pos_in_central_dir;   /* pos of the current file in the central dir*/
-    uLong current_file_ok;      /* flag about the usability of the current file*/
-    uLong central_pos;          /* position of the beginning of the central dir*/
-
-    uLong size_central_dir;     /* size of the central directory  */
-    uLong offset_central_dir;   /* offset of start of central directory with
-                                   respect to the starting disk number */
-
-    unz_file_info cur_file_info; /* public info about the current file in zip*/
-    unz_file_info_internal cur_file_info_internal; /* private info about it*/
-    file_in_zip_read_info_s* pfile_in_zip_read; /* structure about the current
-                                        file if we are decompressing it */
-    int encrypted;
-#    ifndef NOUNCRYPT
-    unsigned long keys[3];     /* keys defining the pseudo-random sequence */
-    const unsigned long* pcrc_32_tab;
-#    endif
-} unz_s;
-
-
-#ifndef NOUNCRYPT
-#include "crypt.h"
-#endif
-
-/* ===========================================================================
-     Read a byte from a gz_stream; update next_in and avail_in. Return EOF
-   for end of file.
-   IN assertion: the stream s has been sucessfully opened for reading.
-*/
-
-
-local int unzlocal_getByte OF((
-    const zlib_filefunc_def* pzlib_filefunc_def,
-    voidpf filestream,
-    int *pi));
-
-local int unzlocal_getByte(pzlib_filefunc_def,filestream,pi)
-    const zlib_filefunc_def* pzlib_filefunc_def;
-    voidpf filestream;
-    int *pi;
-{
-    unsigned char c;
-    int err = (int)ZREAD(*pzlib_filefunc_def,filestream,&c,1);
-    if (err==1)
-    {
-        *pi = (int)c;
-        return UNZ_OK;
-    }
-    else
-    {
-        if (ZERROR(*pzlib_filefunc_def,filestream))
-            return UNZ_ERRNO;
-        else
-            return UNZ_EOF;
-    }
-}
-
-
-/* ===========================================================================
-   Reads a long in LSB order from the given gz_stream. Sets
-*/
-local int unzlocal_getShort OF((
-    const zlib_filefunc_def* pzlib_filefunc_def,
-    voidpf filestream,
-    uLong *pX));
-
-local int unzlocal_getShort (pzlib_filefunc_def,filestream,pX)
-    const zlib_filefunc_def* pzlib_filefunc_def;
-    voidpf filestream;
-    uLong *pX;
-{
-    uLong x ;
-    int i;
-    int err;
-
-    err = unzlocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x = (uLong)i;
-
-    if (err==UNZ_OK)
-        err = unzlocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<8;
-
-    if (err==UNZ_OK)
-        *pX = x;
-    else
-        *pX = 0;
-    return err;
-}
-
-local int unzlocal_getLong OF((
-    const zlib_filefunc_def* pzlib_filefunc_def,
-    voidpf filestream,
-    uLong *pX));
-
-local int unzlocal_getLong (pzlib_filefunc_def,filestream,pX)
-    const zlib_filefunc_def* pzlib_filefunc_def;
-    voidpf filestream;
-    uLong *pX;
-{
-    uLong x ;
-    int i;
-    int err;
-
-    err = unzlocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x = (uLong)i;
-
-    if (err==UNZ_OK)
-        err = unzlocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<8;
-
-    if (err==UNZ_OK)
-        err = unzlocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<16;
-
-    if (err==UNZ_OK)
-        err = unzlocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<24;
-
-    if (err==UNZ_OK)
-        *pX = x;
-    else
-        *pX = 0;
-    return err;
-}
-
-
-/* My own strcmpi / strcasecmp */
-local int strcmpcasenosensitive_internal (fileName1,fileName2)
-    const char* fileName1;
-    const char* fileName2;
-{
-    for (;;)
-    {
-        char c1=*(fileName1++);
-        char c2=*(fileName2++);
-        if ((c1>='a') && (c1<='z'))
-            c1 -= 0x20;
-        if ((c2>='a') && (c2<='z'))
-            c2 -= 0x20;
-        if (c1=='\0')
-            return ((c2=='\0') ? 0 : -1);
-        if (c2=='\0')
-            return 1;
-        if (c1<c2)
-            return -1;
-        if (c1>c2)
-            return 1;
-    }
-}
-
-
-#ifdef  CASESENSITIVITYDEFAULT_NO
-#define CASESENSITIVITYDEFAULTVALUE 2
-#else
-#define CASESENSITIVITYDEFAULTVALUE 1
-#endif
-
-#ifndef STRCMPCASENOSENTIVEFUNCTION
-#define STRCMPCASENOSENTIVEFUNCTION strcmpcasenosensitive_internal
-#endif
-
-/*
-   Compare two filename (fileName1,fileName2).
-   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
-   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
-                                                                or strcasecmp)
-   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
-        (like 1 on Unix, 2 on Windows)
-
-*/
-extern int ZEXPORT unzStringFileNameCompare (fileName1,fileName2,iCaseSensitivity)
-    const char* fileName1;
-    const char* fileName2;
-    int iCaseSensitivity;
-{
-    if (iCaseSensitivity==0)
-        iCaseSensitivity=CASESENSITIVITYDEFAULTVALUE;
-
-    if (iCaseSensitivity==1)
-        return strcmp(fileName1,fileName2);
-
-    return STRCMPCASENOSENTIVEFUNCTION(fileName1,fileName2);
-}
-
-#ifndef BUFREADCOMMENT
-#define BUFREADCOMMENT (0x400)
-#endif
-
-/*
-  Locate the Central directory of a zipfile (at the end, just before
-    the global comment)
-*/
-local uLong unzlocal_SearchCentralDir OF((
-    const zlib_filefunc_def* pzlib_filefunc_def,
-    voidpf filestream));
-
-local uLong unzlocal_SearchCentralDir(pzlib_filefunc_def,filestream)
-    const zlib_filefunc_def* pzlib_filefunc_def;
-    voidpf filestream;
-{
-    unsigned char* buf;
-    uLong uSizeFile;
-    uLong uBackRead;
-    uLong uMaxBack=0xffff; /* maximum size of global comment */
-    uLong uPosFound=0;
-
-    if (ZSEEK(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
-        return 0;
-
-
-    uSizeFile = ZTELL(*pzlib_filefunc_def,filestream);
-
-    if (uMaxBack>uSizeFile)
-        uMaxBack = uSizeFile;
-
-    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
-    if (buf==NULL)
-        return 0;
-
-    uBackRead = 4;
-    while (uBackRead<uMaxBack)
-    {
-        uLong uReadSize,uReadPos ;
-        int i;
-        if (uBackRead+BUFREADCOMMENT>uMaxBack)
-            uBackRead = uMaxBack;
-        else
-            uBackRead+=BUFREADCOMMENT;
-        uReadPos = uSizeFile-uBackRead ;
-
-        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
-                     (BUFREADCOMMENT+4) : (uSizeFile-uReadPos);
-        if (ZSEEK(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            break;
-
-        if (ZREAD(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
-            break;
-
-        for (i=(int)uReadSize-3; (i--)>0;)
-            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&
-                ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))
-            {
-                uPosFound = uReadPos+i;
-                break;
-            }
-
-        if (uPosFound!=0)
-            break;
-    }
-    TRYFREE(buf);
-    return uPosFound;
-}
-
-/*
-  Open a Zip file. path contain the full pathname (by example,
-     on a Windows NT computer "c:\\test\\zlib114.zip" or on an Unix computer
-     "zlib/zlib114.zip".
-     If the zipfile cannot be opened (file doesn't exist or in not valid), the
-       return value is NULL.
-     Else, the return value is a unzFile Handle, usable with other function
-       of this unzip package.
-*/
-extern unzFile ZEXPORT unzOpen2 (path, pzlib_filefunc_def)
-    const char *path;
-    zlib_filefunc_def* pzlib_filefunc_def;
-{
-    unz_s us;
-    unz_s *s;
-    uLong central_pos,uL;
-
-    uLong number_disk;          /* number of the current dist, used for
-                                   spaning ZIP, unsupported, always 0*/
-    uLong number_disk_with_CD;  /* number the the disk with central dir, used
-                                   for spaning ZIP, unsupported, always 0*/
-    uLong number_entry_CD;      /* total number of entries in
-                                   the central dir
-                                   (same than number_entry on nospan) */
-
-    int err=UNZ_OK;
-
-    if (unz_copyright[0]!=' ')
-        return NULL;
-
-    if (pzlib_filefunc_def==NULL)
-        fill_fopen_filefunc(&us.z_filefunc);
-    else
-        us.z_filefunc = *pzlib_filefunc_def;
-
-    us.filestream= (*(us.z_filefunc.zopen_file))(us.z_filefunc.opaque,
-                                                 path,
-                                                 ZLIB_FILEFUNC_MODE_READ |
-                                                 ZLIB_FILEFUNC_MODE_EXISTING);
-    if (us.filestream==NULL)
-        return NULL;
-
-    central_pos = unzlocal_SearchCentralDir(&us.z_filefunc,us.filestream);
-    if (central_pos==0)
-        err=UNZ_ERRNO;
-
-    if (ZSEEK(us.z_filefunc, us.filestream,
-                                      central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-        err=UNZ_ERRNO;
-
-    /* the signature, already checked */
-    if (unzlocal_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
-        err=UNZ_ERRNO;
-
-    /* number of this disk */
-    if (unzlocal_getShort(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)
-        err=UNZ_ERRNO;
-
-    /* number of the disk with the start of the central directory */
-    if (unzlocal_getShort(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)
-        err=UNZ_ERRNO;
-
-    /* total number of entries in the central dir on this disk */
-    if (unzlocal_getShort(&us.z_filefunc, us.filestream,&us.gi.number_entry)!=UNZ_OK)
-        err=UNZ_ERRNO;
-
-    /* total number of entries in the central dir */
-    if (unzlocal_getShort(&us.z_filefunc, us.filestream,&number_entry_CD)!=UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if ((number_entry_CD!=us.gi.number_entry) ||
-        (number_disk_with_CD!=0) ||
-        (number_disk!=0))
-        err=UNZ_BADZIPFILE;
-
-    /* size of the central directory */
-    if (unzlocal_getLong(&us.z_filefunc, us.filestream,&us.size_central_dir)!=UNZ_OK)
-        err=UNZ_ERRNO;
-
-    /* offset of start of central directory with respect to the
-          starting disk number */
-    if (unzlocal_getLong(&us.z_filefunc, us.filestream,&us.offset_central_dir)!=UNZ_OK)
-        err=UNZ_ERRNO;
-
-    /* zipfile comment length */
-    if (unzlocal_getShort(&us.z_filefunc, us.filestream,&us.gi.size_comment)!=UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if ((central_pos<us.offset_central_dir+us.size_central_dir) &&
-        (err==UNZ_OK))
-        err=UNZ_BADZIPFILE;
-
-    if (err!=UNZ_OK)
-    {
-        ZCLOSE(us.z_filefunc, us.filestream);
-        return NULL;
-    }
-
-    us.byte_before_the_zipfile = central_pos -
-                            (us.offset_central_dir+us.size_central_dir);
-    us.central_pos = central_pos;
-    us.pfile_in_zip_read = NULL;
-    us.encrypted = 0;
-
-
-    s=(unz_s*)ALLOC(sizeof(unz_s));
-    *s=us;
-    unzGoToFirstFile((unzFile)s);
-    return (unzFile)s;
-}
-
-
-extern unzFile ZEXPORT unzOpen (path)
-    const char *path;
-{
-    return unzOpen2(path, NULL);
-}
-
-/*
-  Close a ZipFile opened with unzipOpen.
-  If there is files inside the .Zip opened with unzipOpenCurrentFile (see later),
-    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.
-  return UNZ_OK if there is no problem. */
-extern int ZEXPORT unzClose (file)
-    unzFile file;
-{
-    unz_s* s;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-
-    if (s->pfile_in_zip_read!=NULL)
-        unzCloseCurrentFile(file);
-
-    ZCLOSE(s->z_filefunc, s->filestream);
-    TRYFREE(s);
-    return UNZ_OK;
-}
-
-
-/*
-  Write info about the ZipFile in the *pglobal_info structure.
-  No preparation of the structure is needed
-  return UNZ_OK if there is no problem. */
-extern int ZEXPORT unzGetGlobalInfo (file,pglobal_info)
-    unzFile file;
-    unz_global_info *pglobal_info;
-{
-    unz_s* s;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    *pglobal_info=s->gi;
-    return UNZ_OK;
-}
-
-
-/*
-   Translate date/time from Dos format to tm_unz (readable more easilty)
-*/
-local void unzlocal_DosDateToTmuDate (ulDosDate, ptm)
-    uLong ulDosDate;
-    tm_unz* ptm;
-{
-    uLong uDate;
-    uDate = (uLong)(ulDosDate>>16);
-    ptm->tm_mday = (uInt)(uDate&0x1f) ;
-    ptm->tm_mon =  (uInt)((((uDate)&0x1E0)/0x20)-1) ;
-    ptm->tm_year = (uInt)(((uDate&0x0FE00)/0x0200)+1980) ;
-
-    ptm->tm_hour = (uInt) ((ulDosDate &0xF800)/0x800);
-    ptm->tm_min =  (uInt) ((ulDosDate&0x7E0)/0x20) ;
-    ptm->tm_sec =  (uInt) (2*(ulDosDate&0x1f)) ;
-}
-
-/*
-  Get Info about the current file in the zipfile, with internal only info
-*/
-local int unzlocal_GetCurrentFileInfoInternal OF((unzFile file,
-                                                  unz_file_info *pfile_info,
-                                                  unz_file_info_internal
-                                                  *pfile_info_internal,
-                                                  char *szFileName,
-                                                  uLong fileNameBufferSize,
-                                                  void *extraField,
-                                                  uLong extraFieldBufferSize,
-                                                  char *szComment,
-                                                  uLong commentBufferSize));
-
-local int unzlocal_GetCurrentFileInfoInternal (file,
-                                              pfile_info,
-                                              pfile_info_internal,
-                                              szFileName, fileNameBufferSize,
-                                              extraField, extraFieldBufferSize,
-                                              szComment,  commentBufferSize)
-    unzFile file;
-    unz_file_info *pfile_info;
-    unz_file_info_internal *pfile_info_internal;
-    char *szFileName;
-    uLong fileNameBufferSize;
-    void *extraField;
-    uLong extraFieldBufferSize;
-    char *szComment;
-    uLong commentBufferSize;
-{
-    unz_s* s;
-    unz_file_info file_info;
-    unz_file_info_internal file_info_internal;
-    int err=UNZ_OK;
-    uLong uMagic;
-    long lSeek=0;
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    if (ZSEEK(s->z_filefunc, s->filestream,
-              s->pos_in_central_dir+s->byte_before_the_zipfile,
-              ZLIB_FILEFUNC_SEEK_SET)!=0)
-        err=UNZ_ERRNO;
-
-
-    /* we check the magic */
-    if (err==UNZ_OK)
-        if (unzlocal_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)
-            err=UNZ_ERRNO;
-        else if (uMagic!=0x02014b50)
-            err=UNZ_BADZIPFILE;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.version) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.version_needed) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.flag) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.compression_method) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&file_info.dosDate) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    unzlocal_DosDateToTmuDate(file_info.dosDate,&file_info.tmu_date);
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&file_info.crc) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&file_info.compressed_size) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&file_info.uncompressed_size) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.size_filename) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_extra) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_comment) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.disk_num_start) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&file_info.internal_fa) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&file_info.external_fa) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&file_info_internal.offset_curfile) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    lSeek+=file_info.size_filename;
-    if ((err==UNZ_OK) && (szFileName!=NULL))
-    {
-        uLong uSizeRead ;
-        if (file_info.size_filename<fileNameBufferSize)
-        {
-            *(szFileName+file_info.size_filename)='\0';
-            uSizeRead = file_info.size_filename;
-        }
-        else
-            uSizeRead = fileNameBufferSize;
-
-        if ((file_info.size_filename>0) && (fileNameBufferSize>0))
-            if (ZREAD(s->z_filefunc, s->filestream,szFileName,uSizeRead)!=uSizeRead)
-                err=UNZ_ERRNO;
-        lSeek -= uSizeRead;
-    }
-
-
-    if ((err==UNZ_OK) && (extraField!=NULL))
-    {
-        uLong uSizeRead ;
-        if (file_info.size_file_extra<extraFieldBufferSize)
-            uSizeRead = file_info.size_file_extra;
-        else
-            uSizeRead = extraFieldBufferSize;
-
-        if (lSeek!=0)
-            if (ZSEEK(s->z_filefunc, s->filestream,lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)
-                lSeek=0;
-            else
-                err=UNZ_ERRNO;
-        if ((file_info.size_file_extra>0) && (extraFieldBufferSize>0))
-            if (ZREAD(s->z_filefunc, s->filestream,extraField,uSizeRead)!=uSizeRead)
-                err=UNZ_ERRNO;
-        lSeek += file_info.size_file_extra - uSizeRead;
-    }
-    else
-        lSeek+=file_info.size_file_extra;
-
-
-    if ((err==UNZ_OK) && (szComment!=NULL))
-    {
-        uLong uSizeRead ;
-        if (file_info.size_file_comment<commentBufferSize)
-        {
-            *(szComment+file_info.size_file_comment)='\0';
-            uSizeRead = file_info.size_file_comment;
-        }
-        else
-            uSizeRead = commentBufferSize;
-
-        if (lSeek!=0)
-            if (ZSEEK(s->z_filefunc, s->filestream,lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)
-                lSeek=0;
-            else
-                err=UNZ_ERRNO;
-        if ((file_info.size_file_comment>0) && (commentBufferSize>0))
-            if (ZREAD(s->z_filefunc, s->filestream,szComment,uSizeRead)!=uSizeRead)
-                err=UNZ_ERRNO;
-        lSeek+=file_info.size_file_comment - uSizeRead;
-    }
-    else
-        lSeek+=file_info.size_file_comment;
-
-    if ((err==UNZ_OK) && (pfile_info!=NULL))
-        *pfile_info=file_info;
-
-    if ((err==UNZ_OK) && (pfile_info_internal!=NULL))
-        *pfile_info_internal=file_info_internal;
-
-    return err;
-}
-
-
-
-/*
-  Write info about the ZipFile in the *pglobal_info structure.
-  No preparation of the structure is needed
-  return UNZ_OK if there is no problem.
-*/
-extern int ZEXPORT unzGetCurrentFileInfo (file,
-                                          pfile_info,
-                                          szFileName, fileNameBufferSize,
-                                          extraField, extraFieldBufferSize,
-                                          szComment,  commentBufferSize)
-    unzFile file;
-    unz_file_info *pfile_info;
-    char *szFileName;
-    uLong fileNameBufferSize;
-    void *extraField;
-    uLong extraFieldBufferSize;
-    char *szComment;
-    uLong commentBufferSize;
-{
-    return unzlocal_GetCurrentFileInfoInternal(file,pfile_info,NULL,
-                                                szFileName,fileNameBufferSize,
-                                                extraField,extraFieldBufferSize,
-                                                szComment,commentBufferSize);
-}
-
-/*
-  Set the current file of the zipfile to the first file.
-  return UNZ_OK if there is no problem
-*/
-extern int ZEXPORT unzGoToFirstFile (file)
-    unzFile file;
-{
-    int err=UNZ_OK;
-    unz_s* s;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    s->pos_in_central_dir=s->offset_central_dir;
-    s->num_file=0;
-    err=unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,
-                                             &s->cur_file_info_internal,
-                                             NULL,0,NULL,0,NULL,0);
-    s->current_file_ok = (err == UNZ_OK);
-    return err;
-}
-
-/*
-  Set the current file of the zipfile to the next file.
-  return UNZ_OK if there is no problem
-  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
-*/
-extern int ZEXPORT unzGoToNextFile (file)
-    unzFile file;
-{
-    unz_s* s;
-    int err;
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    if (!s->current_file_ok)
-        return UNZ_END_OF_LIST_OF_FILE;
-    if (s->gi.number_entry != 0xffff)    /* 2^16 files overflow hack */
-      if (s->num_file+1==s->gi.number_entry)
-        return UNZ_END_OF_LIST_OF_FILE;
-
-    s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +
-            s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;
-    s->num_file++;
-    err = unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,
-                                               &s->cur_file_info_internal,
-                                               NULL,0,NULL,0,NULL,0);
-    s->current_file_ok = (err == UNZ_OK);
-    return err;
-}
-
-
-/*
-  Try locate the file szFileName in the zipfile.
-  For the iCaseSensitivity signification, see unzipStringFileNameCompare
-
-  return value :
-  UNZ_OK if the file is found. It becomes the current file.
-  UNZ_END_OF_LIST_OF_FILE if the file is not found
-*/
-extern int ZEXPORT unzLocateFile (file, szFileName, iCaseSensitivity)
-    unzFile file;
-    const char *szFileName;
-    int iCaseSensitivity;
-{
-    unz_s* s;
-    int err;
-
-    /* We remember the 'current' position in the file so that we can jump
-     * back there if we fail.
-     */
-    unz_file_info cur_file_infoSaved;
-    unz_file_info_internal cur_file_info_internalSaved;
-    uLong num_fileSaved;
-    uLong pos_in_central_dirSaved;
-
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-
-    if (strlen(szFileName)>=UNZ_MAXFILENAMEINZIP)
-        return UNZ_PARAMERROR;
-
-    s=(unz_s*)file;
-    if (!s->current_file_ok)
-        return UNZ_END_OF_LIST_OF_FILE;
-
-    /* Save the current state */
-    num_fileSaved = s->num_file;
-    pos_in_central_dirSaved = s->pos_in_central_dir;
-    cur_file_infoSaved = s->cur_file_info;
-    cur_file_info_internalSaved = s->cur_file_info_internal;
-
-    err = unzGoToFirstFile(file);
-
-    while (err == UNZ_OK)
-    {
-        char szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];
-        err = unzGetCurrentFileInfo(file,NULL,
-                                    szCurrentFileName,sizeof(szCurrentFileName)-1,
-                                    NULL,0,NULL,0);
-        if (err == UNZ_OK)
-        {
-            if (unzStringFileNameCompare(szCurrentFileName,
-                                            szFileName,iCaseSensitivity)==0)
-                return UNZ_OK;
-            err = unzGoToNextFile(file);
-        }
-    }
-
-    /* We failed, so restore the state of the 'current file' to where we
-     * were.
-     */
-    s->num_file = num_fileSaved ;
-    s->pos_in_central_dir = pos_in_central_dirSaved ;
-    s->cur_file_info = cur_file_infoSaved;
-    s->cur_file_info_internal = cur_file_info_internalSaved;
-    return err;
-}
-
-
-/*
-///////////////////////////////////////////
-// Contributed by Ryan Haksi (mailto://cryogen@infoserve.net)
-// I need random access
-//
-// Further optimization could be realized by adding an ability
-// to cache the directory in memory. The goal being a single
-// comprehensive file read to put the file I need in a memory.
-*/
-
-/*
-typedef struct unz_file_pos_s
-{
-    uLong pos_in_zip_directory;   // offset in file
-    uLong num_of_file;            // # of file
-} unz_file_pos;
-*/
-
-extern int ZEXPORT unzGetFilePos(file, file_pos)
-    unzFile file;
-    unz_file_pos* file_pos;
-{
-    unz_s* s;
-
-    if (file==NULL || file_pos==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    if (!s->current_file_ok)
-        return UNZ_END_OF_LIST_OF_FILE;
-
-    file_pos->pos_in_zip_directory  = s->pos_in_central_dir;
-    file_pos->num_of_file           = s->num_file;
-
-    return UNZ_OK;
-}
-
-extern int ZEXPORT unzGoToFilePos(file, file_pos)
-    unzFile file;
-    unz_file_pos* file_pos;
-{
-    unz_s* s;
-    int err;
-
-    if (file==NULL || file_pos==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-
-    /* jump to the right spot */
-    s->pos_in_central_dir = file_pos->pos_in_zip_directory;
-    s->num_file           = file_pos->num_of_file;
-
-    /* set the current file */
-    err = unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,
-                                               &s->cur_file_info_internal,
-                                               NULL,0,NULL,0,NULL,0);
-    /* return results */
-    s->current_file_ok = (err == UNZ_OK);
-    return err;
-}
-
-/*
-// Unzip Helper Functions - should be here?
-///////////////////////////////////////////
-*/
-
-/*
-  Read the local header of the current zipfile
-  Check the coherency of the local header and info in the end of central
-        directory about this file
-  store in *piSizeVar the size of extra info in local header
-        (filename and size of extra field data)
-*/
-local int unzlocal_CheckCurrentFileCoherencyHeader (s,piSizeVar,
-                                                    poffset_local_extrafield,
-                                                    psize_local_extrafield)
-    unz_s* s;
-    uInt* piSizeVar;
-    uLong *poffset_local_extrafield;
-    uInt  *psize_local_extrafield;
-{
-    uLong uMagic,uData,uFlags;
-    uLong size_filename;
-    uLong size_extra_field;
-    int err=UNZ_OK;
-
-    *piSizeVar = 0;
-    *poffset_local_extrafield = 0;
-    *psize_local_extrafield = 0;
-
-    if (ZSEEK(s->z_filefunc, s->filestream,s->cur_file_info_internal.offset_curfile +
-                                s->byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET)!=0)
-        return UNZ_ERRNO;
-
-
-    if (err==UNZ_OK)
-        if (unzlocal_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)
-            err=UNZ_ERRNO;
-        else if (uMagic!=0x04034b50)
-            err=UNZ_BADZIPFILE;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)
-        err=UNZ_ERRNO;
-/*
-    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))
-        err=UNZ_BADZIPFILE;
-*/
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&uFlags) != UNZ_OK)
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)
-        err=UNZ_ERRNO;
-    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))
-        err=UNZ_BADZIPFILE;
-
-    if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&
-                         (s->cur_file_info.compression_method!=Z_DEFLATED))
-        err=UNZ_BADZIPFILE;
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* date/time */
-        err=UNZ_ERRNO;
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* crc */
-        err=UNZ_ERRNO;
-    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) &&
-                              ((uFlags & 8)==0))
-        err=UNZ_BADZIPFILE;
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size compr */
-        err=UNZ_ERRNO;
-    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) &&
-                              ((uFlags & 8)==0))
-        err=UNZ_BADZIPFILE;
-
-    if (unzlocal_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size uncompr */
-        err=UNZ_ERRNO;
-    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) &&
-                              ((uFlags & 8)==0))
-        err=UNZ_BADZIPFILE;
-
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&size_filename) != UNZ_OK)
-        err=UNZ_ERRNO;
-    else if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))
-        err=UNZ_BADZIPFILE;
-
-    *piSizeVar += (uInt)size_filename;
-
-    if (unzlocal_getShort(&s->z_filefunc, s->filestream,&size_extra_field) != UNZ_OK)
-        err=UNZ_ERRNO;
-    *poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +
-                                    SIZEZIPLOCALHEADER + size_filename;
-    *psize_local_extrafield = (uInt)size_extra_field;
-
-    *piSizeVar += (uInt)size_extra_field;
-
-    return err;
-}
-
-/*
-  Open for reading data the current file in the zipfile.
-  If there is no error and the file is opened, the return value is UNZ_OK.
-*/
-extern int ZEXPORT unzOpenCurrentFile3 (file, method, level, raw, password)
-    unzFile file;
-    int* method;
-    int* level;
-    int raw;
-    const char* password;
-{
-    int err=UNZ_OK;
-    uInt iSizeVar;
-    unz_s* s;
-    file_in_zip_read_info_s* pfile_in_zip_read_info;
-    uLong offset_local_extrafield;  /* offset of the local extra field */
-    uInt  size_local_extrafield;    /* size of the local extra field */
-#    ifndef NOUNCRYPT
-    char source[12];
-#    else
-    if (password != NULL)
-        return UNZ_PARAMERROR;
-#    endif
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    if (!s->current_file_ok)
-        return UNZ_PARAMERROR;
-
-    if (s->pfile_in_zip_read != NULL)
-        unzCloseCurrentFile(file);
-
-    if (unzlocal_CheckCurrentFileCoherencyHeader(s,&iSizeVar,
-                &offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)
-        return UNZ_BADZIPFILE;
-
-    pfile_in_zip_read_info = (file_in_zip_read_info_s*)
-                                        ALLOC(sizeof(file_in_zip_read_info_s));
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_INTERNALERROR;
-
-    pfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);
-    pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;
-    pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;
-    pfile_in_zip_read_info->pos_local_extrafield=0;
-    pfile_in_zip_read_info->raw=raw;
-
-    if (pfile_in_zip_read_info->read_buffer==NULL)
-    {
-        TRYFREE(pfile_in_zip_read_info);
-        return UNZ_INTERNALERROR;
-    }
-
-    pfile_in_zip_read_info->stream_initialised=0;
-
-    if (method!=NULL)
-        *method = (int)s->cur_file_info.compression_method;
-
-    if (level!=NULL)
-    {
-        *level = 6;
-        switch (s->cur_file_info.flag & 0x06)
-        {
-          case 6 : *level = 1; break;
-          case 4 : *level = 2; break;
-          case 2 : *level = 9; break;
-        }
-    }
-
-    if ((s->cur_file_info.compression_method!=0) &&
-        (s->cur_file_info.compression_method!=Z_DEFLATED))
-        err=UNZ_BADZIPFILE;
-
-    pfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;
-    pfile_in_zip_read_info->crc32=0;
-    pfile_in_zip_read_info->compression_method =
-            s->cur_file_info.compression_method;
-    pfile_in_zip_read_info->filestream=s->filestream;
-    pfile_in_zip_read_info->z_filefunc=s->z_filefunc;
-    pfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;
-
-    pfile_in_zip_read_info->stream.total_out = 0;
-
-    if ((s->cur_file_info.compression_method==Z_DEFLATED) &&
-        (!raw))
-    {
-      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
-      pfile_in_zip_read_info->stream.zfree = (free_func)0;
-      pfile_in_zip_read_info->stream.opaque = (voidpf)0;
-      pfile_in_zip_read_info->stream.next_in = (voidpf)0;
-      pfile_in_zip_read_info->stream.avail_in = 0;
-
-      err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);
-      if (err == Z_OK)
-        pfile_in_zip_read_info->stream_initialised=1;
-      else
-      {
-        TRYFREE(pfile_in_zip_read_info);
-        return err;
-      }
-        /* windowBits is passed < 0 to tell that there is no zlib header.
-         * Note that in this case inflate *requires* an extra "dummy" byte
-         * after the compressed stream in order to complete decompression and
-         * return Z_STREAM_END.
-         * In unzip, i don't wait absolutely Z_STREAM_END because I known the
-         * size of both compressed and uncompressed data
-         */
-    }
-    pfile_in_zip_read_info->rest_read_compressed =
-            s->cur_file_info.compressed_size ;
-    pfile_in_zip_read_info->rest_read_uncompressed =
-            s->cur_file_info.uncompressed_size ;
-
-
-    pfile_in_zip_read_info->pos_in_zipfile =
-            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER +
-              iSizeVar;
-
-    pfile_in_zip_read_info->stream.avail_in = (uInt)0;
-
-    s->pfile_in_zip_read = pfile_in_zip_read_info;
-
-#    ifndef NOUNCRYPT
-    if (password != NULL)
-    {
-        int i;
-        s->pcrc_32_tab = get_crc_table();
-        init_keys(password,s->keys,s->pcrc_32_tab);
-        if (ZSEEK(s->z_filefunc, s->filestream,
-                  s->pfile_in_zip_read->pos_in_zipfile +
-                     s->pfile_in_zip_read->byte_before_the_zipfile,
-                  SEEK_SET)!=0)
-            return UNZ_INTERNALERROR;
-        if(ZREAD(s->z_filefunc, s->filestream,source, 12)<12)
-            return UNZ_INTERNALERROR;
-
-        for (i = 0; i<12; i++)
-            zdecode(s->keys,s->pcrc_32_tab,source[i]);
-
-        s->pfile_in_zip_read->pos_in_zipfile+=12;
-        s->encrypted=1;
-    }
-#    endif
-
-
-    return UNZ_OK;
-}
-
-extern int ZEXPORT unzOpenCurrentFile (file)
-    unzFile file;
-{
-    return unzOpenCurrentFile3(file, NULL, NULL, 0, NULL);
-}
-
-extern int ZEXPORT unzOpenCurrentFilePassword (file, password)
-    unzFile file;
-    const char* password;
-{
-    return unzOpenCurrentFile3(file, NULL, NULL, 0, password);
-}
-
-extern int ZEXPORT unzOpenCurrentFile2 (file,method,level,raw)
-    unzFile file;
-    int* method;
-    int* level;
-    int raw;
-{
-    return unzOpenCurrentFile3(file, method, level, raw, NULL);
-}
-
-/*
-  Read bytes from the current file.
-  buf contain buffer where data must be copied
-  len the size of buf.
-
-  return the number of byte copied if somes bytes are copied
-  return 0 if the end of file was reached
-  return <0 with error code if there is an error
-    (UNZ_ERRNO for IO error, or zLib error for uncompress error)
-*/
-extern int ZEXPORT unzReadCurrentFile  (file, buf, len)
-    unzFile file;
-    voidp buf;
-    unsigned len;
-{
-    int err=UNZ_OK;
-    uInt iRead = 0;
-    unz_s* s;
-    file_in_zip_read_info_s* pfile_in_zip_read_info;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-
-    if ((pfile_in_zip_read_info->read_buffer == NULL))
-        return UNZ_END_OF_LIST_OF_FILE;
-    if (len==0)
-        return 0;
-
-    pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;
-
-    pfile_in_zip_read_info->stream.avail_out = (uInt)len;
-
-    if ((len>pfile_in_zip_read_info->rest_read_uncompressed) &&
-        (!(pfile_in_zip_read_info->raw)))
-        pfile_in_zip_read_info->stream.avail_out =
-            (uInt)pfile_in_zip_read_info->rest_read_uncompressed;
-
-    if ((len>pfile_in_zip_read_info->rest_read_compressed+
-           pfile_in_zip_read_info->stream.avail_in) &&
-         (pfile_in_zip_read_info->raw))
-        pfile_in_zip_read_info->stream.avail_out =
-            (uInt)pfile_in_zip_read_info->rest_read_compressed+
-            pfile_in_zip_read_info->stream.avail_in;
-
-    while (pfile_in_zip_read_info->stream.avail_out>0)
-    {
-        if ((pfile_in_zip_read_info->stream.avail_in==0) &&
-            (pfile_in_zip_read_info->rest_read_compressed>0))
-        {
-            uInt uReadThis = UNZ_BUFSIZE;
-            if (pfile_in_zip_read_info->rest_read_compressed<uReadThis)
-                uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;
-            if (uReadThis == 0)
-                return UNZ_EOF;
-            if (ZSEEK(pfile_in_zip_read_info->z_filefunc,
-                      pfile_in_zip_read_info->filestream,
-                      pfile_in_zip_read_info->pos_in_zipfile +
-                         pfile_in_zip_read_info->byte_before_the_zipfile,
-                         ZLIB_FILEFUNC_SEEK_SET)!=0)
-                return UNZ_ERRNO;
-            if (ZREAD(pfile_in_zip_read_info->z_filefunc,
-                      pfile_in_zip_read_info->filestream,
-                      pfile_in_zip_read_info->read_buffer,
-                      uReadThis)!=uReadThis)
-                return UNZ_ERRNO;
-
-
-#            ifndef NOUNCRYPT
-            if(s->encrypted)
-            {
-                uInt i;
-                for(i=0;i<uReadThis;i++)
-                  pfile_in_zip_read_info->read_buffer[i] =
-                      zdecode(s->keys,s->pcrc_32_tab,
-                              pfile_in_zip_read_info->read_buffer[i]);
-            }
-#            endif
-
-
-            pfile_in_zip_read_info->pos_in_zipfile += uReadThis;
-
-            pfile_in_zip_read_info->rest_read_compressed-=uReadThis;
-
-            pfile_in_zip_read_info->stream.next_in =
-                (Bytef*)pfile_in_zip_read_info->read_buffer;
-            pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;
-        }
-
-        if ((pfile_in_zip_read_info->compression_method==0) || (pfile_in_zip_read_info->raw))
-        {
-            uInt uDoCopy,i ;
-
-            if ((pfile_in_zip_read_info->stream.avail_in == 0) &&
-                (pfile_in_zip_read_info->rest_read_compressed == 0))
-                return (iRead==0) ? UNZ_EOF : iRead;
-
-            if (pfile_in_zip_read_info->stream.avail_out <
-                            pfile_in_zip_read_info->stream.avail_in)
-                uDoCopy = pfile_in_zip_read_info->stream.avail_out ;
-            else
-                uDoCopy = pfile_in_zip_read_info->stream.avail_in ;
-
-            for (i=0;i<uDoCopy;i++)
-                *(pfile_in_zip_read_info->stream.next_out+i) =
-                        *(pfile_in_zip_read_info->stream.next_in+i);
-
-            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,
-                                pfile_in_zip_read_info->stream.next_out,
-                                uDoCopy);
-            pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;
-            pfile_in_zip_read_info->stream.avail_in -= uDoCopy;
-            pfile_in_zip_read_info->stream.avail_out -= uDoCopy;
-            pfile_in_zip_read_info->stream.next_out += uDoCopy;
-            pfile_in_zip_read_info->stream.next_in += uDoCopy;
-            pfile_in_zip_read_info->stream.total_out += uDoCopy;
-            iRead += uDoCopy;
-        }
-        else
-        {
-            uLong uTotalOutBefore,uTotalOutAfter;
-            const Bytef *bufBefore;
-            uLong uOutThis;
-            int flush=Z_SYNC_FLUSH;
-
-            uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;
-            bufBefore = pfile_in_zip_read_info->stream.next_out;
-
-            /*
-            if ((pfile_in_zip_read_info->rest_read_uncompressed ==
-                     pfile_in_zip_read_info->stream.avail_out) &&
-                (pfile_in_zip_read_info->rest_read_compressed == 0))
-                flush = Z_FINISH;
-            */
-            err=inflate(&pfile_in_zip_read_info->stream,flush);
-
-            if ((err>=0) && (pfile_in_zip_read_info->stream.msg!=NULL))
-              err = Z_DATA_ERROR;
-
-            uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;
-            uOutThis = uTotalOutAfter-uTotalOutBefore;
-
-            pfile_in_zip_read_info->crc32 =
-                crc32(pfile_in_zip_read_info->crc32,bufBefore,
-                        (uInt)(uOutThis));
-
-            pfile_in_zip_read_info->rest_read_uncompressed -=
-                uOutThis;
-
-            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);
-
-            if (err==Z_STREAM_END)
-                return (iRead==0) ? UNZ_EOF : iRead;
-            if (err!=Z_OK)
-                break;
-        }
-    }
-
-    if (err==Z_OK)
-        return iRead;
-    return err;
-}
-
-
-/*
-  Give the current position in uncompressed data
-*/
-extern z_off_t ZEXPORT unztell (file)
-    unzFile file;
-{
-    unz_s* s;
-    file_in_zip_read_info_s* pfile_in_zip_read_info;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-    return (z_off_t)pfile_in_zip_read_info->stream.total_out;
-}
-
-
-/*
-  return 1 if the end of file was reached, 0 elsewhere
-*/
-extern int ZEXPORT unzeof (file)
-    unzFile file;
-{
-    unz_s* s;
-    file_in_zip_read_info_s* pfile_in_zip_read_info;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-    if (pfile_in_zip_read_info->rest_read_uncompressed == 0)
-        return 1;
-    else
-        return 0;
-}
-
-
-
-/*
-  Read extra field from the current file (opened by unzOpenCurrentFile)
-  This is the local-header version of the extra field (sometimes, there is
-    more info in the local-header version than in the central-header)
-
-  if buf==NULL, it return the size of the local extra field that can be read
-
-  if buf!=NULL, len is the size of the buffer, the extra header is copied in
-    buf.
-  the return value is the number of bytes copied in buf, or (if <0)
-    the error code
-*/
-extern int ZEXPORT unzGetLocalExtrafield (file,buf,len)
-    unzFile file;
-    voidp buf;
-    unsigned len;
-{
-    unz_s* s;
-    file_in_zip_read_info_s* pfile_in_zip_read_info;
-    uInt read_now;
-    uLong size_to_read;
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-    size_to_read = (pfile_in_zip_read_info->size_local_extrafield -
-                pfile_in_zip_read_info->pos_local_extrafield);
-
-    if (buf==NULL)
-        return (int)size_to_read;
-
-    if (len>size_to_read)
-        read_now = (uInt)size_to_read;
-    else
-        read_now = (uInt)len ;
-
-    if (read_now==0)
-        return 0;
-
-    if (ZSEEK(pfile_in_zip_read_info->z_filefunc,
-              pfile_in_zip_read_info->filestream,
-              pfile_in_zip_read_info->offset_local_extrafield +
-              pfile_in_zip_read_info->pos_local_extrafield,
-              ZLIB_FILEFUNC_SEEK_SET)!=0)
-        return UNZ_ERRNO;
-
-    if (ZREAD(pfile_in_zip_read_info->z_filefunc,
-              pfile_in_zip_read_info->filestream,
-              buf,read_now)!=read_now)
-        return UNZ_ERRNO;
-
-    return (int)read_now;
-}
-
-/*
-  Close the file in zip opened with unzipOpenCurrentFile
-  Return UNZ_CRCERROR if all the file was read but the CRC is not good
-*/
-extern int ZEXPORT unzCloseCurrentFile (file)
-    unzFile file;
-{
-    int err=UNZ_OK;
-
-    unz_s* s;
-    file_in_zip_read_info_s* pfile_in_zip_read_info;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    pfile_in_zip_read_info=s->pfile_in_zip_read;
-
-    if (pfile_in_zip_read_info==NULL)
-        return UNZ_PARAMERROR;
-
-
-    if ((pfile_in_zip_read_info->rest_read_uncompressed == 0) &&
-        (!pfile_in_zip_read_info->raw))
-    {
-        if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)
-            err=UNZ_CRCERROR;
-    }
-
-
-    TRYFREE(pfile_in_zip_read_info->read_buffer);
-    pfile_in_zip_read_info->read_buffer = NULL;
-    if (pfile_in_zip_read_info->stream_initialised)
-        inflateEnd(&pfile_in_zip_read_info->stream);
-
-    pfile_in_zip_read_info->stream_initialised = 0;
-    TRYFREE(pfile_in_zip_read_info);
-
-    s->pfile_in_zip_read=NULL;
-
-    return err;
-}
-
-
-/*
-  Get the global comment string of the ZipFile, in the szComment buffer.
-  uSizeBuf is the size of the szComment buffer.
-  return the number of byte copied or an error code <0
-*/
-extern int ZEXPORT unzGetGlobalComment (file, szComment, uSizeBuf)
-    unzFile file;
-    char *szComment;
-    uLong uSizeBuf;
-{
-    int err=UNZ_OK;
-    unz_s* s;
-    uLong uReadThis ;
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-
-    uReadThis = uSizeBuf;
-    if (uReadThis>s->gi.size_comment)
-        uReadThis = s->gi.size_comment;
-
-    if (ZSEEK(s->z_filefunc,s->filestream,s->central_pos+22,ZLIB_FILEFUNC_SEEK_SET)!=0)
-        return UNZ_ERRNO;
-
-    if (uReadThis>0)
-    {
-      *szComment='\0';
-      if (ZREAD(s->z_filefunc,s->filestream,szComment,uReadThis)!=uReadThis)
-        return UNZ_ERRNO;
-    }
-
-    if ((szComment != NULL) && (uSizeBuf > s->gi.size_comment))
-        *(szComment+s->gi.size_comment)='\0';
-    return (int)uReadThis;
-}
-
-/* Additions by RX '2004 */
-extern uLong ZEXPORT unzGetOffset (file)
-    unzFile file;
-{
-    unz_s* s;
-
-    if (file==NULL)
-          return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-    if (!s->current_file_ok)
-      return 0;
-    if (s->gi.number_entry != 0 && s->gi.number_entry != 0xffff)
-      if (s->num_file==s->gi.number_entry)
-         return 0;
-    return s->pos_in_central_dir;
-}
-
-extern int ZEXPORT unzSetOffset (file, pos)
-        unzFile file;
-        uLong pos;
-{
-    unz_s* s;
-    int err;
-
-    if (file==NULL)
-        return UNZ_PARAMERROR;
-    s=(unz_s*)file;
-
-    s->pos_in_central_dir = pos;
-    s->num_file = s->gi.number_entry;      /* hack */
-    err = unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,
-                                              &s->cur_file_info_internal,
-                                              NULL,0,NULL,0,NULL,0);
-    s->current_file_ok = (err == UNZ_OK);
-    return err;
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/minizip/unzip.h gcc-4.6.3-psp/zlib/contrib/minizip/unzip.h
--- gcc-4.6.3/zlib/contrib/minizip/unzip.h	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/minizip/unzip.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,354 +0,0 @@
-/* unzip.h -- IO for uncompress .zip files using zlib
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-
-   This unzip package allow extract file from .ZIP file, compatible with PKZip 2.04g
-     WinZip, InfoZip tools and compatible.
-
-   Multi volume ZipFile (span) are not supported.
-   Encryption compatible with pkzip 2.04g only supported
-   Old compressions used by old PKZip 1.x are not supported
-
-
-   I WAIT FEEDBACK at mail info@winimage.com
-   Visit also http://www.winimage.com/zLibDll/unzip.htm for evolution
-
-   Condition of use and distribution are the same than zlib :
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-
-*/
-
-/* for more info about .ZIP format, see
-      http://www.info-zip.org/pub/infozip/doc/appnote-981119-iz.zip
-      http://www.info-zip.org/pub/infozip/doc/
-   PkWare has also a specification at :
-      ftp://ftp.pkware.com/probdesc.zip
-*/
-
-#ifndef _unz_H
-#define _unz_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef _ZLIB_H
-#include "zlib.h"
-#endif
-
-#ifndef _ZLIBIOAPI_H
-#include "ioapi.h"
-#endif
-
-#if defined(STRICTUNZIP) || defined(STRICTZIPUNZIP)
-/* like the STRICT of WIN32, we define a pointer that cannot be converted
-    from (void*) without cast */
-typedef struct TagunzFile__ { int unused; } unzFile__;
-typedef unzFile__ *unzFile;
-#else
-typedef voidp unzFile;
-#endif
-
-
-#define UNZ_OK                          (0)
-#define UNZ_END_OF_LIST_OF_FILE         (-100)
-#define UNZ_ERRNO                       (Z_ERRNO)
-#define UNZ_EOF                         (0)
-#define UNZ_PARAMERROR                  (-102)
-#define UNZ_BADZIPFILE                  (-103)
-#define UNZ_INTERNALERROR               (-104)
-#define UNZ_CRCERROR                    (-105)
-
-/* tm_unz contain date/time info */
-typedef struct tm_unz_s
-{
-    uInt tm_sec;            /* seconds after the minute - [0,59] */
-    uInt tm_min;            /* minutes after the hour - [0,59] */
-    uInt tm_hour;           /* hours since midnight - [0,23] */
-    uInt tm_mday;           /* day of the month - [1,31] */
-    uInt tm_mon;            /* months since January - [0,11] */
-    uInt tm_year;           /* years - [1980..2044] */
-} tm_unz;
-
-/* unz_global_info structure contain global data about the ZIPfile
-   These data comes from the end of central dir */
-typedef struct unz_global_info_s
-{
-    uLong number_entry;         /* total number of entries in
-                       the central dir on this disk */
-    uLong size_comment;         /* size of the global comment of the zipfile */
-} unz_global_info;
-
-
-/* unz_file_info contain information about a file in the zipfile */
-typedef struct unz_file_info_s
-{
-    uLong version;              /* version made by                 2 bytes */
-    uLong version_needed;       /* version needed to extract       2 bytes */
-    uLong flag;                 /* general purpose bit flag        2 bytes */
-    uLong compression_method;   /* compression method              2 bytes */
-    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */
-    uLong crc;                  /* crc-32                          4 bytes */
-    uLong compressed_size;      /* compressed size                 4 bytes */
-    uLong uncompressed_size;    /* uncompressed size               4 bytes */
-    uLong size_filename;        /* filename length                 2 bytes */
-    uLong size_file_extra;      /* extra field length              2 bytes */
-    uLong size_file_comment;    /* file comment length             2 bytes */
-
-    uLong disk_num_start;       /* disk number start               2 bytes */
-    uLong internal_fa;          /* internal file attributes        2 bytes */
-    uLong external_fa;          /* external file attributes        4 bytes */
-
-    tm_unz tmu_date;
-} unz_file_info;
-
-extern int ZEXPORT unzStringFileNameCompare OF ((const char* fileName1,
-                                                 const char* fileName2,
-                                                 int iCaseSensitivity));
-/*
-   Compare two filename (fileName1,fileName2).
-   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
-   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
-                                or strcasecmp)
-   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
-    (like 1 on Unix, 2 on Windows)
-*/
-
-
-extern unzFile ZEXPORT unzOpen OF((const char *path));
-/*
-  Open a Zip file. path contain the full pathname (by example,
-     on a Windows XP computer "c:\\zlib\\zlib113.zip" or on an Unix computer
-     "zlib/zlib113.zip".
-     If the zipfile cannot be opened (file don't exist or in not valid), the
-       return value is NULL.
-     Else, the return value is a unzFile Handle, usable with other function
-       of this unzip package.
-*/
-
-extern unzFile ZEXPORT unzOpen2 OF((const char *path,
-                                    zlib_filefunc_def* pzlib_filefunc_def));
-/*
-   Open a Zip file, like unzOpen, but provide a set of file low level API
-      for read/write the zip file (see ioapi.h)
-*/
-
-extern int ZEXPORT unzClose OF((unzFile file));
-/*
-  Close a ZipFile opened with unzipOpen.
-  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),
-    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.
-  return UNZ_OK if there is no problem. */
-
-extern int ZEXPORT unzGetGlobalInfo OF((unzFile file,
-                                        unz_global_info *pglobal_info));
-/*
-  Write info about the ZipFile in the *pglobal_info structure.
-  No preparation of the structure is needed
-  return UNZ_OK if there is no problem. */
-
-
-extern int ZEXPORT unzGetGlobalComment OF((unzFile file,
-                                           char *szComment,
-                                           uLong uSizeBuf));
-/*
-  Get the global comment string of the ZipFile, in the szComment buffer.
-  uSizeBuf is the size of the szComment buffer.
-  return the number of byte copied or an error code <0
-*/
-
-
-/***************************************************************************/
-/* Unzip package allow you browse the directory of the zipfile */
-
-extern int ZEXPORT unzGoToFirstFile OF((unzFile file));
-/*
-  Set the current file of the zipfile to the first file.
-  return UNZ_OK if there is no problem
-*/
-
-extern int ZEXPORT unzGoToNextFile OF((unzFile file));
-/*
-  Set the current file of the zipfile to the next file.
-  return UNZ_OK if there is no problem
-  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
-*/
-
-extern int ZEXPORT unzLocateFile OF((unzFile file,
-                     const char *szFileName,
-                     int iCaseSensitivity));
-/*
-  Try locate the file szFileName in the zipfile.
-  For the iCaseSensitivity signification, see unzStringFileNameCompare
-
-  return value :
-  UNZ_OK if the file is found. It becomes the current file.
-  UNZ_END_OF_LIST_OF_FILE if the file is not found
-*/
-
-
-/* ****************************************** */
-/* Ryan supplied functions */
-/* unz_file_info contain information about a file in the zipfile */
-typedef struct unz_file_pos_s
-{
-    uLong pos_in_zip_directory;   /* offset in zip file directory */
-    uLong num_of_file;            /* # of file */
-} unz_file_pos;
-
-extern int ZEXPORT unzGetFilePos(
-    unzFile file,
-    unz_file_pos* file_pos);
-
-extern int ZEXPORT unzGoToFilePos(
-    unzFile file,
-    unz_file_pos* file_pos);
-
-/* ****************************************** */
-
-extern int ZEXPORT unzGetCurrentFileInfo OF((unzFile file,
-                         unz_file_info *pfile_info,
-                         char *szFileName,
-                         uLong fileNameBufferSize,
-                         void *extraField,
-                         uLong extraFieldBufferSize,
-                         char *szComment,
-                         uLong commentBufferSize));
-/*
-  Get Info about the current file
-  if pfile_info!=NULL, the *pfile_info structure will contain somes info about
-        the current file
-  if szFileName!=NULL, the filemane string will be copied in szFileName
-            (fileNameBufferSize is the size of the buffer)
-  if extraField!=NULL, the extra field information will be copied in extraField
-            (extraFieldBufferSize is the size of the buffer).
-            This is the Central-header version of the extra field
-  if szComment!=NULL, the comment string of the file will be copied in szComment
-            (commentBufferSize is the size of the buffer)
-*/
-
-/***************************************************************************/
-/* for reading the content of the current zipfile, you can open it, read data
-   from it, and close it (you can close it before reading all the file)
-   */
-
-extern int ZEXPORT unzOpenCurrentFile OF((unzFile file));
-/*
-  Open for reading data the current file in the zipfile.
-  If there is no error, the return value is UNZ_OK.
-*/
-
-extern int ZEXPORT unzOpenCurrentFilePassword OF((unzFile file,
-                                                  const char* password));
-/*
-  Open for reading data the current file in the zipfile.
-  password is a crypting password
-  If there is no error, the return value is UNZ_OK.
-*/
-
-extern int ZEXPORT unzOpenCurrentFile2 OF((unzFile file,
-                                           int* method,
-                                           int* level,
-                                           int raw));
-/*
-  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)
-    if raw==1
-  *method will receive method of compression, *level will receive level of
-     compression
-  note : you can set level parameter as NULL (if you did not want known level,
-         but you CANNOT set method parameter as NULL
-*/
-
-extern int ZEXPORT unzOpenCurrentFile3 OF((unzFile file,
-                                           int* method,
-                                           int* level,
-                                           int raw,
-                                           const char* password));
-/*
-  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)
-    if raw==1
-  *method will receive method of compression, *level will receive level of
-     compression
-  note : you can set level parameter as NULL (if you did not want known level,
-         but you CANNOT set method parameter as NULL
-*/
-
-
-extern int ZEXPORT unzCloseCurrentFile OF((unzFile file));
-/*
-  Close the file in zip opened with unzOpenCurrentFile
-  Return UNZ_CRCERROR if all the file was read but the CRC is not good
-*/
-
-extern int ZEXPORT unzReadCurrentFile OF((unzFile file,
-                      voidp buf,
-                      unsigned len));
-/*
-  Read bytes from the current file (opened by unzOpenCurrentFile)
-  buf contain buffer where data must be copied
-  len the size of buf.
-
-  return the number of byte copied if somes bytes are copied
-  return 0 if the end of file was reached
-  return <0 with error code if there is an error
-    (UNZ_ERRNO for IO error, or zLib error for uncompress error)
-*/
-
-extern z_off_t ZEXPORT unztell OF((unzFile file));
-/*
-  Give the current position in uncompressed data
-*/
-
-extern int ZEXPORT unzeof OF((unzFile file));
-/*
-  return 1 if the end of file was reached, 0 elsewhere
-*/
-
-extern int ZEXPORT unzGetLocalExtrafield OF((unzFile file,
-                                             voidp buf,
-                                             unsigned len));
-/*
-  Read extra field from the current file (opened by unzOpenCurrentFile)
-  This is the local-header version of the extra field (sometimes, there is
-    more info in the local-header version than in the central-header)
-
-  if buf==NULL, it return the size of the local extra field
-
-  if buf!=NULL, len is the size of the buffer, the extra header is copied in
-    buf.
-  the return value is the number of bytes copied in buf, or (if <0)
-    the error code
-*/
-
-/***************************************************************************/
-
-/* Get the current file offset */
-extern uLong ZEXPORT unzGetOffset (unzFile file);
-
-/* Set the current file offset */
-extern int ZEXPORT unzSetOffset (unzFile file, uLong pos);
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _unz_H */
diff -Nbaur gcc-4.6.3/zlib/contrib/minizip/zip.c gcc-4.6.3-psp/zlib/contrib/minizip/zip.c
--- gcc-4.6.3/zlib/contrib/minizip/zip.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/minizip/zip.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1219 +0,0 @@
-/* zip.c -- IO on .zip files using zlib
-   Version 1.01e, February 12th, 2005
-
-   27 Dec 2004 Rolf Kalbermatter
-   Modification to zipOpen2 to support globalComment retrieval.
-
-   Copyright (C) 1998-2005 Gilles Vollant
-
-   Read zip.h for more info
-*/
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include "zlib.h"
-#include "zip.h"
-
-#ifdef STDC
-#  include <stddef.h>
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-#ifdef NO_ERRNO_H
-    extern int errno;
-#else
-#   include <errno.h>
-#endif
-
-
-#ifndef local
-#  define local static
-#endif
-/* compile with -Dlocal if your debugger can't find static symbols */
-
-#ifndef VERSIONMADEBY
-# define VERSIONMADEBY   (0x0) /* platform depedent */
-#endif
-
-#ifndef Z_BUFSIZE
-#define Z_BUFSIZE (16384)
-#endif
-
-#ifndef Z_MAXFILENAMEINZIP
-#define Z_MAXFILENAMEINZIP (256)
-#endif
-
-#ifndef ALLOC
-# define ALLOC(size) (malloc(size))
-#endif
-#ifndef TRYFREE
-# define TRYFREE(p) {if (p) free(p);}
-#endif
-
-/*
-#define SIZECENTRALDIRITEM (0x2e)
-#define SIZEZIPLOCALHEADER (0x1e)
-*/
-
-/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */
-
-#ifndef SEEK_CUR
-#define SEEK_CUR    1
-#endif
-
-#ifndef SEEK_END
-#define SEEK_END    2
-#endif
-
-#ifndef SEEK_SET
-#define SEEK_SET    0
-#endif
-
-#ifndef DEF_MEM_LEVEL
-#if MAX_MEM_LEVEL >= 8
-#  define DEF_MEM_LEVEL 8
-#else
-#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#endif
-#endif
-const char zip_copyright[] =
-   " zip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll";
-
-
-#define SIZEDATA_INDATABLOCK (4096-(4*4))
-
-#define LOCALHEADERMAGIC    (0x04034b50)
-#define CENTRALHEADERMAGIC  (0x02014b50)
-#define ENDHEADERMAGIC      (0x06054b50)
-
-#define FLAG_LOCALHEADER_OFFSET (0x06)
-#define CRC_LOCALHEADER_OFFSET  (0x0e)
-
-#define SIZECENTRALHEADER (0x2e) /* 46 */
-
-typedef struct linkedlist_datablock_internal_s
-{
-  struct linkedlist_datablock_internal_s* next_datablock;
-  uLong  avail_in_this_block;
-  uLong  filled_in_this_block;
-  uLong  unused; /* for future use and alignement */
-  unsigned char data[SIZEDATA_INDATABLOCK];
-} linkedlist_datablock_internal;
-
-typedef struct linkedlist_data_s
-{
-    linkedlist_datablock_internal* first_block;
-    linkedlist_datablock_internal* last_block;
-} linkedlist_data;
-
-
-typedef struct
-{
-    z_stream stream;            /* zLib stream structure for inflate */
-    int  stream_initialised;    /* 1 is stream is initialised */
-    uInt pos_in_buffered_data;  /* last written byte in buffered_data */
-
-    uLong pos_local_header;     /* offset of the local header of the file
-                                     currenty writing */
-    char* central_header;       /* central header data for the current file */
-    uLong size_centralheader;   /* size of the central header for cur file */
-    uLong flag;                 /* flag of the file currently writing */
-
-    int  method;                /* compression method of file currenty wr.*/
-    int  raw;                   /* 1 for directly writing raw data */
-    Byte buffered_data[Z_BUFSIZE];/* buffer contain compressed data to be writ*/
-    uLong dosDate;
-    uLong crc32;
-    int  encrypt;
-#ifndef NOCRYPT
-    unsigned long keys[3];     /* keys defining the pseudo-random sequence */
-    const unsigned long* pcrc_32_tab;
-    int crypt_header_size;
-#endif
-} curfile_info;
-
-typedef struct
-{
-    zlib_filefunc_def z_filefunc;
-    voidpf filestream;        /* io structore of the zipfile */
-    linkedlist_data central_dir;/* datablock with central dir in construction*/
-    int  in_opened_file_inzip;  /* 1 if a file in the zip is currently writ.*/
-    curfile_info ci;            /* info on the file curretly writing */
-
-    uLong begin_pos;            /* position of the beginning of the zipfile */
-    uLong add_position_when_writting_offset;
-    uLong number_entry;
-#ifndef NO_ADDFILEINEXISTINGZIP
-    char *globalcomment;
-#endif
-} zip_internal;
-
-
-
-#ifndef NOCRYPT
-#define INCLUDECRYPTINGCODE_IFCRYPTALLOWED
-#include "crypt.h"
-#endif
-
-local linkedlist_datablock_internal* allocate_new_datablock()
-{
-    linkedlist_datablock_internal* ldi;
-    ldi = (linkedlist_datablock_internal*)
-                 ALLOC(sizeof(linkedlist_datablock_internal));
-    if (ldi!=NULL)
-    {
-        ldi->next_datablock = NULL ;
-        ldi->filled_in_this_block = 0 ;
-        ldi->avail_in_this_block = SIZEDATA_INDATABLOCK ;
-    }
-    return ldi;
-}
-
-local void free_datablock(ldi)
-    linkedlist_datablock_internal* ldi;
-{
-    while (ldi!=NULL)
-    {
-        linkedlist_datablock_internal* ldinext = ldi->next_datablock;
-        TRYFREE(ldi);
-        ldi = ldinext;
-    }
-}
-
-local void init_linkedlist(ll)
-    linkedlist_data* ll;
-{
-    ll->first_block = ll->last_block = NULL;
-}
-
-local void free_linkedlist(ll)
-    linkedlist_data* ll;
-{
-    free_datablock(ll->first_block);
-    ll->first_block = ll->last_block = NULL;
-}
-
-
-local int add_data_in_datablock(ll,buf,len)
-    linkedlist_data* ll;
-    const void* buf;
-    uLong len;
-{
-    linkedlist_datablock_internal* ldi;
-    const unsigned char* from_copy;
-
-    if (ll==NULL)
-        return ZIP_INTERNALERROR;
-
-    if (ll->last_block == NULL)
-    {
-        ll->first_block = ll->last_block = allocate_new_datablock();
-        if (ll->first_block == NULL)
-            return ZIP_INTERNALERROR;
-    }
-
-    ldi = ll->last_block;
-    from_copy = (unsigned char*)buf;
-
-    while (len>0)
-    {
-        uInt copy_this;
-        uInt i;
-        unsigned char* to_copy;
-
-        if (ldi->avail_in_this_block==0)
-        {
-            ldi->next_datablock = allocate_new_datablock();
-            if (ldi->next_datablock == NULL)
-                return ZIP_INTERNALERROR;
-            ldi = ldi->next_datablock ;
-            ll->last_block = ldi;
-        }
-
-        if (ldi->avail_in_this_block < len)
-            copy_this = (uInt)ldi->avail_in_this_block;
-        else
-            copy_this = (uInt)len;
-
-        to_copy = &(ldi->data[ldi->filled_in_this_block]);
-
-        for (i=0;i<copy_this;i++)
-            *(to_copy+i)=*(from_copy+i);
-
-        ldi->filled_in_this_block += copy_this;
-        ldi->avail_in_this_block -= copy_this;
-        from_copy += copy_this ;
-        len -= copy_this;
-    }
-    return ZIP_OK;
-}
-
-
-
-/****************************************************************************/
-
-#ifndef NO_ADDFILEINEXISTINGZIP
-/* ===========================================================================
-   Inputs a long in LSB order to the given file
-   nbByte == 1, 2 or 4 (byte, short or long)
-*/
-
-local int ziplocal_putValue OF((const zlib_filefunc_def* pzlib_filefunc_def,
-                                voidpf filestream, uLong x, int nbByte));
-local int ziplocal_putValue (pzlib_filefunc_def, filestream, x, nbByte)
-    const zlib_filefunc_def* pzlib_filefunc_def;
-    voidpf filestream;
-    uLong x;
-    int nbByte;
-{
-    unsigned char buf[4];
-    int n;
-    for (n = 0; n < nbByte; n++)
-    {
-        buf[n] = (unsigned char)(x & 0xff);
-        x >>= 8;
-    }
-    if (x != 0)
-      {     /* data overflow - hack for ZIP64 (X Roche) */
-      for (n = 0; n < nbByte; n++)
-        {
-          buf[n] = 0xff;
-        }
-      }
-
-    if (ZWRITE(*pzlib_filefunc_def,filestream,buf,nbByte)!=(uLong)nbByte)
-        return ZIP_ERRNO;
-    else
-        return ZIP_OK;
-}
-
-local void ziplocal_putValue_inmemory OF((void* dest, uLong x, int nbByte));
-local void ziplocal_putValue_inmemory (dest, x, nbByte)
-    void* dest;
-    uLong x;
-    int nbByte;
-{
-    unsigned char* buf=(unsigned char*)dest;
-    int n;
-    for (n = 0; n < nbByte; n++) {
-        buf[n] = (unsigned char)(x & 0xff);
-        x >>= 8;
-    }
-
-    if (x != 0)
-    {     /* data overflow - hack for ZIP64 */
-       for (n = 0; n < nbByte; n++)
-       {
-          buf[n] = 0xff;
-       }
-    }
-}
-
-/****************************************************************************/
-
-
-local uLong ziplocal_TmzDateToDosDate(ptm,dosDate)
-    const tm_zip* ptm;
-    uLong dosDate;
-{
-    uLong year = (uLong)ptm->tm_year;
-    if (year>1980)
-        year-=1980;
-    else if (year>80)
-        year-=80;
-    return
-      (uLong) (((ptm->tm_mday) + (32 * (ptm->tm_mon+1)) + (512 * year)) << 16) |
-        ((ptm->tm_sec/2) + (32* ptm->tm_min) + (2048 * (uLong)ptm->tm_hour));
-}
-
-
-/****************************************************************************/
-
-local int ziplocal_getByte OF((
-    const zlib_filefunc_def* pzlib_filefunc_def,
-    voidpf filestream,
-    int *pi));
-
-local int ziplocal_getByte(pzlib_filefunc_def,filestream,pi)
-    const zlib_filefunc_def* pzlib_filefunc_def;
-    voidpf filestream;
-    int *pi;
-{
-    unsigned char c;
-    int err = (int)ZREAD(*pzlib_filefunc_def,filestream,&c,1);
-    if (err==1)
-    {
-        *pi = (int)c;
-        return ZIP_OK;
-    }
-    else
-    {
-        if (ZERROR(*pzlib_filefunc_def,filestream))
-            return ZIP_ERRNO;
-        else
-            return ZIP_EOF;
-    }
-}
-
-
-/* ===========================================================================
-   Reads a long in LSB order from the given gz_stream. Sets
-*/
-local int ziplocal_getShort OF((
-    const zlib_filefunc_def* pzlib_filefunc_def,
-    voidpf filestream,
-    uLong *pX));
-
-local int ziplocal_getShort (pzlib_filefunc_def,filestream,pX)
-    const zlib_filefunc_def* pzlib_filefunc_def;
-    voidpf filestream;
-    uLong *pX;
-{
-    uLong x ;
-    int i;
-    int err;
-
-    err = ziplocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x = (uLong)i;
-
-    if (err==ZIP_OK)
-        err = ziplocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<8;
-
-    if (err==ZIP_OK)
-        *pX = x;
-    else
-        *pX = 0;
-    return err;
-}
-
-local int ziplocal_getLong OF((
-    const zlib_filefunc_def* pzlib_filefunc_def,
-    voidpf filestream,
-    uLong *pX));
-
-local int ziplocal_getLong (pzlib_filefunc_def,filestream,pX)
-    const zlib_filefunc_def* pzlib_filefunc_def;
-    voidpf filestream;
-    uLong *pX;
-{
-    uLong x ;
-    int i;
-    int err;
-
-    err = ziplocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x = (uLong)i;
-
-    if (err==ZIP_OK)
-        err = ziplocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<8;
-
-    if (err==ZIP_OK)
-        err = ziplocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<16;
-
-    if (err==ZIP_OK)
-        err = ziplocal_getByte(pzlib_filefunc_def,filestream,&i);
-    x += ((uLong)i)<<24;
-
-    if (err==ZIP_OK)
-        *pX = x;
-    else
-        *pX = 0;
-    return err;
-}
-
-#ifndef BUFREADCOMMENT
-#define BUFREADCOMMENT (0x400)
-#endif
-/*
-  Locate the Central directory of a zipfile (at the end, just before
-    the global comment)
-*/
-local uLong ziplocal_SearchCentralDir OF((
-    const zlib_filefunc_def* pzlib_filefunc_def,
-    voidpf filestream));
-
-local uLong ziplocal_SearchCentralDir(pzlib_filefunc_def,filestream)
-    const zlib_filefunc_def* pzlib_filefunc_def;
-    voidpf filestream;
-{
-    unsigned char* buf;
-    uLong uSizeFile;
-    uLong uBackRead;
-    uLong uMaxBack=0xffff; /* maximum size of global comment */
-    uLong uPosFound=0;
-
-    if (ZSEEK(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
-        return 0;
-
-
-    uSizeFile = ZTELL(*pzlib_filefunc_def,filestream);
-
-    if (uMaxBack>uSizeFile)
-        uMaxBack = uSizeFile;
-
-    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
-    if (buf==NULL)
-        return 0;
-
-    uBackRead = 4;
-    while (uBackRead<uMaxBack)
-    {
-        uLong uReadSize,uReadPos ;
-        int i;
-        if (uBackRead+BUFREADCOMMENT>uMaxBack)
-            uBackRead = uMaxBack;
-        else
-            uBackRead+=BUFREADCOMMENT;
-        uReadPos = uSizeFile-uBackRead ;
-
-        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
-                     (BUFREADCOMMENT+4) : (uSizeFile-uReadPos);
-        if (ZSEEK(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            break;
-
-        if (ZREAD(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
-            break;
-
-        for (i=(int)uReadSize-3; (i--)>0;)
-            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&
-                ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))
-            {
-                uPosFound = uReadPos+i;
-                break;
-            }
-
-        if (uPosFound!=0)
-            break;
-    }
-    TRYFREE(buf);
-    return uPosFound;
-}
-#endif /* !NO_ADDFILEINEXISTINGZIP*/
-
-/************************************************************/
-extern zipFile ZEXPORT zipOpen2 (pathname, append, globalcomment, pzlib_filefunc_def)
-    const char *pathname;
-    int append;
-    zipcharpc* globalcomment;
-    zlib_filefunc_def* pzlib_filefunc_def;
-{
-    zip_internal ziinit;
-    zip_internal* zi;
-    int err=ZIP_OK;
-
-
-    if (pzlib_filefunc_def==NULL)
-        fill_fopen_filefunc(&ziinit.z_filefunc);
-    else
-        ziinit.z_filefunc = *pzlib_filefunc_def;
-
-    ziinit.filestream = (*(ziinit.z_filefunc.zopen_file))
-                 (ziinit.z_filefunc.opaque,
-                  pathname,
-                  (append == APPEND_STATUS_CREATE) ?
-                  (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_CREATE) :
-                    (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_EXISTING));
-
-    if (ziinit.filestream == NULL)
-        return NULL;
-    ziinit.begin_pos = ZTELL(ziinit.z_filefunc,ziinit.filestream);
-    ziinit.in_opened_file_inzip = 0;
-    ziinit.ci.stream_initialised = 0;
-    ziinit.number_entry = 0;
-    ziinit.add_position_when_writting_offset = 0;
-    init_linkedlist(&(ziinit.central_dir));
-
-
-    zi = (zip_internal*)ALLOC(sizeof(zip_internal));
-    if (zi==NULL)
-    {
-        ZCLOSE(ziinit.z_filefunc,ziinit.filestream);
-        return NULL;
-    }
-
-    /* now we add file in a zipfile */
-#    ifndef NO_ADDFILEINEXISTINGZIP
-    ziinit.globalcomment = NULL;
-    if (append == APPEND_STATUS_ADDINZIP)
-    {
-        uLong byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
-
-        uLong size_central_dir;     /* size of the central directory  */
-        uLong offset_central_dir;   /* offset of start of central directory */
-        uLong central_pos,uL;
-
-        uLong number_disk;          /* number of the current dist, used for
-                                    spaning ZIP, unsupported, always 0*/
-        uLong number_disk_with_CD;  /* number the the disk with central dir, used
-                                    for spaning ZIP, unsupported, always 0*/
-        uLong number_entry;
-        uLong number_entry_CD;      /* total number of entries in
-                                    the central dir
-                                    (same than number_entry on nospan) */
-        uLong size_comment;
-
-        central_pos = ziplocal_SearchCentralDir(&ziinit.z_filefunc,ziinit.filestream);
-        if (central_pos==0)
-            err=ZIP_ERRNO;
-
-        if (ZSEEK(ziinit.z_filefunc, ziinit.filestream,
-                                        central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            err=ZIP_ERRNO;
-
-        /* the signature, already checked */
-        if (ziplocal_getLong(&ziinit.z_filefunc, ziinit.filestream,&uL)!=ZIP_OK)
-            err=ZIP_ERRNO;
-
-        /* number of this disk */
-        if (ziplocal_getShort(&ziinit.z_filefunc, ziinit.filestream,&number_disk)!=ZIP_OK)
-            err=ZIP_ERRNO;
-
-        /* number of the disk with the start of the central directory */
-        if (ziplocal_getShort(&ziinit.z_filefunc, ziinit.filestream,&number_disk_with_CD)!=ZIP_OK)
-            err=ZIP_ERRNO;
-
-        /* total number of entries in the central dir on this disk */
-        if (ziplocal_getShort(&ziinit.z_filefunc, ziinit.filestream,&number_entry)!=ZIP_OK)
-            err=ZIP_ERRNO;
-
-        /* total number of entries in the central dir */
-        if (ziplocal_getShort(&ziinit.z_filefunc, ziinit.filestream,&number_entry_CD)!=ZIP_OK)
-            err=ZIP_ERRNO;
-
-        if ((number_entry_CD!=number_entry) ||
-            (number_disk_with_CD!=0) ||
-            (number_disk!=0))
-            err=ZIP_BADZIPFILE;
-
-        /* size of the central directory */
-        if (ziplocal_getLong(&ziinit.z_filefunc, ziinit.filestream,&size_central_dir)!=ZIP_OK)
-            err=ZIP_ERRNO;
-
-        /* offset of start of central directory with respect to the
-            starting disk number */
-        if (ziplocal_getLong(&ziinit.z_filefunc, ziinit.filestream,&offset_central_dir)!=ZIP_OK)
-            err=ZIP_ERRNO;
-
-        /* zipfile global comment length */
-        if (ziplocal_getShort(&ziinit.z_filefunc, ziinit.filestream,&size_comment)!=ZIP_OK)
-            err=ZIP_ERRNO;
-
-        if ((central_pos<offset_central_dir+size_central_dir) &&
-            (err==ZIP_OK))
-            err=ZIP_BADZIPFILE;
-
-        if (err!=ZIP_OK)
-        {
-            ZCLOSE(ziinit.z_filefunc, ziinit.filestream);
-            return NULL;
-        }
-
-        if (size_comment>0)
-        {
-            ziinit.globalcomment = ALLOC(size_comment+1);
-            if (ziinit.globalcomment)
-            {
-               size_comment = ZREAD(ziinit.z_filefunc, ziinit.filestream,ziinit.globalcomment,size_comment);
-               ziinit.globalcomment[size_comment]=0;
-            }
-        }
-
-        byte_before_the_zipfile = central_pos -
-                                (offset_central_dir+size_central_dir);
-        ziinit.add_position_when_writting_offset = byte_before_the_zipfile;
-
-        {
-            uLong size_central_dir_to_read = size_central_dir;
-            size_t buf_size = SIZEDATA_INDATABLOCK;
-            void* buf_read = (void*)ALLOC(buf_size);
-            if (ZSEEK(ziinit.z_filefunc, ziinit.filestream,
-                  offset_central_dir + byte_before_the_zipfile,
-                  ZLIB_FILEFUNC_SEEK_SET) != 0)
-                  err=ZIP_ERRNO;
-
-            while ((size_central_dir_to_read>0) && (err==ZIP_OK))
-            {
-                uLong read_this = SIZEDATA_INDATABLOCK;
-                if (read_this > size_central_dir_to_read)
-                    read_this = size_central_dir_to_read;
-                if (ZREAD(ziinit.z_filefunc, ziinit.filestream,buf_read,read_this) != read_this)
-                    err=ZIP_ERRNO;
-
-                if (err==ZIP_OK)
-                    err = add_data_in_datablock(&ziinit.central_dir,buf_read,
-                                                (uLong)read_this);
-                size_central_dir_to_read-=read_this;
-            }
-            TRYFREE(buf_read);
-        }
-        ziinit.begin_pos = byte_before_the_zipfile;
-        ziinit.number_entry = number_entry_CD;
-
-        if (ZSEEK(ziinit.z_filefunc, ziinit.filestream,
-                  offset_central_dir+byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            err=ZIP_ERRNO;
-    }
-
-    if (globalcomment)
-    {
-      *globalcomment = ziinit.globalcomment;
-    }
-#    endif /* !NO_ADDFILEINEXISTINGZIP*/
-
-    if (err != ZIP_OK)
-    {
-#    ifndef NO_ADDFILEINEXISTINGZIP
-        TRYFREE(ziinit.globalcomment);
-#    endif /* !NO_ADDFILEINEXISTINGZIP*/
-        TRYFREE(zi);
-        return NULL;
-    }
-    else
-    {
-        *zi = ziinit;
-        return (zipFile)zi;
-    }
-}
-
-extern zipFile ZEXPORT zipOpen (pathname, append)
-    const char *pathname;
-    int append;
-{
-    return zipOpen2(pathname,append,NULL,NULL);
-}
-
-extern int ZEXPORT zipOpenNewFileInZip3 (file, filename, zipfi,
-                                         extrafield_local, size_extrafield_local,
-                                         extrafield_global, size_extrafield_global,
-                                         comment, method, level, raw,
-                                         windowBits, memLevel, strategy,
-                                         password, crcForCrypting)
-    zipFile file;
-    const char* filename;
-    const zip_fileinfo* zipfi;
-    const void* extrafield_local;
-    uInt size_extrafield_local;
-    const void* extrafield_global;
-    uInt size_extrafield_global;
-    const char* comment;
-    int method;
-    int level;
-    int raw;
-    int windowBits;
-    int memLevel;
-    int strategy;
-    const char* password;
-    uLong crcForCrypting;
-{
-    zip_internal* zi;
-    uInt size_filename;
-    uInt size_comment;
-    uInt i;
-    int err = ZIP_OK;
-
-#    ifdef NOCRYPT
-    if (password != NULL)
-        return ZIP_PARAMERROR;
-#    endif
-
-    if (file == NULL)
-        return ZIP_PARAMERROR;
-    if ((method!=0) && (method!=Z_DEFLATED))
-        return ZIP_PARAMERROR;
-
-    zi = (zip_internal*)file;
-
-    if (zi->in_opened_file_inzip == 1)
-    {
-        err = zipCloseFileInZip (file);
-        if (err != ZIP_OK)
-            return err;
-    }
-
-
-    if (filename==NULL)
-        filename="-";
-
-    if (comment==NULL)
-        size_comment = 0;
-    else
-        size_comment = (uInt)strlen(comment);
-
-    size_filename = (uInt)strlen(filename);
-
-    if (zipfi == NULL)
-        zi->ci.dosDate = 0;
-    else
-    {
-        if (zipfi->dosDate != 0)
-            zi->ci.dosDate = zipfi->dosDate;
-        else zi->ci.dosDate = ziplocal_TmzDateToDosDate(&zipfi->tmz_date,zipfi->dosDate);
-    }
-
-    zi->ci.flag = 0;
-    if ((level==8) || (level==9))
-      zi->ci.flag |= 2;
-    if ((level==2))
-      zi->ci.flag |= 4;
-    if ((level==1))
-      zi->ci.flag |= 6;
-    if (password != NULL)
-      zi->ci.flag |= 1;
-
-    zi->ci.crc32 = 0;
-    zi->ci.method = method;
-    zi->ci.encrypt = 0;
-    zi->ci.stream_initialised = 0;
-    zi->ci.pos_in_buffered_data = 0;
-    zi->ci.raw = raw;
-    zi->ci.pos_local_header = ZTELL(zi->z_filefunc,zi->filestream) ;
-    zi->ci.size_centralheader = SIZECENTRALHEADER + size_filename +
-                                      size_extrafield_global + size_comment;
-    zi->ci.central_header = (char*)ALLOC((uInt)zi->ci.size_centralheader);
-
-    ziplocal_putValue_inmemory(zi->ci.central_header,(uLong)CENTRALHEADERMAGIC,4);
-    /* version info */
-    ziplocal_putValue_inmemory(zi->ci.central_header+4,(uLong)VERSIONMADEBY,2);
-    ziplocal_putValue_inmemory(zi->ci.central_header+6,(uLong)20,2);
-    ziplocal_putValue_inmemory(zi->ci.central_header+8,(uLong)zi->ci.flag,2);
-    ziplocal_putValue_inmemory(zi->ci.central_header+10,(uLong)zi->ci.method,2);
-    ziplocal_putValue_inmemory(zi->ci.central_header+12,(uLong)zi->ci.dosDate,4);
-    ziplocal_putValue_inmemory(zi->ci.central_header+16,(uLong)0,4); /*crc*/
-    ziplocal_putValue_inmemory(zi->ci.central_header+20,(uLong)0,4); /*compr size*/
-    ziplocal_putValue_inmemory(zi->ci.central_header+24,(uLong)0,4); /*uncompr size*/
-    ziplocal_putValue_inmemory(zi->ci.central_header+28,(uLong)size_filename,2);
-    ziplocal_putValue_inmemory(zi->ci.central_header+30,(uLong)size_extrafield_global,2);
-    ziplocal_putValue_inmemory(zi->ci.central_header+32,(uLong)size_comment,2);
-    ziplocal_putValue_inmemory(zi->ci.central_header+34,(uLong)0,2); /*disk nm start*/
-
-    if (zipfi==NULL)
-        ziplocal_putValue_inmemory(zi->ci.central_header+36,(uLong)0,2);
-    else
-        ziplocal_putValue_inmemory(zi->ci.central_header+36,(uLong)zipfi->internal_fa,2);
-
-    if (zipfi==NULL)
-        ziplocal_putValue_inmemory(zi->ci.central_header+38,(uLong)0,4);
-    else
-        ziplocal_putValue_inmemory(zi->ci.central_header+38,(uLong)zipfi->external_fa,4);
-
-    ziplocal_putValue_inmemory(zi->ci.central_header+42,(uLong)zi->ci.pos_local_header- zi->add_position_when_writting_offset,4);
-
-    for (i=0;i<size_filename;i++)
-        *(zi->ci.central_header+SIZECENTRALHEADER+i) = *(filename+i);
-
-    for (i=0;i<size_extrafield_global;i++)
-        *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+i) =
-              *(((const char*)extrafield_global)+i);
-
-    for (i=0;i<size_comment;i++)
-        *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+
-              size_extrafield_global+i) = *(comment+i);
-    if (zi->ci.central_header == NULL)
-        return ZIP_INTERNALERROR;
-
-    /* write the local header */
-    err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)LOCALHEADERMAGIC,4);
-
-    if (err==ZIP_OK)
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)20,2);/* version needed to extract */
-    if (err==ZIP_OK)
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.flag,2);
-
-    if (err==ZIP_OK)
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.method,2);
-
-    if (err==ZIP_OK)
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->ci.dosDate,4);
-
-    if (err==ZIP_OK)
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* crc 32, unknown */
-    if (err==ZIP_OK)
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* compressed size, unknown */
-    if (err==ZIP_OK)
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,4); /* uncompressed size, unknown */
-
-    if (err==ZIP_OK)
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_filename,2);
-
-    if (err==ZIP_OK)
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_extrafield_local,2);
-
-    if ((err==ZIP_OK) && (size_filename>0))
-        if (ZWRITE(zi->z_filefunc,zi->filestream,filename,size_filename)!=size_filename)
-                err = ZIP_ERRNO;
-
-    if ((err==ZIP_OK) && (size_extrafield_local>0))
-        if (ZWRITE(zi->z_filefunc,zi->filestream,extrafield_local,size_extrafield_local)
-                                                                           !=size_extrafield_local)
-                err = ZIP_ERRNO;
-
-    zi->ci.stream.avail_in = (uInt)0;
-    zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
-    zi->ci.stream.next_out = zi->ci.buffered_data;
-    zi->ci.stream.total_in = 0;
-    zi->ci.stream.total_out = 0;
-
-    if ((err==ZIP_OK) && (zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
-    {
-        zi->ci.stream.zalloc = (alloc_func)0;
-        zi->ci.stream.zfree = (free_func)0;
-        zi->ci.stream.opaque = (voidpf)0;
-
-        if (windowBits>0)
-            windowBits = -windowBits;
-
-        err = deflateInit2(&zi->ci.stream, level,
-               Z_DEFLATED, windowBits, memLevel, strategy);
-
-        if (err==Z_OK)
-            zi->ci.stream_initialised = 1;
-    }
-#    ifndef NOCRYPT
-    zi->ci.crypt_header_size = 0;
-    if ((err==Z_OK) && (password != NULL))
-    {
-        unsigned char bufHead[RAND_HEAD_LEN];
-        unsigned int sizeHead;
-        zi->ci.encrypt = 1;
-        zi->ci.pcrc_32_tab = get_crc_table();
-        /*init_keys(password,zi->ci.keys,zi->ci.pcrc_32_tab);*/
-
-        sizeHead=crypthead(password,bufHead,RAND_HEAD_LEN,zi->ci.keys,zi->ci.pcrc_32_tab,crcForCrypting);
-        zi->ci.crypt_header_size = sizeHead;
-
-        if (ZWRITE(zi->z_filefunc,zi->filestream,bufHead,sizeHead) != sizeHead)
-                err = ZIP_ERRNO;
-    }
-#    endif
-
-    if (err==Z_OK)
-        zi->in_opened_file_inzip = 1;
-    return err;
-}
-
-extern int ZEXPORT zipOpenNewFileInZip2(file, filename, zipfi,
-                                        extrafield_local, size_extrafield_local,
-                                        extrafield_global, size_extrafield_global,
-                                        comment, method, level, raw)
-    zipFile file;
-    const char* filename;
-    const zip_fileinfo* zipfi;
-    const void* extrafield_local;
-    uInt size_extrafield_local;
-    const void* extrafield_global;
-    uInt size_extrafield_global;
-    const char* comment;
-    int method;
-    int level;
-    int raw;
-{
-    return zipOpenNewFileInZip3 (file, filename, zipfi,
-                                 extrafield_local, size_extrafield_local,
-                                 extrafield_global, size_extrafield_global,
-                                 comment, method, level, raw,
-                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
-                                 NULL, 0);
-}
-
-extern int ZEXPORT zipOpenNewFileInZip (file, filename, zipfi,
-                                        extrafield_local, size_extrafield_local,
-                                        extrafield_global, size_extrafield_global,
-                                        comment, method, level)
-    zipFile file;
-    const char* filename;
-    const zip_fileinfo* zipfi;
-    const void* extrafield_local;
-    uInt size_extrafield_local;
-    const void* extrafield_global;
-    uInt size_extrafield_global;
-    const char* comment;
-    int method;
-    int level;
-{
-    return zipOpenNewFileInZip2 (file, filename, zipfi,
-                                 extrafield_local, size_extrafield_local,
-                                 extrafield_global, size_extrafield_global,
-                                 comment, method, level, 0);
-}
-
-local int zipFlushWriteBuffer(zi)
-  zip_internal* zi;
-{
-    int err=ZIP_OK;
-
-    if (zi->ci.encrypt != 0)
-    {
-#ifndef NOCRYPT
-        uInt i;
-        int t;
-        for (i=0;i<zi->ci.pos_in_buffered_data;i++)
-            zi->ci.buffered_data[i] = zencode(zi->ci.keys, zi->ci.pcrc_32_tab,
-                                       zi->ci.buffered_data[i],t);
-#endif
-    }
-    if (ZWRITE(zi->z_filefunc,zi->filestream,zi->ci.buffered_data,zi->ci.pos_in_buffered_data)
-                                                                    !=zi->ci.pos_in_buffered_data)
-      err = ZIP_ERRNO;
-    zi->ci.pos_in_buffered_data = 0;
-    return err;
-}
-
-extern int ZEXPORT zipWriteInFileInZip (file, buf, len)
-    zipFile file;
-    const void* buf;
-    unsigned len;
-{
-    zip_internal* zi;
-    int err=ZIP_OK;
-
-    if (file == NULL)
-        return ZIP_PARAMERROR;
-    zi = (zip_internal*)file;
-
-    if (zi->in_opened_file_inzip == 0)
-        return ZIP_PARAMERROR;
-
-    zi->ci.stream.next_in = (void*)buf;
-    zi->ci.stream.avail_in = len;
-    zi->ci.crc32 = crc32(zi->ci.crc32,buf,len);
-
-    while ((err==ZIP_OK) && (zi->ci.stream.avail_in>0))
-    {
-        if (zi->ci.stream.avail_out == 0)
-        {
-            if (zipFlushWriteBuffer(zi) == ZIP_ERRNO)
-                err = ZIP_ERRNO;
-            zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
-            zi->ci.stream.next_out = zi->ci.buffered_data;
-        }
-
-
-        if(err != ZIP_OK)
-            break;
-
-        if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
-        {
-            uLong uTotalOutBefore = zi->ci.stream.total_out;
-            err=deflate(&zi->ci.stream,  Z_NO_FLUSH);
-            zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;
-
-        }
-        else
-        {
-            uInt copy_this,i;
-            if (zi->ci.stream.avail_in < zi->ci.stream.avail_out)
-                copy_this = zi->ci.stream.avail_in;
-            else
-                copy_this = zi->ci.stream.avail_out;
-            for (i=0;i<copy_this;i++)
-                *(((char*)zi->ci.stream.next_out)+i) =
-                    *(((const char*)zi->ci.stream.next_in)+i);
-            {
-                zi->ci.stream.avail_in -= copy_this;
-                zi->ci.stream.avail_out-= copy_this;
-                zi->ci.stream.next_in+= copy_this;
-                zi->ci.stream.next_out+= copy_this;
-                zi->ci.stream.total_in+= copy_this;
-                zi->ci.stream.total_out+= copy_this;
-                zi->ci.pos_in_buffered_data += copy_this;
-            }
-        }
-    }
-
-    return err;
-}
-
-extern int ZEXPORT zipCloseFileInZipRaw (file, uncompressed_size, crc32)
-    zipFile file;
-    uLong uncompressed_size;
-    uLong crc32;
-{
-    zip_internal* zi;
-    uLong compressed_size;
-    int err=ZIP_OK;
-
-    if (file == NULL)
-        return ZIP_PARAMERROR;
-    zi = (zip_internal*)file;
-
-    if (zi->in_opened_file_inzip == 0)
-        return ZIP_PARAMERROR;
-    zi->ci.stream.avail_in = 0;
-
-    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
-        while (err==ZIP_OK)
-    {
-        uLong uTotalOutBefore;
-        if (zi->ci.stream.avail_out == 0)
-        {
-            if (zipFlushWriteBuffer(zi) == ZIP_ERRNO)
-                err = ZIP_ERRNO;
-            zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
-            zi->ci.stream.next_out = zi->ci.buffered_data;
-        }
-        uTotalOutBefore = zi->ci.stream.total_out;
-        err=deflate(&zi->ci.stream,  Z_FINISH);
-        zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;
-    }
-
-    if (err==Z_STREAM_END)
-        err=ZIP_OK; /* this is normal */
-
-    if ((zi->ci.pos_in_buffered_data>0) && (err==ZIP_OK))
-        if (zipFlushWriteBuffer(zi)==ZIP_ERRNO)
-            err = ZIP_ERRNO;
-
-    if ((zi->ci.method == Z_DEFLATED) && (!zi->ci.raw))
-    {
-        err=deflateEnd(&zi->ci.stream);
-        zi->ci.stream_initialised = 0;
-    }
-
-    if (!zi->ci.raw)
-    {
-        crc32 = (uLong)zi->ci.crc32;
-        uncompressed_size = (uLong)zi->ci.stream.total_in;
-    }
-    compressed_size = (uLong)zi->ci.stream.total_out;
-#    ifndef NOCRYPT
-    compressed_size += zi->ci.crypt_header_size;
-#    endif
-
-    ziplocal_putValue_inmemory(zi->ci.central_header+16,crc32,4); /*crc*/
-    ziplocal_putValue_inmemory(zi->ci.central_header+20,
-                                compressed_size,4); /*compr size*/
-    if (zi->ci.stream.data_type == Z_ASCII)
-        ziplocal_putValue_inmemory(zi->ci.central_header+36,(uLong)Z_ASCII,2);
-    ziplocal_putValue_inmemory(zi->ci.central_header+24,
-                                uncompressed_size,4); /*uncompr size*/
-
-    if (err==ZIP_OK)
-        err = add_data_in_datablock(&zi->central_dir,zi->ci.central_header,
-                                       (uLong)zi->ci.size_centralheader);
-    free(zi->ci.central_header);
-
-    if (err==ZIP_OK)
-    {
-        long cur_pos_inzip = ZTELL(zi->z_filefunc,zi->filestream);
-        if (ZSEEK(zi->z_filefunc,zi->filestream,
-                  zi->ci.pos_local_header + 14,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            err = ZIP_ERRNO;
-
-        if (err==ZIP_OK)
-            err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,crc32,4); /* crc 32, unknown */
-
-        if (err==ZIP_OK) /* compressed size, unknown */
-            err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,compressed_size,4);
-
-        if (err==ZIP_OK) /* uncompressed size, unknown */
-            err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,uncompressed_size,4);
-
-        if (ZSEEK(zi->z_filefunc,zi->filestream,
-                  cur_pos_inzip,ZLIB_FILEFUNC_SEEK_SET)!=0)
-            err = ZIP_ERRNO;
-    }
-
-    zi->number_entry ++;
-    zi->in_opened_file_inzip = 0;
-
-    return err;
-}
-
-extern int ZEXPORT zipCloseFileInZip (file)
-    zipFile file;
-{
-    return zipCloseFileInZipRaw (file,0,0);
-}
-
-extern int ZEXPORT zipClose (file, global_comment)
-    zipFile file;
-    const char* global_comment;
-{
-    zip_internal* zi;
-    int err = 0;
-    uLong size_centraldir = 0;
-    uLong centraldir_pos_inzip;
-    uInt size_global_comment;
-    if (file == NULL)
-        return ZIP_PARAMERROR;
-    zi = (zip_internal*)file;
-
-    if (zi->in_opened_file_inzip == 1)
-    {
-        err = zipCloseFileInZip (file);
-    }
-
-#ifndef NO_ADDFILEINEXISTINGZIP
-    if (global_comment==NULL)
-        global_comment = zi->globalcomment;
-#endif
-    if (global_comment==NULL)
-        size_global_comment = 0;
-    else
-        size_global_comment = (uInt)strlen(global_comment);
-
-    centraldir_pos_inzip = ZTELL(zi->z_filefunc,zi->filestream);
-    if (err==ZIP_OK)
-    {
-        linkedlist_datablock_internal* ldi = zi->central_dir.first_block ;
-        while (ldi!=NULL)
-        {
-            if ((err==ZIP_OK) && (ldi->filled_in_this_block>0))
-                if (ZWRITE(zi->z_filefunc,zi->filestream,
-                           ldi->data,ldi->filled_in_this_block)
-                              !=ldi->filled_in_this_block )
-                    err = ZIP_ERRNO;
-
-            size_centraldir += ldi->filled_in_this_block;
-            ldi = ldi->next_datablock;
-        }
-    }
-    free_datablock(zi->central_dir.first_block);
-
-    if (err==ZIP_OK) /* Magic End */
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)ENDHEADERMAGIC,4);
-
-    if (err==ZIP_OK) /* number of this disk */
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);
-
-    if (err==ZIP_OK) /* number of the disk with the start of the central directory */
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)0,2);
-
-    if (err==ZIP_OK) /* total number of entries in the central dir on this disk */
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);
-
-    if (err==ZIP_OK) /* total number of entries in the central dir */
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)zi->number_entry,2);
-
-    if (err==ZIP_OK) /* size of the central directory */
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_centraldir,4);
-
-    if (err==ZIP_OK) /* offset of start of central directory with respect to the
-                            starting disk number */
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,
-                                (uLong)(centraldir_pos_inzip - zi->add_position_when_writting_offset),4);
-
-    if (err==ZIP_OK) /* zipfile comment length */
-        err = ziplocal_putValue(&zi->z_filefunc,zi->filestream,(uLong)size_global_comment,2);
-
-    if ((err==ZIP_OK) && (size_global_comment>0))
-        if (ZWRITE(zi->z_filefunc,zi->filestream,
-                   global_comment,size_global_comment) != size_global_comment)
-                err = ZIP_ERRNO;
-
-    if (ZCLOSE(zi->z_filefunc,zi->filestream) != 0)
-        if (err == ZIP_OK)
-            err = ZIP_ERRNO;
-
-#ifndef NO_ADDFILEINEXISTINGZIP
-    TRYFREE(zi->globalcomment);
-#endif
-    TRYFREE(zi);
-
-    return err;
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/minizip/zip.h gcc-4.6.3-psp/zlib/contrib/minizip/zip.h
--- gcc-4.6.3/zlib/contrib/minizip/zip.h	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/minizip/zip.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,235 +0,0 @@
-/* zip.h -- IO for compress .zip files using zlib
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-
-   This unzip package allow creates .ZIP file, compatible with PKZip 2.04g
-     WinZip, InfoZip tools and compatible.
-   Multi volume ZipFile (span) are not supported.
-   Encryption compatible with pkzip 2.04g only supported
-   Old compressions used by old PKZip 1.x are not supported
-
-  For uncompress .zip file, look at unzip.h
-
-
-   I WAIT FEEDBACK at mail info@winimage.com
-   Visit also http://www.winimage.com/zLibDll/unzip.html for evolution
-
-   Condition of use and distribution are the same than zlib :
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-
-*/
-
-/* for more info about .ZIP format, see
-      http://www.info-zip.org/pub/infozip/doc/appnote-981119-iz.zip
-      http://www.info-zip.org/pub/infozip/doc/
-   PkWare has also a specification at :
-      ftp://ftp.pkware.com/probdesc.zip
-*/
-
-#ifndef _zip_H
-#define _zip_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifndef _ZLIB_H
-#include "zlib.h"
-#endif
-
-#ifndef _ZLIBIOAPI_H
-#include "ioapi.h"
-#endif
-
-#if defined(STRICTZIP) || defined(STRICTZIPUNZIP)
-/* like the STRICT of WIN32, we define a pointer that cannot be converted
-    from (void*) without cast */
-typedef struct TagzipFile__ { int unused; } zipFile__;
-typedef zipFile__ *zipFile;
-#else
-typedef voidp zipFile;
-#endif
-
-#define ZIP_OK                          (0)
-#define ZIP_EOF                         (0)
-#define ZIP_ERRNO                       (Z_ERRNO)
-#define ZIP_PARAMERROR                  (-102)
-#define ZIP_BADZIPFILE                  (-103)
-#define ZIP_INTERNALERROR               (-104)
-
-#ifndef DEF_MEM_LEVEL
-#  if MAX_MEM_LEVEL >= 8
-#    define DEF_MEM_LEVEL 8
-#  else
-#    define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#  endif
-#endif
-/* default memLevel */
-
-/* tm_zip contain date/time info */
-typedef struct tm_zip_s
-{
-    uInt tm_sec;            /* seconds after the minute - [0,59] */
-    uInt tm_min;            /* minutes after the hour - [0,59] */
-    uInt tm_hour;           /* hours since midnight - [0,23] */
-    uInt tm_mday;           /* day of the month - [1,31] */
-    uInt tm_mon;            /* months since January - [0,11] */
-    uInt tm_year;           /* years - [1980..2044] */
-} tm_zip;
-
-typedef struct
-{
-    tm_zip      tmz_date;       /* date in understandable format           */
-    uLong       dosDate;       /* if dos_date == 0, tmu_date is used      */
-/*    uLong       flag;        */   /* general purpose bit flag        2 bytes */
-
-    uLong       internal_fa;    /* internal file attributes        2 bytes */
-    uLong       external_fa;    /* external file attributes        4 bytes */
-} zip_fileinfo;
-
-typedef const char* zipcharpc;
-
-
-#define APPEND_STATUS_CREATE        (0)
-#define APPEND_STATUS_CREATEAFTER   (1)
-#define APPEND_STATUS_ADDINZIP      (2)
-
-extern zipFile ZEXPORT zipOpen OF((const char *pathname, int append));
-/*
-  Create a zipfile.
-     pathname contain on Windows XP a filename like "c:\\zlib\\zlib113.zip" or on
-       an Unix computer "zlib/zlib113.zip".
-     if the file pathname exist and append==APPEND_STATUS_CREATEAFTER, the zip
-       will be created at the end of the file.
-         (useful if the file contain a self extractor code)
-     if the file pathname exist and append==APPEND_STATUS_ADDINZIP, we will
-       add files in existing zip (be sure you don't add file that doesn't exist)
-     If the zipfile cannot be opened, the return value is NULL.
-     Else, the return value is a zipFile Handle, usable with other function
-       of this zip package.
-*/
-
-/* Note : there is no delete function into a zipfile.
-   If you want delete file into a zipfile, you must open a zipfile, and create another
-   Of couse, you can use RAW reading and writing to copy the file you did not want delte
-*/
-
-extern zipFile ZEXPORT zipOpen2 OF((const char *pathname,
-                                   int append,
-                                   zipcharpc* globalcomment,
-                                   zlib_filefunc_def* pzlib_filefunc_def));
-
-extern int ZEXPORT zipOpenNewFileInZip OF((zipFile file,
-                       const char* filename,
-                       const zip_fileinfo* zipfi,
-                       const void* extrafield_local,
-                       uInt size_extrafield_local,
-                       const void* extrafield_global,
-                       uInt size_extrafield_global,
-                       const char* comment,
-                       int method,
-                       int level));
-/*
-  Open a file in the ZIP for writing.
-  filename : the filename in zip (if NULL, '-' without quote will be used
-  *zipfi contain supplemental information
-  if extrafield_local!=NULL and size_extrafield_local>0, extrafield_local
-    contains the extrafield data the the local header
-  if extrafield_global!=NULL and size_extrafield_global>0, extrafield_global
-    contains the extrafield data the the local header
-  if comment != NULL, comment contain the comment string
-  method contain the compression method (0 for store, Z_DEFLATED for deflate)
-  level contain the level of compression (can be Z_DEFAULT_COMPRESSION)
-*/
-
-
-extern int ZEXPORT zipOpenNewFileInZip2 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw));
-
-/*
-  Same than zipOpenNewFileInZip, except if raw=1, we write raw file
- */
-
-extern int ZEXPORT zipOpenNewFileInZip3 OF((zipFile file,
-                                            const char* filename,
-                                            const zip_fileinfo* zipfi,
-                                            const void* extrafield_local,
-                                            uInt size_extrafield_local,
-                                            const void* extrafield_global,
-                                            uInt size_extrafield_global,
-                                            const char* comment,
-                                            int method,
-                                            int level,
-                                            int raw,
-                                            int windowBits,
-                                            int memLevel,
-                                            int strategy,
-                                            const char* password,
-                                            uLong crcForCtypting));
-
-/*
-  Same than zipOpenNewFileInZip2, except
-    windowBits,memLevel,,strategy : see parameter strategy in deflateInit2
-    password : crypting password (NULL for no crypting)
-    crcForCtypting : crc of file to compress (needed for crypting)
- */
-
-
-extern int ZEXPORT zipWriteInFileInZip OF((zipFile file,
-                       const void* buf,
-                       unsigned len));
-/*
-  Write data in the zipfile
-*/
-
-extern int ZEXPORT zipCloseFileInZip OF((zipFile file));
-/*
-  Close the current file in the zipfile
-*/
-
-extern int ZEXPORT zipCloseFileInZipRaw OF((zipFile file,
-                                            uLong uncompressed_size,
-                                            uLong crc32));
-/*
-  Close the current file in the zipfile, for fiel opened with
-    parameter raw=1 in zipOpenNewFileInZip2
-  uncompressed_size and crc32 are value for the uncompressed size
-*/
-
-extern int ZEXPORT zipClose OF((zipFile file,
-                const char* global_comment));
-/*
-  Close the zipfile
-*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _zip_H */
diff -Nbaur gcc-4.6.3/zlib/contrib/pascal/example.pas gcc-4.6.3-psp/zlib/contrib/pascal/example.pas
--- gcc-4.6.3/zlib/contrib/pascal/example.pas	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/pascal/example.pas	1970-01-01 01:00:00.000000000 +0100
@@ -1,599 +0,0 @@
-(* example.c -- usage example of the zlib compression library
- * Copyright (C) 1995-2003 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * Pascal translation
- * Copyright (C) 1998 by Jacques Nomssi Nzali.
- * For conditions of distribution and use, see copyright notice in readme.txt
- *
- * Adaptation to the zlibpas interface
- * Copyright (C) 2003 by Cosmin Truta.
- * For conditions of distribution and use, see copyright notice in readme.txt
- *)
-
-program example;
-
-{$DEFINE TEST_COMPRESS}
-{DO NOT $DEFINE TEST_GZIO}
-{$DEFINE TEST_DEFLATE}
-{$DEFINE TEST_INFLATE}
-{$DEFINE TEST_FLUSH}
-{$DEFINE TEST_SYNC}
-{$DEFINE TEST_DICT}
-
-uses SysUtils, zlibpas;
-
-const TESTFILE = 'foo.gz';
-
-(* "hello world" would be more standard, but the repeated "hello"
- * stresses the compression code better, sorry...
- *)
-const hello: PChar = 'hello, hello!';
-
-const dictionary: PChar = 'hello';
-
-var dictId: LongInt; (* Adler32 value of the dictionary *)
-
-procedure CHECK_ERR(err: Integer; msg: String);
-begin
-  if err <> Z_OK then
-  begin
-    WriteLn(msg, ' error: ', err);
-    Halt(1);
-  end;
-end;
-
-procedure EXIT_ERR(const msg: String);
-begin
-  WriteLn('Error: ', msg);
-  Halt(1);
-end;
-
-(* ===========================================================================
- * Test compress and uncompress
- *)
-{$IFDEF TEST_COMPRESS}
-procedure test_compress(compr: Pointer; comprLen: LongInt;
-                        uncompr: Pointer; uncomprLen: LongInt);
-var err: Integer;
-    len: LongInt;
-begin
-  len := StrLen(hello)+1;
-
-  err := compress(compr, comprLen, hello, len);
-  CHECK_ERR(err, 'compress');
-
-  StrCopy(PChar(uncompr), 'garbage');
-
-  err := uncompress(uncompr, uncomprLen, compr, comprLen);
-  CHECK_ERR(err, 'uncompress');
-
-  if StrComp(PChar(uncompr), hello) <> 0 then
-    EXIT_ERR('bad uncompress')
-  else
-    WriteLn('uncompress(): ', PChar(uncompr));
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test read/write of .gz files
- *)
-{$IFDEF TEST_GZIO}
-procedure test_gzio(const fname: PChar; (* compressed file name *)
-                    uncompr: Pointer;
-                    uncomprLen: LongInt);
-var err: Integer;
-    len: Integer;
-    zfile: gzFile;
-    pos: LongInt;
-begin
-  len := StrLen(hello)+1;
-
-  zfile := gzopen(fname, 'wb');
-  if zfile = NIL then
-  begin
-    WriteLn('gzopen error');
-    Halt(1);
-  end;
-  gzputc(zfile, 'h');
-  if gzputs(zfile, 'ello') <> 4 then
-  begin
-    WriteLn('gzputs err: ', gzerror(zfile, err));
-    Halt(1);
-  end;
-  {$IFDEF GZ_FORMAT_STRING}
-  if gzprintf(zfile, ', %s!', 'hello') <> 8 then
-  begin
-    WriteLn('gzprintf err: ', gzerror(zfile, err));
-    Halt(1);
-  end;
-  {$ELSE}
-  if gzputs(zfile, ', hello!') <> 8 then
-  begin
-    WriteLn('gzputs err: ', gzerror(zfile, err));
-    Halt(1);
-  end;
-  {$ENDIF}
-  gzseek(zfile, 1, SEEK_CUR); (* add one zero byte *)
-  gzclose(zfile);
-
-  zfile := gzopen(fname, 'rb');
-  if zfile = NIL then
-  begin
-    WriteLn('gzopen error');
-    Halt(1);
-  end;
-
-  StrCopy(PChar(uncompr), 'garbage');
-
-  if gzread(zfile, uncompr, uncomprLen) <> len then
-  begin
-    WriteLn('gzread err: ', gzerror(zfile, err));
-    Halt(1);
-  end;
-  if StrComp(PChar(uncompr), hello) <> 0 then
-  begin
-    WriteLn('bad gzread: ', PChar(uncompr));
-    Halt(1);
-  end
-  else
-    WriteLn('gzread(): ', PChar(uncompr));
-
-  pos := gzseek(zfile, -8, SEEK_CUR);
-  if (pos <> 6) or (gztell(zfile) <> pos) then
-  begin
-    WriteLn('gzseek error, pos=', pos, ', gztell=', gztell(zfile));
-    Halt(1);
-  end;
-
-  if gzgetc(zfile) <> ' ' then
-  begin
-    WriteLn('gzgetc error');
-    Halt(1);
-  end;
-
-  if gzungetc(' ', zfile) <> ' ' then
-  begin
-    WriteLn('gzungetc error');
-    Halt(1);
-  end;
-
-  gzgets(zfile, PChar(uncompr), uncomprLen);
-  uncomprLen := StrLen(PChar(uncompr));
-  if uncomprLen <> 7 then (* " hello!" *)
-  begin
-    WriteLn('gzgets err after gzseek: ', gzerror(zfile, err));
-    Halt(1);
-  end;
-  if StrComp(PChar(uncompr), hello + 6) <> 0 then
-  begin
-    WriteLn('bad gzgets after gzseek');
-    Halt(1);
-  end
-  else
-    WriteLn('gzgets() after gzseek: ', PChar(uncompr));
-
-  gzclose(zfile);
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test deflate with small buffers
- *)
-{$IFDEF TEST_DEFLATE}
-procedure test_deflate(compr: Pointer; comprLen: LongInt);
-var c_stream: z_stream; (* compression stream *)
-    err: Integer;
-    len: LongInt;
-begin
-  len := StrLen(hello)+1;
-
-  c_stream.zalloc := NIL;
-  c_stream.zfree := NIL;
-  c_stream.opaque := NIL;
-
-  err := deflateInit(c_stream, Z_DEFAULT_COMPRESSION);
-  CHECK_ERR(err, 'deflateInit');
-
-  c_stream.next_in := hello;
-  c_stream.next_out := compr;
-
-  while (c_stream.total_in <> len) and
-        (c_stream.total_out < comprLen) do
-  begin
-    c_stream.avail_out := 1; { force small buffers }
-    c_stream.avail_in := 1;
-    err := deflate(c_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, 'deflate');
-  end;
-
-  (* Finish the stream, still forcing small buffers: *)
-  while TRUE do
-  begin
-    c_stream.avail_out := 1;
-    err := deflate(c_stream, Z_FINISH);
-    if err = Z_STREAM_END then
-      break;
-    CHECK_ERR(err, 'deflate');
-  end;
-
-  err := deflateEnd(c_stream);
-  CHECK_ERR(err, 'deflateEnd');
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test inflate with small buffers
- *)
-{$IFDEF TEST_INFLATE}
-procedure test_inflate(compr: Pointer; comprLen : LongInt;
-                       uncompr: Pointer; uncomprLen : LongInt);
-var err: Integer;
-    d_stream: z_stream; (* decompression stream *)
-begin
-  StrCopy(PChar(uncompr), 'garbage');
-
-  d_stream.zalloc := NIL;
-  d_stream.zfree := NIL;
-  d_stream.opaque := NIL;
-
-  d_stream.next_in := compr;
-  d_stream.avail_in := 0;
-  d_stream.next_out := uncompr;
-
-  err := inflateInit(d_stream);
-  CHECK_ERR(err, 'inflateInit');
-
-  while (d_stream.total_out < uncomprLen) and
-        (d_stream.total_in < comprLen) do
-  begin
-    d_stream.avail_out := 1; (* force small buffers *)
-    d_stream.avail_in := 1;
-    err := inflate(d_stream, Z_NO_FLUSH);
-    if err = Z_STREAM_END then
-      break;
-    CHECK_ERR(err, 'inflate');
-  end;
-
-  err := inflateEnd(d_stream);
-  CHECK_ERR(err, 'inflateEnd');
-
-  if StrComp(PChar(uncompr), hello) <> 0 then
-    EXIT_ERR('bad inflate')
-  else
-    WriteLn('inflate(): ', PChar(uncompr));
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test deflate with large buffers and dynamic change of compression level
- *)
-{$IFDEF TEST_DEFLATE}
-procedure test_large_deflate(compr: Pointer; comprLen: LongInt;
-                             uncompr: Pointer; uncomprLen: LongInt);
-var c_stream: z_stream; (* compression stream *)
-    err: Integer;
-begin
-  c_stream.zalloc := NIL;
-  c_stream.zfree := NIL;
-  c_stream.opaque := NIL;
-
-  err := deflateInit(c_stream, Z_BEST_SPEED);
-  CHECK_ERR(err, 'deflateInit');
-
-  c_stream.next_out := compr;
-  c_stream.avail_out := Integer(comprLen);
-
-  (* At this point, uncompr is still mostly zeroes, so it should compress
-   * very well:
-   *)
-  c_stream.next_in := uncompr;
-  c_stream.avail_in := Integer(uncomprLen);
-  err := deflate(c_stream, Z_NO_FLUSH);
-  CHECK_ERR(err, 'deflate');
-  if c_stream.avail_in <> 0 then
-    EXIT_ERR('deflate not greedy');
-
-  (* Feed in already compressed data and switch to no compression: *)
-  deflateParams(c_stream, Z_NO_COMPRESSION, Z_DEFAULT_STRATEGY);
-  c_stream.next_in := compr;
-  c_stream.avail_in := Integer(comprLen div 2);
-  err := deflate(c_stream, Z_NO_FLUSH);
-  CHECK_ERR(err, 'deflate');
-
-  (* Switch back to compressing mode: *)
-  deflateParams(c_stream, Z_BEST_COMPRESSION, Z_FILTERED);
-  c_stream.next_in := uncompr;
-  c_stream.avail_in := Integer(uncomprLen);
-  err := deflate(c_stream, Z_NO_FLUSH);
-  CHECK_ERR(err, 'deflate');
-
-  err := deflate(c_stream, Z_FINISH);
-  if err <> Z_STREAM_END then
-    EXIT_ERR('deflate should report Z_STREAM_END');
-
-  err := deflateEnd(c_stream);
-  CHECK_ERR(err, 'deflateEnd');
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test inflate with large buffers
- *)
-{$IFDEF TEST_INFLATE}
-procedure test_large_inflate(compr: Pointer; comprLen: LongInt;
-                             uncompr: Pointer; uncomprLen: LongInt);
-var err: Integer;
-    d_stream: z_stream; (* decompression stream *)
-begin
-  StrCopy(PChar(uncompr), 'garbage');
-
-  d_stream.zalloc := NIL;
-  d_stream.zfree := NIL;
-  d_stream.opaque := NIL;
-
-  d_stream.next_in := compr;
-  d_stream.avail_in := Integer(comprLen);
-
-  err := inflateInit(d_stream);
-  CHECK_ERR(err, 'inflateInit');
-
-  while TRUE do
-  begin
-    d_stream.next_out := uncompr;            (* discard the output *)
-    d_stream.avail_out := Integer(uncomprLen);
-    err := inflate(d_stream, Z_NO_FLUSH);
-    if err = Z_STREAM_END then
-      break;
-    CHECK_ERR(err, 'large inflate');
-  end;
-
-  err := inflateEnd(d_stream);
-  CHECK_ERR(err, 'inflateEnd');
-
-  if d_stream.total_out <> 2 * uncomprLen + comprLen div 2 then
-  begin
-    WriteLn('bad large inflate: ', d_stream.total_out);
-    Halt(1);
-  end
-  else
-    WriteLn('large_inflate(): OK');
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test deflate with full flush
- *)
-{$IFDEF TEST_FLUSH}
-procedure test_flush(compr: Pointer; var comprLen : LongInt);
-var c_stream: z_stream; (* compression stream *)
-    err: Integer;
-    len: Integer;
-begin
-  len := StrLen(hello)+1;
-
-  c_stream.zalloc := NIL;
-  c_stream.zfree := NIL;
-  c_stream.opaque := NIL;
-
-  err := deflateInit(c_stream, Z_DEFAULT_COMPRESSION);
-  CHECK_ERR(err, 'deflateInit');
-
-  c_stream.next_in := hello;
-  c_stream.next_out := compr;
-  c_stream.avail_in := 3;
-  c_stream.avail_out := Integer(comprLen);
-  err := deflate(c_stream, Z_FULL_FLUSH);
-  CHECK_ERR(err, 'deflate');
-
-  Inc(PByteArray(compr)^[3]); (* force an error in first compressed block *)
-  c_stream.avail_in := len - 3;
-
-  err := deflate(c_stream, Z_FINISH);
-  if err <> Z_STREAM_END then
-    CHECK_ERR(err, 'deflate');
-
-  err := deflateEnd(c_stream);
-  CHECK_ERR(err, 'deflateEnd');
-
-  comprLen := c_stream.total_out;
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test inflateSync()
- *)
-{$IFDEF TEST_SYNC}
-procedure test_sync(compr: Pointer; comprLen: LongInt;
-                    uncompr: Pointer; uncomprLen : LongInt);
-var err: Integer;
-    d_stream: z_stream; (* decompression stream *)
-begin
-  StrCopy(PChar(uncompr), 'garbage');
-
-  d_stream.zalloc := NIL;
-  d_stream.zfree := NIL;
-  d_stream.opaque := NIL;
-
-  d_stream.next_in := compr;
-  d_stream.avail_in := 2; (* just read the zlib header *)
-
-  err := inflateInit(d_stream);
-  CHECK_ERR(err, 'inflateInit');
-
-  d_stream.next_out := uncompr;
-  d_stream.avail_out := Integer(uncomprLen);
-
-  inflate(d_stream, Z_NO_FLUSH);
-  CHECK_ERR(err, 'inflate');
-
-  d_stream.avail_in := Integer(comprLen-2);   (* read all compressed data *)
-  err := inflateSync(d_stream);               (* but skip the damaged part *)
-  CHECK_ERR(err, 'inflateSync');
-
-  err := inflate(d_stream, Z_FINISH);
-  if err <> Z_DATA_ERROR then
-    EXIT_ERR('inflate should report DATA_ERROR');
-    (* Because of incorrect adler32 *)
-
-  err := inflateEnd(d_stream);
-  CHECK_ERR(err, 'inflateEnd');
-
-  WriteLn('after inflateSync(): hel', PChar(uncompr));
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test deflate with preset dictionary
- *)
-{$IFDEF TEST_DICT}
-procedure test_dict_deflate(compr: Pointer; comprLen: LongInt);
-var c_stream: z_stream; (* compression stream *)
-    err: Integer;
-begin
-  c_stream.zalloc := NIL;
-  c_stream.zfree := NIL;
-  c_stream.opaque := NIL;
-
-  err := deflateInit(c_stream, Z_BEST_COMPRESSION);
-  CHECK_ERR(err, 'deflateInit');
-
-  err := deflateSetDictionary(c_stream, dictionary, StrLen(dictionary));
-  CHECK_ERR(err, 'deflateSetDictionary');
-
-  dictId := c_stream.adler;
-  c_stream.next_out := compr;
-  c_stream.avail_out := Integer(comprLen);
-
-  c_stream.next_in := hello;
-  c_stream.avail_in := StrLen(hello)+1;
-
-  err := deflate(c_stream, Z_FINISH);
-  if err <> Z_STREAM_END then
-    EXIT_ERR('deflate should report Z_STREAM_END');
-
-  err := deflateEnd(c_stream);
-  CHECK_ERR(err, 'deflateEnd');
-end;
-{$ENDIF}
-
-(* ===========================================================================
- * Test inflate with a preset dictionary
- *)
-{$IFDEF TEST_DICT}
-procedure test_dict_inflate(compr: Pointer; comprLen: LongInt;
-                            uncompr: Pointer; uncomprLen: LongInt);
-var err: Integer;
-    d_stream: z_stream; (* decompression stream *)
-begin
-  StrCopy(PChar(uncompr), 'garbage');
-
-  d_stream.zalloc := NIL;
-  d_stream.zfree := NIL;
-  d_stream.opaque := NIL;
-
-  d_stream.next_in := compr;
-  d_stream.avail_in := Integer(comprLen);
-
-  err := inflateInit(d_stream);
-  CHECK_ERR(err, 'inflateInit');
-
-  d_stream.next_out := uncompr;
-  d_stream.avail_out := Integer(uncomprLen);
-
-  while TRUE do
-  begin
-    err := inflate(d_stream, Z_NO_FLUSH);
-    if err = Z_STREAM_END then
-      break;
-    if err = Z_NEED_DICT then
-    begin
-      if d_stream.adler <> dictId then
-        EXIT_ERR('unexpected dictionary');
-      err := inflateSetDictionary(d_stream, dictionary, StrLen(dictionary));
-    end;
-    CHECK_ERR(err, 'inflate with dict');
-  end;
-
-  err := inflateEnd(d_stream);
-  CHECK_ERR(err, 'inflateEnd');
-
-  if StrComp(PChar(uncompr), hello) <> 0 then
-    EXIT_ERR('bad inflate with dict')
-  else
-    WriteLn('inflate with dictionary: ', PChar(uncompr));
-end;
-{$ENDIF}
-
-var compr, uncompr: Pointer;
-    comprLen, uncomprLen: LongInt;
-
-begin
-  if zlibVersion^ <> ZLIB_VERSION[1] then
-    EXIT_ERR('Incompatible zlib version');
-
-  WriteLn('zlib version: ', zlibVersion);
-  WriteLn('zlib compile flags: ', Format('0x%x', [zlibCompileFlags]));
-
-  comprLen := 10000 * SizeOf(Integer); (* don't overflow on MSDOS *)
-  uncomprLen := comprLen;
-  GetMem(compr, comprLen);
-  GetMem(uncompr, uncomprLen);
-  if (compr = NIL) or (uncompr = NIL) then
-    EXIT_ERR('Out of memory');
-  (* compr and uncompr are cleared to avoid reading uninitialized
-   * data and to ensure that uncompr compresses well.
-   *)
-  FillChar(compr^, comprLen, 0);
-  FillChar(uncompr^, uncomprLen, 0);
-
-  {$IFDEF TEST_COMPRESS}
-  WriteLn('** Testing compress');
-  test_compress(compr, comprLen, uncompr, uncomprLen);
-  {$ENDIF}
-
-  {$IFDEF TEST_GZIO}
-  WriteLn('** Testing gzio');
-  if ParamCount >= 1 then
-    test_gzio(ParamStr(1), uncompr, uncomprLen)
-  else
-    test_gzio(TESTFILE, uncompr, uncomprLen);
-  {$ENDIF}
-
-  {$IFDEF TEST_DEFLATE}
-  WriteLn('** Testing deflate with small buffers');
-  test_deflate(compr, comprLen);
-  {$ENDIF}
-  {$IFDEF TEST_INFLATE}
-  WriteLn('** Testing inflate with small buffers');
-  test_inflate(compr, comprLen, uncompr, uncomprLen);
-  {$ENDIF}
-
-  {$IFDEF TEST_DEFLATE}
-  WriteLn('** Testing deflate with large buffers');
-  test_large_deflate(compr, comprLen, uncompr, uncomprLen);
-  {$ENDIF}
-  {$IFDEF TEST_INFLATE}
-  WriteLn('** Testing inflate with large buffers');
-  test_large_inflate(compr, comprLen, uncompr, uncomprLen);
-  {$ENDIF}
-
-  {$IFDEF TEST_FLUSH}
-  WriteLn('** Testing deflate with full flush');
-  test_flush(compr, comprLen);
-  {$ENDIF}
-  {$IFDEF TEST_SYNC}
-  WriteLn('** Testing inflateSync');
-  test_sync(compr, comprLen, uncompr, uncomprLen);
-  {$ENDIF}
-  comprLen := uncomprLen;
-
-  {$IFDEF TEST_DICT}
-  WriteLn('** Testing deflate and inflate with preset dictionary');
-  test_dict_deflate(compr, comprLen);
-  test_dict_inflate(compr, comprLen, uncompr, uncomprLen);
-  {$ENDIF}
-
-  FreeMem(compr, comprLen);
-  FreeMem(uncompr, uncomprLen);
-end.
diff -Nbaur gcc-4.6.3/zlib/contrib/pascal/readme.txt gcc-4.6.3-psp/zlib/contrib/pascal/readme.txt
--- gcc-4.6.3/zlib/contrib/pascal/readme.txt	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/pascal/readme.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-
-This directory contains a Pascal (Delphi, Kylix) interface to the
-zlib data compression library.
-
-
-Directory listing
-=================
-
-zlibd32.mak     makefile for Borland C++
-example.pas     usage example of zlib
-zlibpas.pas     the Pascal interface to zlib
-readme.txt      this file
-
-
-Compatibility notes
-===================
-
-- Although the name "zlib" would have been more normal for the
-  zlibpas unit, this name is already taken by Borland's ZLib unit.
-  This is somehow unfortunate, because that unit is not a genuine
-  interface to the full-fledged zlib functionality, but a suite of
-  class wrappers around zlib streams.  Other essential features,
-  such as checksums, are missing.
-  It would have been more appropriate for that unit to have a name
-  like "ZStreams", or something similar.
-
-- The C and zlib-supplied types int, uInt, long, uLong, etc. are
-  translated directly into Pascal types of similar sizes (Integer,
-  LongInt, etc.), to avoid namespace pollution.  In particular,
-  there is no conversion of unsigned int into a Pascal unsigned
-  integer.  The Word type is non-portable and has the same size
-  (16 bits) both in a 16-bit and in a 32-bit environment, unlike
-  Integer.  Even if there is a 32-bit Cardinal type, there is no
-  real need for unsigned int in zlib under a 32-bit environment.
-
-- Except for the callbacks, the zlib function interfaces are
-  assuming the calling convention normally used in Pascal
-  (__pascal for DOS and Windows16, __fastcall for Windows32).
-  Since the cdecl keyword is used, the old Turbo Pascal does
-  not work with this interface.
-
-- The gz* function interfaces are not translated, to avoid
-  interfacing problems with the C runtime library.  Besides,
-    gzprintf(gzFile file, const char *format, ...)
-  cannot be translated into Pascal.
-
-
-Legal issues
-============
-
-The zlibpas interface is:
-  Copyright (C) 1995-2003 Jean-loup Gailly and Mark Adler.
-  Copyright (C) 1998 by Bob Dellaca.
-  Copyright (C) 2003 by Cosmin Truta.
-
-The example program is:
-  Copyright (C) 1995-2003 by Jean-loup Gailly.
-  Copyright (C) 1998,1999,2000 by Jacques Nomssi Nzali.
-  Copyright (C) 2003 by Cosmin Truta.
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
diff -Nbaur gcc-4.6.3/zlib/contrib/pascal/zlibd32.mak gcc-4.6.3-psp/zlib/contrib/pascal/zlibd32.mak
--- gcc-4.6.3/zlib/contrib/pascal/zlibd32.mak	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/pascal/zlibd32.mak	1970-01-01 01:00:00.000000000 +0100
@@ -1,93 +0,0 @@
-# Makefile for zlib
-# For use with Delphi and C++ Builder under Win32
-# Updated for zlib 1.2.x by Cosmin Truta
-
-# ------------ Borland C++ ------------
-
-# This project uses the Delphi (fastcall/register) calling convention:
-LOC = -DZEXPORT=__fastcall -DZEXPORTVA=__cdecl
-
-CC = bcc32
-LD = bcc32
-AR = tlib
-# do not use "-pr" in CFLAGS
-CFLAGS = -a -d -k- -O2 $(LOC)
-LDFLAGS =
-
-
-# variables
-ZLIB_LIB = zlib.lib
-
-OBJ1 = adler32.obj compress.obj crc32.obj deflate.obj gzio.obj infback.obj
-OBJ2 = inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj
-OBJP1 = +adler32.obj+compress.obj+crc32.obj+deflate.obj+gzio.obj+infback.obj
-OBJP2 = +inffast.obj+inflate.obj+inftrees.obj+trees.obj+uncompr.obj+zutil.obj
-
-
-# targets
-all: $(ZLIB_LIB) example.exe minigzip.exe
-
-.c.obj:
-	$(CC) -c $(CFLAGS) $*.c
-
-adler32.obj: adler32.c zlib.h zconf.h
-
-compress.obj: compress.c zlib.h zconf.h
-
-crc32.obj: crc32.c zlib.h zconf.h crc32.h
-
-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h
-
-gzio.obj: gzio.c zutil.h zlib.h zconf.h
-
-infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h
-
-inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h
-
-trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h
-
-uncompr.obj: uncompr.c zlib.h zconf.h
-
-zutil.obj: zutil.c zutil.h zlib.h zconf.h
-
-example.obj: example.c zlib.h zconf.h
-
-minigzip.obj: minigzip.c zlib.h zconf.h
-
-
-# For the sake of the old Borland make,
-# the command line is cut to fit in the MS-DOS 128 byte limit:
-$(ZLIB_LIB): $(OBJ1) $(OBJ2)
-	-del $(ZLIB_LIB)
-	$(AR) $(ZLIB_LIB) $(OBJP1)
-	$(AR) $(ZLIB_LIB) $(OBJP2)
-
-
-# testing
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d
-
-example.exe: example.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) example.obj $(ZLIB_LIB)
-
-minigzip.exe: minigzip.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) minigzip.obj $(ZLIB_LIB)
-
-
-# cleanup
-clean:
-	-del *.obj
-	-del *.exe
-	-del *.lib
-	-del *.tds
-	-del zlib.bak
-	-del foo.gz
-
diff -Nbaur gcc-4.6.3/zlib/contrib/pascal/zlibpas.pas gcc-4.6.3-psp/zlib/contrib/pascal/zlibpas.pas
--- gcc-4.6.3/zlib/contrib/pascal/zlibpas.pas	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/pascal/zlibpas.pas	1970-01-01 01:00:00.000000000 +0100
@@ -1,236 +0,0 @@
-(* zlibpas -- Pascal interface to the zlib data compression library
- *
- * Copyright (C) 2003 Cosmin Truta.
- * Derived from original sources by Bob Dellaca.
- * For conditions of distribution and use, see copyright notice in readme.txt
- *)
-
-unit zlibpas;
-
-interface
-
-const
-  ZLIB_VERSION = '1.2.3';
-
-type
-  alloc_func = function(opaque: Pointer; items, size: Integer): Pointer;
-                 cdecl;
-  free_func  = procedure(opaque, address: Pointer);
-                 cdecl;
-
-  in_func    = function(opaque: Pointer; var buf: PByte): Integer;
-                 cdecl;
-  out_func   = function(opaque: Pointer; buf: PByte; size: Integer): Integer;
-                 cdecl;
-
-  z_streamp = ^z_stream;
-  z_stream = packed record
-    next_in: PChar;       (* next input byte *)
-    avail_in: Integer;    (* number of bytes available at next_in *)
-    total_in: LongInt;    (* total nb of input bytes read so far *)
-
-    next_out: PChar;      (* next output byte should be put there *)
-    avail_out: Integer;   (* remaining free space at next_out *)
-    total_out: LongInt;   (* total nb of bytes output so far *)
-
-    msg: PChar;           (* last error message, NULL if no error *)
-    state: Pointer;       (* not visible by applications *)
-
-    zalloc: alloc_func;   (* used to allocate the internal state *)
-    zfree: free_func;     (* used to free the internal state *)
-    opaque: Pointer;      (* private data object passed to zalloc and zfree *)
-
-    data_type: Integer;   (* best guess about the data type: ascii or binary *)
-    adler: LongInt;       (* adler32 value of the uncompressed data *)
-    reserved: LongInt;    (* reserved for future use *)
-  end;
-
-(* constants *)
-const
-  Z_NO_FLUSH      = 0;
-  Z_PARTIAL_FLUSH = 1;
-  Z_SYNC_FLUSH    = 2;
-  Z_FULL_FLUSH    = 3;
-  Z_FINISH        = 4;
-
-  Z_OK            =  0;
-  Z_STREAM_END    =  1;
-  Z_NEED_DICT     =  2;
-  Z_ERRNO         = -1;
-  Z_STREAM_ERROR  = -2;
-  Z_DATA_ERROR    = -3;
-  Z_MEM_ERROR     = -4;
-  Z_BUF_ERROR     = -5;
-  Z_VERSION_ERROR = -6;
-
-  Z_NO_COMPRESSION       =  0;
-  Z_BEST_SPEED           =  1;
-  Z_BEST_COMPRESSION     =  9;
-  Z_DEFAULT_COMPRESSION  = -1;
-
-  Z_FILTERED            = 1;
-  Z_HUFFMAN_ONLY        = 2;
-  Z_RLE                 = 3;
-  Z_DEFAULT_STRATEGY    = 0;
-
-  Z_BINARY   = 0;
-  Z_ASCII    = 1;
-  Z_UNKNOWN  = 2;
-
-  Z_DEFLATED = 8;
-
-(* basic functions *)
-function zlibVersion: PChar;
-function deflateInit(var strm: z_stream; level: Integer): Integer;
-function deflate(var strm: z_stream; flush: Integer): Integer;
-function deflateEnd(var strm: z_stream): Integer;
-function inflateInit(var strm: z_stream): Integer;
-function inflate(var strm: z_stream; flush: Integer): Integer;
-function inflateEnd(var strm: z_stream): Integer;
-
-(* advanced functions *)
-function deflateInit2(var strm: z_stream; level, method, windowBits,
-                      memLevel, strategy: Integer): Integer;
-function deflateSetDictionary(var strm: z_stream; const dictionary: PChar;
-                              dictLength: Integer): Integer;
-function deflateCopy(var dest, source: z_stream): Integer;
-function deflateReset(var strm: z_stream): Integer;
-function deflateParams(var strm: z_stream; level, strategy: Integer): Integer;
-function deflateBound(var strm: z_stream; sourceLen: LongInt): LongInt;
-function deflatePrime(var strm: z_stream; bits, value: Integer): Integer;
-function inflateInit2(var strm: z_stream; windowBits: Integer): Integer;
-function inflateSetDictionary(var strm: z_stream; const dictionary: PChar;
-                              dictLength: Integer): Integer;
-function inflateSync(var strm: z_stream): Integer;
-function inflateCopy(var dest, source: z_stream): Integer;
-function inflateReset(var strm: z_stream): Integer;
-function inflateBackInit(var strm: z_stream;
-                         windowBits: Integer; window: PChar): Integer;
-function inflateBack(var strm: z_stream; in_fn: in_func; in_desc: Pointer;
-                     out_fn: out_func; out_desc: Pointer): Integer;
-function inflateBackEnd(var strm: z_stream): Integer;
-function zlibCompileFlags: LongInt;
-
-(* utility functions *)
-function compress(dest: PChar; var destLen: LongInt;
-                  const source: PChar; sourceLen: LongInt): Integer;
-function compress2(dest: PChar; var destLen: LongInt;
-                  const source: PChar; sourceLen: LongInt;
-                  level: Integer): Integer;
-function compressBound(sourceLen: LongInt): LongInt;
-function uncompress(dest: PChar; var destLen: LongInt;
-                    const source: PChar; sourceLen: LongInt): Integer;
-
-(* checksum functions *)
-function adler32(adler: LongInt; const buf: PChar; len: Integer): LongInt;
-function crc32(crc: LongInt; const buf: PChar; len: Integer): LongInt;
-
-(* various hacks, don't look :) *)
-function deflateInit_(var strm: z_stream; level: Integer;
-                      const version: PChar; stream_size: Integer): Integer;
-function inflateInit_(var strm: z_stream; const version: PChar;
-                      stream_size: Integer): Integer;
-function deflateInit2_(var strm: z_stream;
-                       level, method, windowBits, memLevel, strategy: Integer;
-                       const version: PChar; stream_size: Integer): Integer;
-function inflateInit2_(var strm: z_stream; windowBits: Integer;
-                       const version: PChar; stream_size: Integer): Integer;
-function inflateBackInit_(var strm: z_stream;
-                          windowBits: Integer; window: PChar;
-                          const version: PChar; stream_size: Integer): Integer;
-
-
-implementation
-
-{$L adler32.obj}
-{$L compress.obj}
-{$L crc32.obj}
-{$L deflate.obj}
-{$L infback.obj}
-{$L inffast.obj}
-{$L inflate.obj}
-{$L inftrees.obj}
-{$L trees.obj}
-{$L uncompr.obj}
-{$L zutil.obj}
-
-function adler32; external;
-function compress; external;
-function compress2; external;
-function compressBound; external;
-function crc32; external;
-function deflate; external;
-function deflateBound; external;
-function deflateCopy; external;
-function deflateEnd; external;
-function deflateInit_; external;
-function deflateInit2_; external;
-function deflateParams; external;
-function deflatePrime; external;
-function deflateReset; external;
-function deflateSetDictionary; external;
-function inflate; external;
-function inflateBack; external;
-function inflateBackEnd; external;
-function inflateBackInit_; external;
-function inflateCopy; external;
-function inflateEnd; external;
-function inflateInit_; external;
-function inflateInit2_; external;
-function inflateReset; external;
-function inflateSetDictionary; external;
-function inflateSync; external;
-function uncompress; external;
-function zlibCompileFlags; external;
-function zlibVersion; external;
-
-function deflateInit(var strm: z_stream; level: Integer): Integer;
-begin
-  Result := deflateInit_(strm, level, ZLIB_VERSION, sizeof(z_stream));
-end;
-
-function deflateInit2(var strm: z_stream; level, method, windowBits, memLevel,
-                      strategy: Integer): Integer;
-begin
-  Result := deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
-                          ZLIB_VERSION, sizeof(z_stream));
-end;
-
-function inflateInit(var strm: z_stream): Integer;
-begin
-  Result := inflateInit_(strm, ZLIB_VERSION, sizeof(z_stream));
-end;
-
-function inflateInit2(var strm: z_stream; windowBits: Integer): Integer;
-begin
-  Result := inflateInit2_(strm, windowBits, ZLIB_VERSION, sizeof(z_stream));
-end;
-
-function inflateBackInit(var strm: z_stream;
-                         windowBits: Integer; window: PChar): Integer;
-begin
-  Result := inflateBackInit_(strm, windowBits, window,
-                             ZLIB_VERSION, sizeof(z_stream));
-end;
-
-function _malloc(Size: Integer): Pointer; cdecl;
-begin
-  GetMem(Result, Size);
-end;
-
-procedure _free(Block: Pointer); cdecl;
-begin
-  FreeMem(Block);
-end;
-
-procedure _memset(P: Pointer; B: Byte; count: Integer); cdecl;
-begin
-  FillChar(P^, count, B);
-end;
-
-procedure _memcpy(dest, source: Pointer; count: Integer); cdecl;
-begin
-  Move(source^, dest^, count);
-end;
-
-end.
diff -Nbaur gcc-4.6.3/zlib/contrib/puff/Makefile gcc-4.6.3-psp/zlib/contrib/puff/Makefile
--- gcc-4.6.3/zlib/contrib/puff/Makefile	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/puff/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-puff: puff.c puff.h
-	cc -DTEST -o puff puff.c
-
-test: puff
-	puff zeros.raw
-
-clean:
-	rm -f puff puff.o
diff -Nbaur gcc-4.6.3/zlib/contrib/puff/puff.c gcc-4.6.3-psp/zlib/contrib/puff/puff.c
--- gcc-4.6.3/zlib/contrib/puff/puff.c	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/puff/puff.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,837 +0,0 @@
-/*
- * puff.c
- * Copyright (C) 2002-2004 Mark Adler
- * For conditions of distribution and use, see copyright notice in puff.h
- * version 1.8, 9 Jan 2004
- *
- * puff.c is a simple inflate written to be an unambiguous way to specify the
- * deflate format.  It is not written for speed but rather simplicity.  As a
- * side benefit, this code might actually be useful when small code is more
- * important than speed, such as bootstrap applications.  For typical deflate
- * data, zlib's inflate() is about four times as fast as puff().  zlib's
- * inflate compiles to around 20K on my machine, whereas puff.c compiles to
- * around 4K on my machine (a PowerPC using GNU cc).  If the faster decode()
- * function here is used, then puff() is only twice as slow as zlib's
- * inflate().
- *
- * All dynamically allocated memory comes from the stack.  The stack required
- * is less than 2K bytes.  This code is compatible with 16-bit int's and
- * assumes that long's are at least 32 bits.  puff.c uses the short data type,
- * assumed to be 16 bits, for arrays in order to to conserve memory.  The code
- * works whether integers are stored big endian or little endian.
- *
- * In the comments below are "Format notes" that describe the inflate process
- * and document some of the less obvious aspects of the format.  This source
- * code is meant to supplement RFC 1951, which formally describes the deflate
- * format:
- *
- *    http://www.zlib.org/rfc-deflate.html
- */
-
-/*
- * Change history:
- *
- * 1.0  10 Feb 2002     - First version
- * 1.1  17 Feb 2002     - Clarifications of some comments and notes
- *                      - Update puff() dest and source pointers on negative
- *                        errors to facilitate debugging deflators
- *                      - Remove longest from struct huffman -- not needed
- *                      - Simplify offs[] index in construct()
- *                      - Add input size and checking, using longjmp() to
- *                        maintain easy readability
- *                      - Use short data type for large arrays
- *                      - Use pointers instead of long to specify source and
- *                        destination sizes to avoid arbitrary 4 GB limits
- * 1.2  17 Mar 2002     - Add faster version of decode(), doubles speed (!),
- *                        but leave simple version for readabilty
- *                      - Make sure invalid distances detected if pointers
- *                        are 16 bits
- *                      - Fix fixed codes table error
- *                      - Provide a scanning mode for determining size of
- *                        uncompressed data
- * 1.3  20 Mar 2002     - Go back to lengths for puff() parameters [Jean-loup]
- *                      - Add a puff.h file for the interface
- *                      - Add braces in puff() for else do [Jean-loup]
- *                      - Use indexes instead of pointers for readability
- * 1.4  31 Mar 2002     - Simplify construct() code set check
- *                      - Fix some comments
- *                      - Add FIXLCODES #define
- * 1.5   6 Apr 2002     - Minor comment fixes
- * 1.6   7 Aug 2002     - Minor format changes
- * 1.7   3 Mar 2003     - Added test code for distribution
- *                      - Added zlib-like license
- * 1.8   9 Jan 2004     - Added some comments on no distance codes case
- */
-
-#include <setjmp.h>             /* for setjmp(), longjmp(), and jmp_buf */
-#include "puff.h"               /* prototype for puff() */
-
-#define local static            /* for local function definitions */
-#define NIL ((unsigned char *)0)        /* for no output option */
-
-/*
- * Maximums for allocations and loops.  It is not useful to change these --
- * they are fixed by the deflate format.
- */
-#define MAXBITS 15              /* maximum bits in a code */
-#define MAXLCODES 286           /* maximum number of literal/length codes */
-#define MAXDCODES 30            /* maximum number of distance codes */
-#define MAXCODES (MAXLCODES+MAXDCODES)  /* maximum codes lengths to read */
-#define FIXLCODES 288           /* number of fixed literal/length codes */
-
-/* input and output state */
-struct state {
-    /* output state */
-    unsigned char *out;         /* output buffer */
-    unsigned long outlen;       /* available space at out */
-    unsigned long outcnt;       /* bytes written to out so far */
-
-    /* input state */
-    unsigned char *in;          /* input buffer */
-    unsigned long inlen;        /* available input at in */
-    unsigned long incnt;        /* bytes read so far */
-    int bitbuf;                 /* bit buffer */
-    int bitcnt;                 /* number of bits in bit buffer */
-
-    /* input limit error return state for bits() and decode() */
-    jmp_buf env;
-};
-
-/*
- * Return need bits from the input stream.  This always leaves less than
- * eight bits in the buffer.  bits() works properly for need == 0.
- *
- * Format notes:
- *
- * - Bits are stored in bytes from the least significant bit to the most
- *   significant bit.  Therefore bits are dropped from the bottom of the bit
- *   buffer, using shift right, and new bytes are appended to the top of the
- *   bit buffer, using shift left.
- */
-local int bits(struct state *s, int need)
-{
-    long val;           /* bit accumulator (can use up to 20 bits) */
-
-    /* load at least need bits into val */
-    val = s->bitbuf;
-    while (s->bitcnt < need) {
-        if (s->incnt == s->inlen) longjmp(s->env, 1);   /* out of input */
-        val |= (long)(s->in[s->incnt++]) << s->bitcnt;  /* load eight bits */
-        s->bitcnt += 8;
-    }
-
-    /* drop need bits and update buffer, always zero to seven bits left */
-    s->bitbuf = (int)(val >> need);
-    s->bitcnt -= need;
-
-    /* return need bits, zeroing the bits above that */
-    return (int)(val & ((1L << need) - 1));
-}
-
-/*
- * Process a stored block.
- *
- * Format notes:
- *
- * - After the two-bit stored block type (00), the stored block length and
- *   stored bytes are byte-aligned for fast copying.  Therefore any leftover
- *   bits in the byte that has the last bit of the type, as many as seven, are
- *   discarded.  The value of the discarded bits are not defined and should not
- *   be checked against any expectation.
- *
- * - The second inverted copy of the stored block length does not have to be
- *   checked, but it's probably a good idea to do so anyway.
- *
- * - A stored block can have zero length.  This is sometimes used to byte-align
- *   subsets of the compressed data for random access or partial recovery.
- */
-local int stored(struct state *s)
-{
-    unsigned len;       /* length of stored block */
-
-    /* discard leftover bits from current byte (assumes s->bitcnt < 8) */
-    s->bitbuf = 0;
-    s->bitcnt = 0;
-
-    /* get length and check against its one's complement */
-    if (s->incnt + 4 > s->inlen) return 2;      /* not enough input */
-    len = s->in[s->incnt++];
-    len |= s->in[s->incnt++] << 8;
-    if (s->in[s->incnt++] != (~len & 0xff) ||
-        s->in[s->incnt++] != ((~len >> 8) & 0xff))
-        return -2;                              /* didn't match complement! */
-
-    /* copy len bytes from in to out */
-    if (s->incnt + len > s->inlen) return 2;    /* not enough input */
-    if (s->out != NIL) {
-        if (s->outcnt + len > s->outlen)
-            return 1;                           /* not enough output space */
-        while (len--)
-            s->out[s->outcnt++] = s->in[s->incnt++];
-    }
-    else {                                      /* just scanning */
-        s->outcnt += len;
-        s->incnt += len;
-    }
-
-    /* done with a valid stored block */
-    return 0;
-}
-
-/*
- * Huffman code decoding tables.  count[1..MAXBITS] is the number of symbols of
- * each length, which for a canonical code are stepped through in order.
- * symbol[] are the symbol values in canonical order, where the number of
- * entries is the sum of the counts in count[].  The decoding process can be
- * seen in the function decode() below.
- */
-struct huffman {
-    short *count;       /* number of symbols of each length */
-    short *symbol;      /* canonically ordered symbols */
-};
-
-/*
- * Decode a code from the stream s using huffman table h.  Return the symbol or
- * a negative value if there is an error.  If all of the lengths are zero, i.e.
- * an empty code, or if the code is incomplete and an invalid code is received,
- * then -9 is returned after reading MAXBITS bits.
- *
- * Format notes:
- *
- * - The codes as stored in the compressed data are bit-reversed relative to
- *   a simple integer ordering of codes of the same lengths.  Hence below the
- *   bits are pulled from the compressed data one at a time and used to
- *   build the code value reversed from what is in the stream in order to
- *   permit simple integer comparisons for decoding.  A table-based decoding
- *   scheme (as used in zlib) does not need to do this reversal.
- *
- * - The first code for the shortest length is all zeros.  Subsequent codes of
- *   the same length are simply integer increments of the previous code.  When
- *   moving up a length, a zero bit is appended to the code.  For a complete
- *   code, the last code of the longest length will be all ones.
- *
- * - Incomplete codes are handled by this decoder, since they are permitted
- *   in the deflate format.  See the format notes for fixed() and dynamic().
- */
-#ifdef SLOW
-local int decode(struct state *s, struct huffman *h)
-{
-    int len;            /* current number of bits in code */
-    int code;           /* len bits being decoded */
-    int first;          /* first code of length len */
-    int count;          /* number of codes of length len */
-    int index;          /* index of first code of length len in symbol table */
-
-    code = first = index = 0;
-    for (len = 1; len <= MAXBITS; len++) {
-        code |= bits(s, 1);             /* get next bit */
-        count = h->count[len];
-        if (code < first + count)       /* if length len, return symbol */
-            return h->symbol[index + (code - first)];
-        index += count;                 /* else update for next length */
-        first += count;
-        first <<= 1;
-        code <<= 1;
-    }
-    return -9;                          /* ran out of codes */
-}
-
-/*
- * A faster version of decode() for real applications of this code.   It's not
- * as readable, but it makes puff() twice as fast.  And it only makes the code
- * a few percent larger.
- */
-#else /* !SLOW */
-local int decode(struct state *s, struct huffman *h)
-{
-    int len;            /* current number of bits in code */
-    int code;           /* len bits being decoded */
-    int first;          /* first code of length len */
-    int count;          /* number of codes of length len */
-    int index;          /* index of first code of length len in symbol table */
-    int bitbuf;         /* bits from stream */
-    int left;           /* bits left in next or left to process */
-    short *next;        /* next number of codes */
-
-    bitbuf = s->bitbuf;
-    left = s->bitcnt;
-    code = first = index = 0;
-    len = 1;
-    next = h->count + 1;
-    while (1) {
-        while (left--) {
-            code |= bitbuf & 1;
-            bitbuf >>= 1;
-            count = *next++;
-            if (code < first + count) { /* if length len, return symbol */
-                s->bitbuf = bitbuf;
-                s->bitcnt = (s->bitcnt - len) & 7;
-                return h->symbol[index + (code - first)];
-            }
-            index += count;             /* else update for next length */
-            first += count;
-            first <<= 1;
-            code <<= 1;
-            len++;
-        }
-        left = (MAXBITS+1) - len;
-        if (left == 0) break;
-        if (s->incnt == s->inlen) longjmp(s->env, 1);   /* out of input */
-        bitbuf = s->in[s->incnt++];
-        if (left > 8) left = 8;
-    }
-    return -9;                          /* ran out of codes */
-}
-#endif /* SLOW */
-
-/*
- * Given the list of code lengths length[0..n-1] representing a canonical
- * Huffman code for n symbols, construct the tables required to decode those
- * codes.  Those tables are the number of codes of each length, and the symbols
- * sorted by length, retaining their original order within each length.  The
- * return value is zero for a complete code set, negative for an over-
- * subscribed code set, and positive for an incomplete code set.  The tables
- * can be used if the return value is zero or positive, but they cannot be used
- * if the return value is negative.  If the return value is zero, it is not
- * possible for decode() using that table to return an error--any stream of
- * enough bits will resolve to a symbol.  If the return value is positive, then
- * it is possible for decode() using that table to return an error for received
- * codes past the end of the incomplete lengths.
- *
- * Not used by decode(), but used for error checking, h->count[0] is the number
- * of the n symbols not in the code.  So n - h->count[0] is the number of
- * codes.  This is useful for checking for incomplete codes that have more than
- * one symbol, which is an error in a dynamic block.
- *
- * Assumption: for all i in 0..n-1, 0 <= length[i] <= MAXBITS
- * This is assured by the construction of the length arrays in dynamic() and
- * fixed() and is not verified by construct().
- *
- * Format notes:
- *
- * - Permitted and expected examples of incomplete codes are one of the fixed
- *   codes and any code with a single symbol which in deflate is coded as one
- *   bit instead of zero bits.  See the format notes for fixed() and dynamic().
- *
- * - Within a given code length, the symbols are kept in ascending order for
- *   the code bits definition.
- */
-local int construct(struct huffman *h, short *length, int n)
-{
-    int symbol;         /* current symbol when stepping through length[] */
-    int len;            /* current length when stepping through h->count[] */
-    int left;           /* number of possible codes left of current length */
-    short offs[MAXBITS+1];      /* offsets in symbol table for each length */
-
-    /* count number of codes of each length */
-    for (len = 0; len <= MAXBITS; len++)
-        h->count[len] = 0;
-    for (symbol = 0; symbol < n; symbol++)
-        (h->count[length[symbol]])++;   /* assumes lengths are within bounds */
-    if (h->count[0] == n)               /* no codes! */
-        return 0;                       /* complete, but decode() will fail */
-
-    /* check for an over-subscribed or incomplete set of lengths */
-    left = 1;                           /* one possible code of zero length */
-    for (len = 1; len <= MAXBITS; len++) {
-        left <<= 1;                     /* one more bit, double codes left */
-        left -= h->count[len];          /* deduct count from possible codes */
-        if (left < 0) return left;      /* over-subscribed--return negative */
-    }                                   /* left > 0 means incomplete */
-
-    /* generate offsets into symbol table for each length for sorting */
-    offs[1] = 0;
-    for (len = 1; len < MAXBITS; len++)
-        offs[len + 1] = offs[len] + h->count[len];
-
-    /*
-     * put symbols in table sorted by length, by symbol order within each
-     * length
-     */
-    for (symbol = 0; symbol < n; symbol++)
-        if (length[symbol] != 0)
-            h->symbol[offs[length[symbol]]++] = symbol;
-
-    /* return zero for complete set, positive for incomplete set */
-    return left;
-}
-
-/*
- * Decode literal/length and distance codes until an end-of-block code.
- *
- * Format notes:
- *
- * - Compressed data that is after the block type if fixed or after the code
- *   description if dynamic is a combination of literals and length/distance
- *   pairs terminated by and end-of-block code.  Literals are simply Huffman
- *   coded bytes.  A length/distance pair is a coded length followed by a
- *   coded distance to represent a string that occurs earlier in the
- *   uncompressed data that occurs again at the current location.
- *
- * - Literals, lengths, and the end-of-block code are combined into a single
- *   code of up to 286 symbols.  They are 256 literals (0..255), 29 length
- *   symbols (257..285), and the end-of-block symbol (256).
- *
- * - There are 256 possible lengths (3..258), and so 29 symbols are not enough
- *   to represent all of those.  Lengths 3..10 and 258 are in fact represented
- *   by just a length symbol.  Lengths 11..257 are represented as a symbol and
- *   some number of extra bits that are added as an integer to the base length
- *   of the length symbol.  The number of extra bits is determined by the base
- *   length symbol.  These are in the static arrays below, lens[] for the base
- *   lengths and lext[] for the corresponding number of extra bits.
- *
- * - The reason that 258 gets its own symbol is that the longest length is used
- *   often in highly redundant files.  Note that 258 can also be coded as the
- *   base value 227 plus the maximum extra value of 31.  While a good deflate
- *   should never do this, it is not an error, and should be decoded properly.
- *
- * - If a length is decoded, including its extra bits if any, then it is
- *   followed a distance code.  There are up to 30 distance symbols.  Again
- *   there are many more possible distances (1..32768), so extra bits are added
- *   to a base value represented by the symbol.  The distances 1..4 get their
- *   own symbol, but the rest require extra bits.  The base distances and
- *   corresponding number of extra bits are below in the static arrays dist[]
- *   and dext[].
- *
- * - Literal bytes are simply written to the output.  A length/distance pair is
- *   an instruction to copy previously uncompressed bytes to the output.  The
- *   copy is from distance bytes back in the output stream, copying for length
- *   bytes.
- *
- * - Distances pointing before the beginning of the output data are not
- *   permitted.
- *
- * - Overlapped copies, where the length is greater than the distance, are
- *   allowed and common.  For example, a distance of one and a length of 258
- *   simply copies the last byte 258 times.  A distance of four and a length of
- *   twelve copies the last four bytes three times.  A simple forward copy
- *   ignoring whether the length is greater than the distance or not implements
- *   this correctly.  You should not use memcpy() since its behavior is not
- *   defined for overlapped arrays.  You should not use memmove() or bcopy()
- *   since though their behavior -is- defined for overlapping arrays, it is
- *   defined to do the wrong thing in this case.
- */
-local int codes(struct state *s,
-                struct huffman *lencode,
-                struct huffman *distcode)
-{
-    int symbol;         /* decoded symbol */
-    int len;            /* length for copy */
-    unsigned dist;      /* distance for copy */
-    static const short lens[29] = { /* Size base for length codes 257..285 */
-        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
-        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};
-    static const short lext[29] = { /* Extra bits for length codes 257..285 */
-        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
-        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};
-    static const short dists[30] = { /* Offset base for distance codes 0..29 */
-        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
-        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
-        8193, 12289, 16385, 24577};
-    static const short dext[30] = { /* Extra bits for distance codes 0..29 */
-        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
-        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
-        12, 12, 13, 13};
-
-    /* decode literals and length/distance pairs */
-    do {
-        symbol = decode(s, lencode);
-        if (symbol < 0) return symbol;  /* invalid symbol */
-        if (symbol < 256) {             /* literal: symbol is the byte */
-            /* write out the literal */
-            if (s->out != NIL) {
-                if (s->outcnt == s->outlen) return 1;
-                s->out[s->outcnt] = symbol;
-            }
-            s->outcnt++;
-        }
-        else if (symbol > 256) {        /* length */
-            /* get and compute length */
-            symbol -= 257;
-            if (symbol >= 29) return -9;        /* invalid fixed code */
-            len = lens[symbol] + bits(s, lext[symbol]);
-
-            /* get and check distance */
-            symbol = decode(s, distcode);
-            if (symbol < 0) return symbol;      /* invalid symbol */
-            dist = dists[symbol] + bits(s, dext[symbol]);
-            if (dist > s->outcnt)
-                return -10;     /* distance too far back */
-
-            /* copy length bytes from distance bytes back */
-            if (s->out != NIL) {
-                if (s->outcnt + len > s->outlen) return 1;
-                while (len--) {
-                    s->out[s->outcnt] = s->out[s->outcnt - dist];
-                    s->outcnt++;
-                }
-            }
-            else
-                s->outcnt += len;
-        }
-    } while (symbol != 256);            /* end of block symbol */
-
-    /* done with a valid fixed or dynamic block */
-    return 0;
-}
-
-/*
- * Process a fixed codes block.
- *
- * Format notes:
- *
- * - This block type can be useful for compressing small amounts of data for
- *   which the size of the code descriptions in a dynamic block exceeds the
- *   benefit of custom codes for that block.  For fixed codes, no bits are
- *   spent on code descriptions.  Instead the code lengths for literal/length
- *   codes and distance codes are fixed.  The specific lengths for each symbol
- *   can be seen in the "for" loops below.
- *
- * - The literal/length code is complete, but has two symbols that are invalid
- *   and should result in an error if received.  This cannot be implemented
- *   simply as an incomplete code since those two symbols are in the "middle"
- *   of the code.  They are eight bits long and the longest literal/length\
- *   code is nine bits.  Therefore the code must be constructed with those
- *   symbols, and the invalid symbols must be detected after decoding.
- *
- * - The fixed distance codes also have two invalid symbols that should result
- *   in an error if received.  Since all of the distance codes are the same
- *   length, this can be implemented as an incomplete code.  Then the invalid
- *   codes are detected while decoding.
- */
-local int fixed(struct state *s)
-{
-    static int virgin = 1;
-    static short lencnt[MAXBITS+1], lensym[FIXLCODES];
-    static short distcnt[MAXBITS+1], distsym[MAXDCODES];
-    static struct huffman lencode = {lencnt, lensym};
-    static struct huffman distcode = {distcnt, distsym};
-
-    /* build fixed huffman tables if first call (may not be thread safe) */
-    if (virgin) {
-        int symbol;
-        short lengths[FIXLCODES];
-
-        /* literal/length table */
-        for (symbol = 0; symbol < 144; symbol++)
-            lengths[symbol] = 8;
-        for (; symbol < 256; symbol++)
-            lengths[symbol] = 9;
-        for (; symbol < 280; symbol++)
-            lengths[symbol] = 7;
-        for (; symbol < FIXLCODES; symbol++)
-            lengths[symbol] = 8;
-        construct(&lencode, lengths, FIXLCODES);
-
-        /* distance table */
-        for (symbol = 0; symbol < MAXDCODES; symbol++)
-            lengths[symbol] = 5;
-        construct(&distcode, lengths, MAXDCODES);
-
-        /* do this just once */
-        virgin = 0;
-    }
-
-    /* decode data until end-of-block code */
-    return codes(s, &lencode, &distcode);
-}
-
-/*
- * Process a dynamic codes block.
- *
- * Format notes:
- *
- * - A dynamic block starts with a description of the literal/length and
- *   distance codes for that block.  New dynamic blocks allow the compressor to
- *   rapidly adapt to changing data with new codes optimized for that data.
- *
- * - The codes used by the deflate format are "canonical", which means that
- *   the actual bits of the codes are generated in an unambiguous way simply
- *   from the number of bits in each code.  Therefore the code descriptions
- *   are simply a list of code lengths for each symbol.
- *
- * - The code lengths are stored in order for the symbols, so lengths are
- *   provided for each of the literal/length symbols, and for each of the
- *   distance symbols.
- *
- * - If a symbol is not used in the block, this is represented by a zero as
- *   as the code length.  This does not mean a zero-length code, but rather
- *   that no code should be created for this symbol.  There is no way in the
- *   deflate format to represent a zero-length code.
- *
- * - The maximum number of bits in a code is 15, so the possible lengths for
- *   any code are 1..15.
- *
- * - The fact that a length of zero is not permitted for a code has an
- *   interesting consequence.  Normally if only one symbol is used for a given
- *   code, then in fact that code could be represented with zero bits.  However
- *   in deflate, that code has to be at least one bit.  So for example, if
- *   only a single distance base symbol appears in a block, then it will be
- *   represented by a single code of length one, in particular one 0 bit.  This
- *   is an incomplete code, since if a 1 bit is received, it has no meaning,
- *   and should result in an error.  So incomplete distance codes of one symbol
- *   should be permitted, and the receipt of invalid codes should be handled.
- *
- * - It is also possible to have a single literal/length code, but that code
- *   must be the end-of-block code, since every dynamic block has one.  This
- *   is not the most efficient way to create an empty block (an empty fixed
- *   block is fewer bits), but it is allowed by the format.  So incomplete
- *   literal/length codes of one symbol should also be permitted.
- *
- * - If there are only literal codes and no lengths, then there are no distance
- *   codes.  This is represented by one distance code with zero bits.
- *
- * - The list of up to 286 length/literal lengths and up to 30 distance lengths
- *   are themselves compressed using Huffman codes and run-length encoding.  In
- *   the list of code lengths, a 0 symbol means no code, a 1..15 symbol means
- *   that length, and the symbols 16, 17, and 18 are run-length instructions.
- *   Each of 16, 17, and 18 are follwed by extra bits to define the length of
- *   the run.  16 copies the last length 3 to 6 times.  17 represents 3 to 10
- *   zero lengths, and 18 represents 11 to 138 zero lengths.  Unused symbols
- *   are common, hence the special coding for zero lengths.
- *
- * - The symbols for 0..18 are Huffman coded, and so that code must be
- *   described first.  This is simply a sequence of up to 19 three-bit values
- *   representing no code (0) or the code length for that symbol (1..7).
- *
- * - A dynamic block starts with three fixed-size counts from which is computed
- *   the number of literal/length code lengths, the number of distance code
- *   lengths, and the number of code length code lengths (ok, you come up with
- *   a better name!) in the code descriptions.  For the literal/length and
- *   distance codes, lengths after those provided are considered zero, i.e. no
- *   code.  The code length code lengths are received in a permuted order (see
- *   the order[] array below) to make a short code length code length list more
- *   likely.  As it turns out, very short and very long codes are less likely
- *   to be seen in a dynamic code description, hence what may appear initially
- *   to be a peculiar ordering.
- *
- * - Given the number of literal/length code lengths (nlen) and distance code
- *   lengths (ndist), then they are treated as one long list of nlen + ndist
- *   code lengths.  Therefore run-length coding can and often does cross the
- *   boundary between the two sets of lengths.
- *
- * - So to summarize, the code description at the start of a dynamic block is
- *   three counts for the number of code lengths for the literal/length codes,
- *   the distance codes, and the code length codes.  This is followed by the
- *   code length code lengths, three bits each.  This is used to construct the
- *   code length code which is used to read the remainder of the lengths.  Then
- *   the literal/length code lengths and distance lengths are read as a single
- *   set of lengths using the code length codes.  Codes are constructed from
- *   the resulting two sets of lengths, and then finally you can start
- *   decoding actual compressed data in the block.
- *
- * - For reference, a "typical" size for the code description in a dynamic
- *   block is around 80 bytes.
- */
-local int dynamic(struct state *s)
-{
-    int nlen, ndist, ncode;             /* number of lengths in descriptor */
-    int index;                          /* index of lengths[] */
-    int err;                            /* construct() return value */
-    short lengths[MAXCODES];            /* descriptor code lengths */
-    short lencnt[MAXBITS+1], lensym[MAXLCODES];         /* lencode memory */
-    short distcnt[MAXBITS+1], distsym[MAXDCODES];       /* distcode memory */
-    struct huffman lencode = {lencnt, lensym};          /* length code */
-    struct huffman distcode = {distcnt, distsym};       /* distance code */
-    static const short order[19] =      /* permutation of code length codes */
-        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-
-    /* get number of lengths in each table, check lengths */
-    nlen = bits(s, 5) + 257;
-    ndist = bits(s, 5) + 1;
-    ncode = bits(s, 4) + 4;
-    if (nlen > MAXLCODES || ndist > MAXDCODES)
-        return -3;                      /* bad counts */
-
-    /* read code length code lengths (really), missing lengths are zero */
-    for (index = 0; index < ncode; index++)
-        lengths[order[index]] = bits(s, 3);
-    for (; index < 19; index++)
-        lengths[order[index]] = 0;
-
-    /* build huffman table for code lengths codes (use lencode temporarily) */
-    err = construct(&lencode, lengths, 19);
-    if (err != 0) return -4;            /* require complete code set here */
-
-    /* read length/literal and distance code length tables */
-    index = 0;
-    while (index < nlen + ndist) {
-        int symbol;             /* decoded value */
-        int len;                /* last length to repeat */
-
-        symbol = decode(s, &lencode);
-        if (symbol < 16)                /* length in 0..15 */
-            lengths[index++] = symbol;
-        else {                          /* repeat instruction */
-            len = 0;                    /* assume repeating zeros */
-            if (symbol == 16) {         /* repeat last length 3..6 times */
-                if (index == 0) return -5;      /* no last length! */
-                len = lengths[index - 1];       /* last length */
-                symbol = 3 + bits(s, 2);
-            }
-            else if (symbol == 17)      /* repeat zero 3..10 times */
-                symbol = 3 + bits(s, 3);
-            else                        /* == 18, repeat zero 11..138 times */
-                symbol = 11 + bits(s, 7);
-            if (index + symbol > nlen + ndist)
-                return -6;              /* too many lengths! */
-            while (symbol--)            /* repeat last or zero symbol times */
-                lengths[index++] = len;
-        }
-    }
-
-    /* build huffman table for literal/length codes */
-    err = construct(&lencode, lengths, nlen);
-    if (err < 0 || (err > 0 && nlen - lencode.count[0] != 1))
-        return -7;      /* only allow incomplete codes if just one code */
-
-    /* build huffman table for distance codes */
-    err = construct(&distcode, lengths + nlen, ndist);
-    if (err < 0 || (err > 0 && ndist - distcode.count[0] != 1))
-        return -8;      /* only allow incomplete codes if just one code */
-
-    /* decode data until end-of-block code */
-    return codes(s, &lencode, &distcode);
-}
-
-/*
- * Inflate source to dest.  On return, destlen and sourcelen are updated to the
- * size of the uncompressed data and the size of the deflate data respectively.
- * On success, the return value of puff() is zero.  If there is an error in the
- * source data, i.e. it is not in the deflate format, then a negative value is
- * returned.  If there is not enough input available or there is not enough
- * output space, then a positive error is returned.  In that case, destlen and
- * sourcelen are not updated to facilitate retrying from the beginning with the
- * provision of more input data or more output space.  In the case of invalid
- * inflate data (a negative error), the dest and source pointers are updated to
- * facilitate the debugging of deflators.
- *
- * puff() also has a mode to determine the size of the uncompressed output with
- * no output written.  For this dest must be (unsigned char *)0.  In this case,
- * the input value of *destlen is ignored, and on return *destlen is set to the
- * size of the uncompressed output.
- *
- * The return codes are:
- *
- *   2:  available inflate data did not terminate
- *   1:  output space exhausted before completing inflate
- *   0:  successful inflate
- *  -1:  invalid block type (type == 3)
- *  -2:  stored block length did not match one's complement
- *  -3:  dynamic block code description: too many length or distance codes
- *  -4:  dynamic block code description: code lengths codes incomplete
- *  -5:  dynamic block code description: repeat lengths with no first length
- *  -6:  dynamic block code description: repeat more than specified lengths
- *  -7:  dynamic block code description: invalid literal/length code lengths
- *  -8:  dynamic block code description: invalid distance code lengths
- *  -9:  invalid literal/length or distance code in fixed or dynamic block
- * -10:  distance is too far back in fixed or dynamic block
- *
- * Format notes:
- *
- * - Three bits are read for each block to determine the kind of block and
- *   whether or not it is the last block.  Then the block is decoded and the
- *   process repeated if it was not the last block.
- *
- * - The leftover bits in the last byte of the deflate data after the last
- *   block (if it was a fixed or dynamic block) are undefined and have no
- *   expected values to check.
- */
-int puff(unsigned char *dest,           /* pointer to destination pointer */
-         unsigned long *destlen,        /* amount of output space */
-         unsigned char *source,         /* pointer to source data pointer */
-         unsigned long *sourcelen)      /* amount of input available */
-{
-    struct state s;             /* input/output state */
-    int last, type;             /* block information */
-    int err;                    /* return value */
-
-    /* initialize output state */
-    s.out = dest;
-    s.outlen = *destlen;                /* ignored if dest is NIL */
-    s.outcnt = 0;
-
-    /* initialize input state */
-    s.in = source;
-    s.inlen = *sourcelen;
-    s.incnt = 0;
-    s.bitbuf = 0;
-    s.bitcnt = 0;
-
-    /* return if bits() or decode() tries to read past available input */
-    if (setjmp(s.env) != 0)             /* if came back here via longjmp() */
-        err = 2;                        /* then skip do-loop, return error */
-    else {
-        /* process blocks until last block or error */
-        do {
-            last = bits(&s, 1);         /* one if last block */
-            type = bits(&s, 2);         /* block type 0..3 */
-            err = type == 0 ? stored(&s) :
-                  (type == 1 ? fixed(&s) :
-                   (type == 2 ? dynamic(&s) :
-                    -1));               /* type == 3, invalid */
-            if (err != 0) break;        /* return with error */
-        } while (!last);
-    }
-
-    /* update the lengths and return */
-    if (err <= 0) {
-        *destlen = s.outcnt;
-        *sourcelen = s.incnt;
-    }
-    return err;
-}
-
-#ifdef TEST
-/* Example of how to use puff() */
-#include <stdio.h>
-#include <stdlib.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-
-local unsigned char *yank(char *name, unsigned long *len)
-{
-    unsigned long size;
-    unsigned char *buf;
-    FILE *in;
-    struct stat s;
-
-    *len = 0;
-    if (stat(name, &s)) return NULL;
-    if ((s.st_mode & S_IFMT) != S_IFREG) return NULL;
-    size = (unsigned long)(s.st_size);
-    if (size == 0 || (off_t)size != s.st_size) return NULL;
-    in = fopen(name, "r");
-    if (in == NULL) return NULL;
-    buf = malloc(size);
-    if (buf != NULL && fread(buf, 1, size, in) != size) {
-        free(buf);
-        buf = NULL;
-    }
-    fclose(in);
-    *len = size;
-    return buf;
-}
-
-int main(int argc, char **argv)
-{
-    int ret;
-    unsigned char *source;
-    unsigned long len, sourcelen, destlen;
-
-    if (argc < 2) return 2;
-    source = yank(argv[1], &len);
-    if (source == NULL) return 2;
-    sourcelen = len;
-    ret = puff(NIL, &destlen, source, &sourcelen);
-    if (ret)
-        printf("puff() failed with return code %d\n", ret);
-    else {
-        printf("puff() succeeded uncompressing %lu bytes\n", destlen);
-        if (sourcelen < len) printf("%lu compressed bytes unused\n",
-                                    len - sourcelen);
-    }
-    free(source);
-    return ret;
-}
-#endif
diff -Nbaur gcc-4.6.3/zlib/contrib/puff/puff.h gcc-4.6.3-psp/zlib/contrib/puff/puff.h
--- gcc-4.6.3/zlib/contrib/puff/puff.h	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/puff/puff.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,31 +0,0 @@
-/* puff.h
-  Copyright (C) 2002, 2003 Mark Adler, all rights reserved
-  version 1.7, 3 Mar 2002
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Mark Adler    madler@alumni.caltech.edu
- */
-
-
-/*
- * See puff.c for purpose and usage.
- */
-int puff(unsigned char *dest,           /* pointer to destination pointer */
-         unsigned long *destlen,        /* amount of output space */
-         unsigned char *source,         /* pointer to source data pointer */
-         unsigned long *sourcelen);     /* amount of input available */
diff -Nbaur gcc-4.6.3/zlib/contrib/puff/README gcc-4.6.3-psp/zlib/contrib/puff/README
--- gcc-4.6.3/zlib/contrib/puff/README	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/puff/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,63 +0,0 @@
-Puff -- A Simple Inflate
-3 Mar 2003
-Mark Adler
-madler@alumni.caltech.edu
-
-What this is --
-
-puff.c provides the routine puff() to decompress the deflate data format.  It
-does so more slowly than zlib, but the code is about one-fifth the size of the
-inflate code in zlib, and written to be very easy to read.
-
-Why I wrote this --
-
-puff.c was written to document the deflate format unambiguously, by virtue of
-being working C code.  It is meant to supplement RFC 1951, which formally
-describes the deflate format.  I have received many questions on details of the
-deflate format, and I hope that reading this code will answer those questions.
-puff.c is heavily commented with details of the deflate format, especially
-those little nooks and cranies of the format that might not be obvious from a
-specification.
-
-puff.c may also be useful in applications where code size or memory usage is a
-very limited resource, and speed is not as important.
-
-How to use it --
-
-Well, most likely you should just be reading puff.c and using zlib for actual
-applications, but if you must ...
-
-Include puff.h in your code, which provides this prototype:
-
-int puff(unsigned char *dest,           /* pointer to destination pointer */
-         unsigned long *destlen,        /* amount of output space */
-         unsigned char *source,         /* pointer to source data pointer */
-         unsigned long *sourcelen);     /* amount of input available */
-
-Then you can call puff() to decompress a deflate stream that is in memory in
-its entirety at source, to a sufficiently sized block of memory for the
-decompressed data at dest.  puff() is the only external symbol in puff.c  The
-only C library functions that puff.c needs are setjmp() and longjmp(), which
-are used to simplify error checking in the code to improve readabilty.  puff.c
-does no memory allocation, and uses less than 2K bytes off of the stack.
-
-If destlen is not enough space for the uncompressed data, then inflate will
-return an error without writing more than destlen bytes.  Note that this means
-that in order to decompress the deflate data successfully, you need to know
-the size of the uncompressed data ahead of time.
-
-If needed, puff() can determine the size of the uncompressed data with no
-output space.  This is done by passing dest equal to (unsigned char *)0.  Then
-the initial value of *destlen is ignored and *destlen is set to the length of
-the uncompressed data.  So if the size of the uncompressed data is not known,
-then two passes of puff() can be used--first to determine the size, and second
-to do the actual inflation after allocating the appropriate memory.  Not
-pretty, but it works.  (This is one of the reasons you should be using zlib.)
-
-The deflate format is self-terminating.  If the deflate stream does not end
-in *sourcelen bytes, puff() will return an error without reading at or past
-endsource.
-
-On return, *sourcelen is updated to the amount of input data consumed, and
-*destlen is updated to the size of the uncompressed data.  See the comments
-in puff.c for the possible return codes for puff().
diff -Nbaur gcc-4.6.3/zlib/contrib/puff/zeros.raw gcc-4.6.3-psp/zlib/contrib/puff/zeros.raw
--- gcc-4.6.3/zlib/contrib/puff/zeros.raw	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/puff/zeros.raw	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-    S_ U                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           p
\ No newline at end of file
diff -Nbaur gcc-4.6.3/zlib/contrib/README.contrib gcc-4.6.3-psp/zlib/contrib/README.contrib
--- gcc-4.6.3/zlib/contrib/README.contrib	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/README.contrib	1970-01-01 01:00:00.000000000 +0100
@@ -1,71 +0,0 @@
-All files under this contrib directory are UNSUPPORTED. There were
-provided by users of zlib and were not tested by the authors of zlib.
-Use at your own risk. Please contact the authors of the contributions
-for help about these, not the zlib authors. Thanks.
-
-
-ada/        by Dmitriy Anisimkov <anisimkov@yahoo.com>
-        Support for Ada
-        See http://zlib-ada.sourceforge.net/
-
-asm586/
-asm686/     by Brian Raiter <breadbox@muppetlabs.com>
-        asm code for Pentium and PPro/PII, using the AT&T (GNU as) syntax
-        See http://www.muppetlabs.com/~breadbox/software/assembly.html
-
-blast/      by Mark Adler <madler@alumni.caltech.edu>
-        Decompressor for output of PKWare Data Compression Library (DCL)
-
-delphi/     by Cosmin Truta <cosmint@cs.ubbcluj.ro>
-        Support for Delphi and C++ Builder
-
-dotzlib/    by Henrik Ravn <henrik@ravn.com>
-        Support for Microsoft .Net and Visual C++ .Net
-
-infback9/   by Mark Adler <madler@alumni.caltech.edu>
-        Unsupported diffs to infback to decode the deflate64 format
-
-inflate86/  by Chris Anderson <christop@charm.net>
-        Tuned x86 gcc asm code to replace inflate_fast()
-
-iostream/   by Kevin Ruland <kevin@rodin.wustl.edu>
-        A C++ I/O streams interface to the zlib gz* functions
-
-iostream2/  by Tyge Lvset <Tyge.Lovset@cmr.no>
-        Another C++ I/O streams interface
-
-iostream3/  by Ludwig Schwardt <schwardt@sun.ac.za>
-            and Kevin Ruland <kevin@rodin.wustl.edu>
-        Yet another C++ I/O streams interface
-
-masm686/    by Dan Higdon <hdan@kinesoft.com>
-            and Chuck Walbourn <chuckw@kinesoft.com>
-        asm code for Pentium Pro/PII, using the MASM syntax
-
-masmx64/    by Gilles Vollant <info@winimage.com>
-	x86 64-bit (AMD64 and Intel EM64t) code for x64 assembler to
-	replace longest_match() and inflate_fast()
-
-masmx86/    by Gilles Vollant <info@winimage.com>
-        x86 asm code to replace longest_match() and inflate_fast(),
-        for Visual C++ and MASM
-
-minizip/    by Gilles Vollant <info@winimage.com>
-        Mini zip and unzip based on zlib
-        See http://www.winimage.com/zLibDll/unzip.html
-
-pascal/     by Bob Dellaca <bobdl@xtra.co.nz> et al.
-        Support for Pascal
-
-puff/       by Mark Adler <madler@alumni.caltech.edu>
-        Small, low memory usage inflate.  Also serves to provide an
-        unambiguous description of the deflate format.
-
-testzlib/   by Gilles Vollant <info@winimage.com>
-        Example of the use of zlib
-
-untgz/      by Pedro A. Aranda Gutierrez <paag@tid.es>
-        A very simple tar.gz file extractor using zlib
-
-vstudio/    by Gilles Vollant <info@winimage.com>
-        Building a minizip-enhanced zlib with Microsoft Visual Studio
diff -Nbaur gcc-4.6.3/zlib/contrib/testzlib/testzlib.c gcc-4.6.3-psp/zlib/contrib/testzlib/testzlib.c
--- gcc-4.6.3/zlib/contrib/testzlib/testzlib.c	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/testzlib/testzlib.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,275 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <windows.h>
-
-#include "zlib.h"
-
-
-void MyDoMinus64(LARGE_INTEGER *R,LARGE_INTEGER A,LARGE_INTEGER B)
-{
-    R->HighPart = A.HighPart - B.HighPart;
-    if (A.LowPart >= B.LowPart)
-        R->LowPart = A.LowPart - B.LowPart;
-    else
-    {
-        R->LowPart = A.LowPart - B.LowPart;
-        R->HighPart --;
-    }
-}
-
-#ifdef _M_X64
-// see http://msdn2.microsoft.com/library/twchhe95(en-us,vs.80).aspx for __rdtsc
-unsigned __int64 __rdtsc(void);
-void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)
-{
- //   printf("rdtsc = %I64x\n",__rdtsc());
-   pbeginTime64->QuadPart=__rdtsc();
-}
-
-LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)
-{
-    LARGE_INTEGER LIres;
-    unsigned _int64 res=__rdtsc()-((unsigned _int64)(beginTime64.QuadPart));
-    LIres.QuadPart=res;
-   // printf("rdtsc = %I64x\n",__rdtsc());
-    return LIres;
-}
-#else
-#ifdef _M_IX86
-void myGetRDTSC32(LARGE_INTEGER * pbeginTime64)
-{
-    DWORD dwEdx,dwEax;
-    _asm
-    {
-        rdtsc
-        mov dwEax,eax
-        mov dwEdx,edx
-    }
-    pbeginTime64->LowPart=dwEax;
-    pbeginTime64->HighPart=dwEdx;
-}
-
-void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)
-{
-    myGetRDTSC32(pbeginTime64);
-}
-
-LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)
-{
-    LARGE_INTEGER LIres,endTime64;
-    myGetRDTSC32(&endTime64);
-
-    LIres.LowPart=LIres.HighPart=0;
-    MyDoMinus64(&LIres,endTime64,beginTime64);
-    return LIres;
-}
-#else
-void myGetRDTSC32(LARGE_INTEGER * pbeginTime64)
-{
-}
-
-void BeginCountRdtsc(LARGE_INTEGER * pbeginTime64)
-{
-}
-
-LARGE_INTEGER GetResRdtsc(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)
-{
-    LARGE_INTEGER lr;
-    lr.QuadPart=0;
-    return lr;
-}
-#endif
-#endif
-
-void BeginCountPerfCounter(LARGE_INTEGER * pbeginTime64,BOOL fComputeTimeQueryPerf)
-{
-    if ((!fComputeTimeQueryPerf) || (!QueryPerformanceCounter(pbeginTime64)))
-    {
-        pbeginTime64->LowPart = GetTickCount();
-        pbeginTime64->HighPart = 0;
-    }
-}
-
-DWORD GetMsecSincePerfCounter(LARGE_INTEGER beginTime64,BOOL fComputeTimeQueryPerf)
-{
-    LARGE_INTEGER endTime64,ticksPerSecond,ticks;
-    DWORDLONG ticksShifted,tickSecShifted;
-    DWORD dwLog=16+0;
-    DWORD dwRet;
-    if ((!fComputeTimeQueryPerf) || (!QueryPerformanceCounter(&endTime64)))
-        dwRet = (GetTickCount() - beginTime64.LowPart)*1;
-    else
-    {
-        MyDoMinus64(&ticks,endTime64,beginTime64);
-        QueryPerformanceFrequency(&ticksPerSecond);
-
-    
-        {
-            ticksShifted = Int64ShrlMod32(*(DWORDLONG*)&ticks,dwLog);
-            tickSecShifted = Int64ShrlMod32(*(DWORDLONG*)&ticksPerSecond,dwLog);
-        
-        } 
-
-        dwRet = (DWORD)((((DWORD)ticksShifted)*1000)/(DWORD)(tickSecShifted));
-        dwRet *=1;
-    }
-    return dwRet;
-}
-
-int ReadFileMemory(const char* filename,long* plFileSize,void** pFilePtr)
-{
-    FILE* stream;
-    void* ptr;
-    int retVal=1;
-    stream=fopen(filename, "rb");
-    if (stream==NULL)
-        return 0;
-
-    fseek(stream,0,SEEK_END);
-
-    *plFileSize=ftell(stream);
-    fseek(stream,0,SEEK_SET);
-    ptr=malloc((*plFileSize)+1);
-    if (ptr==NULL)
-        retVal=0;
-    else
-    {
-        if (fread(ptr, 1, *plFileSize,stream) != (*plFileSize))
-            retVal=0;
-    }
-    fclose(stream);
-    *pFilePtr=ptr;
-    return retVal;
-}
-
-int main(int argc, char *argv[])
-{
-    int BlockSizeCompress=0x8000;
-    int BlockSizeUncompress=0x8000;
-    int cprLevel=Z_DEFAULT_COMPRESSION ;
-    long lFileSize;
-    unsigned char* FilePtr;
-    long lBufferSizeCpr;
-    long lBufferSizeUncpr;
-    long lCompressedSize=0;
-    unsigned char* CprPtr;
-    unsigned char* UncprPtr;
-    long lSizeCpr,lSizeUncpr;
-    DWORD dwGetTick,dwMsecQP;
-    LARGE_INTEGER li_qp,li_rdtsc,dwResRdtsc;
-
-    if (argc<=1)
-    {
-        printf("run TestZlib <File> [BlockSizeCompress] [BlockSizeUncompress] [compres. level]\n");
-        return 0;
-    }
-
-    if (ReadFileMemory(argv[1],&lFileSize,&FilePtr)==0)
-    {
-        printf("error reading %s\n",argv[1]);
-        return 1;
-    }
-    else printf("file %s read, %u bytes\n",argv[1],lFileSize);
-
-    if (argc>=3)
-        BlockSizeCompress=atol(argv[2]);
-
-    if (argc>=4)
-        BlockSizeUncompress=atol(argv[3]);
-
-    if (argc>=5)
-        cprLevel=(int)atol(argv[4]);
-
-    lBufferSizeCpr = lFileSize + (lFileSize/0x10) + 0x200;
-    lBufferSizeUncpr = lBufferSizeCpr;
-
-    CprPtr=(unsigned char*)malloc(lBufferSizeCpr + BlockSizeCompress);
-
-    BeginCountPerfCounter(&li_qp,TRUE);
-    dwGetTick=GetTickCount();
-    BeginCountRdtsc(&li_rdtsc);
-    {
-        z_stream zcpr;
-        int ret=Z_OK;
-        long lOrigToDo = lFileSize;
-        long lOrigDone = 0;
-        int step=0;
-        memset(&zcpr,0,sizeof(z_stream));
-        deflateInit(&zcpr,cprLevel);
-
-        zcpr.next_in = FilePtr;
-        zcpr.next_out = CprPtr;
-
-
-        do
-        {
-            long all_read_before = zcpr.total_in;
-            zcpr.avail_in = min(lOrigToDo,BlockSizeCompress);
-            zcpr.avail_out = BlockSizeCompress;
-            ret=deflate(&zcpr,(zcpr.avail_in==lOrigToDo) ? Z_FINISH : Z_SYNC_FLUSH);
-            lOrigDone += (zcpr.total_in-all_read_before);
-            lOrigToDo -= (zcpr.total_in-all_read_before);
-            step++;
-        } while (ret==Z_OK);
-
-        lSizeCpr=zcpr.total_out;
-        deflateEnd(&zcpr);
-        dwGetTick=GetTickCount()-dwGetTick;
-        dwMsecQP=GetMsecSincePerfCounter(li_qp,TRUE);
-        dwResRdtsc=GetResRdtsc(li_rdtsc,TRUE);
-        printf("total compress size = %u, in %u step\n",lSizeCpr,step);
-        printf("time = %u msec = %f sec\n",dwGetTick,dwGetTick/(double)1000.);
-        printf("defcpr time QP = %u msec = %f sec\n",dwMsecQP,dwMsecQP/(double)1000.);
-        printf("defcpr result rdtsc = %I64x\n\n",dwResRdtsc.QuadPart);
-    }
-
-    CprPtr=(unsigned char*)realloc(CprPtr,lSizeCpr);
-    UncprPtr=(unsigned char*)malloc(lBufferSizeUncpr + BlockSizeUncompress);
-
-    BeginCountPerfCounter(&li_qp,TRUE);
-    dwGetTick=GetTickCount();
-    BeginCountRdtsc(&li_rdtsc);
-    {
-        z_stream zcpr;
-        int ret=Z_OK;
-        long lOrigToDo = lSizeCpr;
-        long lOrigDone = 0;
-        int step=0;
-        memset(&zcpr,0,sizeof(z_stream));
-        inflateInit(&zcpr);
-
-        zcpr.next_in = CprPtr;
-        zcpr.next_out = UncprPtr;
-
-
-        do
-        {
-            long all_read_before = zcpr.total_in;
-            zcpr.avail_in = min(lOrigToDo,BlockSizeUncompress);
-            zcpr.avail_out = BlockSizeUncompress;
-            ret=inflate(&zcpr,Z_SYNC_FLUSH);
-            lOrigDone += (zcpr.total_in-all_read_before);
-            lOrigToDo -= (zcpr.total_in-all_read_before);
-            step++;
-        } while (ret==Z_OK);
-
-        lSizeUncpr=zcpr.total_out;
-        inflateEnd(&zcpr);
-        dwGetTick=GetTickCount()-dwGetTick;
-        dwMsecQP=GetMsecSincePerfCounter(li_qp,TRUE);
-        dwResRdtsc=GetResRdtsc(li_rdtsc,TRUE);
-        printf("total uncompress size = %u, in %u step\n",lSizeUncpr,step);
-        printf("time = %u msec = %f sec\n",dwGetTick,dwGetTick/(double)1000.);
-        printf("uncpr  time QP = %u msec = %f sec\n",dwMsecQP,dwMsecQP/(double)1000.);
-        printf("uncpr  result rdtsc = %I64x\n\n",dwResRdtsc.QuadPart);
-    }
-
-    if (lSizeUncpr==lFileSize)
-    {
-        if (memcmp(FilePtr,UncprPtr,lFileSize)==0)
-            printf("compare ok\n");
-
-    }
-
-    return 0;
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/testzlib/testzlib.txt gcc-4.6.3-psp/zlib/contrib/testzlib/testzlib.txt
--- gcc-4.6.3/zlib/contrib/testzlib/testzlib.txt	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/testzlib/testzlib.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,10 +0,0 @@
-To build testzLib with Visual Studio 2005:
-
-copy to a directory file from :
-- root of zLib tree
-- contrib/testzlib
-- contrib/masmx86
-- contrib/masmx64
-- contrib/vstudio/vc7
-
-and open testzlib8.sln
\ No newline at end of file
diff -Nbaur gcc-4.6.3/zlib/contrib/untgz/Makefile gcc-4.6.3-psp/zlib/contrib/untgz/Makefile
--- gcc-4.6.3/zlib/contrib/untgz/Makefile	2004-10-11 19:45:43.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/untgz/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,14 +0,0 @@
-CC=cc
-CFLAGS=-g
-
-untgz: untgz.o ../../libz.a
-	$(CC) $(CFLAGS) -o untgz untgz.o -L../.. -lz
-
-untgz.o: untgz.c ../../zlib.h
-	$(CC) $(CFLAGS) -c -I../.. untgz.c
-
-../../libz.a:
-	cd ../..; ./configure; make
-
-clean:
-	rm -f untgz untgz.o *~
diff -Nbaur gcc-4.6.3/zlib/contrib/untgz/Makefile.msc gcc-4.6.3-psp/zlib/contrib/untgz/Makefile.msc
--- gcc-4.6.3/zlib/contrib/untgz/Makefile.msc	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/untgz/Makefile.msc	1970-01-01 01:00:00.000000000 +0100
@@ -1,17 +0,0 @@
-CC=cl
-CFLAGS=-MD
-
-untgz.exe: untgz.obj ..\..\zlib.lib
-	$(CC) $(CFLAGS) untgz.obj ..\..\zlib.lib
-
-untgz.obj: untgz.c ..\..\zlib.h
-	$(CC) $(CFLAGS) -c -I..\.. untgz.c
-
-..\..\zlib.lib:
-	cd ..\..
-	$(MAKE) -f win32\makefile.msc
-	cd contrib\untgz
-
-clean:
-	-del untgz.obj
-	-del untgz.exe
diff -Nbaur gcc-4.6.3/zlib/contrib/untgz/untgz.c gcc-4.6.3-psp/zlib/contrib/untgz/untgz.c
--- gcc-4.6.3/zlib/contrib/untgz/untgz.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/untgz/untgz.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,674 +0,0 @@
-/*
- * untgz.c -- Display contents and extract files from a gzip'd TAR file
- *
- * written by Pedro A. Aranda Gutierrez <paag@tid.es>
- * adaptation to Unix by Jean-loup Gailly <jloup@gzip.org>
- * various fixes by Cosmin Truta <cosmint@cs.ubbcluj.ro>
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <errno.h>
-
-#include "zlib.h"
-
-#ifdef unix
-#  include <unistd.h>
-#else
-#  include <direct.h>
-#  include <io.h>
-#endif
-
-#ifdef WIN32
-#include <windows.h>
-#  ifndef F_OK
-#    define F_OK  0
-#  endif
-#  define mkdir(dirname,mode)   _mkdir(dirname)
-#  ifdef _MSC_VER
-#    define access(path,mode)   _access(path,mode)
-#    define chmod(path,mode)    _chmod(path,mode)
-#    define strdup(str)         _strdup(str)
-#  endif
-#else
-#  include <utime.h>
-#endif
-
-
-/* values used in typeflag field */
-
-#define REGTYPE  '0'            /* regular file */
-#define AREGTYPE '\0'           /* regular file */
-#define LNKTYPE  '1'            /* link */
-#define SYMTYPE  '2'            /* reserved */
-#define CHRTYPE  '3'            /* character special */
-#define BLKTYPE  '4'            /* block special */
-#define DIRTYPE  '5'            /* directory */
-#define FIFOTYPE '6'            /* FIFO special */
-#define CONTTYPE '7'            /* reserved */
-
-/* GNU tar extensions */
-
-#define GNUTYPE_DUMPDIR  'D'    /* file names from dumped directory */
-#define GNUTYPE_LONGLINK 'K'    /* long link name */
-#define GNUTYPE_LONGNAME 'L'    /* long file name */
-#define GNUTYPE_MULTIVOL 'M'    /* continuation of file from another volume */
-#define GNUTYPE_NAMES    'N'    /* file name that does not fit into main hdr */
-#define GNUTYPE_SPARSE   'S'    /* sparse file */
-#define GNUTYPE_VOLHDR   'V'    /* tape/volume header */
-
-
-/* tar header */
-
-#define BLOCKSIZE     512
-#define SHORTNAMESIZE 100
-
-struct tar_header
-{                               /* byte offset */
-  char name[100];               /*   0 */
-  char mode[8];                 /* 100 */
-  char uid[8];                  /* 108 */
-  char gid[8];                  /* 116 */
-  char size[12];                /* 124 */
-  char mtime[12];               /* 136 */
-  char chksum[8];               /* 148 */
-  char typeflag;                /* 156 */
-  char linkname[100];           /* 157 */
-  char magic[6];                /* 257 */
-  char version[2];              /* 263 */
-  char uname[32];               /* 265 */
-  char gname[32];               /* 297 */
-  char devmajor[8];             /* 329 */
-  char devminor[8];             /* 337 */
-  char prefix[155];             /* 345 */
-                                /* 500 */
-};
-
-union tar_buffer
-{
-  char               buffer[BLOCKSIZE];
-  struct tar_header  header;
-};
-
-struct attr_item
-{
-  struct attr_item  *next;
-  char              *fname;
-  int                mode;
-  time_t             time;
-};
-
-enum { TGZ_EXTRACT, TGZ_LIST, TGZ_INVALID };
-
-char *TGZfname          OF((const char *));
-void TGZnotfound        OF((const char *));
-
-int getoct              OF((char *, int));
-char *strtime           OF((time_t *));
-int setfiletime         OF((char *, time_t));
-void push_attr          OF((struct attr_item **, char *, int, time_t));
-void restore_attr       OF((struct attr_item **));
-
-int ExprMatch           OF((char *, char *));
-
-int makedir             OF((char *));
-int matchname           OF((int, int, char **, char *));
-
-void error              OF((const char *));
-int tar                 OF((gzFile, int, int, int, char **));
-
-void help               OF((int));
-int main                OF((int, char **));
-
-char *prog;
-
-const char *TGZsuffix[] = { "\0", ".tar", ".tar.gz", ".taz", ".tgz", NULL };
-
-/* return the file name of the TGZ archive */
-/* or NULL if it does not exist */
-
-char *TGZfname (const char *arcname)
-{
-  static char buffer[1024];
-  int origlen,i;
-
-  strcpy(buffer,arcname);
-  origlen = strlen(buffer);
-
-  for (i=0; TGZsuffix[i]; i++)
-    {
-       strcpy(buffer+origlen,TGZsuffix[i]);
-       if (access(buffer,F_OK) == 0)
-         return buffer;
-    }
-  return NULL;
-}
-
-
-/* error message for the filename */
-
-void TGZnotfound (const char *arcname)
-{
-  int i;
-
-  fprintf(stderr,"%s: Couldn't find ",prog);
-  for (i=0;TGZsuffix[i];i++)
-    fprintf(stderr,(TGZsuffix[i+1]) ? "%s%s, " : "or %s%s\n",
-            arcname,
-            TGZsuffix[i]);
-  exit(1);
-}
-
-
-/* convert octal digits to int */
-/* on error return -1 */
-
-int getoct (char *p,int width)
-{
-  int result = 0;
-  char c;
-
-  while (width--)
-    {
-      c = *p++;
-      if (c == 0)
-        break;
-      if (c == ' ')
-        continue;
-      if (c < '0' || c > '7')
-        return -1;
-      result = result * 8 + (c - '0');
-    }
-  return result;
-}
-
-
-/* convert time_t to string */
-/* use the "YYYY/MM/DD hh:mm:ss" format */
-
-char *strtime (time_t *t)
-{
-  struct tm   *local;
-  static char result[32];
-
-  local = localtime(t);
-  sprintf(result,"%4d/%02d/%02d %02d:%02d:%02d",
-          local->tm_year+1900, local->tm_mon+1, local->tm_mday,
-          local->tm_hour, local->tm_min, local->tm_sec);
-  return result;
-}
-
-
-/* set file time */
-
-int setfiletime (char *fname,time_t ftime)
-{
-#ifdef WIN32
-  static int isWinNT = -1;
-  SYSTEMTIME st;
-  FILETIME locft, modft;
-  struct tm *loctm;
-  HANDLE hFile;
-  int result;
-
-  loctm = localtime(&ftime);
-  if (loctm == NULL)
-    return -1;
-
-  st.wYear         = (WORD)loctm->tm_year + 1900;
-  st.wMonth        = (WORD)loctm->tm_mon + 1;
-  st.wDayOfWeek    = (WORD)loctm->tm_wday;
-  st.wDay          = (WORD)loctm->tm_mday;
-  st.wHour         = (WORD)loctm->tm_hour;
-  st.wMinute       = (WORD)loctm->tm_min;
-  st.wSecond       = (WORD)loctm->tm_sec;
-  st.wMilliseconds = 0;
-  if (!SystemTimeToFileTime(&st, &locft) ||
-      !LocalFileTimeToFileTime(&locft, &modft))
-    return -1;
-
-  if (isWinNT < 0)
-    isWinNT = (GetVersion() < 0x80000000) ? 1 : 0;
-  hFile = CreateFile(fname, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
-                     (isWinNT ? FILE_FLAG_BACKUP_SEMANTICS : 0),
-                     NULL);
-  if (hFile == INVALID_HANDLE_VALUE)
-    return -1;
-  result = SetFileTime(hFile, NULL, NULL, &modft) ? 0 : -1;
-  CloseHandle(hFile);
-  return result;
-#else
-  struct utimbuf settime;
-
-  settime.actime = settime.modtime = ftime;
-  return utime(fname,&settime);
-#endif
-}
-
-
-/* push file attributes */
-
-void push_attr(struct attr_item **list,char *fname,int mode,time_t time)
-{
-  struct attr_item *item;
-
-  item = (struct attr_item *)malloc(sizeof(struct attr_item));
-  if (item == NULL)
-    error("Out of memory");
-  item->fname = strdup(fname);
-  item->mode  = mode;
-  item->time  = time;
-  item->next  = *list;
-  *list       = item;
-}
-
-
-/* restore file attributes */
-
-void restore_attr(struct attr_item **list)
-{
-  struct attr_item *item, *prev;
-
-  for (item = *list; item != NULL; )
-    {
-      setfiletime(item->fname,item->time);
-      chmod(item->fname,item->mode);
-      prev = item;
-      item = item->next;
-      free(prev);
-    }
-  *list = NULL;
-}
-
-
-/* match regular expression */
-
-#define ISSPECIAL(c) (((c) == '*') || ((c) == '/'))
-
-int ExprMatch (char *string,char *expr)
-{
-  while (1)
-    {
-      if (ISSPECIAL(*expr))
-        {
-          if (*expr == '/')
-            {
-              if (*string != '\\' && *string != '/')
-                return 0;
-              string ++; expr++;
-            }
-          else if (*expr == '*')
-            {
-              if (*expr ++ == 0)
-                return 1;
-              while (*++string != *expr)
-                if (*string == 0)
-                  return 0;
-            }
-        }
-      else
-        {
-          if (*string != *expr)
-            return 0;
-          if (*expr++ == 0)
-            return 1;
-          string++;
-        }
-    }
-}
-
-
-/* recursive mkdir */
-/* abort on ENOENT; ignore other errors like "directory already exists" */
-/* return 1 if OK */
-/*        0 on error */
-
-int makedir (char *newdir)
-{
-  char *buffer = strdup(newdir);
-  char *p;
-  int  len = strlen(buffer);
-
-  if (len <= 0) {
-    free(buffer);
-    return 0;
-  }
-  if (buffer[len-1] == '/') {
-    buffer[len-1] = '\0';
-  }
-  if (mkdir(buffer, 0755) == 0)
-    {
-      free(buffer);
-      return 1;
-    }
-
-  p = buffer+1;
-  while (1)
-    {
-      char hold;
-
-      while(*p && *p != '\\' && *p != '/')
-        p++;
-      hold = *p;
-      *p = 0;
-      if ((mkdir(buffer, 0755) == -1) && (errno == ENOENT))
-        {
-          fprintf(stderr,"%s: Couldn't create directory %s\n",prog,buffer);
-          free(buffer);
-          return 0;
-        }
-      if (hold == 0)
-        break;
-      *p++ = hold;
-    }
-  free(buffer);
-  return 1;
-}
-
-
-int matchname (int arg,int argc,char **argv,char *fname)
-{
-  if (arg == argc)      /* no arguments given (untgz tgzarchive) */
-    return 1;
-
-  while (arg < argc)
-    if (ExprMatch(fname,argv[arg++]))
-      return 1;
-
-  return 0; /* ignore this for the moment being */
-}
-
-
-/* tar file list or extract */
-
-int tar (gzFile in,int action,int arg,int argc,char **argv)
-{
-  union  tar_buffer buffer;
-  int    len;
-  int    err;
-  int    getheader = 1;
-  int    remaining = 0;
-  FILE   *outfile = NULL;
-  char   fname[BLOCKSIZE];
-  int    tarmode;
-  time_t tartime;
-  struct attr_item *attributes = NULL;
-
-  if (action == TGZ_LIST)
-    printf("    date      time     size                       file\n"
-           " ---------- -------- --------- -------------------------------------\n");
-  while (1)
-    {
-      len = gzread(in, &buffer, BLOCKSIZE);
-      if (len < 0)
-        error(gzerror(in, &err));
-      /*
-       * Always expect complete blocks to process
-       * the tar information.
-       */
-      if (len != BLOCKSIZE)
-        {
-          action = TGZ_INVALID; /* force error exit */
-          remaining = 0;        /* force I/O cleanup */
-        }
-
-      /*
-       * If we have to get a tar header
-       */
-      if (getheader >= 1)
-        {
-          /*
-           * if we met the end of the tar
-           * or the end-of-tar block,
-           * we are done
-           */
-          if (len == 0 || buffer.header.name[0] == 0)
-            break;
-
-          tarmode = getoct(buffer.header.mode,8);
-          tartime = (time_t)getoct(buffer.header.mtime,12);
-          if (tarmode == -1 || tartime == (time_t)-1)
-            {
-              buffer.header.name[0] = 0;
-              action = TGZ_INVALID;
-            }
-
-          if (getheader == 1)
-            {
-              strncpy(fname,buffer.header.name,SHORTNAMESIZE);
-              if (fname[SHORTNAMESIZE-1] != 0)
-                  fname[SHORTNAMESIZE] = 0;
-            }
-          else
-            {
-              /*
-               * The file name is longer than SHORTNAMESIZE
-               */
-              if (strncmp(fname,buffer.header.name,SHORTNAMESIZE-1) != 0)
-                  error("bad long name");
-              getheader = 1;
-            }
-
-          /*
-           * Act according to the type flag
-           */
-          switch (buffer.header.typeflag)
-            {
-            case DIRTYPE:
-              if (action == TGZ_LIST)
-                printf(" %s     <dir> %s\n",strtime(&tartime),fname);
-              if (action == TGZ_EXTRACT)
-                {
-                  makedir(fname);
-                  push_attr(&attributes,fname,tarmode,tartime);
-                }
-              break;
-            case REGTYPE:
-            case AREGTYPE:
-              remaining = getoct(buffer.header.size,12);
-              if (remaining == -1)
-                {
-                  action = TGZ_INVALID;
-                  break;
-                }
-              if (action == TGZ_LIST)
-                printf(" %s %9d %s\n",strtime(&tartime),remaining,fname);
-              else if (action == TGZ_EXTRACT)
-                {
-                  if (matchname(arg,argc,argv,fname))
-                    {
-                      outfile = fopen(fname,"wb");
-                      if (outfile == NULL) {
-                        /* try creating directory */
-                        char *p = strrchr(fname, '/');
-                        if (p != NULL) {
-                          *p = '\0';
-                          makedir(fname);
-                          *p = '/';
-                          outfile = fopen(fname,"wb");
-                        }
-                      }
-                      if (outfile != NULL)
-                        printf("Extracting %s\n",fname);
-                      else
-                        fprintf(stderr, "%s: Couldn't create %s",prog,fname);
-                    }
-                  else
-                    outfile = NULL;
-                }
-              getheader = 0;
-              break;
-            case GNUTYPE_LONGLINK:
-            case GNUTYPE_LONGNAME:
-              remaining = getoct(buffer.header.size,12);
-              if (remaining < 0 || remaining >= BLOCKSIZE)
-                {
-                  action = TGZ_INVALID;
-                  break;
-                }
-              len = gzread(in, fname, BLOCKSIZE);
-              if (len < 0)
-                error(gzerror(in, &err));
-              if (fname[BLOCKSIZE-1] != 0 || (int)strlen(fname) > remaining)
-                {
-                  action = TGZ_INVALID;
-                  break;
-                }
-              getheader = 2;
-              break;
-            default:
-              if (action == TGZ_LIST)
-                printf(" %s     <---> %s\n",strtime(&tartime),fname);
-              break;
-            }
-        }
-      else
-        {
-          unsigned int bytes = (remaining > BLOCKSIZE) ? BLOCKSIZE : remaining;
-
-          if (outfile != NULL)
-            {
-              if (fwrite(&buffer,sizeof(char),bytes,outfile) != bytes)
-                {
-                  fprintf(stderr,
-                    "%s: Error writing %s -- skipping\n",prog,fname);
-                  fclose(outfile);
-                  outfile = NULL;
-                  remove(fname);
-                }
-            }
-          remaining -= bytes;
-        }
-
-      if (remaining == 0)
-        {
-          getheader = 1;
-          if (outfile != NULL)
-            {
-              fclose(outfile);
-              outfile = NULL;
-              if (action != TGZ_INVALID)
-                push_attr(&attributes,fname,tarmode,tartime);
-            }
-        }
-
-      /*
-       * Abandon if errors are found
-       */
-      if (action == TGZ_INVALID)
-        {
-          error("broken archive");
-          break;
-        }
-    }
-
-  /*
-   * Restore file modes and time stamps
-   */
-  restore_attr(&attributes);
-
-  if (gzclose(in) != Z_OK)
-    error("failed gzclose");
-
-  return 0;
-}
-
-
-/* ============================================================ */
-
-void help(int exitval)
-{
-  printf("untgz version 0.2.1\n"
-         "  using zlib version %s\n\n",
-         zlibVersion());
-  printf("Usage: untgz file.tgz            extract all files\n"
-         "       untgz file.tgz fname ...  extract selected files\n"
-         "       untgz -l file.tgz         list archive contents\n"
-         "       untgz -h                  display this help\n");
-  exit(exitval);
-}
-
-void error(const char *msg)
-{
-  fprintf(stderr, "%s: %s\n", prog, msg);
-  exit(1);
-}
-
-
-/* ============================================================ */
-
-#if defined(WIN32) && defined(__GNUC__)
-int _CRT_glob = 0;      /* disable argument globbing in MinGW */
-#endif
-
-int main(int argc,char **argv)
-{
-    int         action = TGZ_EXTRACT;
-    int         arg = 1;
-    char        *TGZfile;
-    gzFile      *f;
-
-    prog = strrchr(argv[0],'\\');
-    if (prog == NULL)
-      {
-        prog = strrchr(argv[0],'/');
-        if (prog == NULL)
-          {
-            prog = strrchr(argv[0],':');
-            if (prog == NULL)
-              prog = argv[0];
-            else
-              prog++;
-          }
-        else
-          prog++;
-      }
-    else
-      prog++;
-
-    if (argc == 1)
-      help(0);
-
-    if (strcmp(argv[arg],"-l") == 0)
-      {
-        action = TGZ_LIST;
-        if (argc == ++arg)
-          help(0);
-      }
-    else if (strcmp(argv[arg],"-h") == 0)
-      {
-        help(0);
-      }
-
-    if ((TGZfile = TGZfname(argv[arg])) == NULL)
-      TGZnotfound(argv[arg]);
-
-    ++arg;
-    if ((action == TGZ_LIST) && (arg != argc))
-      help(1);
-
-/*
- *  Process the TGZ file
- */
-    switch(action)
-      {
-      case TGZ_LIST:
-      case TGZ_EXTRACT:
-        f = gzopen(TGZfile,"rb");
-        if (f == NULL)
-          {
-            fprintf(stderr,"%s: Couldn't gzopen %s\n",prog,TGZfile);
-            return 1;
-          }
-        exit(tar(f, action, arg, argc, argv));
-      break;
-
-      default:
-        error("Unknown option");
-        exit(1);
-      }
-
-    return 0;
-}
diff -Nbaur gcc-4.6.3/zlib/contrib/vstudio/readme.txt gcc-4.6.3-psp/zlib/contrib/vstudio/readme.txt
--- gcc-4.6.3/zlib/contrib/vstudio/readme.txt	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/vstudio/readme.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,73 +0,0 @@
-Building instructions for the DLL versions of Zlib 1.2.3
-========================================================
-
-This directory contains projects that build zlib and minizip using
-Microsoft Visual C++ 7.0/7.1, and Visual C++ .
-
-You don't need to build these projects yourself. You can download the
-binaries from:
-  http://www.winimage.com/zLibDll
-
-More information can be found at this site.
-
-
-Build instructions for Visual Studio 7.x (32 bits)
---------------------------------------------------
-- Uncompress current zlib, including all contrib/* files
-- Download the crtdll library from
-    http://www.winimage.com/zLibDll/crtdll.zip
-  Unzip crtdll.zip to extract crtdll.lib on contrib\vstudio\vc7.
-- Open contrib\vstudio\vc7\zlibvc.sln with Microsoft Visual C++ 7.x
-  (Visual Studio .Net 2002 or 2003).
-
-Build instructions for Visual Studio 2005 (32 bits or 64 bits)
---------------------------------------------------------------
-- Uncompress current zlib, including all contrib/* files
-- For 32 bits only: download the crtdll library from
-    http://www.winimage.com/zLibDll/crtdll.zip
-  Unzip crtdll.zip to extract crtdll.lib on contrib\vstudio\vc8.
-- Open contrib\vstudio\vc8\zlibvc.sln with Microsoft Visual C++ 8.0
-
-Build instructions for Visual Studio 2005 64 bits, PSDK compiler
-----------------------------------------------------------------
-at the time of writing this text file, Visual Studio 2005 (and 
-  Microsoft Visual C++ 8.0) is on the beta 2 stage.
-Using you can get the free 64 bits compiler from Platform SDK, 
-  which is NOT a beta, and compile using the Visual studio 2005 IDE
-see http://www.winimage.com/misc/sdk64onvs2005/ for instruction
-
-- Uncompress current zlib, including all contrib/* files
-- start Visual Studio 2005 from a platform SDK command prompt, using
-  the /useenv switch
-- Open contrib\vstudio\vc8\zlibvc.sln with Microsoft Visual C++ 8.0
-
-
-Important
----------
-- To use zlibwapi.dll in your application, you must define the
-  macro ZLIB_WINAPI when compiling your application's source files.
-
-
-Additional notes
-----------------
-- This DLL, named zlibwapi.dll, is compatible to the old zlib.dll built
-  by Gilles Vollant from the zlib 1.1.x sources, and distributed at
-    http://www.winimage.com/zLibDll
-  It uses the WINAPI calling convention for the exported functions, and
-  includes the minizip functionality. If your application needs that
-  particular build of zlib.dll, you can rename zlibwapi.dll to zlib.dll.
-
-- The new DLL was renamed because there exist several incompatible
-  versions of zlib.dll on the Internet.
-
-- There is also an official DLL build of zlib, named zlib1.dll. This one
-  is exporting the functions using the CDECL convention. See the file
-  win32\DLL_FAQ.txt found in this zlib distribution.
-
-- There used to be a ZLIB_DLL macro in zlib 1.1.x, but now this symbol
-  has a slightly different effect. To avoid compatibility problems, do
-  not define it here.
-
-
-Gilles Vollant
-info@winimage.com
diff -Nbaur gcc-4.6.3/zlib/contrib/vstudio/vc7/miniunz.vcproj gcc-4.6.3-psp/zlib/contrib/vstudio/vc7/miniunz.vcproj
--- gcc-4.6.3/zlib/contrib/vstudio/vc7/miniunz.vcproj	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/vstudio/vc7/miniunz.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,126 +0,0 @@
-<?xml version="1.0" encoding = "Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="7.00"
-	Name="miniunz"
-	ProjectGUID="{C52F9E7B-498A-42BE-8DB4-85A15694382A}"
-	Keyword="Win32Proj">
-	<Platforms>
-		<Platform
-			Name="Win32"/>
-	</Platforms>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="Debug"
-			IntermediateDirectory="Debug"
-			ConfigurationType="1"
-			CharacterSet="2">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI;_DEBUG;_CONSOLE"
-				MinimalRebuild="TRUE"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="5"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="TRUE"
-				DebugInformationFormat="4"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)/miniunz.exe"
-				LinkIncremental="2"
-				GenerateDebugInformation="TRUE"
-				ProgramDatabaseFile="$(OutDir)/miniunz.pdb"
-				SubSystem="1"
-				TargetMachine="1"/>
-			<Tool
-				Name="VCMIDLTool"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCWebDeploymentTool"/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="Release"
-			IntermediateDirectory="Release"
-			ConfigurationType="1"
-			CharacterSet="2">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="TRUE"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE"
-				StringPooling="TRUE"
-				RuntimeLibrary="4"
-				EnableFunctionLevelLinking="TRUE"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="TRUE"
-				DebugInformationFormat="3"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)/miniunz.exe"
-				LinkIncremental="1"
-				GenerateDebugInformation="TRUE"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="1"/>
-			<Tool
-				Name="VCMIDLTool"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCWebDeploymentTool"/>
-		</Configuration>
-	</Configurations>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm">
-			<File
-				RelativePath="..\..\minizip\miniunz.c">
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc">
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe">
-		</Filter>
-		<File
-			RelativePath="ReleaseDll\zlibwapi.lib">
-		</File>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nbaur gcc-4.6.3/zlib/contrib/vstudio/vc7/minizip.vcproj gcc-4.6.3-psp/zlib/contrib/vstudio/vc7/minizip.vcproj
--- gcc-4.6.3/zlib/contrib/vstudio/vc7/minizip.vcproj	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/vstudio/vc7/minizip.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,126 +0,0 @@
-<?xml version="1.0" encoding = "Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="7.00"
-	Name="minizip"
-	ProjectGUID="{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}"
-	Keyword="Win32Proj">
-	<Platforms>
-		<Platform
-			Name="Win32"/>
-	</Platforms>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="Debug"
-			IntermediateDirectory="Debug"
-			ConfigurationType="1"
-			CharacterSet="2">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI;_DEBUG;_CONSOLE"
-				MinimalRebuild="TRUE"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="5"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="TRUE"
-				DebugInformationFormat="4"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)/minizip.exe"
-				LinkIncremental="2"
-				GenerateDebugInformation="TRUE"
-				ProgramDatabaseFile="$(OutDir)/minizip.pdb"
-				SubSystem="1"
-				TargetMachine="1"/>
-			<Tool
-				Name="VCMIDLTool"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCWebDeploymentTool"/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="Release"
-			IntermediateDirectory="Release"
-			ConfigurationType="1"
-			CharacterSet="2">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="TRUE"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE"
-				StringPooling="TRUE"
-				RuntimeLibrary="4"
-				EnableFunctionLevelLinking="TRUE"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="TRUE"
-				DebugInformationFormat="3"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)/minizip.exe"
-				LinkIncremental="1"
-				GenerateDebugInformation="TRUE"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="1"/>
-			<Tool
-				Name="VCMIDLTool"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCWebDeploymentTool"/>
-		</Configuration>
-	</Configurations>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm">
-			<File
-				RelativePath="..\..\minizip\minizip.c">
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc">
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe">
-		</Filter>
-		<File
-			RelativePath="ReleaseDll\zlibwapi.lib">
-		</File>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nbaur gcc-4.6.3/zlib/contrib/vstudio/vc7/testzlib.vcproj gcc-4.6.3-psp/zlib/contrib/vstudio/vc7/testzlib.vcproj
--- gcc-4.6.3/zlib/contrib/vstudio/vc7/testzlib.vcproj	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/vstudio/vc7/testzlib.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,126 +0,0 @@
-<?xml version="1.0" encoding = "Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="7.00"
-	Name="testZlibDll"
-	ProjectGUID="{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}"
-	Keyword="Win32Proj">
-	<Platforms>
-		<Platform
-			Name="Win32"/>
-	</Platforms>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="Debug"
-			IntermediateDirectory="Debug"
-			ConfigurationType="1"
-			CharacterSet="2">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI;_DEBUG;_CONSOLE"
-				MinimalRebuild="TRUE"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="5"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="TRUE"
-				DebugInformationFormat="4"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="2"
-				GenerateDebugInformation="TRUE"
-				ProgramDatabaseFile="$(OutDir)/testzlib.pdb"
-				SubSystem="1"
-				TargetMachine="1"/>
-			<Tool
-				Name="VCMIDLTool"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCWebDeploymentTool"/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="Release"
-			IntermediateDirectory="Release"
-			ConfigurationType="1"
-			CharacterSet="2">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="TRUE"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE"
-				StringPooling="TRUE"
-				RuntimeLibrary="4"
-				EnableFunctionLevelLinking="TRUE"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="TRUE"
-				DebugInformationFormat="3"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="1"
-				GenerateDebugInformation="TRUE"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="1"/>
-			<Tool
-				Name="VCMIDLTool"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCWebDeploymentTool"/>
-		</Configuration>
-	</Configurations>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm">
-			<File
-				RelativePath="..\..\testzlib\testzlib.c">
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc">
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe">
-		</Filter>
-		<File
-			RelativePath="ReleaseDll\zlibwapi.lib">
-		</File>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nbaur gcc-4.6.3/zlib/contrib/vstudio/vc7/zlib.rc gcc-4.6.3-psp/zlib/contrib/vstudio/vc7/zlib.rc
--- gcc-4.6.3/zlib/contrib/vstudio/vc7/zlib.rc	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/vstudio/vc7/zlib.rc	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-#include <windows.h>
-
-#define IDR_VERSION1  1
-IDR_VERSION1	VERSIONINFO	MOVEABLE IMPURE LOADONCALL DISCARDABLE
-  FILEVERSION	 1,2,3,0
-  PRODUCTVERSION 1,2,3,0
-  FILEFLAGSMASK	VS_FFI_FILEFLAGSMASK
-  FILEFLAGS	0
-  FILEOS	VOS_DOS_WINDOWS32
-  FILETYPE	VFT_DLL
-  FILESUBTYPE	0	// not used
-BEGIN
-  BLOCK "StringFileInfo"
-  BEGIN
-    BLOCK "040904E4"
-    //language ID = U.S. English, char set = Windows, Multilingual
-
-    BEGIN
-      VALUE "FileDescription", "zlib data compression library\0"
-      VALUE "FileVersion",	"1.2.3.0\0"
-      VALUE "InternalName",	"zlib\0"
-      VALUE "OriginalFilename",	"zlib.dll\0"
-      VALUE "ProductName",	"ZLib.DLL\0"
-      VALUE "Comments","DLL support by Alessandro Iacopetti & Gilles Vollant\0"
-      VALUE "LegalCopyright", "(C) 1995-2003 Jean-loup Gailly & Mark Adler\0"
-    END
-  END
-  BLOCK "VarFileInfo"
-  BEGIN
-    VALUE "Translation", 0x0409, 1252
-  END
-END
diff -Nbaur gcc-4.6.3/zlib/contrib/vstudio/vc7/zlibstat.vcproj gcc-4.6.3-psp/zlib/contrib/vstudio/vc7/zlibstat.vcproj
--- gcc-4.6.3/zlib/contrib/vstudio/vc7/zlibstat.vcproj	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/vstudio/vc7/zlibstat.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,246 +0,0 @@
-<?xml version="1.0" encoding = "Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="7.00"
-	Name="zlibstat"
-	SccProjectName=""
-	SccLocalPath="">
-	<Platforms>
-		<Platform
-			Name="Win32"/>
-	</Platforms>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory=".\zlibstatDebug"
-			IntermediateDirectory=".\zlibstatDebug"
-			ConfigurationType="4"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI"
-				ExceptionHandling="FALSE"
-				RuntimeLibrary="5"
-				PrecompiledHeaderFile=".\zlibstatDebug/zlibstat.pch"
-				AssemblerListingLocation=".\zlibstatDebug/"
-				ObjectFile=".\zlibstatDebug/"
-				ProgramDataBaseFileName=".\zlibstatDebug/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"
-				DebugInformationFormat="1"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/NODEFAULTLIB "
-				OutputFile=".\zlibstatDebug\zlibstat.lib"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCMIDLTool"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseAxp|Win32"
-			OutputDirectory=".\zlibsta0"
-			IntermediateDirectory=".\zlibsta0"
-			ConfigurationType="4"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE">
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI"
-				StringPooling="TRUE"
-				ExceptionHandling="FALSE"
-				RuntimeLibrary="4"
-				EnableFunctionLevelLinking="TRUE"
-				PrecompiledHeaderFile=".\zlibsta0/zlibstat.pch"
-				AssemblerListingLocation=".\zlibsta0/"
-				ObjectFile=".\zlibsta0/"
-				ProgramDataBaseFileName=".\zlibsta0/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/NODEFAULTLIB "
-				OutputFile=".\zlibsta0\zlibstat.lib"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCMIDLTool"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory=".\zlibstat"
-			IntermediateDirectory=".\zlibstat"
-			ConfigurationType="4"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE">
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI;ASMV;ASMINF"
-				StringPooling="TRUE"
-				ExceptionHandling="FALSE"
-				RuntimeLibrary="4"
-				EnableFunctionLevelLinking="TRUE"
-				PrecompiledHeaderFile=".\zlibstat/zlibstat.pch"
-				AssemblerListingLocation=".\zlibstat/"
-				ObjectFile=".\zlibstat/"
-				ProgramDataBaseFileName=".\zlibstat/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="..\..\masmx86\gvmat32.obj ..\..\masmx86\inffas32.obj /NODEFAULTLIB "
-				OutputFile=".\zlibstat\zlibstat.lib"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCMIDLTool"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|Win32"
-			OutputDirectory="zlibstatWithoutAsm"
-			IntermediateDirectory="zlibstatWithoutAsm"
-			ConfigurationType="4"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE">
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI"
-				StringPooling="TRUE"
-				ExceptionHandling="FALSE"
-				RuntimeLibrary="4"
-				EnableFunctionLevelLinking="TRUE"
-				PrecompiledHeaderFile=".\zlibstat/zlibstat.pch"
-				AssemblerListingLocation=".\zlibstatWithoutAsm/"
-				ObjectFile=".\zlibstatWithoutAsm/"
-				ProgramDataBaseFileName=".\zlibstatWithoutAsm/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions=" /NODEFAULTLIB "
-				OutputFile=".\zlibstatWithoutAsm\zlibstat.lib"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCMIDLTool"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-		</Configuration>
-	</Configurations>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="">
-			<File
-				RelativePath="..\..\..\adler32.c">
-			</File>
-			<File
-				RelativePath="..\..\..\compress.c">
-			</File>
-			<File
-				RelativePath="..\..\..\crc32.c">
-			</File>
-			<File
-				RelativePath="..\..\..\deflate.c">
-			</File>
-			<File
-				RelativePath="..\..\masmx86\gvmat32c.c">
-			</File>
-			<File
-				RelativePath="..\..\..\gzio.c">
-			</File>
-			<File
-				RelativePath="..\..\..\infback.c">
-			</File>
-			<File
-				RelativePath="..\..\..\inffast.c">
-			</File>
-			<File
-				RelativePath="..\..\..\inflate.c">
-			</File>
-			<File
-				RelativePath="..\..\..\inftrees.c">
-			</File>
-			<File
-				RelativePath="..\..\minizip\ioapi.c">
-			</File>
-			<File
-				RelativePath="..\..\..\trees.c">
-			</File>
-			<File
-				RelativePath="..\..\..\uncompr.c">
-			</File>
-			<File
-				RelativePath="..\..\minizip\unzip.c">
-			</File>
-			<File
-				RelativePath="..\..\minizip\zip.c">
-			</File>
-			<File
-				RelativePath=".\zlib.rc">
-			</File>
-			<File
-				RelativePath=".\zlibvc.def">
-			</File>
-			<File
-				RelativePath="..\..\..\zutil.c">
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nbaur gcc-4.6.3/zlib/contrib/vstudio/vc7/zlibvc.def gcc-4.6.3-psp/zlib/contrib/vstudio/vc7/zlibvc.def
--- gcc-4.6.3/zlib/contrib/vstudio/vc7/zlibvc.def	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/vstudio/vc7/zlibvc.def	1970-01-01 01:00:00.000000000 +0100
@@ -1,92 +0,0 @@
-
-VERSION		1.23
-
-HEAPSIZE	1048576,8192
-
-EXPORTS
-        adler32                                  @1
-        compress                                 @2
-        crc32                                    @3
-        deflate                                  @4
-        deflateCopy                              @5
-        deflateEnd                               @6
-        deflateInit2_                            @7
-        deflateInit_                             @8
-        deflateParams                            @9
-        deflateReset                             @10
-        deflateSetDictionary                     @11
-        gzclose                                  @12
-        gzdopen                                  @13
-        gzerror                                  @14
-        gzflush                                  @15
-        gzopen                                   @16
-        gzread                                   @17
-        gzwrite                                  @18
-        inflate                                  @19
-        inflateEnd                               @20
-        inflateInit2_                            @21
-        inflateInit_                             @22
-        inflateReset                             @23
-        inflateSetDictionary                     @24
-        inflateSync                              @25
-        uncompress                               @26
-        zlibVersion                              @27
-        gzprintf                                 @28
-        gzputc                                   @29
-        gzgetc                                   @30
-        gzseek                                   @31
-        gzrewind                                 @32
-        gztell                                   @33
-        gzeof                                    @34
-        gzsetparams                              @35
-        zError                                   @36
-        inflateSyncPoint                         @37
-        get_crc_table                            @38
-        compress2                                @39
-        gzputs                                   @40
-        gzgets                                   @41
-        inflateCopy                              @42
-        inflateBackInit_                         @43
-        inflateBack                              @44
-        inflateBackEnd                           @45
-        compressBound                            @46
-        deflateBound                             @47
-        gzclearerr                               @48
-        gzungetc                                 @49
-        zlibCompileFlags                         @50
-        deflatePrime                             @51
-
-        unzOpen                                  @61
-        unzClose                                 @62
-        unzGetGlobalInfo                         @63
-        unzGetCurrentFileInfo                    @64
-        unzGoToFirstFile                         @65
-        unzGoToNextFile                          @66
-        unzOpenCurrentFile                       @67
-        unzReadCurrentFile                       @68
-        unzOpenCurrentFile3                      @69
-        unztell                                  @70
-        unzeof                                   @71
-        unzCloseCurrentFile                      @72
-        unzGetGlobalComment                      @73
-        unzStringFileNameCompare                 @74
-        unzLocateFile                            @75
-        unzGetLocalExtrafield                    @76
-        unzOpen2                                 @77
-        unzOpenCurrentFile2                      @78
-        unzOpenCurrentFilePassword               @79
-
-        zipOpen                                  @80
-        zipOpenNewFileInZip                      @81
-        zipWriteInFileInZip                      @82
-        zipCloseFileInZip                        @83
-        zipClose                                 @84
-        zipOpenNewFileInZip2                     @86
-        zipCloseFileInZipRaw                     @87
-        zipOpen2                                 @88
-        zipOpenNewFileInZip3                     @89
-
-        unzGetFilePos                            @100
-        unzGoToFilePos                           @101
-
-        fill_win32_filefunc                      @110
diff -Nbaur gcc-4.6.3/zlib/contrib/vstudio/vc7/zlibvc.sln gcc-4.6.3-psp/zlib/contrib/vstudio/vc7/zlibvc.sln
--- gcc-4.6.3/zlib/contrib/vstudio/vc7/zlibvc.sln	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/vstudio/vc7/zlibvc.sln	1970-01-01 01:00:00.000000000 +0100
@@ -1,78 +0,0 @@
-Microsoft Visual Studio Solution File, Format Version 7.00
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "zlibstat", "zlibstat.vcproj", "{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "zlibvc", "zlibvc.vcproj", "{8FD826F8-3739-44E6-8CC8-997122E53B8D}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "minizip", "minizip.vcproj", "{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "miniunz", "miniunz.vcproj", "{C52F9E7B-498A-42BE-8DB4-85A15694382A}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "testZlibDll", "testzlib.vcproj", "{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}"
-EndProject
-Global
-	GlobalSection(SolutionConfiguration) = preSolution
-		ConfigName.0 = Debug
-		ConfigName.1 = Release
-		ConfigName.2 = ReleaseAxp
-		ConfigName.3 = ReleaseWithoutAsm
-		ConfigName.4 = ReleaseWithoutCrtdll
-	EndGlobalSection
-	GlobalSection(ProjectDependencies) = postSolution
-	EndGlobalSection
-	GlobalSection(ProjectConfiguration) = postSolution
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug.ActiveCfg = Debug|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug.Build.0 = Debug|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release.ActiveCfg = Release|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release.Build.0 = Release|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseAxp.ActiveCfg = ReleaseAxp|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseAxp.Build.0 = ReleaseAxp|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm.ActiveCfg = ReleaseWithoutAsm|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm.Build.0 = ReleaseWithoutAsm|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutCrtdll.ActiveCfg = ReleaseAxp|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutCrtdll.Build.0 = ReleaseAxp|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug.ActiveCfg = Debug|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug.Build.0 = Debug|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release.ActiveCfg = Release|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release.Build.0 = Release|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseAxp.ActiveCfg = ReleaseAxp|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseAxp.Build.0 = ReleaseAxp|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm.ActiveCfg = ReleaseWithoutAsm|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm.Build.0 = ReleaseWithoutAsm|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutCrtdll.ActiveCfg = ReleaseWithoutCrtdll|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutCrtdll.Build.0 = ReleaseWithoutCrtdll|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug.ActiveCfg = Debug|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug.Build.0 = Debug|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release.ActiveCfg = Release|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release.Build.0 = Release|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseAxp.ActiveCfg = Release|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseAxp.Build.0 = Release|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm.ActiveCfg = Release|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm.Build.0 = Release|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutCrtdll.ActiveCfg = Release|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutCrtdll.Build.0 = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug.ActiveCfg = Debug|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug.Build.0 = Debug|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release.ActiveCfg = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release.Build.0 = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseAxp.ActiveCfg = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseAxp.Build.0 = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm.ActiveCfg = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm.Build.0 = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutCrtdll.ActiveCfg = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutCrtdll.Build.0 = Release|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.Debug.ActiveCfg = Debug|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.Debug.Build.0 = Debug|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.Release.ActiveCfg = Release|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.Release.Build.0 = Release|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.ReleaseAxp.ActiveCfg = Release|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.ReleaseAxp.Build.0 = Release|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.ReleaseWithoutAsm.ActiveCfg = Release|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.ReleaseWithoutAsm.Build.0 = Release|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.ReleaseWithoutCrtdll.ActiveCfg = Release|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654C}.ReleaseWithoutCrtdll.Build.0 = Release|Win32
-	EndGlobalSection
-	GlobalSection(ExtensibilityGlobals) = postSolution
-	EndGlobalSection
-	GlobalSection(ExtensibilityAddIns) = postSolution
-	EndGlobalSection
-EndGlobal
diff -Nbaur gcc-4.6.3/zlib/contrib/vstudio/vc7/zlibvc.vcproj gcc-4.6.3-psp/zlib/contrib/vstudio/vc7/zlibvc.vcproj
--- gcc-4.6.3/zlib/contrib/vstudio/vc7/zlibvc.vcproj	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/vstudio/vc7/zlibvc.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,445 +0,0 @@
-<?xml version="1.0" encoding = "Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="7.00"
-	Name="zlibvc"
-	SccProjectName=""
-	SccLocalPath="">
-	<Platforms>
-		<Platform
-			Name="Win32"/>
-	</Platforms>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory=".\DebugDll"
-			IntermediateDirectory=".\DebugDll"
-			ConfigurationType="2"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE">
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32,ZLIB_WINAPI,ASMV,ASMINF"
-				ExceptionHandling="FALSE"
-				RuntimeLibrary="1"
-				PrecompiledHeaderFile=".\DebugDll/zlibvc.pch"
-				AssemblerListingLocation=".\DebugDll/"
-				ObjectFile=".\DebugDll/"
-				ProgramDataBaseFileName=".\DebugDll/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"
-				DebugInformationFormat="4"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="..\..\masmx86\gvmat32.obj ..\..\masmx86\inffas32.obj"
-				OutputFile=".\DebugDll\zlibwapi.dll"
-				LinkIncremental="2"
-				SuppressStartupBanner="TRUE"
-				ModuleDefinitionFile=".\zlibvc.def"
-				GenerateDebugInformation="TRUE"
-				ProgramDatabaseFile=".\DebugDll/zlibwapi.pdb"
-				SubSystem="2"
-				ImportLibrary=".\DebugDll/zlibwapi.lib"/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="_DEBUG"
-				MkTypLibCompatible="TRUE"
-				SuppressStartupBanner="TRUE"
-				TargetEnvironment="1"
-				TypeLibraryName=".\DebugDll/zlibvc.tlb"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1036"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCWebDeploymentTool"/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|Win32"
-			OutputDirectory=".\zlibDllWithoutAsm"
-			IntermediateDirectory=".\zlibDllWithoutAsm"
-			ConfigurationType="2"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			WholeProgramOptimization="TRUE">
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32,ZLIB_WINAPI"
-				StringPooling="TRUE"
-				ExceptionHandling="FALSE"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="TRUE"
-				PrecompiledHeaderFile=".\zlibDllWithoutAsm/zlibvc.pch"
-				AssemblerOutput="2"
-				AssemblerListingLocation=".\zlibDllWithoutAsm/"
-				ObjectFile=".\zlibDllWithoutAsm/"
-				ProgramDataBaseFileName=".\zlibDllWithoutAsm/"
-				BrowseInformation="1"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="crtdll.lib"
-				OutputFile=".\zlibDllWithoutAsm\zlibwapi.dll"
-				LinkIncremental="1"
-				SuppressStartupBanner="TRUE"
-				IgnoreAllDefaultLibraries="TRUE"
-				ModuleDefinitionFile=".\zlibvc.def"
-				ProgramDatabaseFile=".\zlibDllWithoutAsm/zlibwapi.pdb"
-				GenerateMapFile="TRUE"
-				MapFileName=".\zlibDllWithoutAsm/zlibwapi.map"
-				SubSystem="2"
-				OptimizeForWindows98="1"
-				ImportLibrary=".\zlibDllWithoutAsm/zlibwapi.lib"/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="TRUE"
-				SuppressStartupBanner="TRUE"
-				TargetEnvironment="1"
-				TypeLibraryName=".\zlibDllWithoutAsm/zlibvc.tlb"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1036"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCWebDeploymentTool"/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutCrtdll|Win32"
-			OutputDirectory=".\zlibDllWithoutCrtDll"
-			IntermediateDirectory=".\zlibDllWithoutCrtDll"
-			ConfigurationType="2"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			WholeProgramOptimization="TRUE">
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32,ZLIB_WINAPI,ASMV,ASMINF"
-				StringPooling="TRUE"
-				ExceptionHandling="FALSE"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="TRUE"
-				PrecompiledHeaderFile=".\zlibDllWithoutCrtDll/zlibvc.pch"
-				AssemblerOutput="2"
-				AssemblerListingLocation=".\zlibDllWithoutCrtDll/"
-				ObjectFile=".\zlibDllWithoutCrtDll/"
-				ProgramDataBaseFileName=".\zlibDllWithoutCrtDll/"
-				BrowseInformation="1"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="..\..\masmx86\gvmat32.obj ..\..\masmx86\inffas32.obj "
-				OutputFile=".\zlibDllWithoutCrtDll\zlibwapi.dll"
-				LinkIncremental="1"
-				SuppressStartupBanner="TRUE"
-				IgnoreAllDefaultLibraries="FALSE"
-				ModuleDefinitionFile=".\zlibvc.def"
-				ProgramDatabaseFile=".\zlibDllWithoutCrtDll/zlibwapi.pdb"
-				GenerateMapFile="TRUE"
-				MapFileName=".\zlibDllWithoutCrtDll/zlibwapi.map"
-				SubSystem="2"
-				OptimizeForWindows98="1"
-				ImportLibrary=".\zlibDllWithoutCrtDll/zlibwapi.lib"/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="TRUE"
-				SuppressStartupBanner="TRUE"
-				TargetEnvironment="1"
-				TypeLibraryName=".\zlibDllWithoutCrtDll/zlibvc.tlb"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1036"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCWebDeploymentTool"/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseAxp|Win32"
-			OutputDirectory=".\zlibvc__"
-			IntermediateDirectory=".\zlibvc__"
-			ConfigurationType="2"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			WholeProgramOptimization="TRUE">
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32,ZLIB_WINAPI"
-				StringPooling="TRUE"
-				ExceptionHandling="FALSE"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="TRUE"
-				PrecompiledHeaderFile=".\zlibvc__/zlibvc.pch"
-				AssemblerOutput="2"
-				AssemblerListingLocation=".\zlibvc__/"
-				ObjectFile=".\zlibvc__/"
-				ProgramDataBaseFileName=".\zlibvc__/"
-				BrowseInformation="1"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="crtdll.lib"
-				OutputFile="zlibvc__\zlibwapi.dll"
-				LinkIncremental="1"
-				SuppressStartupBanner="TRUE"
-				IgnoreAllDefaultLibraries="TRUE"
-				ModuleDefinitionFile=".\zlibvc.def"
-				ProgramDatabaseFile=".\zlibvc__/zlibwapi.pdb"
-				GenerateMapFile="TRUE"
-				MapFileName=".\zlibvc__/zlibwapi.map"
-				SubSystem="2"
-				ImportLibrary=".\zlibvc__/zlibwapi.lib"/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="TRUE"
-				SuppressStartupBanner="TRUE"
-				TargetEnvironment="1"
-				TypeLibraryName=".\zlibvc__/zlibvc.tlb"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1036"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCWebDeploymentTool"/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory=".\ReleaseDll"
-			IntermediateDirectory=".\ReleaseDll"
-			ConfigurationType="2"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			WholeProgramOptimization="TRUE">
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32,ZLIB_WINAPI,ASMV,ASMINF"
-				StringPooling="TRUE"
-				ExceptionHandling="FALSE"
-				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="TRUE"
-				PrecompiledHeaderFile=".\ReleaseDll/zlibvc.pch"
-				AssemblerOutput="2"
-				AssemblerListingLocation=".\ReleaseDll/"
-				ObjectFile=".\ReleaseDll/"
-				ProgramDataBaseFileName=".\ReleaseDll/"
-				BrowseInformation="1"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"/>
-			<Tool
-				Name="VCCustomBuildTool"/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="..\..\masmx86\gvmat32.obj ..\..\masmx86\inffas32.obj crtdll.lib"
-				OutputFile=".\ReleaseDll\zlibwapi.dll"
-				LinkIncremental="1"
-				SuppressStartupBanner="TRUE"
-				IgnoreAllDefaultLibraries="TRUE"
-				ModuleDefinitionFile=".\zlibvc.def"
-				ProgramDatabaseFile=".\ReleaseDll/zlibwapi.pdb"
-				GenerateMapFile="TRUE"
-				MapFileName=".\ReleaseDll/zlibwapi.map"
-				SubSystem="2"
-				OptimizeForWindows98="1"
-				ImportLibrary=".\ReleaseDll/zlibwapi.lib"/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="TRUE"
-				SuppressStartupBanner="TRUE"
-				TargetEnvironment="1"
-				TypeLibraryName=".\Release/zlibvc.tlb"/>
-			<Tool
-				Name="VCPostBuildEventTool"/>
-			<Tool
-				Name="VCPreBuildEventTool"/>
-			<Tool
-				Name="VCPreLinkEventTool"/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1036"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCWebDeploymentTool"/>
-		</Configuration>
-	</Configurations>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;rc;def;r;odl;hpj;bat;for;f90">
-			<File
-				RelativePath="..\..\..\adler32.c">
-			</File>
-			<File
-				RelativePath="..\..\..\compress.c">
-			</File>
-			<File
-				RelativePath="..\..\..\crc32.c">
-			</File>
-			<File
-				RelativePath="..\..\..\deflate.c">
-			</File>
-			<File
-				RelativePath="..\..\masmx86\gvmat32c.c">
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|Win32"
-					ExcludedFromBuild="TRUE">
-					<Tool
-						Name="VCCLCompilerTool"/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\..\..\gzio.c">
-			</File>
-			<File
-				RelativePath="..\..\..\infback.c">
-			</File>
-			<File
-				RelativePath="..\..\..\inffast.c">
-			</File>
-			<File
-				RelativePath="..\..\..\inflate.c">
-			</File>
-			<File
-				RelativePath="..\..\..\inftrees.c">
-			</File>
-			<File
-				RelativePath="..\..\minizip\ioapi.c">
-			</File>
-			<File
-				RelativePath="..\..\minizip\iowin32.c">
-			</File>
-			<File
-				RelativePath="..\..\..\trees.c">
-			</File>
-			<File
-				RelativePath="..\..\..\uncompr.c">
-			</File>
-			<File
-				RelativePath="..\..\minizip\unzip.c">
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions="ZLIB_INTERNAL"/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\..\minizip\zip.c">
-				<FileConfiguration
-					Name="Release|Win32">
-					<Tool
-						Name="VCCLCompilerTool"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions="ZLIB_INTERNAL"/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath=".\zlib.rc">
-			</File>
-			<File
-				RelativePath=".\zlibvc.def">
-			</File>
-			<File
-				RelativePath="..\..\..\zutil.c">
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;fi;fd">
-			<File
-				RelativePath="..\..\..\deflate.h">
-			</File>
-			<File
-				RelativePath="..\..\..\infblock.h">
-			</File>
-			<File
-				RelativePath="..\..\..\infcodes.h">
-			</File>
-			<File
-				RelativePath="..\..\..\inffast.h">
-			</File>
-			<File
-				RelativePath="..\..\..\inftrees.h">
-			</File>
-			<File
-				RelativePath="..\..\..\infutil.h">
-			</File>
-			<File
-				RelativePath="..\..\..\zconf.h">
-			</File>
-			<File
-				RelativePath="..\..\..\zlib.h">
-			</File>
-			<File
-				RelativePath="..\..\..\zutil.h">
-			</File>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="ico;cur;bmp;dlg;rc2;rct;bin;cnt;rtf;gif;jpg;jpeg;jpe">
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nbaur gcc-4.6.3/zlib/contrib/vstudio/vc8/miniunz.vcproj gcc-4.6.3-psp/zlib/contrib/vstudio/vc8/miniunz.vcproj
--- gcc-4.6.3/zlib/contrib/vstudio/vc8/miniunz.vcproj	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/vstudio/vc8/miniunz.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,566 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="8,00"
-	Name="miniunz"
-	ProjectGUID="{C52F9E7B-498A-42BE-8DB4-85A15694382A}"
-	Keyword="Win32Proj"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-		<Platform
-			Name="x64"
-		/>
-		<Platform
-			Name="Itanium"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="x86\MiniUnzip$(ConfigurationName)"
-			IntermediateDirectory="x86\MiniUnzip$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x86\ZlibDllDebug\zlibwapi.lib"
-				OutputFile="$(OutDir)/miniunz.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/miniunz.pdb"
-				SubSystem="1"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="x64\MiniUnzip$(ConfigurationName)"
-			IntermediateDirectory="x64\MiniUnzip$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x64\ZlibDllDebug\zlibwapi.lib"
-				OutputFile="$(OutDir)/miniunz.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/miniunz.pdb"
-				SubSystem="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Itanium"
-			OutputDirectory="ia64\MiniUnzip$(ConfigurationName)"
-			IntermediateDirectory="ia64\MiniUnzip$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="ia64\ZlibDllDebug\zlibwapi.lib"
-				OutputFile="$(OutDir)/miniunz.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/miniunz.pdb"
-				SubSystem="1"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="x86\MiniUnzip$(ConfigurationName)"
-			IntermediateDirectory="x86\MiniUnzip$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x86\ZlibDllRelease\zlibwapi.lib"
-				OutputFile="$(OutDir)/miniunz.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="x64\MiniUnzip$(ConfigurationName)"
-			IntermediateDirectory="x64\MiniUnzip$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x64\ZlibDllRelease\zlibwapi.lib"
-				OutputFile="$(OutDir)/miniunz.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Itanium"
-			OutputDirectory="ia64\MiniUnzip$(ConfigurationName)"
-			IntermediateDirectory="ia64\MiniUnzip$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="ia64\ZlibDllRelease\zlibwapi.lib"
-				OutputFile="$(OutDir)/miniunz.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm"
-			>
-			<File
-				RelativePath="..\..\minizip\miniunz.c"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc"
-			>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nbaur gcc-4.6.3/zlib/contrib/vstudio/vc8/minizip.vcproj gcc-4.6.3-psp/zlib/contrib/vstudio/vc8/minizip.vcproj
--- gcc-4.6.3/zlib/contrib/vstudio/vc8/minizip.vcproj	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/vstudio/vc8/minizip.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,563 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="8,00"
-	Name="minizip"
-	ProjectGUID="{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}"
-	Keyword="Win32Proj"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-		<Platform
-			Name="x64"
-		/>
-		<Platform
-			Name="Itanium"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="x86\MiniZip$(ConfigurationName)"
-			IntermediateDirectory="x86\MiniZip$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x86\ZlibDllDebug\zlibwapi.lib"
-				OutputFile="$(OutDir)/minizip.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/minizip.pdb"
-				SubSystem="1"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="x64\$(ConfigurationName)"
-			IntermediateDirectory="x64\$(ConfigurationName)"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x64\ZlibDllDebug\zlibwapi.lib"
-				OutputFile="$(OutDir)/minizip.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/minizip.pdb"
-				SubSystem="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Itanium"
-			OutputDirectory="ia64\$(ConfigurationName)"
-			IntermediateDirectory="ia64\$(ConfigurationName)"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="ia64\ZlibDllDebug\zlibwapi.lib"
-				OutputFile="$(OutDir)/minizip.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/minizip.pdb"
-				SubSystem="1"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="x86\MiniZip$(ConfigurationName)"
-			IntermediateDirectory="x86\MiniZip$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x86\ZlibDllRelease\zlibwapi.lib"
-				OutputFile="$(OutDir)/minizip.exe"
-				LinkIncremental="1"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="x64\$(ConfigurationName)"
-			IntermediateDirectory="x64\$(ConfigurationName)"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x64\ZlibDllRelease\zlibwapi.lib"
-				OutputFile="$(OutDir)/minizip.exe"
-				LinkIncremental="1"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Itanium"
-			OutputDirectory="ia64\$(ConfigurationName)"
-			IntermediateDirectory="ia64\$(ConfigurationName)"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="ia64\ZlibDllRelease\zlibwapi.lib"
-				OutputFile="$(OutDir)/minizip.exe"
-				LinkIncremental="1"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm"
-			>
-			<File
-				RelativePath="..\..\minizip\minizip.c"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc"
-			>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nbaur gcc-4.6.3/zlib/contrib/vstudio/vc8/testzlibdll.vcproj gcc-4.6.3-psp/zlib/contrib/vstudio/vc8/testzlibdll.vcproj
--- gcc-4.6.3/zlib/contrib/vstudio/vc8/testzlibdll.vcproj	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/vstudio/vc8/testzlibdll.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,567 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="8,00"
-	Name="TestZlibDll"
-	ProjectGUID="{C52F9E7B-498A-42BE-8DB4-85A15694366A}"
-	Keyword="Win32Proj"
-	SignManifests="true"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-		<Platform
-			Name="x64"
-		/>
-		<Platform
-			Name="Itanium"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="x86\TestZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x86\TestZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x86\ZlibDllDebug\zlibwapi.lib"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/testzlib.pdb"
-				SubSystem="1"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="x64\TestZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x64\TestZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x64\ZlibDllDebug\zlibwapi.lib"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/testzlib.pdb"
-				SubSystem="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Itanium"
-			OutputDirectory="ia64\TestZlibDll$(ConfigurationName)"
-			IntermediateDirectory="ia64\TestZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;_DEBUG;_CONSOLE;WIN64"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="ia64\ZlibDllDebug\zlibwapi.lib"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/testzlib.pdb"
-				SubSystem="1"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="x86\TestZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x86\TestZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="WIN32;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x86\ZlibDllRelease\zlibwapi.lib"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="x64\TestZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x64\TestZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="x64\ZlibDllRelease\zlibwapi.lib"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Itanium"
-			OutputDirectory="ia64\TestZlibDll$(ConfigurationName)"
-			IntermediateDirectory="ia64\TestZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\..;..\..\minizip"
-				PreprocessorDefinitions="_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;NDEBUG;_CONSOLE;WIN64"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="ia64\ZlibDllRelease\zlibwapi.lib"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm"
-			>
-			<File
-				RelativePath="..\..\testzlib\testzlib.c"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc"
-			>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nbaur gcc-4.6.3/zlib/contrib/vstudio/vc8/testzlib.vcproj gcc-4.6.3-psp/zlib/contrib/vstudio/vc8/testzlib.vcproj
--- gcc-4.6.3/zlib/contrib/vstudio/vc8/testzlib.vcproj	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/vstudio/vc8/testzlib.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,948 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="8,00"
-	Name="testzlib"
-	ProjectGUID="{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}"
-	RootNamespace="testzlib"
-	Keyword="Win32Proj"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-		<Platform
-			Name="x64"
-		/>
-		<Platform
-			Name="Itanium"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="x86\TestZlib$(ConfigurationName)"
-			IntermediateDirectory="x86\TestZlib$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="ASMV;ASMINF;WIN32;ZLIB_WINAPI;_DEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerOutput="4"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="..\..\masmx86\gvmat32.obj ..\..\masmx86\inffas32.obj"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/testzlib.pdb"
-				SubSystem="1"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="x64\TestZlib$(ConfigurationName)"
-			IntermediateDirectory="x64\TestZlib$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="ASMV;ASMINF;WIN32;ZLIB_WINAPI;_DEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				AssemblerListingLocation="$(IntDir)\"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="..\..\masmx64\gvmat64.obj ..\..\masmx64\inffasx64.obj"
-				GenerateManifest="false"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Itanium"
-			OutputDirectory="ia64\TestZlib$(ConfigurationName)"
-			IntermediateDirectory="ia64\TestZlib$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			CharacterSet="2"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="ZLIB_WINAPI;_DEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;WIN64"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				UsePrecompiledHeader="0"
-				AssemblerOutput="4"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="2"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/testzlib.pdb"
-				SubSystem="1"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|Win32"
-			OutputDirectory="x86\TestZlib$(ConfigurationName)"
-			IntermediateDirectory="x86\TestZlib$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			CharacterSet="2"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|x64"
-			OutputDirectory="x64\TestZlib$(ConfigurationName)"
-			IntermediateDirectory="x64\TestZlib$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				AssemblerListingLocation="$(IntDir)\"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies=""
-				GenerateManifest="false"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|Itanium"
-			OutputDirectory="ia64\TestZlib$(ConfigurationName)"
-			IntermediateDirectory="ia64\TestZlib$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			CharacterSet="2"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;WIN64"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="x86\TestZlib$(ConfigurationName)"
-			IntermediateDirectory="x86\TestZlib$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			CharacterSet="2"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="ASMV;ASMINF;WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="..\..\masmx86\gvmat32.obj ..\..\masmx86\inffas32.obj"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="1"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="x64\TestZlib$(ConfigurationName)"
-			IntermediateDirectory="x64\TestZlib$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="ASMV;ASMINF;WIN32;ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				AssemblerListingLocation="$(IntDir)\"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="..\..\masmx64\gvmat64.obj ..\..\masmx64\inffasx64.obj"
-				GenerateManifest="false"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Itanium"
-			OutputDirectory="ia64\TestZlib$(ConfigurationName)"
-			IntermediateDirectory="ia64\TestZlib$(ConfigurationName)\Tmp"
-			ConfigurationType="1"
-			CharacterSet="2"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="2"
-				InlineFunctionExpansion="1"
-				OmitFramePointers="true"
-				AdditionalIncludeDirectories="..\..\.."
-				PreprocessorDefinitions="ZLIB_WINAPI;NDEBUG;_CONSOLE;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;WIN64"
-				StringPooling="true"
-				BasicRuntimeChecks="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				UsePrecompiledHeader="0"
-				AssemblerListingLocation="$(IntDir)\"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)/testzlib.exe"
-				LinkIncremental="1"
-				GenerateManifest="false"
-				GenerateDebugInformation="true"
-				SubSystem="1"
-				OptimizeReferences="2"
-				EnableCOMDATFolding="2"
-				OptimizeForWindows98="1"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm"
-			>
-			<File
-				RelativePath="..\..\..\adler32.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\compress.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\crc32.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\deflate.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\masmx86\gvmat32c.c"
-				>
-				<FileConfiguration
-					Name="Debug|x64"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|x64"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|x64"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Win64 (AMD64)"
-					ExcludedFromBuild="TRUE"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win64 (AMD64)"
-					ExcludedFromBuild="TRUE"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseAsm|Win64 (AMD64)"
-					ExcludedFromBuild="TRUE"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\..\..\infback.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\masmx64\inffas8664.c"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\..\..\inffast.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\inflate.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\inftrees.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\testzlib\testzlib.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\trees.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\uncompr.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\zutil.c"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc"
-			>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nbaur gcc-4.6.3/zlib/contrib/vstudio/vc8/zlib.rc gcc-4.6.3-psp/zlib/contrib/vstudio/vc8/zlib.rc
--- gcc-4.6.3/zlib/contrib/vstudio/vc8/zlib.rc	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/vstudio/vc8/zlib.rc	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-#include <windows.h>
-
-#define IDR_VERSION1  1
-IDR_VERSION1	VERSIONINFO	MOVEABLE IMPURE LOADONCALL DISCARDABLE
-  FILEVERSION	 1,2,3,0
-  PRODUCTVERSION 1,2,3,0
-  FILEFLAGSMASK	VS_FFI_FILEFLAGSMASK
-  FILEFLAGS	0
-  FILEOS	VOS_DOS_WINDOWS32
-  FILETYPE	VFT_DLL
-  FILESUBTYPE	0	// not used
-BEGIN
-  BLOCK "StringFileInfo"
-  BEGIN
-    BLOCK "040904E4"
-    //language ID = U.S. English, char set = Windows, Multilingual
-
-    BEGIN
-      VALUE "FileDescription", "zlib data compression library\0"
-      VALUE "FileVersion",	"1.2.3.0\0"
-      VALUE "InternalName",	"zlib\0"
-      VALUE "OriginalFilename",	"zlib.dll\0"
-      VALUE "ProductName",	"ZLib.DLL\0"
-      VALUE "Comments","DLL support by Alessandro Iacopetti & Gilles Vollant\0"
-      VALUE "LegalCopyright", "(C) 1995-2003 Jean-loup Gailly & Mark Adler\0"
-    END
-  END
-  BLOCK "VarFileInfo"
-  BEGIN
-    VALUE "Translation", 0x0409, 1252
-  END
-END
diff -Nbaur gcc-4.6.3/zlib/contrib/vstudio/vc8/zlibstat.vcproj gcc-4.6.3-psp/zlib/contrib/vstudio/vc8/zlibstat.vcproj
--- gcc-4.6.3/zlib/contrib/vstudio/vc8/zlibstat.vcproj	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/vstudio/vc8/zlibstat.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,870 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="8,00"
-	Name="zlibstat"
-	ProjectGUID="{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-		<Platform
-			Name="x64"
-		/>
-		<Platform
-			Name="Itanium"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="x86\ZlibStat$(ConfigurationName)"
-			IntermediateDirectory="x86\ZlibStat$(ConfigurationName)\Tmp"
-			ConfigurationType="4"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE"
-				ExceptionHandling="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				PrecompiledHeaderFile="$(IntDir)/zlibstat.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="1"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/MACHINE:X86 /NODEFAULTLIB"
-				OutputFile="$(OutDir)\zlibstat.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="x64\ZlibStat$(ConfigurationName)"
-			IntermediateDirectory="x64\ZlibStat$(ConfigurationName)\Tmp"
-			ConfigurationType="4"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;WIN64"
-				ExceptionHandling="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				PrecompiledHeaderFile="$(IntDir)/zlibstat.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="1"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/MACHINE:AMD64 /NODEFAULTLIB"
-				OutputFile="$(OutDir)\zlibstat.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Itanium"
-			OutputDirectory="ia64\ZlibStat$(ConfigurationName)"
-			IntermediateDirectory="ia64\ZlibStat$(ConfigurationName)\Tmp"
-			ConfigurationType="4"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;WIN64"
-				ExceptionHandling="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				PrecompiledHeaderFile="$(IntDir)/zlibstat.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="1"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/MACHINE:IA64 /NODEFAULTLIB"
-				OutputFile="$(OutDir)\zlibstat.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="x86\ZlibStat$(ConfigurationName)"
-			IntermediateDirectory="x86\ZlibStat$(ConfigurationName)\Tmp"
-			ConfigurationType="4"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ASMV;ASMINF"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibstat.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/MACHINE:X86 /NODEFAULTLIB"
-				AdditionalDependencies="..\..\masmx86\gvmat32.obj ..\..\masmx86\inffas32.obj "
-				OutputFile="$(OutDir)\zlibstat.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="x64\ZlibStat$(ConfigurationName)"
-			IntermediateDirectory="x64\ZlibStat$(ConfigurationName)\Tmp"
-			ConfigurationType="4"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;ASMV;ASMINF;WIN64"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibstat.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/MACHINE:AMD64 /NODEFAULTLIB"
-				AdditionalDependencies="..\..\masmx64\gvmat64.obj ..\..\masmx64\inffasx64.obj "
-				OutputFile="$(OutDir)\zlibstat.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Itanium"
-			OutputDirectory="ia64\ZlibStat$(ConfigurationName)"
-			IntermediateDirectory="ia64\ZlibStat$(ConfigurationName)\Tmp"
-			ConfigurationType="4"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;WIN64"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibstat.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/MACHINE:IA64 /NODEFAULTLIB"
-				OutputFile="$(OutDir)\zlibstat.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|Win32"
-			OutputDirectory="x86\ZlibStat$(ConfigurationName)"
-			IntermediateDirectory="x86\ZlibStat$(ConfigurationName)\Tmp"
-			ConfigurationType="4"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="0"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibstat.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/MACHINE:X86 /NODEFAULTLIB"
-				OutputFile="$(OutDir)\zlibstat.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|x64"
-			OutputDirectory="x64\ZlibStat$(ConfigurationName)"
-			IntermediateDirectory="x64\ZlibStat$(ConfigurationName)\Tmp"
-			ConfigurationType="4"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="3"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;WIN64"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibstat.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/MACHINE:AMD64 /NODEFAULTLIB"
-				OutputFile="$(OutDir)\zlibstat.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|Itanium"
-			OutputDirectory="ia64\ZlibStat$(ConfigurationName)"
-			IntermediateDirectory="ia64\ZlibStat$(ConfigurationName)\Tmp"
-			ConfigurationType="4"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				TargetEnvironment="2"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="ZLIB_WINAPI;_CRT_NONSTDC_NO_DEPRECATE;_CRT_SECURE_NO_DEPRECATE;WIN64"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibstat.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-				AdditionalOptions="/MACHINE:IA64 /NODEFAULTLIB"
-				OutputFile="$(OutDir)\zlibstat.lib"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			>
-			<File
-				RelativePath="..\..\..\adler32.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\compress.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\crc32.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\deflate.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\masmx86\gvmat32c.c"
-				>
-				<FileConfiguration
-					Name="Debug|x64"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|x64"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|x64"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\..\..\gzio.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\infback.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\masmx64\inffas8664.c"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\..\..\inffast.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\inflate.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\inftrees.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\minizip\ioapi.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\trees.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\uncompr.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\minizip\unzip.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\minizip\zip.c"
-				>
-			</File>
-			<File
-				RelativePath=".\zlib.rc"
-				>
-			</File>
-			<File
-				RelativePath=".\zlibvc.def"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\zutil.c"
-				>
-			</File>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nbaur gcc-4.6.3/zlib/contrib/vstudio/vc8/zlibvc.def gcc-4.6.3-psp/zlib/contrib/vstudio/vc8/zlibvc.def
--- gcc-4.6.3/zlib/contrib/vstudio/vc8/zlibvc.def	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/vstudio/vc8/zlibvc.def	1970-01-01 01:00:00.000000000 +0100
@@ -1,92 +0,0 @@
-
-VERSION		1.23
-
-HEAPSIZE	1048576,8192
-
-EXPORTS
-        adler32                                  @1
-        compress                                 @2
-        crc32                                    @3
-        deflate                                  @4
-        deflateCopy                              @5
-        deflateEnd                               @6
-        deflateInit2_                            @7
-        deflateInit_                             @8
-        deflateParams                            @9
-        deflateReset                             @10
-        deflateSetDictionary                     @11
-        gzclose                                  @12
-        gzdopen                                  @13
-        gzerror                                  @14
-        gzflush                                  @15
-        gzopen                                   @16
-        gzread                                   @17
-        gzwrite                                  @18
-        inflate                                  @19
-        inflateEnd                               @20
-        inflateInit2_                            @21
-        inflateInit_                             @22
-        inflateReset                             @23
-        inflateSetDictionary                     @24
-        inflateSync                              @25
-        uncompress                               @26
-        zlibVersion                              @27
-        gzprintf                                 @28
-        gzputc                                   @29
-        gzgetc                                   @30
-        gzseek                                   @31
-        gzrewind                                 @32
-        gztell                                   @33
-        gzeof                                    @34
-        gzsetparams                              @35
-        zError                                   @36
-        inflateSyncPoint                         @37
-        get_crc_table                            @38
-        compress2                                @39
-        gzputs                                   @40
-        gzgets                                   @41
-        inflateCopy                              @42
-        inflateBackInit_                         @43
-        inflateBack                              @44
-        inflateBackEnd                           @45
-        compressBound                            @46
-        deflateBound                             @47
-        gzclearerr                               @48
-        gzungetc                                 @49
-        zlibCompileFlags                         @50
-        deflatePrime                             @51
-
-        unzOpen                                  @61
-        unzClose                                 @62
-        unzGetGlobalInfo                         @63
-        unzGetCurrentFileInfo                    @64
-        unzGoToFirstFile                         @65
-        unzGoToNextFile                          @66
-        unzOpenCurrentFile                       @67
-        unzReadCurrentFile                       @68
-        unzOpenCurrentFile3                      @69
-        unztell                                  @70
-        unzeof                                   @71
-        unzCloseCurrentFile                      @72
-        unzGetGlobalComment                      @73
-        unzStringFileNameCompare                 @74
-        unzLocateFile                            @75
-        unzGetLocalExtrafield                    @76
-        unzOpen2                                 @77
-        unzOpenCurrentFile2                      @78
-        unzOpenCurrentFilePassword               @79
-
-        zipOpen                                  @80
-        zipOpenNewFileInZip                      @81
-        zipWriteInFileInZip                      @82
-        zipCloseFileInZip                        @83
-        zipClose                                 @84
-        zipOpenNewFileInZip2                     @86
-        zipCloseFileInZipRaw                     @87
-        zipOpen2                                 @88
-        zipOpenNewFileInZip3                     @89
-
-        unzGetFilePos                            @100
-        unzGoToFilePos                           @101
-
-        fill_win32_filefunc                      @110
diff -Nbaur gcc-4.6.3/zlib/contrib/vstudio/vc8/zlibvc.sln gcc-4.6.3-psp/zlib/contrib/vstudio/vc8/zlibvc.sln
--- gcc-4.6.3/zlib/contrib/vstudio/vc8/zlibvc.sln	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/vstudio/vc8/zlibvc.sln	1970-01-01 01:00:00.000000000 +0100
@@ -1,144 +0,0 @@
-
-Microsoft Visual Studio Solution File, Format Version 9.00
-# Visual Studio 2005
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "zlibvc", "zlibvc.vcproj", "{8FD826F8-3739-44E6-8CC8-997122E53B8D}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "zlibstat", "zlibstat.vcproj", "{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "testzlib", "testzlib.vcproj", "{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "TestZlibDll", "testzlibdll.vcproj", "{C52F9E7B-498A-42BE-8DB4-85A15694366A}"
-	ProjectSection(ProjectDependencies) = postProject
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D} = {8FD826F8-3739-44E6-8CC8-997122E53B8D}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "minizip", "minizip.vcproj", "{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}"
-	ProjectSection(ProjectDependencies) = postProject
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D} = {8FD826F8-3739-44E6-8CC8-997122E53B8D}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "miniunz", "miniunz.vcproj", "{C52F9E7B-498A-42BE-8DB4-85A15694382A}"
-	ProjectSection(ProjectDependencies) = postProject
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D} = {8FD826F8-3739-44E6-8CC8-997122E53B8D}
-	EndProjectSection
-EndProject
-Global
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|Itanium = Debug|Itanium
-		Debug|Win32 = Debug|Win32
-		Debug|x64 = Debug|x64
-		Release|Itanium = Release|Itanium
-		Release|Win32 = Release|Win32
-		Release|x64 = Release|x64
-		ReleaseWithoutAsm|Itanium = ReleaseWithoutAsm|Itanium
-		ReleaseWithoutAsm|Win32 = ReleaseWithoutAsm|Win32
-		ReleaseWithoutAsm|x64 = ReleaseWithoutAsm|x64
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|Itanium.ActiveCfg = Debug|Itanium
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|Itanium.Build.0 = Debug|Itanium
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|Win32.ActiveCfg = Debug|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|Win32.Build.0 = Debug|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|x64.ActiveCfg = Debug|x64
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Debug|x64.Build.0 = Debug|x64
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|Itanium.ActiveCfg = Release|Itanium
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|Itanium.Build.0 = Release|Itanium
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|Win32.ActiveCfg = Release|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|Win32.Build.0 = Release|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|x64.ActiveCfg = ReleaseWithoutAsm|x64
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.Release|x64.Build.0 = ReleaseWithoutAsm|x64
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|Itanium.ActiveCfg = ReleaseWithoutAsm|Itanium
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|Itanium.Build.0 = ReleaseWithoutAsm|Itanium
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|Win32.ActiveCfg = ReleaseWithoutAsm|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|Win32.Build.0 = ReleaseWithoutAsm|Win32
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|x64.ActiveCfg = ReleaseWithoutAsm|x64
-		{8FD826F8-3739-44E6-8CC8-997122E53B8D}.ReleaseWithoutAsm|x64.Build.0 = ReleaseWithoutAsm|x64
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|Itanium.ActiveCfg = Debug|Itanium
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|Itanium.Build.0 = Debug|Itanium
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|Win32.ActiveCfg = Debug|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|Win32.Build.0 = Debug|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|x64.ActiveCfg = Debug|x64
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Debug|x64.Build.0 = Debug|x64
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|Itanium.ActiveCfg = Release|Itanium
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|Itanium.Build.0 = Release|Itanium
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|Win32.ActiveCfg = Release|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|Win32.Build.0 = Release|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|x64.ActiveCfg = Release|x64
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.Release|x64.Build.0 = Release|x64
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|Itanium.ActiveCfg = ReleaseWithoutAsm|Itanium
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|Itanium.Build.0 = ReleaseWithoutAsm|Itanium
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|Win32.ActiveCfg = ReleaseWithoutAsm|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|Win32.Build.0 = ReleaseWithoutAsm|Win32
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|x64.ActiveCfg = ReleaseWithoutAsm|x64
-		{745DEC58-EBB3-47A9-A9B8-4C6627C01BF8}.ReleaseWithoutAsm|x64.Build.0 = ReleaseWithoutAsm|x64
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|Itanium.ActiveCfg = Debug|Itanium
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|Itanium.Build.0 = Debug|Itanium
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|Win32.ActiveCfg = Debug|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|Win32.Build.0 = Debug|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|x64.ActiveCfg = Debug|x64
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Debug|x64.Build.0 = Debug|x64
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|Itanium.ActiveCfg = Release|Itanium
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|Itanium.Build.0 = Release|Itanium
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|Win32.ActiveCfg = Release|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|Win32.Build.0 = Release|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|x64.ActiveCfg = Release|x64
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.Release|x64.Build.0 = Release|x64
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Itanium.ActiveCfg = ReleaseWithoutAsm|Itanium
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Itanium.Build.0 = ReleaseWithoutAsm|Itanium
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Win32.ActiveCfg = ReleaseWithoutAsm|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Win32.Build.0 = ReleaseWithoutAsm|Win32
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|x64.ActiveCfg = ReleaseWithoutAsm|x64
-		{AA6666AA-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|x64.Build.0 = ReleaseWithoutAsm|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|Itanium.ActiveCfg = Debug|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|Itanium.Build.0 = Debug|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|Win32.ActiveCfg = Debug|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|Win32.Build.0 = Debug|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|x64.ActiveCfg = Debug|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Debug|x64.Build.0 = Debug|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|Itanium.ActiveCfg = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|Itanium.Build.0 = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|Win32.ActiveCfg = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|Win32.Build.0 = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|x64.ActiveCfg = Release|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.Release|x64.Build.0 = Release|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.ReleaseWithoutAsm|Itanium.ActiveCfg = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.ReleaseWithoutAsm|Itanium.Build.0 = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.ReleaseWithoutAsm|Win32.ActiveCfg = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694366A}.ReleaseWithoutAsm|x64.ActiveCfg = Release|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|Itanium.ActiveCfg = Debug|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|Itanium.Build.0 = Debug|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|Win32.ActiveCfg = Debug|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|Win32.Build.0 = Debug|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|x64.ActiveCfg = Debug|x64
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Debug|x64.Build.0 = Debug|x64
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|Itanium.ActiveCfg = Release|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|Itanium.Build.0 = Release|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|Win32.ActiveCfg = Release|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|Win32.Build.0 = Release|Win32
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|x64.ActiveCfg = Release|x64
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.Release|x64.Build.0 = Release|x64
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Itanium.ActiveCfg = Release|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Itanium.Build.0 = Release|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|Win32.ActiveCfg = Release|Itanium
-		{48CDD9DC-E09F-4135-9C0C-4FE50C3C654B}.ReleaseWithoutAsm|x64.ActiveCfg = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|Itanium.ActiveCfg = Debug|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|Itanium.Build.0 = Debug|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|Win32.ActiveCfg = Debug|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|Win32.Build.0 = Debug|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|x64.ActiveCfg = Debug|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Debug|x64.Build.0 = Debug|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|Itanium.ActiveCfg = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|Itanium.Build.0 = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|Win32.ActiveCfg = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|Win32.Build.0 = Release|Win32
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|x64.ActiveCfg = Release|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.Release|x64.Build.0 = Release|x64
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm|Itanium.ActiveCfg = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm|Itanium.Build.0 = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm|Win32.ActiveCfg = Release|Itanium
-		{C52F9E7B-498A-42BE-8DB4-85A15694382A}.ReleaseWithoutAsm|x64.ActiveCfg = Release|Itanium
-	EndGlobalSection
-	GlobalSection(SolutionProperties) = preSolution
-		HideSolutionNode = FALSE
-	EndGlobalSection
-EndGlobal
diff -Nbaur gcc-4.6.3/zlib/contrib/vstudio/vc8/zlibvc.vcproj gcc-4.6.3-psp/zlib/contrib/vstudio/vc8/zlibvc.vcproj
--- gcc-4.6.3/zlib/contrib/vstudio/vc8/zlibvc.vcproj	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/contrib/vstudio/vc8/zlibvc.vcproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,1219 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="8,00"
-	Name="zlibvc"
-	ProjectGUID="{8FD826F8-3739-44E6-8CC8-997122E53B8D}"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-		<Platform
-			Name="x64"
-		/>
-		<Platform
-			Name="Itanium"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="x86\ZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x86\ZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="2"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="_DEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="1"
-				TypeLibraryName="$(OutDir)/zlibvc.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32,_CRT_SECURE_NO_DEPRECATE,ZLIB_WINAPI,ASMV,ASMINF"
-				ExceptionHandling="0"
-				RuntimeLibrary="1"
-				BufferSecurityCheck="false"
-				PrecompiledHeaderFile="$(IntDir)/zlibvc.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="..\..\masmx86\gvmat32.obj ..\..\masmx86\inffas32.obj"
-				OutputFile="$(OutDir)\zlibwapi.dll"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				GenerateManifest="false"
-				ModuleDefinitionFile=".\zlibvc.def"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/zlibwapi.pdb"
-				GenerateMapFile="true"
-				MapFileName="$(OutDir)/zlibwapi.map"
-				SubSystem="2"
-				ImportLibrary="$(OutDir)/zlibwapi.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|x64"
-			OutputDirectory="x64\ZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x64\ZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="2"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="_DEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="3"
-				TypeLibraryName="$(OutDir)/zlibvc.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32,_CRT_SECURE_NO_DEPRECATE,ZLIB_WINAPI,ASMV,ASMINF;WIN64"
-				ExceptionHandling="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				PrecompiledHeaderFile="$(IntDir)/zlibvc.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="..\..\masmx64\gvmat64.obj ..\..\masmx64\inffasx64.obj "
-				OutputFile="$(OutDir)\zlibwapi.dll"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				GenerateManifest="false"
-				ModuleDefinitionFile=".\zlibvc.def"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/zlibwapi.pdb"
-				GenerateMapFile="true"
-				MapFileName="$(OutDir)/zlibwapi.map"
-				SubSystem="2"
-				ImportLibrary="$(OutDir)/zlibwapi.lib"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Debug|Itanium"
-			OutputDirectory="ia64\ZlibDll$(ConfigurationName)"
-			IntermediateDirectory="ia64\ZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="2"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="_DEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="2"
-				TypeLibraryName="$(OutDir)/zlibvc.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;WIN64"
-				ExceptionHandling="0"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				PrecompiledHeaderFile="$(IntDir)/zlibvc.pch"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)\zlibwapi.dll"
-				LinkIncremental="2"
-				SuppressStartupBanner="true"
-				GenerateManifest="false"
-				ModuleDefinitionFile=".\zlibvc.def"
-				GenerateDebugInformation="true"
-				ProgramDatabaseFile="$(OutDir)/zlibwapi.pdb"
-				GenerateMapFile="true"
-				MapFileName="$(OutDir)/zlibwapi.map"
-				SubSystem="2"
-				ImportLibrary="$(OutDir)/zlibwapi.lib"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|Win32"
-			OutputDirectory="x86\ZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x86\ZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="2"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="1"
-				TypeLibraryName="$(OutDir)/zlibvc.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32,_CRT_SECURE_NO_DEPRECATE,ZLIB_WINAPI"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibvc.pch"
-				AssemblerOutput="2"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/MACHINE:I386"
-				OutputFile="$(OutDir)\zlibwapi.dll"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				GenerateManifest="false"
-				IgnoreAllDefaultLibraries="false"
-				ModuleDefinitionFile=".\zlibvc.def"
-				ProgramDatabaseFile="$(OutDir)/zlibwapi.pdb"
-				GenerateMapFile="true"
-				MapFileName="$(OutDir)/zlibwapi.map"
-				SubSystem="2"
-				OptimizeForWindows98="1"
-				ImportLibrary="$(OutDir)/zlibwapi.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|x64"
-			OutputDirectory="x64\ZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x64\ZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="2"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="3"
-				TypeLibraryName="$(OutDir)/zlibvc.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32,_CRT_SECURE_NO_DEPRECATE,ZLIB_WINAPI;WIN64"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibvc.pch"
-				AssemblerOutput="2"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)\zlibwapi.dll"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				GenerateManifest="false"
-				IgnoreAllDefaultLibraries="false"
-				ModuleDefinitionFile=".\zlibvc.def"
-				ProgramDatabaseFile="$(OutDir)/zlibwapi.pdb"
-				GenerateMapFile="true"
-				MapFileName="$(OutDir)/zlibwapi.map"
-				SubSystem="2"
-				OptimizeForWindows98="1"
-				ImportLibrary="$(OutDir)/zlibwapi.lib"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="ReleaseWithoutAsm|Itanium"
-			OutputDirectory="ia64\ZlibDll$(ConfigurationName)"
-			IntermediateDirectory="ia64\ZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="2"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="2"
-				TypeLibraryName="$(OutDir)/zlibvc.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32,_CRT_SECURE_NO_DEPRECATE,ZLIB_WINAPI;WIN64"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibvc.pch"
-				AssemblerOutput="2"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)\zlibwapi.dll"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				GenerateManifest="false"
-				IgnoreAllDefaultLibraries="false"
-				ModuleDefinitionFile=".\zlibvc.def"
-				ProgramDatabaseFile="$(OutDir)/zlibwapi.pdb"
-				GenerateMapFile="true"
-				MapFileName="$(OutDir)/zlibwapi.map"
-				SubSystem="2"
-				OptimizeForWindows98="1"
-				ImportLibrary="$(OutDir)/zlibwapi.lib"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="x86\ZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x86\ZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="2"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="1"
-				TypeLibraryName="$(OutDir)/zlibvc.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="WIN32;_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;ASMV;ASMINF"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibvc.pch"
-				AssemblerOutput="2"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="..\..\masmx86\gvmat32.obj ..\..\masmx86\inffas32.obj "
-				OutputFile="$(OutDir)\zlibwapi.dll"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				GenerateManifest="false"
-				IgnoreAllDefaultLibraries="false"
-				ModuleDefinitionFile=".\zlibvc.def"
-				ProgramDatabaseFile="$(OutDir)/zlibwapi.pdb"
-				GenerateMapFile="true"
-				MapFileName="$(OutDir)/zlibwapi.map"
-				SubSystem="2"
-				OptimizeForWindows98="1"
-				ImportLibrary="$(OutDir)/zlibwapi.lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|x64"
-			OutputDirectory="x64\ZlibDll$(ConfigurationName)"
-			IntermediateDirectory="x64\ZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="2"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="3"
-				TypeLibraryName="$(OutDir)/zlibvc.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;ASMV;ASMINF;WIN64"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibvc.pch"
-				AssemblerOutput="2"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="..\..\masmx64\gvmat64.obj ..\..\masmx64\inffasx64.obj "
-				OutputFile="$(OutDir)\zlibwapi.dll"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				GenerateManifest="false"
-				IgnoreAllDefaultLibraries="false"
-				ModuleDefinitionFile=".\zlibvc.def"
-				ProgramDatabaseFile="$(OutDir)/zlibwapi.pdb"
-				GenerateMapFile="true"
-				MapFileName="$(OutDir)/zlibwapi.map"
-				SubSystem="2"
-				OptimizeForWindows98="1"
-				ImportLibrary="$(OutDir)/zlibwapi.lib"
-				TargetMachine="17"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Itanium"
-			OutputDirectory="ia64\ZlibDll$(ConfigurationName)"
-			IntermediateDirectory="ia64\ZlibDll$(ConfigurationName)\Tmp"
-			ConfigurationType="2"
-			InheritedPropertySheets="UpgradeFromVC70.vsprops"
-			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="false"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-				PreprocessorDefinitions="NDEBUG"
-				MkTypLibCompatible="true"
-				SuppressStartupBanner="true"
-				TargetEnvironment="2"
-				TypeLibraryName="$(OutDir)/zlibvc.tlb"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="..\..\..;..\..\masmx86"
-				PreprocessorDefinitions="_CRT_SECURE_NO_DEPRECATE;ZLIB_WINAPI;WIN64"
-				StringPooling="true"
-				ExceptionHandling="0"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
-				EnableFunctionLevelLinking="true"
-				PrecompiledHeaderFile="$(IntDir)/zlibvc.pch"
-				AssemblerOutput="2"
-				AssemblerListingLocation="$(IntDir)\"
-				ObjectFile="$(IntDir)\"
-				ProgramDataBaseFileName="$(OutDir)\"
-				BrowseInformation="0"
-				WarningLevel="3"
-				SuppressStartupBanner="true"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1036"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				OutputFile="$(OutDir)\zlibwapi.dll"
-				LinkIncremental="1"
-				SuppressStartupBanner="true"
-				GenerateManifest="false"
-				IgnoreAllDefaultLibraries="false"
-				ModuleDefinitionFile=".\zlibvc.def"
-				ProgramDatabaseFile="$(OutDir)/zlibwapi.pdb"
-				GenerateMapFile="true"
-				MapFileName="$(OutDir)/zlibwapi.map"
-				SubSystem="2"
-				OptimizeForWindows98="1"
-				ImportLibrary="$(OutDir)/zlibwapi.lib"
-				TargetMachine="5"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cxx;rc;def;r;odl;hpj;bat;for;f90"
-			>
-			<File
-				RelativePath="..\..\..\adler32.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\compress.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\crc32.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\deflate.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\masmx86\gvmat32c.c"
-				>
-				<FileConfiguration
-					Name="Debug|x64"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|x64"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|x64"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\..\..\gzio.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\infback.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\masmx64\inffas8664.c"
-				>
-				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Debug|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="ReleaseWithoutAsm|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Win32"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Itanium"
-					ExcludedFromBuild="true"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\..\..\inffast.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\inflate.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\inftrees.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\minizip\ioapi.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\minizip\iowin32.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\trees.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\uncompr.c"
-				>
-			</File>
-			<File
-				RelativePath="..\..\minizip\unzip.c"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions="ZLIB_INTERNAL"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|x64"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions="ZLIB_INTERNAL"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Itanium"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions="ZLIB_INTERNAL"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath="..\..\minizip\zip.c"
-				>
-				<FileConfiguration
-					Name="Release|Win32"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions="ZLIB_INTERNAL"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|x64"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions="ZLIB_INTERNAL"
-					/>
-				</FileConfiguration>
-				<FileConfiguration
-					Name="Release|Itanium"
-					>
-					<Tool
-						Name="VCCLCompilerTool"
-						AdditionalIncludeDirectories=""
-						PreprocessorDefinitions="ZLIB_INTERNAL"
-					/>
-				</FileConfiguration>
-			</File>
-			<File
-				RelativePath=".\zlib.rc"
-				>
-			</File>
-			<File
-				RelativePath=".\zlibvc.def"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\zutil.c"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;fi;fd"
-			>
-			<File
-				RelativePath="..\..\..\deflate.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\infblock.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\infcodes.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\inffast.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\inftrees.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\infutil.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\zconf.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\zlib.h"
-				>
-			</File>
-			<File
-				RelativePath="..\..\..\zutil.h"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="ico;cur;bmp;dlg;rc2;rct;bin;cnt;rtf;gif;jpg;jpeg;jpe"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
diff -Nbaur gcc-4.6.3/zlib/crc32.c gcc-4.6.3-psp/zlib/crc32.c
--- gcc-4.6.3/zlib/crc32.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/crc32.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,423 +0,0 @@
-/* crc32.c -- compute the CRC-32 of a data stream
- * Copyright (C) 1995-2005 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster
- * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing
- * tables for updating the shift register in one step with three exclusive-ors
- * instead of four steps with four exclusive-ors.  This results in about a
- * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.
- */
-
-/* @(#) $Id: crc32.c,v 1.1.1.2 2002/03/11 21:53:23 tromey Exp $ */
-
-/*
-  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
-  protection on the static variables used to control the first-use generation
-  of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should
-  first call get_crc_table() to initialize the tables before allowing more than
-  one thread to use crc32().
- */
-
-#ifdef MAKECRCH
-#  include <stdio.h>
-#  ifndef DYNAMIC_CRC_TABLE
-#    define DYNAMIC_CRC_TABLE
-#  endif /* !DYNAMIC_CRC_TABLE */
-#endif /* MAKECRCH */
-
-#include "zutil.h"      /* for STDC and FAR definitions */
-
-#define local static
-
-/* Find a four-byte integer type for crc32_little() and crc32_big(). */
-#ifndef NOBYFOUR
-#  ifdef STDC           /* need ANSI C limits.h to determine sizes */
-#    include <limits.h>
-#    define BYFOUR
-#    if (UINT_MAX == 0xffffffffUL)
-       typedef unsigned int u4;
-#    else
-#      if (ULONG_MAX == 0xffffffffUL)
-         typedef unsigned long u4;
-#      else
-#        if (USHRT_MAX == 0xffffffffUL)
-           typedef unsigned short u4;
-#        else
-#          undef BYFOUR     /* can't find a four-byte integer type! */
-#        endif
-#      endif
-#    endif
-#  endif /* STDC */
-#endif /* !NOBYFOUR */
-
-/* Definitions for doing the crc four data bytes at a time. */
-#ifdef BYFOUR
-#  define REV(w) (((w)>>24)+(((w)>>8)&0xff00)+ \
-                (((w)&0xff00)<<8)+(((w)&0xff)<<24))
-   local unsigned long crc32_little OF((unsigned long,
-                        const unsigned char FAR *, unsigned));
-   local unsigned long crc32_big OF((unsigned long,
-                        const unsigned char FAR *, unsigned));
-#  define TBLS 8
-#else
-#  define TBLS 1
-#endif /* BYFOUR */
-
-/* Local functions for crc concatenation */
-local unsigned long gf2_matrix_times OF((unsigned long *mat,
-                                         unsigned long vec));
-local void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));
-
-#ifdef DYNAMIC_CRC_TABLE
-
-local volatile int crc_table_empty = 1;
-local unsigned long FAR crc_table[TBLS][256];
-local void make_crc_table OF((void));
-#ifdef MAKECRCH
-   local void write_table OF((FILE *, const unsigned long FAR *));
-#endif /* MAKECRCH */
-/*
-  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
-  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
-
-  Polynomials over GF(2) are represented in binary, one bit per coefficient,
-  with the lowest powers in the most significant bit.  Then adding polynomials
-  is just exclusive-or, and multiplying a polynomial by x is a right shift by
-  one.  If we call the above polynomial p, and represent a byte as the
-  polynomial q, also with the lowest power in the most significant bit (so the
-  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
-  where a mod b means the remainder after dividing a by b.
-
-  This calculation is done using the shift-register method of multiplying and
-  taking the remainder.  The register is initialized to zero, and for each
-  incoming bit, x^32 is added mod p to the register if the bit is a one (where
-  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
-  x (which is shifting right by one and adding x^32 mod p if the bit shifted
-  out is a one).  We start with the highest power (least significant bit) of
-  q and repeat for all eight bits of q.
-
-  The first table is simply the CRC of all possible eight bit values.  This is
-  all the information needed to generate CRCs on data a byte at a time for all
-  combinations of CRC register values and incoming bytes.  The remaining tables
-  allow for word-at-a-time CRC calculation for both big-endian and little-
-  endian machines, where a word is four bytes.
-*/
-local void make_crc_table()
-{
-    unsigned long c;
-    int n, k;
-    unsigned long poly;                 /* polynomial exclusive-or pattern */
-    /* terms of polynomial defining this crc (except x^32): */
-    static volatile int first = 1;      /* flag to limit concurrent making */
-    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
-
-    /* See if another task is already doing this (not thread-safe, but better
-       than nothing -- significantly reduces duration of vulnerability in
-       case the advice about DYNAMIC_CRC_TABLE is ignored) */
-    if (first) {
-        first = 0;
-
-        /* make exclusive-or pattern from polynomial (0xedb88320UL) */
-        poly = 0UL;
-        for (n = 0; n < sizeof(p)/sizeof(unsigned char); n++)
-            poly |= 1UL << (31 - p[n]);
-
-        /* generate a crc for every 8-bit value */
-        for (n = 0; n < 256; n++) {
-            c = (unsigned long)n;
-            for (k = 0; k < 8; k++)
-                c = c & 1 ? poly ^ (c >> 1) : c >> 1;
-            crc_table[0][n] = c;
-        }
-
-#ifdef BYFOUR
-        /* generate crc for each value followed by one, two, and three zeros,
-           and then the byte reversal of those as well as the first table */
-        for (n = 0; n < 256; n++) {
-            c = crc_table[0][n];
-            crc_table[4][n] = REV(c);
-            for (k = 1; k < 4; k++) {
-                c = crc_table[0][c & 0xff] ^ (c >> 8);
-                crc_table[k][n] = c;
-                crc_table[k + 4][n] = REV(c);
-            }
-        }
-#endif /* BYFOUR */
-
-        crc_table_empty = 0;
-    }
-    else {      /* not first */
-        /* wait for the other guy to finish (not efficient, but rare) */
-        while (crc_table_empty)
-            ;
-    }
-
-#ifdef MAKECRCH
-    /* write out CRC tables to crc32.h */
-    {
-        FILE *out;
-
-        out = fopen("crc32.h", "w");
-        if (out == NULL) return;
-        fprintf(out, "/* crc32.h -- tables for rapid CRC calculation\n");
-        fprintf(out, " * Generated automatically by crc32.c\n */\n\n");
-        fprintf(out, "local const unsigned long FAR ");
-        fprintf(out, "crc_table[TBLS][256] =\n{\n  {\n");
-        write_table(out, crc_table[0]);
-#  ifdef BYFOUR
-        fprintf(out, "#ifdef BYFOUR\n");
-        for (k = 1; k < 8; k++) {
-            fprintf(out, "  },\n  {\n");
-            write_table(out, crc_table[k]);
-        }
-        fprintf(out, "#endif\n");
-#  endif /* BYFOUR */
-        fprintf(out, "  }\n};\n");
-        fclose(out);
-    }
-#endif /* MAKECRCH */
-}
-
-#ifdef MAKECRCH
-local void write_table(out, table)
-    FILE *out;
-    const unsigned long FAR *table;
-{
-    int n;
-
-    for (n = 0; n < 256; n++)
-        fprintf(out, "%s0x%08lxUL%s", n % 5 ? "" : "    ", table[n],
-                n == 255 ? "\n" : (n % 5 == 4 ? ",\n" : ", "));
-}
-#endif /* MAKECRCH */
-
-#else /* !DYNAMIC_CRC_TABLE */
-/* ========================================================================
- * Tables of CRC-32s of all single-byte values, made by make_crc_table().
- */
-#include "crc32.h"
-#endif /* DYNAMIC_CRC_TABLE */
-
-/* =========================================================================
- * This function can be used by asm versions of crc32()
- */
-const unsigned long FAR * ZEXPORT get_crc_table()
-{
-#ifdef DYNAMIC_CRC_TABLE
-    if (crc_table_empty)
-        make_crc_table();
-#endif /* DYNAMIC_CRC_TABLE */
-    return (const unsigned long FAR *)crc_table;
-}
-
-/* ========================================================================= */
-#define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8)
-#define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1
-
-/* ========================================================================= */
-unsigned long ZEXPORT crc32(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    unsigned len;
-{
-    if (buf == Z_NULL) return 0UL;
-
-#ifdef DYNAMIC_CRC_TABLE
-    if (crc_table_empty)
-        make_crc_table();
-#endif /* DYNAMIC_CRC_TABLE */
-
-#ifdef BYFOUR
-    if (sizeof(void *) == sizeof(ptrdiff_t)) {
-        u4 endian;
-
-        endian = 1;
-        if (*((unsigned char *)(&endian)))
-            return crc32_little(crc, buf, len);
-        else
-            return crc32_big(crc, buf, len);
-    }
-#endif /* BYFOUR */
-    crc = crc ^ 0xffffffffUL;
-    while (len >= 8) {
-        DO8;
-        len -= 8;
-    }
-    if (len) do {
-        DO1;
-    } while (--len);
-    return crc ^ 0xffffffffUL;
-}
-
-#ifdef BYFOUR
-
-/* ========================================================================= */
-#define DOLIT4 c ^= *buf4++; \
-        c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ \
-            crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24]
-#define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4
-
-/* ========================================================================= */
-local unsigned long crc32_little(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    unsigned len;
-{
-    register u4 c;
-    register const u4 FAR *buf4;
-
-    c = (u4)crc;
-    c = ~c;
-    while (len && ((ptrdiff_t)buf & 3)) {
-        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
-        len--;
-    }
-
-    buf4 = (const u4 FAR *)(const void FAR *)buf;
-    while (len >= 32) {
-        DOLIT32;
-        len -= 32;
-    }
-    while (len >= 4) {
-        DOLIT4;
-        len -= 4;
-    }
-    buf = (const unsigned char FAR *)buf4;
-
-    if (len) do {
-        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
-    } while (--len);
-    c = ~c;
-    return (unsigned long)c;
-}
-
-/* ========================================================================= */
-#define DOBIG4 c ^= *++buf4; \
-        c = crc_table[4][c & 0xff] ^ crc_table[5][(c >> 8) & 0xff] ^ \
-            crc_table[6][(c >> 16) & 0xff] ^ crc_table[7][c >> 24]
-#define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4
-
-/* ========================================================================= */
-local unsigned long crc32_big(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    unsigned len;
-{
-    register u4 c;
-    register const u4 FAR *buf4;
-
-    c = REV((u4)crc);
-    c = ~c;
-    while (len && ((ptrdiff_t)buf & 3)) {
-        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
-        len--;
-    }
-
-    buf4 = (const u4 FAR *)(const void FAR *)buf;
-    buf4--;
-    while (len >= 32) {
-        DOBIG32;
-        len -= 32;
-    }
-    while (len >= 4) {
-        DOBIG4;
-        len -= 4;
-    }
-    buf4++;
-    buf = (const unsigned char FAR *)buf4;
-
-    if (len) do {
-        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
-    } while (--len);
-    c = ~c;
-    return (unsigned long)(REV(c));
-}
-
-#endif /* BYFOUR */
-
-#define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */
-
-/* ========================================================================= */
-local unsigned long gf2_matrix_times(mat, vec)
-    unsigned long *mat;
-    unsigned long vec;
-{
-    unsigned long sum;
-
-    sum = 0;
-    while (vec) {
-        if (vec & 1)
-            sum ^= *mat;
-        vec >>= 1;
-        mat++;
-    }
-    return sum;
-}
-
-/* ========================================================================= */
-local void gf2_matrix_square(square, mat)
-    unsigned long *square;
-    unsigned long *mat;
-{
-    int n;
-
-    for (n = 0; n < GF2_DIM; n++)
-        square[n] = gf2_matrix_times(mat, mat[n]);
-}
-
-/* ========================================================================= */
-uLong ZEXPORT crc32_combine(crc1, crc2, len2)
-    uLong crc1;
-    uLong crc2;
-    z_off_t len2;
-{
-    int n;
-    unsigned long row;
-    unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */
-    unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */
-
-    /* degenerate case */
-    if (len2 == 0)
-        return crc1;
-
-    /* put operator for one zero bit in odd */
-    odd[0] = 0xedb88320L;           /* CRC-32 polynomial */
-    row = 1;
-    for (n = 1; n < GF2_DIM; n++) {
-        odd[n] = row;
-        row <<= 1;
-    }
-
-    /* put operator for two zero bits in even */
-    gf2_matrix_square(even, odd);
-
-    /* put operator for four zero bits in odd */
-    gf2_matrix_square(odd, even);
-
-    /* apply len2 zeros to crc1 (first square will put the operator for one
-       zero byte, eight zero bits, in even) */
-    do {
-        /* apply zeros operator for this bit of len2 */
-        gf2_matrix_square(even, odd);
-        if (len2 & 1)
-            crc1 = gf2_matrix_times(even, crc1);
-        len2 >>= 1;
-
-        /* if no more bits set, then done */
-        if (len2 == 0)
-            break;
-
-        /* another iteration of the loop with odd and even swapped */
-        gf2_matrix_square(odd, even);
-        if (len2 & 1)
-            crc1 = gf2_matrix_times(odd, crc1);
-        len2 >>= 1;
-
-        /* if no more bits set, then done */
-    } while (len2 != 0);
-
-    /* return combined crc */
-    crc1 ^= crc2;
-    return crc1;
-}
diff -Nbaur gcc-4.6.3/zlib/crc32.h gcc-4.6.3-psp/zlib/crc32.h
--- gcc-4.6.3/zlib/crc32.h	2005-09-12 18:02:07.000000000 +0100
+++ gcc-4.6.3-psp/zlib/crc32.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,441 +0,0 @@
-/* crc32.h -- tables for rapid CRC calculation
- * Generated automatically by crc32.c
- */
-
-local const unsigned long FAR crc_table[TBLS][256] =
-{
-  {
-    0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
-    0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,
-    0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,
-    0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,
-    0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,
-    0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,
-    0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,
-    0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,
-    0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,
-    0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,
-    0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,
-    0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,
-    0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,
-    0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,
-    0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,
-    0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,
-    0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,
-    0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,
-    0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,
-    0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,
-    0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,
-    0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,
-    0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,
-    0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,
-    0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,
-    0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,
-    0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,
-    0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,
-    0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,
-    0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,
-    0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,
-    0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,
-    0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,
-    0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,
-    0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,
-    0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,
-    0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,
-    0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,
-    0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,
-    0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,
-    0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,
-    0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,
-    0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,
-    0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,
-    0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,
-    0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,
-    0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,
-    0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,
-    0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,
-    0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,
-    0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,
-    0x2d02ef8dUL
-#ifdef BYFOUR
-  },
-  {
-    0x00000000UL, 0x191b3141UL, 0x32366282UL, 0x2b2d53c3UL, 0x646cc504UL,
-    0x7d77f445UL, 0x565aa786UL, 0x4f4196c7UL, 0xc8d98a08UL, 0xd1c2bb49UL,
-    0xfaefe88aUL, 0xe3f4d9cbUL, 0xacb54f0cUL, 0xb5ae7e4dUL, 0x9e832d8eUL,
-    0x87981ccfUL, 0x4ac21251UL, 0x53d92310UL, 0x78f470d3UL, 0x61ef4192UL,
-    0x2eaed755UL, 0x37b5e614UL, 0x1c98b5d7UL, 0x05838496UL, 0x821b9859UL,
-    0x9b00a918UL, 0xb02dfadbUL, 0xa936cb9aUL, 0xe6775d5dUL, 0xff6c6c1cUL,
-    0xd4413fdfUL, 0xcd5a0e9eUL, 0x958424a2UL, 0x8c9f15e3UL, 0xa7b24620UL,
-    0xbea97761UL, 0xf1e8e1a6UL, 0xe8f3d0e7UL, 0xc3de8324UL, 0xdac5b265UL,
-    0x5d5daeaaUL, 0x44469febUL, 0x6f6bcc28UL, 0x7670fd69UL, 0x39316baeUL,
-    0x202a5aefUL, 0x0b07092cUL, 0x121c386dUL, 0xdf4636f3UL, 0xc65d07b2UL,
-    0xed705471UL, 0xf46b6530UL, 0xbb2af3f7UL, 0xa231c2b6UL, 0x891c9175UL,
-    0x9007a034UL, 0x179fbcfbUL, 0x0e848dbaUL, 0x25a9de79UL, 0x3cb2ef38UL,
-    0x73f379ffUL, 0x6ae848beUL, 0x41c51b7dUL, 0x58de2a3cUL, 0xf0794f05UL,
-    0xe9627e44UL, 0xc24f2d87UL, 0xdb541cc6UL, 0x94158a01UL, 0x8d0ebb40UL,
-    0xa623e883UL, 0xbf38d9c2UL, 0x38a0c50dUL, 0x21bbf44cUL, 0x0a96a78fUL,
-    0x138d96ceUL, 0x5ccc0009UL, 0x45d73148UL, 0x6efa628bUL, 0x77e153caUL,
-    0xbabb5d54UL, 0xa3a06c15UL, 0x888d3fd6UL, 0x91960e97UL, 0xded79850UL,
-    0xc7cca911UL, 0xece1fad2UL, 0xf5facb93UL, 0x7262d75cUL, 0x6b79e61dUL,
-    0x4054b5deUL, 0x594f849fUL, 0x160e1258UL, 0x0f152319UL, 0x243870daUL,
-    0x3d23419bUL, 0x65fd6ba7UL, 0x7ce65ae6UL, 0x57cb0925UL, 0x4ed03864UL,
-    0x0191aea3UL, 0x188a9fe2UL, 0x33a7cc21UL, 0x2abcfd60UL, 0xad24e1afUL,
-    0xb43fd0eeUL, 0x9f12832dUL, 0x8609b26cUL, 0xc94824abUL, 0xd05315eaUL,
-    0xfb7e4629UL, 0xe2657768UL, 0x2f3f79f6UL, 0x362448b7UL, 0x1d091b74UL,
-    0x04122a35UL, 0x4b53bcf2UL, 0x52488db3UL, 0x7965de70UL, 0x607eef31UL,
-    0xe7e6f3feUL, 0xfefdc2bfUL, 0xd5d0917cUL, 0xcccba03dUL, 0x838a36faUL,
-    0x9a9107bbUL, 0xb1bc5478UL, 0xa8a76539UL, 0x3b83984bUL, 0x2298a90aUL,
-    0x09b5fac9UL, 0x10aecb88UL, 0x5fef5d4fUL, 0x46f46c0eUL, 0x6dd93fcdUL,
-    0x74c20e8cUL, 0xf35a1243UL, 0xea412302UL, 0xc16c70c1UL, 0xd8774180UL,
-    0x9736d747UL, 0x8e2de606UL, 0xa500b5c5UL, 0xbc1b8484UL, 0x71418a1aUL,
-    0x685abb5bUL, 0x4377e898UL, 0x5a6cd9d9UL, 0x152d4f1eUL, 0x0c367e5fUL,
-    0x271b2d9cUL, 0x3e001cddUL, 0xb9980012UL, 0xa0833153UL, 0x8bae6290UL,
-    0x92b553d1UL, 0xddf4c516UL, 0xc4eff457UL, 0xefc2a794UL, 0xf6d996d5UL,
-    0xae07bce9UL, 0xb71c8da8UL, 0x9c31de6bUL, 0x852aef2aUL, 0xca6b79edUL,
-    0xd37048acUL, 0xf85d1b6fUL, 0xe1462a2eUL, 0x66de36e1UL, 0x7fc507a0UL,
-    0x54e85463UL, 0x4df36522UL, 0x02b2f3e5UL, 0x1ba9c2a4UL, 0x30849167UL,
-    0x299fa026UL, 0xe4c5aeb8UL, 0xfdde9ff9UL, 0xd6f3cc3aUL, 0xcfe8fd7bUL,
-    0x80a96bbcUL, 0x99b25afdUL, 0xb29f093eUL, 0xab84387fUL, 0x2c1c24b0UL,
-    0x350715f1UL, 0x1e2a4632UL, 0x07317773UL, 0x4870e1b4UL, 0x516bd0f5UL,
-    0x7a468336UL, 0x635db277UL, 0xcbfad74eUL, 0xd2e1e60fUL, 0xf9ccb5ccUL,
-    0xe0d7848dUL, 0xaf96124aUL, 0xb68d230bUL, 0x9da070c8UL, 0x84bb4189UL,
-    0x03235d46UL, 0x1a386c07UL, 0x31153fc4UL, 0x280e0e85UL, 0x674f9842UL,
-    0x7e54a903UL, 0x5579fac0UL, 0x4c62cb81UL, 0x8138c51fUL, 0x9823f45eUL,
-    0xb30ea79dUL, 0xaa1596dcUL, 0xe554001bUL, 0xfc4f315aUL, 0xd7626299UL,
-    0xce7953d8UL, 0x49e14f17UL, 0x50fa7e56UL, 0x7bd72d95UL, 0x62cc1cd4UL,
-    0x2d8d8a13UL, 0x3496bb52UL, 0x1fbbe891UL, 0x06a0d9d0UL, 0x5e7ef3ecUL,
-    0x4765c2adUL, 0x6c48916eUL, 0x7553a02fUL, 0x3a1236e8UL, 0x230907a9UL,
-    0x0824546aUL, 0x113f652bUL, 0x96a779e4UL, 0x8fbc48a5UL, 0xa4911b66UL,
-    0xbd8a2a27UL, 0xf2cbbce0UL, 0xebd08da1UL, 0xc0fdde62UL, 0xd9e6ef23UL,
-    0x14bce1bdUL, 0x0da7d0fcUL, 0x268a833fUL, 0x3f91b27eUL, 0x70d024b9UL,
-    0x69cb15f8UL, 0x42e6463bUL, 0x5bfd777aUL, 0xdc656bb5UL, 0xc57e5af4UL,
-    0xee530937UL, 0xf7483876UL, 0xb809aeb1UL, 0xa1129ff0UL, 0x8a3fcc33UL,
-    0x9324fd72UL
-  },
-  {
-    0x00000000UL, 0x01c26a37UL, 0x0384d46eUL, 0x0246be59UL, 0x0709a8dcUL,
-    0x06cbc2ebUL, 0x048d7cb2UL, 0x054f1685UL, 0x0e1351b8UL, 0x0fd13b8fUL,
-    0x0d9785d6UL, 0x0c55efe1UL, 0x091af964UL, 0x08d89353UL, 0x0a9e2d0aUL,
-    0x0b5c473dUL, 0x1c26a370UL, 0x1de4c947UL, 0x1fa2771eUL, 0x1e601d29UL,
-    0x1b2f0bacUL, 0x1aed619bUL, 0x18abdfc2UL, 0x1969b5f5UL, 0x1235f2c8UL,
-    0x13f798ffUL, 0x11b126a6UL, 0x10734c91UL, 0x153c5a14UL, 0x14fe3023UL,
-    0x16b88e7aUL, 0x177ae44dUL, 0x384d46e0UL, 0x398f2cd7UL, 0x3bc9928eUL,
-    0x3a0bf8b9UL, 0x3f44ee3cUL, 0x3e86840bUL, 0x3cc03a52UL, 0x3d025065UL,
-    0x365e1758UL, 0x379c7d6fUL, 0x35dac336UL, 0x3418a901UL, 0x3157bf84UL,
-    0x3095d5b3UL, 0x32d36beaUL, 0x331101ddUL, 0x246be590UL, 0x25a98fa7UL,
-    0x27ef31feUL, 0x262d5bc9UL, 0x23624d4cUL, 0x22a0277bUL, 0x20e69922UL,
-    0x2124f315UL, 0x2a78b428UL, 0x2bbade1fUL, 0x29fc6046UL, 0x283e0a71UL,
-    0x2d711cf4UL, 0x2cb376c3UL, 0x2ef5c89aUL, 0x2f37a2adUL, 0x709a8dc0UL,
-    0x7158e7f7UL, 0x731e59aeUL, 0x72dc3399UL, 0x7793251cUL, 0x76514f2bUL,
-    0x7417f172UL, 0x75d59b45UL, 0x7e89dc78UL, 0x7f4bb64fUL, 0x7d0d0816UL,
-    0x7ccf6221UL, 0x798074a4UL, 0x78421e93UL, 0x7a04a0caUL, 0x7bc6cafdUL,
-    0x6cbc2eb0UL, 0x6d7e4487UL, 0x6f38fadeUL, 0x6efa90e9UL, 0x6bb5866cUL,
-    0x6a77ec5bUL, 0x68315202UL, 0x69f33835UL, 0x62af7f08UL, 0x636d153fUL,
-    0x612bab66UL, 0x60e9c151UL, 0x65a6d7d4UL, 0x6464bde3UL, 0x662203baUL,
-    0x67e0698dUL, 0x48d7cb20UL, 0x4915a117UL, 0x4b531f4eUL, 0x4a917579UL,
-    0x4fde63fcUL, 0x4e1c09cbUL, 0x4c5ab792UL, 0x4d98dda5UL, 0x46c49a98UL,
-    0x4706f0afUL, 0x45404ef6UL, 0x448224c1UL, 0x41cd3244UL, 0x400f5873UL,
-    0x4249e62aUL, 0x438b8c1dUL, 0x54f16850UL, 0x55330267UL, 0x5775bc3eUL,
-    0x56b7d609UL, 0x53f8c08cUL, 0x523aaabbUL, 0x507c14e2UL, 0x51be7ed5UL,
-    0x5ae239e8UL, 0x5b2053dfUL, 0x5966ed86UL, 0x58a487b1UL, 0x5deb9134UL,
-    0x5c29fb03UL, 0x5e6f455aUL, 0x5fad2f6dUL, 0xe1351b80UL, 0xe0f771b7UL,
-    0xe2b1cfeeUL, 0xe373a5d9UL, 0xe63cb35cUL, 0xe7fed96bUL, 0xe5b86732UL,
-    0xe47a0d05UL, 0xef264a38UL, 0xeee4200fUL, 0xeca29e56UL, 0xed60f461UL,
-    0xe82fe2e4UL, 0xe9ed88d3UL, 0xebab368aUL, 0xea695cbdUL, 0xfd13b8f0UL,
-    0xfcd1d2c7UL, 0xfe976c9eUL, 0xff5506a9UL, 0xfa1a102cUL, 0xfbd87a1bUL,
-    0xf99ec442UL, 0xf85cae75UL, 0xf300e948UL, 0xf2c2837fUL, 0xf0843d26UL,
-    0xf1465711UL, 0xf4094194UL, 0xf5cb2ba3UL, 0xf78d95faUL, 0xf64fffcdUL,
-    0xd9785d60UL, 0xd8ba3757UL, 0xdafc890eUL, 0xdb3ee339UL, 0xde71f5bcUL,
-    0xdfb39f8bUL, 0xddf521d2UL, 0xdc374be5UL, 0xd76b0cd8UL, 0xd6a966efUL,
-    0xd4efd8b6UL, 0xd52db281UL, 0xd062a404UL, 0xd1a0ce33UL, 0xd3e6706aUL,
-    0xd2241a5dUL, 0xc55efe10UL, 0xc49c9427UL, 0xc6da2a7eUL, 0xc7184049UL,
-    0xc25756ccUL, 0xc3953cfbUL, 0xc1d382a2UL, 0xc011e895UL, 0xcb4dafa8UL,
-    0xca8fc59fUL, 0xc8c97bc6UL, 0xc90b11f1UL, 0xcc440774UL, 0xcd866d43UL,
-    0xcfc0d31aUL, 0xce02b92dUL, 0x91af9640UL, 0x906dfc77UL, 0x922b422eUL,
-    0x93e92819UL, 0x96a63e9cUL, 0x976454abUL, 0x9522eaf2UL, 0x94e080c5UL,
-    0x9fbcc7f8UL, 0x9e7eadcfUL, 0x9c381396UL, 0x9dfa79a1UL, 0x98b56f24UL,
-    0x99770513UL, 0x9b31bb4aUL, 0x9af3d17dUL, 0x8d893530UL, 0x8c4b5f07UL,
-    0x8e0de15eUL, 0x8fcf8b69UL, 0x8a809decUL, 0x8b42f7dbUL, 0x89044982UL,
-    0x88c623b5UL, 0x839a6488UL, 0x82580ebfUL, 0x801eb0e6UL, 0x81dcdad1UL,
-    0x8493cc54UL, 0x8551a663UL, 0x8717183aUL, 0x86d5720dUL, 0xa9e2d0a0UL,
-    0xa820ba97UL, 0xaa6604ceUL, 0xaba46ef9UL, 0xaeeb787cUL, 0xaf29124bUL,
-    0xad6fac12UL, 0xacadc625UL, 0xa7f18118UL, 0xa633eb2fUL, 0xa4755576UL,
-    0xa5b73f41UL, 0xa0f829c4UL, 0xa13a43f3UL, 0xa37cfdaaUL, 0xa2be979dUL,
-    0xb5c473d0UL, 0xb40619e7UL, 0xb640a7beUL, 0xb782cd89UL, 0xb2cddb0cUL,
-    0xb30fb13bUL, 0xb1490f62UL, 0xb08b6555UL, 0xbbd72268UL, 0xba15485fUL,
-    0xb853f606UL, 0xb9919c31UL, 0xbcde8ab4UL, 0xbd1ce083UL, 0xbf5a5edaUL,
-    0xbe9834edUL
-  },
-  {
-    0x00000000UL, 0xb8bc6765UL, 0xaa09c88bUL, 0x12b5afeeUL, 0x8f629757UL,
-    0x37def032UL, 0x256b5fdcUL, 0x9dd738b9UL, 0xc5b428efUL, 0x7d084f8aUL,
-    0x6fbde064UL, 0xd7018701UL, 0x4ad6bfb8UL, 0xf26ad8ddUL, 0xe0df7733UL,
-    0x58631056UL, 0x5019579fUL, 0xe8a530faUL, 0xfa109f14UL, 0x42acf871UL,
-    0xdf7bc0c8UL, 0x67c7a7adUL, 0x75720843UL, 0xcdce6f26UL, 0x95ad7f70UL,
-    0x2d111815UL, 0x3fa4b7fbUL, 0x8718d09eUL, 0x1acfe827UL, 0xa2738f42UL,
-    0xb0c620acUL, 0x087a47c9UL, 0xa032af3eUL, 0x188ec85bUL, 0x0a3b67b5UL,
-    0xb28700d0UL, 0x2f503869UL, 0x97ec5f0cUL, 0x8559f0e2UL, 0x3de59787UL,
-    0x658687d1UL, 0xdd3ae0b4UL, 0xcf8f4f5aUL, 0x7733283fUL, 0xeae41086UL,
-    0x525877e3UL, 0x40edd80dUL, 0xf851bf68UL, 0xf02bf8a1UL, 0x48979fc4UL,
-    0x5a22302aUL, 0xe29e574fUL, 0x7f496ff6UL, 0xc7f50893UL, 0xd540a77dUL,
-    0x6dfcc018UL, 0x359fd04eUL, 0x8d23b72bUL, 0x9f9618c5UL, 0x272a7fa0UL,
-    0xbafd4719UL, 0x0241207cUL, 0x10f48f92UL, 0xa848e8f7UL, 0x9b14583dUL,
-    0x23a83f58UL, 0x311d90b6UL, 0x89a1f7d3UL, 0x1476cf6aUL, 0xaccaa80fUL,
-    0xbe7f07e1UL, 0x06c36084UL, 0x5ea070d2UL, 0xe61c17b7UL, 0xf4a9b859UL,
-    0x4c15df3cUL, 0xd1c2e785UL, 0x697e80e0UL, 0x7bcb2f0eUL, 0xc377486bUL,
-    0xcb0d0fa2UL, 0x73b168c7UL, 0x6104c729UL, 0xd9b8a04cUL, 0x446f98f5UL,
-    0xfcd3ff90UL, 0xee66507eUL, 0x56da371bUL, 0x0eb9274dUL, 0xb6054028UL,
-    0xa4b0efc6UL, 0x1c0c88a3UL, 0x81dbb01aUL, 0x3967d77fUL, 0x2bd27891UL,
-    0x936e1ff4UL, 0x3b26f703UL, 0x839a9066UL, 0x912f3f88UL, 0x299358edUL,
-    0xb4446054UL, 0x0cf80731UL, 0x1e4da8dfUL, 0xa6f1cfbaUL, 0xfe92dfecUL,
-    0x462eb889UL, 0x549b1767UL, 0xec277002UL, 0x71f048bbUL, 0xc94c2fdeUL,
-    0xdbf98030UL, 0x6345e755UL, 0x6b3fa09cUL, 0xd383c7f9UL, 0xc1366817UL,
-    0x798a0f72UL, 0xe45d37cbUL, 0x5ce150aeUL, 0x4e54ff40UL, 0xf6e89825UL,
-    0xae8b8873UL, 0x1637ef16UL, 0x048240f8UL, 0xbc3e279dUL, 0x21e91f24UL,
-    0x99557841UL, 0x8be0d7afUL, 0x335cb0caUL, 0xed59b63bUL, 0x55e5d15eUL,
-    0x47507eb0UL, 0xffec19d5UL, 0x623b216cUL, 0xda874609UL, 0xc832e9e7UL,
-    0x708e8e82UL, 0x28ed9ed4UL, 0x9051f9b1UL, 0x82e4565fUL, 0x3a58313aUL,
-    0xa78f0983UL, 0x1f336ee6UL, 0x0d86c108UL, 0xb53aa66dUL, 0xbd40e1a4UL,
-    0x05fc86c1UL, 0x1749292fUL, 0xaff54e4aUL, 0x322276f3UL, 0x8a9e1196UL,
-    0x982bbe78UL, 0x2097d91dUL, 0x78f4c94bUL, 0xc048ae2eUL, 0xd2fd01c0UL,
-    0x6a4166a5UL, 0xf7965e1cUL, 0x4f2a3979UL, 0x5d9f9697UL, 0xe523f1f2UL,
-    0x4d6b1905UL, 0xf5d77e60UL, 0xe762d18eUL, 0x5fdeb6ebUL, 0xc2098e52UL,
-    0x7ab5e937UL, 0x680046d9UL, 0xd0bc21bcUL, 0x88df31eaUL, 0x3063568fUL,
-    0x22d6f961UL, 0x9a6a9e04UL, 0x07bda6bdUL, 0xbf01c1d8UL, 0xadb46e36UL,
-    0x15080953UL, 0x1d724e9aUL, 0xa5ce29ffUL, 0xb77b8611UL, 0x0fc7e174UL,
-    0x9210d9cdUL, 0x2aacbea8UL, 0x38191146UL, 0x80a57623UL, 0xd8c66675UL,
-    0x607a0110UL, 0x72cfaefeUL, 0xca73c99bUL, 0x57a4f122UL, 0xef189647UL,
-    0xfdad39a9UL, 0x45115eccUL, 0x764dee06UL, 0xcef18963UL, 0xdc44268dUL,
-    0x64f841e8UL, 0xf92f7951UL, 0x41931e34UL, 0x5326b1daUL, 0xeb9ad6bfUL,
-    0xb3f9c6e9UL, 0x0b45a18cUL, 0x19f00e62UL, 0xa14c6907UL, 0x3c9b51beUL,
-    0x842736dbUL, 0x96929935UL, 0x2e2efe50UL, 0x2654b999UL, 0x9ee8defcUL,
-    0x8c5d7112UL, 0x34e11677UL, 0xa9362eceUL, 0x118a49abUL, 0x033fe645UL,
-    0xbb838120UL, 0xe3e09176UL, 0x5b5cf613UL, 0x49e959fdUL, 0xf1553e98UL,
-    0x6c820621UL, 0xd43e6144UL, 0xc68bceaaUL, 0x7e37a9cfUL, 0xd67f4138UL,
-    0x6ec3265dUL, 0x7c7689b3UL, 0xc4caeed6UL, 0x591dd66fUL, 0xe1a1b10aUL,
-    0xf3141ee4UL, 0x4ba87981UL, 0x13cb69d7UL, 0xab770eb2UL, 0xb9c2a15cUL,
-    0x017ec639UL, 0x9ca9fe80UL, 0x241599e5UL, 0x36a0360bUL, 0x8e1c516eUL,
-    0x866616a7UL, 0x3eda71c2UL, 0x2c6fde2cUL, 0x94d3b949UL, 0x090481f0UL,
-    0xb1b8e695UL, 0xa30d497bUL, 0x1bb12e1eUL, 0x43d23e48UL, 0xfb6e592dUL,
-    0xe9dbf6c3UL, 0x516791a6UL, 0xccb0a91fUL, 0x740cce7aUL, 0x66b96194UL,
-    0xde0506f1UL
-  },
-  {
-    0x00000000UL, 0x96300777UL, 0x2c610eeeUL, 0xba510999UL, 0x19c46d07UL,
-    0x8ff46a70UL, 0x35a563e9UL, 0xa395649eUL, 0x3288db0eUL, 0xa4b8dc79UL,
-    0x1ee9d5e0UL, 0x88d9d297UL, 0x2b4cb609UL, 0xbd7cb17eUL, 0x072db8e7UL,
-    0x911dbf90UL, 0x6410b71dUL, 0xf220b06aUL, 0x4871b9f3UL, 0xde41be84UL,
-    0x7dd4da1aUL, 0xebe4dd6dUL, 0x51b5d4f4UL, 0xc785d383UL, 0x56986c13UL,
-    0xc0a86b64UL, 0x7af962fdUL, 0xecc9658aUL, 0x4f5c0114UL, 0xd96c0663UL,
-    0x633d0ffaUL, 0xf50d088dUL, 0xc8206e3bUL, 0x5e10694cUL, 0xe44160d5UL,
-    0x727167a2UL, 0xd1e4033cUL, 0x47d4044bUL, 0xfd850dd2UL, 0x6bb50aa5UL,
-    0xfaa8b535UL, 0x6c98b242UL, 0xd6c9bbdbUL, 0x40f9bcacUL, 0xe36cd832UL,
-    0x755cdf45UL, 0xcf0dd6dcUL, 0x593dd1abUL, 0xac30d926UL, 0x3a00de51UL,
-    0x8051d7c8UL, 0x1661d0bfUL, 0xb5f4b421UL, 0x23c4b356UL, 0x9995bacfUL,
-    0x0fa5bdb8UL, 0x9eb80228UL, 0x0888055fUL, 0xb2d90cc6UL, 0x24e90bb1UL,
-    0x877c6f2fUL, 0x114c6858UL, 0xab1d61c1UL, 0x3d2d66b6UL, 0x9041dc76UL,
-    0x0671db01UL, 0xbc20d298UL, 0x2a10d5efUL, 0x8985b171UL, 0x1fb5b606UL,
-    0xa5e4bf9fUL, 0x33d4b8e8UL, 0xa2c90778UL, 0x34f9000fUL, 0x8ea80996UL,
-    0x18980ee1UL, 0xbb0d6a7fUL, 0x2d3d6d08UL, 0x976c6491UL, 0x015c63e6UL,
-    0xf4516b6bUL, 0x62616c1cUL, 0xd8306585UL, 0x4e0062f2UL, 0xed95066cUL,
-    0x7ba5011bUL, 0xc1f40882UL, 0x57c40ff5UL, 0xc6d9b065UL, 0x50e9b712UL,
-    0xeab8be8bUL, 0x7c88b9fcUL, 0xdf1ddd62UL, 0x492dda15UL, 0xf37cd38cUL,
-    0x654cd4fbUL, 0x5861b24dUL, 0xce51b53aUL, 0x7400bca3UL, 0xe230bbd4UL,
-    0x41a5df4aUL, 0xd795d83dUL, 0x6dc4d1a4UL, 0xfbf4d6d3UL, 0x6ae96943UL,
-    0xfcd96e34UL, 0x468867adUL, 0xd0b860daUL, 0x732d0444UL, 0xe51d0333UL,
-    0x5f4c0aaaUL, 0xc97c0dddUL, 0x3c710550UL, 0xaa410227UL, 0x10100bbeUL,
-    0x86200cc9UL, 0x25b56857UL, 0xb3856f20UL, 0x09d466b9UL, 0x9fe461ceUL,
-    0x0ef9de5eUL, 0x98c9d929UL, 0x2298d0b0UL, 0xb4a8d7c7UL, 0x173db359UL,
-    0x810db42eUL, 0x3b5cbdb7UL, 0xad6cbac0UL, 0x2083b8edUL, 0xb6b3bf9aUL,
-    0x0ce2b603UL, 0x9ad2b174UL, 0x3947d5eaUL, 0xaf77d29dUL, 0x1526db04UL,
-    0x8316dc73UL, 0x120b63e3UL, 0x843b6494UL, 0x3e6a6d0dUL, 0xa85a6a7aUL,
-    0x0bcf0ee4UL, 0x9dff0993UL, 0x27ae000aUL, 0xb19e077dUL, 0x44930ff0UL,
-    0xd2a30887UL, 0x68f2011eUL, 0xfec20669UL, 0x5d5762f7UL, 0xcb676580UL,
-    0x71366c19UL, 0xe7066b6eUL, 0x761bd4feUL, 0xe02bd389UL, 0x5a7ada10UL,
-    0xcc4add67UL, 0x6fdfb9f9UL, 0xf9efbe8eUL, 0x43beb717UL, 0xd58eb060UL,
-    0xe8a3d6d6UL, 0x7e93d1a1UL, 0xc4c2d838UL, 0x52f2df4fUL, 0xf167bbd1UL,
-    0x6757bca6UL, 0xdd06b53fUL, 0x4b36b248UL, 0xda2b0dd8UL, 0x4c1b0aafUL,
-    0xf64a0336UL, 0x607a0441UL, 0xc3ef60dfUL, 0x55df67a8UL, 0xef8e6e31UL,
-    0x79be6946UL, 0x8cb361cbUL, 0x1a8366bcUL, 0xa0d26f25UL, 0x36e26852UL,
-    0x95770cccUL, 0x03470bbbUL, 0xb9160222UL, 0x2f260555UL, 0xbe3bbac5UL,
-    0x280bbdb2UL, 0x925ab42bUL, 0x046ab35cUL, 0xa7ffd7c2UL, 0x31cfd0b5UL,
-    0x8b9ed92cUL, 0x1daede5bUL, 0xb0c2649bUL, 0x26f263ecUL, 0x9ca36a75UL,
-    0x0a936d02UL, 0xa906099cUL, 0x3f360eebUL, 0x85670772UL, 0x13570005UL,
-    0x824abf95UL, 0x147ab8e2UL, 0xae2bb17bUL, 0x381bb60cUL, 0x9b8ed292UL,
-    0x0dbed5e5UL, 0xb7efdc7cUL, 0x21dfdb0bUL, 0xd4d2d386UL, 0x42e2d4f1UL,
-    0xf8b3dd68UL, 0x6e83da1fUL, 0xcd16be81UL, 0x5b26b9f6UL, 0xe177b06fUL,
-    0x7747b718UL, 0xe65a0888UL, 0x706a0fffUL, 0xca3b0666UL, 0x5c0b0111UL,
-    0xff9e658fUL, 0x69ae62f8UL, 0xd3ff6b61UL, 0x45cf6c16UL, 0x78e20aa0UL,
-    0xeed20dd7UL, 0x5483044eUL, 0xc2b30339UL, 0x612667a7UL, 0xf71660d0UL,
-    0x4d476949UL, 0xdb776e3eUL, 0x4a6ad1aeUL, 0xdc5ad6d9UL, 0x660bdf40UL,
-    0xf03bd837UL, 0x53aebca9UL, 0xc59ebbdeUL, 0x7fcfb247UL, 0xe9ffb530UL,
-    0x1cf2bdbdUL, 0x8ac2bacaUL, 0x3093b353UL, 0xa6a3b424UL, 0x0536d0baUL,
-    0x9306d7cdUL, 0x2957de54UL, 0xbf67d923UL, 0x2e7a66b3UL, 0xb84a61c4UL,
-    0x021b685dUL, 0x942b6f2aUL, 0x37be0bb4UL, 0xa18e0cc3UL, 0x1bdf055aUL,
-    0x8def022dUL
-  },
-  {
-    0x00000000UL, 0x41311b19UL, 0x82623632UL, 0xc3532d2bUL, 0x04c56c64UL,
-    0x45f4777dUL, 0x86a75a56UL, 0xc796414fUL, 0x088ad9c8UL, 0x49bbc2d1UL,
-    0x8ae8effaUL, 0xcbd9f4e3UL, 0x0c4fb5acUL, 0x4d7eaeb5UL, 0x8e2d839eUL,
-    0xcf1c9887UL, 0x5112c24aUL, 0x1023d953UL, 0xd370f478UL, 0x9241ef61UL,
-    0x55d7ae2eUL, 0x14e6b537UL, 0xd7b5981cUL, 0x96848305UL, 0x59981b82UL,
-    0x18a9009bUL, 0xdbfa2db0UL, 0x9acb36a9UL, 0x5d5d77e6UL, 0x1c6c6cffUL,
-    0xdf3f41d4UL, 0x9e0e5acdUL, 0xa2248495UL, 0xe3159f8cUL, 0x2046b2a7UL,
-    0x6177a9beUL, 0xa6e1e8f1UL, 0xe7d0f3e8UL, 0x2483dec3UL, 0x65b2c5daUL,
-    0xaaae5d5dUL, 0xeb9f4644UL, 0x28cc6b6fUL, 0x69fd7076UL, 0xae6b3139UL,
-    0xef5a2a20UL, 0x2c09070bUL, 0x6d381c12UL, 0xf33646dfUL, 0xb2075dc6UL,
-    0x715470edUL, 0x30656bf4UL, 0xf7f32abbUL, 0xb6c231a2UL, 0x75911c89UL,
-    0x34a00790UL, 0xfbbc9f17UL, 0xba8d840eUL, 0x79dea925UL, 0x38efb23cUL,
-    0xff79f373UL, 0xbe48e86aUL, 0x7d1bc541UL, 0x3c2ade58UL, 0x054f79f0UL,
-    0x447e62e9UL, 0x872d4fc2UL, 0xc61c54dbUL, 0x018a1594UL, 0x40bb0e8dUL,
-    0x83e823a6UL, 0xc2d938bfUL, 0x0dc5a038UL, 0x4cf4bb21UL, 0x8fa7960aUL,
-    0xce968d13UL, 0x0900cc5cUL, 0x4831d745UL, 0x8b62fa6eUL, 0xca53e177UL,
-    0x545dbbbaUL, 0x156ca0a3UL, 0xd63f8d88UL, 0x970e9691UL, 0x5098d7deUL,
-    0x11a9ccc7UL, 0xd2fae1ecUL, 0x93cbfaf5UL, 0x5cd76272UL, 0x1de6796bUL,
-    0xdeb55440UL, 0x9f844f59UL, 0x58120e16UL, 0x1923150fUL, 0xda703824UL,
-    0x9b41233dUL, 0xa76bfd65UL, 0xe65ae67cUL, 0x2509cb57UL, 0x6438d04eUL,
-    0xa3ae9101UL, 0xe29f8a18UL, 0x21cca733UL, 0x60fdbc2aUL, 0xafe124adUL,
-    0xeed03fb4UL, 0x2d83129fUL, 0x6cb20986UL, 0xab2448c9UL, 0xea1553d0UL,
-    0x29467efbUL, 0x687765e2UL, 0xf6793f2fUL, 0xb7482436UL, 0x741b091dUL,
-    0x352a1204UL, 0xf2bc534bUL, 0xb38d4852UL, 0x70de6579UL, 0x31ef7e60UL,
-    0xfef3e6e7UL, 0xbfc2fdfeUL, 0x7c91d0d5UL, 0x3da0cbccUL, 0xfa368a83UL,
-    0xbb07919aUL, 0x7854bcb1UL, 0x3965a7a8UL, 0x4b98833bUL, 0x0aa99822UL,
-    0xc9fab509UL, 0x88cbae10UL, 0x4f5def5fUL, 0x0e6cf446UL, 0xcd3fd96dUL,
-    0x8c0ec274UL, 0x43125af3UL, 0x022341eaUL, 0xc1706cc1UL, 0x804177d8UL,
-    0x47d73697UL, 0x06e62d8eUL, 0xc5b500a5UL, 0x84841bbcUL, 0x1a8a4171UL,
-    0x5bbb5a68UL, 0x98e87743UL, 0xd9d96c5aUL, 0x1e4f2d15UL, 0x5f7e360cUL,
-    0x9c2d1b27UL, 0xdd1c003eUL, 0x120098b9UL, 0x533183a0UL, 0x9062ae8bUL,
-    0xd153b592UL, 0x16c5f4ddUL, 0x57f4efc4UL, 0x94a7c2efUL, 0xd596d9f6UL,
-    0xe9bc07aeUL, 0xa88d1cb7UL, 0x6bde319cUL, 0x2aef2a85UL, 0xed796bcaUL,
-    0xac4870d3UL, 0x6f1b5df8UL, 0x2e2a46e1UL, 0xe136de66UL, 0xa007c57fUL,
-    0x6354e854UL, 0x2265f34dUL, 0xe5f3b202UL, 0xa4c2a91bUL, 0x67918430UL,
-    0x26a09f29UL, 0xb8aec5e4UL, 0xf99fdefdUL, 0x3accf3d6UL, 0x7bfde8cfUL,
-    0xbc6ba980UL, 0xfd5ab299UL, 0x3e099fb2UL, 0x7f3884abUL, 0xb0241c2cUL,
-    0xf1150735UL, 0x32462a1eUL, 0x73773107UL, 0xb4e17048UL, 0xf5d06b51UL,
-    0x3683467aUL, 0x77b25d63UL, 0x4ed7facbUL, 0x0fe6e1d2UL, 0xccb5ccf9UL,
-    0x8d84d7e0UL, 0x4a1296afUL, 0x0b238db6UL, 0xc870a09dUL, 0x8941bb84UL,
-    0x465d2303UL, 0x076c381aUL, 0xc43f1531UL, 0x850e0e28UL, 0x42984f67UL,
-    0x03a9547eUL, 0xc0fa7955UL, 0x81cb624cUL, 0x1fc53881UL, 0x5ef42398UL,
-    0x9da70eb3UL, 0xdc9615aaUL, 0x1b0054e5UL, 0x5a314ffcUL, 0x996262d7UL,
-    0xd85379ceUL, 0x174fe149UL, 0x567efa50UL, 0x952dd77bUL, 0xd41ccc62UL,
-    0x138a8d2dUL, 0x52bb9634UL, 0x91e8bb1fUL, 0xd0d9a006UL, 0xecf37e5eUL,
-    0xadc26547UL, 0x6e91486cUL, 0x2fa05375UL, 0xe836123aUL, 0xa9070923UL,
-    0x6a542408UL, 0x2b653f11UL, 0xe479a796UL, 0xa548bc8fUL, 0x661b91a4UL,
-    0x272a8abdUL, 0xe0bccbf2UL, 0xa18dd0ebUL, 0x62defdc0UL, 0x23efe6d9UL,
-    0xbde1bc14UL, 0xfcd0a70dUL, 0x3f838a26UL, 0x7eb2913fUL, 0xb924d070UL,
-    0xf815cb69UL, 0x3b46e642UL, 0x7a77fd5bUL, 0xb56b65dcUL, 0xf45a7ec5UL,
-    0x370953eeUL, 0x763848f7UL, 0xb1ae09b8UL, 0xf09f12a1UL, 0x33cc3f8aUL,
-    0x72fd2493UL
-  },
-  {
-    0x00000000UL, 0x376ac201UL, 0x6ed48403UL, 0x59be4602UL, 0xdca80907UL,
-    0xebc2cb06UL, 0xb27c8d04UL, 0x85164f05UL, 0xb851130eUL, 0x8f3bd10fUL,
-    0xd685970dUL, 0xe1ef550cUL, 0x64f91a09UL, 0x5393d808UL, 0x0a2d9e0aUL,
-    0x3d475c0bUL, 0x70a3261cUL, 0x47c9e41dUL, 0x1e77a21fUL, 0x291d601eUL,
-    0xac0b2f1bUL, 0x9b61ed1aUL, 0xc2dfab18UL, 0xf5b56919UL, 0xc8f23512UL,
-    0xff98f713UL, 0xa626b111UL, 0x914c7310UL, 0x145a3c15UL, 0x2330fe14UL,
-    0x7a8eb816UL, 0x4de47a17UL, 0xe0464d38UL, 0xd72c8f39UL, 0x8e92c93bUL,
-    0xb9f80b3aUL, 0x3cee443fUL, 0x0b84863eUL, 0x523ac03cUL, 0x6550023dUL,
-    0x58175e36UL, 0x6f7d9c37UL, 0x36c3da35UL, 0x01a91834UL, 0x84bf5731UL,
-    0xb3d59530UL, 0xea6bd332UL, 0xdd011133UL, 0x90e56b24UL, 0xa78fa925UL,
-    0xfe31ef27UL, 0xc95b2d26UL, 0x4c4d6223UL, 0x7b27a022UL, 0x2299e620UL,
-    0x15f32421UL, 0x28b4782aUL, 0x1fdeba2bUL, 0x4660fc29UL, 0x710a3e28UL,
-    0xf41c712dUL, 0xc376b32cUL, 0x9ac8f52eUL, 0xada2372fUL, 0xc08d9a70UL,
-    0xf7e75871UL, 0xae591e73UL, 0x9933dc72UL, 0x1c259377UL, 0x2b4f5176UL,
-    0x72f11774UL, 0x459bd575UL, 0x78dc897eUL, 0x4fb64b7fUL, 0x16080d7dUL,
-    0x2162cf7cUL, 0xa4748079UL, 0x931e4278UL, 0xcaa0047aUL, 0xfdcac67bUL,
-    0xb02ebc6cUL, 0x87447e6dUL, 0xdefa386fUL, 0xe990fa6eUL, 0x6c86b56bUL,
-    0x5bec776aUL, 0x02523168UL, 0x3538f369UL, 0x087faf62UL, 0x3f156d63UL,
-    0x66ab2b61UL, 0x51c1e960UL, 0xd4d7a665UL, 0xe3bd6464UL, 0xba032266UL,
-    0x8d69e067UL, 0x20cbd748UL, 0x17a11549UL, 0x4e1f534bUL, 0x7975914aUL,
-    0xfc63de4fUL, 0xcb091c4eUL, 0x92b75a4cUL, 0xa5dd984dUL, 0x989ac446UL,
-    0xaff00647UL, 0xf64e4045UL, 0xc1248244UL, 0x4432cd41UL, 0x73580f40UL,
-    0x2ae64942UL, 0x1d8c8b43UL, 0x5068f154UL, 0x67023355UL, 0x3ebc7557UL,
-    0x09d6b756UL, 0x8cc0f853UL, 0xbbaa3a52UL, 0xe2147c50UL, 0xd57ebe51UL,
-    0xe839e25aUL, 0xdf53205bUL, 0x86ed6659UL, 0xb187a458UL, 0x3491eb5dUL,
-    0x03fb295cUL, 0x5a456f5eUL, 0x6d2fad5fUL, 0x801b35e1UL, 0xb771f7e0UL,
-    0xeecfb1e2UL, 0xd9a573e3UL, 0x5cb33ce6UL, 0x6bd9fee7UL, 0x3267b8e5UL,
-    0x050d7ae4UL, 0x384a26efUL, 0x0f20e4eeUL, 0x569ea2ecUL, 0x61f460edUL,
-    0xe4e22fe8UL, 0xd388ede9UL, 0x8a36abebUL, 0xbd5c69eaUL, 0xf0b813fdUL,
-    0xc7d2d1fcUL, 0x9e6c97feUL, 0xa90655ffUL, 0x2c101afaUL, 0x1b7ad8fbUL,
-    0x42c49ef9UL, 0x75ae5cf8UL, 0x48e900f3UL, 0x7f83c2f2UL, 0x263d84f0UL,
-    0x115746f1UL, 0x944109f4UL, 0xa32bcbf5UL, 0xfa958df7UL, 0xcdff4ff6UL,
-    0x605d78d9UL, 0x5737bad8UL, 0x0e89fcdaUL, 0x39e33edbUL, 0xbcf571deUL,
-    0x8b9fb3dfUL, 0xd221f5ddUL, 0xe54b37dcUL, 0xd80c6bd7UL, 0xef66a9d6UL,
-    0xb6d8efd4UL, 0x81b22dd5UL, 0x04a462d0UL, 0x33cea0d1UL, 0x6a70e6d3UL,
-    0x5d1a24d2UL, 0x10fe5ec5UL, 0x27949cc4UL, 0x7e2adac6UL, 0x494018c7UL,
-    0xcc5657c2UL, 0xfb3c95c3UL, 0xa282d3c1UL, 0x95e811c0UL, 0xa8af4dcbUL,
-    0x9fc58fcaUL, 0xc67bc9c8UL, 0xf1110bc9UL, 0x740744ccUL, 0x436d86cdUL,
-    0x1ad3c0cfUL, 0x2db902ceUL, 0x4096af91UL, 0x77fc6d90UL, 0x2e422b92UL,
-    0x1928e993UL, 0x9c3ea696UL, 0xab546497UL, 0xf2ea2295UL, 0xc580e094UL,
-    0xf8c7bc9fUL, 0xcfad7e9eUL, 0x9613389cUL, 0xa179fa9dUL, 0x246fb598UL,
-    0x13057799UL, 0x4abb319bUL, 0x7dd1f39aUL, 0x3035898dUL, 0x075f4b8cUL,
-    0x5ee10d8eUL, 0x698bcf8fUL, 0xec9d808aUL, 0xdbf7428bUL, 0x82490489UL,
-    0xb523c688UL, 0x88649a83UL, 0xbf0e5882UL, 0xe6b01e80UL, 0xd1dadc81UL,
-    0x54cc9384UL, 0x63a65185UL, 0x3a181787UL, 0x0d72d586UL, 0xa0d0e2a9UL,
-    0x97ba20a8UL, 0xce0466aaUL, 0xf96ea4abUL, 0x7c78ebaeUL, 0x4b1229afUL,
-    0x12ac6fadUL, 0x25c6adacUL, 0x1881f1a7UL, 0x2feb33a6UL, 0x765575a4UL,
-    0x413fb7a5UL, 0xc429f8a0UL, 0xf3433aa1UL, 0xaafd7ca3UL, 0x9d97bea2UL,
-    0xd073c4b5UL, 0xe71906b4UL, 0xbea740b6UL, 0x89cd82b7UL, 0x0cdbcdb2UL,
-    0x3bb10fb3UL, 0x620f49b1UL, 0x55658bb0UL, 0x6822d7bbUL, 0x5f4815baUL,
-    0x06f653b8UL, 0x319c91b9UL, 0xb48adebcUL, 0x83e01cbdUL, 0xda5e5abfUL,
-    0xed3498beUL
-  },
-  {
-    0x00000000UL, 0x6567bcb8UL, 0x8bc809aaUL, 0xeeafb512UL, 0x5797628fUL,
-    0x32f0de37UL, 0xdc5f6b25UL, 0xb938d79dUL, 0xef28b4c5UL, 0x8a4f087dUL,
-    0x64e0bd6fUL, 0x018701d7UL, 0xb8bfd64aUL, 0xddd86af2UL, 0x3377dfe0UL,
-    0x56106358UL, 0x9f571950UL, 0xfa30a5e8UL, 0x149f10faUL, 0x71f8ac42UL,
-    0xc8c07bdfUL, 0xada7c767UL, 0x43087275UL, 0x266fcecdUL, 0x707fad95UL,
-    0x1518112dUL, 0xfbb7a43fUL, 0x9ed01887UL, 0x27e8cf1aUL, 0x428f73a2UL,
-    0xac20c6b0UL, 0xc9477a08UL, 0x3eaf32a0UL, 0x5bc88e18UL, 0xb5673b0aUL,
-    0xd00087b2UL, 0x6938502fUL, 0x0c5fec97UL, 0xe2f05985UL, 0x8797e53dUL,
-    0xd1878665UL, 0xb4e03addUL, 0x5a4f8fcfUL, 0x3f283377UL, 0x8610e4eaUL,
-    0xe3775852UL, 0x0dd8ed40UL, 0x68bf51f8UL, 0xa1f82bf0UL, 0xc49f9748UL,
-    0x2a30225aUL, 0x4f579ee2UL, 0xf66f497fUL, 0x9308f5c7UL, 0x7da740d5UL,
-    0x18c0fc6dUL, 0x4ed09f35UL, 0x2bb7238dUL, 0xc518969fUL, 0xa07f2a27UL,
-    0x1947fdbaUL, 0x7c204102UL, 0x928ff410UL, 0xf7e848a8UL, 0x3d58149bUL,
-    0x583fa823UL, 0xb6901d31UL, 0xd3f7a189UL, 0x6acf7614UL, 0x0fa8caacUL,
-    0xe1077fbeUL, 0x8460c306UL, 0xd270a05eUL, 0xb7171ce6UL, 0x59b8a9f4UL,
-    0x3cdf154cUL, 0x85e7c2d1UL, 0xe0807e69UL, 0x0e2fcb7bUL, 0x6b4877c3UL,
-    0xa20f0dcbUL, 0xc768b173UL, 0x29c70461UL, 0x4ca0b8d9UL, 0xf5986f44UL,
-    0x90ffd3fcUL, 0x7e5066eeUL, 0x1b37da56UL, 0x4d27b90eUL, 0x284005b6UL,
-    0xc6efb0a4UL, 0xa3880c1cUL, 0x1ab0db81UL, 0x7fd76739UL, 0x9178d22bUL,
-    0xf41f6e93UL, 0x03f7263bUL, 0x66909a83UL, 0x883f2f91UL, 0xed589329UL,
-    0x546044b4UL, 0x3107f80cUL, 0xdfa84d1eUL, 0xbacff1a6UL, 0xecdf92feUL,
-    0x89b82e46UL, 0x67179b54UL, 0x027027ecUL, 0xbb48f071UL, 0xde2f4cc9UL,
-    0x3080f9dbUL, 0x55e74563UL, 0x9ca03f6bUL, 0xf9c783d3UL, 0x176836c1UL,
-    0x720f8a79UL, 0xcb375de4UL, 0xae50e15cUL, 0x40ff544eUL, 0x2598e8f6UL,
-    0x73888baeUL, 0x16ef3716UL, 0xf8408204UL, 0x9d273ebcUL, 0x241fe921UL,
-    0x41785599UL, 0xafd7e08bUL, 0xcab05c33UL, 0x3bb659edUL, 0x5ed1e555UL,
-    0xb07e5047UL, 0xd519ecffUL, 0x6c213b62UL, 0x094687daUL, 0xe7e932c8UL,
-    0x828e8e70UL, 0xd49eed28UL, 0xb1f95190UL, 0x5f56e482UL, 0x3a31583aUL,
-    0x83098fa7UL, 0xe66e331fUL, 0x08c1860dUL, 0x6da63ab5UL, 0xa4e140bdUL,
-    0xc186fc05UL, 0x2f294917UL, 0x4a4ef5afUL, 0xf3762232UL, 0x96119e8aUL,
-    0x78be2b98UL, 0x1dd99720UL, 0x4bc9f478UL, 0x2eae48c0UL, 0xc001fdd2UL,
-    0xa566416aUL, 0x1c5e96f7UL, 0x79392a4fUL, 0x97969f5dUL, 0xf2f123e5UL,
-    0x05196b4dUL, 0x607ed7f5UL, 0x8ed162e7UL, 0xebb6de5fUL, 0x528e09c2UL,
-    0x37e9b57aUL, 0xd9460068UL, 0xbc21bcd0UL, 0xea31df88UL, 0x8f566330UL,
-    0x61f9d622UL, 0x049e6a9aUL, 0xbda6bd07UL, 0xd8c101bfUL, 0x366eb4adUL,
-    0x53090815UL, 0x9a4e721dUL, 0xff29cea5UL, 0x11867bb7UL, 0x74e1c70fUL,
-    0xcdd91092UL, 0xa8beac2aUL, 0x46111938UL, 0x2376a580UL, 0x7566c6d8UL,
-    0x10017a60UL, 0xfeaecf72UL, 0x9bc973caUL, 0x22f1a457UL, 0x479618efUL,
-    0xa939adfdUL, 0xcc5e1145UL, 0x06ee4d76UL, 0x6389f1ceUL, 0x8d2644dcUL,
-    0xe841f864UL, 0x51792ff9UL, 0x341e9341UL, 0xdab12653UL, 0xbfd69aebUL,
-    0xe9c6f9b3UL, 0x8ca1450bUL, 0x620ef019UL, 0x07694ca1UL, 0xbe519b3cUL,
-    0xdb362784UL, 0x35999296UL, 0x50fe2e2eUL, 0x99b95426UL, 0xfcdee89eUL,
-    0x12715d8cUL, 0x7716e134UL, 0xce2e36a9UL, 0xab498a11UL, 0x45e63f03UL,
-    0x208183bbUL, 0x7691e0e3UL, 0x13f65c5bUL, 0xfd59e949UL, 0x983e55f1UL,
-    0x2106826cUL, 0x44613ed4UL, 0xaace8bc6UL, 0xcfa9377eUL, 0x38417fd6UL,
-    0x5d26c36eUL, 0xb389767cUL, 0xd6eecac4UL, 0x6fd61d59UL, 0x0ab1a1e1UL,
-    0xe41e14f3UL, 0x8179a84bUL, 0xd769cb13UL, 0xb20e77abUL, 0x5ca1c2b9UL,
-    0x39c67e01UL, 0x80fea99cUL, 0xe5991524UL, 0x0b36a036UL, 0x6e511c8eUL,
-    0xa7166686UL, 0xc271da3eUL, 0x2cde6f2cUL, 0x49b9d394UL, 0xf0810409UL,
-    0x95e6b8b1UL, 0x7b490da3UL, 0x1e2eb11bUL, 0x483ed243UL, 0x2d596efbUL,
-    0xc3f6dbe9UL, 0xa6916751UL, 0x1fa9b0ccUL, 0x7ace0c74UL, 0x9461b966UL,
-    0xf10605deUL
-#endif
-  }
-};
diff -Nbaur gcc-4.6.3/zlib/deflate.c gcc-4.6.3-psp/zlib/deflate.c
--- gcc-4.6.3/zlib/deflate.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/deflate.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1736 +0,0 @@
-/* deflate.c -- compress data using the deflation algorithm
- * Copyright (C) 1995-2005 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- *  ALGORITHM
- *
- *      The "deflation" process depends on being able to identify portions
- *      of the input text which are identical to earlier input (within a
- *      sliding window trailing behind the input currently being processed).
- *
- *      The most straightforward technique turns out to be the fastest for
- *      most input files: try all possible matches and select the longest.
- *      The key feature of this algorithm is that insertions into the string
- *      dictionary are very simple and thus fast, and deletions are avoided
- *      completely. Insertions are performed at each input character, whereas
- *      string matches are performed only when the previous match ends. So it
- *      is preferable to spend more time in matches to allow very fast string
- *      insertions and avoid deletions. The matching algorithm for small
- *      strings is inspired from that of Rabin & Karp. A brute force approach
- *      is used to find longer strings when a small match has been found.
- *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
- *      (by Leonid Broukhis).
- *         A previous version of this file used a more sophisticated algorithm
- *      (by Fiala and Greene) which is guaranteed to run in linear amortized
- *      time, but has a larger average cost, uses more memory and is patented.
- *      However the F&G algorithm may be faster for some highly redundant
- *      files if the parameter max_chain_length (described below) is too large.
- *
- *  ACKNOWLEDGEMENTS
- *
- *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
- *      I found it in 'freeze' written by Leonid Broukhis.
- *      Thanks to many people for bug reports and testing.
- *
- *  REFERENCES
- *
- *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
- *      Available in http://www.ietf.org/rfc/rfc1951.txt
- *
- *      A description of the Rabin and Karp algorithm is given in the book
- *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
- *
- *      Fiala,E.R., and Greene,D.H.
- *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
- *
- */
-
-/* @(#) $Id: deflate.c,v 1.1.1.2 2002/03/11 21:53:23 tromey Exp $ */
-
-#include "deflate.h"
-
-const char deflate_copyright[] =
-   " deflate 1.2.3 Copyright 1995-2005 Jean-loup Gailly ";
-/*
-  If you use the zlib library in a product, an acknowledgment is welcome
-  in the documentation of your product. If for some reason you cannot
-  include such an acknowledgment, I would appreciate that you keep this
-  copyright string in the executable of your product.
- */
-
-/* ===========================================================================
- *  Function prototypes.
- */
-typedef enum {
-    need_more,      /* block not completed, need more input or more output */
-    block_done,     /* block flush performed */
-    finish_started, /* finish started, need only more output at next deflate */
-    finish_done     /* finish done, accept no more input or output */
-} block_state;
-
-typedef block_state (*compress_func) OF((deflate_state *s, int flush));
-/* Compression function. Returns the block state after the call. */
-
-local void fill_window    OF((deflate_state *s));
-local block_state deflate_stored OF((deflate_state *s, int flush));
-local block_state deflate_fast   OF((deflate_state *s, int flush));
-#ifndef FASTEST
-local block_state deflate_slow   OF((deflate_state *s, int flush));
-#endif
-local void lm_init        OF((deflate_state *s));
-local void putShortMSB    OF((deflate_state *s, uInt b));
-local void flush_pending  OF((z_streamp strm));
-local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
-#ifndef FASTEST
-#ifdef ASMV
-      void match_init OF((void)); /* asm code initialization */
-      uInt longest_match  OF((deflate_state *s, IPos cur_match));
-#else
-local uInt longest_match  OF((deflate_state *s, IPos cur_match));
-#endif
-#endif
-local uInt longest_match_fast OF((deflate_state *s, IPos cur_match));
-
-#ifdef DEBUG
-local  void check_match OF((deflate_state *s, IPos start, IPos match,
-                            int length));
-#endif
-
-/* ===========================================================================
- * Local data
- */
-
-#define NIL 0
-/* Tail of hash chains */
-
-#ifndef TOO_FAR
-#  define TOO_FAR 4096
-#endif
-/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
-
-#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
-/* Minimum amount of lookahead, except at the end of the input file.
- * See deflate.c for comments about the MIN_MATCH+1.
- */
-
-/* Values for max_lazy_match, good_match and max_chain_length, depending on
- * the desired pack level (0..9). The values given below have been tuned to
- * exclude worst case performance for pathological files. Better values may be
- * found for specific files.
- */
-typedef struct config_s {
-   ush good_length; /* reduce lazy search above this match length */
-   ush max_lazy;    /* do not perform lazy search above this match length */
-   ush nice_length; /* quit search above this match length */
-   ush max_chain;
-   compress_func func;
-} config;
-
-#ifdef FASTEST
-local const config configuration_table[2] = {
-/*      good lazy nice chain */
-/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
-/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
-#else
-local const config configuration_table[10] = {
-/*      good lazy nice chain */
-/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
-/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
-/* 2 */ {4,    5, 16,    8, deflate_fast},
-/* 3 */ {4,    6, 32,   32, deflate_fast},
-
-/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
-/* 5 */ {8,   16, 32,   32, deflate_slow},
-/* 6 */ {8,   16, 128, 128, deflate_slow},
-/* 7 */ {8,   32, 128, 256, deflate_slow},
-/* 8 */ {32, 128, 258, 1024, deflate_slow},
-/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
-#endif
-
-/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
- * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
- * meaning.
- */
-
-#define EQUAL 0
-/* result of memcmp for equal strings */
-
-#ifndef NO_DUMMY_DECL
-struct static_tree_desc_s {int dummy;}; /* for buggy compilers */
-#endif
-
-/* ===========================================================================
- * Update a hash value with the given input byte
- * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
- *    input characters, so that a running hash key can be computed from the
- *    previous key instead of complete recalculation each time.
- */
-#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)
-
-
-/* ===========================================================================
- * Insert string str in the dictionary and set match_head to the previous head
- * of the hash chain (the most recent string with same hash key). Return
- * the previous length of the hash chain.
- * If this file is compiled with -DFASTEST, the compression level is forced
- * to 1, and no hash chains are maintained.
- * IN  assertion: all calls to to INSERT_STRING are made with consecutive
- *    input characters and the first MIN_MATCH bytes of str are valid
- *    (except for the last MIN_MATCH-1 bytes of the input file).
- */
-#ifdef FASTEST
-#define INSERT_STRING(s, str, match_head) \
-   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
-    match_head = s->head[s->ins_h], \
-    s->head[s->ins_h] = (Pos)(str))
-#else
-#define INSERT_STRING(s, str, match_head) \
-   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
-    match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \
-    s->head[s->ins_h] = (Pos)(str))
-#endif
-
-/* ===========================================================================
- * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
- * prev[] will be initialized on the fly.
- */
-#define CLEAR_HASH(s) \
-    s->head[s->hash_size-1] = NIL; \
-    zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));
-
-/* ========================================================================= */
-int ZEXPORT deflateInit_(strm, level, version, stream_size)
-    z_streamp strm;
-    int level;
-    const char *version;
-    int stream_size;
-{
-    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
-                         Z_DEFAULT_STRATEGY, version, stream_size);
-    /* To do: ignore strm->next_in if we use it as window */
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
-                  version, stream_size)
-    z_streamp strm;
-    int  level;
-    int  method;
-    int  windowBits;
-    int  memLevel;
-    int  strategy;
-    const char *version;
-    int stream_size;
-{
-    deflate_state *s;
-    int wrap = 1;
-    static const char my_version[] = ZLIB_VERSION;
-
-    ushf *overlay;
-    /* We overlay pending_buf and d_buf+l_buf. This works since the average
-     * output size for (length,distance) codes is <= 24 bits.
-     */
-
-    if (version == Z_NULL || version[0] != my_version[0] ||
-        stream_size != sizeof(z_stream)) {
-        return Z_VERSION_ERROR;
-    }
-    if (strm == Z_NULL) return Z_STREAM_ERROR;
-
-    strm->msg = Z_NULL;
-    if (strm->zalloc == (alloc_func)0) {
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-    }
-    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
-
-#ifdef FASTEST
-    if (level != 0) level = 1;
-#else
-    if (level == Z_DEFAULT_COMPRESSION) level = 6;
-#endif
-
-    if (windowBits < 0) { /* suppress zlib wrapper */
-        wrap = 0;
-        windowBits = -windowBits;
-    }
-#ifdef GZIP
-    else if (windowBits > 15) {
-        wrap = 2;       /* write gzip wrapper instead */
-        windowBits -= 16;
-    }
-#endif
-    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
-        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
-        strategy < 0 || strategy > Z_FIXED) {
-        return Z_STREAM_ERROR;
-    }
-    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
-    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
-    if (s == Z_NULL) return Z_MEM_ERROR;
-    strm->state = (struct internal_state FAR *)s;
-    s->strm = strm;
-
-    s->wrap = wrap;
-    s->gzhead = Z_NULL;
-    s->w_bits = windowBits;
-    s->w_size = 1 << s->w_bits;
-    s->w_mask = s->w_size - 1;
-
-    s->hash_bits = memLevel + 7;
-    s->hash_size = 1 << s->hash_bits;
-    s->hash_mask = s->hash_size - 1;
-    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
-
-    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
-    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
-    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
-
-    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
-
-    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
-    s->pending_buf = (uchf *) overlay;
-    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);
-
-    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
-        s->pending_buf == Z_NULL) {
-        s->status = FINISH_STATE;
-        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);
-        deflateEnd (strm);
-        return Z_MEM_ERROR;
-    }
-    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
-    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
-
-    s->level = level;
-    s->strategy = strategy;
-    s->method = (Byte)method;
-
-    return deflateReset(strm);
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
-    z_streamp strm;
-    const Bytef *dictionary;
-    uInt  dictLength;
-{
-    deflate_state *s;
-    uInt length = dictLength;
-    uInt n;
-    IPos hash_head = 0;
-
-    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
-        strm->state->wrap == 2 ||
-        (strm->state->wrap == 1 && strm->state->status != INIT_STATE))
-        return Z_STREAM_ERROR;
-
-    s = strm->state;
-    if (s->wrap)
-        strm->adler = adler32(strm->adler, dictionary, dictLength);
-
-    if (length < MIN_MATCH) return Z_OK;
-    if (length > MAX_DIST(s)) {
-        length = MAX_DIST(s);
-        dictionary += dictLength - length; /* use the tail of the dictionary */
-    }
-    zmemcpy(s->window, dictionary, length);
-    s->strstart = length;
-    s->block_start = (long)length;
-
-    /* Insert all strings in the hash table (except for the last two bytes).
-     * s->lookahead stays null, so s->ins_h will be recomputed at the next
-     * call of fill_window.
-     */
-    s->ins_h = s->window[0];
-    UPDATE_HASH(s, s->ins_h, s->window[1]);
-    for (n = 0; n <= length - MIN_MATCH; n++) {
-        INSERT_STRING(s, n, hash_head);
-    }
-    if (hash_head) hash_head = 0;  /* to make compiler happy */
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateReset (strm)
-    z_streamp strm;
-{
-    deflate_state *s;
-
-    if (strm == Z_NULL || strm->state == Z_NULL ||
-        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {
-        return Z_STREAM_ERROR;
-    }
-
-    strm->total_in = strm->total_out = 0;
-    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
-    strm->data_type = Z_UNKNOWN;
-
-    s = (deflate_state *)strm->state;
-    s->pending = 0;
-    s->pending_out = s->pending_buf;
-
-    if (s->wrap < 0) {
-        s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */
-    }
-    s->status = s->wrap ? INIT_STATE : BUSY_STATE;
-    strm->adler =
-#ifdef GZIP
-        s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
-#endif
-        adler32(0L, Z_NULL, 0);
-    s->last_flush = Z_NO_FLUSH;
-
-    _tr_init(s);
-    lm_init(s);
-
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateSetHeader (strm, head)
-    z_streamp strm;
-    gz_headerp head;
-{
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    if (strm->state->wrap != 2) return Z_STREAM_ERROR;
-    strm->state->gzhead = head;
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflatePrime (strm, bits, value)
-    z_streamp strm;
-    int bits;
-    int value;
-{
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    strm->state->bi_valid = bits;
-    strm->state->bi_buf = (ush)(value & ((1 << bits) - 1));
-    return Z_OK;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateParams(strm, level, strategy)
-    z_streamp strm;
-    int level;
-    int strategy;
-{
-    deflate_state *s;
-    compress_func func;
-    int err = Z_OK;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    s = strm->state;
-
-#ifdef FASTEST
-    if (level != 0) level = 1;
-#else
-    if (level == Z_DEFAULT_COMPRESSION) level = 6;
-#endif
-    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
-        return Z_STREAM_ERROR;
-    }
-    func = configuration_table[s->level].func;
-
-    if (func != configuration_table[level].func && strm->total_in != 0) {
-        /* Flush the last buffer: */
-        err = deflate(strm, Z_PARTIAL_FLUSH);
-    }
-    if (s->level != level) {
-        s->level = level;
-        s->max_lazy_match   = configuration_table[level].max_lazy;
-        s->good_match       = configuration_table[level].good_length;
-        s->nice_match       = configuration_table[level].nice_length;
-        s->max_chain_length = configuration_table[level].max_chain;
-    }
-    s->strategy = strategy;
-    return err;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)
-    z_streamp strm;
-    int good_length;
-    int max_lazy;
-    int nice_length;
-    int max_chain;
-{
-    deflate_state *s;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    s = strm->state;
-    s->good_match = good_length;
-    s->max_lazy_match = max_lazy;
-    s->nice_match = nice_length;
-    s->max_chain_length = max_chain;
-    return Z_OK;
-}
-
-/* =========================================================================
- * For the default windowBits of 15 and memLevel of 8, this function returns
- * a close to exact, as well as small, upper bound on the compressed size.
- * They are coded as constants here for a reason--if the #define's are
- * changed, then this function needs to be changed as well.  The return
- * value for 15 and 8 only works for those exact settings.
- *
- * For any setting other than those defaults for windowBits and memLevel,
- * the value returned is a conservative worst case for the maximum expansion
- * resulting from using fixed blocks instead of stored blocks, which deflate
- * can emit on compressed data for some combinations of the parameters.
- *
- * This function could be more sophisticated to provide closer upper bounds
- * for every combination of windowBits and memLevel, as well as wrap.
- * But even the conservative upper bound of about 14% expansion does not
- * seem onerous for output buffer allocation.
- */
-uLong ZEXPORT deflateBound(strm, sourceLen)
-    z_streamp strm;
-    uLong sourceLen;
-{
-    deflate_state *s;
-    uLong destLen;
-
-    /* conservative upper bound */
-    destLen = sourceLen +
-              ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 11;
-
-    /* if can't get parameters, return conservative bound */
-    if (strm == Z_NULL || strm->state == Z_NULL)
-        return destLen;
-
-    /* if not default parameters, return conservative bound */
-    s = strm->state;
-    if (s->w_bits != 15 || s->hash_bits != 8 + 7)
-        return destLen;
-
-    /* default settings: return tight bound for that case */
-    return compressBound(sourceLen);
-}
-
-/* =========================================================================
- * Put a short in the pending buffer. The 16-bit value is put in MSB order.
- * IN assertion: the stream state is correct and there is enough room in
- * pending_buf.
- */
-local void putShortMSB (s, b)
-    deflate_state *s;
-    uInt b;
-{
-    put_byte(s, (Byte)(b >> 8));
-    put_byte(s, (Byte)(b & 0xff));
-}
-
-/* =========================================================================
- * Flush as much pending output as possible. All deflate() output goes
- * through this function so some applications may wish to modify it
- * to avoid allocating a large strm->next_out buffer and copying into it.
- * (See also read_buf()).
- */
-local void flush_pending(strm)
-    z_streamp strm;
-{
-    unsigned len = strm->state->pending;
-
-    if (len > strm->avail_out) len = strm->avail_out;
-    if (len == 0) return;
-
-    zmemcpy(strm->next_out, strm->state->pending_out, len);
-    strm->next_out  += len;
-    strm->state->pending_out  += len;
-    strm->total_out += len;
-    strm->avail_out  -= len;
-    strm->state->pending -= len;
-    if (strm->state->pending == 0) {
-        strm->state->pending_out = strm->state->pending_buf;
-    }
-}
-
-/* ========================================================================= */
-int ZEXPORT deflate (strm, flush)
-    z_streamp strm;
-    int flush;
-{
-    int old_flush; /* value of flush param for previous deflate call */
-    deflate_state *s;
-
-    if (strm == Z_NULL || strm->state == Z_NULL ||
-        flush > Z_FINISH || flush < 0) {
-        return Z_STREAM_ERROR;
-    }
-    s = strm->state;
-
-    if (strm->next_out == Z_NULL ||
-        (strm->next_in == Z_NULL && strm->avail_in != 0) ||
-        (s->status == FINISH_STATE && flush != Z_FINISH)) {
-        ERR_RETURN(strm, Z_STREAM_ERROR);
-    }
-    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
-
-    s->strm = strm; /* just in case */
-    old_flush = s->last_flush;
-    s->last_flush = flush;
-
-    /* Write the header */
-    if (s->status == INIT_STATE) {
-#ifdef GZIP
-        if (s->wrap == 2) {
-            strm->adler = crc32(0L, Z_NULL, 0);
-            put_byte(s, 31);
-            put_byte(s, 139);
-            put_byte(s, 8);
-            if (s->gzhead == NULL) {
-                put_byte(s, 0);
-                put_byte(s, 0);
-                put_byte(s, 0);
-                put_byte(s, 0);
-                put_byte(s, 0);
-                put_byte(s, s->level == 9 ? 2 :
-                            (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
-                             4 : 0));
-                put_byte(s, OS_CODE);
-                s->status = BUSY_STATE;
-            }
-            else {
-                put_byte(s, (s->gzhead->text ? 1 : 0) +
-                            (s->gzhead->hcrc ? 2 : 0) +
-                            (s->gzhead->extra == Z_NULL ? 0 : 4) +
-                            (s->gzhead->name == Z_NULL ? 0 : 8) +
-                            (s->gzhead->comment == Z_NULL ? 0 : 16)
-                        );
-                put_byte(s, (Byte)(s->gzhead->time & 0xff));
-                put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));
-                put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
-                put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
-                put_byte(s, s->level == 9 ? 2 :
-                            (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
-                             4 : 0));
-                put_byte(s, s->gzhead->os & 0xff);
-                if (s->gzhead->extra != NULL) {
-                    put_byte(s, s->gzhead->extra_len & 0xff);
-                    put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
-                }
-                if (s->gzhead->hcrc)
-                    strm->adler = crc32(strm->adler, s->pending_buf,
-                                        s->pending);
-                s->gzindex = 0;
-                s->status = EXTRA_STATE;
-            }
-        }
-        else
-#endif
-        {
-            uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
-            uInt level_flags;
-
-            if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)
-                level_flags = 0;
-            else if (s->level < 6)
-                level_flags = 1;
-            else if (s->level == 6)
-                level_flags = 2;
-            else
-                level_flags = 3;
-            header |= (level_flags << 6);
-            if (s->strstart != 0) header |= PRESET_DICT;
-            header += 31 - (header % 31);
-
-            s->status = BUSY_STATE;
-            putShortMSB(s, header);
-
-            /* Save the adler32 of the preset dictionary: */
-            if (s->strstart != 0) {
-                putShortMSB(s, (uInt)(strm->adler >> 16));
-                putShortMSB(s, (uInt)(strm->adler & 0xffff));
-            }
-            strm->adler = adler32(0L, Z_NULL, 0);
-        }
-    }
-#ifdef GZIP
-    if (s->status == EXTRA_STATE) {
-        if (s->gzhead->extra != NULL) {
-            uInt beg = s->pending;  /* start of bytes to update crc */
-
-            while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {
-                if (s->pending == s->pending_buf_size) {
-                    if (s->gzhead->hcrc && s->pending > beg)
-                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
-                                            s->pending - beg);
-                    flush_pending(strm);
-                    beg = s->pending;
-                    if (s->pending == s->pending_buf_size)
-                        break;
-                }
-                put_byte(s, s->gzhead->extra[s->gzindex]);
-                s->gzindex++;
-            }
-            if (s->gzhead->hcrc && s->pending > beg)
-                strm->adler = crc32(strm->adler, s->pending_buf + beg,
-                                    s->pending - beg);
-            if (s->gzindex == s->gzhead->extra_len) {
-                s->gzindex = 0;
-                s->status = NAME_STATE;
-            }
-        }
-        else
-            s->status = NAME_STATE;
-    }
-    if (s->status == NAME_STATE) {
-        if (s->gzhead->name != NULL) {
-            uInt beg = s->pending;  /* start of bytes to update crc */
-            int val;
-
-            do {
-                if (s->pending == s->pending_buf_size) {
-                    if (s->gzhead->hcrc && s->pending > beg)
-                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
-                                            s->pending - beg);
-                    flush_pending(strm);
-                    beg = s->pending;
-                    if (s->pending == s->pending_buf_size) {
-                        val = 1;
-                        break;
-                    }
-                }
-                val = s->gzhead->name[s->gzindex++];
-                put_byte(s, val);
-            } while (val != 0);
-            if (s->gzhead->hcrc && s->pending > beg)
-                strm->adler = crc32(strm->adler, s->pending_buf + beg,
-                                    s->pending - beg);
-            if (val == 0) {
-                s->gzindex = 0;
-                s->status = COMMENT_STATE;
-            }
-        }
-        else
-            s->status = COMMENT_STATE;
-    }
-    if (s->status == COMMENT_STATE) {
-        if (s->gzhead->comment != NULL) {
-            uInt beg = s->pending;  /* start of bytes to update crc */
-            int val;
-
-            do {
-                if (s->pending == s->pending_buf_size) {
-                    if (s->gzhead->hcrc && s->pending > beg)
-                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
-                                            s->pending - beg);
-                    flush_pending(strm);
-                    beg = s->pending;
-                    if (s->pending == s->pending_buf_size) {
-                        val = 1;
-                        break;
-                    }
-                }
-                val = s->gzhead->comment[s->gzindex++];
-                put_byte(s, val);
-            } while (val != 0);
-            if (s->gzhead->hcrc && s->pending > beg)
-                strm->adler = crc32(strm->adler, s->pending_buf + beg,
-                                    s->pending - beg);
-            if (val == 0)
-                s->status = HCRC_STATE;
-        }
-        else
-            s->status = HCRC_STATE;
-    }
-    if (s->status == HCRC_STATE) {
-        if (s->gzhead->hcrc) {
-            if (s->pending + 2 > s->pending_buf_size)
-                flush_pending(strm);
-            if (s->pending + 2 <= s->pending_buf_size) {
-                put_byte(s, (Byte)(strm->adler & 0xff));
-                put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
-                strm->adler = crc32(0L, Z_NULL, 0);
-                s->status = BUSY_STATE;
-            }
-        }
-        else
-            s->status = BUSY_STATE;
-    }
-#endif
-
-    /* Flush as much pending output as possible */
-    if (s->pending != 0) {
-        flush_pending(strm);
-        if (strm->avail_out == 0) {
-            /* Since avail_out is 0, deflate will be called again with
-             * more output space, but possibly with both pending and
-             * avail_in equal to zero. There won't be anything to do,
-             * but this is not an error situation so make sure we
-             * return OK instead of BUF_ERROR at next call of deflate:
-             */
-            s->last_flush = -1;
-            return Z_OK;
-        }
-
-    /* Make sure there is something to do and avoid duplicate consecutive
-     * flushes. For repeated and useless calls with Z_FINISH, we keep
-     * returning Z_STREAM_END instead of Z_BUF_ERROR.
-     */
-    } else if (strm->avail_in == 0 && flush <= old_flush &&
-               flush != Z_FINISH) {
-        ERR_RETURN(strm, Z_BUF_ERROR);
-    }
-
-    /* User must not provide more input after the first FINISH: */
-    if (s->status == FINISH_STATE && strm->avail_in != 0) {
-        ERR_RETURN(strm, Z_BUF_ERROR);
-    }
-
-    /* Start a new block or continue the current one.
-     */
-    if (strm->avail_in != 0 || s->lookahead != 0 ||
-        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
-        block_state bstate;
-
-        bstate = (*(configuration_table[s->level].func))(s, flush);
-
-        if (bstate == finish_started || bstate == finish_done) {
-            s->status = FINISH_STATE;
-        }
-        if (bstate == need_more || bstate == finish_started) {
-            if (strm->avail_out == 0) {
-                s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
-            }
-            return Z_OK;
-            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
-             * of deflate should use the same flush parameter to make sure
-             * that the flush is complete. So we don't have to output an
-             * empty block here, this will be done at next call. This also
-             * ensures that for a very small output buffer, we emit at most
-             * one empty block.
-             */
-        }
-        if (bstate == block_done) {
-            if (flush == Z_PARTIAL_FLUSH) {
-                _tr_align(s);
-            } else { /* FULL_FLUSH or SYNC_FLUSH */
-                _tr_stored_block(s, (char*)0, 0L, 0);
-                /* For a full flush, this empty block will be recognized
-                 * as a special marker by inflate_sync().
-                 */
-                if (flush == Z_FULL_FLUSH) {
-                    CLEAR_HASH(s);             /* forget history */
-                }
-            }
-            flush_pending(strm);
-            if (strm->avail_out == 0) {
-              s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
-              return Z_OK;
-            }
-        }
-    }
-    Assert(strm->avail_out > 0, "bug2");
-
-    if (flush != Z_FINISH) return Z_OK;
-    if (s->wrap <= 0) return Z_STREAM_END;
-
-    /* Write the trailer */
-#ifdef GZIP
-    if (s->wrap == 2) {
-        put_byte(s, (Byte)(strm->adler & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 16) & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 24) & 0xff));
-        put_byte(s, (Byte)(strm->total_in & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));
-    }
-    else
-#endif
-    {
-        putShortMSB(s, (uInt)(strm->adler >> 16));
-        putShortMSB(s, (uInt)(strm->adler & 0xffff));
-    }
-    flush_pending(strm);
-    /* If avail_out is zero, the application will call deflate again
-     * to flush the rest.
-     */
-    if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */
-    return s->pending != 0 ? Z_OK : Z_STREAM_END;
-}
-
-/* ========================================================================= */
-int ZEXPORT deflateEnd (strm)
-    z_streamp strm;
-{
-    int status;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-
-    status = strm->state->status;
-    if (status != INIT_STATE &&
-        status != EXTRA_STATE &&
-        status != NAME_STATE &&
-        status != COMMENT_STATE &&
-        status != HCRC_STATE &&
-        status != BUSY_STATE &&
-        status != FINISH_STATE) {
-      return Z_STREAM_ERROR;
-    }
-
-    /* Deallocate in reverse order of allocations: */
-    TRY_FREE(strm, strm->state->pending_buf);
-    TRY_FREE(strm, strm->state->head);
-    TRY_FREE(strm, strm->state->prev);
-    TRY_FREE(strm, strm->state->window);
-
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-
-    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
-}
-
-/* =========================================================================
- * Copy the source state to the destination state.
- * To simplify the source, this is not supported for 16-bit MSDOS (which
- * doesn't have enough memory anyway to duplicate compression states).
- */
-int ZEXPORT deflateCopy (dest, source)
-    z_streamp dest;
-    z_streamp source;
-{
-#ifdef MAXSEG_64K
-    return Z_STREAM_ERROR;
-#else
-    deflate_state *ds;
-    deflate_state *ss;
-    ushf *overlay;
-
-
-    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
-        return Z_STREAM_ERROR;
-    }
-
-    ss = source->state;
-
-    zmemcpy(dest, source, sizeof(z_stream));
-
-    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
-    if (ds == Z_NULL) return Z_MEM_ERROR;
-    dest->state = (struct internal_state FAR *) ds;
-    zmemcpy(ds, ss, sizeof(deflate_state));
-    ds->strm = dest;
-
-    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
-    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
-    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
-    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
-    ds->pending_buf = (uchf *) overlay;
-
-    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
-        ds->pending_buf == Z_NULL) {
-        deflateEnd (dest);
-        return Z_MEM_ERROR;
-    }
-    /* following zmemcpy do not work for 16-bit MSDOS */
-    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
-    zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));
-    zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));
-    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
-
-    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
-    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
-    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;
-
-    ds->l_desc.dyn_tree = ds->dyn_ltree;
-    ds->d_desc.dyn_tree = ds->dyn_dtree;
-    ds->bl_desc.dyn_tree = ds->bl_tree;
-
-    return Z_OK;
-#endif /* MAXSEG_64K */
-}
-
-/* ===========================================================================
- * Read a new buffer from the current input stream, update the adler32
- * and total number of bytes read.  All deflate() input goes through
- * this function so some applications may wish to modify it to avoid
- * allocating a large strm->next_in buffer and copying from it.
- * (See also flush_pending()).
- */
-local int read_buf(strm, buf, size)
-    z_streamp strm;
-    Bytef *buf;
-    unsigned size;
-{
-    unsigned len = strm->avail_in;
-
-    if (len > size) len = size;
-    if (len == 0) return 0;
-
-    strm->avail_in  -= len;
-
-    if (strm->state->wrap == 1) {
-        strm->adler = adler32(strm->adler, strm->next_in, len);
-    }
-#ifdef GZIP
-    else if (strm->state->wrap == 2) {
-        strm->adler = crc32(strm->adler, strm->next_in, len);
-    }
-#endif
-    zmemcpy(buf, strm->next_in, len);
-    strm->next_in  += len;
-    strm->total_in += len;
-
-    return (int)len;
-}
-
-/* ===========================================================================
- * Initialize the "longest match" routines for a new zlib stream
- */
-local void lm_init (s)
-    deflate_state *s;
-{
-    s->window_size = (ulg)2L*s->w_size;
-
-    CLEAR_HASH(s);
-
-    /* Set the default configuration parameters:
-     */
-    s->max_lazy_match   = configuration_table[s->level].max_lazy;
-    s->good_match       = configuration_table[s->level].good_length;
-    s->nice_match       = configuration_table[s->level].nice_length;
-    s->max_chain_length = configuration_table[s->level].max_chain;
-
-    s->strstart = 0;
-    s->block_start = 0L;
-    s->lookahead = 0;
-    s->match_length = s->prev_length = MIN_MATCH-1;
-    s->match_available = 0;
-    s->ins_h = 0;
-#ifndef FASTEST
-#ifdef ASMV
-    match_init(); /* initialize the asm code */
-#endif
-#endif
-}
-
-#ifndef FASTEST
-/* ===========================================================================
- * Set match_start to the longest match starting at the given string and
- * return its length. Matches shorter or equal to prev_length are discarded,
- * in which case the result is equal to prev_length and match_start is
- * garbage.
- * IN assertions: cur_match is the head of the hash chain for the current
- *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
- * OUT assertion: the match length is not greater than s->lookahead.
- */
-#ifndef ASMV
-/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
- * match.S. The code will be functionally equivalent.
- */
-local uInt longest_match(s, cur_match)
-    deflate_state *s;
-    IPos cur_match;                             /* current match */
-{
-    unsigned chain_length = s->max_chain_length;/* max hash chain length */
-    register Bytef *scan = s->window + s->strstart; /* current string */
-    register Bytef *match;                       /* matched string */
-    register int len;                           /* length of current match */
-    int best_len = s->prev_length;              /* best match length so far */
-    int nice_match = s->nice_match;             /* stop if match long enough */
-    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
-        s->strstart - (IPos)MAX_DIST(s) : NIL;
-    /* Stop when cur_match becomes <= limit. To simplify the code,
-     * we prevent matches with the string of window index 0.
-     */
-    Posf *prev = s->prev;
-    uInt wmask = s->w_mask;
-
-#ifdef UNALIGNED_OK
-    /* Compare two bytes at a time. Note: this is not always beneficial.
-     * Try with and without -DUNALIGNED_OK to check.
-     */
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
-    register ush scan_start = *(ushf*)scan;
-    register ush scan_end   = *(ushf*)(scan+best_len-1);
-#else
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
-    register Byte scan_end1  = scan[best_len-1];
-    register Byte scan_end   = scan[best_len];
-#endif
-
-    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
-     * It is easy to get rid of this optimization if necessary.
-     */
-    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
-
-    /* Do not waste too much time if we already have a good match: */
-    if (s->prev_length >= s->good_match) {
-        chain_length >>= 2;
-    }
-    /* Do not look for matches beyond the end of the input. This is necessary
-     * to make deflate deterministic.
-     */
-    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
-
-    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
-
-    do {
-        Assert(cur_match < s->strstart, "no future");
-        match = s->window + cur_match;
-
-        /* Skip to next match if the match length cannot increase
-         * or if the match length is less than 2.  Note that the checks below
-         * for insufficient lookahead only occur occasionally for performance
-         * reasons.  Therefore uninitialized memory will be accessed, and
-         * conditional jumps will be made that depend on those values.
-         * However the length of the match is limited to the lookahead, so
-         * the output of deflate is not affected by the uninitialized values.
-         */
-#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
-        /* This code assumes sizeof(unsigned short) == 2. Do not use
-         * UNALIGNED_OK if your compiler uses a different size.
-         */
-        if (*(ushf*)(match+best_len-1) != scan_end ||
-            *(ushf*)match != scan_start) continue;
-
-        /* It is not necessary to compare scan[2] and match[2] since they are
-         * always equal when the other bytes match, given that the hash keys
-         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
-         * strstart+3, +5, ... up to strstart+257. We check for insufficient
-         * lookahead only every 4th comparison; the 128th check will be made
-         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
-         * necessary to put more guard bytes at the end of the window, or
-         * to check more often for insufficient lookahead.
-         */
-        Assert(scan[2] == match[2], "scan[2]?");
-        scan++, match++;
-        do {
-        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
-                 scan < strend);
-        /* The funny "do {}" generates better code on most compilers */
-
-        /* Here, scan <= window+strstart+257 */
-        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
-        if (*scan == *match) scan++;
-
-        len = (MAX_MATCH - 1) - (int)(strend-scan);
-        scan = strend - (MAX_MATCH-1);
-
-#else /* UNALIGNED_OK */
-
-        if (match[best_len]   != scan_end  ||
-            match[best_len-1] != scan_end1 ||
-            *match            != *scan     ||
-            *++match          != scan[1])      continue;
-
-        /* The check at best_len-1 can be removed because it will be made
-         * again later. (This heuristic is not always a win.)
-         * It is not necessary to compare scan[2] and match[2] since they
-         * are always equal when the other bytes match, given that
-         * the hash keys are equal and that HASH_BITS >= 8.
-         */
-        scan += 2, match++;
-        Assert(*scan == *match, "match[2]?");
-
-        /* We check for insufficient lookahead only every 8th comparison;
-         * the 256th check will be made at strstart+258.
-         */
-        do {
-        } while (*++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 scan < strend);
-
-        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
-
-        len = MAX_MATCH - (int)(strend - scan);
-        scan = strend - MAX_MATCH;
-
-#endif /* UNALIGNED_OK */
-
-        if (len > best_len) {
-            s->match_start = cur_match;
-            best_len = len;
-            if (len >= nice_match) break;
-#ifdef UNALIGNED_OK
-            scan_end = *(ushf*)(scan+best_len-1);
-#else
-            scan_end1  = scan[best_len-1];
-            scan_end   = scan[best_len];
-#endif
-        }
-    } while ((cur_match = prev[cur_match & wmask]) > limit
-             && --chain_length != 0);
-
-    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
-    return s->lookahead;
-}
-#endif /* ASMV */
-#endif /* FASTEST */
-
-/* ---------------------------------------------------------------------------
- * Optimized version for level == 1 or strategy == Z_RLE only
- */
-local uInt longest_match_fast(s, cur_match)
-    deflate_state *s;
-    IPos cur_match;                             /* current match */
-{
-    register Bytef *scan = s->window + s->strstart; /* current string */
-    register Bytef *match;                       /* matched string */
-    register int len;                           /* length of current match */
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
-
-    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
-     * It is easy to get rid of this optimization if necessary.
-     */
-    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
-
-    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
-
-    Assert(cur_match < s->strstart, "no future");
-
-    match = s->window + cur_match;
-
-    /* Return failure if the match length is less than 2:
-     */
-    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;
-
-    /* The check at best_len-1 can be removed because it will be made
-     * again later. (This heuristic is not always a win.)
-     * It is not necessary to compare scan[2] and match[2] since they
-     * are always equal when the other bytes match, given that
-     * the hash keys are equal and that HASH_BITS >= 8.
-     */
-    scan += 2, match += 2;
-    Assert(*scan == *match, "match[2]?");
-
-    /* We check for insufficient lookahead only every 8th comparison;
-     * the 256th check will be made at strstart+258.
-     */
-    do {
-    } while (*++scan == *++match && *++scan == *++match &&
-             *++scan == *++match && *++scan == *++match &&
-             *++scan == *++match && *++scan == *++match &&
-             *++scan == *++match && *++scan == *++match &&
-             scan < strend);
-
-    Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
-
-    len = MAX_MATCH - (int)(strend - scan);
-
-    if (len < MIN_MATCH) return MIN_MATCH - 1;
-
-    s->match_start = cur_match;
-    return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;
-}
-
-#ifdef DEBUG
-/* ===========================================================================
- * Check that the match at match_start is indeed a match.
- */
-local void check_match(s, start, match, length)
-    deflate_state *s;
-    IPos start, match;
-    int length;
-{
-    /* check that the match is indeed a match */
-    if (zmemcmp(s->window + match,
-                s->window + start, length) != EQUAL) {
-        fprintf(stderr, " start %u, match %u, length %d\n",
-                start, match, length);
-        do {
-            fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
-        } while (--length != 0);
-        z_error("invalid match");
-    }
-    if (z_verbose > 1) {
-        fprintf(stderr,"\\[%d,%d]", start-match, length);
-        do { putc(s->window[start++], stderr); } while (--length != 0);
-    }
-}
-#else
-#  define check_match(s, start, match, length)
-#endif /* DEBUG */
-
-/* ===========================================================================
- * Fill the window when the lookahead becomes insufficient.
- * Updates strstart and lookahead.
- *
- * IN assertion: lookahead < MIN_LOOKAHEAD
- * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
- *    At least one byte has been read, or avail_in == 0; reads are
- *    performed for at least two bytes (required for the zip translate_eol
- *    option -- not supported here).
- */
-local void fill_window(s)
-    deflate_state *s;
-{
-    register unsigned n, m;
-    register Posf *p;
-    unsigned more;    /* Amount of free space at the end of the window. */
-    uInt wsize = s->w_size;
-
-    do {
-        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
-
-        /* Deal with !@#$% 64K limit: */
-        if (sizeof(int) <= 2) {
-            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
-                more = wsize;
-
-            } else if (more == (unsigned)(-1)) {
-                /* Very unlikely, but possible on 16 bit machine if
-                 * strstart == 0 && lookahead == 1 (input done a byte at time)
-                 */
-                more--;
-            }
-        }
-
-        /* If the window is almost full and there is insufficient lookahead,
-         * move the upper half to the lower one to make room in the upper half.
-         */
-        if (s->strstart >= wsize+MAX_DIST(s)) {
-
-            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);
-            s->match_start -= wsize;
-            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
-            s->block_start -= (long) wsize;
-
-            /* Slide the hash table (could be avoided with 32 bit values
-               at the expense of memory usage). We slide even when level == 0
-               to keep the hash table consistent if we switch back to level > 0
-               later. (Using level 0 permanently is not an optimal usage of
-               zlib, so we don't care about this pathological case.)
-             */
-            /* %%% avoid this when Z_RLE */
-            n = s->hash_size;
-            p = &s->head[n];
-            do {
-                m = *--p;
-                *p = (Pos)(m >= wsize ? m-wsize : NIL);
-            } while (--n);
-
-            n = wsize;
-#ifndef FASTEST
-            p = &s->prev[n];
-            do {
-                m = *--p;
-                *p = (Pos)(m >= wsize ? m-wsize : NIL);
-                /* If n is not on any hash chain, prev[n] is garbage but
-                 * its value will never be used.
-                 */
-            } while (--n);
-#endif
-            more += wsize;
-        }
-        if (s->strm->avail_in == 0) return;
-
-        /* If there was no sliding:
-         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
-         *    more == window_size - lookahead - strstart
-         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
-         * => more >= window_size - 2*WSIZE + 2
-         * In the BIG_MEM or MMAP case (not yet supported),
-         *   window_size == input_size + MIN_LOOKAHEAD  &&
-         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
-         * Otherwise, window_size == 2*WSIZE so more >= 2.
-         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
-         */
-        Assert(more >= 2, "more < 2");
-
-        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
-        s->lookahead += n;
-
-        /* Initialize the hash value now that we have some input: */
-        if (s->lookahead >= MIN_MATCH) {
-            s->ins_h = s->window[s->strstart];
-            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
-#if MIN_MATCH != 3
-            Call UPDATE_HASH() MIN_MATCH-3 more times
-#endif
-        }
-        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
-         * but this is not important since only literal bytes will be emitted.
-         */
-
-    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
-}
-
-/* ===========================================================================
- * Flush the current block, with given end-of-file flag.
- * IN assertion: strstart is set to the end of the current match.
- */
-#define FLUSH_BLOCK_ONLY(s, eof) { \
-   _tr_flush_block(s, (s->block_start >= 0L ? \
-                   (charf *)&s->window[(unsigned)s->block_start] : \
-                   (charf *)Z_NULL), \
-                (ulg)((long)s->strstart - s->block_start), \
-                (eof)); \
-   s->block_start = s->strstart; \
-   flush_pending(s->strm); \
-   Tracev((stderr,"[FLUSH]")); \
-}
-
-/* Same but force premature exit if necessary. */
-#define FLUSH_BLOCK(s, eof) { \
-   FLUSH_BLOCK_ONLY(s, eof); \
-   if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \
-}
-
-/* ===========================================================================
- * Copy without compression as much as possible from the input stream, return
- * the current block state.
- * This function does not insert new strings in the dictionary since
- * uncompressible data is probably not useful. This function is used
- * only for the level=0 compression option.
- * NOTE: this function should be optimized to avoid extra copying from
- * window to pending_buf.
- */
-local block_state deflate_stored(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
-     * to pending_buf_size, and each stored block has a 5 byte header:
-     */
-    ulg max_block_size = 0xffff;
-    ulg max_start;
-
-    if (max_block_size > s->pending_buf_size - 5) {
-        max_block_size = s->pending_buf_size - 5;
-    }
-
-    /* Copy as much as possible from input to output: */
-    for (;;) {
-        /* Fill the window as much as possible: */
-        if (s->lookahead <= 1) {
-
-            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
-                   s->block_start >= (long)s->w_size, "slide too late");
-
-            fill_window(s);
-            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;
-
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-        Assert(s->block_start >= 0L, "block gone");
-
-        s->strstart += s->lookahead;
-        s->lookahead = 0;
-
-        /* Emit a stored block if pending_buf will be full: */
-        max_start = s->block_start + max_block_size;
-        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
-            /* strstart == 0 is possible when wraparound on 16-bit machine */
-            s->lookahead = (uInt)(s->strstart - max_start);
-            s->strstart = (uInt)max_start;
-            FLUSH_BLOCK(s, 0);
-        }
-        /* Flush if we may have to slide, otherwise block_start may become
-         * negative and the data will be gone:
-         */
-        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
-            FLUSH_BLOCK(s, 0);
-        }
-    }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
-}
-
-/* ===========================================================================
- * Compress as much as possible from the input stream, return the current
- * block state.
- * This function does not perform lazy evaluation of matches and inserts
- * new strings in the dictionary only for unmatched strings or for short
- * matches. It is used only for the fast compression options.
- */
-local block_state deflate_fast(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    IPos hash_head = NIL; /* head of the hash chain */
-    int bflush;           /* set if current block must be flushed */
-
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the next match, plus MIN_MATCH bytes to insert the
-         * string following the next match.
-         */
-        if (s->lookahead < MIN_LOOKAHEAD) {
-            fill_window(s);
-            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-
-        /* Insert the string window[strstart .. strstart+2] in the
-         * dictionary, and set hash_head to the head of the hash chain:
-         */
-        if (s->lookahead >= MIN_MATCH) {
-            INSERT_STRING(s, s->strstart, hash_head);
-        }
-
-        /* Find the longest match, discarding those <= prev_length.
-         * At this point we have always match_length < MIN_MATCH
-         */
-        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
-            /* To simplify the code, we prevent matches with the string
-             * of window index 0 (in particular we have to avoid a match
-             * of the string with itself at the start of the input file).
-             */
-#ifdef FASTEST
-            if ((s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) ||
-                (s->strategy == Z_RLE && s->strstart - hash_head == 1)) {
-                s->match_length = longest_match_fast (s, hash_head);
-            }
-#else
-            if (s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) {
-                s->match_length = longest_match (s, hash_head);
-            } else if (s->strategy == Z_RLE && s->strstart - hash_head == 1) {
-                s->match_length = longest_match_fast (s, hash_head);
-            }
-#endif
-            /* longest_match() or longest_match_fast() sets match_start */
-        }
-        if (s->match_length >= MIN_MATCH) {
-            check_match(s, s->strstart, s->match_start, s->match_length);
-
-            _tr_tally_dist(s, s->strstart - s->match_start,
-                           s->match_length - MIN_MATCH, bflush);
-
-            s->lookahead -= s->match_length;
-
-            /* Insert new strings in the hash table only if the match length
-             * is not too large. This saves time but degrades compression.
-             */
-#ifndef FASTEST
-            if (s->match_length <= s->max_insert_length &&
-                s->lookahead >= MIN_MATCH) {
-                s->match_length--; /* string at strstart already in table */
-                do {
-                    s->strstart++;
-                    INSERT_STRING(s, s->strstart, hash_head);
-                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
-                     * always MIN_MATCH bytes ahead.
-                     */
-                } while (--s->match_length != 0);
-                s->strstart++;
-            } else
-#endif
-            {
-                s->strstart += s->match_length;
-                s->match_length = 0;
-                s->ins_h = s->window[s->strstart];
-                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
-#if MIN_MATCH != 3
-                Call UPDATE_HASH() MIN_MATCH-3 more times
-#endif
-                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
-                 * matter since it will be recomputed at next deflate call.
-                 */
-            }
-        } else {
-            /* No match, output a literal byte */
-            Tracevv((stderr,"%c", s->window[s->strstart]));
-            _tr_tally_lit (s, s->window[s->strstart], bflush);
-            s->lookahead--;
-            s->strstart++;
-        }
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
-}
-
-#ifndef FASTEST
-/* ===========================================================================
- * Same as above, but achieves better compression. We use a lazy
- * evaluation for matches: a match is finally adopted only if there is
- * no better match at the next window position.
- */
-local block_state deflate_slow(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    IPos hash_head = NIL;    /* head of hash chain */
-    int bflush;              /* set if current block must be flushed */
-
-    /* Process the input block. */
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the next match, plus MIN_MATCH bytes to insert the
-         * string following the next match.
-         */
-        if (s->lookahead < MIN_LOOKAHEAD) {
-            fill_window(s);
-            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-
-        /* Insert the string window[strstart .. strstart+2] in the
-         * dictionary, and set hash_head to the head of the hash chain:
-         */
-        if (s->lookahead >= MIN_MATCH) {
-            INSERT_STRING(s, s->strstart, hash_head);
-        }
-
-        /* Find the longest match, discarding those <= prev_length.
-         */
-        s->prev_length = s->match_length, s->prev_match = s->match_start;
-        s->match_length = MIN_MATCH-1;
-
-        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
-            s->strstart - hash_head <= MAX_DIST(s)) {
-            /* To simplify the code, we prevent matches with the string
-             * of window index 0 (in particular we have to avoid a match
-             * of the string with itself at the start of the input file).
-             */
-            if (s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) {
-                s->match_length = longest_match (s, hash_head);
-            } else if (s->strategy == Z_RLE && s->strstart - hash_head == 1) {
-                s->match_length = longest_match_fast (s, hash_head);
-            }
-            /* longest_match() or longest_match_fast() sets match_start */
-
-            if (s->match_length <= 5 && (s->strategy == Z_FILTERED
-#if TOO_FAR <= 32767
-                || (s->match_length == MIN_MATCH &&
-                    s->strstart - s->match_start > TOO_FAR)
-#endif
-                )) {
-
-                /* If prev_match is also MIN_MATCH, match_start is garbage
-                 * but we will ignore the current match anyway.
-                 */
-                s->match_length = MIN_MATCH-1;
-            }
-        }
-        /* If there was a match at the previous step and the current
-         * match is not better, output the previous match:
-         */
-        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
-            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
-            /* Do not insert strings in hash table beyond this. */
-
-            check_match(s, s->strstart-1, s->prev_match, s->prev_length);
-
-            _tr_tally_dist(s, s->strstart -1 - s->prev_match,
-                           s->prev_length - MIN_MATCH, bflush);
-
-            /* Insert in hash table all strings up to the end of the match.
-             * strstart-1 and strstart are already inserted. If there is not
-             * enough lookahead, the last two strings are not inserted in
-             * the hash table.
-             */
-            s->lookahead -= s->prev_length-1;
-            s->prev_length -= 2;
-            do {
-                if (++s->strstart <= max_insert) {
-                    INSERT_STRING(s, s->strstart, hash_head);
-                }
-            } while (--s->prev_length != 0);
-            s->match_available = 0;
-            s->match_length = MIN_MATCH-1;
-            s->strstart++;
-
-            if (bflush) FLUSH_BLOCK(s, 0);
-
-        } else if (s->match_available) {
-            /* If there was no match at the previous position, output a
-             * single literal. If there was a match but the current match
-             * is longer, truncate the previous match to a single literal.
-             */
-            Tracevv((stderr,"%c", s->window[s->strstart-1]));
-            _tr_tally_lit(s, s->window[s->strstart-1], bflush);
-            if (bflush) {
-                FLUSH_BLOCK_ONLY(s, 0);
-            }
-            s->strstart++;
-            s->lookahead--;
-            if (s->strm->avail_out == 0) return need_more;
-        } else {
-            /* There is no previous match to compare with, wait for
-             * the next step to decide.
-             */
-            s->match_available = 1;
-            s->strstart++;
-            s->lookahead--;
-        }
-    }
-    Assert (flush != Z_NO_FLUSH, "no flush?");
-    if (s->match_available) {
-        Tracevv((stderr,"%c", s->window[s->strstart-1]));
-        _tr_tally_lit(s, s->window[s->strstart-1], bflush);
-        s->match_available = 0;
-    }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
-}
-#endif /* FASTEST */
-
-#if 0
-/* ===========================================================================
- * For Z_RLE, simply look for runs of bytes, generate matches only of distance
- * one.  Do not maintain a hash table.  (It will be regenerated if this run of
- * deflate switches away from Z_RLE.)
- */
-local block_state deflate_rle(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    int bflush;         /* set if current block must be flushed */
-    uInt run;           /* length of run */
-    uInt max;           /* maximum length of run */
-    uInt prev;          /* byte at distance one to match */
-    Bytef *scan;        /* scan for end of run */
-
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the longest encodable run.
-         */
-        if (s->lookahead < MAX_MATCH) {
-            fill_window(s);
-            if (s->lookahead < MAX_MATCH && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-
-        /* See how many times the previous byte repeats */
-        run = 0;
-        if (s->strstart > 0) {      /* if there is a previous byte, that is */
-            max = s->lookahead < MAX_MATCH ? s->lookahead : MAX_MATCH;
-            scan = s->window + s->strstart - 1;
-            prev = *scan++;
-            do {
-                if (*scan++ != prev)
-                    break;
-            } while (++run < max);
-        }
-
-        /* Emit match if have run of MIN_MATCH or longer, else emit literal */
-        if (run >= MIN_MATCH) {
-            check_match(s, s->strstart, s->strstart - 1, run);
-            _tr_tally_dist(s, 1, run - MIN_MATCH, bflush);
-            s->lookahead -= run;
-            s->strstart += run;
-        } else {
-            /* No match, output a literal byte */
-            Tracevv((stderr,"%c", s->window[s->strstart]));
-            _tr_tally_lit (s, s->window[s->strstart], bflush);
-            s->lookahead--;
-            s->strstart++;
-        }
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    FLUSH_BLOCK(s, flush == Z_FINISH);
-    return flush == Z_FINISH ? finish_done : block_done;
-}
-#endif
diff -Nbaur gcc-4.6.3/zlib/deflate.h gcc-4.6.3-psp/zlib/deflate.h
--- gcc-4.6.3/zlib/deflate.h	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/deflate.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,331 +0,0 @@
-/* deflate.h -- internal compression state
- * Copyright (C) 1995-2004 Jean-loup Gailly
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* @(#) $Id: deflate.h,v 1.1.1.2 2002/03/11 21:53:23 tromey Exp $ */
-
-#ifndef DEFLATE_H
-#define DEFLATE_H
-
-#include "zutil.h"
-
-/* define NO_GZIP when compiling if you want to disable gzip header and
-   trailer creation by deflate().  NO_GZIP would be used to avoid linking in
-   the crc code when it is not needed.  For shared libraries, gzip encoding
-   should be left enabled. */
-#ifndef NO_GZIP
-#  define GZIP
-#endif
-
-/* ===========================================================================
- * Internal compression state.
- */
-
-#define LENGTH_CODES 29
-/* number of length codes, not counting the special END_BLOCK code */
-
-#define LITERALS  256
-/* number of literal bytes 0..255 */
-
-#define L_CODES (LITERALS+1+LENGTH_CODES)
-/* number of Literal or Length codes, including the END_BLOCK code */
-
-#define D_CODES   30
-/* number of distance codes */
-
-#define BL_CODES  19
-/* number of codes used to transfer the bit lengths */
-
-#define HEAP_SIZE (2*L_CODES+1)
-/* maximum heap size */
-
-#define MAX_BITS 15
-/* All codes must not exceed MAX_BITS bits */
-
-#define INIT_STATE    42
-#define EXTRA_STATE   69
-#define NAME_STATE    73
-#define COMMENT_STATE 91
-#define HCRC_STATE   103
-#define BUSY_STATE   113
-#define FINISH_STATE 666
-/* Stream status */
-
-
-/* Data structure describing a single value and its code string. */
-typedef struct ct_data_s {
-    union {
-        ush  freq;       /* frequency count */
-        ush  code;       /* bit string */
-    } fc;
-    union {
-        ush  dad;        /* father node in Huffman tree */
-        ush  len;        /* length of bit string */
-    } dl;
-} FAR ct_data;
-
-#define Freq fc.freq
-#define Code fc.code
-#define Dad  dl.dad
-#define Len  dl.len
-
-typedef struct static_tree_desc_s  static_tree_desc;
-
-typedef struct tree_desc_s {
-    ct_data *dyn_tree;           /* the dynamic tree */
-    int     max_code;            /* largest code with non zero frequency */
-    static_tree_desc *stat_desc; /* the corresponding static tree */
-} FAR tree_desc;
-
-typedef ush Pos;
-typedef Pos FAR Posf;
-typedef unsigned IPos;
-
-/* A Pos is an index in the character window. We use short instead of int to
- * save space in the various tables. IPos is used only for parameter passing.
- */
-
-typedef struct internal_state {
-    z_streamp strm;      /* pointer back to this zlib stream */
-    int   status;        /* as the name implies */
-    Bytef *pending_buf;  /* output still pending */
-    ulg   pending_buf_size; /* size of pending_buf */
-    Bytef *pending_out;  /* next pending byte to output to the stream */
-    uInt   pending;      /* nb of bytes in the pending buffer */
-    int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */
-    gz_headerp  gzhead;  /* gzip header information to write */
-    uInt   gzindex;      /* where in extra, name, or comment */
-    Byte  method;        /* STORED (for zip only) or DEFLATED */
-    int   last_flush;    /* value of flush param for previous deflate call */
-
-                /* used by deflate.c: */
-
-    uInt  w_size;        /* LZ77 window size (32K by default) */
-    uInt  w_bits;        /* log2(w_size)  (8..16) */
-    uInt  w_mask;        /* w_size - 1 */
-
-    Bytef *window;
-    /* Sliding window. Input bytes are read into the second half of the window,
-     * and move to the first half later to keep a dictionary of at least wSize
-     * bytes. With this organization, matches are limited to a distance of
-     * wSize-MAX_MATCH bytes, but this ensures that IO is always
-     * performed with a length multiple of the block size. Also, it limits
-     * the window size to 64K, which is quite useful on MSDOS.
-     * To do: use the user input buffer as sliding window.
-     */
-
-    ulg window_size;
-    /* Actual size of window: 2*wSize, except when the user input buffer
-     * is directly used as sliding window.
-     */
-
-    Posf *prev;
-    /* Link to older string with same hash index. To limit the size of this
-     * array to 64K, this link is maintained only for the last 32K strings.
-     * An index in this array is thus a window index modulo 32K.
-     */
-
-    Posf *head; /* Heads of the hash chains or NIL. */
-
-    uInt  ins_h;          /* hash index of string to be inserted */
-    uInt  hash_size;      /* number of elements in hash table */
-    uInt  hash_bits;      /* log2(hash_size) */
-    uInt  hash_mask;      /* hash_size-1 */
-
-    uInt  hash_shift;
-    /* Number of bits by which ins_h must be shifted at each input
-     * step. It must be such that after MIN_MATCH steps, the oldest
-     * byte no longer takes part in the hash key, that is:
-     *   hash_shift * MIN_MATCH >= hash_bits
-     */
-
-    long block_start;
-    /* Window position at the beginning of the current output block. Gets
-     * negative when the window is moved backwards.
-     */
-
-    uInt match_length;           /* length of best match */
-    IPos prev_match;             /* previous match */
-    int match_available;         /* set if previous match exists */
-    uInt strstart;               /* start of string to insert */
-    uInt match_start;            /* start of matching string */
-    uInt lookahead;              /* number of valid bytes ahead in window */
-
-    uInt prev_length;
-    /* Length of the best match at previous step. Matches not greater than this
-     * are discarded. This is used in the lazy match evaluation.
-     */
-
-    uInt max_chain_length;
-    /* To speed up deflation, hash chains are never searched beyond this
-     * length.  A higher limit improves compression ratio but degrades the
-     * speed.
-     */
-
-    uInt max_lazy_match;
-    /* Attempt to find a better match only when the current match is strictly
-     * smaller than this value. This mechanism is used only for compression
-     * levels >= 4.
-     */
-#   define max_insert_length  max_lazy_match
-    /* Insert new strings in the hash table only if the match length is not
-     * greater than this length. This saves time but degrades compression.
-     * max_insert_length is used only for compression levels <= 3.
-     */
-
-    int level;    /* compression level (1..9) */
-    int strategy; /* favor or force Huffman coding*/
-
-    uInt good_match;
-    /* Use a faster search when the previous match is longer than this */
-
-    int nice_match; /* Stop searching when current match exceeds this */
-
-                /* used by trees.c: */
-    /* Didn't use ct_data typedef below to supress compiler warning */
-    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
-    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
-    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
-
-    struct tree_desc_s l_desc;               /* desc. for literal tree */
-    struct tree_desc_s d_desc;               /* desc. for distance tree */
-    struct tree_desc_s bl_desc;              /* desc. for bit length tree */
-
-    ush bl_count[MAX_BITS+1];
-    /* number of codes at each bit length for an optimal tree */
-
-    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
-    int heap_len;               /* number of elements in the heap */
-    int heap_max;               /* element of largest frequency */
-    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
-     * The same heap array is used to build all trees.
-     */
-
-    uch depth[2*L_CODES+1];
-    /* Depth of each subtree used as tie breaker for trees of equal frequency
-     */
-
-    uchf *l_buf;          /* buffer for literals or lengths */
-
-    uInt  lit_bufsize;
-    /* Size of match buffer for literals/lengths.  There are 4 reasons for
-     * limiting lit_bufsize to 64K:
-     *   - frequencies can be kept in 16 bit counters
-     *   - if compression is not successful for the first block, all input
-     *     data is still in the window so we can still emit a stored block even
-     *     when input comes from standard input.  (This can also be done for
-     *     all blocks if lit_bufsize is not greater than 32K.)
-     *   - if compression is not successful for a file smaller than 64K, we can
-     *     even emit a stored file instead of a stored block (saving 5 bytes).
-     *     This is applicable only for zip (not gzip or zlib).
-     *   - creating new Huffman trees less frequently may not provide fast
-     *     adaptation to changes in the input data statistics. (Take for
-     *     example a binary file with poorly compressible code followed by
-     *     a highly compressible string table.) Smaller buffer sizes give
-     *     fast adaptation but have of course the overhead of transmitting
-     *     trees more frequently.
-     *   - I can't count above 4
-     */
-
-    uInt last_lit;      /* running index in l_buf */
-
-    ushf *d_buf;
-    /* Buffer for distances. To simplify the code, d_buf and l_buf have
-     * the same number of elements. To use different lengths, an extra flag
-     * array would be necessary.
-     */
-
-    ulg opt_len;        /* bit length of current block with optimal trees */
-    ulg static_len;     /* bit length of current block with static trees */
-    uInt matches;       /* number of string matches in current block */
-    int last_eob_len;   /* bit length of EOB code for last block */
-
-#ifdef DEBUG
-    ulg compressed_len; /* total bit length of compressed file mod 2^32 */
-    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
-#endif
-
-    ush bi_buf;
-    /* Output buffer. bits are inserted starting at the bottom (least
-     * significant bits).
-     */
-    int bi_valid;
-    /* Number of valid bits in bi_buf.  All bits above the last valid bit
-     * are always zero.
-     */
-
-} FAR deflate_state;
-
-/* Output a byte on the stream.
- * IN assertion: there is enough room in pending_buf.
- */
-#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}
-
-
-#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
-/* Minimum amount of lookahead, except at the end of the input file.
- * See deflate.c for comments about the MIN_MATCH+1.
- */
-
-#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
-/* In order to simplify the code, particularly on 16 bit machines, match
- * distances are limited to MAX_DIST instead of WSIZE.
- */
-
-        /* in trees.c */
-void _tr_init         OF((deflate_state *s));
-int  _tr_tally        OF((deflate_state *s, unsigned dist, unsigned lc));
-void _tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,
-                          int eof));
-void _tr_align        OF((deflate_state *s));
-void _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,
-                          int eof));
-
-#define d_code(dist) \
-   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
-/* Mapping from a distance to a distance code. dist is the distance - 1 and
- * must not have side effects. _dist_code[256] and _dist_code[257] are never
- * used.
- */
-
-#ifndef DEBUG
-/* Inline versions of _tr_tally for speed: */
-
-#if defined(GEN_TREES_H) || !defined(STDC)
-  extern uch _length_code[];
-  extern uch _dist_code[];
-#else
-  extern const uch _length_code[];
-  extern const uch _dist_code[];
-#endif
-
-# define _tr_tally_lit(s, c, flush) \
-  { uch cc = (c); \
-    s->d_buf[s->last_lit] = 0; \
-    s->l_buf[s->last_lit++] = cc; \
-    s->dyn_ltree[cc].Freq++; \
-    flush = (s->last_lit == s->lit_bufsize-1); \
-   }
-# define _tr_tally_dist(s, distance, length, flush) \
-  { uch len = (length); \
-    ush dist = (distance); \
-    s->d_buf[s->last_lit] = dist; \
-    s->l_buf[s->last_lit++] = len; \
-    dist--; \
-    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
-    s->dyn_dtree[d_code(dist)].Freq++; \
-    flush = (s->last_lit == s->lit_bufsize-1); \
-  }
-#else
-# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
-# define _tr_tally_dist(s, distance, length, flush) \
-              flush = _tr_tally(s, distance, length)
-#endif
-
-#endif /* DEFLATE_H */
diff -Nbaur gcc-4.6.3/zlib/example.c gcc-4.6.3-psp/zlib/example.c
--- gcc-4.6.3/zlib/example.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/example.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,565 +0,0 @@
-/* example.c -- usage example of the zlib compression library
- * Copyright (C) 1995-2004 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id: example.c,v 1.1.1.2 2002/03/11 21:53:23 tromey Exp $ */
-
-#include <stdio.h>
-#include "zlib.h"
-
-#ifdef STDC
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-
-#if defined(VMS) || defined(RISCOS)
-#  define TESTFILE "foo-gz"
-#else
-#  define TESTFILE "foo.gz"
-#endif
-
-#define CHECK_ERR(err, msg) { \
-    if (err != Z_OK) { \
-        fprintf(stderr, "%s error: %d\n", msg, err); \
-        exit(1); \
-    } \
-}
-
-const char hello[] = "hello, hello!";
-/* "hello world" would be more standard, but the repeated "hello"
- * stresses the compression code better, sorry...
- */
-
-const char dictionary[] = "hello";
-uLong dictId; /* Adler32 value of the dictionary */
-
-void test_compress      OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_gzio          OF((const char *fname,
-                            Byte *uncompr, uLong uncomprLen));
-void test_deflate       OF((Byte *compr, uLong comprLen));
-void test_inflate       OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_large_deflate OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_large_inflate OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_flush         OF((Byte *compr, uLong *comprLen));
-void test_sync          OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-void test_dict_deflate  OF((Byte *compr, uLong comprLen));
-void test_dict_inflate  OF((Byte *compr, uLong comprLen,
-                            Byte *uncompr, uLong uncomprLen));
-int  main               OF((int argc, char *argv[]));
-
-/* ===========================================================================
- * Test compress() and uncompress()
- */
-void test_compress(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    uLong len = (uLong)strlen(hello)+1;
-
-    err = compress(compr, &comprLen, (const Bytef*)hello, len);
-    CHECK_ERR(err, "compress");
-
-    strcpy((char*)uncompr, "garbage");
-
-    err = uncompress(uncompr, &uncomprLen, compr, comprLen);
-    CHECK_ERR(err, "uncompress");
-
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad uncompress\n");
-        exit(1);
-    } else {
-        printf("uncompress(): %s\n", (char *)uncompr);
-    }
-}
-
-/* ===========================================================================
- * Test read/write of .gz files
- */
-void test_gzio(fname, uncompr, uncomprLen)
-    const char *fname; /* compressed file name */
-    Byte *uncompr;
-    uLong uncomprLen;
-{
-#ifdef NO_GZCOMPRESS
-    fprintf(stderr, "NO_GZCOMPRESS -- gz* functions cannot compress\n");
-#else
-    int err;
-    int len = (int)strlen(hello)+1;
-    gzFile file;
-    z_off_t pos;
-
-    file = gzopen(fname, "wb");
-    if (file == NULL) {
-        fprintf(stderr, "gzopen error\n");
-        exit(1);
-    }
-    gzputc(file, 'h');
-    if (gzputs(file, "ello") != 4) {
-        fprintf(stderr, "gzputs err: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    if (gzprintf(file, ", %s!", "hello") != 8) {
-        fprintf(stderr, "gzprintf err: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    gzseek(file, 1L, SEEK_CUR); /* add one zero byte */
-    gzclose(file);
-
-    file = gzopen(fname, "rb");
-    if (file == NULL) {
-        fprintf(stderr, "gzopen error\n");
-        exit(1);
-    }
-    strcpy((char*)uncompr, "garbage");
-
-    if (gzread(file, uncompr, (unsigned)uncomprLen) != len) {
-        fprintf(stderr, "gzread err: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad gzread: %s\n", (char*)uncompr);
-        exit(1);
-    } else {
-        printf("gzread(): %s\n", (char*)uncompr);
-    }
-
-    pos = gzseek(file, -8L, SEEK_CUR);
-    if (pos != 6 || gztell(file) != pos) {
-        fprintf(stderr, "gzseek error, pos=%ld, gztell=%ld\n",
-                (long)pos, (long)gztell(file));
-        exit(1);
-    }
-
-    if (gzgetc(file) != ' ') {
-        fprintf(stderr, "gzgetc error\n");
-        exit(1);
-    }
-
-    if (gzungetc(' ', file) != ' ') {
-        fprintf(stderr, "gzungetc error\n");
-        exit(1);
-    }
-
-    gzgets(file, (char*)uncompr, (int)uncomprLen);
-    if (strlen((char*)uncompr) != 7) { /* " hello!" */
-        fprintf(stderr, "gzgets err after gzseek: %s\n", gzerror(file, &err));
-        exit(1);
-    }
-    if (strcmp((char*)uncompr, hello + 6)) {
-        fprintf(stderr, "bad gzgets after gzseek\n");
-        exit(1);
-    } else {
-        printf("gzgets() after gzseek: %s\n", (char*)uncompr);
-    }
-
-    gzclose(file);
-#endif
-}
-
-/* ===========================================================================
- * Test deflate() with small buffers
- */
-void test_deflate(compr, comprLen)
-    Byte *compr;
-    uLong comprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-    uLong len = (uLong)strlen(hello)+1;
-
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);
-    CHECK_ERR(err, "deflateInit");
-
-    c_stream.next_in  = (Bytef*)hello;
-    c_stream.next_out = compr;
-
-    while (c_stream.total_in != len && c_stream.total_out < comprLen) {
-        c_stream.avail_in = c_stream.avail_out = 1; /* force small buffers */
-        err = deflate(&c_stream, Z_NO_FLUSH);
-        CHECK_ERR(err, "deflate");
-    }
-    /* Finish the stream, still forcing small buffers: */
-    for (;;) {
-        c_stream.avail_out = 1;
-        err = deflate(&c_stream, Z_FINISH);
-        if (err == Z_STREAM_END) break;
-        CHECK_ERR(err, "deflate");
-    }
-
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-}
-
-/* ===========================================================================
- * Test inflate() with small buffers
- */
-void test_inflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = 0;
-    d_stream.next_out = uncompr;
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    while (d_stream.total_out < uncomprLen && d_stream.total_in < comprLen) {
-        d_stream.avail_in = d_stream.avail_out = 1; /* force small buffers */
-        err = inflate(&d_stream, Z_NO_FLUSH);
-        if (err == Z_STREAM_END) break;
-        CHECK_ERR(err, "inflate");
-    }
-
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad inflate\n");
-        exit(1);
-    } else {
-        printf("inflate(): %s\n", (char *)uncompr);
-    }
-}
-
-/* ===========================================================================
- * Test deflate() with large buffers and dynamic change of compression level
- */
-void test_large_deflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_BEST_SPEED);
-    CHECK_ERR(err, "deflateInit");
-
-    c_stream.next_out = compr;
-    c_stream.avail_out = (uInt)comprLen;
-
-    /* At this point, uncompr is still mostly zeroes, so it should compress
-     * very well:
-     */
-    c_stream.next_in = uncompr;
-    c_stream.avail_in = (uInt)uncomprLen;
-    err = deflate(&c_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "deflate");
-    if (c_stream.avail_in != 0) {
-        fprintf(stderr, "deflate not greedy\n");
-        exit(1);
-    }
-
-    /* Feed in already compressed data and switch to no compression: */
-    deflateParams(&c_stream, Z_NO_COMPRESSION, Z_DEFAULT_STRATEGY);
-    c_stream.next_in = compr;
-    c_stream.avail_in = (uInt)comprLen/2;
-    err = deflate(&c_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "deflate");
-
-    /* Switch back to compressing mode: */
-    deflateParams(&c_stream, Z_BEST_COMPRESSION, Z_FILTERED);
-    c_stream.next_in = uncompr;
-    c_stream.avail_in = (uInt)uncomprLen;
-    err = deflate(&c_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "deflate");
-
-    err = deflate(&c_stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        fprintf(stderr, "deflate should report Z_STREAM_END\n");
-        exit(1);
-    }
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-}
-
-/* ===========================================================================
- * Test inflate() with large buffers
- */
-void test_large_inflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = (uInt)comprLen;
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    for (;;) {
-        d_stream.next_out = uncompr;            /* discard the output */
-        d_stream.avail_out = (uInt)uncomprLen;
-        err = inflate(&d_stream, Z_NO_FLUSH);
-        if (err == Z_STREAM_END) break;
-        CHECK_ERR(err, "large inflate");
-    }
-
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    if (d_stream.total_out != 2*uncomprLen + comprLen/2) {
-        fprintf(stderr, "bad large inflate: %ld\n", d_stream.total_out);
-        exit(1);
-    } else {
-        printf("large_inflate(): OK\n");
-    }
-}
-
-/* ===========================================================================
- * Test deflate() with full flush
- */
-void test_flush(compr, comprLen)
-    Byte *compr;
-    uLong *comprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-    uInt len = (uInt)strlen(hello)+1;
-
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);
-    CHECK_ERR(err, "deflateInit");
-
-    c_stream.next_in  = (Bytef*)hello;
-    c_stream.next_out = compr;
-    c_stream.avail_in = 3;
-    c_stream.avail_out = (uInt)*comprLen;
-    err = deflate(&c_stream, Z_FULL_FLUSH);
-    CHECK_ERR(err, "deflate");
-
-    compr[3]++; /* force an error in first compressed block */
-    c_stream.avail_in = len - 3;
-
-    err = deflate(&c_stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        CHECK_ERR(err, "deflate");
-    }
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-
-    *comprLen = c_stream.total_out;
-}
-
-/* ===========================================================================
- * Test inflateSync()
- */
-void test_sync(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = 2; /* just read the zlib header */
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    d_stream.next_out = uncompr;
-    d_stream.avail_out = (uInt)uncomprLen;
-
-    inflate(&d_stream, Z_NO_FLUSH);
-    CHECK_ERR(err, "inflate");
-
-    d_stream.avail_in = (uInt)comprLen-2;   /* read all compressed data */
-    err = inflateSync(&d_stream);           /* but skip the damaged part */
-    CHECK_ERR(err, "inflateSync");
-
-    err = inflate(&d_stream, Z_FINISH);
-    if (err != Z_DATA_ERROR) {
-        fprintf(stderr, "inflate should report DATA_ERROR\n");
-        /* Because of incorrect adler32 */
-        exit(1);
-    }
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    printf("after inflateSync(): hel%s\n", (char *)uncompr);
-}
-
-/* ===========================================================================
- * Test deflate() with preset dictionary
- */
-void test_dict_deflate(compr, comprLen)
-    Byte *compr;
-    uLong comprLen;
-{
-    z_stream c_stream; /* compression stream */
-    int err;
-
-    c_stream.zalloc = (alloc_func)0;
-    c_stream.zfree = (free_func)0;
-    c_stream.opaque = (voidpf)0;
-
-    err = deflateInit(&c_stream, Z_BEST_COMPRESSION);
-    CHECK_ERR(err, "deflateInit");
-
-    err = deflateSetDictionary(&c_stream,
-                               (const Bytef*)dictionary, sizeof(dictionary));
-    CHECK_ERR(err, "deflateSetDictionary");
-
-    dictId = c_stream.adler;
-    c_stream.next_out = compr;
-    c_stream.avail_out = (uInt)comprLen;
-
-    c_stream.next_in = (Bytef*)hello;
-    c_stream.avail_in = (uInt)strlen(hello)+1;
-
-    err = deflate(&c_stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        fprintf(stderr, "deflate should report Z_STREAM_END\n");
-        exit(1);
-    }
-    err = deflateEnd(&c_stream);
-    CHECK_ERR(err, "deflateEnd");
-}
-
-/* ===========================================================================
- * Test inflate() with a preset dictionary
- */
-void test_dict_inflate(compr, comprLen, uncompr, uncomprLen)
-    Byte *compr, *uncompr;
-    uLong comprLen, uncomprLen;
-{
-    int err;
-    z_stream d_stream; /* decompression stream */
-
-    strcpy((char*)uncompr, "garbage");
-
-    d_stream.zalloc = (alloc_func)0;
-    d_stream.zfree = (free_func)0;
-    d_stream.opaque = (voidpf)0;
-
-    d_stream.next_in  = compr;
-    d_stream.avail_in = (uInt)comprLen;
-
-    err = inflateInit(&d_stream);
-    CHECK_ERR(err, "inflateInit");
-
-    d_stream.next_out = uncompr;
-    d_stream.avail_out = (uInt)uncomprLen;
-
-    for (;;) {
-        err = inflate(&d_stream, Z_NO_FLUSH);
-        if (err == Z_STREAM_END) break;
-        if (err == Z_NEED_DICT) {
-            if (d_stream.adler != dictId) {
-                fprintf(stderr, "unexpected dictionary");
-                exit(1);
-            }
-            err = inflateSetDictionary(&d_stream, (const Bytef*)dictionary,
-                                       sizeof(dictionary));
-        }
-        CHECK_ERR(err, "inflate with dict");
-    }
-
-    err = inflateEnd(&d_stream);
-    CHECK_ERR(err, "inflateEnd");
-
-    if (strcmp((char*)uncompr, hello)) {
-        fprintf(stderr, "bad inflate with dict\n");
-        exit(1);
-    } else {
-        printf("inflate with dictionary: %s\n", (char *)uncompr);
-    }
-}
-
-/* ===========================================================================
- * Usage:  example [output.gz  [input.gz]]
- */
-
-int main(argc, argv)
-    int argc;
-    char *argv[];
-{
-    Byte *compr, *uncompr;
-    uLong comprLen = 10000*sizeof(int); /* don't overflow on MSDOS */
-    uLong uncomprLen = comprLen;
-    static const char* myVersion = ZLIB_VERSION;
-
-    if (zlibVersion()[0] != myVersion[0]) {
-        fprintf(stderr, "incompatible zlib version\n");
-        exit(1);
-
-    } else if (strcmp(zlibVersion(), ZLIB_VERSION) != 0) {
-        fprintf(stderr, "warning: different zlib version\n");
-    }
-
-    printf("zlib version %s = 0x%04x, compile flags = 0x%lx\n",
-            ZLIB_VERSION, ZLIB_VERNUM, zlibCompileFlags());
-
-    compr    = (Byte*)calloc((uInt)comprLen, 1);
-    uncompr  = (Byte*)calloc((uInt)uncomprLen, 1);
-    /* compr and uncompr are cleared to avoid reading uninitialized
-     * data and to ensure that uncompr compresses well.
-     */
-    if (compr == Z_NULL || uncompr == Z_NULL) {
-        printf("out of memory\n");
-        exit(1);
-    }
-    test_compress(compr, comprLen, uncompr, uncomprLen);
-
-    test_gzio((argc > 1 ? argv[1] : TESTFILE),
-              uncompr, uncomprLen);
-
-    test_deflate(compr, comprLen);
-    test_inflate(compr, comprLen, uncompr, uncomprLen);
-
-    test_large_deflate(compr, comprLen, uncompr, uncomprLen);
-    test_large_inflate(compr, comprLen, uncompr, uncomprLen);
-
-    test_flush(compr, &comprLen);
-    test_sync(compr, comprLen, uncompr, uncomprLen);
-    comprLen = uncomprLen;
-
-    test_dict_deflate(compr, comprLen);
-    test_dict_inflate(compr, comprLen, uncompr, uncomprLen);
-
-    free(compr);
-    free(uncompr);
-
-    return 0;
-}
diff -Nbaur gcc-4.6.3/zlib/examples/fitblk.c gcc-4.6.3-psp/zlib/examples/fitblk.c
--- gcc-4.6.3/zlib/examples/fitblk.c	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/examples/fitblk.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,233 +0,0 @@
-/* fitblk.c: example of fitting compressed output to a specified size
-   Not copyrighted -- provided to the public domain
-   Version 1.1  25 November 2004  Mark Adler */
-
-/* Version history:
-   1.0  24 Nov 2004  First version
-   1.1  25 Nov 2004  Change deflateInit2() to deflateInit()
-                     Use fixed-size, stack-allocated raw buffers
-                     Simplify code moving compression to subroutines
-                     Use assert() for internal errors
-                     Add detailed description of approach
- */
-
-/* Approach to just fitting a requested compressed size:
-
-   fitblk performs three compression passes on a portion of the input
-   data in order to determine how much of that input will compress to
-   nearly the requested output block size.  The first pass generates
-   enough deflate blocks to produce output to fill the requested
-   output size plus a specfied excess amount (see the EXCESS define
-   below).  The last deflate block may go quite a bit past that, but
-   is discarded.  The second pass decompresses and recompresses just
-   the compressed data that fit in the requested plus excess sized
-   buffer.  The deflate process is terminated after that amount of
-   input, which is less than the amount consumed on the first pass.
-   The last deflate block of the result will be of a comparable size
-   to the final product, so that the header for that deflate block and
-   the compression ratio for that block will be about the same as in
-   the final product.  The third compression pass decompresses the
-   result of the second step, but only the compressed data up to the
-   requested size minus an amount to allow the compressed stream to
-   complete (see the MARGIN define below).  That will result in a
-   final compressed stream whose length is less than or equal to the
-   requested size.  Assuming sufficient input and a requested size
-   greater than a few hundred bytes, the shortfall will typically be
-   less than ten bytes.
-
-   If the input is short enough that the first compression completes
-   before filling the requested output size, then that compressed
-   stream is return with no recompression.
-
-   EXCESS is chosen to be just greater than the shortfall seen in a
-   two pass approach similar to the above.  That shortfall is due to
-   the last deflate block compressing more efficiently with a smaller
-   header on the second pass.  EXCESS is set to be large enough so
-   that there is enough uncompressed data for the second pass to fill
-   out the requested size, and small enough so that the final deflate
-   block of the second pass will be close in size to the final deflate
-   block of the third and final pass.  MARGIN is chosen to be just
-   large enough to assure that the final compression has enough room
-   to complete in all cases.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <assert.h>
-#include "zlib.h"
-
-#define local static
-
-/* print nastygram and leave */
-local void quit(char *why)
-{
-    fprintf(stderr, "fitblk abort: %s\n", why);
-    exit(1);
-}
-
-#define RAWLEN 4096    /* intermediate uncompressed buffer size */
-
-/* compress from file to def until provided buffer is full or end of
-   input reached; return last deflate() return value, or Z_ERRNO if
-   there was read error on the file */
-local int partcompress(FILE *in, z_streamp def)
-{
-    int ret, flush;
-    unsigned char raw[RAWLEN];
-
-    flush = Z_NO_FLUSH;
-    do {
-        def->avail_in = fread(raw, 1, RAWLEN, in);
-        if (ferror(in))
-            return Z_ERRNO;
-        def->next_in = raw;
-        if (feof(in))
-            flush = Z_FINISH;
-        ret = deflate(def, flush);
-        assert(ret != Z_STREAM_ERROR);
-    } while (def->avail_out != 0 && flush == Z_NO_FLUSH);
-    return ret;
-}
-
-/* recompress from inf's input to def's output; the input for inf and
-   the output for def are set in those structures before calling;
-   return last deflate() return value, or Z_MEM_ERROR if inflate()
-   was not able to allocate enough memory when it needed to */
-local int recompress(z_streamp inf, z_streamp def)
-{
-    int ret, flush;
-    unsigned char raw[RAWLEN];
-
-    flush = Z_NO_FLUSH;
-    do {
-        /* decompress */
-        inf->avail_out = RAWLEN;
-        inf->next_out = raw;
-        ret = inflate(inf, Z_NO_FLUSH);
-        assert(ret != Z_STREAM_ERROR && ret != Z_DATA_ERROR &&
-               ret != Z_NEED_DICT);
-        if (ret == Z_MEM_ERROR)
-            return ret;
-
-        /* compress what was decompresed until done or no room */
-        def->avail_in = RAWLEN - inf->avail_out;
-        def->next_in = raw;
-        if (inf->avail_out != 0)
-            flush = Z_FINISH;
-        ret = deflate(def, flush);
-        assert(ret != Z_STREAM_ERROR);
-    } while (ret != Z_STREAM_END && def->avail_out != 0);
-    return ret;
-}
-
-#define EXCESS 256      /* empirically determined stream overage */
-#define MARGIN 8        /* amount to back off for completion */
-
-/* compress from stdin to fixed-size block on stdout */
-int main(int argc, char **argv)
-{
-    int ret;                /* return code */
-    unsigned size;          /* requested fixed output block size */
-    unsigned have;          /* bytes written by deflate() call */
-    unsigned char *blk;     /* intermediate and final stream */
-    unsigned char *tmp;     /* close to desired size stream */
-    z_stream def, inf;      /* zlib deflate and inflate states */
-
-    /* get requested output size */
-    if (argc != 2)
-        quit("need one argument: size of output block");
-    ret = strtol(argv[1], argv + 1, 10);
-    if (argv[1][0] != 0)
-        quit("argument must be a number");
-    if (ret < 8)            /* 8 is minimum zlib stream size */
-        quit("need positive size of 8 or greater");
-    size = (unsigned)ret;
-
-    /* allocate memory for buffers and compression engine */
-    blk = malloc(size + EXCESS);
-    def.zalloc = Z_NULL;
-    def.zfree = Z_NULL;
-    def.opaque = Z_NULL;
-    ret = deflateInit(&def, Z_DEFAULT_COMPRESSION);
-    if (ret != Z_OK || blk == NULL)
-        quit("out of memory");
-
-    /* compress from stdin until output full, or no more input */
-    def.avail_out = size + EXCESS;
-    def.next_out = blk;
-    ret = partcompress(stdin, &def);
-    if (ret == Z_ERRNO)
-        quit("error reading input");
-
-    /* if it all fit, then size was undersubscribed -- done! */
-    if (ret == Z_STREAM_END && def.avail_out >= EXCESS) {
-        /* write block to stdout */
-        have = size + EXCESS - def.avail_out;
-        if (fwrite(blk, 1, have, stdout) != have || ferror(stdout))
-            quit("error writing output");
-
-        /* clean up and print results to stderr */
-        ret = deflateEnd(&def);
-        assert(ret != Z_STREAM_ERROR);
-        free(blk);
-        fprintf(stderr,
-                "%u bytes unused out of %u requested (all input)\n",
-                size - have, size);
-        return 0;
-    }
-
-    /* it didn't all fit -- set up for recompression */
-    inf.zalloc = Z_NULL;
-    inf.zfree = Z_NULL;
-    inf.opaque = Z_NULL;
-    inf.avail_in = 0;
-    inf.next_in = Z_NULL;
-    ret = inflateInit(&inf);
-    tmp = malloc(size + EXCESS);
-    if (ret != Z_OK || tmp == NULL)
-        quit("out of memory");
-    ret = deflateReset(&def);
-    assert(ret != Z_STREAM_ERROR);
-
-    /* do first recompression close to the right amount */
-    inf.avail_in = size + EXCESS;
-    inf.next_in = blk;
-    def.avail_out = size + EXCESS;
-    def.next_out = tmp;
-    ret = recompress(&inf, &def);
-    if (ret == Z_MEM_ERROR)
-        quit("out of memory");
-
-    /* set up for next reocmpression */
-    ret = inflateReset(&inf);
-    assert(ret != Z_STREAM_ERROR);
-    ret = deflateReset(&def);
-    assert(ret != Z_STREAM_ERROR);
-
-    /* do second and final recompression (third compression) */
-    inf.avail_in = size - MARGIN;   /* assure stream will complete */
-    inf.next_in = tmp;
-    def.avail_out = size;
-    def.next_out = blk;
-    ret = recompress(&inf, &def);
-    if (ret == Z_MEM_ERROR)
-        quit("out of memory");
-    assert(ret == Z_STREAM_END);    /* otherwise MARGIN too small */
-
-    /* done -- write block to stdout */
-    have = size - def.avail_out;
-    if (fwrite(blk, 1, have, stdout) != have || ferror(stdout))
-        quit("error writing output");
-
-    /* clean up and print results to stderr */
-    free(tmp);
-    ret = inflateEnd(&inf);
-    assert(ret != Z_STREAM_ERROR);
-    ret = deflateEnd(&def);
-    assert(ret != Z_STREAM_ERROR);
-    free(blk);
-    fprintf(stderr,
-            "%u bytes unused out of %u requested (%lu input)\n",
-            size - have, size, def.total_in);
-    return 0;
-}
diff -Nbaur gcc-4.6.3/zlib/examples/gun.c gcc-4.6.3-psp/zlib/examples/gun.c
--- gcc-4.6.3/zlib/examples/gun.c	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/examples/gun.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,693 +0,0 @@
-/* gun.c -- simple gunzip to give an example of the use of inflateBack()
- * Copyright (C) 2003, 2005 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
-   Version 1.3  12 June 2005  Mark Adler */
-
-/* Version history:
-   1.0  16 Feb 2003  First version for testing of inflateBack()
-   1.1  21 Feb 2005  Decompress concatenated gzip streams
-                     Remove use of "this" variable (C++ keyword)
-                     Fix return value for in()
-                     Improve allocation failure checking
-                     Add typecasting for void * structures
-                     Add -h option for command version and usage
-                     Add a bunch of comments
-   1.2  20 Mar 2005  Add Unix compress (LZW) decompression
-                     Copy file attributes from input file to output file
-   1.3  12 Jun 2005  Add casts for error messages [Oberhumer]
- */
-
-/*
-   gun [ -t ] [ name ... ]
-
-   decompresses the data in the named gzip files.  If no arguments are given,
-   gun will decompress from stdin to stdout.  The names must end in .gz, -gz,
-   .z, -z, _z, or .Z.  The uncompressed data will be written to a file name
-   with the suffix stripped.  On success, the original file is deleted.  On
-   failure, the output file is deleted.  For most failures, the command will
-   continue to process the remaining names on the command line.  A memory
-   allocation failure will abort the command.  If -t is specified, then the
-   listed files or stdin will be tested as gzip files for integrity (without
-   checking for a proper suffix), no output will be written, and no files
-   will be deleted.
-
-   Like gzip, gun allows concatenated gzip streams and will decompress them,
-   writing all of the uncompressed data to the output.  Unlike gzip, gun allows
-   an empty file on input, and will produce no error writing an empty output
-   file.
-
-   gun will also decompress files made by Unix compress, which uses LZW
-   compression.  These files are automatically detected by virtue of their
-   magic header bytes.  Since the end of Unix compress stream is marked by the
-   end-of-file, they cannot be concantenated.  If a Unix compress stream is
-   encountered in an input file, it is the last stream in that file.
-
-   Like gunzip and uncompress, the file attributes of the orignal compressed
-   file are maintained in the final uncompressed file, to the extent that the
-   user permissions allow it.
-
-   On my Mac OS X PowerPC G4, gun is almost twice as fast as gunzip (version
-   1.2.4) is on the same file, when gun is linked with zlib 1.2.2.  Also the
-   LZW decompression provided by gun is about twice as fast as the standard
-   Unix uncompress command.
- */
-
-/* external functions and related types and constants */
-#include <stdio.h>          /* fprintf() */
-#include <stdlib.h>         /* malloc(), free() */
-#include <string.h>         /* strerror(), strcmp(), strlen(), memcpy() */
-#include <errno.h>          /* errno */
-#include <fcntl.h>          /* open() */
-#include <unistd.h>         /* read(), write(), close(), chown(), unlink() */
-#include <sys/types.h>
-#include <sys/stat.h>       /* stat(), chmod() */
-#include <utime.h>          /* utime() */
-#include "zlib.h"           /* inflateBackInit(), inflateBack(), */
-                            /* inflateBackEnd(), crc32() */
-
-/* function declaration */
-#define local static
-
-/* buffer constants */
-#define SIZE 32768U         /* input and output buffer sizes */
-#define PIECE 16384         /* limits i/o chunks for 16-bit int case */
-
-/* structure for infback() to pass to input function in() -- it maintains the
-   input file and a buffer of size SIZE */
-struct ind {
-    int infile;
-    unsigned char *inbuf;
-};
-
-/* Load input buffer, assumed to be empty, and return bytes loaded and a
-   pointer to them.  read() is called until the buffer is full, or until it
-   returns end-of-file or error.  Return 0 on error. */
-local unsigned in(void *in_desc, unsigned char **buf)
-{
-    int ret;
-    unsigned len;
-    unsigned char *next;
-    struct ind *me = (struct ind *)in_desc;
-
-    next = me->inbuf;
-    *buf = next;
-    len = 0;
-    do {
-        ret = PIECE;
-        if ((unsigned)ret > SIZE - len)
-            ret = (int)(SIZE - len);
-        ret = (int)read(me->infile, next, ret);
-        if (ret == -1) {
-            len = 0;
-            break;
-        }
-        next += ret;
-        len += ret;
-    } while (ret != 0 && len < SIZE);
-    return len;
-}
-
-/* structure for infback() to pass to output function out() -- it maintains the
-   output file, a running CRC-32 check on the output and the total number of
-   bytes output, both for checking against the gzip trailer.  (The length in
-   the gzip trailer is stored modulo 2^32, so it's ok if a long is 32 bits and
-   the output is greater than 4 GB.) */
-struct outd {
-    int outfile;
-    int check;                  /* true if checking crc and total */
-    unsigned long crc;
-    unsigned long total;
-};
-
-/* Write output buffer and update the CRC-32 and total bytes written.  write()
-   is called until all of the output is written or an error is encountered.
-   On success out() returns 0.  For a write failure, out() returns 1.  If the
-   output file descriptor is -1, then nothing is written.
- */
-local int out(void *out_desc, unsigned char *buf, unsigned len)
-{
-    int ret;
-    struct outd *me = (struct outd *)out_desc;
-
-    if (me->check) {
-        me->crc = crc32(me->crc, buf, len);
-        me->total += len;
-    }
-    if (me->outfile != -1)
-        do {
-            ret = PIECE;
-            if ((unsigned)ret > len)
-                ret = (int)len;
-            ret = (int)write(me->outfile, buf, ret);
-            if (ret == -1)
-                return 1;
-            buf += ret;
-            len -= ret;
-        } while (len != 0);
-    return 0;
-}
-
-/* next input byte macro for use inside lunpipe() and gunpipe() */
-#define NEXT() (have ? 0 : (have = in(indp, &next)), \
-                last = have ? (have--, (int)(*next++)) : -1)
-
-/* memory for gunpipe() and lunpipe() --
-   the first 256 entries of prefix[] and suffix[] are never used, could
-   have offset the index, but it's faster to waste the memory */
-unsigned char inbuf[SIZE];              /* input buffer */
-unsigned char outbuf[SIZE];             /* output buffer */
-unsigned short prefix[65536];           /* index to LZW prefix string */
-unsigned char suffix[65536];            /* one-character LZW suffix */
-unsigned char match[65280 + 2];         /* buffer for reversed match or gzip
-                                           32K sliding window */
-
-/* throw out what's left in the current bits byte buffer (this is a vestigial
-   aspect of the compressed data format derived from an implementation that
-   made use of a special VAX machine instruction!) */
-#define FLUSHCODE() \
-    do { \
-        left = 0; \
-        rem = 0; \
-        if (chunk > have) { \
-            chunk -= have; \
-            have = 0; \
-            if (NEXT() == -1) \
-                break; \
-            chunk--; \
-            if (chunk > have) { \
-                chunk = have = 0; \
-                break; \
-            } \
-        } \
-        have -= chunk; \
-        next += chunk; \
-        chunk = 0; \
-    } while (0)
-
-/* Decompress a compress (LZW) file from indp to outfile.  The compress magic
-   header (two bytes) has already been read and verified.  There are have bytes
-   of buffered input at next.  strm is used for passing error information back
-   to gunpipe().
-
-   lunpipe() will return Z_OK on success, Z_BUF_ERROR for an unexpected end of
-   file, read error, or write error (a write error indicated by strm->next_in
-   not equal to Z_NULL), or Z_DATA_ERROR for invalid input.
- */
-local int lunpipe(unsigned have, unsigned char *next, struct ind *indp,
-                  int outfile, z_stream *strm)
-{
-    int last;                   /* last byte read by NEXT(), or -1 if EOF */
-    int chunk;                  /* bytes left in current chunk */
-    int left;                   /* bits left in rem */
-    unsigned rem;               /* unused bits from input */
-    int bits;                   /* current bits per code */
-    unsigned code;              /* code, table traversal index */
-    unsigned mask;              /* mask for current bits codes */
-    int max;                    /* maximum bits per code for this stream */
-    int flags;                  /* compress flags, then block compress flag */
-    unsigned end;               /* last valid entry in prefix/suffix tables */
-    unsigned temp;              /* current code */
-    unsigned prev;              /* previous code */
-    unsigned final;             /* last character written for previous code */
-    unsigned stack;             /* next position for reversed string */
-    unsigned outcnt;            /* bytes in output buffer */
-    struct outd outd;           /* output structure */
-
-    /* set up output */
-    outd.outfile = outfile;
-    outd.check = 0;
-
-    /* process remainder of compress header -- a flags byte */
-    flags = NEXT();
-    if (last == -1)
-        return Z_BUF_ERROR;
-    if (flags & 0x60) {
-        strm->msg = (char *)"unknown lzw flags set";
-        return Z_DATA_ERROR;
-    }
-    max = flags & 0x1f;
-    if (max < 9 || max > 16) {
-        strm->msg = (char *)"lzw bits out of range";
-        return Z_DATA_ERROR;
-    }
-    if (max == 9)                           /* 9 doesn't really mean 9 */
-        max = 10;
-    flags &= 0x80;                          /* true if block compress */
-
-    /* clear table */
-    bits = 9;
-    mask = 0x1ff;
-    end = flags ? 256 : 255;
-
-    /* set up: get first 9-bit code, which is the first decompressed byte, but
-       don't create a table entry until the next code */
-    if (NEXT() == -1)                       /* no compressed data is ok */
-        return Z_OK;
-    final = prev = (unsigned)last;          /* low 8 bits of code */
-    if (NEXT() == -1)                       /* missing a bit */
-        return Z_BUF_ERROR;
-    if (last & 1) {                         /* code must be < 256 */
-        strm->msg = (char *)"invalid lzw code";
-        return Z_DATA_ERROR;
-    }
-    rem = (unsigned)last >> 1;              /* remaining 7 bits */
-    left = 7;
-    chunk = bits - 2;                       /* 7 bytes left in this chunk */
-    outbuf[0] = (unsigned char)final;       /* write first decompressed byte */
-    outcnt = 1;
-
-    /* decode codes */
-    stack = 0;
-    for (;;) {
-        /* if the table will be full after this, increment the code size */
-        if (end >= mask && bits < max) {
-            FLUSHCODE();
-            bits++;
-            mask <<= 1;
-            mask++;
-        }
-
-        /* get a code of length bits */
-        if (chunk == 0)                     /* decrement chunk modulo bits */
-            chunk = bits;
-        code = rem;                         /* low bits of code */
-        if (NEXT() == -1) {                 /* EOF is end of compressed data */
-            /* write remaining buffered output */
-            if (outcnt && out(&outd, outbuf, outcnt)) {
-                strm->next_in = outbuf;     /* signal write error */
-                return Z_BUF_ERROR;
-            }
-            return Z_OK;
-        }
-        code += (unsigned)last << left;     /* middle (or high) bits of code */
-        left += 8;
-        chunk--;
-        if (bits > left) {                  /* need more bits */
-            if (NEXT() == -1)               /* can't end in middle of code */
-                return Z_BUF_ERROR;
-            code += (unsigned)last << left; /* high bits of code */
-            left += 8;
-            chunk--;
-        }
-        code &= mask;                       /* mask to current code length */
-        left -= bits;                       /* number of unused bits */
-        rem = (unsigned)last >> (8 - left); /* unused bits from last byte */
-
-        /* process clear code (256) */
-        if (code == 256 && flags) {
-            FLUSHCODE();
-            bits = 9;                       /* initialize bits and mask */
-            mask = 0x1ff;
-            end = 255;                      /* empty table */
-            continue;                       /* get next code */
-        }
-
-        /* special code to reuse last match */
-        temp = code;                        /* save the current code */
-        if (code > end) {
-            /* Be picky on the allowed code here, and make sure that the code
-               we drop through (prev) will be a valid index so that random
-               input does not cause an exception.  The code != end + 1 check is
-               empirically derived, and not checked in the original uncompress
-               code.  If this ever causes a problem, that check could be safely
-               removed.  Leaving this check in greatly improves gun's ability
-               to detect random or corrupted input after a compress header.
-               In any case, the prev > end check must be retained. */
-            if (code != end + 1 || prev > end) {
-                strm->msg = (char *)"invalid lzw code";
-                return Z_DATA_ERROR;
-            }
-            match[stack++] = (unsigned char)final;
-            code = prev;
-        }
-
-        /* walk through linked list to generate output in reverse order */
-        while (code >= 256) {
-            match[stack++] = suffix[code];
-            code = prefix[code];
-        }
-        match[stack++] = (unsigned char)code;
-        final = code;
-
-        /* link new table entry */
-        if (end < mask) {
-            end++;
-            prefix[end] = (unsigned short)prev;
-            suffix[end] = (unsigned char)final;
-        }
-
-        /* set previous code for next iteration */
-        prev = temp;
-
-        /* write output in forward order */
-        while (stack > SIZE - outcnt) {
-            while (outcnt < SIZE)
-                outbuf[outcnt++] = match[--stack];
-            if (out(&outd, outbuf, outcnt)) {
-                strm->next_in = outbuf; /* signal write error */
-                return Z_BUF_ERROR;
-            }
-            outcnt = 0;
-        }
-        do {
-            outbuf[outcnt++] = match[--stack];
-        } while (stack);
-
-        /* loop for next code with final and prev as the last match, rem and
-           left provide the first 0..7 bits of the next code, end is the last
-           valid table entry */
-    }
-}
-
-/* Decompress a gzip file from infile to outfile.  strm is assumed to have been
-   successfully initialized with inflateBackInit().  The input file may consist
-   of a series of gzip streams, in which case all of them will be decompressed
-   to the output file.  If outfile is -1, then the gzip stream(s) integrity is
-   checked and nothing is written.
-
-   The return value is a zlib error code: Z_MEM_ERROR if out of memory,
-   Z_DATA_ERROR if the header or the compressed data is invalid, or if the
-   trailer CRC-32 check or length doesn't match, Z_BUF_ERROR if the input ends
-   prematurely or a write error occurs, or Z_ERRNO if junk (not a another gzip
-   stream) follows a valid gzip stream.
- */
-local int gunpipe(z_stream *strm, int infile, int outfile)
-{
-    int ret, first, last;
-    unsigned have, flags, len;
-    unsigned char *next;
-    struct ind ind, *indp;
-    struct outd outd;
-
-    /* setup input buffer */
-    ind.infile = infile;
-    ind.inbuf = inbuf;
-    indp = &ind;
-
-    /* decompress concatenated gzip streams */
-    have = 0;                               /* no input data read in yet */
-    first = 1;                              /* looking for first gzip header */
-    strm->next_in = Z_NULL;                 /* so Z_BUF_ERROR means EOF */
-    for (;;) {
-        /* look for the two magic header bytes for a gzip stream */
-        if (NEXT() == -1) {
-            ret = Z_OK;
-            break;                          /* empty gzip stream is ok */
-        }
-        if (last != 31 || (NEXT() != 139 && last != 157)) {
-            strm->msg = (char *)"incorrect header check";
-            ret = first ? Z_DATA_ERROR : Z_ERRNO;
-            break;                          /* not a gzip or compress header */
-        }
-        first = 0;                          /* next non-header is junk */
-
-        /* process a compress (LZW) file -- can't be concatenated after this */
-        if (last == 157) {
-            ret = lunpipe(have, next, indp, outfile, strm);
-            break;
-        }
-
-        /* process remainder of gzip header */
-        ret = Z_BUF_ERROR;
-        if (NEXT() != 8) {                  /* only deflate method allowed */
-            if (last == -1) break;
-            strm->msg = (char *)"unknown compression method";
-            ret = Z_DATA_ERROR;
-            break;
-        }
-        flags = NEXT();                     /* header flags */
-        NEXT();                             /* discard mod time, xflgs, os */
-        NEXT();
-        NEXT();
-        NEXT();
-        NEXT();
-        NEXT();
-        if (last == -1) break;
-        if (flags & 0xe0) {
-            strm->msg = (char *)"unknown header flags set";
-            ret = Z_DATA_ERROR;
-            break;
-        }
-        if (flags & 4) {                    /* extra field */
-            len = NEXT();
-            len += (unsigned)(NEXT()) << 8;
-            if (last == -1) break;
-            while (len > have) {
-                len -= have;
-                have = 0;
-                if (NEXT() == -1) break;
-                len--;
-            }
-            if (last == -1) break;
-            have -= len;
-            next += len;
-        }
-        if (flags & 8)                      /* file name */
-            while (NEXT() != 0 && last != -1)
-                ;
-        if (flags & 16)                     /* comment */
-            while (NEXT() != 0 && last != -1)
-                ;
-        if (flags & 2) {                    /* header crc */
-            NEXT();
-            NEXT();
-        }
-        if (last == -1) break;
-
-        /* set up output */
-        outd.outfile = outfile;
-        outd.check = 1;
-        outd.crc = crc32(0L, Z_NULL, 0);
-        outd.total = 0;
-
-        /* decompress data to output */
-        strm->next_in = next;
-        strm->avail_in = have;
-        ret = inflateBack(strm, in, indp, out, &outd);
-        if (ret != Z_STREAM_END) break;
-        next = strm->next_in;
-        have = strm->avail_in;
-        strm->next_in = Z_NULL;             /* so Z_BUF_ERROR means EOF */
-
-        /* check trailer */
-        ret = Z_BUF_ERROR;
-        if (NEXT() != (outd.crc & 0xff) ||
-            NEXT() != ((outd.crc >> 8) & 0xff) ||
-            NEXT() != ((outd.crc >> 16) & 0xff) ||
-            NEXT() != ((outd.crc >> 24) & 0xff)) {
-            /* crc error */
-            if (last != -1) {
-                strm->msg = (char *)"incorrect data check";
-                ret = Z_DATA_ERROR;
-            }
-            break;
-        }
-        if (NEXT() != (outd.total & 0xff) ||
-            NEXT() != ((outd.total >> 8) & 0xff) ||
-            NEXT() != ((outd.total >> 16) & 0xff) ||
-            NEXT() != ((outd.total >> 24) & 0xff)) {
-            /* length error */
-            if (last != -1) {
-                strm->msg = (char *)"incorrect length check";
-                ret = Z_DATA_ERROR;
-            }
-            break;
-        }
-
-        /* go back and look for another gzip stream */
-    }
-
-    /* clean up and return */
-    return ret;
-}
-
-/* Copy file attributes, from -> to, as best we can.  This is best effort, so
-   no errors are reported.  The mode bits, including suid, sgid, and the sticky
-   bit are copied (if allowed), the owner's user id and group id are copied
-   (again if allowed), and the access and modify times are copied. */
-local void copymeta(char *from, char *to)
-{
-    struct stat was;
-    struct utimbuf when;
-
-    /* get all of from's Unix meta data, return if not a regular file */
-    if (stat(from, &was) != 0 || (was.st_mode & S_IFMT) != S_IFREG)
-        return;
-
-    /* set to's mode bits, ignore errors */
-    (void)chmod(to, was.st_mode & 07777);
-
-    /* copy owner's user and group, ignore errors */
-    (void)chown(to, was.st_uid, was.st_gid);
-
-    /* copy access and modify times, ignore errors */
-    when.actime = was.st_atime;
-    when.modtime = was.st_mtime;
-    (void)utime(to, &when);
-}
-
-/* Decompress the file inname to the file outnname, of if test is true, just
-   decompress without writing and check the gzip trailer for integrity.  If
-   inname is NULL or an empty string, read from stdin.  If outname is NULL or
-   an empty string, write to stdout.  strm is a pre-initialized inflateBack
-   structure.  When appropriate, copy the file attributes from inname to
-   outname.
-
-   gunzip() returns 1 if there is an out-of-memory error or an unexpected
-   return code from gunpipe().  Otherwise it returns 0.
- */
-local int gunzip(z_stream *strm, char *inname, char *outname, int test)
-{
-    int ret;
-    int infile, outfile;
-
-    /* open files */
-    if (inname == NULL || *inname == 0) {
-        inname = "-";
-        infile = 0;     /* stdin */
-    }
-    else {
-        infile = open(inname, O_RDONLY, 0);
-        if (infile == -1) {
-            fprintf(stderr, "gun cannot open %s\n", inname);
-            return 0;
-        }
-    }
-    if (test)
-        outfile = -1;
-    else if (outname == NULL || *outname == 0) {
-        outname = "-";
-        outfile = 1;    /* stdout */
-    }
-    else {
-        outfile = open(outname, O_CREAT | O_TRUNC | O_WRONLY, 0666);
-        if (outfile == -1) {
-            close(infile);
-            fprintf(stderr, "gun cannot create %s\n", outname);
-            return 0;
-        }
-    }
-    errno = 0;
-
-    /* decompress */
-    ret = gunpipe(strm, infile, outfile);
-    if (outfile > 2) close(outfile);
-    if (infile > 2) close(infile);
-
-    /* interpret result */
-    switch (ret) {
-    case Z_OK:
-    case Z_ERRNO:
-        if (infile > 2 && outfile > 2) {
-            copymeta(inname, outname);          /* copy attributes */
-            unlink(inname);
-        }
-        if (ret == Z_ERRNO)
-            fprintf(stderr, "gun warning: trailing garbage ignored in %s\n",
-                    inname);
-        break;
-    case Z_DATA_ERROR:
-        if (outfile > 2) unlink(outname);
-        fprintf(stderr, "gun data error on %s: %s\n", inname, strm->msg);
-        break;
-    case Z_MEM_ERROR:
-        if (outfile > 2) unlink(outname);
-        fprintf(stderr, "gun out of memory error--aborting\n");
-        return 1;
-    case Z_BUF_ERROR:
-        if (outfile > 2) unlink(outname);
-        if (strm->next_in != Z_NULL) {
-            fprintf(stderr, "gun write error on %s: %s\n",
-                    outname, strerror(errno));
-        }
-        else if (errno) {
-            fprintf(stderr, "gun read error on %s: %s\n",
-                    inname, strerror(errno));
-        }
-        else {
-            fprintf(stderr, "gun unexpected end of file on %s\n",
-                    inname);
-        }
-        break;
-    default:
-        if (outfile > 2) unlink(outname);
-        fprintf(stderr, "gun internal error--aborting\n");
-        return 1;
-    }
-    return 0;
-}
-
-/* Process the gun command line arguments.  See the command syntax near the
-   beginning of this source file. */
-int main(int argc, char **argv)
-{
-    int ret, len, test;
-    char *outname;
-    unsigned char *window;
-    z_stream strm;
-
-    /* initialize inflateBack state for repeated use */
-    window = match;                         /* reuse LZW match buffer */
-    strm.zalloc = Z_NULL;
-    strm.zfree = Z_NULL;
-    strm.opaque = Z_NULL;
-    ret = inflateBackInit(&strm, 15, window);
-    if (ret != Z_OK) {
-        fprintf(stderr, "gun out of memory error--aborting\n");
-        return 1;
-    }
-
-    /* decompress each file to the same name with the suffix removed */
-    argc--;
-    argv++;
-    test = 0;
-    if (argc && strcmp(*argv, "-h") == 0) {
-        fprintf(stderr, "gun 1.3 (12 Jun 2005)\n");
-        fprintf(stderr, "Copyright (c) 2005 Mark Adler\n");
-        fprintf(stderr, "usage: gun [-t] [file1.gz [file2.Z ...]]\n");
-        return 0;
-    }
-    if (argc && strcmp(*argv, "-t") == 0) {
-        test = 1;
-        argc--;
-        argv++;
-    }
-    if (argc)
-        do {
-            if (test)
-                outname = NULL;
-            else {
-                len = (int)strlen(*argv);
-                if (strcmp(*argv + len - 3, ".gz") == 0 ||
-                    strcmp(*argv + len - 3, "-gz") == 0)
-                    len -= 3;
-                else if (strcmp(*argv + len - 2, ".z") == 0 ||
-                    strcmp(*argv + len - 2, "-z") == 0 ||
-                    strcmp(*argv + len - 2, "_z") == 0 ||
-                    strcmp(*argv + len - 2, ".Z") == 0)
-                    len -= 2;
-                else {
-                    fprintf(stderr, "gun error: no gz type on %s--skipping\n",
-                            *argv);
-                    continue;
-                }
-                outname = malloc(len + 1);
-                if (outname == NULL) {
-                    fprintf(stderr, "gun out of memory error--aborting\n");
-                    ret = 1;
-                    break;
-                }
-                memcpy(outname, *argv, len);
-                outname[len] = 0;
-            }
-            ret = gunzip(&strm, *argv, outname, test);
-            if (outname != NULL) free(outname);
-            if (ret) break;
-        } while (argv++, --argc);
-    else
-        ret = gunzip(&strm, NULL, NULL, test);
-
-    /* clean up */
-    inflateBackEnd(&strm);
-    return ret;
-}
diff -Nbaur gcc-4.6.3/zlib/examples/gzappend.c gcc-4.6.3-psp/zlib/examples/gzappend.c
--- gcc-4.6.3/zlib/examples/gzappend.c	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/examples/gzappend.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,500 +0,0 @@
-/* gzappend -- command to append to a gzip file
-
-  Copyright (C) 2003 Mark Adler, all rights reserved
-  version 1.1, 4 Nov 2003
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Mark Adler    madler@alumni.caltech.edu
- */
-
-/*
- * Change history:
- *
- * 1.0  19 Oct 2003     - First version
- * 1.1   4 Nov 2003     - Expand and clarify some comments and notes
- *                      - Add version and copyright to help
- *                      - Send help to stdout instead of stderr
- *                      - Add some preemptive typecasts
- *                      - Add L to constants in lseek() calls
- *                      - Remove some debugging information in error messages
- *                      - Use new data_type definition for zlib 1.2.1
- *                      - Simplfy and unify file operations
- *                      - Finish off gzip file in gztack()
- *                      - Use deflatePrime() instead of adding empty blocks
- *                      - Keep gzip file clean on appended file read errors
- *                      - Use in-place rotate instead of auxiliary buffer
- *                        (Why you ask?  Because it was fun to write!)
- */
-
-/*
-   gzappend takes a gzip file and appends to it, compressing files from the
-   command line or data from stdin.  The gzip file is written to directly, to
-   avoid copying that file, in case it's large.  Note that this results in the
-   unfriendly behavior that if gzappend fails, the gzip file is corrupted.
-
-   This program was written to illustrate the use of the new Z_BLOCK option of
-   zlib 1.2.x's inflate() function.  This option returns from inflate() at each
-   block boundary to facilitate locating and modifying the last block bit at
-   the start of the final deflate block.  Also whether using Z_BLOCK or not,
-   another required feature of zlib 1.2.x is that inflate() now provides the
-   number of unusued bits in the last input byte used.  gzappend will not work
-   with versions of zlib earlier than 1.2.1.
-
-   gzappend first decompresses the gzip file internally, discarding all but
-   the last 32K of uncompressed data, and noting the location of the last block
-   bit and the number of unused bits in the last byte of the compressed data.
-   The gzip trailer containing the CRC-32 and length of the uncompressed data
-   is verified.  This trailer will be later overwritten.
-
-   Then the last block bit is cleared by seeking back in the file and rewriting
-   the byte that contains it.  Seeking forward, the last byte of the compressed
-   data is saved along with the number of unused bits to initialize deflate.
-
-   A deflate process is initialized, using the last 32K of the uncompressed
-   data from the gzip file to initialize the dictionary.  If the total
-   uncompressed data was less than 32K, then all of it is used to initialize
-   the dictionary.  The deflate output bit buffer is also initialized with the
-   last bits from the original deflate stream.  From here on, the data to
-   append is simply compressed using deflate, and written to the gzip file.
-   When that is complete, the new CRC-32 and uncompressed length are written
-   as the trailer of the gzip file.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include "zlib.h"
-
-#define local static
-#define LGCHUNK 14
-#define CHUNK (1U << LGCHUNK)
-#define DSIZE 32768U
-
-/* print an error message and terminate with extreme prejudice */
-local void bye(char *msg1, char *msg2)
-{
-    fprintf(stderr, "gzappend error: %s%s\n", msg1, msg2);
-    exit(1);
-}
-
-/* return the greatest common divisor of a and b using Euclid's algorithm,
-   modified to be fast when one argument much greater than the other, and
-   coded to avoid unnecessary swapping */
-local unsigned gcd(unsigned a, unsigned b)
-{
-    unsigned c;
-
-    while (a && b)
-        if (a > b) {
-            c = b;
-            while (a - c >= c)
-                c <<= 1;
-            a -= c;
-        }
-        else {
-            c = a;
-            while (b - c >= c)
-                c <<= 1;
-            b -= c;
-        }
-    return a + b;
-}
-
-/* rotate list[0..len-1] left by rot positions, in place */
-local void rotate(unsigned char *list, unsigned len, unsigned rot)
-{
-    unsigned char tmp;
-    unsigned cycles;
-    unsigned char *start, *last, *to, *from;
-
-    /* normalize rot and handle degenerate cases */
-    if (len < 2) return;
-    if (rot >= len) rot %= len;
-    if (rot == 0) return;
-
-    /* pointer to last entry in list */
-    last = list + (len - 1);
-
-    /* do simple left shift by one */
-    if (rot == 1) {
-        tmp = *list;
-        memcpy(list, list + 1, len - 1);
-        *last = tmp;
-        return;
-    }
-
-    /* do simple right shift by one */
-    if (rot == len - 1) {
-        tmp = *last;
-        memmove(list + 1, list, len - 1);
-        *list = tmp;
-        return;
-    }
-
-    /* otherwise do rotate as a set of cycles in place */
-    cycles = gcd(len, rot);             /* number of cycles */
-    do {
-        start = from = list + cycles;   /* start index is arbitrary */
-        tmp = *from;                    /* save entry to be overwritten */
-        for (;;) {
-            to = from;                  /* next step in cycle */
-            from += rot;                /* go right rot positions */
-            if (from > last) from -= len;   /* (pointer better not wrap) */
-            if (from == start) break;   /* all but one shifted */
-            *to = *from;                /* shift left */
-        }
-        *to = tmp;                      /* complete the circle */
-    } while (--cycles);
-}
-
-/* structure for gzip file read operations */
-typedef struct {
-    int fd;                     /* file descriptor */
-    int size;                   /* 1 << size is bytes in buf */
-    unsigned left;              /* bytes available at next */
-    unsigned char *buf;         /* buffer */
-    unsigned char *next;        /* next byte in buffer */
-    char *name;                 /* file name for error messages */
-} file;
-
-/* reload buffer */
-local int readin(file *in)
-{
-    int len;
-
-    len = read(in->fd, in->buf, 1 << in->size);
-    if (len == -1) bye("error reading ", in->name);
-    in->left = (unsigned)len;
-    in->next = in->buf;
-    return len;
-}
-
-/* read from file in, exit if end-of-file */
-local int readmore(file *in)
-{
-    if (readin(in) == 0) bye("unexpected end of ", in->name);
-    return 0;
-}
-
-#define read1(in) (in->left == 0 ? readmore(in) : 0, \
-                   in->left--, *(in->next)++)
-
-/* skip over n bytes of in */
-local void skip(file *in, unsigned n)
-{
-    unsigned bypass;
-
-    if (n > in->left) {
-        n -= in->left;
-        bypass = n & ~((1U << in->size) - 1);
-        if (bypass) {
-            if (lseek(in->fd, (off_t)bypass, SEEK_CUR) == -1)
-                bye("seeking ", in->name);
-            n -= bypass;
-        }
-        readmore(in);
-        if (n > in->left)
-            bye("unexpected end of ", in->name);
-    }
-    in->left -= n;
-    in->next += n;
-}
-
-/* read a four-byte unsigned integer, little-endian, from in */
-unsigned long read4(file *in)
-{
-    unsigned long val;
-
-    val = read1(in);
-    val += (unsigned)read1(in) << 8;
-    val += (unsigned long)read1(in) << 16;
-    val += (unsigned long)read1(in) << 24;
-    return val;
-}
-
-/* skip over gzip header */
-local void gzheader(file *in)
-{
-    int flags;
-    unsigned n;
-
-    if (read1(in) != 31 || read1(in) != 139) bye(in->name, " not a gzip file");
-    if (read1(in) != 8) bye("unknown compression method in", in->name);
-    flags = read1(in);
-    if (flags & 0xe0) bye("unknown header flags set in", in->name);
-    skip(in, 6);
-    if (flags & 4) {
-        n = read1(in);
-        n += (unsigned)(read1(in)) << 8;
-        skip(in, n);
-    }
-    if (flags & 8) while (read1(in) != 0) ;
-    if (flags & 16) while (read1(in) != 0) ;
-    if (flags & 2) skip(in, 2);
-}
-
-/* decompress gzip file "name", return strm with a deflate stream ready to
-   continue compression of the data in the gzip file, and return a file
-   descriptor pointing to where to write the compressed data -- the deflate
-   stream is initialized to compress using level "level" */
-local int gzscan(char *name, z_stream *strm, int level)
-{
-    int ret, lastbit, left, full;
-    unsigned have;
-    unsigned long crc, tot;
-    unsigned char *window;
-    off_t lastoff, end;
-    file gz;
-
-    /* open gzip file */
-    gz.name = name;
-    gz.fd = open(name, O_RDWR, 0);
-    if (gz.fd == -1) bye("cannot open ", name);
-    gz.buf = malloc(CHUNK);
-    if (gz.buf == NULL) bye("out of memory", "");
-    gz.size = LGCHUNK;
-    gz.left = 0;
-
-    /* skip gzip header */
-    gzheader(&gz);
-
-    /* prepare to decompress */
-    window = malloc(DSIZE);
-    if (window == NULL) bye("out of memory", "");
-    strm->zalloc = Z_NULL;
-    strm->zfree = Z_NULL;
-    strm->opaque = Z_NULL;
-    ret = inflateInit2(strm, -15);
-    if (ret != Z_OK) bye("out of memory", " or library mismatch");
-
-    /* decompress the deflate stream, saving append information */
-    lastbit = 0;
-    lastoff = lseek(gz.fd, 0L, SEEK_CUR) - gz.left;
-    left = 0;
-    strm->avail_in = gz.left;
-    strm->next_in = gz.next;
-    crc = crc32(0L, Z_NULL, 0);
-    have = full = 0;
-    do {
-        /* if needed, get more input */
-        if (strm->avail_in == 0) {
-            readmore(&gz);
-            strm->avail_in = gz.left;
-            strm->next_in = gz.next;
-        }
-
-        /* set up output to next available section of sliding window */
-        strm->avail_out = DSIZE - have;
-        strm->next_out = window + have;
-
-        /* inflate and check for errors */
-        ret = inflate(strm, Z_BLOCK);
-        if (ret == Z_STREAM_ERROR) bye("internal stream error!", "");
-        if (ret == Z_MEM_ERROR) bye("out of memory", "");
-        if (ret == Z_DATA_ERROR)
-            bye("invalid compressed data--format violated in", name);
-
-        /* update crc and sliding window pointer */
-        crc = crc32(crc, window + have, DSIZE - have - strm->avail_out);
-        if (strm->avail_out)
-            have = DSIZE - strm->avail_out;
-        else {
-            have = 0;
-            full = 1;
-        }
-
-        /* process end of block */
-        if (strm->data_type & 128) {
-            if (strm->data_type & 64)
-                left = strm->data_type & 0x1f;
-            else {
-                lastbit = strm->data_type & 0x1f;
-                lastoff = lseek(gz.fd, 0L, SEEK_CUR) - strm->avail_in;
-            }
-        }
-    } while (ret != Z_STREAM_END);
-    inflateEnd(strm);
-    gz.left = strm->avail_in;
-    gz.next = strm->next_in;
-
-    /* save the location of the end of the compressed data */
-    end = lseek(gz.fd, 0L, SEEK_CUR) - gz.left;
-
-    /* check gzip trailer and save total for deflate */
-    if (crc != read4(&gz))
-        bye("invalid compressed data--crc mismatch in ", name);
-    tot = strm->total_out;
-    if ((tot & 0xffffffffUL) != read4(&gz))
-        bye("invalid compressed data--length mismatch in", name);
-
-    /* if not at end of file, warn */
-    if (gz.left || readin(&gz))
-        fprintf(stderr,
-            "gzappend warning: junk at end of gzip file overwritten\n");
-
-    /* clear last block bit */
-    lseek(gz.fd, lastoff - (lastbit != 0), SEEK_SET);
-    if (read(gz.fd, gz.buf, 1) != 1) bye("reading after seek on ", name);
-    *gz.buf = (unsigned char)(*gz.buf ^ (1 << ((8 - lastbit) & 7)));
-    lseek(gz.fd, -1L, SEEK_CUR);
-    if (write(gz.fd, gz.buf, 1) != 1) bye("writing after seek to ", name);
-
-    /* if window wrapped, build dictionary from window by rotating */
-    if (full) {
-        rotate(window, DSIZE, have);
-        have = DSIZE;
-    }
-
-    /* set up deflate stream with window, crc, total_in, and leftover bits */
-    ret = deflateInit2(strm, level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY);
-    if (ret != Z_OK) bye("out of memory", "");
-    deflateSetDictionary(strm, window, have);
-    strm->adler = crc;
-    strm->total_in = tot;
-    if (left) {
-        lseek(gz.fd, --end, SEEK_SET);
-        if (read(gz.fd, gz.buf, 1) != 1) bye("reading after seek on ", name);
-        deflatePrime(strm, 8 - left, *gz.buf);
-    }
-    lseek(gz.fd, end, SEEK_SET);
-
-    /* clean up and return */
-    free(window);
-    free(gz.buf);
-    return gz.fd;
-}
-
-/* append file "name" to gzip file gd using deflate stream strm -- if last
-   is true, then finish off the deflate stream at the end */
-local void gztack(char *name, int gd, z_stream *strm, int last)
-{
-    int fd, len, ret;
-    unsigned left;
-    unsigned char *in, *out;
-
-    /* open file to compress and append */
-    fd = 0;
-    if (name != NULL) {
-        fd = open(name, O_RDONLY, 0);
-        if (fd == -1)
-            fprintf(stderr, "gzappend warning: %s not found, skipping ...\n",
-                    name);
-    }
-
-    /* allocate buffers */
-    in = fd == -1 ? NULL : malloc(CHUNK);
-    out = malloc(CHUNK);
-    if (out == NULL) bye("out of memory", "");
-
-    /* compress input file and append to gzip file */
-    do {
-        /* get more input */
-        len = fd == -1 ? 0 : read(fd, in, CHUNK);
-        if (len == -1) {
-            fprintf(stderr,
-                    "gzappend warning: error reading %s, skipping rest ...\n",
-                    name);
-            len = 0;
-        }
-        strm->avail_in = (unsigned)len;
-        strm->next_in = in;
-        if (len) strm->adler = crc32(strm->adler, in, (unsigned)len);
-
-        /* compress and write all available output */
-        do {
-            strm->avail_out = CHUNK;
-            strm->next_out = out;
-            ret = deflate(strm, last && len == 0 ? Z_FINISH : Z_NO_FLUSH);
-            left = CHUNK - strm->avail_out;
-            while (left) {
-                len = write(gd, out + CHUNK - strm->avail_out - left, left);
-                if (len == -1) bye("writing gzip file", "");
-                left -= (unsigned)len;
-            }
-        } while (strm->avail_out == 0 && ret != Z_STREAM_END);
-    } while (len != 0);
-
-    /* write trailer after last entry */
-    if (last) {
-        deflateEnd(strm);
-        out[0] = (unsigned char)(strm->adler);
-        out[1] = (unsigned char)(strm->adler >> 8);
-        out[2] = (unsigned char)(strm->adler >> 16);
-        out[3] = (unsigned char)(strm->adler >> 24);
-        out[4] = (unsigned char)(strm->total_in);
-        out[5] = (unsigned char)(strm->total_in >> 8);
-        out[6] = (unsigned char)(strm->total_in >> 16);
-        out[7] = (unsigned char)(strm->total_in >> 24);
-        len = 8;
-        do {
-            ret = write(gd, out + 8 - len, len);
-            if (ret == -1) bye("writing gzip file", "");
-            len -= ret;
-        } while (len);
-        close(gd);
-    }
-
-    /* clean up and return */
-    free(out);
-    if (in != NULL) free(in);
-    if (fd > 0) close(fd);
-}
-
-/* process the compression level option if present, scan the gzip file, and
-   append the specified files, or append the data from stdin if no other file
-   names are provided on the command line -- the gzip file must be writable
-   and seekable */
-int main(int argc, char **argv)
-{
-    int gd, level;
-    z_stream strm;
-
-    /* ignore command name */
-    argv++;
-
-    /* provide usage if no arguments */
-    if (*argv == NULL) {
-        printf("gzappend 1.1 (4 Nov 2003) Copyright (C) 2003 Mark Adler\n");
-        printf(
-            "usage: gzappend [-level] file.gz [ addthis [ andthis ... ]]\n");
-        return 0;
-    }
-
-    /* set compression level */
-    level = Z_DEFAULT_COMPRESSION;
-    if (argv[0][0] == '-') {
-        if (argv[0][1] < '0' || argv[0][1] > '9' || argv[0][2] != 0)
-            bye("invalid compression level", "");
-        level = argv[0][1] - '0';
-        if (*++argv == NULL) bye("no gzip file name after options", "");
-    }
-
-    /* prepare to append to gzip file */
-    gd = gzscan(*argv++, &strm, level);
-
-    /* append files on command line, or from stdin if none */
-    if (*argv == NULL)
-        gztack(NULL, gd, &strm, 1);
-    else
-        do {
-            gztack(*argv, gd, &strm, argv[1] == NULL);
-        } while (*++argv != NULL);
-    return 0;
-}
diff -Nbaur gcc-4.6.3/zlib/examples/gzjoin.c gcc-4.6.3-psp/zlib/examples/gzjoin.c
--- gcc-4.6.3/zlib/examples/gzjoin.c	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/examples/gzjoin.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,448 +0,0 @@
-/* gzjoin -- command to join gzip files into one gzip file
-
-  Copyright (C) 2004 Mark Adler, all rights reserved
-  version 1.0, 11 Dec 2004
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Mark Adler    madler@alumni.caltech.edu
- */
-
-/*
- * Change history:
- *
- * 1.0  11 Dec 2004     - First version
- * 1.1  12 Jun 2005     - Changed ssize_t to long for portability
- */
-
-/*
-   gzjoin takes one or more gzip files on the command line and writes out a
-   single gzip file that will uncompress to the concatenation of the
-   uncompressed data from the individual gzip files.  gzjoin does this without
-   having to recompress any of the data and without having to calculate a new
-   crc32 for the concatenated uncompressed data.  gzjoin does however have to
-   decompress all of the input data in order to find the bits in the compressed
-   data that need to be modified to concatenate the streams.
-
-   gzjoin does not do an integrity check on the input gzip files other than
-   checking the gzip header and decompressing the compressed data.  They are
-   otherwise assumed to be complete and correct.
-
-   Each joint between gzip files removes at least 18 bytes of previous trailer
-   and subsequent header, and inserts an average of about three bytes to the
-   compressed data in order to connect the streams.  The output gzip file
-   has a minimal ten-byte gzip header with no file name or modification time.
-
-   This program was written to illustrate the use of the Z_BLOCK option of
-   inflate() and the crc32_combine() function.  gzjoin will not compile with
-   versions of zlib earlier than 1.2.3.
- */
-
-#include <stdio.h>      /* fputs(), fprintf(), fwrite(), putc() */
-#include <stdlib.h>     /* exit(), malloc(), free() */
-#include <fcntl.h>      /* open() */
-#include <unistd.h>     /* close(), read(), lseek() */
-#include "zlib.h"
-    /* crc32(), crc32_combine(), inflateInit2(), inflate(), inflateEnd() */
-
-#define local static
-
-/* exit with an error (return a value to allow use in an expression) */
-local int bail(char *why1, char *why2)
-{
-    fprintf(stderr, "gzjoin error: %s%s, output incomplete\n", why1, why2);
-    exit(1);
-    return 0;
-}
-
-/* -- simple buffered file input with access to the buffer -- */
-
-#define CHUNK 32768         /* must be a power of two and fit in unsigned */
-
-/* bin buffered input file type */
-typedef struct {
-    char *name;             /* name of file for error messages */
-    int fd;                 /* file descriptor */
-    unsigned left;          /* bytes remaining at next */
-    unsigned char *next;    /* next byte to read */
-    unsigned char *buf;     /* allocated buffer of length CHUNK */
-} bin;
-
-/* close a buffered file and free allocated memory */
-local void bclose(bin *in)
-{
-    if (in != NULL) {
-        if (in->fd != -1)
-            close(in->fd);
-        if (in->buf != NULL)
-            free(in->buf);
-        free(in);
-    }
-}
-
-/* open a buffered file for input, return a pointer to type bin, or NULL on
-   failure */
-local bin *bopen(char *name)
-{
-    bin *in;
-
-    in = malloc(sizeof(bin));
-    if (in == NULL)
-        return NULL;
-    in->buf = malloc(CHUNK);
-    in->fd = open(name, O_RDONLY, 0);
-    if (in->buf == NULL || in->fd == -1) {
-        bclose(in);
-        return NULL;
-    }
-    in->left = 0;
-    in->next = in->buf;
-    in->name = name;
-    return in;
-}
-
-/* load buffer from file, return -1 on read error, 0 or 1 on success, with
-   1 indicating that end-of-file was reached */
-local int bload(bin *in)
-{
-    long len;
-
-    if (in == NULL)
-        return -1;
-    if (in->left != 0)
-        return 0;
-    in->next = in->buf;
-    do {
-        len = (long)read(in->fd, in->buf + in->left, CHUNK - in->left);
-        if (len < 0)
-            return -1;
-        in->left += (unsigned)len;
-    } while (len != 0 && in->left < CHUNK);
-    return len == 0 ? 1 : 0;
-}
-
-/* get a byte from the file, bail if end of file */
-#define bget(in) (in->left ? 0 : bload(in), \
-                  in->left ? (in->left--, *(in->next)++) : \
-                    bail("unexpected end of file on ", in->name))
-
-/* get a four-byte little-endian unsigned integer from file */
-local unsigned long bget4(bin *in)
-{
-    unsigned long val;
-
-    val = bget(in);
-    val += (unsigned long)(bget(in)) << 8;
-    val += (unsigned long)(bget(in)) << 16;
-    val += (unsigned long)(bget(in)) << 24;
-    return val;
-}
-
-/* skip bytes in file */
-local void bskip(bin *in, unsigned skip)
-{
-    /* check pointer */
-    if (in == NULL)
-        return;
-
-    /* easy case -- skip bytes in buffer */
-    if (skip <= in->left) {
-        in->left -= skip;
-        in->next += skip;
-        return;
-    }
-
-    /* skip what's in buffer, discard buffer contents */
-    skip -= in->left;
-    in->left = 0;
-
-    /* seek past multiples of CHUNK bytes */
-    if (skip > CHUNK) {
-        unsigned left;
-
-        left = skip & (CHUNK - 1);
-        if (left == 0) {
-            /* exact number of chunks: seek all the way minus one byte to check
-               for end-of-file with a read */
-            lseek(in->fd, skip - 1, SEEK_CUR);
-            if (read(in->fd, in->buf, 1) != 1)
-                bail("unexpected end of file on ", in->name);
-            return;
-        }
-
-        /* skip the integral chunks, update skip with remainder */
-        lseek(in->fd, skip - left, SEEK_CUR);
-        skip = left;
-    }
-
-    /* read more input and skip remainder */
-    bload(in);
-    if (skip > in->left)
-        bail("unexpected end of file on ", in->name);
-    in->left -= skip;
-    in->next += skip;
-}
-
-/* -- end of buffered input functions -- */
-
-/* skip the gzip header from file in */
-local void gzhead(bin *in)
-{
-    int flags;
-
-    /* verify gzip magic header and compression method */
-    if (bget(in) != 0x1f || bget(in) != 0x8b || bget(in) != 8)
-        bail(in->name, " is not a valid gzip file");
-
-    /* get and verify flags */
-    flags = bget(in);
-    if ((flags & 0xe0) != 0)
-        bail("unknown reserved bits set in ", in->name);
-
-    /* skip modification time, extra flags, and os */
-    bskip(in, 6);
-
-    /* skip extra field if present */
-    if (flags & 4) {
-        unsigned len;
-
-        len = bget(in);
-        len += (unsigned)(bget(in)) << 8;
-        bskip(in, len);
-    }
-
-    /* skip file name if present */
-    if (flags & 8)
-        while (bget(in) != 0)
-            ;
-
-    /* skip comment if present */
-    if (flags & 16)
-        while (bget(in) != 0)
-            ;
-
-    /* skip header crc if present */
-    if (flags & 2)
-        bskip(in, 2);
-}
-
-/* write a four-byte little-endian unsigned integer to out */
-local void put4(unsigned long val, FILE *out)
-{
-    putc(val & 0xff, out);
-    putc((val >> 8) & 0xff, out);
-    putc((val >> 16) & 0xff, out);
-    putc((val >> 24) & 0xff, out);
-}
-
-/* Load up zlib stream from buffered input, bail if end of file */
-local void zpull(z_streamp strm, bin *in)
-{
-    if (in->left == 0)
-        bload(in);
-    if (in->left == 0)
-        bail("unexpected end of file on ", in->name);
-    strm->avail_in = in->left;
-    strm->next_in = in->next;
-}
-
-/* Write header for gzip file to out and initialize trailer. */
-local void gzinit(unsigned long *crc, unsigned long *tot, FILE *out)
-{
-    fwrite("\x1f\x8b\x08\0\0\0\0\0\0\xff", 1, 10, out);
-    *crc = crc32(0L, Z_NULL, 0);
-    *tot = 0;
-}
-
-/* Copy the compressed data from name, zeroing the last block bit of the last
-   block if clr is true, and adding empty blocks as needed to get to a byte
-   boundary.  If clr is false, then the last block becomes the last block of
-   the output, and the gzip trailer is written.  crc and tot maintains the
-   crc and length (modulo 2^32) of the output for the trailer.  The resulting
-   gzip file is written to out.  gzinit() must be called before the first call
-   of gzcopy() to write the gzip header and to initialize crc and tot. */
-local void gzcopy(char *name, int clr, unsigned long *crc, unsigned long *tot,
-                  FILE *out)
-{
-    int ret;                /* return value from zlib functions */
-    int pos;                /* where the "last block" bit is in byte */
-    int last;               /* true if processing the last block */
-    bin *in;                /* buffered input file */
-    unsigned char *start;   /* start of compressed data in buffer */
-    unsigned char *junk;    /* buffer for uncompressed data -- discarded */
-    z_off_t len;            /* length of uncompressed data (support > 4 GB) */
-    z_stream strm;          /* zlib inflate stream */
-
-    /* open gzip file and skip header */
-    in = bopen(name);
-    if (in == NULL)
-        bail("could not open ", name);
-    gzhead(in);
-
-    /* allocate buffer for uncompressed data and initialize raw inflate
-       stream */
-    junk = malloc(CHUNK);
-    strm.zalloc = Z_NULL;
-    strm.zfree = Z_NULL;
-    strm.opaque = Z_NULL;
-    strm.avail_in = 0;
-    strm.next_in = Z_NULL;
-    ret = inflateInit2(&strm, -15);
-    if (junk == NULL || ret != Z_OK)
-        bail("out of memory", "");
-
-    /* inflate and copy compressed data, clear last-block bit if requested */
-    len = 0;
-    zpull(&strm, in);
-    start = strm.next_in;
-    last = start[0] & 1;
-    if (last && clr)
-        start[0] &= ~1;
-    strm.avail_out = 0;
-    for (;;) {
-        /* if input used and output done, write used input and get more */
-        if (strm.avail_in == 0 && strm.avail_out != 0) {
-            fwrite(start, 1, strm.next_in - start, out);
-            start = in->buf;
-            in->left = 0;
-            zpull(&strm, in);
-        }
-
-        /* decompress -- return early when end-of-block reached */
-        strm.avail_out = CHUNK;
-        strm.next_out = junk;
-        ret = inflate(&strm, Z_BLOCK);
-        switch (ret) {
-        case Z_MEM_ERROR:
-            bail("out of memory", "");
-        case Z_DATA_ERROR:
-            bail("invalid compressed data in ", in->name);
-        }
-
-        /* update length of uncompressed data */
-        len += CHUNK - strm.avail_out;
-
-        /* check for block boundary (only get this when block copied out) */
-        if (strm.data_type & 128) {
-            /* if that was the last block, then done */
-            if (last)
-                break;
-
-            /* number of unused bits in last byte */
-            pos = strm.data_type & 7;
-
-            /* find the next last-block bit */
-            if (pos != 0) {
-                /* next last-block bit is in last used byte */
-                pos = 0x100 >> pos;
-                last = strm.next_in[-1] & pos;
-                if (last && clr)
-                    strm.next_in[-1] &= ~pos;
-            }
-            else {
-                /* next last-block bit is in next unused byte */
-                if (strm.avail_in == 0) {
-                    /* don't have that byte yet -- get it */
-                    fwrite(start, 1, strm.next_in - start, out);
-                    start = in->buf;
-                    in->left = 0;
-                    zpull(&strm, in);
-                }
-                last = strm.next_in[0] & 1;
-                if (last && clr)
-                    strm.next_in[0] &= ~1;
-            }
-        }
-    }
-
-    /* update buffer with unused input */
-    in->left = strm.avail_in;
-    in->next = strm.next_in;
-
-    /* copy used input, write empty blocks to get to byte boundary */
-    pos = strm.data_type & 7;
-    fwrite(start, 1, in->next - start - 1, out);
-    last = in->next[-1];
-    if (pos == 0 || !clr)
-        /* already at byte boundary, or last file: write last byte */
-        putc(last, out);
-    else {
-        /* append empty blocks to last byte */
-        last &= ((0x100 >> pos) - 1);       /* assure unused bits are zero */
-        if (pos & 1) {
-            /* odd -- append an empty stored block */
-            putc(last, out);
-            if (pos == 1)
-                putc(0, out);               /* two more bits in block header */
-            fwrite("\0\0\xff\xff", 1, 4, out);
-        }
-        else {
-            /* even -- append 1, 2, or 3 empty fixed blocks */
-            switch (pos) {
-            case 6:
-                putc(last | 8, out);
-                last = 0;
-            case 4:
-                putc(last | 0x20, out);
-                last = 0;
-            case 2:
-                putc(last | 0x80, out);
-                putc(0, out);
-            }
-        }
-    }
-
-    /* update crc and tot */
-    *crc = crc32_combine(*crc, bget4(in), len);
-    *tot += (unsigned long)len;
-
-    /* clean up */
-    inflateEnd(&strm);
-    free(junk);
-    bclose(in);
-
-    /* write trailer if this is the last gzip file */
-    if (!clr) {
-        put4(*crc, out);
-        put4(*tot, out);
-    }
-}
-
-/* join the gzip files on the command line, write result to stdout */
-int main(int argc, char **argv)
-{
-    unsigned long crc, tot;     /* running crc and total uncompressed length */
-
-    /* skip command name */
-    argc--;
-    argv++;
-
-    /* show usage if no arguments */
-    if (argc == 0) {
-        fputs("gzjoin usage: gzjoin f1.gz [f2.gz [f3.gz ...]] > fjoin.gz\n",
-              stderr);
-        return 0;
-    }
-
-    /* join gzip files on command line and write to stdout */
-    gzinit(&crc, &tot, stdout);
-    while (argc--)
-        gzcopy(*argv++, argc, &crc, &tot, stdout);
-
-    /* done */
-    return 0;
-}
diff -Nbaur gcc-4.6.3/zlib/examples/gzlog.c gcc-4.6.3-psp/zlib/examples/gzlog.c
--- gcc-4.6.3/zlib/examples/gzlog.c	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/examples/gzlog.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,413 +0,0 @@
-/*
- * gzlog.c
- * Copyright (C) 2004 Mark Adler
- * For conditions of distribution and use, see copyright notice in gzlog.h
- * version 1.0, 26 Nov 2004
- *
- */
-
-#include <string.h>             /* memcmp() */
-#include <stdlib.h>             /* malloc(), free(), NULL */
-#include <sys/types.h>          /* size_t, off_t */
-#include <unistd.h>             /* read(), close(), sleep(), ftruncate(), */
-                                /* lseek() */
-#include <fcntl.h>              /* open() */
-#include <sys/file.h>           /* flock() */
-#include "zlib.h"               /* deflateInit2(), deflate(), deflateEnd() */
-
-#include "gzlog.h"              /* interface */
-#define local static
-
-/* log object structure */
-typedef struct {
-    int id;                 /* object identifier */
-    int fd;                 /* log file descriptor */
-    off_t extra;            /* offset of extra "ap" subfield */
-    off_t mark_off;         /* offset of marked data */
-    off_t last_off;         /* offset of last block */
-    unsigned long crc;      /* uncompressed crc */
-    unsigned long len;      /* uncompressed length (modulo 2^32) */
-    unsigned stored;        /* length of current stored block */
-} gz_log;
-
-#define GZLOGID 19334       /* gz_log object identifier */
-
-#define LOCK_RETRY 1            /* retry lock once a second */
-#define LOCK_PATIENCE 1200      /* try about twenty minutes before forcing */
-
-/* acquire a lock on a file */
-local int lock(int fd)
-{
-    int patience;
-
-    /* try to lock every LOCK_RETRY seconds for LOCK_PATIENCE seconds */
-    patience = LOCK_PATIENCE;
-    do {
-        if (flock(fd, LOCK_EX + LOCK_NB) == 0)
-            return 0;
-        (void)sleep(LOCK_RETRY);
-        patience -= LOCK_RETRY;
-    } while (patience > 0);
-
-    /* we've run out of patience -- give up */
-    return -1;
-}
-
-/* release lock */
-local void unlock(int fd)
-{
-    (void)flock(fd, LOCK_UN);
-}
-
-/* release a log object */
-local void log_clean(gz_log *log)
-{
-    unlock(log->fd);
-    (void)close(log->fd);
-    free(log);
-}
-
-/* read an unsigned long from a byte buffer little-endian */
-local unsigned long make_ulg(unsigned char *buf)
-{
-    int n;
-    unsigned long val;
-
-    val = (unsigned long)(*buf++);
-    for (n = 8; n < 32; n += 8)
-        val += (unsigned long)(*buf++) << n;
-    return val;
-}
-
-/* read an off_t from a byte buffer little-endian */
-local off_t make_off(unsigned char *buf)
-{
-    int n;
-    off_t val;
-
-    val = (off_t)(*buf++);
-    for (n = 8; n < 64; n += 8)
-        val += (off_t)(*buf++) << n;
-    return val;
-}
-
-/* write an unsigned long little-endian to byte buffer */
-local void dice_ulg(unsigned long val, unsigned char *buf)
-{
-    int n;
-
-    for (n = 0; n < 4; n++) {
-        *buf++ = val & 0xff;
-        val >>= 8;
-    }
-}
-
-/* write an off_t little-endian to byte buffer */
-local void dice_off(off_t val, unsigned char *buf)
-{
-    int n;
-
-    for (n = 0; n < 8; n++) {
-        *buf++ = val & 0xff;
-        val >>= 8;
-    }
-}
-
-/* initial, empty gzip file for appending */
-local char empty_gz[] = {
-    0x1f, 0x8b,                 /* magic gzip id */
-    8,                          /* compression method is deflate */
-    4,                          /* there is an extra field */
-    0, 0, 0, 0,                 /* no modification time provided */
-    0, 0xff,                    /* no extra flags, no OS */
-    20, 0, 'a', 'p', 16, 0,     /* extra field with "ap" subfield */
-    32, 0, 0, 0, 0, 0, 0, 0,    /* offset of uncompressed data */
-    32, 0, 0, 0, 0, 0, 0, 0,    /* offset of last block */
-    1, 0, 0, 0xff, 0xff,        /* empty stored block (last) */
-    0, 0, 0, 0,                 /* crc */
-    0, 0, 0, 0                  /* uncompressed length */
-};
-
-/* initialize a log object with locking */
-void *gzlog_open(char *path)
-{
-    unsigned xlen;
-    unsigned char temp[20];
-    unsigned sub_len;
-    int good;
-    gz_log *log;
-
-    /* allocate log structure */
-    log = malloc(sizeof(gz_log));
-    if (log == NULL)
-        return NULL;
-    log->id = GZLOGID;
-
-    /* open file, creating it if necessary, and locking it */
-    log->fd = open(path, O_RDWR | O_CREAT, 0600);
-    if (log->fd < 0) {
-        free(log);
-        return NULL;
-    }
-    if (lock(log->fd)) {
-        close(log->fd);
-        free(log);
-        return NULL;
-    }
-
-    /* if file is empty, write new gzip stream */
-    if (lseek(log->fd, 0, SEEK_END) == 0) {
-        if (write(log->fd, empty_gz, sizeof(empty_gz)) != sizeof(empty_gz)) {
-            log_clean(log);
-            return NULL;
-        }
-    }
-
-    /* check gzip header */
-    (void)lseek(log->fd, 0, SEEK_SET);
-    if (read(log->fd, temp, 12) != 12 || temp[0] != 0x1f ||
-        temp[1] != 0x8b || temp[2] != 8 || (temp[3] & 4) == 0) {
-        log_clean(log);
-        return NULL;
-    }
-
-    /* process extra field to find "ap" sub-field */
-    xlen = temp[10] + (temp[11] << 8);
-    good = 0;
-    while (xlen) {
-        if (xlen < 4 || read(log->fd, temp, 4) != 4)
-            break;
-        sub_len = temp[2];
-        sub_len += temp[3] << 8;
-        xlen -= 4;
-        if (memcmp(temp, "ap", 2) == 0 && sub_len == 16) {
-            good = 1;
-            break;
-        }
-        if (xlen < sub_len)
-            break;
-        (void)lseek(log->fd, sub_len, SEEK_CUR);
-        xlen -= sub_len;
-    }
-    if (!good) {
-        log_clean(log);
-        return NULL;
-    }
-
-    /* read in "ap" sub-field */
-    log->extra = lseek(log->fd, 0, SEEK_CUR);
-    if (read(log->fd, temp, 16) != 16) {
-        log_clean(log);
-        return NULL;
-    }
-    log->mark_off = make_off(temp);
-    log->last_off = make_off(temp + 8);
-
-    /* get crc, length of gzip file */
-    (void)lseek(log->fd, log->last_off, SEEK_SET);
-    if (read(log->fd, temp, 13) != 13 ||
-        memcmp(temp, "\001\000\000\377\377", 5) != 0) {
-        log_clean(log);
-        return NULL;
-    }
-    log->crc = make_ulg(temp + 5);
-    log->len = make_ulg(temp + 9);
-
-    /* set up to write over empty last block */
-    (void)lseek(log->fd, log->last_off + 5, SEEK_SET);
-    log->stored = 0;
-    return (void *)log;
-}
-
-/* maximum amount to put in a stored block before starting a new one */
-#define MAX_BLOCK 16384
-
-/* write a block to a log object */
-int gzlog_write(void *obj, char *data, size_t len)
-{
-    size_t some;
-    unsigned char temp[5];
-    gz_log *log;
-
-    /* check object */
-    log = (gz_log *)obj;
-    if (log == NULL || log->id != GZLOGID)
-        return 1;
-
-    /* write stored blocks until all of the input is written */
-    do {
-        some = MAX_BLOCK - log->stored;
-        if (some > len)
-            some = len;
-        if (write(log->fd, data, some) != some)
-            return 1;
-        log->crc = crc32(log->crc, data, some);
-        log->len += some;
-        len -= some;
-        data += some;
-        log->stored += some;
-
-        /* if the stored block is full, end it and start another */
-        if (log->stored == MAX_BLOCK) {
-            (void)lseek(log->fd, log->last_off, SEEK_SET);
-            temp[0] = 0;
-            dice_ulg(log->stored + ((unsigned long)(~log->stored) << 16),
-                     temp + 1);
-            if (write(log->fd, temp, 5) != 5)
-                return 1;
-            log->last_off = lseek(log->fd, log->stored, SEEK_CUR);
-            (void)lseek(log->fd, 5, SEEK_CUR);
-            log->stored = 0;
-        }
-    } while (len);
-    return 0;
-}
-
-/* recompress the remaining stored deflate data in place */
-local int recomp(gz_log *log)
-{
-    z_stream strm;
-    size_t len, max;
-    unsigned char *in;
-    unsigned char *out;
-    unsigned char temp[16];
-
-    /* allocate space and read it all in (it's around 1 MB) */
-    len = log->last_off - log->mark_off;
-    max = len + (len >> 12) + (len >> 14) + 11;
-    out = malloc(max);
-    if (out == NULL)
-        return 1;
-    in = malloc(len);
-    if (in == NULL) {
-        free(out);
-        return 1;
-    }
-    (void)lseek(log->fd, log->mark_off, SEEK_SET);
-    if (read(log->fd, in, len) != len) {
-        free(in);
-        free(out);
-        return 1;
-    }
-
-    /* recompress in memory, decoding stored data as we go */
-    /* note: this assumes that unsigned is four bytes or more */
-    /*       consider not making that assumption */
-    strm.zalloc = Z_NULL;
-    strm.zfree = Z_NULL;
-    strm.opaque = Z_NULL;
-    if (deflateInit2(&strm, Z_BEST_COMPRESSION, Z_DEFLATED, -15, 8,
-        Z_DEFAULT_STRATEGY) != Z_OK) {
-        free(in);
-        free(out);
-        return 1;
-    }
-    strm.next_in = in;
-    strm.avail_out = max;
-    strm.next_out = out;
-    while (len >= 5) {
-        if (strm.next_in[0] != 0)
-            break;
-        strm.avail_in = strm.next_in[1] + (strm.next_in[2] << 8);
-        strm.next_in += 5;
-        len -= 5;
-        if (strm.avail_in != 0) {
-            if (len < strm.avail_in)
-                break;
-            len -= strm.avail_in;
-            (void)deflate(&strm, Z_NO_FLUSH);
-            if (strm.avail_in != 0 || strm.avail_out == 0)
-                break;
-        }
-    }
-    (void)deflate(&strm, Z_SYNC_FLUSH);
-    (void)deflateEnd(&strm);
-    free(in);
-    if (len != 0 || strm.avail_out == 0) {
-        free(out);
-        return 1;
-    }
-
-    /* overwrite stored data with compressed data */
-    (void)lseek(log->fd, log->mark_off, SEEK_SET);
-    len = max - strm.avail_out;
-    if (write(log->fd, out, len) != len) {
-        free(out);
-        return 1;
-    }
-    free(out);
-
-    /* write last empty block, crc, and length */
-    log->mark_off = log->last_off = lseek(log->fd, 0, SEEK_CUR);
-    temp[0] = 1;
-    dice_ulg(0xffffL << 16, temp + 1);
-    dice_ulg(log->crc, temp + 5);
-    dice_ulg(log->len, temp + 9);
-    if (write(log->fd, temp, 13) != 13)
-        return 1;
-
-    /* truncate file to discard remaining stored data and old trailer */
-    ftruncate(log->fd, lseek(log->fd, 0, SEEK_CUR));
-
-    /* update extra field to point to new last empty block */
-    (void)lseek(log->fd, log->extra, SEEK_SET);
-    dice_off(log->mark_off, temp);
-    dice_off(log->last_off, temp + 8);
-    if (write(log->fd, temp, 16) != 16)
-        return 1;
-    return 0;
-}
-
-/* maximum accumulation of stored blocks before compressing */
-#define MAX_STORED 1048576
-
-/* close log object */
-int gzlog_close(void *obj)
-{
-    unsigned char temp[8];
-    gz_log *log;
-
-    /* check object */
-    log = (gz_log *)obj;
-    if (log == NULL || log->id != GZLOGID)
-        return 1;
-
-    /* go to start of most recent block being written */
-    (void)lseek(log->fd, log->last_off, SEEK_SET);
-
-    /* if some stuff was put there, update block */
-    if (log->stored) {
-        temp[0] = 0;
-        dice_ulg(log->stored + ((unsigned long)(~log->stored) << 16),
-                 temp + 1);
-        if (write(log->fd, temp, 5) != 5)
-            return 1;
-        log->last_off = lseek(log->fd, log->stored, SEEK_CUR);
-    }
-
-    /* write last block (empty) */
-    if (write(log->fd, "\001\000\000\377\377", 5) != 5)
-        return 1;
-
-    /* write updated crc and uncompressed length */
-    dice_ulg(log->crc, temp);
-    dice_ulg(log->len, temp + 4);
-    if (write(log->fd, temp, 8) != 8)
-        return 1;
-
-    /* put offset of that last block in gzip extra block */
-    (void)lseek(log->fd, log->extra + 8, SEEK_SET);
-    dice_off(log->last_off, temp);
-    if (write(log->fd, temp, 8) != 8)
-        return 1;
-
-    /* if more than 1 MB stored, then time to compress it */
-    if (log->last_off - log->mark_off > MAX_STORED) {
-        if (recomp(log))
-            return 1;
-    }
-
-    /* unlock and close file */
-    log_clean(log);
-    return 0;
-}
diff -Nbaur gcc-4.6.3/zlib/examples/gzlog.h gcc-4.6.3-psp/zlib/examples/gzlog.h
--- gcc-4.6.3/zlib/examples/gzlog.h	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/examples/gzlog.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,58 +0,0 @@
-/* gzlog.h
-  Copyright (C) 2004 Mark Adler, all rights reserved
-  version 1.0, 26 Nov 2004
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the author be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Mark Adler    madler@alumni.caltech.edu
- */
-
-/*
-   The gzlog object allows writing short messages to a gzipped log file,
-   opening the log file locked for small bursts, and then closing it.  The log
-   object works by appending stored data to the gzip file until 1 MB has been
-   accumulated.  At that time, the stored data is compressed, and replaces the
-   uncompressed data in the file.  The log file is truncated to its new size at
-   that time.  After closing, the log file is always valid gzip file that can
-   decompressed to recover what was written.
-
-   A gzip header "extra" field contains two file offsets for appending.  The
-   first points to just after the last compressed data.  The second points to
-   the last stored block in the deflate stream, which is empty.  All of the
-   data between those pointers is uncompressed.
- */
-
-/* Open a gzlog object, creating the log file if it does not exist.  Return
-   NULL on error.  Note that gzlog_open() could take a long time to return if
-   there is difficulty in locking the file. */
-void *gzlog_open(char *path);
-
-/* Write to a gzlog object.  Return non-zero on error.  This function will
-   simply write data to the file uncompressed.  Compression of the data
-   will not occur until gzlog_close() is called.  It is expected that
-   gzlog_write() is used for a short message, and then gzlog_close() is
-   called.  If a large amount of data is to be written, then the application
-   should write no more than 1 MB at a time with gzlog_write() before
-   calling gzlog_close() and then gzlog_open() again. */
-int gzlog_write(void *log, char *data, size_t len);
-
-/* Close a gzlog object.  Return non-zero on error.  The log file is locked
-   until this function is called.  This function will compress stored data
-   at the end of the gzip file if at least 1 MB has been accumulated.  Note
-   that the file will not be a valid gzip file until this function completes.
- */
-int gzlog_close(void *log);
diff -Nbaur gcc-4.6.3/zlib/examples/README.examples gcc-4.6.3-psp/zlib/examples/README.examples
--- gcc-4.6.3/zlib/examples/README.examples	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/examples/README.examples	1970-01-01 01:00:00.000000000 +0100
@@ -1,42 +0,0 @@
-This directory contains examples of the use of zlib.
-
-fitblk.c
-    compress just enough input to nearly fill a requested output size
-    - zlib isn't designed to do this, but fitblk does it anyway
-
-gun.c
-    uncompress a gzip file
-    - illustrates the use of inflateBack() for high speed file-to-file
-      decompression using call-back functions
-    - is approximately twice as fast as gzip -d
-    - also provides Unix uncompress functionality, again twice as fast
-
-gzappend.c
-    append to a gzip file
-    - illustrates the use of the Z_BLOCK flush parameter for inflate()
-    - illustrates the use of deflatePrime() to start at any bit
-
-gzjoin.c
-    join gzip files without recalculating the crc or recompressing
-    - illustrates the use of the Z_BLOCK flush parameter for inflate()
-    - illustrates the use of crc32_combine()
-
-gzlog.c
-gzlog.h
-    efficiently maintain a message log file in gzip format
-    - illustrates use of raw deflate and Z_SYNC_FLUSH
-    - illustrates use of gzip header extra field
-
-zlib_how.html
-    painfully comprehensive description of zpipe.c (see below)
-    - describes in excruciating detail the use of deflate() and inflate()
-
-zpipe.c
-    reads and writes zlib streams from stdin to stdout
-    - illustrates the proper use of deflate() and inflate()
-    - deeply commented in zlib_how.html (see above)
-
-zran.c
-    index a zlib or gzip stream and randomly access it
-    - illustrates the use of Z_BLOCK, inflatePrime(), and
-      inflateSetDictionary() to provide random access
diff -Nbaur gcc-4.6.3/zlib/examples/zlib_how.html gcc-4.6.3-psp/zlib/examples/zlib_how.html
--- gcc-4.6.3/zlib/examples/zlib_how.html	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/examples/zlib_how.html	1970-01-01 01:00:00.000000000 +0100
@@ -1,523 +0,0 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
-  "http://www.w3.org/TR/REC-html40/loose.dtd">
-<html>
-<head>
-<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
-<title>zlib Usage Example</title>
-<!--  Copyright (c) 2004 Mark Adler.  -->
-</head>
-<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#00A000">
-<h2 align="center"> zlib Usage Example </h2>
-We often get questions about how the <tt>deflate()</tt> and <tt>inflate()</tt> functions should be used.
-Users wonder when they should provide more input, when they should use more output,
-what to do with a <tt>Z_BUF_ERROR</tt>, how to make sure the process terminates properly, and
-so on.  So for those who have read <tt>zlib.h</tt> (a few times), and
-would like further edification, below is an annotated example in C of simple routines to compress and decompress
-from an input file to an output file using <tt>deflate()</tt> and <tt>inflate()</tt> respectively.  The
-annotations are interspersed between lines of the code.  So please read between the lines.
-We hope this helps explain some of the intricacies of <em>zlib</em>.
-<p>
-Without further adieu, here is the program <a href="zpipe.c"><tt>zpipe.c</tt></a>:
-<pre><b>
-/* zpipe.c: example of proper use of zlib's inflate() and deflate()
-   Not copyrighted -- provided to the public domain
-   Version 1.2  9 November 2004  Mark Adler */
-
-/* Version history:
-   1.0  30 Oct 2004  First version
-   1.1   8 Nov 2004  Add void casting for unused return values
-                     Use switch statement for inflate() return values
-   1.2   9 Nov 2004  Add assertions to document zlib guarantees
- */
-</b></pre><!-- -->
-We now include the header files for the required definitions.  From
-<tt>stdio.h</tt> we use <tt>fopen()</tt>, <tt>fread()</tt>, <tt>fwrite()</tt>,
-<tt>feof()</tt>, <tt>ferror()</tt>, and <tt>fclose()</tt> for file i/o, and
-<tt>fputs()</tt> for error messages.  From <tt>string.h</tt> we use
-<tt>strcmp()</tt> for command line argument processing.
-From <tt>assert.h</tt> we use the <tt>assert()</tt> macro.
-From <tt>zlib.h</tt>
-we use the basic compression functions <tt>deflateInit()</tt>,
-<tt>deflate()</tt>, and <tt>deflateEnd()</tt>, and the basic decompression
-functions <tt>inflateInit()</tt>, <tt>inflate()</tt>, and
-<tt>inflateEnd()</tt>.
-<pre><b>
-#include &lt;stdio.h&gt;
-#include &lt;string.h&gt;
-#include &lt;assert.h&gt;
-#include "zlib.h"
-</b></pre><!-- -->
-<tt>CHUNK</tt> is simply the buffer size for feeding data to and pulling data
-from the <em>zlib</em> routines.  Larger buffer sizes would be more efficient,
-especially for <tt>inflate()</tt>.  If the memory is available, buffers sizes
-on the order of 128K or 256K bytes should be used.
-<pre><b>
-#define CHUNK 16384
-</b></pre><!-- -->
-The <tt>def()</tt> routine compresses data from an input file to an output file.  The output data
-will be in the <em>zlib</em> format, which is different from the <em>gzip</em> or <em>zip</em>
-formats.  The <em>zlib</em> format has a very small header of only two bytes to identify it as
-a <em>zlib</em> stream and to provide decoding information, and a four-byte trailer with a fast
-check value to verify the integrity of the uncompressed data after decoding.
-<pre><b>
-/* Compress from file source to file dest until EOF on source.
-   def() returns Z_OK on success, Z_MEM_ERROR if memory could not be
-   allocated for processing, Z_STREAM_ERROR if an invalid compression
-   level is supplied, Z_VERSION_ERROR if the version of zlib.h and the
-   version of the library linked do not match, or Z_ERRNO if there is
-   an error reading or writing the files. */
-int def(FILE *source, FILE *dest, int level)
-{
-</b></pre>
-Here are the local variables for <tt>def()</tt>.  <tt>ret</tt> will be used for <em>zlib</em>
-return codes.  <tt>flush</tt> will keep track of the current flushing state for <tt>deflate()</tt>,
-which is either no flushing, or flush to completion after the end of the input file is reached.
-<tt>have</tt> is the amount of data returned from <tt>deflate()</tt>.  The <tt>strm</tt> structure
-is used to pass information to and from the <em>zlib</em> routines, and to maintain the
-<tt>deflate()</tt> state.  <tt>in</tt> and <tt>out</tt> are the input and output buffers for
-<tt>deflate()</tt>.
-<pre><b>
-    int ret, flush;
-    unsigned have;
-    z_stream strm;
-    char in[CHUNK];
-    char out[CHUNK];
-</b></pre><!-- -->
-The first thing we do is to initialize the <em>zlib</em> state for compression using
-<tt>deflateInit()</tt>.  This must be done before the first use of <tt>deflate()</tt>.
-The <tt>zalloc</tt>, <tt>zfree</tt>, and <tt>opaque</tt> fields in the <tt>strm</tt>
-structure must be initialized before calling <tt>deflateInit()</tt>.  Here they are
-set to the <em>zlib</em> constant <tt>Z_NULL</tt> to request that <em>zlib</em> use
-the default memory allocation routines.  An application may also choose to provide
-custom memory allocation routines here.  <tt>deflateInit()</tt> will allocate on the
-order of 256K bytes for the internal state.
-(See <a href="zlib_tech.html"><em>zlib Technical Details</em></a>.)
-<p>
-<tt>deflateInit()</tt> is called with a pointer to the structure to be initialized and
-the compression level, which is an integer in the range of -1 to 9.  Lower compression
-levels result in faster execution, but less compression.  Higher levels result in
-greater compression, but slower execution.  The <em>zlib</em> constant Z_DEFAULT_COMPRESSION,
-equal to -1,
-provides a good compromise between compression and speed and is equivalent to level 6.
-Level 0 actually does no compression at all, and in fact expands the data slightly to produce
-the <em>zlib</em> format (it is not a byte-for-byte copy of the input).
-More advanced applications of <em>zlib</em>
-may use <tt>deflateInit2()</tt> here instead.  Such an application may want to reduce how
-much memory will be used, at some price in compression.  Or it may need to request a
-<em>gzip</em> header and trailer instead of a <em>zlib</em> header and trailer, or raw
-encoding with no header or trailer at all.
-<p>
-We must check the return value of <tt>deflateInit()</tt> against the <em>zlib</em> constant
-<tt>Z_OK</tt> to make sure that it was able to
-allocate memory for the internal state, and that the provided arguments were valid.
-<tt>deflateInit()</tt> will also check that the version of <em>zlib</em> that the <tt>zlib.h</tt>
-file came from matches the version of <em>zlib</em> actually linked with the program.  This
-is especially important for environments in which <em>zlib</em> is a shared library.
-<p>
-Note that an application can initialize multiple, independent <em>zlib</em> streams, which can
-operate in parallel.  The state information maintained in the structure allows the <em>zlib</em>
-routines to be reentrant.
-<pre><b>
-    /* allocate deflate state */
-    strm.zalloc = Z_NULL;
-    strm.zfree = Z_NULL;
-    strm.opaque = Z_NULL;
-    ret = deflateInit(&amp;strm, level);
-    if (ret != Z_OK)
-        return ret;
-</b></pre><!-- -->
-With the pleasantries out of the way, now we can get down to business.  The outer <tt>do</tt>-loop
-reads all of the input file and exits at the bottom of the loop once end-of-file is reached.
-This loop contains the only call of <tt>deflate()</tt>.  So we must make sure that all of the
-input data has been processed and that all of the output data has been generated and consumed
-before we fall out of the loop at the bottom.
-<pre><b>
-    /* compress until end of file */
-    do {
-</b></pre>
-We start off by reading data from the input file.  The number of bytes read is put directly
-into <tt>avail_in</tt>, and a pointer to those bytes is put into <tt>next_in</tt>.  We also
-check to see if end-of-file on the input has been reached.  If we are at the end of file, then <tt>flush</tt> is set to the
-<em>zlib</em> constant <tt>Z_FINISH</tt>, which is later passed to <tt>deflate()</tt> to
-indicate that this is the last chunk of input data to compress.  We need to use <tt>feof()</tt>
-to check for end-of-file as opposed to seeing if fewer than <tt>CHUNK</tt> bytes have been read.  The
-reason is that if the input file length is an exact multiple of <tt>CHUNK</tt>, we will miss
-the fact that we got to the end-of-file, and not know to tell <tt>deflate()</tt> to finish
-up the compressed stream.  If we are not yet at the end of the input, then the <em>zlib</em>
-constant <tt>Z_NO_FLUSH</tt> will be passed to <tt>deflate</tt> to indicate that we are still
-in the middle of the uncompressed data.
-<p>
-If there is an error in reading from the input file, the process is aborted with
-<tt>deflateEnd()</tt> being called to free the allocated <em>zlib</em> state before returning
-the error.  We wouldn't want a memory leak, now would we?  <tt>deflateEnd()</tt> can be called
-at any time after the state has been initialized.  Once that's done, <tt>deflateInit()</tt> (or
-<tt>deflateInit2()</tt>) would have to be called to start a new compression process.  There is
-no point here in checking the <tt>deflateEnd()</tt> return code.  The deallocation can't fail.
-<pre><b>
-        strm.avail_in = fread(in, 1, CHUNK, source);
-        if (ferror(source)) {
-            (void)deflateEnd(&amp;strm);
-            return Z_ERRNO;
-        }
-        flush = feof(source) ? Z_FINISH : Z_NO_FLUSH;
-        strm.next_in = in;
-</b></pre><!-- -->
-The inner <tt>do</tt>-loop passes our chunk of input data to <tt>deflate()</tt>, and then
-keeps calling <tt>deflate()</tt> until it is done producing output.  Once there is no more
-new output, <tt>deflate()</tt> is guaranteed to have consumed all of the input, i.e.,
-<tt>avail_in</tt> will be zero.
-<pre><b>
-        /* run deflate() on input until output buffer not full, finish
-           compression if all of source has been read in */
-        do {
-</b></pre>
-Output space is provided to <tt>deflate()</tt> by setting <tt>avail_out</tt> to the number
-of available output bytes and <tt>next_out</tt> to a pointer to that space.
-<pre><b>
-            strm.avail_out = CHUNK;
-            strm.next_out = out;
-</b></pre>
-Now we call the compression engine itself, <tt>deflate()</tt>.  It takes as many of the
-<tt>avail_in</tt> bytes at <tt>next_in</tt> as it can process, and writes as many as
-<tt>avail_out</tt> bytes to <tt>next_out</tt>.  Those counters and pointers are then
-updated past the input data consumed and the output data written.  It is the amount of
-output space available that may limit how much input is consumed.
-Hence the inner loop to make sure that
-all of the input is consumed by providing more output space each time.  Since <tt>avail_in</tt>
-and <tt>next_in</tt> are updated by <tt>deflate()</tt>, we don't have to mess with those
-between <tt>deflate()</tt> calls until it's all used up.
-<p>
-The parameters to <tt>deflate()</tt> are a pointer to the <tt>strm</tt> structure containing
-the input and output information and the internal compression engine state, and a parameter
-indicating whether and how to flush data to the output.  Normally <tt>deflate</tt> will consume
-several K bytes of input data before producing any output (except for the header), in order
-to accumulate statistics on the data for optimum compression.  It will then put out a burst of
-compressed data, and proceed to consume more input before the next burst.  Eventually,
-<tt>deflate()</tt>
-must be told to terminate the stream, complete the compression with provided input data, and
-write out the trailer check value.  <tt>deflate()</tt> will continue to compress normally as long
-as the flush parameter is <tt>Z_NO_FLUSH</tt>.  Once the <tt>Z_FINISH</tt> parameter is provided,
-<tt>deflate()</tt> will begin to complete the compressed output stream.  However depending on how
-much output space is provided, <tt>deflate()</tt> may have to be called several times until it
-has provided the complete compressed stream, even after it has consumed all of the input.  The flush
-parameter must continue to be <tt>Z_FINISH</tt> for those subsequent calls.
-<p>
-There are other values of the flush parameter that are used in more advanced applications.  You can
-force <tt>deflate()</tt> to produce a burst of output that encodes all of the input data provided
-so far, even if it wouldn't have otherwise, for example to control data latency on a link with
-compressed data.  You can also ask that <tt>deflate()</tt> do that as well as erase any history up to
-that point so that what follows can be decompressed independently, for example for random access
-applications.  Both requests will degrade compression by an amount depending on how often such
-requests are made.
-<p>
-<tt>deflate()</tt> has a return value that can indicate errors, yet we do not check it here.  Why
-not?  Well, it turns out that <tt>deflate()</tt> can do no wrong here.  Let's go through
-<tt>deflate()</tt>'s return values and dispense with them one by one.  The possible values are
-<tt>Z_OK</tt>, <tt>Z_STREAM_END</tt>, <tt>Z_STREAM_ERROR</tt>, or <tt>Z_BUF_ERROR</tt>.  <tt>Z_OK</tt>
-is, well, ok.  <tt>Z_STREAM_END</tt> is also ok and will be returned for the last call of
-<tt>deflate()</tt>.  This is already guaranteed by calling <tt>deflate()</tt> with <tt>Z_FINISH</tt>
-until it has no more output.  <tt>Z_STREAM_ERROR</tt> is only possible if the stream is not
-initialized properly, but we did initialize it properly.  There is no harm in checking for
-<tt>Z_STREAM_ERROR</tt> here, for example to check for the possibility that some
-other part of the application inadvertently clobbered the memory containing the <em>zlib</em> state.
-<tt>Z_BUF_ERROR</tt> will be explained further below, but
-suffice it to say that this is simply an indication that <tt>deflate()</tt> could not consume
-more input or produce more output.  <tt>deflate()</tt> can be called again with more output space
-or more available input, which it will be in this code.
-<pre><b>
-            ret = deflate(&amp;strm, flush);    /* no bad return value */
-            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */
-</b></pre>
-Now we compute how much output <tt>deflate()</tt> provided on the last call, which is the
-difference between how much space was provided before the call, and how much output space
-is still available after the call.  Then that data, if any, is written to the output file.
-We can then reuse the output buffer for the next call of <tt>deflate()</tt>.  Again if there
-is a file i/o error, we call <tt>deflateEnd()</tt> before returning to avoid a memory leak.
-<pre><b>
-            have = CHUNK - strm.avail_out;
-            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {
-                (void)deflateEnd(&amp;strm);
-                return Z_ERRNO;
-            }
-</b></pre>
-The inner <tt>do</tt>-loop is repeated until the last <tt>deflate()</tt> call fails to fill the
-provided output buffer.  Then we know that <tt>deflate()</tt> has done as much as it can with
-the provided input, and that all of that input has been consumed.  We can then fall out of this
-loop and reuse the input buffer.
-<p>
-The way we tell that <tt>deflate()</tt> has no more output is by seeing that it did not fill
-the output buffer, leaving <tt>avail_out</tt> greater than zero.  However suppose that
-<tt>deflate()</tt> has no more output, but just so happened to exactly fill the output buffer!
-<tt>avail_out</tt> is zero, and we can't tell that <tt>deflate()</tt> has done all it can.
-As far as we know, <tt>deflate()</tt>
-has more output for us.  So we call it again.  But now <tt>deflate()</tt> produces no output
-at all, and <tt>avail_out</tt> remains unchanged as <tt>CHUNK</tt>.  That <tt>deflate()</tt> call
-wasn't able to do anything, either consume input or produce output, and so it returns
-<tt>Z_BUF_ERROR</tt>.  (See, I told you I'd cover this later.)  However this is not a problem at
-all.  Now we finally have the desired indication that <tt>deflate()</tt> is really done,
-and so we drop out of the inner loop to provide more input to <tt>deflate()</tt>.
-<p>
-With <tt>flush</tt> set to <tt>Z_FINISH</tt>, this final set of <tt>deflate()</tt> calls will
-complete the output stream.  Once that is done, subsequent calls of <tt>deflate()</tt> would return
-<tt>Z_STREAM_ERROR</tt> if the flush parameter is not <tt>Z_FINISH</tt>, and do no more processing
-until the state is reinitialized.
-<p>
-Some applications of <em>zlib</em> have two loops that call <tt>deflate()</tt>
-instead of the single inner loop we have here.  The first loop would call
-without flushing and feed all of the data to <tt>deflate()</tt>.  The second loop would call
-<tt>deflate()</tt> with no more
-data and the <tt>Z_FINISH</tt> parameter to complete the process.  As you can see from this
-example, that can be avoided by simply keeping track of the current flush state.
-<pre><b>
-        } while (strm.avail_out == 0);
-        assert(strm.avail_in == 0);     /* all input will be used */
-</b></pre><!-- -->
-Now we check to see if we have already processed all of the input file.  That information was
-saved in the <tt>flush</tt> variable, so we see if that was set to <tt>Z_FINISH</tt>.  If so,
-then we're done and we fall out of the outer loop.  We're guaranteed to get <tt>Z_STREAM_END</tt>
-from the last <tt>deflate()</tt> call, since we ran it until the last chunk of input was
-consumed and all of the output was generated.
-<pre><b>
-        /* done when last data in file processed */
-    } while (flush != Z_FINISH);
-    assert(ret == Z_STREAM_END);        /* stream will be complete */
-</b></pre><!-- -->
-The process is complete, but we still need to deallocate the state to avoid a memory leak
-(or rather more like a memory hemorrhage if you didn't do this).  Then
-finally we can return with a happy return value.
-<pre><b>
-    /* clean up and return */
-    (void)deflateEnd(&amp;strm);
-    return Z_OK;
-}
-</b></pre><!-- -->
-Now we do the same thing for decompression in the <tt>inf()</tt> routine. <tt>inf()</tt>
-decompresses what is hopefully a valid <em>zlib</em> stream from the input file and writes the
-uncompressed data to the output file.  Much of the discussion above for <tt>def()</tt>
-applies to <tt>inf()</tt> as well, so the discussion here will focus on the differences between
-the two.
-<pre><b>
-/* Decompress from file source to file dest until stream ends or EOF.
-   inf() returns Z_OK on success, Z_MEM_ERROR if memory could not be
-   allocated for processing, Z_DATA_ERROR if the deflate data is
-   invalid or incomplete, Z_VERSION_ERROR if the version of zlib.h and
-   the version of the library linked do not match, or Z_ERRNO if there
-   is an error reading or writing the files. */
-int inf(FILE *source, FILE *dest)
-{
-</b></pre>
-The local variables have the same functionality as they do for <tt>def()</tt>.  The
-only difference is that there is no <tt>flush</tt> variable, since <tt>inflate()</tt>
-can tell from the <em>zlib</em> stream itself when the stream is complete.
-<pre><b>
-    int ret;
-    unsigned have;
-    z_stream strm;
-    char in[CHUNK];
-    char out[CHUNK];
-</b></pre><!-- -->
-The initialization of the state is the same, except that there is no compression level,
-of course, and two more elements of the structure are initialized.  <tt>avail_in</tt>
-and <tt>next_in</tt> must be initialized before calling <tt>inflateInit()</tt>.  This
-is because the application has the option to provide the start of the zlib stream in
-order for <tt>inflateInit()</tt> to have access to information about the compression
-method to aid in memory allocation.  In the current implementation of <em>zlib</em>
-(up through versions 1.2.x), the method-dependent memory allocations are deferred to the first call of
-<tt>inflate()</tt> anyway.  However those fields must be initialized since later versions
-of <em>zlib</em> that provide more compression methods may take advantage of this interface.
-In any case, no decompression is performed by <tt>inflateInit()</tt>, so the
-<tt>avail_out</tt> and <tt>next_out</tt> fields do not need to be initialized before calling.
-<p>
-Here <tt>avail_in</tt> is set to zero and <tt>next_in</tt> is set to <tt>Z_NULL</tt> to
-indicate that no input data is being provided.
-<pre><b>
-    /* allocate inflate state */
-    strm.zalloc = Z_NULL;
-    strm.zfree = Z_NULL;
-    strm.opaque = Z_NULL;
-    strm.avail_in = 0;
-    strm.next_in = Z_NULL;
-    ret = inflateInit(&amp;strm);
-    if (ret != Z_OK)
-        return ret;
-</b></pre><!-- -->
-The outer <tt>do</tt>-loop decompresses input until <tt>inflate()</tt> indicates
-that it has reached the end of the compressed data and has produced all of the uncompressed
-output.  This is in contrast to <tt>def()</tt> which processes all of the input file.
-If end-of-file is reached before the compressed data self-terminates, then the compressed
-data is incomplete and an error is returned.
-<pre><b>
-    /* decompress until deflate stream ends or end of file */
-    do {
-</b></pre>
-We read input data and set the <tt>strm</tt> structure accordingly.  If we've reached the
-end of the input file, then we leave the outer loop and report an error, since the
-compressed data is incomplete.  Note that we may read more data than is eventually consumed
-by <tt>inflate()</tt>, if the input file continues past the <em>zlib</em> stream.
-For applications where <em>zlib</em> streams are embedded in other data, this routine would
-need to be modified to return the unused data, or at least indicate how much of the input
-data was not used, so the application would know where to pick up after the <em>zlib</em> stream.
-<pre><b>
-        strm.avail_in = fread(in, 1, CHUNK, source);
-        if (ferror(source)) {
-            (void)inflateEnd(&amp;strm);
-            return Z_ERRNO;
-        }
-        if (strm.avail_in == 0)
-            break;
-        strm.next_in = in;
-</b></pre><!-- -->
-The inner <tt>do</tt>-loop has the same function it did in <tt>def()</tt>, which is to
-keep calling <tt>inflate()</tt> until has generated all of the output it can with the
-provided input.
-<pre><b>
-        /* run inflate() on input until output buffer not full */
-        do {
-</b></pre>
-Just like in <tt>def()</tt>, the same output space is provided for each call of <tt>inflate()</tt>.
-<pre><b>
-            strm.avail_out = CHUNK;
-            strm.next_out = out;
-</b></pre>
-Now we run the decompression engine itself.  There is no need to adjust the flush parameter, since
-the <em>zlib</em> format is self-terminating. The main difference here is that there are
-return values that we need to pay attention to.  <tt>Z_DATA_ERROR</tt>
-indicates that <tt>inflate()</tt> detected an error in the <em>zlib</em> compressed data format,
-which means that either the data is not a <em>zlib</em> stream to begin with, or that the data was
-corrupted somewhere along the way since it was compressed.  The other error to be processed is
-<tt>Z_MEM_ERROR</tt>, which can occur since memory allocation is deferred until <tt>inflate()</tt>
-needs it, unlike <tt>deflate()</tt>, whose memory is allocated at the start by <tt>deflateInit()</tt>.
-<p>
-Advanced applications may use
-<tt>deflateSetDictionary()</tt> to prime <tt>deflate()</tt> with a set of likely data to improve the
-first 32K or so of compression.  This is noted in the <em>zlib</em> header, so <tt>inflate()</tt>
-requests that that dictionary be provided before it can start to decompress.  Without the dictionary,
-correct decompression is not possible.  For this routine, we have no idea what the dictionary is,
-so the <tt>Z_NEED_DICT</tt> indication is converted to a <tt>Z_DATA_ERROR</tt>.
-<p>
-<tt>inflate()</tt> can also return <tt>Z_STREAM_ERROR</tt>, which should not be possible here,
-but could be checked for as noted above for <tt>def()</tt>.  <tt>Z_BUF_ERROR</tt> does not need to be
-checked for here, for the same reasons noted for <tt>def()</tt>.  <tt>Z_STREAM_END</tt> will be
-checked for later.
-<pre><b>
-            ret = inflate(&amp;strm, Z_NO_FLUSH);
-            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */
-            switch (ret) {
-            case Z_NEED_DICT:
-                ret = Z_DATA_ERROR;     /* and fall through */
-            case Z_DATA_ERROR:
-            case Z_MEM_ERROR:
-                (void)inflateEnd(&amp;strm);
-                return ret;
-            }
-</b></pre>
-The output of <tt>inflate()</tt> is handled identically to that of <tt>deflate()</tt>.
-<pre><b>
-            have = CHUNK - strm.avail_out;
-            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {
-                (void)inflateEnd(&amp;strm);
-                return Z_ERRNO;
-            }
-</b></pre>
-The inner <tt>do</tt>-loop ends when <tt>inflate()</tt> has no more output as indicated
-by not filling the output buffer, just as for <tt>deflate()</tt>.  In this case, we cannot
-assert that <tt>strm.avail_in</tt> will be zero, since the deflate stream may end before the file
-does.
-<pre><b>
-        } while (strm.avail_out == 0);
-</b></pre><!-- -->
-The outer <tt>do</tt>-loop ends when <tt>inflate()</tt> reports that it has reached the
-end of the input <em>zlib</em> stream, has completed the decompression and integrity
-check, and has provided all of the output.  This is indicated by the <tt>inflate()</tt>
-return value <tt>Z_STREAM_END</tt>.  The inner loop is guaranteed to leave <tt>ret</tt>
-equal to <tt>Z_STREAM_END</tt> if the last chunk of the input file read contained the end
-of the <em>zlib</em> stream.  So if the return value is not <tt>Z_STREAM_END</tt>, the
-loop continues to read more input.
-<pre><b>
-        /* done when inflate() says it's done */
-    } while (ret != Z_STREAM_END);
-</b></pre><!-- -->
-At this point, decompression successfully completed, or we broke out of the loop due to no
-more data being available from the input file.  If the last <tt>inflate()</tt> return value
-is not <tt>Z_STREAM_END</tt>, then the <em>zlib</em> stream was incomplete and a data error
-is returned.  Otherwise, we return with a happy return value.  Of course, <tt>inflateEnd()</tt>
-is called first to avoid a memory leak.
-<pre><b>
-    /* clean up and return */
-    (void)inflateEnd(&amp;strm);
-    return ret == Z_STREAM_END ? Z_OK : Z_DATA_ERROR;
-}
-</b></pre><!-- -->
-That ends the routines that directly use <em>zlib</em>.  The following routines make this
-a command-line program by running data through the above routines from <tt>stdin</tt> to
-<tt>stdout</tt>, and handling any errors reported by <tt>def()</tt> or <tt>inf()</tt>.
-<p>
-<tt>zerr()</tt> is used to interpret the possible error codes from <tt>def()</tt>
-and <tt>inf()</tt>, as detailed in their comments above, and print out an error message.
-Note that these are only a subset of the possible return values from <tt>deflate()</tt>
-and <tt>inflate()</tt>.
-<pre><b>
-/* report a zlib or i/o error */
-void zerr(int ret)
-{
-    fputs("zpipe: ", stderr);
-    switch (ret) {
-    case Z_ERRNO:
-        if (ferror(stdin))
-            fputs("error reading stdin\n", stderr);
-        if (ferror(stdout))
-            fputs("error writing stdout\n", stderr);
-        break;
-    case Z_STREAM_ERROR:
-        fputs("invalid compression level\n", stderr);
-        break;
-    case Z_DATA_ERROR:
-        fputs("invalid or incomplete deflate data\n", stderr);
-        break;
-    case Z_MEM_ERROR:
-        fputs("out of memory\n", stderr);
-        break;
-    case Z_VERSION_ERROR:
-        fputs("zlib version mismatch!\n", stderr);
-    }
-}
-</b></pre><!-- -->
-Here is the <tt>main()</tt> routine used to test <tt>def()</tt> and <tt>inf()</tt>.  The
-<tt>zpipe</tt> command is simply a compression pipe from <tt>stdin</tt> to <tt>stdout</tt>, if
-no arguments are given, or it is a decompression pipe if <tt>zpipe -d</tt> is used.  If any other
-arguments are provided, no compression or decompression is performed.  Instead a usage
-message is displayed.  Examples are <tt>zpipe < foo.txt > foo.txt.z</tt> to compress, and
-<tt>zpipe -d < foo.txt.z > foo.txt</tt> to decompress.
-<pre><b>
-/* compress or decompress from stdin to stdout */
-int main(int argc, char **argv)
-{
-    int ret;
-
-    /* do compression if no arguments */
-    if (argc == 1) {
-        ret = def(stdin, stdout, Z_DEFAULT_COMPRESSION);
-        if (ret != Z_OK)
-            zerr(ret);
-        return ret;
-    }
-
-    /* do decompression if -d specified */
-    else if (argc == 2 &amp;&amp; strcmp(argv[1], "-d") == 0) {
-        ret = inf(stdin, stdout);
-        if (ret != Z_OK)
-            zerr(ret);
-        return ret;
-    }
-
-    /* otherwise, report usage */
-    else {
-        fputs("zpipe usage: zpipe [-d] &lt; source &gt; dest\n", stderr);
-        return 1;
-    }
-}
-</b></pre>
-<hr>
-<i>Copyright (c) 2004 by Mark Adler<br>Last modified 13 November 2004</i>
-</body>
-</html>
diff -Nbaur gcc-4.6.3/zlib/examples/zpipe.c gcc-4.6.3-psp/zlib/examples/zpipe.c
--- gcc-4.6.3/zlib/examples/zpipe.c	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/examples/zpipe.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,191 +0,0 @@
-/* zpipe.c: example of proper use of zlib's inflate() and deflate()
-   Not copyrighted -- provided to the public domain
-   Version 1.2  9 November 2004  Mark Adler */
-
-/* Version history:
-   1.0  30 Oct 2004  First version
-   1.1   8 Nov 2004  Add void casting for unused return values
-                     Use switch statement for inflate() return values
-   1.2   9 Nov 2004  Add assertions to document zlib guarantees
-   1.3   6 Apr 2005  Remove incorrect assertion in inf()
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <assert.h>
-#include "zlib.h"
-
-#define CHUNK 16384
-
-/* Compress from file source to file dest until EOF on source.
-   def() returns Z_OK on success, Z_MEM_ERROR if memory could not be
-   allocated for processing, Z_STREAM_ERROR if an invalid compression
-   level is supplied, Z_VERSION_ERROR if the version of zlib.h and the
-   version of the library linked do not match, or Z_ERRNO if there is
-   an error reading or writing the files. */
-int def(FILE *source, FILE *dest, int level)
-{
-    int ret, flush;
-    unsigned have;
-    z_stream strm;
-    char in[CHUNK];
-    char out[CHUNK];
-
-    /* allocate deflate state */
-    strm.zalloc = Z_NULL;
-    strm.zfree = Z_NULL;
-    strm.opaque = Z_NULL;
-    ret = deflateInit(&strm, level);
-    if (ret != Z_OK)
-        return ret;
-
-    /* compress until end of file */
-    do {
-        strm.avail_in = fread(in, 1, CHUNK, source);
-        if (ferror(source)) {
-            (void)deflateEnd(&strm);
-            return Z_ERRNO;
-        }
-        flush = feof(source) ? Z_FINISH : Z_NO_FLUSH;
-        strm.next_in = in;
-
-        /* run deflate() on input until output buffer not full, finish
-           compression if all of source has been read in */
-        do {
-            strm.avail_out = CHUNK;
-            strm.next_out = out;
-            ret = deflate(&strm, flush);    /* no bad return value */
-            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */
-            have = CHUNK - strm.avail_out;
-            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {
-                (void)deflateEnd(&strm);
-                return Z_ERRNO;
-            }
-        } while (strm.avail_out == 0);
-        assert(strm.avail_in == 0);     /* all input will be used */
-
-        /* done when last data in file processed */
-    } while (flush != Z_FINISH);
-    assert(ret == Z_STREAM_END);        /* stream will be complete */
-
-    /* clean up and return */
-    (void)deflateEnd(&strm);
-    return Z_OK;
-}
-
-/* Decompress from file source to file dest until stream ends or EOF.
-   inf() returns Z_OK on success, Z_MEM_ERROR if memory could not be
-   allocated for processing, Z_DATA_ERROR if the deflate data is
-   invalid or incomplete, Z_VERSION_ERROR if the version of zlib.h and
-   the version of the library linked do not match, or Z_ERRNO if there
-   is an error reading or writing the files. */
-int inf(FILE *source, FILE *dest)
-{
-    int ret;
-    unsigned have;
-    z_stream strm;
-    char in[CHUNK];
-    char out[CHUNK];
-
-    /* allocate inflate state */
-    strm.zalloc = Z_NULL;
-    strm.zfree = Z_NULL;
-    strm.opaque = Z_NULL;
-    strm.avail_in = 0;
-    strm.next_in = Z_NULL;
-    ret = inflateInit(&strm);
-    if (ret != Z_OK)
-        return ret;
-
-    /* decompress until deflate stream ends or end of file */
-    do {
-        strm.avail_in = fread(in, 1, CHUNK, source);
-        if (ferror(source)) {
-            (void)inflateEnd(&strm);
-            return Z_ERRNO;
-        }
-        if (strm.avail_in == 0)
-            break;
-        strm.next_in = in;
-
-        /* run inflate() on input until output buffer not full */
-        do {
-            strm.avail_out = CHUNK;
-            strm.next_out = out;
-            ret = inflate(&strm, Z_NO_FLUSH);
-            assert(ret != Z_STREAM_ERROR);  /* state not clobbered */
-            switch (ret) {
-            case Z_NEED_DICT:
-                ret = Z_DATA_ERROR;     /* and fall through */
-            case Z_DATA_ERROR:
-            case Z_MEM_ERROR:
-                (void)inflateEnd(&strm);
-                return ret;
-            }
-            have = CHUNK - strm.avail_out;
-            if (fwrite(out, 1, have, dest) != have || ferror(dest)) {
-                (void)inflateEnd(&strm);
-                return Z_ERRNO;
-            }
-        } while (strm.avail_out == 0);
-
-        /* done when inflate() says it's done */
-    } while (ret != Z_STREAM_END);
-
-    /* clean up and return */
-    (void)inflateEnd(&strm);
-    return ret == Z_STREAM_END ? Z_OK : Z_DATA_ERROR;
-}
-
-/* report a zlib or i/o error */
-void zerr(int ret)
-{
-    fputs("zpipe: ", stderr);
-    switch (ret) {
-    case Z_ERRNO:
-        if (ferror(stdin))
-            fputs("error reading stdin\n", stderr);
-        if (ferror(stdout))
-            fputs("error writing stdout\n", stderr);
-        break;
-    case Z_STREAM_ERROR:
-        fputs("invalid compression level\n", stderr);
-        break;
-    case Z_DATA_ERROR:
-        fputs("invalid or incomplete deflate data\n", stderr);
-        break;
-    case Z_MEM_ERROR:
-        fputs("out of memory\n", stderr);
-        break;
-    case Z_VERSION_ERROR:
-        fputs("zlib version mismatch!\n", stderr);
-    }
-}
-
-/* compress or decompress from stdin to stdout */
-int main(int argc, char **argv)
-{
-    int ret;
-
-    /* do compression if no arguments */
-    if (argc == 1) {
-        ret = def(stdin, stdout, Z_DEFAULT_COMPRESSION);
-        if (ret != Z_OK)
-            zerr(ret);
-        return ret;
-    }
-
-    /* do decompression if -d specified */
-    else if (argc == 2 && strcmp(argv[1], "-d") == 0) {
-        ret = inf(stdin, stdout);
-        if (ret != Z_OK)
-            zerr(ret);
-        return ret;
-    }
-
-    /* otherwise, report usage */
-    else {
-        fputs("zpipe usage: zpipe [-d] < source > dest\n", stderr);
-        return 1;
-    }
-}
diff -Nbaur gcc-4.6.3/zlib/examples/zran.c gcc-4.6.3-psp/zlib/examples/zran.c
--- gcc-4.6.3/zlib/examples/zran.c	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/examples/zran.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,404 +0,0 @@
-/* zran.c -- example of zlib/gzip stream indexing and random access
- * Copyright (C) 2005 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
-   Version 1.0  29 May 2005  Mark Adler */
-
-/* Illustrate the use of Z_BLOCK, inflatePrime(), and inflateSetDictionary()
-   for random access of a compressed file.  A file containing a zlib or gzip
-   stream is provided on the command line.  The compressed stream is decoded in
-   its entirety, and an index built with access points about every SPAN bytes
-   in the uncompressed output.  The compressed file is left open, and can then
-   be read randomly, having to decompress on the average SPAN/2 uncompressed
-   bytes before getting to the desired block of data.
-
-   An access point can be created at the start of any deflate block, by saving
-   the starting file offset and bit of that block, and the 32K bytes of
-   uncompressed data that precede that block.  Also the uncompressed offset of
-   that block is saved to provide a referece for locating a desired starting
-   point in the uncompressed stream.  build_index() works by decompressing the
-   input zlib or gzip stream a block at a time, and at the end of each block
-   deciding if enough uncompressed data has gone by to justify the creation of
-   a new access point.  If so, that point is saved in a data structure that
-   grows as needed to accommodate the points.
-
-   To use the index, an offset in the uncompressed data is provided, for which
-   the latest accees point at or preceding that offset is located in the index.
-   The input file is positioned to the specified location in the index, and if
-   necessary the first few bits of the compressed data is read from the file.
-   inflate is initialized with those bits and the 32K of uncompressed data, and
-   the decompression then proceeds until the desired offset in the file is
-   reached.  Then the decompression continues to read the desired uncompressed
-   data from the file.
-
-   Another approach would be to generate the index on demand.  In that case,
-   requests for random access reads from the compressed data would try to use
-   the index, but if a read far enough past the end of the index is required,
-   then further index entries would be generated and added.
-
-   There is some fair bit of overhead to starting inflation for the random
-   access, mainly copying the 32K byte dictionary.  So if small pieces of the
-   file are being accessed, it would make sense to implement a cache to hold
-   some lookahead and avoid many calls to extract() for small lengths.
-
-   Another way to build an index would be to use inflateCopy().  That would
-   not be constrained to have access points at block boundaries, but requires
-   more memory per access point, and also cannot be saved to file due to the
-   use of pointers in the state.  The approach here allows for storage of the
-   index in a file.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "zlib.h"
-
-#define local static
-
-#define SPAN 1048576L       /* desired distance between access points */
-#define WINSIZE 32768U      /* sliding window size */
-#define CHUNK 16384         /* file input buffer size */
-
-/* access point entry */
-struct point {
-    off_t out;          /* corresponding offset in uncompressed data */
-    off_t in;           /* offset in input file of first full byte */
-    int bits;           /* number of bits (1-7) from byte at in - 1, or 0 */
-    unsigned char window[WINSIZE];  /* preceding 32K of uncompressed data */
-};
-
-/* access point list */
-struct access {
-    int have;           /* number of list entries filled in */
-    int size;           /* number of list entries allocated */
-    struct point *list; /* allocated list */
-};
-
-/* Deallocate an index built by build_index() */
-local void free_index(struct access *index)
-{
-    if (index != NULL) {
-        free(index->list);
-        free(index);
-    }
-}
-
-/* Add an entry to the access point list.  If out of memory, deallocate the
-   existing list and return NULL. */
-local struct access *addpoint(struct access *index, int bits,
-    off_t in, off_t out, unsigned left, unsigned char *window)
-{
-    struct point *next;
-
-    /* if list is empty, create it (start with eight points) */
-    if (index == NULL) {
-        index = malloc(sizeof(struct access));
-        if (index == NULL) return NULL;
-        index->list = malloc(sizeof(struct point) << 3);
-        if (index->list == NULL) {
-            free(index);
-            return NULL;
-        }
-        index->size = 8;
-        index->have = 0;
-    }
-
-    /* if list is full, make it bigger */
-    else if (index->have == index->size) {
-        index->size <<= 1;
-        next = realloc(index->list, sizeof(struct point) * index->size);
-        if (next == NULL) {
-            free_index(index);
-            return NULL;
-        }
-        index->list = next;
-    }
-
-    /* fill in entry and increment how many we have */
-    next = index->list + index->have;
-    next->bits = bits;
-    next->in = in;
-    next->out = out;
-    if (left)
-        memcpy(next->window, window + WINSIZE - left, left);
-    if (left < WINSIZE)
-        memcpy(next->window + left, window, WINSIZE - left);
-    index->have++;
-
-    /* return list, possibly reallocated */
-    return index;
-}
-
-/* Make one entire pass through the compressed stream and build an index, with
-   access points about every span bytes of uncompressed output -- span is
-   chosen to balance the speed of random access against the memory requirements
-   of the list, about 32K bytes per access point.  Note that data after the end
-   of the first zlib or gzip stream in the file is ignored.  build_index()
-   returns the number of access points on success (>= 1), Z_MEM_ERROR for out
-   of memory, Z_DATA_ERROR for an error in the input file, or Z_ERRNO for a
-   file read error.  On success, *built points to the resulting index. */
-local int build_index(FILE *in, off_t span, struct access **built)
-{
-    int ret;
-    off_t totin, totout;        /* our own total counters to avoid 4GB limit */
-    off_t last;                 /* totout value of last access point */
-    struct access *index;       /* access points being generated */
-    z_stream strm;
-    unsigned char input[CHUNK];
-    unsigned char window[WINSIZE];
-
-    /* initialize inflate */
-    strm.zalloc = Z_NULL;
-    strm.zfree = Z_NULL;
-    strm.opaque = Z_NULL;
-    strm.avail_in = 0;
-    strm.next_in = Z_NULL;
-    ret = inflateInit2(&strm, 47);      /* automatic zlib or gzip decoding */
-    if (ret != Z_OK)
-        return ret;
-
-    /* inflate the input, maintain a sliding window, and build an index -- this
-       also validates the integrity of the compressed data using the check
-       information at the end of the gzip or zlib stream */
-    totin = totout = last = 0;
-    index = NULL;               /* will be allocated by first addpoint() */
-    strm.avail_out = 0;
-    do {
-        /* get some compressed data from input file */
-        strm.avail_in = fread(input, 1, CHUNK, in);
-        if (ferror(in)) {
-            ret = Z_ERRNO;
-            goto build_index_error;
-        }
-        if (strm.avail_in == 0) {
-            ret = Z_DATA_ERROR;
-            goto build_index_error;
-        }
-        strm.next_in = input;
-
-        /* process all of that, or until end of stream */
-        do {
-            /* reset sliding window if necessary */
-            if (strm.avail_out == 0) {
-                strm.avail_out = WINSIZE;
-                strm.next_out = window;
-            }
-
-            /* inflate until out of input, output, or at end of block --
-               update the total input and output counters */
-            totin += strm.avail_in;
-            totout += strm.avail_out;
-            ret = inflate(&strm, Z_BLOCK);      /* return at end of block */
-            totin -= strm.avail_in;
-            totout -= strm.avail_out;
-            if (ret == Z_NEED_DICT)
-                ret = Z_DATA_ERROR;
-            if (ret == Z_MEM_ERROR || ret == Z_DATA_ERROR)
-                goto build_index_error;
-            if (ret == Z_STREAM_END)
-                break;
-
-            /* if at end of block, consider adding an index entry (note that if
-               data_type indicates an end-of-block, then all of the
-               uncompressed data from that block has been delivered, and none
-               of the compressed data after that block has been consumed,
-               except for up to seven bits) -- the totout == 0 provides an
-               entry point after the zlib or gzip header, and assures that the
-               index always has at least one access point; we avoid creating an
-               access point after the last block by checking bit 6 of data_type
-             */
-            if ((strm.data_type & 128) && !(strm.data_type & 64) &&
-                (totout == 0 || totout - last > span)) {
-                index = addpoint(index, strm.data_type & 7, totin,
-                                 totout, strm.avail_out, window);
-                if (index == NULL) {
-                    ret = Z_MEM_ERROR;
-                    goto build_index_error;
-                }
-                last = totout;
-            }
-        } while (strm.avail_in != 0);
-    } while (ret != Z_STREAM_END);
-
-    /* clean up and return index (release unused entries in list) */
-    (void)inflateEnd(&strm);
-    index = realloc(index, sizeof(struct point) * index->have);
-    index->size = index->have;
-    *built = index;
-    return index->size;
-
-    /* return error */
-  build_index_error:
-    (void)inflateEnd(&strm);
-    if (index != NULL)
-        free_index(index);
-    return ret;
-}
-
-/* Use the index to read len bytes from offset into buf, return bytes read or
-   negative for error (Z_DATA_ERROR or Z_MEM_ERROR).  If data is requested past
-   the end of the uncompressed data, then extract() will return a value less
-   than len, indicating how much as actually read into buf.  This function
-   should not return a data error unless the file was modified since the index
-   was generated.  extract() may also return Z_ERRNO if there is an error on
-   reading or seeking the input file. */
-local int extract(FILE *in, struct access *index, off_t offset,
-                  unsigned char *buf, int len)
-{
-    int ret, skip;
-    z_stream strm;
-    struct point *here;
-    unsigned char input[CHUNK];
-    unsigned char discard[WINSIZE];
-
-    /* proceed only if something reasonable to do */
-    if (len < 0)
-        return 0;
-
-    /* find where in stream to start */
-    here = index->list;
-    ret = index->have;
-    while (--ret && here[1].out <= offset)
-        here++;
-
-    /* initialize file and inflate state to start there */
-    strm.zalloc = Z_NULL;
-    strm.zfree = Z_NULL;
-    strm.opaque = Z_NULL;
-    strm.avail_in = 0;
-    strm.next_in = Z_NULL;
-    ret = inflateInit2(&strm, -15);         /* raw inflate */
-    if (ret != Z_OK)
-        return ret;
-    ret = fseeko(in, here->in - (here->bits ? 1 : 0), SEEK_SET);
-    if (ret == -1)
-        goto extract_ret;
-    if (here->bits) {
-        ret = getc(in);
-        if (ret == -1) {
-            ret = ferror(in) ? Z_ERRNO : Z_DATA_ERROR;
-            goto extract_ret;
-        }
-        (void)inflatePrime(&strm, here->bits, ret >> (8 - here->bits));
-    }
-    (void)inflateSetDictionary(&strm, here->window, WINSIZE);
-
-    /* skip uncompressed bytes until offset reached, then satisfy request */
-    offset -= here->out;
-    strm.avail_in = 0;
-    skip = 1;                               /* while skipping to offset */
-    do {
-        /* define where to put uncompressed data, and how much */
-        if (offset == 0 && skip) {          /* at offset now */
-            strm.avail_out = len;
-            strm.next_out = buf;
-            skip = 0;                       /* only do this once */
-        }
-        if (offset > WINSIZE) {             /* skip WINSIZE bytes */
-            strm.avail_out = WINSIZE;
-            strm.next_out = discard;
-            offset -= WINSIZE;
-        }
-        else if (offset != 0) {             /* last skip */
-            strm.avail_out = (unsigned)offset;
-            strm.next_out = discard;
-            offset = 0;
-        }
-
-        /* uncompress until avail_out filled, or end of stream */
-        do {
-            if (strm.avail_in == 0) {
-                strm.avail_in = fread(input, 1, CHUNK, in);
-                if (ferror(in)) {
-                    ret = Z_ERRNO;
-                    goto extract_ret;
-                }
-                if (strm.avail_in == 0) {
-                    ret = Z_DATA_ERROR;
-                    goto extract_ret;
-                }
-                strm.next_in = input;
-            }
-            ret = inflate(&strm, Z_NO_FLUSH);       /* normal inflate */
-            if (ret == Z_NEED_DICT)
-                ret = Z_DATA_ERROR;
-            if (ret == Z_MEM_ERROR || ret == Z_DATA_ERROR)
-                goto extract_ret;
-            if (ret == Z_STREAM_END)
-                break;
-        } while (strm.avail_out != 0);
-
-        /* if reach end of stream, then don't keep trying to get more */
-        if (ret == Z_STREAM_END)
-            break;
-
-        /* do until offset reached and requested data read, or stream ends */
-    } while (skip);
-
-    /* compute number of uncompressed bytes read after offset */
-    ret = skip ? 0 : len - strm.avail_out;
-
-    /* clean up and return bytes read or error */
-  extract_ret:
-    (void)inflateEnd(&strm);
-    return ret;
-}
-
-/* Demonstrate the use of build_index() and extract() by processing the file
-   provided on the command line, and the extracting 16K from about 2/3rds of
-   the way through the uncompressed output, and writing that to stdout. */
-int main(int argc, char **argv)
-{
-    int len;
-    off_t offset;
-    FILE *in;
-    struct access *index;
-    unsigned char buf[CHUNK];
-
-    /* open input file */
-    if (argc != 2) {
-        fprintf(stderr, "usage: zran file.gz\n");
-        return 1;
-    }
-    in = fopen(argv[1], "rb");
-    if (in == NULL) {
-        fprintf(stderr, "zran: could not open %s for reading\n", argv[1]);
-        return 1;
-    }
-
-    /* build index */
-    len = build_index(in, SPAN, &index);
-    if (len < 0) {
-        fclose(in);
-        switch (len) {
-        case Z_MEM_ERROR:
-            fprintf(stderr, "zran: out of memory\n");
-            break;
-        case Z_DATA_ERROR:
-            fprintf(stderr, "zran: compressed data error in %s\n", argv[1]);
-            break;
-        case Z_ERRNO:
-            fprintf(stderr, "zran: read error on %s\n", argv[1]);
-            break;
-        default:
-            fprintf(stderr, "zran: error %d while building index\n", len);
-        }
-        return 1;
-    }
-    fprintf(stderr, "zran: built index with %d access points\n", len);
-
-    /* use index by reading some bytes from an arbitrary offset */
-    offset = (index->list[index->have - 1].out << 1) / 3;
-    len = extract(in, index, offset, buf, CHUNK);
-    if (len < 0)
-        fprintf(stderr, "zran: extraction failed: %s error\n",
-                len == Z_MEM_ERROR ? "out of memory" : "input corrupted");
-    else {
-        fwrite(buf, 1, len, stdout);
-        fprintf(stderr, "zran: extracted %d bytes at %llu\n", len, offset);
-    }
-
-    /* clean up and exit */
-    free_index(index);
-    fclose(in);
-    return 0;
-}
diff -Nbaur gcc-4.6.3/zlib/FAQ gcc-4.6.3-psp/zlib/FAQ
--- gcc-4.6.3/zlib/FAQ	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/FAQ	1970-01-01 01:00:00.000000000 +0100
@@ -1,339 +0,0 @@
-
-                Frequently Asked Questions about zlib
-
-
-If your question is not there, please check the zlib home page
-http://www.zlib.org which may have more recent information.
-The lastest zlib FAQ is at http://www.gzip.org/zlib/zlib_faq.html
-
-
- 1. Is zlib Y2K-compliant?
-
-    Yes. zlib doesn't handle dates.
-
- 2. Where can I get a Windows DLL version?
-
-    The zlib sources can be compiled without change to produce a DLL.
-    See the file win32/DLL_FAQ.txt in the zlib distribution.
-    Pointers to the precompiled DLL are found in the zlib web site at
-    http://www.zlib.org.
-
- 3. Where can I get a Visual Basic interface to zlib?
-
-    See
-        * http://www.dogma.net/markn/articles/zlibtool/zlibtool.htm
-        * contrib/visual-basic.txt in the zlib distribution
-        * win32/DLL_FAQ.txt in the zlib distribution
-
- 4. compress() returns Z_BUF_ERROR.
-
-    Make sure that before the call of compress, the length of the compressed
-    buffer is equal to the total size of the compressed buffer and not
-    zero. For Visual Basic, check that this parameter is passed by reference
-    ("as any"), not by value ("as long").
-
- 5. deflate() or inflate() returns Z_BUF_ERROR.
-
-    Before making the call, make sure that avail_in and avail_out are not
-    zero. When setting the parameter flush equal to Z_FINISH, also make sure
-    that avail_out is big enough to allow processing all pending input.
-    Note that a Z_BUF_ERROR is not fatal--another call to deflate() or
-    inflate() can be made with more input or output space. A Z_BUF_ERROR
-    may in fact be unavoidable depending on how the functions are used, since
-    it is not possible to tell whether or not there is more output pending
-    when strm.avail_out returns with zero.
-
- 6. Where's the zlib documentation (man pages, etc.)?
-
-    It's in zlib.h for the moment, and Francis S. Lin has converted it to a
-    web page zlib.html. Volunteers to transform this to Unix-style man pages,
-    please contact us (zlib@gzip.org). Examples of zlib usage are in the files
-    example.c and minigzip.c.
-
- 7. Why don't you use GNU autoconf or libtool or ...?
-
-    Because we would like to keep zlib as a very small and simple
-    package. zlib is rather portable and doesn't need much configuration.
-
- 8. I found a bug in zlib.
-
-    Most of the time, such problems are due to an incorrect usage of
-    zlib. Please try to reproduce the problem with a small program and send
-    the corresponding source to us at zlib@gzip.org . Do not send
-    multi-megabyte data files without prior agreement.
-
- 9. Why do I get "undefined reference to gzputc"?
-
-    If "make test" produces something like
-
-       example.o(.text+0x154): undefined reference to `gzputc'
-
-    check that you don't have old files libz.* in /usr/lib, /usr/local/lib or
-    /usr/X11R6/lib. Remove any old versions, then do "make install".
-
-10. I need a Delphi interface to zlib.
-
-    See the contrib/delphi directory in the zlib distribution.
-
-11. Can zlib handle .zip archives?
-
-    Not by itself, no.  See the directory contrib/minizip in the zlib
-    distribution.
-
-12. Can zlib handle .Z files?
-
-    No, sorry. You have to spawn an uncompress or gunzip subprocess, or adapt
-    the code of uncompress on your own.
-
-13. How can I make a Unix shared library?
-
-    make clean
-    ./configure -s
-    make
-
-14. How do I install a shared zlib library on Unix?
-
-    After the above, then:
-
-    make install
-
-    However, many flavors of Unix come with a shared zlib already installed.
-    Before going to the trouble of compiling a shared version of zlib and
-    trying to install it, you may want to check if it's already there! If you
-    can #include <zlib.h>, it's there. The -lz option will probably link to it.
-
-15. I have a question about OttoPDF.
-
-    We are not the authors of OttoPDF. The real author is on the OttoPDF web
-    site: Joel Hainley, jhainley@myndkryme.com.
-
-16. Can zlib decode Flate data in an Adobe PDF file?
-
-    Yes. See http://www.fastio.com/ (ClibPDF), or http://www.pdflib.com/ .
-    To modify PDF forms, see http://sourceforge.net/projects/acroformtool/ .
-
-17. Why am I getting this "register_frame_info not found" error on Solaris?
-
-    After installing zlib 1.1.4 on Solaris 2.6, running applications using zlib
-    generates an error such as:
-
-        ld.so.1: rpm: fatal: relocation error: file /usr/local/lib/libz.so:
-        symbol __register_frame_info: referenced symbol not found
-
-    The symbol __register_frame_info is not part of zlib, it is generated by
-    the C compiler (cc or gcc). You must recompile applications using zlib
-    which have this problem. This problem is specific to Solaris. See
-    http://www.sunfreeware.com for Solaris versions of zlib and applications
-    using zlib.
-
-18. Why does gzip give an error on a file I make with compress/deflate?
-
-    The compress and deflate functions produce data in the zlib format, which
-    is different and incompatible with the gzip format. The gz* functions in
-    zlib on the other hand use the gzip format. Both the zlib and gzip
-    formats use the same compressed data format internally, but have different
-    headers and trailers around the compressed data.
-
-19. Ok, so why are there two different formats?
-
-    The gzip format was designed to retain the directory information about
-    a single file, such as the name and last modification date. The zlib
-    format on the other hand was designed for in-memory and communication
-    channel applications, and has a much more compact header and trailer and
-    uses a faster integrity check than gzip.
-
-20. Well that's nice, but how do I make a gzip file in memory?
-
-    You can request that deflate write the gzip format instead of the zlib
-    format using deflateInit2(). You can also request that inflate decode
-    the gzip format using inflateInit2(). Read zlib.h for more details.
-
-21. Is zlib thread-safe?
-
-    Yes. However any library routines that zlib uses and any application-
-    provided memory allocation routines must also be thread-safe. zlib's gz*
-    functions use stdio library routines, and most of zlib's functions use the
-    library memory allocation routines by default. zlib's Init functions allow
-    for the application to provide custom memory allocation routines.
-
-    Of course, you should only operate on any given zlib or gzip stream from a
-    single thread at a time.
-
-22. Can I use zlib in my commercial application?
-
-    Yes. Please read the license in zlib.h.
-
-23. Is zlib under the GNU license?
-
-    No. Please read the license in zlib.h.
-
-24. The license says that altered source versions must be "plainly marked". So
-    what exactly do I need to do to meet that requirement?
-
-    You need to change the ZLIB_VERSION and ZLIB_VERNUM #defines in zlib.h. In
-    particular, the final version number needs to be changed to "f", and an
-    identification string should be appended to ZLIB_VERSION. Version numbers
-    x.x.x.f are reserved for modifications to zlib by others than the zlib
-    maintainers. For example, if the version of the base zlib you are altering
-    is "1.2.3.4", then in zlib.h you should change ZLIB_VERNUM to 0x123f, and
-    ZLIB_VERSION to something like "1.2.3.f-zachary-mods-v3". You can also
-    update the version strings in deflate.c and inftrees.c.
-
-    For altered source distributions, you should also note the origin and
-    nature of the changes in zlib.h, as well as in ChangeLog and README, along
-    with the dates of the alterations. The origin should include at least your
-    name (or your company's name), and an email address to contact for help or
-    issues with the library.
-
-    Note that distributing a compiled zlib library along with zlib.h and
-    zconf.h is also a source distribution, and so you should change
-    ZLIB_VERSION and ZLIB_VERNUM and note the origin and nature of the changes
-    in zlib.h as you would for a full source distribution.
-
-25. Will zlib work on a big-endian or little-endian architecture, and can I
-    exchange compressed data between them?
-
-    Yes and yes.
-
-26. Will zlib work on a 64-bit machine?
-
-    It should. It has been tested on 64-bit machines, and has no dependence
-    on any data types being limited to 32-bits in length. If you have any
-    difficulties, please provide a complete problem report to zlib@gzip.org
-
-27. Will zlib decompress data from the PKWare Data Compression Library?
-
-    No. The PKWare DCL uses a completely different compressed data format
-    than does PKZIP and zlib. However, you can look in zlib's contrib/blast
-    directory for a possible solution to your problem.
-
-28. Can I access data randomly in a compressed stream?
-
-    No, not without some preparation. If when compressing you periodically
-    use Z_FULL_FLUSH, carefully write all the pending data at those points,
-    and keep an index of those locations, then you can start decompression
-    at those points. You have to be careful to not use Z_FULL_FLUSH too
-    often, since it can significantly degrade compression.
-
-29. Does zlib work on MVS, OS/390, CICS, etc.?
-
-    We don't know for sure. We have heard occasional reports of success on
-    these systems. If you do use it on one of these, please provide us with
-    a report, instructions, and patches that we can reference when we get
-    these questions. Thanks.
-
-30. Is there some simpler, easier to read version of inflate I can look at
-    to understand the deflate format?
-
-    First off, you should read RFC 1951. Second, yes. Look in zlib's
-    contrib/puff directory.
-
-31. Does zlib infringe on any patents?
-
-    As far as we know, no. In fact, that was originally the whole point behind
-    zlib. Look here for some more information:
-
-    http://www.gzip.org/#faq11
-
-32. Can zlib work with greater than 4 GB of data?
-
-    Yes. inflate() and deflate() will process any amount of data correctly.
-    Each call of inflate() or deflate() is limited to input and output chunks
-    of the maximum value that can be stored in the compiler's "unsigned int"
-    type, but there is no limit to the number of chunks. Note however that the
-    strm.total_in and strm_total_out counters may be limited to 4 GB. These
-    counters are provided as a convenience and are not used internally by
-    inflate() or deflate(). The application can easily set up its own counters
-    updated after each call of inflate() or deflate() to count beyond 4 GB.
-    compress() and uncompress() may be limited to 4 GB, since they operate in a
-    single call. gzseek() and gztell() may be limited to 4 GB depending on how
-    zlib is compiled. See the zlibCompileFlags() function in zlib.h.
-
-    The word "may" appears several times above since there is a 4 GB limit
-    only if the compiler's "long" type is 32 bits. If the compiler's "long"
-    type is 64 bits, then the limit is 16 exabytes.
-
-33. Does zlib have any security vulnerabilities?
-
-    The only one that we are aware of is potentially in gzprintf(). If zlib
-    is compiled to use sprintf() or vsprintf(), then there is no protection
-    against a buffer overflow of a 4K string space, other than the caller of
-    gzprintf() assuring that the output will not exceed 4K. On the other
-    hand, if zlib is compiled to use snprintf() or vsnprintf(), which should
-    normally be the case, then there is no vulnerability. The ./configure
-    script will display warnings if an insecure variation of sprintf() will
-    be used by gzprintf(). Also the zlibCompileFlags() function will return
-    information on what variant of sprintf() is used by gzprintf().
-
-    If you don't have snprintf() or vsnprintf() and would like one, you can
-    find a portable implementation here:
-
-        http://www.ijs.si/software/snprintf/
-
-    Note that you should be using the most recent version of zlib. Versions
-    1.1.3 and before were subject to a double-free vulnerability.
-
-34. Is there a Java version of zlib?
-
-    Probably what you want is to use zlib in Java. zlib is already included
-    as part of the Java SDK in the java.util.zip package. If you really want
-    a version of zlib written in the Java language, look on the zlib home
-    page for links: http://www.zlib.org/
-
-35. I get this or that compiler or source-code scanner warning when I crank it
-    up to maximally-pedantic. Can't you guys write proper code?
-
-    Many years ago, we gave up attempting to avoid warnings on every compiler
-    in the universe. It just got to be a waste of time, and some compilers
-    were downright silly. So now, we simply make sure that the code always
-    works.
-
-36. Valgrind (or some similar memory access checker) says that deflate is
-    performing a conditional jump that depends on an uninitialized value.
-    Isn't that a bug?
-
-    No.  That is intentional for performance reasons, and the output of
-    deflate is not affected.  This only started showing up recently since
-    zlib 1.2.x uses malloc() by default for allocations, whereas earlier
-    versions used calloc(), which zeros out the allocated memory.
-
-37. Will zlib read the (insert any ancient or arcane format here) compressed
-    data format?
-
-    Probably not. Look in the comp.compression FAQ for pointers to various
-    formats and associated software.
-
-38. How can I encrypt/decrypt zip files with zlib?
-
-    zlib doesn't support encryption. The original PKZIP encryption is very weak
-    and can be broken with freely available programs. To get strong encryption,
-    use GnuPG, http://www.gnupg.org/ , which already includes zlib compression.
-    For PKZIP compatible "encryption", look at http://www.info-zip.org/
-
-39. What's the difference between the "gzip" and "deflate" HTTP 1.1 encodings?
-
-    "gzip" is the gzip format, and "deflate" is the zlib format. They should
-    probably have called the second one "zlib" instead to avoid confusion
-    with the raw deflate compressed data format. While the HTTP 1.1 RFC 2616
-    correctly points to the zlib specification in RFC 1950 for the "deflate"
-    transfer encoding, there have been reports of servers and browsers that
-    incorrectly produce or expect raw deflate data per the deflate
-    specficiation in RFC 1951, most notably Microsoft. So even though the
-    "deflate" transfer encoding using the zlib format would be the more
-    efficient approach (and in fact exactly what the zlib format was designed
-    for), using the "gzip" transfer encoding is probably more reliable due to
-    an unfortunate choice of name on the part of the HTTP 1.1 authors.
-
-    Bottom line: use the gzip format for HTTP 1.1 encoding.
-
-40. Does zlib support the new "Deflate64" format introduced by PKWare?
-
-    No. PKWare has apparently decided to keep that format proprietary, since
-    they have not documented it as they have previous compression formats.
-    In any case, the compression improvements are so modest compared to other
-    more modern approaches, that it's not worth the effort to implement.
-
-41. Can you please sign these lengthy legal documents and fax them back to us
-    so that we can use your software in our product?
-
-    No. Go away. Shoo.
diff -Nbaur gcc-4.6.3/zlib/gzio.c gcc-4.6.3-psp/zlib/gzio.c
--- gcc-4.6.3/zlib/gzio.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/gzio.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1026 +0,0 @@
-/* gzio.c -- IO on .gz files
- * Copyright (C) 1995-2005 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * Compile this file with -DNO_GZCOMPRESS to avoid the compression code.
- */
-
-/* @(#) $Id: gzio.c,v 1.1.1.2 2002/03/11 21:53:24 tromey Exp $ */
-
-#include <stdio.h>
-
-#include "zutil.h"
-
-#ifdef NO_DEFLATE       /* for compatibility with old definition */
-#  define NO_GZCOMPRESS
-#endif
-
-#ifndef NO_DUMMY_DECL
-struct internal_state {int dummy;}; /* for buggy compilers */
-#endif
-
-#ifndef Z_BUFSIZE
-#  ifdef MAXSEG_64K
-#    define Z_BUFSIZE 4096 /* minimize memory usage for 16-bit DOS */
-#  else
-#    define Z_BUFSIZE 16384
-#  endif
-#endif
-#ifndef Z_PRINTF_BUFSIZE
-#  define Z_PRINTF_BUFSIZE 4096
-#endif
-
-#ifdef __MVS__
-#  pragma map (fdopen , "\174\174FDOPEN")
-   FILE *fdopen(int, const char *);
-#endif
-
-#ifndef STDC
-extern voidp  malloc OF((uInt size));
-extern void   free   OF((voidpf ptr));
-#endif
-
-#define ALLOC(size) malloc(size)
-#define TRYFREE(p) {if (p) free(p);}
-
-static int const gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */
-
-/* gzip flag byte */
-#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
-#define HEAD_CRC     0x02 /* bit 1 set: header CRC present */
-#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
-#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
-#define COMMENT      0x10 /* bit 4 set: file comment present */
-#define RESERVED     0xE0 /* bits 5..7: reserved */
-
-typedef struct gz_stream {
-    z_stream stream;
-    int      z_err;   /* error code for last stream operation */
-    int      z_eof;   /* set if end of input file */
-    FILE     *file;   /* .gz file */
-    Byte     *inbuf;  /* input buffer */
-    Byte     *outbuf; /* output buffer */
-    uLong    crc;     /* crc32 of uncompressed data */
-    char     *msg;    /* error message */
-    char     *path;   /* path name for debugging only */
-    int      transparent; /* 1 if input file is not a .gz file */
-    char     mode;    /* 'w' or 'r' */
-    z_off_t  start;   /* start of compressed data in file (header skipped) */
-    z_off_t  in;      /* bytes into deflate or inflate */
-    z_off_t  out;     /* bytes out of deflate or inflate */
-    int      back;    /* one character push-back */
-    int      last;    /* true if push-back is last character */
-} gz_stream;
-
-
-local gzFile gz_open      OF((const char *path, const char *mode, int  fd));
-local int do_flush        OF((gzFile file, int flush));
-local int    get_byte     OF((gz_stream *s));
-local void   check_header OF((gz_stream *s));
-local int    destroy      OF((gz_stream *s));
-local void   putLong      OF((FILE *file, uLong x));
-local uLong  getLong      OF((gz_stream *s));
-
-/* ===========================================================================
-     Opens a gzip (.gz) file for reading or writing. The mode parameter
-   is as in fopen ("rb" or "wb"). The file is given either by file descriptor
-   or path name (if fd == -1).
-     gz_open returns NULL if the file could not be opened or if there was
-   insufficient memory to allocate the (de)compression state; errno
-   can be checked to distinguish the two cases (if errno is zero, the
-   zlib error is Z_MEM_ERROR).
-*/
-local gzFile gz_open (path, mode, fd)
-    const char *path;
-    const char *mode;
-    int  fd;
-{
-    int err;
-    int level = Z_DEFAULT_COMPRESSION; /* compression level */
-    int strategy = Z_DEFAULT_STRATEGY; /* compression strategy */
-    char *p = (char*)mode;
-    gz_stream *s;
-    char fmode[80]; /* copy of mode, without the compression level */
-    char *m = fmode;
-
-    if (!path || !mode) return Z_NULL;
-
-    s = (gz_stream *)ALLOC(sizeof(gz_stream));
-    if (!s) return Z_NULL;
-
-    s->stream.zalloc = (alloc_func)0;
-    s->stream.zfree = (free_func)0;
-    s->stream.opaque = (voidpf)0;
-    s->stream.next_in = s->inbuf = Z_NULL;
-    s->stream.next_out = s->outbuf = Z_NULL;
-    s->stream.avail_in = s->stream.avail_out = 0;
-    s->file = NULL;
-    s->z_err = Z_OK;
-    s->z_eof = 0;
-    s->in = 0;
-    s->out = 0;
-    s->back = EOF;
-    s->crc = crc32(0L, Z_NULL, 0);
-    s->msg = NULL;
-    s->transparent = 0;
-
-    s->path = (char*)ALLOC(strlen(path)+1);
-    if (s->path == NULL) {
-        return destroy(s), (gzFile)Z_NULL;
-    }
-    strcpy(s->path, path); /* do this early for debugging */
-
-    s->mode = '\0';
-    do {
-        if (*p == 'r') s->mode = 'r';
-        if (*p == 'w' || *p == 'a') s->mode = 'w';
-        if (*p >= '0' && *p <= '9') {
-            level = *p - '0';
-        } else if (*p == 'f') {
-          strategy = Z_FILTERED;
-        } else if (*p == 'h') {
-          strategy = Z_HUFFMAN_ONLY;
-        } else if (*p == 'R') {
-          strategy = Z_RLE;
-        } else {
-            *m++ = *p; /* copy the mode */
-        }
-    } while (*p++ && m != fmode + sizeof(fmode));
-    if (s->mode == '\0') return destroy(s), (gzFile)Z_NULL;
-
-    if (s->mode == 'w') {
-#ifdef NO_GZCOMPRESS
-        err = Z_STREAM_ERROR;
-#else
-        err = deflateInit2(&(s->stream), level,
-                           Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);
-        /* windowBits is passed < 0 to suppress zlib header */
-
-        s->stream.next_out = s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
-#endif
-        if (err != Z_OK || s->outbuf == Z_NULL) {
-            return destroy(s), (gzFile)Z_NULL;
-        }
-    } else {
-        s->stream.next_in  = s->inbuf = (Byte*)ALLOC(Z_BUFSIZE);
-
-        err = inflateInit2(&(s->stream), -MAX_WBITS);
-        /* windowBits is passed < 0 to tell that there is no zlib header.
-         * Note that in this case inflate *requires* an extra "dummy" byte
-         * after the compressed stream in order to complete decompression and
-         * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are
-         * present after the compressed stream.
-         */
-        if (err != Z_OK || s->inbuf == Z_NULL) {
-            return destroy(s), (gzFile)Z_NULL;
-        }
-    }
-    s->stream.avail_out = Z_BUFSIZE;
-
-    errno = 0;
-    s->file = fd < 0 ? F_OPEN(path, fmode) : (FILE*)fdopen(fd, fmode);
-
-    if (s->file == NULL) {
-        return destroy(s), (gzFile)Z_NULL;
-    }
-    if (s->mode == 'w') {
-        /* Write a very simple .gz header:
-         */
-        fprintf(s->file, "%c%c%c%c%c%c%c%c%c%c", gz_magic[0], gz_magic[1],
-             Z_DEFLATED, 0 /*flags*/, 0,0,0,0 /*time*/, 0 /*xflags*/, OS_CODE);
-        s->start = 10L;
-        /* We use 10L instead of ftell(s->file) to because ftell causes an
-         * fflush on some systems. This version of the library doesn't use
-         * start anyway in write mode, so this initialization is not
-         * necessary.
-         */
-    } else {
-        check_header(s); /* skip the .gz header */
-        s->start = ftell(s->file) - s->stream.avail_in;
-    }
-
-    return (gzFile)s;
-}
-
-/* ===========================================================================
-     Opens a gzip (.gz) file for reading or writing.
-*/
-gzFile ZEXPORT gzopen (path, mode)
-    const char *path;
-    const char *mode;
-{
-    return gz_open (path, mode, -1);
-}
-
-/* ===========================================================================
-     Associate a gzFile with the file descriptor fd. fd is not dup'ed here
-   to mimic the behavio(u)r of fdopen.
-*/
-gzFile ZEXPORT gzdopen (fd, mode)
-    int fd;
-    const char *mode;
-{
-    char name[46];      /* allow for up to 128-bit integers */
-
-    if (fd < 0) return (gzFile)Z_NULL;
-    sprintf(name, "<fd:%d>", fd); /* for debugging */
-
-    return gz_open (name, mode, fd);
-}
-
-/* ===========================================================================
- * Update the compression level and strategy
- */
-int ZEXPORT gzsetparams (file, level, strategy)
-    gzFile file;
-    int level;
-    int strategy;
-{
-    gz_stream *s = (gz_stream*)file;
-
-    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
-
-    /* Make room to allow flushing */
-    if (s->stream.avail_out == 0) {
-
-        s->stream.next_out = s->outbuf;
-        if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
-            s->z_err = Z_ERRNO;
-        }
-        s->stream.avail_out = Z_BUFSIZE;
-    }
-
-    return deflateParams (&(s->stream), level, strategy);
-}
-
-/* ===========================================================================
-     Read a byte from a gz_stream; update next_in and avail_in. Return EOF
-   for end of file.
-   IN assertion: the stream s has been sucessfully opened for reading.
-*/
-local int get_byte(s)
-    gz_stream *s;
-{
-    if (s->z_eof) return EOF;
-    if (s->stream.avail_in == 0) {
-        errno = 0;
-        s->stream.avail_in = (uInt)fread(s->inbuf, 1, Z_BUFSIZE, s->file);
-        if (s->stream.avail_in == 0) {
-            s->z_eof = 1;
-            if (ferror(s->file)) s->z_err = Z_ERRNO;
-            return EOF;
-        }
-        s->stream.next_in = s->inbuf;
-    }
-    s->stream.avail_in--;
-    return *(s->stream.next_in)++;
-}
-
-/* ===========================================================================
-      Check the gzip header of a gz_stream opened for reading. Set the stream
-    mode to transparent if the gzip magic header is not present; set s->err
-    to Z_DATA_ERROR if the magic header is present but the rest of the header
-    is incorrect.
-    IN assertion: the stream s has already been created sucessfully;
-       s->stream.avail_in is zero for the first time, but may be non-zero
-       for concatenated .gz files.
-*/
-local void check_header(s)
-    gz_stream *s;
-{
-    int method; /* method byte */
-    int flags;  /* flags byte */
-    uInt len;
-    int c;
-
-    /* Assure two bytes in the buffer so we can peek ahead -- handle case
-       where first byte of header is at the end of the buffer after the last
-       gzip segment */
-    len = s->stream.avail_in;
-    if (len < 2) {
-        if (len) s->inbuf[0] = s->stream.next_in[0];
-        errno = 0;
-        len = (uInt)fread(s->inbuf + len, 1, Z_BUFSIZE >> len, s->file);
-        if (len == 0 && ferror(s->file)) s->z_err = Z_ERRNO;
-        s->stream.avail_in += len;
-        s->stream.next_in = s->inbuf;
-        if (s->stream.avail_in < 2) {
-            s->transparent = s->stream.avail_in;
-            return;
-        }
-    }
-
-    /* Peek ahead to check the gzip magic header */
-    if (s->stream.next_in[0] != gz_magic[0] ||
-        s->stream.next_in[1] != gz_magic[1]) {
-        s->transparent = 1;
-        return;
-    }
-    s->stream.avail_in -= 2;
-    s->stream.next_in += 2;
-
-    /* Check the rest of the gzip header */
-    method = get_byte(s);
-    flags = get_byte(s);
-    if (method != Z_DEFLATED || (flags & RESERVED) != 0) {
-        s->z_err = Z_DATA_ERROR;
-        return;
-    }
-
-    /* Discard time, xflags and OS code: */
-    for (len = 0; len < 6; len++) (void)get_byte(s);
-
-    if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
-        len  =  (uInt)get_byte(s);
-        len += ((uInt)get_byte(s))<<8;
-        /* len is garbage if EOF but the loop below will quit anyway */
-        while (len-- != 0 && get_byte(s) != EOF) ;
-    }
-    if ((flags & ORIG_NAME) != 0) { /* skip the original file name */
-        while ((c = get_byte(s)) != 0 && c != EOF) ;
-    }
-    if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */
-        while ((c = get_byte(s)) != 0 && c != EOF) ;
-    }
-    if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */
-        for (len = 0; len < 2; len++) (void)get_byte(s);
-    }
-    s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;
-}
-
- /* ===========================================================================
- * Cleanup then free the given gz_stream. Return a zlib error code.
-   Try freeing in the reverse order of allocations.
- */
-local int destroy (s)
-    gz_stream *s;
-{
-    int err = Z_OK;
-
-    if (!s) return Z_STREAM_ERROR;
-
-    TRYFREE(s->msg);
-
-    if (s->stream.state != NULL) {
-        if (s->mode == 'w') {
-#ifdef NO_GZCOMPRESS
-            err = Z_STREAM_ERROR;
-#else
-            err = deflateEnd(&(s->stream));
-#endif
-        } else if (s->mode == 'r') {
-            err = inflateEnd(&(s->stream));
-        }
-    }
-    if (s->file != NULL && fclose(s->file)) {
-#ifdef ESPIPE
-        if (errno != ESPIPE) /* fclose is broken for pipes in HP/UX */
-#endif
-            err = Z_ERRNO;
-    }
-    if (s->z_err < 0) err = s->z_err;
-
-    TRYFREE(s->inbuf);
-    TRYFREE(s->outbuf);
-    TRYFREE(s->path);
-    TRYFREE(s);
-    return err;
-}
-
-/* ===========================================================================
-     Reads the given number of uncompressed bytes from the compressed file.
-   gzread returns the number of bytes actually read (0 for end of file).
-*/
-int ZEXPORT gzread (file, buf, len)
-    gzFile file;
-    voidp buf;
-    unsigned len;
-{
-    gz_stream *s = (gz_stream*)file;
-    Bytef *start = (Bytef*)buf; /* starting point for crc computation */
-    Byte  *next_out; /* == stream.next_out but not forced far (for MSDOS) */
-
-    if (s == NULL || s->mode != 'r') return Z_STREAM_ERROR;
-
-    if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;
-    if (s->z_err == Z_STREAM_END) return 0;  /* EOF */
-
-    next_out = (Byte*)buf;
-    s->stream.next_out = (Bytef*)buf;
-    s->stream.avail_out = len;
-
-    if (s->stream.avail_out && s->back != EOF) {
-        *next_out++ = s->back;
-        s->stream.next_out++;
-        s->stream.avail_out--;
-        s->back = EOF;
-        s->out++;
-        start++;
-        if (s->last) {
-            s->z_err = Z_STREAM_END;
-            return 1;
-        }
-    }
-
-    while (s->stream.avail_out != 0) {
-
-        if (s->transparent) {
-            /* Copy first the lookahead bytes: */
-            uInt n = s->stream.avail_in;
-            if (n > s->stream.avail_out) n = s->stream.avail_out;
-            if (n > 0) {
-                zmemcpy(s->stream.next_out, s->stream.next_in, n);
-                next_out += n;
-                s->stream.next_out = next_out;
-                s->stream.next_in   += n;
-                s->stream.avail_out -= n;
-                s->stream.avail_in  -= n;
-            }
-            if (s->stream.avail_out > 0) {
-                s->stream.avail_out -=
-                    (uInt)fread(next_out, 1, s->stream.avail_out, s->file);
-            }
-            len -= s->stream.avail_out;
-            s->in  += len;
-            s->out += len;
-            if (len == 0) s->z_eof = 1;
-            return (int)len;
-        }
-        if (s->stream.avail_in == 0 && !s->z_eof) {
-
-            errno = 0;
-            s->stream.avail_in = (uInt)fread(s->inbuf, 1, Z_BUFSIZE, s->file);
-            if (s->stream.avail_in == 0) {
-                s->z_eof = 1;
-                if (ferror(s->file)) {
-                    s->z_err = Z_ERRNO;
-                    break;
-                }
-            }
-            s->stream.next_in = s->inbuf;
-        }
-        s->in += s->stream.avail_in;
-        s->out += s->stream.avail_out;
-        s->z_err = inflate(&(s->stream), Z_NO_FLUSH);
-        s->in -= s->stream.avail_in;
-        s->out -= s->stream.avail_out;
-
-        if (s->z_err == Z_STREAM_END) {
-            /* Check CRC and original size */
-            s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));
-            start = s->stream.next_out;
-
-            if (getLong(s) != s->crc) {
-                s->z_err = Z_DATA_ERROR;
-            } else {
-                (void)getLong(s);
-                /* The uncompressed length returned by above getlong() may be
-                 * different from s->out in case of concatenated .gz files.
-                 * Check for such files:
-                 */
-                check_header(s);
-                if (s->z_err == Z_OK) {
-                    inflateReset(&(s->stream));
-                    s->crc = crc32(0L, Z_NULL, 0);
-                }
-            }
-        }
-        if (s->z_err != Z_OK || s->z_eof) break;
-    }
-    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));
-
-    if (len == s->stream.avail_out &&
-        (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO))
-        return -1;
-    return (int)(len - s->stream.avail_out);
-}
-
-
-/* ===========================================================================
-      Reads one byte from the compressed file. gzgetc returns this byte
-   or -1 in case of end of file or error.
-*/
-int ZEXPORT gzgetc(file)
-    gzFile file;
-{
-    unsigned char c;
-
-    return gzread(file, &c, 1) == 1 ? c : -1;
-}
-
-
-/* ===========================================================================
-      Push one byte back onto the stream.
-*/
-int ZEXPORT gzungetc(c, file)
-    int c;
-    gzFile file;
-{
-    gz_stream *s = (gz_stream*)file;
-
-    if (s == NULL || s->mode != 'r' || c == EOF || s->back != EOF) return EOF;
-    s->back = c;
-    s->out--;
-    s->last = (s->z_err == Z_STREAM_END);
-    if (s->last) s->z_err = Z_OK;
-    s->z_eof = 0;
-    return c;
-}
-
-
-/* ===========================================================================
-      Reads bytes from the compressed file until len-1 characters are
-   read, or a newline character is read and transferred to buf, or an
-   end-of-file condition is encountered.  The string is then terminated
-   with a null character.
-      gzgets returns buf, or Z_NULL in case of error.
-
-      The current implementation is not optimized at all.
-*/
-char * ZEXPORT gzgets(file, buf, len)
-    gzFile file;
-    char *buf;
-    int len;
-{
-    char *b = buf;
-    if (buf == Z_NULL || len <= 0) return Z_NULL;
-
-    while (--len > 0 && gzread(file, buf, 1) == 1 && *buf++ != '\n') ;
-    *buf = '\0';
-    return b == buf && len > 0 ? Z_NULL : b;
-}
-
-
-#ifndef NO_GZCOMPRESS
-/* ===========================================================================
-     Writes the given number of uncompressed bytes into the compressed file.
-   gzwrite returns the number of bytes actually written (0 in case of error).
-*/
-int ZEXPORT gzwrite (file, buf, len)
-    gzFile file;
-    voidpc buf;
-    unsigned len;
-{
-    gz_stream *s = (gz_stream*)file;
-
-    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
-
-    s->stream.next_in = (Bytef*)buf;
-    s->stream.avail_in = len;
-
-    while (s->stream.avail_in != 0) {
-
-        if (s->stream.avail_out == 0) {
-
-            s->stream.next_out = s->outbuf;
-            if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
-                s->z_err = Z_ERRNO;
-                break;
-            }
-            s->stream.avail_out = Z_BUFSIZE;
-        }
-        s->in += s->stream.avail_in;
-        s->out += s->stream.avail_out;
-        s->z_err = deflate(&(s->stream), Z_NO_FLUSH);
-        s->in -= s->stream.avail_in;
-        s->out -= s->stream.avail_out;
-        if (s->z_err != Z_OK) break;
-    }
-    s->crc = crc32(s->crc, (const Bytef *)buf, len);
-
-    return (int)(len - s->stream.avail_in);
-}
-
-
-/* ===========================================================================
-     Converts, formats, and writes the args to the compressed file under
-   control of the format string, as in fprintf. gzprintf returns the number of
-   uncompressed bytes actually written (0 in case of error).
-*/
-#ifdef STDC
-#include <stdarg.h>
-
-int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)
-{
-    char buf[Z_PRINTF_BUFSIZE];
-    va_list va;
-    int len;
-
-    buf[sizeof(buf) - 1] = 0;
-    va_start(va, format);
-#ifdef NO_vsnprintf
-#  ifdef HAS_vsprintf_void
-    (void)vsprintf(buf, format, va);
-    va_end(va);
-    for (len = 0; len < sizeof(buf); len++)
-        if (buf[len] == 0) break;
-#  else
-    len = vsprintf(buf, format, va);
-    va_end(va);
-#  endif
-#else
-#  ifdef HAS_vsnprintf_void
-    (void)vsnprintf(buf, sizeof(buf), format, va);
-    va_end(va);
-    len = strlen(buf);
-#  else
-    len = vsnprintf(buf, sizeof(buf), format, va);
-    va_end(va);
-#  endif
-#endif
-    if (len <= 0 || len >= (int)sizeof(buf) || buf[sizeof(buf) - 1] != 0)
-        return 0;
-    return gzwrite(file, buf, (unsigned)len);
-}
-#else /* not ANSI C */
-
-int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
-                       a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
-    gzFile file;
-    const char *format;
-    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
-        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
-{
-    char buf[Z_PRINTF_BUFSIZE];
-    int len;
-
-    buf[sizeof(buf) - 1] = 0;
-#ifdef NO_snprintf
-#  ifdef HAS_sprintf_void
-    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,
-            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
-    for (len = 0; len < sizeof(buf); len++)
-        if (buf[len] == 0) break;
-#  else
-    len = sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,
-                a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
-#  endif
-#else
-#  ifdef HAS_snprintf_void
-    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,
-             a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
-    len = strlen(buf);
-#  else
-    len = snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,
-                 a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
-#  endif
-#endif
-    if (len <= 0 || len >= sizeof(buf) || buf[sizeof(buf) - 1] != 0)
-        return 0;
-    return gzwrite(file, buf, len);
-}
-#endif
-
-/* ===========================================================================
-      Writes c, converted to an unsigned char, into the compressed file.
-   gzputc returns the value that was written, or -1 in case of error.
-*/
-int ZEXPORT gzputc(file, c)
-    gzFile file;
-    int c;
-{
-    unsigned char cc = (unsigned char) c; /* required for big endian systems */
-
-    return gzwrite(file, &cc, 1) == 1 ? (int)cc : -1;
-}
-
-
-/* ===========================================================================
-      Writes the given null-terminated string to the compressed file, excluding
-   the terminating null character.
-      gzputs returns the number of characters written, or -1 in case of error.
-*/
-int ZEXPORT gzputs(file, s)
-    gzFile file;
-    const char *s;
-{
-    return gzwrite(file, (char*)s, (unsigned)strlen(s));
-}
-
-
-/* ===========================================================================
-     Flushes all pending output into the compressed file. The parameter
-   flush is as in the deflate() function.
-*/
-local int do_flush (file, flush)
-    gzFile file;
-    int flush;
-{
-    uInt len;
-    int done = 0;
-    gz_stream *s = (gz_stream*)file;
-
-    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
-
-    s->stream.avail_in = 0; /* should be zero already anyway */
-
-    for (;;) {
-        len = Z_BUFSIZE - s->stream.avail_out;
-
-        if (len != 0) {
-            if ((uInt)fwrite(s->outbuf, 1, len, s->file) != len) {
-                s->z_err = Z_ERRNO;
-                return Z_ERRNO;
-            }
-            s->stream.next_out = s->outbuf;
-            s->stream.avail_out = Z_BUFSIZE;
-        }
-        if (done) break;
-        s->out += s->stream.avail_out;
-        s->z_err = deflate(&(s->stream), flush);
-        s->out -= s->stream.avail_out;
-
-        /* Ignore the second of two consecutive flushes: */
-        if (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;
-
-        /* deflate has finished flushing only when it hasn't used up
-         * all the available space in the output buffer:
-         */
-        done = (s->stream.avail_out != 0 || s->z_err == Z_STREAM_END);
-
-        if (s->z_err != Z_OK && s->z_err != Z_STREAM_END) break;
-    }
-    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
-}
-
-int ZEXPORT gzflush (file, flush)
-     gzFile file;
-     int flush;
-{
-    gz_stream *s = (gz_stream*)file;
-    int err = do_flush (file, flush);
-
-    if (err) return err;
-    fflush(s->file);
-    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
-}
-#endif /* NO_GZCOMPRESS */
-
-/* ===========================================================================
-      Sets the starting position for the next gzread or gzwrite on the given
-   compressed file. The offset represents a number of bytes in the
-      gzseek returns the resulting offset location as measured in bytes from
-   the beginning of the uncompressed stream, or -1 in case of error.
-      SEEK_END is not implemented, returns error.
-      In this version of the library, gzseek can be extremely slow.
-*/
-z_off_t ZEXPORT gzseek (file, offset, whence)
-    gzFile file;
-    z_off_t offset;
-    int whence;
-{
-    gz_stream *s = (gz_stream*)file;
-
-    if (s == NULL || whence == SEEK_END ||
-        s->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {
-        return -1L;
-    }
-
-    if (s->mode == 'w') {
-#ifdef NO_GZCOMPRESS
-        return -1L;
-#else
-        if (whence == SEEK_SET) {
-            offset -= s->in;
-        }
-        if (offset < 0) return -1L;
-
-        /* At this point, offset is the number of zero bytes to write. */
-        if (s->inbuf == Z_NULL) {
-            s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */
-            if (s->inbuf == Z_NULL) return -1L;
-            zmemzero(s->inbuf, Z_BUFSIZE);
-        }
-        while (offset > 0)  {
-            uInt size = Z_BUFSIZE;
-            if (offset < Z_BUFSIZE) size = (uInt)offset;
-
-            size = gzwrite(file, s->inbuf, size);
-            if (size == 0) return -1L;
-
-            offset -= size;
-        }
-        return s->in;
-#endif
-    }
-    /* Rest of function is for reading only */
-
-    /* compute absolute position */
-    if (whence == SEEK_CUR) {
-        offset += s->out;
-    }
-    if (offset < 0) return -1L;
-
-    if (s->transparent) {
-        /* map to fseek */
-        s->back = EOF;
-        s->stream.avail_in = 0;
-        s->stream.next_in = s->inbuf;
-        if (fseek(s->file, offset, SEEK_SET) < 0) return -1L;
-
-        s->in = s->out = offset;
-        return offset;
-    }
-
-    /* For a negative seek, rewind and use positive seek */
-    if (offset >= s->out) {
-        offset -= s->out;
-    } else if (gzrewind(file) < 0) {
-        return -1L;
-    }
-    /* offset is now the number of bytes to skip. */
-
-    if (offset != 0 && s->outbuf == Z_NULL) {
-        s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
-        if (s->outbuf == Z_NULL) return -1L;
-    }
-    if (offset && s->back != EOF) {
-        s->back = EOF;
-        s->out++;
-        offset--;
-        if (s->last) s->z_err = Z_STREAM_END;
-    }
-    while (offset > 0)  {
-        int size = Z_BUFSIZE;
-        if (offset < Z_BUFSIZE) size = (int)offset;
-
-        size = gzread(file, s->outbuf, (uInt)size);
-        if (size <= 0) return -1L;
-        offset -= size;
-    }
-    return s->out;
-}
-
-/* ===========================================================================
-     Rewinds input file.
-*/
-int ZEXPORT gzrewind (file)
-    gzFile file;
-{
-    gz_stream *s = (gz_stream*)file;
-
-    if (s == NULL || s->mode != 'r') return -1;
-
-    s->z_err = Z_OK;
-    s->z_eof = 0;
-    s->back = EOF;
-    s->stream.avail_in = 0;
-    s->stream.next_in = s->inbuf;
-    s->crc = crc32(0L, Z_NULL, 0);
-    if (!s->transparent) (void)inflateReset(&s->stream);
-    s->in = 0;
-    s->out = 0;
-    return fseek(s->file, s->start, SEEK_SET);
-}
-
-/* ===========================================================================
-     Returns the starting position for the next gzread or gzwrite on the
-   given compressed file. This position represents a number of bytes in the
-   uncompressed data stream.
-*/
-z_off_t ZEXPORT gztell (file)
-    gzFile file;
-{
-    return gzseek(file, 0L, SEEK_CUR);
-}
-
-/* ===========================================================================
-     Returns 1 when EOF has previously been detected reading the given
-   input stream, otherwise zero.
-*/
-int ZEXPORT gzeof (file)
-    gzFile file;
-{
-    gz_stream *s = (gz_stream*)file;
-
-    /* With concatenated compressed files that can have embedded
-     * crc trailers, z_eof is no longer the only/best indicator of EOF
-     * on a gz_stream. Handle end-of-stream error explicitly here.
-     */
-    if (s == NULL || s->mode != 'r') return 0;
-    if (s->z_eof) return 1;
-    return s->z_err == Z_STREAM_END;
-}
-
-/* ===========================================================================
-     Returns 1 if reading and doing so transparently, otherwise zero.
-*/
-int ZEXPORT gzdirect (file)
-    gzFile file;
-{
-    gz_stream *s = (gz_stream*)file;
-
-    if (s == NULL || s->mode != 'r') return 0;
-    return s->transparent;
-}
-
-/* ===========================================================================
-   Outputs a long in LSB order to the given file
-*/
-local void putLong (file, x)
-    FILE *file;
-    uLong x;
-{
-    int n;
-    for (n = 0; n < 4; n++) {
-        fputc((int)(x & 0xff), file);
-        x >>= 8;
-    }
-}
-
-/* ===========================================================================
-   Reads a long in LSB order from the given gz_stream. Sets z_err in case
-   of error.
-*/
-local uLong getLong (s)
-    gz_stream *s;
-{
-    uLong x = (uLong)get_byte(s);
-    int c;
-
-    x += ((uLong)get_byte(s))<<8;
-    x += ((uLong)get_byte(s))<<16;
-    c = get_byte(s);
-    if (c == EOF) s->z_err = Z_DATA_ERROR;
-    x += ((uLong)c)<<24;
-    return x;
-}
-
-/* ===========================================================================
-     Flushes all pending output if necessary, closes the compressed file
-   and deallocates all the (de)compression state.
-*/
-int ZEXPORT gzclose (file)
-    gzFile file;
-{
-    gz_stream *s = (gz_stream*)file;
-
-    if (s == NULL) return Z_STREAM_ERROR;
-
-    if (s->mode == 'w') {
-#ifdef NO_GZCOMPRESS
-        return Z_STREAM_ERROR;
-#else
-        if (do_flush (file, Z_FINISH) != Z_OK)
-            return destroy((gz_stream*)file);
-
-        putLong (s->file, s->crc);
-        putLong (s->file, (uLong)(s->in & 0xffffffff));
-#endif
-    }
-    return destroy((gz_stream*)file);
-}
-
-#ifdef STDC
-#  define zstrerror(errnum) strerror(errnum)
-#else
-#  define zstrerror(errnum) ""
-#endif
-
-/* ===========================================================================
-     Returns the error message for the last error which occurred on the
-   given compressed file. errnum is set to zlib error number. If an
-   error occurred in the file system and not in the compression library,
-   errnum is set to Z_ERRNO and the application may consult errno
-   to get the exact error code.
-*/
-const char * ZEXPORT gzerror (file, errnum)
-    gzFile file;
-    int *errnum;
-{
-    char *m;
-    gz_stream *s = (gz_stream*)file;
-
-    if (s == NULL) {
-        *errnum = Z_STREAM_ERROR;
-        return (const char*)ERR_MSG(Z_STREAM_ERROR);
-    }
-    *errnum = s->z_err;
-    if (*errnum == Z_OK) return (const char*)"";
-
-    m = (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);
-
-    if (m == NULL || *m == '\0') m = (char*)ERR_MSG(s->z_err);
-
-    TRYFREE(s->msg);
-    s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);
-    if (s->msg == Z_NULL) return (const char*)ERR_MSG(Z_MEM_ERROR);
-    strcpy(s->msg, s->path);
-    strcat(s->msg, ": ");
-    strcat(s->msg, m);
-    return (const char*)s->msg;
-}
-
-/* ===========================================================================
-     Clear the error and end-of-file flags, and do the same for the real file.
-*/
-void ZEXPORT gzclearerr (file)
-    gzFile file;
-{
-    gz_stream *s = (gz_stream*)file;
-
-    if (s == NULL) return;
-    if (s->z_err != Z_STREAM_END) s->z_err = Z_OK;
-    s->z_eof = 0;
-    clearerr(s->file);
-}
diff -Nbaur gcc-4.6.3/zlib/INDEX gcc-4.6.3-psp/zlib/INDEX
--- gcc-4.6.3/zlib/INDEX	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/INDEX	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-ChangeLog       history of changes
-FAQ             Frequently Asked Questions about zlib
-INDEX           this file
-Makefile        makefile for Unix (generated by configure)
-Makefile.in     makefile for Unix (template for configure)
-README          guess what
-algorithm.txt   description of the (de)compression algorithm
-configure       configure script for Unix
-zconf.in.h      template for zconf.h (used by configure)
-
-amiga/          makefiles for Amiga SAS C
-as400/          makefiles for IBM AS/400
-msdos/          makefiles for MSDOS
-old/            makefiles for various architectures and zlib documentation
-                files that have not yet been updated for zlib 1.2.x
-projects/       projects for various Integrated Development Environments
-qnx/            makefiles for QNX
-win32/          makefiles for Windows
-
-                zlib public header files (must be kept):
-zconf.h
-zlib.h
-
-                private source files used to build the zlib library:
-adler32.c
-compress.c
-crc32.c
-crc32.h
-deflate.c
-deflate.h
-gzio.c
-infback.c
-inffast.c
-inffast.h
-inffixed.h
-inflate.c
-inflate.h
-inftrees.c
-inftrees.h
-trees.c
-trees.h
-uncompr.c
-zutil.c
-zutil.h
-
-                source files for sample programs:
-example.c
-minigzip.c
-
-                unsupported contribution by third parties
-See contrib/README.contrib
diff -Nbaur gcc-4.6.3/zlib/infback.c gcc-4.6.3-psp/zlib/infback.c
--- gcc-4.6.3/zlib/infback.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/infback.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,623 +0,0 @@
-/* infback.c -- inflate using a call-back interface
- * Copyright (C) 1995-2005 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
-   This code is largely copied from inflate.c.  Normally either infback.o or
-   inflate.o would be linked into an application--not both.  The interface
-   with inffast.c is retained so that optimized assembler-coded versions of
-   inflate_fast() can be used with either inflate.c or infback.c.
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-
-/* function prototypes */
-local void fixedtables OF((struct inflate_state FAR *state));
-
-/*
-   strm provides memory allocation functions in zalloc and zfree, or
-   Z_NULL to use the library memory allocation functions.
-
-   windowBits is in the range 8..15, and window is a user-supplied
-   window and output buffer that is 2**windowBits bytes.
- */
-int ZEXPORT inflateBackInit_(strm, windowBits, window, version, stream_size)
-z_streamp strm;
-int windowBits;
-unsigned char FAR *window;
-const char *version;
-int stream_size;
-{
-    struct inflate_state FAR *state;
-
-    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
-        stream_size != (int)(sizeof(z_stream)))
-        return Z_VERSION_ERROR;
-    if (strm == Z_NULL || window == Z_NULL ||
-        windowBits < 8 || windowBits > 15)
-        return Z_STREAM_ERROR;
-    strm->msg = Z_NULL;                 /* in case we return an error */
-    if (strm->zalloc == (alloc_func)0) {
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-    }
-    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
-    state = (struct inflate_state FAR *)ZALLOC(strm, 1,
-                                               sizeof(struct inflate_state));
-    if (state == Z_NULL) return Z_MEM_ERROR;
-    Tracev((stderr, "inflate: allocated\n"));
-    strm->state = (struct internal_state FAR *)state;
-    state->dmax = 32768U;
-    state->wbits = windowBits;
-    state->wsize = 1U << windowBits;
-    state->window = window;
-    state->write = 0;
-    state->whave = 0;
-    return Z_OK;
-}
-
-/*
-   Return state with length and distance decoding tables and index sizes set to
-   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
-   If BUILDFIXED is defined, then instead this routine builds the tables the
-   first time it's called, and returns those tables the first time and
-   thereafter.  This reduces the size of the code by about 2K bytes, in
-   exchange for a little execution time.  However, BUILDFIXED should not be
-   used for threaded applications, since the rewriting of the tables and virgin
-   may not be thread-safe.
- */
-local void fixedtables(state)
-struct inflate_state FAR *state;
-{
-#ifdef BUILDFIXED
-    static int virgin = 1;
-    static code *lenfix, *distfix;
-    static code fixed[544];
-
-    /* build fixed huffman tables if first call (may not be thread safe) */
-    if (virgin) {
-        unsigned sym, bits;
-        static code *next;
-
-        /* literal/length table */
-        sym = 0;
-        while (sym < 144) state->lens[sym++] = 8;
-        while (sym < 256) state->lens[sym++] = 9;
-        while (sym < 280) state->lens[sym++] = 7;
-        while (sym < 288) state->lens[sym++] = 8;
-        next = fixed;
-        lenfix = next;
-        bits = 9;
-        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
-
-        /* distance table */
-        sym = 0;
-        while (sym < 32) state->lens[sym++] = 5;
-        distfix = next;
-        bits = 5;
-        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
-
-        /* do this just once */
-        virgin = 0;
-    }
-#else /* !BUILDFIXED */
-#   include "inffixed.h"
-#endif /* BUILDFIXED */
-    state->lencode = lenfix;
-    state->lenbits = 9;
-    state->distcode = distfix;
-    state->distbits = 5;
-}
-
-/* Macros for inflateBack(): */
-
-/* Load returned state from inflate_fast() */
-#define LOAD() \
-    do { \
-        put = strm->next_out; \
-        left = strm->avail_out; \
-        next = strm->next_in; \
-        have = strm->avail_in; \
-        hold = state->hold; \
-        bits = state->bits; \
-    } while (0)
-
-/* Set state from registers for inflate_fast() */
-#define RESTORE() \
-    do { \
-        strm->next_out = put; \
-        strm->avail_out = left; \
-        strm->next_in = next; \
-        strm->avail_in = have; \
-        state->hold = hold; \
-        state->bits = bits; \
-    } while (0)
-
-/* Clear the input bit accumulator */
-#define INITBITS() \
-    do { \
-        hold = 0; \
-        bits = 0; \
-    } while (0)
-
-/* Assure that some input is available.  If input is requested, but denied,
-   then return a Z_BUF_ERROR from inflateBack(). */
-#define PULL() \
-    do { \
-        if (have == 0) { \
-            have = in(in_desc, &next); \
-            if (have == 0) { \
-                next = Z_NULL; \
-                ret = Z_BUF_ERROR; \
-                goto inf_leave; \
-            } \
-        } \
-    } while (0)
-
-/* Get a byte of input into the bit accumulator, or return from inflateBack()
-   with an error if there is no input available. */
-#define PULLBYTE() \
-    do { \
-        PULL(); \
-        have--; \
-        hold += (unsigned long)(*next++) << bits; \
-        bits += 8; \
-    } while (0)
-
-/* Assure that there are at least n bits in the bit accumulator.  If there is
-   not enough available input to do that, then return from inflateBack() with
-   an error. */
-#define NEEDBITS(n) \
-    do { \
-        while (bits < (unsigned)(n)) \
-            PULLBYTE(); \
-    } while (0)
-
-/* Return the low n bits of the bit accumulator (n < 16) */
-#define BITS(n) \
-    ((unsigned)hold & ((1U << (n)) - 1))
-
-/* Remove n bits from the bit accumulator */
-#define DROPBITS(n) \
-    do { \
-        hold >>= (n); \
-        bits -= (unsigned)(n); \
-    } while (0)
-
-/* Remove zero to seven bits as needed to go to a byte boundary */
-#define BYTEBITS() \
-    do { \
-        hold >>= bits & 7; \
-        bits -= bits & 7; \
-    } while (0)
-
-/* Assure that some output space is available, by writing out the window
-   if it's full.  If the write fails, return from inflateBack() with a
-   Z_BUF_ERROR. */
-#define ROOM() \
-    do { \
-        if (left == 0) { \
-            put = state->window; \
-            left = state->wsize; \
-            state->whave = left; \
-            if (out(out_desc, put, left)) { \
-                ret = Z_BUF_ERROR; \
-                goto inf_leave; \
-            } \
-        } \
-    } while (0)
-
-/*
-   strm provides the memory allocation functions and window buffer on input,
-   and provides information on the unused input on return.  For Z_DATA_ERROR
-   returns, strm will also provide an error message.
-
-   in() and out() are the call-back input and output functions.  When
-   inflateBack() needs more input, it calls in().  When inflateBack() has
-   filled the window with output, or when it completes with data in the
-   window, it calls out() to write out the data.  The application must not
-   change the provided input until in() is called again or inflateBack()
-   returns.  The application must not change the window/output buffer until
-   inflateBack() returns.
-
-   in() and out() are called with a descriptor parameter provided in the
-   inflateBack() call.  This parameter can be a structure that provides the
-   information required to do the read or write, as well as accumulated
-   information on the input and output such as totals and check values.
-
-   in() should return zero on failure.  out() should return non-zero on
-   failure.  If either in() or out() fails, than inflateBack() returns a
-   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it
-   was in() or out() that caused in the error.  Otherwise,  inflateBack()
-   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
-   error, or Z_MEM_ERROR if it could not allocate memory for the state.
-   inflateBack() can also return Z_STREAM_ERROR if the input parameters
-   are not correct, i.e. strm is Z_NULL or the state was not initialized.
- */
-int ZEXPORT inflateBack(strm, in, in_desc, out, out_desc)
-z_streamp strm;
-in_func in;
-void FAR *in_desc;
-out_func out;
-void FAR *out_desc;
-{
-    struct inflate_state FAR *state;
-    unsigned char FAR *next;    /* next input */
-    unsigned char FAR *put;     /* next output */
-    unsigned have, left;        /* available input and output */
-    unsigned long hold;         /* bit buffer */
-    unsigned bits;              /* bits in bit buffer */
-    unsigned copy;              /* number of stored or match bytes to copy */
-    unsigned char FAR *from;    /* where to copy match bytes from */
-    code this;                  /* current decoding table entry */
-    code last;                  /* parent table entry */
-    unsigned len;               /* length to copy for repeats, bits to drop */
-    int ret;                    /* return code */
-    static const unsigned short order[19] = /* permutation of code lengths */
-        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-
-    /* Check that the strm exists and that the state was initialized */
-    if (strm == Z_NULL || strm->state == Z_NULL)
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-
-    /* Reset the state */
-    strm->msg = Z_NULL;
-    state->mode = TYPE;
-    state->last = 0;
-    state->whave = 0;
-    next = strm->next_in;
-    have = next != Z_NULL ? strm->avail_in : 0;
-    hold = 0;
-    bits = 0;
-    put = state->window;
-    left = state->wsize;
-
-    /* Inflate until end of block marked as last */
-    for (;;)
-        switch (state->mode) {
-        case TYPE:
-            /* determine and dispatch block type */
-            if (state->last) {
-                BYTEBITS();
-                state->mode = DONE;
-                break;
-            }
-            NEEDBITS(3);
-            state->last = BITS(1);
-            DROPBITS(1);
-            switch (BITS(2)) {
-            case 0:                             /* stored block */
-                Tracev((stderr, "inflate:     stored block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = STORED;
-                break;
-            case 1:                             /* fixed block */
-                fixedtables(state);
-                Tracev((stderr, "inflate:     fixed codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = LEN;              /* decode codes */
-                break;
-            case 2:                             /* dynamic block */
-                Tracev((stderr, "inflate:     dynamic codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = TABLE;
-                break;
-            case 3:
-                strm->msg = (char *)"invalid block type";
-                state->mode = BAD;
-            }
-            DROPBITS(2);
-            break;
-
-        case STORED:
-            /* get and verify stored block length */
-            BYTEBITS();                         /* go to byte boundary */
-            NEEDBITS(32);
-            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
-                strm->msg = (char *)"invalid stored block lengths";
-                state->mode = BAD;
-                break;
-            }
-            state->length = (unsigned)hold & 0xffff;
-            Tracev((stderr, "inflate:       stored length %u\n",
-                    state->length));
-            INITBITS();
-
-            /* copy stored block from input to output */
-            while (state->length != 0) {
-                copy = state->length;
-                PULL();
-                ROOM();
-                if (copy > have) copy = have;
-                if (copy > left) copy = left;
-                zmemcpy(put, next, copy);
-                have -= copy;
-                next += copy;
-                left -= copy;
-                put += copy;
-                state->length -= copy;
-            }
-            Tracev((stderr, "inflate:       stored end\n"));
-            state->mode = TYPE;
-            break;
-
-        case TABLE:
-            /* get dynamic table entries descriptor */
-            NEEDBITS(14);
-            state->nlen = BITS(5) + 257;
-            DROPBITS(5);
-            state->ndist = BITS(5) + 1;
-            DROPBITS(5);
-            state->ncode = BITS(4) + 4;
-            DROPBITS(4);
-#ifndef PKZIP_BUG_WORKAROUND
-            if (state->nlen > 286 || state->ndist > 30) {
-                strm->msg = (char *)"too many length or distance symbols";
-                state->mode = BAD;
-                break;
-            }
-#endif
-            Tracev((stderr, "inflate:       table sizes ok\n"));
-
-            /* get code length code lengths (not a typo) */
-            state->have = 0;
-            while (state->have < state->ncode) {
-                NEEDBITS(3);
-                state->lens[order[state->have++]] = (unsigned short)BITS(3);
-                DROPBITS(3);
-            }
-            while (state->have < 19)
-                state->lens[order[state->have++]] = 0;
-            state->next = state->codes;
-            state->lencode = (code const FAR *)(state->next);
-            state->lenbits = 7;
-            ret = inflate_table(CODES, state->lens, 19, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid code lengths set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       code lengths ok\n"));
-
-            /* get length and distance code code lengths */
-            state->have = 0;
-            while (state->have < state->nlen + state->ndist) {
-                for (;;) {
-                    this = state->lencode[BITS(state->lenbits)];
-                    if ((unsigned)(this.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                if (this.val < 16) {
-                    NEEDBITS(this.bits);
-                    DROPBITS(this.bits);
-                    state->lens[state->have++] = this.val;
-                }
-                else {
-                    if (this.val == 16) {
-                        NEEDBITS(this.bits + 2);
-                        DROPBITS(this.bits);
-                        if (state->have == 0) {
-                            strm->msg = (char *)"invalid bit length repeat";
-                            state->mode = BAD;
-                            break;
-                        }
-                        len = (unsigned)(state->lens[state->have - 1]);
-                        copy = 3 + BITS(2);
-                        DROPBITS(2);
-                    }
-                    else if (this.val == 17) {
-                        NEEDBITS(this.bits + 3);
-                        DROPBITS(this.bits);
-                        len = 0;
-                        copy = 3 + BITS(3);
-                        DROPBITS(3);
-                    }
-                    else {
-                        NEEDBITS(this.bits + 7);
-                        DROPBITS(this.bits);
-                        len = 0;
-                        copy = 11 + BITS(7);
-                        DROPBITS(7);
-                    }
-                    if (state->have + copy > state->nlen + state->ndist) {
-                        strm->msg = (char *)"invalid bit length repeat";
-                        state->mode = BAD;
-                        break;
-                    }
-                    while (copy--)
-                        state->lens[state->have++] = (unsigned short)len;
-                }
-            }
-
-            /* handle error breaks in while */
-            if (state->mode == BAD) break;
-
-            /* build code tables */
-            state->next = state->codes;
-            state->lencode = (code const FAR *)(state->next);
-            state->lenbits = 9;
-            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid literal/lengths set";
-                state->mode = BAD;
-                break;
-            }
-            state->distcode = (code const FAR *)(state->next);
-            state->distbits = 6;
-            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
-                            &(state->next), &(state->distbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid distances set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       codes ok\n"));
-            state->mode = LEN;
-
-        case LEN:
-            /* use inflate_fast() if we have enough input and output */
-            if (have >= 6 && left >= 258) {
-                RESTORE();
-                if (state->whave < state->wsize)
-                    state->whave = state->wsize - left;
-                inflate_fast(strm, state->wsize);
-                LOAD();
-                break;
-            }
-
-            /* get a literal, length, or end-of-block code */
-            for (;;) {
-                this = state->lencode[BITS(state->lenbits)];
-                if ((unsigned)(this.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if (this.op && (this.op & 0xf0) == 0) {
-                last = this;
-                for (;;) {
-                    this = state->lencode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + this.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-            }
-            DROPBITS(this.bits);
-            state->length = (unsigned)this.val;
-
-            /* process literal */
-            if (this.op == 0) {
-                Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
-                        "inflate:         literal '%c'\n" :
-                        "inflate:         literal 0x%02x\n", this.val));
-                ROOM();
-                *put++ = (unsigned char)(state->length);
-                left--;
-                state->mode = LEN;
-                break;
-            }
-
-            /* process end of block */
-            if (this.op & 32) {
-                Tracevv((stderr, "inflate:         end of block\n"));
-                state->mode = TYPE;
-                break;
-            }
-
-            /* invalid code */
-            if (this.op & 64) {
-                strm->msg = (char *)"invalid literal/length code";
-                state->mode = BAD;
-                break;
-            }
-
-            /* length code -- get extra bits, if any */
-            state->extra = (unsigned)(this.op) & 15;
-            if (state->extra != 0) {
-                NEEDBITS(state->extra);
-                state->length += BITS(state->extra);
-                DROPBITS(state->extra);
-            }
-            Tracevv((stderr, "inflate:         length %u\n", state->length));
-
-            /* get distance code */
-            for (;;) {
-                this = state->distcode[BITS(state->distbits)];
-                if ((unsigned)(this.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if ((this.op & 0xf0) == 0) {
-                last = this;
-                for (;;) {
-                    this = state->distcode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + this.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-            }
-            DROPBITS(this.bits);
-            if (this.op & 64) {
-                strm->msg = (char *)"invalid distance code";
-                state->mode = BAD;
-                break;
-            }
-            state->offset = (unsigned)this.val;
-
-            /* get distance extra bits, if any */
-            state->extra = (unsigned)(this.op) & 15;
-            if (state->extra != 0) {
-                NEEDBITS(state->extra);
-                state->offset += BITS(state->extra);
-                DROPBITS(state->extra);
-            }
-            if (state->offset > state->wsize - (state->whave < state->wsize ?
-                                                left : 0)) {
-                strm->msg = (char *)"invalid distance too far back";
-                state->mode = BAD;
-                break;
-            }
-            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
-
-            /* copy match from window to output */
-            do {
-                ROOM();
-                copy = state->wsize - state->offset;
-                if (copy < left) {
-                    from = put + copy;
-                    copy = left - copy;
-                }
-                else {
-                    from = put - state->offset;
-                    copy = left;
-                }
-                if (copy > state->length) copy = state->length;
-                state->length -= copy;
-                left -= copy;
-                do {
-                    *put++ = *from++;
-                } while (--copy);
-            } while (state->length != 0);
-            break;
-
-        case DONE:
-            /* inflate stream terminated properly -- write leftover output */
-            ret = Z_STREAM_END;
-            if (left < state->wsize) {
-                if (out(out_desc, state->window, state->wsize - left))
-                    ret = Z_BUF_ERROR;
-            }
-            goto inf_leave;
-
-        case BAD:
-            ret = Z_DATA_ERROR;
-            goto inf_leave;
-
-        default:                /* can't happen, but makes compilers happy */
-            ret = Z_STREAM_ERROR;
-            goto inf_leave;
-        }
-
-    /* Return unused input */
-  inf_leave:
-    strm->next_in = next;
-    strm->avail_in = have;
-    return ret;
-}
-
-int ZEXPORT inflateBackEnd(strm)
-z_streamp strm;
-{
-    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
-        return Z_STREAM_ERROR;
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-    Tracev((stderr, "inflate: end\n"));
-    return Z_OK;
-}
diff -Nbaur gcc-4.6.3/zlib/inffast.c gcc-4.6.3-psp/zlib/inffast.c
--- gcc-4.6.3/zlib/inffast.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/inffast.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,318 +0,0 @@
-/* inffast.c -- fast decoding
- * Copyright (C) 1995-2004 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-
-#ifndef ASMINF
-
-/* Allow machine dependent optimization for post-increment or pre-increment.
-   Based on testing to date,
-   Pre-increment preferred for:
-   - PowerPC G3 (Adler)
-   - MIPS R5000 (Randers-Pehrson)
-   Post-increment preferred for:
-   - none
-   No measurable difference:
-   - Pentium III (Anderson)
-   - M68060 (Nikl)
- */
-#ifdef POSTINC
-#  define OFF 0
-#  define PUP(a) *(a)++
-#else
-#  define OFF 1
-#  define PUP(a) *++(a)
-#endif
-
-/*
-   Decode literal, length, and distance codes and write out the resulting
-   literal and match bytes until either not enough input or output is
-   available, an end-of-block is encountered, or a data error is encountered.
-   When large enough input and output buffers are supplied to inflate(), for
-   example, a 16K input buffer and a 64K output buffer, more than 95% of the
-   inflate execution time is spent in this routine.
-
-   Entry assumptions:
-
-        state->mode == LEN
-        strm->avail_in >= 6
-        strm->avail_out >= 258
-        start >= strm->avail_out
-        state->bits < 8
-
-   On return, state->mode is one of:
-
-        LEN -- ran out of enough output space or enough available input
-        TYPE -- reached end of block code, inflate() to interpret next block
-        BAD -- error in block data
-
-   Notes:
-
-    - The maximum input bits used by a length/distance pair is 15 bits for the
-      length code, 5 bits for the length extra, 15 bits for the distance code,
-      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
-      Therefore if strm->avail_in >= 6, then there is enough input to avoid
-      checking for available input while decoding.
-
-    - The maximum bytes that a single length/distance pair can output is 258
-      bytes, which is the maximum length that can be coded.  inflate_fast()
-      requires strm->avail_out >= 258 for each loop to avoid checking for
-      output space.
- */
-void inflate_fast(strm, start)
-z_streamp strm;
-unsigned start;         /* inflate()'s starting value for strm->avail_out */
-{
-    struct inflate_state FAR *state;
-    unsigned char FAR *in;      /* local strm->next_in */
-    unsigned char FAR *last;    /* while in < last, enough input available */
-    unsigned char FAR *out;     /* local strm->next_out */
-    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
-    unsigned char FAR *end;     /* while out < end, enough space available */
-#ifdef INFLATE_STRICT
-    unsigned dmax;              /* maximum distance from zlib header */
-#endif
-    unsigned wsize;             /* window size or zero if not using window */
-    unsigned whave;             /* valid bytes in the window */
-    unsigned write;             /* window write index */
-    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
-    unsigned long hold;         /* local strm->hold */
-    unsigned bits;              /* local strm->bits */
-    code const FAR *lcode;      /* local strm->lencode */
-    code const FAR *dcode;      /* local strm->distcode */
-    unsigned lmask;             /* mask for first level of length codes */
-    unsigned dmask;             /* mask for first level of distance codes */
-    code this;                  /* retrieved table entry */
-    unsigned op;                /* code bits, operation, extra bits, or */
-                                /*  window position, window bytes to copy */
-    unsigned len;               /* match length, unused bytes */
-    unsigned dist;              /* match distance */
-    unsigned char FAR *from;    /* where to copy match from */
-
-    /* copy state to local variables */
-    state = (struct inflate_state FAR *)strm->state;
-    in = strm->next_in - OFF;
-    last = in + (strm->avail_in - 5);
-    out = strm->next_out - OFF;
-    beg = out - (start - strm->avail_out);
-    end = out + (strm->avail_out - 257);
-#ifdef INFLATE_STRICT
-    dmax = state->dmax;
-#endif
-    wsize = state->wsize;
-    whave = state->whave;
-    write = state->write;
-    window = state->window;
-    hold = state->hold;
-    bits = state->bits;
-    lcode = state->lencode;
-    dcode = state->distcode;
-    lmask = (1U << state->lenbits) - 1;
-    dmask = (1U << state->distbits) - 1;
-
-    /* decode literals and length/distances until end-of-block or not enough
-       input data or output space */
-    do {
-        if (bits < 15) {
-            hold += (unsigned long)(PUP(in)) << bits;
-            bits += 8;
-            hold += (unsigned long)(PUP(in)) << bits;
-            bits += 8;
-        }
-        this = lcode[hold & lmask];
-      dolen:
-        op = (unsigned)(this.bits);
-        hold >>= op;
-        bits -= op;
-        op = (unsigned)(this.op);
-        if (op == 0) {                          /* literal */
-            Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
-                    "inflate:         literal '%c'\n" :
-                    "inflate:         literal 0x%02x\n", this.val));
-            PUP(out) = (unsigned char)(this.val);
-        }
-        else if (op & 16) {                     /* length base */
-            len = (unsigned)(this.val);
-            op &= 15;                           /* number of extra bits */
-            if (op) {
-                if (bits < op) {
-                    hold += (unsigned long)(PUP(in)) << bits;
-                    bits += 8;
-                }
-                len += (unsigned)hold & ((1U << op) - 1);
-                hold >>= op;
-                bits -= op;
-            }
-            Tracevv((stderr, "inflate:         length %u\n", len));
-            if (bits < 15) {
-                hold += (unsigned long)(PUP(in)) << bits;
-                bits += 8;
-                hold += (unsigned long)(PUP(in)) << bits;
-                bits += 8;
-            }
-            this = dcode[hold & dmask];
-          dodist:
-            op = (unsigned)(this.bits);
-            hold >>= op;
-            bits -= op;
-            op = (unsigned)(this.op);
-            if (op & 16) {                      /* distance base */
-                dist = (unsigned)(this.val);
-                op &= 15;                       /* number of extra bits */
-                if (bits < op) {
-                    hold += (unsigned long)(PUP(in)) << bits;
-                    bits += 8;
-                    if (bits < op) {
-                        hold += (unsigned long)(PUP(in)) << bits;
-                        bits += 8;
-                    }
-                }
-                dist += (unsigned)hold & ((1U << op) - 1);
-#ifdef INFLATE_STRICT
-                if (dist > dmax) {
-                    strm->msg = (char *)"invalid distance too far back";
-                    state->mode = BAD;
-                    break;
-                }
-#endif
-                hold >>= op;
-                bits -= op;
-                Tracevv((stderr, "inflate:         distance %u\n", dist));
-                op = (unsigned)(out - beg);     /* max distance in output */
-                if (dist > op) {                /* see if copy from window */
-                    op = dist - op;             /* distance back in window */
-                    if (op > whave) {
-                        strm->msg = (char *)"invalid distance too far back";
-                        state->mode = BAD;
-                        break;
-                    }
-                    from = window - OFF;
-                    if (write == 0) {           /* very common case */
-                        from += wsize - op;
-                        if (op < len) {         /* some from window */
-                            len -= op;
-                            do {
-                                PUP(out) = PUP(from);
-                            } while (--op);
-                            from = out - dist;  /* rest from output */
-                        }
-                    }
-                    else if (write < op) {      /* wrap around window */
-                        from += wsize + write - op;
-                        op -= write;
-                        if (op < len) {         /* some from end of window */
-                            len -= op;
-                            do {
-                                PUP(out) = PUP(from);
-                            } while (--op);
-                            from = window - OFF;
-                            if (write < len) {  /* some from start of window */
-                                op = write;
-                                len -= op;
-                                do {
-                                    PUP(out) = PUP(from);
-                                } while (--op);
-                                from = out - dist;      /* rest from output */
-                            }
-                        }
-                    }
-                    else {                      /* contiguous in window */
-                        from += write - op;
-                        if (op < len) {         /* some from window */
-                            len -= op;
-                            do {
-                                PUP(out) = PUP(from);
-                            } while (--op);
-                            from = out - dist;  /* rest from output */
-                        }
-                    }
-                    while (len > 2) {
-                        PUP(out) = PUP(from);
-                        PUP(out) = PUP(from);
-                        PUP(out) = PUP(from);
-                        len -= 3;
-                    }
-                    if (len) {
-                        PUP(out) = PUP(from);
-                        if (len > 1)
-                            PUP(out) = PUP(from);
-                    }
-                }
-                else {
-                    from = out - dist;          /* copy direct from output */
-                    do {                        /* minimum length is three */
-                        PUP(out) = PUP(from);
-                        PUP(out) = PUP(from);
-                        PUP(out) = PUP(from);
-                        len -= 3;
-                    } while (len > 2);
-                    if (len) {
-                        PUP(out) = PUP(from);
-                        if (len > 1)
-                            PUP(out) = PUP(from);
-                    }
-                }
-            }
-            else if ((op & 64) == 0) {          /* 2nd level distance code */
-                this = dcode[this.val + (hold & ((1U << op) - 1))];
-                goto dodist;
-            }
-            else {
-                strm->msg = (char *)"invalid distance code";
-                state->mode = BAD;
-                break;
-            }
-        }
-        else if ((op & 64) == 0) {              /* 2nd level length code */
-            this = lcode[this.val + (hold & ((1U << op) - 1))];
-            goto dolen;
-        }
-        else if (op & 32) {                     /* end-of-block */
-            Tracevv((stderr, "inflate:         end of block\n"));
-            state->mode = TYPE;
-            break;
-        }
-        else {
-            strm->msg = (char *)"invalid literal/length code";
-            state->mode = BAD;
-            break;
-        }
-    } while (in < last && out < end);
-
-    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
-    len = bits >> 3;
-    in -= len;
-    bits -= len << 3;
-    hold &= (1U << bits) - 1;
-
-    /* update state and return */
-    strm->next_in = in + OFF;
-    strm->next_out = out + OFF;
-    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
-    strm->avail_out = (unsigned)(out < end ?
-                                 257 + (end - out) : 257 - (out - end));
-    state->hold = hold;
-    state->bits = bits;
-    return;
-}
-
-/*
-   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
-   - Using bit fields for code structure
-   - Different op definition to avoid & for extra bits (do & for table bits)
-   - Three separate decoding do-loops for direct, window, and write == 0
-   - Special case for distance > 1 copies to do overlapped load and store copy
-   - Explicit branch predictions (based on measured branch probabilities)
-   - Deferring match copy and interspersed it with decoding subsequent codes
-   - Swapping literal/length else
-   - Swapping window/direct else
-   - Larger unrolled copy loops (three is about right)
-   - Moving len -= 3 statement into middle of loop
- */
-
-#endif /* !ASMINF */
diff -Nbaur gcc-4.6.3/zlib/inffast.h gcc-4.6.3-psp/zlib/inffast.h
--- gcc-4.6.3/zlib/inffast.h	2005-09-12 18:02:07.000000000 +0100
+++ gcc-4.6.3-psp/zlib/inffast.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
-/* inffast.h -- header to use inffast.c
- * Copyright (C) 1995-2003 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-void inflate_fast OF((z_streamp strm, unsigned start));
diff -Nbaur gcc-4.6.3/zlib/inffixed.h gcc-4.6.3-psp/zlib/inffixed.h
--- gcc-4.6.3/zlib/inffixed.h	2005-09-12 18:02:07.000000000 +0100
+++ gcc-4.6.3-psp/zlib/inffixed.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,94 +0,0 @@
-    /* inffixed.h -- table for decoding fixed codes
-     * Generated automatically by makefixed().
-     */
-
-    /* WARNING: this file should *not* be used by applications. It
-       is part of the implementation of the compression library and
-       is subject to change. Applications should only use zlib.h.
-     */
-
-    static const code lenfix[512] = {
-        {96,7,0},{0,8,80},{0,8,16},{20,8,115},{18,7,31},{0,8,112},{0,8,48},
-        {0,9,192},{16,7,10},{0,8,96},{0,8,32},{0,9,160},{0,8,0},{0,8,128},
-        {0,8,64},{0,9,224},{16,7,6},{0,8,88},{0,8,24},{0,9,144},{19,7,59},
-        {0,8,120},{0,8,56},{0,9,208},{17,7,17},{0,8,104},{0,8,40},{0,9,176},
-        {0,8,8},{0,8,136},{0,8,72},{0,9,240},{16,7,4},{0,8,84},{0,8,20},
-        {21,8,227},{19,7,43},{0,8,116},{0,8,52},{0,9,200},{17,7,13},{0,8,100},
-        {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},{16,7,8},
-        {0,8,92},{0,8,28},{0,9,152},{20,7,83},{0,8,124},{0,8,60},{0,9,216},
-        {18,7,23},{0,8,108},{0,8,44},{0,9,184},{0,8,12},{0,8,140},{0,8,76},
-        {0,9,248},{16,7,3},{0,8,82},{0,8,18},{21,8,163},{19,7,35},{0,8,114},
-        {0,8,50},{0,9,196},{17,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},
-        {0,8,130},{0,8,66},{0,9,228},{16,7,7},{0,8,90},{0,8,26},{0,9,148},
-        {20,7,67},{0,8,122},{0,8,58},{0,9,212},{18,7,19},{0,8,106},{0,8,42},
-        {0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},{16,7,5},{0,8,86},
-        {0,8,22},{64,8,0},{19,7,51},{0,8,118},{0,8,54},{0,9,204},{17,7,15},
-        {0,8,102},{0,8,38},{0,9,172},{0,8,6},{0,8,134},{0,8,70},{0,9,236},
-        {16,7,9},{0,8,94},{0,8,30},{0,9,156},{20,7,99},{0,8,126},{0,8,62},
-        {0,9,220},{18,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},
-        {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{21,8,131},{18,7,31},
-        {0,8,113},{0,8,49},{0,9,194},{16,7,10},{0,8,97},{0,8,33},{0,9,162},
-        {0,8,1},{0,8,129},{0,8,65},{0,9,226},{16,7,6},{0,8,89},{0,8,25},
-        {0,9,146},{19,7,59},{0,8,121},{0,8,57},{0,9,210},{17,7,17},{0,8,105},
-        {0,8,41},{0,9,178},{0,8,9},{0,8,137},{0,8,73},{0,9,242},{16,7,4},
-        {0,8,85},{0,8,21},{16,8,258},{19,7,43},{0,8,117},{0,8,53},{0,9,202},
-        {17,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},{0,8,69},
-        {0,9,234},{16,7,8},{0,8,93},{0,8,29},{0,9,154},{20,7,83},{0,8,125},
-        {0,8,61},{0,9,218},{18,7,23},{0,8,109},{0,8,45},{0,9,186},{0,8,13},
-        {0,8,141},{0,8,77},{0,9,250},{16,7,3},{0,8,83},{0,8,19},{21,8,195},
-        {19,7,35},{0,8,115},{0,8,51},{0,9,198},{17,7,11},{0,8,99},{0,8,35},
-        {0,9,166},{0,8,3},{0,8,131},{0,8,67},{0,9,230},{16,7,7},{0,8,91},
-        {0,8,27},{0,9,150},{20,7,67},{0,8,123},{0,8,59},{0,9,214},{18,7,19},
-        {0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},{0,8,75},{0,9,246},
-        {16,7,5},{0,8,87},{0,8,23},{64,8,0},{19,7,51},{0,8,119},{0,8,55},
-        {0,9,206},{17,7,15},{0,8,103},{0,8,39},{0,9,174},{0,8,7},{0,8,135},
-        {0,8,71},{0,9,238},{16,7,9},{0,8,95},{0,8,31},{0,9,158},{20,7,99},
-        {0,8,127},{0,8,63},{0,9,222},{18,7,27},{0,8,111},{0,8,47},{0,9,190},
-        {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},{0,8,16},
-        {20,8,115},{18,7,31},{0,8,112},{0,8,48},{0,9,193},{16,7,10},{0,8,96},
-        {0,8,32},{0,9,161},{0,8,0},{0,8,128},{0,8,64},{0,9,225},{16,7,6},
-        {0,8,88},{0,8,24},{0,9,145},{19,7,59},{0,8,120},{0,8,56},{0,9,209},
-        {17,7,17},{0,8,104},{0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},
-        {0,9,241},{16,7,4},{0,8,84},{0,8,20},{21,8,227},{19,7,43},{0,8,116},
-        {0,8,52},{0,9,201},{17,7,13},{0,8,100},{0,8,36},{0,9,169},{0,8,4},
-        {0,8,132},{0,8,68},{0,9,233},{16,7,8},{0,8,92},{0,8,28},{0,9,153},
-        {20,7,83},{0,8,124},{0,8,60},{0,9,217},{18,7,23},{0,8,108},{0,8,44},
-        {0,9,185},{0,8,12},{0,8,140},{0,8,76},{0,9,249},{16,7,3},{0,8,82},
-        {0,8,18},{21,8,163},{19,7,35},{0,8,114},{0,8,50},{0,9,197},{17,7,11},
-        {0,8,98},{0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},
-        {16,7,7},{0,8,90},{0,8,26},{0,9,149},{20,7,67},{0,8,122},{0,8,58},
-        {0,9,213},{18,7,19},{0,8,106},{0,8,42},{0,9,181},{0,8,10},{0,8,138},
-        {0,8,74},{0,9,245},{16,7,5},{0,8,86},{0,8,22},{64,8,0},{19,7,51},
-        {0,8,118},{0,8,54},{0,9,205},{17,7,15},{0,8,102},{0,8,38},{0,9,173},
-        {0,8,6},{0,8,134},{0,8,70},{0,9,237},{16,7,9},{0,8,94},{0,8,30},
-        {0,9,157},{20,7,99},{0,8,126},{0,8,62},{0,9,221},{18,7,27},{0,8,110},
-        {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},{96,7,0},
-        {0,8,81},{0,8,17},{21,8,131},{18,7,31},{0,8,113},{0,8,49},{0,9,195},
-        {16,7,10},{0,8,97},{0,8,33},{0,9,163},{0,8,1},{0,8,129},{0,8,65},
-        {0,9,227},{16,7,6},{0,8,89},{0,8,25},{0,9,147},{19,7,59},{0,8,121},
-        {0,8,57},{0,9,211},{17,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},
-        {0,8,137},{0,8,73},{0,9,243},{16,7,4},{0,8,85},{0,8,21},{16,8,258},
-        {19,7,43},{0,8,117},{0,8,53},{0,9,203},{17,7,13},{0,8,101},{0,8,37},
-        {0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},{16,7,8},{0,8,93},
-        {0,8,29},{0,9,155},{20,7,83},{0,8,125},{0,8,61},{0,9,219},{18,7,23},
-        {0,8,109},{0,8,45},{0,9,187},{0,8,13},{0,8,141},{0,8,77},{0,9,251},
-        {16,7,3},{0,8,83},{0,8,19},{21,8,195},{19,7,35},{0,8,115},{0,8,51},
-        {0,9,199},{17,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},
-        {0,8,67},{0,9,231},{16,7,7},{0,8,91},{0,8,27},{0,9,151},{20,7,67},
-        {0,8,123},{0,8,59},{0,9,215},{18,7,19},{0,8,107},{0,8,43},{0,9,183},
-        {0,8,11},{0,8,139},{0,8,75},{0,9,247},{16,7,5},{0,8,87},{0,8,23},
-        {64,8,0},{19,7,51},{0,8,119},{0,8,55},{0,9,207},{17,7,15},{0,8,103},
-        {0,8,39},{0,9,175},{0,8,7},{0,8,135},{0,8,71},{0,9,239},{16,7,9},
-        {0,8,95},{0,8,31},{0,9,159},{20,7,99},{0,8,127},{0,8,63},{0,9,223},
-        {18,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},{0,8,79},
-        {0,9,255}
-    };
-
-    static const code distfix[32] = {
-        {16,5,1},{23,5,257},{19,5,17},{27,5,4097},{17,5,5},{25,5,1025},
-        {21,5,65},{29,5,16385},{16,5,3},{24,5,513},{20,5,33},{28,5,8193},
-        {18,5,9},{26,5,2049},{22,5,129},{64,5,0},{16,5,2},{23,5,385},
-        {19,5,25},{27,5,6145},{17,5,7},{25,5,1537},{21,5,97},{29,5,24577},
-        {16,5,4},{24,5,769},{20,5,49},{28,5,12289},{18,5,13},{26,5,3073},
-        {22,5,193},{64,5,0}
-    };
diff -Nbaur gcc-4.6.3/zlib/inflate.c gcc-4.6.3-psp/zlib/inflate.c
--- gcc-4.6.3/zlib/inflate.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/inflate.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1368 +0,0 @@
-/* inflate.c -- zlib decompression
- * Copyright (C) 1995-2005 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- * Change history:
- *
- * 1.2.beta0    24 Nov 2002
- * - First version -- complete rewrite of inflate to simplify code, avoid
- *   creation of window when not needed, minimize use of window when it is
- *   needed, make inffast.c even faster, implement gzip decoding, and to
- *   improve code readability and style over the previous zlib inflate code
- *
- * 1.2.beta1    25 Nov 2002
- * - Use pointers for available input and output checking in inffast.c
- * - Remove input and output counters in inffast.c
- * - Change inffast.c entry and loop from avail_in >= 7 to >= 6
- * - Remove unnecessary second byte pull from length extra in inffast.c
- * - Unroll direct copy to three copies per loop in inffast.c
- *
- * 1.2.beta2    4 Dec 2002
- * - Change external routine names to reduce potential conflicts
- * - Correct filename to inffixed.h for fixed tables in inflate.c
- * - Make hbuf[] unsigned char to match parameter type in inflate.c
- * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)
- *   to avoid negation problem on Alphas (64 bit) in inflate.c
- *
- * 1.2.beta3    22 Dec 2002
- * - Add comments on state->bits assertion in inffast.c
- * - Add comments on op field in inftrees.h
- * - Fix bug in reuse of allocated window after inflateReset()
- * - Remove bit fields--back to byte structure for speed
- * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
- * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
- * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
- * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
- * - Use local copies of stream next and avail values, as well as local bit
- *   buffer and bit count in inflate()--for speed when inflate_fast() not used
- *
- * 1.2.beta4    1 Jan 2003
- * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
- * - Move a comment on output buffer sizes from inffast.c to inflate.c
- * - Add comments in inffast.c to introduce the inflate_fast() routine
- * - Rearrange window copies in inflate_fast() for speed and simplification
- * - Unroll last copy for window match in inflate_fast()
- * - Use local copies of window variables in inflate_fast() for speed
- * - Pull out common write == 0 case for speed in inflate_fast()
- * - Make op and len in inflate_fast() unsigned for consistency
- * - Add FAR to lcode and dcode declarations in inflate_fast()
- * - Simplified bad distance check in inflate_fast()
- * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
- *   source file infback.c to provide a call-back interface to inflate for
- *   programs like gzip and unzip -- uses window as output buffer to avoid
- *   window copying
- *
- * 1.2.beta5    1 Jan 2003
- * - Improved inflateBack() interface to allow the caller to provide initial
- *   input in strm.
- * - Fixed stored blocks bug in inflateBack()
- *
- * 1.2.beta6    4 Jan 2003
- * - Added comments in inffast.c on effectiveness of POSTINC
- * - Typecasting all around to reduce compiler warnings
- * - Changed loops from while (1) or do {} while (1) to for (;;), again to
- *   make compilers happy
- * - Changed type of window in inflateBackInit() to unsigned char *
- *
- * 1.2.beta7    27 Jan 2003
- * - Changed many types to unsigned or unsigned short to avoid warnings
- * - Added inflateCopy() function
- *
- * 1.2.0        9 Mar 2003
- * - Changed inflateBack() interface to provide separate opaque descriptors
- *   for the in() and out() functions
- * - Changed inflateBack() argument and in_func typedef to swap the length
- *   and buffer address return values for the input function
- * - Check next_in and next_out for Z_NULL on entry to inflate()
- *
- * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-
-#ifdef MAKEFIXED
-#  ifndef BUILDFIXED
-#    define BUILDFIXED
-#  endif
-#endif
-
-/* function prototypes */
-local void fixedtables OF((struct inflate_state FAR *state));
-local int updatewindow OF((z_streamp strm, unsigned out));
-#ifdef BUILDFIXED
-   void makefixed OF((void));
-#endif
-local unsigned syncsearch OF((unsigned FAR *have, unsigned char FAR *buf,
-                              unsigned len));
-
-int ZEXPORT inflateReset(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    strm->total_in = strm->total_out = state->total = 0;
-    strm->msg = Z_NULL;
-    strm->adler = 1;        /* to support ill-conceived Java test suite */
-    state->mode = HEAD;
-    state->last = 0;
-    state->havedict = 0;
-    state->dmax = 32768U;
-    state->head = Z_NULL;
-    state->wsize = 0;
-    state->whave = 0;
-    state->write = 0;
-    state->hold = 0;
-    state->bits = 0;
-    state->lencode = state->distcode = state->next = state->codes;
-    Tracev((stderr, "inflate: reset\n"));
-    return Z_OK;
-}
-
-int ZEXPORT inflatePrime(strm, bits, value)
-z_streamp strm;
-int bits;
-int value;
-{
-    struct inflate_state FAR *state;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;
-    value &= (1L << bits) - 1;
-    state->hold += value << state->bits;
-    state->bits += bits;
-    return Z_OK;
-}
-
-int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
-z_streamp strm;
-int windowBits;
-const char *version;
-int stream_size;
-{
-    struct inflate_state FAR *state;
-
-    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
-        stream_size != (int)(sizeof(z_stream)))
-        return Z_VERSION_ERROR;
-    if (strm == Z_NULL) return Z_STREAM_ERROR;
-    strm->msg = Z_NULL;                 /* in case we return an error */
-    if (strm->zalloc == (alloc_func)0) {
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-    }
-    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
-    state = (struct inflate_state FAR *)
-            ZALLOC(strm, 1, sizeof(struct inflate_state));
-    if (state == Z_NULL) return Z_MEM_ERROR;
-    Tracev((stderr, "inflate: allocated\n"));
-    strm->state = (struct internal_state FAR *)state;
-    if (windowBits < 0) {
-        state->wrap = 0;
-        windowBits = -windowBits;
-    }
-    else {
-        state->wrap = (windowBits >> 4) + 1;
-#ifdef GUNZIP
-        if (windowBits < 48) windowBits &= 15;
-#endif
-    }
-    if (windowBits < 8 || windowBits > 15) {
-        ZFREE(strm, state);
-        strm->state = Z_NULL;
-        return Z_STREAM_ERROR;
-    }
-    state->wbits = (unsigned)windowBits;
-    state->window = Z_NULL;
-    return inflateReset(strm);
-}
-
-int ZEXPORT inflateInit_(strm, version, stream_size)
-z_streamp strm;
-const char *version;
-int stream_size;
-{
-    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
-}
-
-/*
-   Return state with length and distance decoding tables and index sizes set to
-   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
-   If BUILDFIXED is defined, then instead this routine builds the tables the
-   first time it's called, and returns those tables the first time and
-   thereafter.  This reduces the size of the code by about 2K bytes, in
-   exchange for a little execution time.  However, BUILDFIXED should not be
-   used for threaded applications, since the rewriting of the tables and virgin
-   may not be thread-safe.
- */
-local void fixedtables(state)
-struct inflate_state FAR *state;
-{
-#ifdef BUILDFIXED
-    static int virgin = 1;
-    static code *lenfix, *distfix;
-    static code fixed[544];
-
-    /* build fixed huffman tables if first call (may not be thread safe) */
-    if (virgin) {
-        unsigned sym, bits;
-        static code *next;
-
-        /* literal/length table */
-        sym = 0;
-        while (sym < 144) state->lens[sym++] = 8;
-        while (sym < 256) state->lens[sym++] = 9;
-        while (sym < 280) state->lens[sym++] = 7;
-        while (sym < 288) state->lens[sym++] = 8;
-        next = fixed;
-        lenfix = next;
-        bits = 9;
-        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
-
-        /* distance table */
-        sym = 0;
-        while (sym < 32) state->lens[sym++] = 5;
-        distfix = next;
-        bits = 5;
-        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
-
-        /* do this just once */
-        virgin = 0;
-    }
-#else /* !BUILDFIXED */
-#   include "inffixed.h"
-#endif /* BUILDFIXED */
-    state->lencode = lenfix;
-    state->lenbits = 9;
-    state->distcode = distfix;
-    state->distbits = 5;
-}
-
-#ifdef MAKEFIXED
-#include <stdio.h>
-
-/*
-   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
-   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
-   those tables to stdout, which would be piped to inffixed.h.  A small program
-   can simply call makefixed to do this:
-
-    void makefixed(void);
-
-    int main(void)
-    {
-        makefixed();
-        return 0;
-    }
-
-   Then that can be linked with zlib built with MAKEFIXED defined and run:
-
-    a.out > inffixed.h
- */
-void makefixed()
-{
-    unsigned low, size;
-    struct inflate_state state;
-
-    fixedtables(&state);
-    puts("    /* inffixed.h -- table for decoding fixed codes");
-    puts("     * Generated automatically by makefixed().");
-    puts("     */");
-    puts("");
-    puts("    /* WARNING: this file should *not* be used by applications.");
-    puts("       It is part of the implementation of this library and is");
-    puts("       subject to change. Applications should only use zlib.h.");
-    puts("     */");
-    puts("");
-    size = 1U << 9;
-    printf("    static const code lenfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 7) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", state.lencode[low].op, state.lencode[low].bits,
-               state.lencode[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-    size = 1U << 5;
-    printf("\n    static const code distfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 6) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", state.distcode[low].op, state.distcode[low].bits,
-               state.distcode[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-}
-#endif /* MAKEFIXED */
-
-/*
-   Update the window with the last wsize (normally 32K) bytes written before
-   returning.  If window does not exist yet, create it.  This is only called
-   when a window is already in use, or when output has been written during this
-   inflate call, but the end of the deflate stream has not been reached yet.
-   It is also called to create a window for dictionary data when a dictionary
-   is loaded.
-
-   Providing output buffers larger than 32K to inflate() should provide a speed
-   advantage, since only the last 32K of output is copied to the sliding window
-   upon return from inflate(), and since all distances after the first 32K of
-   output will fall in the output data, making match copies simpler and faster.
-   The advantage may be dependent on the size of the processor's data caches.
- */
-local int updatewindow(strm, out)
-z_streamp strm;
-unsigned out;
-{
-    struct inflate_state FAR *state;
-    unsigned copy, dist;
-
-    state = (struct inflate_state FAR *)strm->state;
-
-    /* if it hasn't been done already, allocate space for the window */
-    if (state->window == Z_NULL) {
-        state->window = (unsigned char FAR *)
-                        ZALLOC(strm, 1U << state->wbits,
-                               sizeof(unsigned char));
-        if (state->window == Z_NULL) return 1;
-    }
-
-    /* if window not in use yet, initialize */
-    if (state->wsize == 0) {
-        state->wsize = 1U << state->wbits;
-        state->write = 0;
-        state->whave = 0;
-    }
-
-    /* copy state->wsize or less output bytes into the circular window */
-    copy = out - strm->avail_out;
-    if (copy >= state->wsize) {
-        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
-        state->write = 0;
-        state->whave = state->wsize;
-    }
-    else {
-        dist = state->wsize - state->write;
-        if (dist > copy) dist = copy;
-        zmemcpy(state->window + state->write, strm->next_out - copy, dist);
-        copy -= dist;
-        if (copy) {
-            zmemcpy(state->window, strm->next_out - copy, copy);
-            state->write = copy;
-            state->whave = state->wsize;
-        }
-        else {
-            state->write += dist;
-            if (state->write == state->wsize) state->write = 0;
-            if (state->whave < state->wsize) state->whave += dist;
-        }
-    }
-    return 0;
-}
-
-/* Macros for inflate(): */
-
-/* check function to use adler32() for zlib or crc32() for gzip */
-#ifdef GUNZIP
-#  define UPDATE(check, buf, len) \
-    (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
-#else
-#  define UPDATE(check, buf, len) adler32(check, buf, len)
-#endif
-
-/* check macros for header crc */
-#ifdef GUNZIP
-#  define CRC2(check, word) \
-    do { \
-        hbuf[0] = (unsigned char)(word); \
-        hbuf[1] = (unsigned char)((word) >> 8); \
-        check = crc32(check, hbuf, 2); \
-    } while (0)
-
-#  define CRC4(check, word) \
-    do { \
-        hbuf[0] = (unsigned char)(word); \
-        hbuf[1] = (unsigned char)((word) >> 8); \
-        hbuf[2] = (unsigned char)((word) >> 16); \
-        hbuf[3] = (unsigned char)((word) >> 24); \
-        check = crc32(check, hbuf, 4); \
-    } while (0)
-#endif
-
-/* Load registers with state in inflate() for speed */
-#define LOAD() \
-    do { \
-        put = strm->next_out; \
-        left = strm->avail_out; \
-        next = strm->next_in; \
-        have = strm->avail_in; \
-        hold = state->hold; \
-        bits = state->bits; \
-    } while (0)
-
-/* Restore state from registers in inflate() */
-#define RESTORE() \
-    do { \
-        strm->next_out = put; \
-        strm->avail_out = left; \
-        strm->next_in = next; \
-        strm->avail_in = have; \
-        state->hold = hold; \
-        state->bits = bits; \
-    } while (0)
-
-/* Clear the input bit accumulator */
-#define INITBITS() \
-    do { \
-        hold = 0; \
-        bits = 0; \
-    } while (0)
-
-/* Get a byte of input into the bit accumulator, or return from inflate()
-   if there is no input available. */
-#define PULLBYTE() \
-    do { \
-        if (have == 0) goto inf_leave; \
-        have--; \
-        hold += (unsigned long)(*next++) << bits; \
-        bits += 8; \
-    } while (0)
-
-/* Assure that there are at least n bits in the bit accumulator.  If there is
-   not enough available input to do that, then return from inflate(). */
-#define NEEDBITS(n) \
-    do { \
-        while (bits < (unsigned)(n)) \
-            PULLBYTE(); \
-    } while (0)
-
-/* Return the low n bits of the bit accumulator (n < 16) */
-#define BITS(n) \
-    ((unsigned)hold & ((1U << (n)) - 1))
-
-/* Remove n bits from the bit accumulator */
-#define DROPBITS(n) \
-    do { \
-        hold >>= (n); \
-        bits -= (unsigned)(n); \
-    } while (0)
-
-/* Remove zero to seven bits as needed to go to a byte boundary */
-#define BYTEBITS() \
-    do { \
-        hold >>= bits & 7; \
-        bits -= bits & 7; \
-    } while (0)
-
-/* Reverse the bytes in a 32-bit value */
-#define REVERSE(q) \
-    ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
-     (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))
-
-/*
-   inflate() uses a state machine to process as much input data and generate as
-   much output data as possible before returning.  The state machine is
-   structured roughly as follows:
-
-    for (;;) switch (state) {
-    ...
-    case STATEn:
-        if (not enough input data or output space to make progress)
-            return;
-        ... make progress ...
-        state = STATEm;
-        break;
-    ...
-    }
-
-   so when inflate() is called again, the same case is attempted again, and
-   if the appropriate resources are provided, the machine proceeds to the
-   next state.  The NEEDBITS() macro is usually the way the state evaluates
-   whether it can proceed or should return.  NEEDBITS() does the return if
-   the requested bits are not available.  The typical use of the BITS macros
-   is:
-
-        NEEDBITS(n);
-        ... do something with BITS(n) ...
-        DROPBITS(n);
-
-   where NEEDBITS(n) either returns from inflate() if there isn't enough
-   input left to load n bits into the accumulator, or it continues.  BITS(n)
-   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
-   the low n bits off the accumulator.  INITBITS() clears the accumulator
-   and sets the number of available bits to zero.  BYTEBITS() discards just
-   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
-   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.
-
-   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
-   if there is no input available.  The decoding of variable length codes uses
-   PULLBYTE() directly in order to pull just enough bytes to decode the next
-   code, and no more.
-
-   Some states loop until they get enough input, making sure that enough
-   state information is maintained to continue the loop where it left off
-   if NEEDBITS() returns in the loop.  For example, want, need, and keep
-   would all have to actually be part of the saved state in case NEEDBITS()
-   returns:
-
-    case STATEw:
-        while (want < need) {
-            NEEDBITS(n);
-            keep[want++] = BITS(n);
-            DROPBITS(n);
-        }
-        state = STATEx;
-    case STATEx:
-
-   As shown above, if the next state is also the next case, then the break
-   is omitted.
-
-   A state may also return if there is not enough output space available to
-   complete that state.  Those states are copying stored data, writing a
-   literal byte, and copying a matching string.
-
-   When returning, a "goto inf_leave" is used to update the total counters,
-   update the check value, and determine whether any progress has been made
-   during that inflate() call in order to return the proper return code.
-   Progress is defined as a change in either strm->avail_in or strm->avail_out.
-   When there is a window, goto inf_leave will update the window with the last
-   output written.  If a goto inf_leave occurs in the middle of decompression
-   and there is no window currently, goto inf_leave will create one and copy
-   output to the window for the next call of inflate().
-
-   In this implementation, the flush parameter of inflate() only affects the
-   return code (per zlib.h).  inflate() always writes as much as possible to
-   strm->next_out, given the space available and the provided input--the effect
-   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
-   the allocation of and copying into a sliding window until necessary, which
-   provides the effect documented in zlib.h for Z_FINISH when the entire input
-   stream available.  So the only thing the flush parameter actually does is:
-   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
-   will return Z_BUF_ERROR if it has not reached the end of the stream.
- */
-
-int ZEXPORT inflate(strm, flush)
-z_streamp strm;
-int flush;
-{
-    struct inflate_state FAR *state;
-    unsigned char FAR *next;    /* next input */
-    unsigned char FAR *put;     /* next output */
-    unsigned have, left;        /* available input and output */
-    unsigned long hold;         /* bit buffer */
-    unsigned bits;              /* bits in bit buffer */
-    unsigned in, out;           /* save starting available input and output */
-    unsigned copy;              /* number of stored or match bytes to copy */
-    unsigned char FAR *from;    /* where to copy match bytes from */
-    code this;                  /* current decoding table entry */
-    code last;                  /* parent table entry */
-    unsigned len;               /* length to copy for repeats, bits to drop */
-    int ret;                    /* return code */
-#ifdef GUNZIP
-    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
-#endif
-    static const unsigned short order[19] = /* permutation of code lengths */
-        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-
-    if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
-        (strm->next_in == Z_NULL && strm->avail_in != 0))
-        return Z_STREAM_ERROR;
-
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
-    LOAD();
-    in = have;
-    out = left;
-    ret = Z_OK;
-    for (;;)
-        switch (state->mode) {
-        case HEAD:
-            if (state->wrap == 0) {
-                state->mode = TYPEDO;
-                break;
-            }
-            NEEDBITS(16);
-#ifdef GUNZIP
-            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
-                state->check = crc32(0L, Z_NULL, 0);
-                CRC2(state->check, hold);
-                INITBITS();
-                state->mode = FLAGS;
-                break;
-            }
-            state->flags = 0;           /* expect zlib header */
-            if (state->head != Z_NULL)
-                state->head->done = -1;
-            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
-#else
-            if (
-#endif
-                ((BITS(8) << 8) + (hold >> 8)) % 31) {
-                strm->msg = (char *)"incorrect header check";
-                state->mode = BAD;
-                break;
-            }
-            if (BITS(4) != Z_DEFLATED) {
-                strm->msg = (char *)"unknown compression method";
-                state->mode = BAD;
-                break;
-            }
-            DROPBITS(4);
-            len = BITS(4) + 8;
-            if (len > state->wbits) {
-                strm->msg = (char *)"invalid window size";
-                state->mode = BAD;
-                break;
-            }
-            state->dmax = 1U << len;
-            Tracev((stderr, "inflate:   zlib header ok\n"));
-            strm->adler = state->check = adler32(0L, Z_NULL, 0);
-            state->mode = hold & 0x200 ? DICTID : TYPE;
-            INITBITS();
-            break;
-#ifdef GUNZIP
-        case FLAGS:
-            NEEDBITS(16);
-            state->flags = (int)(hold);
-            if ((state->flags & 0xff) != Z_DEFLATED) {
-                strm->msg = (char *)"unknown compression method";
-                state->mode = BAD;
-                break;
-            }
-            if (state->flags & 0xe000) {
-                strm->msg = (char *)"unknown header flags set";
-                state->mode = BAD;
-                break;
-            }
-            if (state->head != Z_NULL)
-                state->head->text = (int)((hold >> 8) & 1);
-            if (state->flags & 0x0200) CRC2(state->check, hold);
-            INITBITS();
-            state->mode = TIME;
-        case TIME:
-            NEEDBITS(32);
-            if (state->head != Z_NULL)
-                state->head->time = hold;
-            if (state->flags & 0x0200) CRC4(state->check, hold);
-            INITBITS();
-            state->mode = OS;
-        case OS:
-            NEEDBITS(16);
-            if (state->head != Z_NULL) {
-                state->head->xflags = (int)(hold & 0xff);
-                state->head->os = (int)(hold >> 8);
-            }
-            if (state->flags & 0x0200) CRC2(state->check, hold);
-            INITBITS();
-            state->mode = EXLEN;
-        case EXLEN:
-            if (state->flags & 0x0400) {
-                NEEDBITS(16);
-                state->length = (unsigned)(hold);
-                if (state->head != Z_NULL)
-                    state->head->extra_len = (unsigned)hold;
-                if (state->flags & 0x0200) CRC2(state->check, hold);
-                INITBITS();
-            }
-            else if (state->head != Z_NULL)
-                state->head->extra = Z_NULL;
-            state->mode = EXTRA;
-        case EXTRA:
-            if (state->flags & 0x0400) {
-                copy = state->length;
-                if (copy > have) copy = have;
-                if (copy) {
-                    if (state->head != Z_NULL &&
-                        state->head->extra != Z_NULL) {
-                        len = state->head->extra_len - state->length;
-                        zmemcpy(state->head->extra + len, next,
-                                len + copy > state->head->extra_max ?
-                                state->head->extra_max - len : copy);
-                    }
-                    if (state->flags & 0x0200)
-                        state->check = crc32(state->check, next, copy);
-                    have -= copy;
-                    next += copy;
-                    state->length -= copy;
-                }
-                if (state->length) goto inf_leave;
-            }
-            state->length = 0;
-            state->mode = NAME;
-        case NAME:
-            if (state->flags & 0x0800) {
-                if (have == 0) goto inf_leave;
-                copy = 0;
-                do {
-                    len = (unsigned)(next[copy++]);
-                    if (state->head != Z_NULL &&
-                            state->head->name != Z_NULL &&
-                            state->length < state->head->name_max)
-                        state->head->name[state->length++] = len;
-                } while (len && copy < have);
-                if (state->flags & 0x0200)
-                    state->check = crc32(state->check, next, copy);
-                have -= copy;
-                next += copy;
-                if (len) goto inf_leave;
-            }
-            else if (state->head != Z_NULL)
-                state->head->name = Z_NULL;
-            state->length = 0;
-            state->mode = COMMENT;
-        case COMMENT:
-            if (state->flags & 0x1000) {
-                if (have == 0) goto inf_leave;
-                copy = 0;
-                do {
-                    len = (unsigned)(next[copy++]);
-                    if (state->head != Z_NULL &&
-                            state->head->comment != Z_NULL &&
-                            state->length < state->head->comm_max)
-                        state->head->comment[state->length++] = len;
-                } while (len && copy < have);
-                if (state->flags & 0x0200)
-                    state->check = crc32(state->check, next, copy);
-                have -= copy;
-                next += copy;
-                if (len) goto inf_leave;
-            }
-            else if (state->head != Z_NULL)
-                state->head->comment = Z_NULL;
-            state->mode = HCRC;
-        case HCRC:
-            if (state->flags & 0x0200) {
-                NEEDBITS(16);
-                if (hold != (state->check & 0xffff)) {
-                    strm->msg = (char *)"header crc mismatch";
-                    state->mode = BAD;
-                    break;
-                }
-                INITBITS();
-            }
-            if (state->head != Z_NULL) {
-                state->head->hcrc = (int)((state->flags >> 9) & 1);
-                state->head->done = 1;
-            }
-            strm->adler = state->check = crc32(0L, Z_NULL, 0);
-            state->mode = TYPE;
-            break;
-#endif
-        case DICTID:
-            NEEDBITS(32);
-            strm->adler = state->check = REVERSE(hold);
-            INITBITS();
-            state->mode = DICT;
-        case DICT:
-            if (state->havedict == 0) {
-                RESTORE();
-                return Z_NEED_DICT;
-            }
-            strm->adler = state->check = adler32(0L, Z_NULL, 0);
-            state->mode = TYPE;
-        case TYPE:
-            if (flush == Z_BLOCK) goto inf_leave;
-        case TYPEDO:
-            if (state->last) {
-                BYTEBITS();
-                state->mode = CHECK;
-                break;
-            }
-            NEEDBITS(3);
-            state->last = BITS(1);
-            DROPBITS(1);
-            switch (BITS(2)) {
-            case 0:                             /* stored block */
-                Tracev((stderr, "inflate:     stored block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = STORED;
-                break;
-            case 1:                             /* fixed block */
-                fixedtables(state);
-                Tracev((stderr, "inflate:     fixed codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = LEN;              /* decode codes */
-                break;
-            case 2:                             /* dynamic block */
-                Tracev((stderr, "inflate:     dynamic codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = TABLE;
-                break;
-            case 3:
-                strm->msg = (char *)"invalid block type";
-                state->mode = BAD;
-            }
-            DROPBITS(2);
-            break;
-        case STORED:
-            BYTEBITS();                         /* go to byte boundary */
-            NEEDBITS(32);
-            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
-                strm->msg = (char *)"invalid stored block lengths";
-                state->mode = BAD;
-                break;
-            }
-            state->length = (unsigned)hold & 0xffff;
-            Tracev((stderr, "inflate:       stored length %u\n",
-                    state->length));
-            INITBITS();
-            state->mode = COPY;
-        case COPY:
-            copy = state->length;
-            if (copy) {
-                if (copy > have) copy = have;
-                if (copy > left) copy = left;
-                if (copy == 0) goto inf_leave;
-                zmemcpy(put, next, copy);
-                have -= copy;
-                next += copy;
-                left -= copy;
-                put += copy;
-                state->length -= copy;
-                break;
-            }
-            Tracev((stderr, "inflate:       stored end\n"));
-            state->mode = TYPE;
-            break;
-        case TABLE:
-            NEEDBITS(14);
-            state->nlen = BITS(5) + 257;
-            DROPBITS(5);
-            state->ndist = BITS(5) + 1;
-            DROPBITS(5);
-            state->ncode = BITS(4) + 4;
-            DROPBITS(4);
-#ifndef PKZIP_BUG_WORKAROUND
-            if (state->nlen > 286 || state->ndist > 30) {
-                strm->msg = (char *)"too many length or distance symbols";
-                state->mode = BAD;
-                break;
-            }
-#endif
-            Tracev((stderr, "inflate:       table sizes ok\n"));
-            state->have = 0;
-            state->mode = LENLENS;
-        case LENLENS:
-            while (state->have < state->ncode) {
-                NEEDBITS(3);
-                state->lens[order[state->have++]] = (unsigned short)BITS(3);
-                DROPBITS(3);
-            }
-            while (state->have < 19)
-                state->lens[order[state->have++]] = 0;
-            state->next = state->codes;
-            state->lencode = (code const FAR *)(state->next);
-            state->lenbits = 7;
-            ret = inflate_table(CODES, state->lens, 19, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid code lengths set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       code lengths ok\n"));
-            state->have = 0;
-            state->mode = CODELENS;
-        case CODELENS:
-            while (state->have < state->nlen + state->ndist) {
-                for (;;) {
-                    this = state->lencode[BITS(state->lenbits)];
-                    if ((unsigned)(this.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                if (this.val < 16) {
-                    NEEDBITS(this.bits);
-                    DROPBITS(this.bits);
-                    state->lens[state->have++] = this.val;
-                }
-                else {
-                    if (this.val == 16) {
-                        NEEDBITS(this.bits + 2);
-                        DROPBITS(this.bits);
-                        if (state->have == 0) {
-                            strm->msg = (char *)"invalid bit length repeat";
-                            state->mode = BAD;
-                            break;
-                        }
-                        len = state->lens[state->have - 1];
-                        copy = 3 + BITS(2);
-                        DROPBITS(2);
-                    }
-                    else if (this.val == 17) {
-                        NEEDBITS(this.bits + 3);
-                        DROPBITS(this.bits);
-                        len = 0;
-                        copy = 3 + BITS(3);
-                        DROPBITS(3);
-                    }
-                    else {
-                        NEEDBITS(this.bits + 7);
-                        DROPBITS(this.bits);
-                        len = 0;
-                        copy = 11 + BITS(7);
-                        DROPBITS(7);
-                    }
-                    if (state->have + copy > state->nlen + state->ndist) {
-                        strm->msg = (char *)"invalid bit length repeat";
-                        state->mode = BAD;
-                        break;
-                    }
-                    while (copy--)
-                        state->lens[state->have++] = (unsigned short)len;
-                }
-            }
-
-            /* handle error breaks in while */
-            if (state->mode == BAD) break;
-
-            /* build code tables */
-            state->next = state->codes;
-            state->lencode = (code const FAR *)(state->next);
-            state->lenbits = 9;
-            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid literal/lengths set";
-                state->mode = BAD;
-                break;
-            }
-            state->distcode = (code const FAR *)(state->next);
-            state->distbits = 6;
-            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
-                            &(state->next), &(state->distbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid distances set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       codes ok\n"));
-            state->mode = LEN;
-        case LEN:
-            if (have >= 6 && left >= 258) {
-                RESTORE();
-                inflate_fast(strm, out);
-                LOAD();
-                break;
-            }
-            for (;;) {
-                this = state->lencode[BITS(state->lenbits)];
-                if ((unsigned)(this.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if (this.op && (this.op & 0xf0) == 0) {
-                last = this;
-                for (;;) {
-                    this = state->lencode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + this.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-            }
-            DROPBITS(this.bits);
-            state->length = (unsigned)this.val;
-            if ((int)(this.op) == 0) {
-                Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
-                        "inflate:         literal '%c'\n" :
-                        "inflate:         literal 0x%02x\n", this.val));
-                state->mode = LIT;
-                break;
-            }
-            if (this.op & 32) {
-                Tracevv((stderr, "inflate:         end of block\n"));
-                state->mode = TYPE;
-                break;
-            }
-            if (this.op & 64) {
-                strm->msg = (char *)"invalid literal/length code";
-                state->mode = BAD;
-                break;
-            }
-            state->extra = (unsigned)(this.op) & 15;
-            state->mode = LENEXT;
-        case LENEXT:
-            if (state->extra) {
-                NEEDBITS(state->extra);
-                state->length += BITS(state->extra);
-                DROPBITS(state->extra);
-            }
-            Tracevv((stderr, "inflate:         length %u\n", state->length));
-            state->mode = DIST;
-        case DIST:
-            for (;;) {
-                this = state->distcode[BITS(state->distbits)];
-                if ((unsigned)(this.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if ((this.op & 0xf0) == 0) {
-                last = this;
-                for (;;) {
-                    this = state->distcode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + this.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-            }
-            DROPBITS(this.bits);
-            if (this.op & 64) {
-                strm->msg = (char *)"invalid distance code";
-                state->mode = BAD;
-                break;
-            }
-            state->offset = (unsigned)this.val;
-            state->extra = (unsigned)(this.op) & 15;
-            state->mode = DISTEXT;
-        case DISTEXT:
-            if (state->extra) {
-                NEEDBITS(state->extra);
-                state->offset += BITS(state->extra);
-                DROPBITS(state->extra);
-            }
-#ifdef INFLATE_STRICT
-            if (state->offset > state->dmax) {
-                strm->msg = (char *)"invalid distance too far back";
-                state->mode = BAD;
-                break;
-            }
-#endif
-            if (state->offset > state->whave + out - left) {
-                strm->msg = (char *)"invalid distance too far back";
-                state->mode = BAD;
-                break;
-            }
-            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
-            state->mode = MATCH;
-        case MATCH:
-            if (left == 0) goto inf_leave;
-            copy = out - left;
-            if (state->offset > copy) {         /* copy from window */
-                copy = state->offset - copy;
-                if (copy > state->write) {
-                    copy -= state->write;
-                    from = state->window + (state->wsize - copy);
-                }
-                else
-                    from = state->window + (state->write - copy);
-                if (copy > state->length) copy = state->length;
-            }
-            else {                              /* copy from output */
-                from = put - state->offset;
-                copy = state->length;
-            }
-            if (copy > left) copy = left;
-            left -= copy;
-            state->length -= copy;
-            do {
-                *put++ = *from++;
-            } while (--copy);
-            if (state->length == 0) state->mode = LEN;
-            break;
-        case LIT:
-            if (left == 0) goto inf_leave;
-            *put++ = (unsigned char)(state->length);
-            left--;
-            state->mode = LEN;
-            break;
-        case CHECK:
-            if (state->wrap) {
-                NEEDBITS(32);
-                out -= left;
-                strm->total_out += out;
-                state->total += out;
-                if (out)
-                    strm->adler = state->check =
-                        UPDATE(state->check, put - out, out);
-                out = left;
-                if ((
-#ifdef GUNZIP
-                     state->flags ? hold :
-#endif
-                     REVERSE(hold)) != state->check) {
-                    strm->msg = (char *)"incorrect data check";
-                    state->mode = BAD;
-                    break;
-                }
-                INITBITS();
-                Tracev((stderr, "inflate:   check matches trailer\n"));
-            }
-#ifdef GUNZIP
-            state->mode = LENGTH;
-        case LENGTH:
-            if (state->wrap && state->flags) {
-                NEEDBITS(32);
-                if (hold != (state->total & 0xffffffffUL)) {
-                    strm->msg = (char *)"incorrect length check";
-                    state->mode = BAD;
-                    break;
-                }
-                INITBITS();
-                Tracev((stderr, "inflate:   length matches trailer\n"));
-            }
-#endif
-            state->mode = DONE;
-        case DONE:
-            ret = Z_STREAM_END;
-            goto inf_leave;
-        case BAD:
-            ret = Z_DATA_ERROR;
-            goto inf_leave;
-        case MEM:
-            return Z_MEM_ERROR;
-        case SYNC:
-        default:
-            return Z_STREAM_ERROR;
-        }
-
-    /*
-       Return from inflate(), updating the total counts and the check value.
-       If there was no progress during the inflate() call, return a buffer
-       error.  Call updatewindow() to create and/or update the window state.
-       Note: a memory error from inflate() is non-recoverable.
-     */
-  inf_leave:
-    RESTORE();
-    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
-        if (updatewindow(strm, out)) {
-            state->mode = MEM;
-            return Z_MEM_ERROR;
-        }
-    in -= strm->avail_in;
-    out -= strm->avail_out;
-    strm->total_in += in;
-    strm->total_out += out;
-    state->total += out;
-    if (state->wrap && out)
-        strm->adler = state->check =
-            UPDATE(state->check, strm->next_out - out, out);
-    strm->data_type = state->bits + (state->last ? 64 : 0) +
-                      (state->mode == TYPE ? 128 : 0);
-    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
-        ret = Z_BUF_ERROR;
-    return ret;
-}
-
-int ZEXPORT inflateEnd(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->window != Z_NULL) ZFREE(strm, state->window);
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-    Tracev((stderr, "inflate: end\n"));
-    return Z_OK;
-}
-
-int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
-z_streamp strm;
-const Bytef *dictionary;
-uInt dictLength;
-{
-    struct inflate_state FAR *state;
-    unsigned long id;
-
-    /* check state */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->wrap != 0 && state->mode != DICT)
-        return Z_STREAM_ERROR;
-
-    /* check for correct dictionary id */
-    if (state->mode == DICT) {
-        id = adler32(0L, Z_NULL, 0);
-        id = adler32(id, dictionary, dictLength);
-        if (id != state->check)
-            return Z_DATA_ERROR;
-    }
-
-    /* copy dictionary to window */
-    if (updatewindow(strm, strm->avail_out)) {
-        state->mode = MEM;
-        return Z_MEM_ERROR;
-    }
-    if (dictLength > state->wsize) {
-        zmemcpy(state->window, dictionary + dictLength - state->wsize,
-                state->wsize);
-        state->whave = state->wsize;
-    }
-    else {
-        zmemcpy(state->window + state->wsize - dictLength, dictionary,
-                dictLength);
-        state->whave = dictLength;
-    }
-    state->havedict = 1;
-    Tracev((stderr, "inflate:   dictionary set\n"));
-    return Z_OK;
-}
-
-int ZEXPORT inflateGetHeader(strm, head)
-z_streamp strm;
-gz_headerp head;
-{
-    struct inflate_state FAR *state;
-
-    /* check state */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;
-
-    /* save header structure */
-    state->head = head;
-    head->done = 0;
-    return Z_OK;
-}
-
-/*
-   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
-   or when out of input.  When called, *have is the number of pattern bytes
-   found in order so far, in 0..3.  On return *have is updated to the new
-   state.  If on return *have equals four, then the pattern was found and the
-   return value is how many bytes were read including the last byte of the
-   pattern.  If *have is less than four, then the pattern has not been found
-   yet and the return value is len.  In the latter case, syncsearch() can be
-   called again with more data and the *have state.  *have is initialized to
-   zero for the first call.
- */
-local unsigned syncsearch(have, buf, len)
-unsigned FAR *have;
-unsigned char FAR *buf;
-unsigned len;
-{
-    unsigned got;
-    unsigned next;
-
-    got = *have;
-    next = 0;
-    while (next < len && got < 4) {
-        if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))
-            got++;
-        else if (buf[next])
-            got = 0;
-        else
-            got = 4 - got;
-        next++;
-    }
-    *have = got;
-    return next;
-}
-
-int ZEXPORT inflateSync(strm)
-z_streamp strm;
-{
-    unsigned len;               /* number of bytes to look at or looked at */
-    unsigned long in, out;      /* temporary to save total_in and total_out */
-    unsigned char buf[4];       /* to restore bit buffer to byte string */
-    struct inflate_state FAR *state;
-
-    /* check parameters */
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;
-
-    /* if first time, start search in bit buffer */
-    if (state->mode != SYNC) {
-        state->mode = SYNC;
-        state->hold <<= state->bits & 7;
-        state->bits -= state->bits & 7;
-        len = 0;
-        while (state->bits >= 8) {
-            buf[len++] = (unsigned char)(state->hold);
-            state->hold >>= 8;
-            state->bits -= 8;
-        }
-        state->have = 0;
-        syncsearch(&(state->have), buf, len);
-    }
-
-    /* search available input */
-    len = syncsearch(&(state->have), strm->next_in, strm->avail_in);
-    strm->avail_in -= len;
-    strm->next_in += len;
-    strm->total_in += len;
-
-    /* return no joy or set up to restart inflate() on a new block */
-    if (state->have != 4) return Z_DATA_ERROR;
-    in = strm->total_in;  out = strm->total_out;
-    inflateReset(strm);
-    strm->total_in = in;  strm->total_out = out;
-    state->mode = TYPE;
-    return Z_OK;
-}
-
-/*
-   Returns true if inflate is currently at the end of a block generated by
-   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
-   implementation to provide an additional safety check. PPP uses
-   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
-   block. When decompressing, PPP checks that at the end of input packet,
-   inflate is waiting for these length bytes.
- */
-int ZEXPORT inflateSyncPoint(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-
-    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    return state->mode == STORED && state->bits == 0;
-}
-
-int ZEXPORT inflateCopy(dest, source)
-z_streamp dest;
-z_streamp source;
-{
-    struct inflate_state FAR *state;
-    struct inflate_state FAR *copy;
-    unsigned char FAR *window;
-    unsigned wsize;
-
-    /* check input */
-    if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
-        source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)source->state;
-
-    /* allocate space */
-    copy = (struct inflate_state FAR *)
-           ZALLOC(source, 1, sizeof(struct inflate_state));
-    if (copy == Z_NULL) return Z_MEM_ERROR;
-    window = Z_NULL;
-    if (state->window != Z_NULL) {
-        window = (unsigned char FAR *)
-                 ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
-        if (window == Z_NULL) {
-            ZFREE(source, copy);
-            return Z_MEM_ERROR;
-        }
-    }
-
-    /* copy state */
-    zmemcpy(dest, source, sizeof(z_stream));
-    zmemcpy(copy, state, sizeof(struct inflate_state));
-    if (state->lencode >= state->codes &&
-        state->lencode <= state->codes + ENOUGH - 1) {
-        copy->lencode = copy->codes + (state->lencode - state->codes);
-        copy->distcode = copy->codes + (state->distcode - state->codes);
-    }
-    copy->next = copy->codes + (state->next - state->codes);
-    if (window != Z_NULL) {
-        wsize = 1U << state->wbits;
-        zmemcpy(window, state->window, wsize);
-    }
-    copy->window = window;
-    dest->state = (struct internal_state FAR *)copy;
-    return Z_OK;
-}
diff -Nbaur gcc-4.6.3/zlib/inflate.h gcc-4.6.3-psp/zlib/inflate.h
--- gcc-4.6.3/zlib/inflate.h	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/inflate.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,115 +0,0 @@
-/* inflate.h -- internal inflate state definition
- * Copyright (C) 1995-2004 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* define NO_GZIP when compiling if you want to disable gzip header and
-   trailer decoding by inflate().  NO_GZIP would be used to avoid linking in
-   the crc code when it is not needed.  For shared libraries, gzip decoding
-   should be left enabled. */
-#ifndef NO_GZIP
-#  define GUNZIP
-#endif
-
-/* Possible inflate modes between inflate() calls */
-typedef enum {
-    HEAD,       /* i: waiting for magic header */
-    FLAGS,      /* i: waiting for method and flags (gzip) */
-    TIME,       /* i: waiting for modification time (gzip) */
-    OS,         /* i: waiting for extra flags and operating system (gzip) */
-    EXLEN,      /* i: waiting for extra length (gzip) */
-    EXTRA,      /* i: waiting for extra bytes (gzip) */
-    NAME,       /* i: waiting for end of file name (gzip) */
-    COMMENT,    /* i: waiting for end of comment (gzip) */
-    HCRC,       /* i: waiting for header crc (gzip) */
-    DICTID,     /* i: waiting for dictionary check value */
-    DICT,       /* waiting for inflateSetDictionary() call */
-        TYPE,       /* i: waiting for type bits, including last-flag bit */
-        TYPEDO,     /* i: same, but skip check to exit inflate on new block */
-        STORED,     /* i: waiting for stored size (length and complement) */
-        COPY,       /* i/o: waiting for input or output to copy stored block */
-        TABLE,      /* i: waiting for dynamic block table lengths */
-        LENLENS,    /* i: waiting for code length code lengths */
-        CODELENS,   /* i: waiting for length/lit and distance code lengths */
-            LEN,        /* i: waiting for length/lit code */
-            LENEXT,     /* i: waiting for length extra bits */
-            DIST,       /* i: waiting for distance code */
-            DISTEXT,    /* i: waiting for distance extra bits */
-            MATCH,      /* o: waiting for output space to copy string */
-            LIT,        /* o: waiting for output space to write literal */
-    CHECK,      /* i: waiting for 32-bit check value */
-    LENGTH,     /* i: waiting for 32-bit length (gzip) */
-    DONE,       /* finished check, done -- remain here until reset */
-    BAD,        /* got a data error -- remain here until reset */
-    MEM,        /* got an inflate() memory error -- remain here until reset */
-    SYNC        /* looking for synchronization bytes to restart inflate() */
-} inflate_mode;
-
-/*
-    State transitions between above modes -
-
-    (most modes can go to the BAD or MEM mode -- not shown for clarity)
-
-    Process header:
-        HEAD -> (gzip) or (zlib)
-        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME
-        NAME -> COMMENT -> HCRC -> TYPE
-        (zlib) -> DICTID or TYPE
-        DICTID -> DICT -> TYPE
-    Read deflate blocks:
-            TYPE -> STORED or TABLE or LEN or CHECK
-            STORED -> COPY -> TYPE
-            TABLE -> LENLENS -> CODELENS -> LEN
-    Read deflate codes:
-                LEN -> LENEXT or LIT or TYPE
-                LENEXT -> DIST -> DISTEXT -> MATCH -> LEN
-                LIT -> LEN
-    Process trailer:
-        CHECK -> LENGTH -> DONE
- */
-
-/* state maintained between inflate() calls.  Approximately 7K bytes. */
-struct inflate_state {
-    inflate_mode mode;          /* current inflate mode */
-    int last;                   /* true if processing last block */
-    int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip */
-    int havedict;               /* true if dictionary provided */
-    int flags;                  /* gzip header method and flags (0 if zlib) */
-    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */
-    unsigned long check;        /* protected copy of check value */
-    unsigned long total;        /* protected copy of output count */
-    gz_headerp head;            /* where to save gzip header information */
-        /* sliding window */
-    unsigned wbits;             /* log base 2 of requested window size */
-    unsigned wsize;             /* window size or zero if not using window */
-    unsigned whave;             /* valid bytes in the window */
-    unsigned write;             /* window write index */
-    unsigned char FAR *window;  /* allocated sliding window, if needed */
-        /* bit accumulator */
-    unsigned long hold;         /* input bit accumulator */
-    unsigned bits;              /* number of bits in "in" */
-        /* for string and stored block copying */
-    unsigned length;            /* literal or length of data to copy */
-    unsigned offset;            /* distance back to copy string from */
-        /* for table and code decoding */
-    unsigned extra;             /* extra bits needed */
-        /* fixed and dynamic code tables */
-    code const FAR *lencode;    /* starting table for length/literal codes */
-    code const FAR *distcode;   /* starting table for distance codes */
-    unsigned lenbits;           /* index bits for lencode */
-    unsigned distbits;          /* index bits for distcode */
-        /* dynamic table building */
-    unsigned ncode;             /* number of code length code lengths */
-    unsigned nlen;              /* number of length code lengths */
-    unsigned ndist;             /* number of distance code lengths */
-    unsigned have;              /* number of code lengths in lens[] */
-    code FAR *next;             /* next available space in codes[] */
-    unsigned short lens[320];   /* temporary storage for code lengths */
-    unsigned short work[288];   /* work area for code table building */
-    code codes[ENOUGH];         /* space for code tables */
-};
diff -Nbaur gcc-4.6.3/zlib/inftrees.c gcc-4.6.3-psp/zlib/inftrees.c
--- gcc-4.6.3/zlib/inftrees.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/inftrees.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,329 +0,0 @@
-/* inftrees.c -- generate Huffman trees for efficient decoding
- * Copyright (C) 1995-2005 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-#include "zutil.h"
-#include "inftrees.h"
-
-#define MAXBITS 15
-
-const char inflate_copyright[] =
-   " inflate 1.2.3 Copyright 1995-2005 Mark Adler ";
-/*
-  If you use the zlib library in a product, an acknowledgment is welcome
-  in the documentation of your product. If for some reason you cannot
-  include such an acknowledgment, I would appreciate that you keep this
-  copyright string in the executable of your product.
- */
-
-/*
-   Build a set of tables to decode the provided canonical Huffman code.
-   The code lengths are lens[0..codes-1].  The result starts at *table,
-   whose indices are 0..2^bits-1.  work is a writable array of at least
-   lens shorts, which is used as a work area.  type is the type of code
-   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
-   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
-   on return points to the next available entry's address.  bits is the
-   requested root table index bits, and on return it is the actual root
-   table index bits.  It will differ if the request is greater than the
-   longest code or if it is less than the shortest code.
- */
-int inflate_table(type, lens, codes, table, bits, work)
-codetype type;
-unsigned short FAR *lens;
-unsigned codes;
-code FAR * FAR *table;
-unsigned FAR *bits;
-unsigned short FAR *work;
-{
-    unsigned len;               /* a code's length in bits */
-    unsigned sym;               /* index of code symbols */
-    unsigned min, max;          /* minimum and maximum code lengths */
-    unsigned root;              /* number of index bits for root table */
-    unsigned curr;              /* number of index bits for current table */
-    unsigned drop;              /* code bits to drop for sub-table */
-    int left;                   /* number of prefix codes available */
-    unsigned used;              /* code entries in table used */
-    unsigned huff;              /* Huffman code */
-    unsigned incr;              /* for incrementing code, index */
-    unsigned fill;              /* index for replicating entries */
-    unsigned low;               /* low bits for current root entry */
-    unsigned mask;              /* mask for low root bits */
-    code this;                  /* table entry for duplication */
-    code FAR *next;             /* next available space in table */
-    const unsigned short FAR *base;     /* base value table to use */
-    const unsigned short FAR *extra;    /* extra bits table to use */
-    int end;                    /* use base and extra for symbol > end */
-    unsigned short count[MAXBITS+1];    /* number of codes of each length */
-    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
-    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
-        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
-        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
-    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
-        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
-        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 201, 196};
-    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
-        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
-        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
-        8193, 12289, 16385, 24577, 0, 0};
-    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
-        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
-        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
-        28, 28, 29, 29, 64, 64};
-
-    /*
-       Process a set of code lengths to create a canonical Huffman code.  The
-       code lengths are lens[0..codes-1].  Each length corresponds to the
-       symbols 0..codes-1.  The Huffman code is generated by first sorting the
-       symbols by length from short to long, and retaining the symbol order
-       for codes with equal lengths.  Then the code starts with all zero bits
-       for the first code of the shortest length, and the codes are integer
-       increments for the same length, and zeros are appended as the length
-       increases.  For the deflate format, these bits are stored backwards
-       from their more natural integer increment ordering, and so when the
-       decoding tables are built in the large loop below, the integer codes
-       are incremented backwards.
-
-       This routine assumes, but does not check, that all of the entries in
-       lens[] are in the range 0..MAXBITS.  The caller must assure this.
-       1..MAXBITS is interpreted as that code length.  zero means that that
-       symbol does not occur in this code.
-
-       The codes are sorted by computing a count of codes for each length,
-       creating from that a table of starting indices for each length in the
-       sorted table, and then entering the symbols in order in the sorted
-       table.  The sorted table is work[], with that space being provided by
-       the caller.
-
-       The length counts are used for other purposes as well, i.e. finding
-       the minimum and maximum length codes, determining if there are any
-       codes at all, checking for a valid set of lengths, and looking ahead
-       at length counts to determine sub-table sizes when building the
-       decoding tables.
-     */
-
-    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
-    for (len = 0; len <= MAXBITS; len++)
-        count[len] = 0;
-    for (sym = 0; sym < codes; sym++)
-        count[lens[sym]]++;
-
-    /* bound code lengths, force root to be within code lengths */
-    root = *bits;
-    for (max = MAXBITS; max >= 1; max--)
-        if (count[max] != 0) break;
-    if (root > max) root = max;
-    if (max == 0) {                     /* no symbols to code at all */
-        this.op = (unsigned char)64;    /* invalid code marker */
-        this.bits = (unsigned char)1;
-        this.val = (unsigned short)0;
-        *(*table)++ = this;             /* make a table to force an error */
-        *(*table)++ = this;
-        *bits = 1;
-        return 0;     /* no symbols, but wait for decoding to report error */
-    }
-    for (min = 1; min <= MAXBITS; min++)
-        if (count[min] != 0) break;
-    if (root < min) root = min;
-
-    /* check for an over-subscribed or incomplete set of lengths */
-    left = 1;
-    for (len = 1; len <= MAXBITS; len++) {
-        left <<= 1;
-        left -= count[len];
-        if (left < 0) return -1;        /* over-subscribed */
-    }
-    if (left > 0 && (type == CODES || max != 1))
-        return -1;                      /* incomplete set */
-
-    /* generate offsets into symbol table for each length for sorting */
-    offs[1] = 0;
-    for (len = 1; len < MAXBITS; len++)
-        offs[len + 1] = offs[len] + count[len];
-
-    /* sort symbols by length, by symbol order within each length */
-    for (sym = 0; sym < codes; sym++)
-        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
-
-    /*
-       Create and fill in decoding tables.  In this loop, the table being
-       filled is at next and has curr index bits.  The code being used is huff
-       with length len.  That code is converted to an index by dropping drop
-       bits off of the bottom.  For codes where len is less than drop + curr,
-       those top drop + curr - len bits are incremented through all values to
-       fill the table with replicated entries.
-
-       root is the number of index bits for the root table.  When len exceeds
-       root, sub-tables are created pointed to by the root entry with an index
-       of the low root bits of huff.  This is saved in low to check for when a
-       new sub-table should be started.  drop is zero when the root table is
-       being filled, and drop is root when sub-tables are being filled.
-
-       When a new sub-table is needed, it is necessary to look ahead in the
-       code lengths to determine what size sub-table is needed.  The length
-       counts are used for this, and so count[] is decremented as codes are
-       entered in the tables.
-
-       used keeps track of how many table entries have been allocated from the
-       provided *table space.  It is checked when a LENS table is being made
-       against the space in *table, ENOUGH, minus the maximum space needed by
-       the worst case distance code, MAXD.  This should never happen, but the
-       sufficiency of ENOUGH has not been proven exhaustively, hence the check.
-       This assumes that when type == LENS, bits == 9.
-
-       sym increments through all symbols, and the loop terminates when
-       all codes of length max, i.e. all codes, have been processed.  This
-       routine permits incomplete codes, so another loop after this one fills
-       in the rest of the decoding tables with invalid code markers.
-     */
-
-    /* set up for code type */
-    switch (type) {
-    case CODES:
-        base = extra = work;    /* dummy value--not used */
-        end = 19;
-        break;
-    case LENS:
-        base = lbase;
-        base -= 257;
-        extra = lext;
-        extra -= 257;
-        end = 256;
-        break;
-    default:            /* DISTS */
-        base = dbase;
-        extra = dext;
-        end = -1;
-    }
-
-    /* initialize state for loop */
-    huff = 0;                   /* starting code */
-    sym = 0;                    /* starting code symbol */
-    len = min;                  /* starting code length */
-    next = *table;              /* current table to fill in */
-    curr = root;                /* current table index bits */
-    drop = 0;                   /* current bits to drop from code for index */
-    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
-    used = 1U << root;          /* use root table entries */
-    mask = used - 1;            /* mask for comparing low */
-
-    /* check available table space */
-    if (type == LENS && used >= ENOUGH - MAXD)
-        return 1;
-
-    /* process all codes and make table entries */
-    for (;;) {
-        /* create table entry */
-        this.bits = (unsigned char)(len - drop);
-        if ((int)(work[sym]) < end) {
-            this.op = (unsigned char)0;
-            this.val = work[sym];
-        }
-        else if ((int)(work[sym]) > end) {
-            this.op = (unsigned char)(extra[work[sym]]);
-            this.val = base[work[sym]];
-        }
-        else {
-            this.op = (unsigned char)(32 + 64);         /* end of block */
-            this.val = 0;
-        }
-
-        /* replicate for those indices with low len bits equal to huff */
-        incr = 1U << (len - drop);
-        fill = 1U << curr;
-        min = fill;                 /* save offset to next table */
-        do {
-            fill -= incr;
-            next[(huff >> drop) + fill] = this;
-        } while (fill != 0);
-
-        /* backwards increment the len-bit code huff */
-        incr = 1U << (len - 1);
-        while (huff & incr)
-            incr >>= 1;
-        if (incr != 0) {
-            huff &= incr - 1;
-            huff += incr;
-        }
-        else
-            huff = 0;
-
-        /* go to next symbol, update count, len */
-        sym++;
-        if (--(count[len]) == 0) {
-            if (len == max) break;
-            len = lens[work[sym]];
-        }
-
-        /* create new sub-table if needed */
-        if (len > root && (huff & mask) != low) {
-            /* if first time, transition to sub-tables */
-            if (drop == 0)
-                drop = root;
-
-            /* increment past last table */
-            next += min;            /* here min is 1 << curr */
-
-            /* determine length of next table */
-            curr = len - drop;
-            left = (int)(1 << curr);
-            while (curr + drop < max) {
-                left -= count[curr + drop];
-                if (left <= 0) break;
-                curr++;
-                left <<= 1;
-            }
-
-            /* check for enough space */
-            used += 1U << curr;
-            if (type == LENS && used >= ENOUGH - MAXD)
-                return 1;
-
-            /* point entry in root table to sub-table */
-            low = huff & mask;
-            (*table)[low].op = (unsigned char)curr;
-            (*table)[low].bits = (unsigned char)root;
-            (*table)[low].val = (unsigned short)(next - *table);
-        }
-    }
-
-    /*
-       Fill in rest of table for incomplete codes.  This loop is similar to the
-       loop above in incrementing huff for table indices.  It is assumed that
-       len is equal to curr + drop, so there is no loop needed to increment
-       through high index bits.  When the current sub-table is filled, the loop
-       drops back to the root table to fill in any remaining entries there.
-     */
-    this.op = (unsigned char)64;                /* invalid code marker */
-    this.bits = (unsigned char)(len - drop);
-    this.val = (unsigned short)0;
-    while (huff != 0) {
-        /* when done with sub-table, drop back to root table */
-        if (drop != 0 && (huff & mask) != low) {
-            drop = 0;
-            len = root;
-            next = *table;
-            this.bits = (unsigned char)len;
-        }
-
-        /* put invalid code marker in table */
-        next[huff >> drop] = this;
-
-        /* backwards increment the len-bit code huff */
-        incr = 1U << (len - 1);
-        while (huff & incr)
-            incr >>= 1;
-        if (incr != 0) {
-            huff &= incr - 1;
-            huff += incr;
-        }
-        else
-            huff = 0;
-    }
-
-    /* set return parameters */
-    *table += used;
-    *bits = root;
-    return 0;
-}
diff -Nbaur gcc-4.6.3/zlib/inftrees.h gcc-4.6.3-psp/zlib/inftrees.h
--- gcc-4.6.3/zlib/inftrees.h	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/inftrees.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,55 +0,0 @@
-/* inftrees.h -- header to use inftrees.c
- * Copyright (C) 1995-2005 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* Structure for decoding tables.  Each entry provides either the
-   information needed to do the operation requested by the code that
-   indexed that table entry, or it provides a pointer to another
-   table that indexes more bits of the code.  op indicates whether
-   the entry is a pointer to another table, a literal, a length or
-   distance, an end-of-block, or an invalid code.  For a table
-   pointer, the low four bits of op is the number of index bits of
-   that table.  For a length or distance, the low four bits of op
-   is the number of extra bits to get after the code.  bits is
-   the number of bits in this code or part of the code to drop off
-   of the bit buffer.  val is the actual byte to output in the case
-   of a literal, the base length or distance, or the offset from
-   the current table to the next table.  Each entry is four bytes. */
-typedef struct {
-    unsigned char op;           /* operation, extra bits, table bits */
-    unsigned char bits;         /* bits in this part of the code */
-    unsigned short val;         /* offset in table or code value */
-} code;
-
-/* op values as set by inflate_table():
-    00000000 - literal
-    0000tttt - table link, tttt != 0 is the number of table index bits
-    0001eeee - length or distance, eeee is the number of extra bits
-    01100000 - end of block
-    01000000 - invalid code
- */
-
-/* Maximum size of dynamic tree.  The maximum found in a long but non-
-   exhaustive search was 1444 code structures (852 for length/literals
-   and 592 for distances, the latter actually the result of an
-   exhaustive search).  The true maximum is not known, but the value
-   below is more than safe. */
-#define ENOUGH 2048
-#define MAXD 592
-
-/* Type of code to build for inftable() */
-typedef enum {
-    CODES,
-    LENS,
-    DISTS
-} codetype;
-
-extern int inflate_table OF((codetype type, unsigned short FAR *lens,
-                             unsigned codes, code FAR * FAR *table,
-                             unsigned FAR *bits, unsigned short FAR *work));
diff -Nbaur gcc-4.6.3/zlib/Makefile.am gcc-4.6.3-psp/zlib/Makefile.am
--- gcc-4.6.3/zlib/Makefile.am	2009-08-22 14:41:50.000000000 +0100
+++ gcc-4.6.3-psp/zlib/Makefile.am	1970-01-01 01:00:00.000000000 +0100
@@ -1,60 +0,0 @@
-## Process this file with automake to create Makefile.in.
-
-AUTOMAKE_OPTIONS = 1.8 cygnus
-
-ACLOCAL_AMFLAGS = -I .. -I ../config
-
-ZLIB_SOURCES = adler32.c compress.c crc32.c crc32.h deflate.c \
-deflate.h gzio.c infback.c inffast.c inffast.h inffixed.h inflate.c \
-inflate.h inftrees.c inftrees.h trees.c trees.h uncompr.c zconf.h \
-zconf.in.h zlib.h zutil.c zutil.h
-
-if TARGET_LIBRARY
-noinst_LTLIBRARIES = libzgcj_convenience.la
-libzgcj_convenience_la_SOURCES = $(ZLIB_SOURCES)
-else
-toolexeclib_LIBRARIES = libz.a
-libz_a_SOURCES = $(ZLIB_SOURCES)
-libz_a_CFLAGS = $(AM_CFLAGS)
-endif
-
-# Work around what appears to be a GNU make bug handling MAKEFLAGS
-# values defined in terms of make variables, as is the case for CC and
-# friends when we are called from the top level Makefile.
-AM_MAKEFLAGS = \
-	"AR_FLAGS=$(AR_FLAGS)" \
-	"CC_FOR_BUILD=$(CC_FOR_BUILD)" \
-	"CFLAGS=$(CFLAGS)" \
-	"CXXFLAGS=$(CXXFLAGS)" \
-	"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)" \
-	"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)" \
-	"INSTALL=$(INSTALL)" \
-	"INSTALL_DATA=$(INSTALL_DATA)" \
-	"INSTALL_PROGRAM=$(INSTALL_PROGRAM)" \
-	"INSTALL_SCRIPT=$(INSTALL_SCRIPT)" \
-	"LDFLAGS=$(LDFLAGS)" \
-	"LIBCFLAGS=$(LIBCFLAGS)" \
-	"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)" \
-	"MAKE=$(MAKE)" \
-	"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)" \
-	"PICFLAG=$(PICFLAG)" \
-	"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)" \
-	"SHELL=$(SHELL)" \
-	"EXPECT=$(EXPECT)" \
-	"RUNTEST=$(RUNTEST)" \
-	"RUNTESTFLAGS=$(RUNTESTFLAGS)" \
-	"exec_prefix=$(exec_prefix)" \
-	"infodir=$(infodir)" \
-	"libdir=$(libdir)" \
-	"prefix=$(prefix)" \
-	"tooldir=$(tooldir)" \
-	"AR=$(AR)" \
-	"AS=$(AS)" \
-	"CC=$(CC)" \
-	"CXX=$(CXX)" \
-	"LD=$(LD)" \
-	"LIBCFLAGS=$(LIBCFLAGS)" \
-	"NM=$(NM)" \
-	"PICFLAG=$(PICFLAG)" \
-	"RANLIB=$(RANLIB)" \
-	"DESTDIR=$(DESTDIR)"
diff -Nbaur gcc-4.6.3/zlib/Makefile.in gcc-4.6.3-psp/zlib/Makefile.in
--- gcc-4.6.3/zlib/Makefile.in	2010-04-02 19:18:06.000000000 +0100
+++ gcc-4.6.3-psp/zlib/Makefile.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,675 +0,0 @@
-# Makefile.in generated by automake 1.11.1 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
-# Inc.
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-@SET_MAKE@
-
-
-VPATH = @srcdir@
-pkgdatadir = $(datadir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkglibexecdir = $(libexecdir)/@PACKAGE@
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-target_triplet = @target@
-subdir = .
-DIST_COMMON = README ChangeLog $(srcdir)/Makefile.in \
-	$(srcdir)/Makefile.am $(top_srcdir)/configure \
-	$(am__configure_deps) $(srcdir)/../mkinstalldirs
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/../config/depstand.m4 \
-	$(top_srcdir)/../config/lead-dot.m4 \
-	$(top_srcdir)/../config/multi.m4 \
-	$(top_srcdir)/../config/override.m4 \
-	$(top_srcdir)/../ltoptions.m4 $(top_srcdir)/../ltsugar.m4 \
-	$(top_srcdir)/../ltversion.m4 $(top_srcdir)/../lt~obsolete.m4 \
-	$(top_srcdir)/acinclude.m4 \
-	$(top_srcdir)/../config/no-executables.m4 \
-	$(top_srcdir)/../libtool.m4 $(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
- configure.lineno config.status.lineno
-CONFIG_CLEAN_FILES =
-CONFIG_CLEAN_VPATH_FILES =
-am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
-am__vpath_adj = case $$p in \
-    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
-    *) f=$$p;; \
-  esac;
-am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
-am__install_max = 40
-am__nobase_strip_setup = \
-  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
-am__nobase_strip = \
-  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
-am__nobase_list = $(am__nobase_strip_setup); \
-  for p in $$list; do echo "$$p $$p"; done | \
-  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
-  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
-    if (++n[$$2] == $(am__install_max)) \
-      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
-    END { for (dir in files) print dir, files[dir] }'
-am__base_list = \
-  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
-  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
-am__installdirs = "$(DESTDIR)$(toolexeclibdir)"
-LIBRARIES = $(toolexeclib_LIBRARIES)
-ARFLAGS = cru
-libz_a_AR = $(AR) $(ARFLAGS)
-libz_a_LIBADD =
-am__objects_1 = libz_a-adler32.$(OBJEXT) libz_a-compress.$(OBJEXT) \
-	libz_a-crc32.$(OBJEXT) libz_a-deflate.$(OBJEXT) \
-	libz_a-gzio.$(OBJEXT) libz_a-infback.$(OBJEXT) \
-	libz_a-inffast.$(OBJEXT) libz_a-inflate.$(OBJEXT) \
-	libz_a-inftrees.$(OBJEXT) libz_a-trees.$(OBJEXT) \
-	libz_a-uncompr.$(OBJEXT) libz_a-zutil.$(OBJEXT)
-@TARGET_LIBRARY_FALSE@am_libz_a_OBJECTS = $(am__objects_1)
-libz_a_OBJECTS = $(am_libz_a_OBJECTS)
-LTLIBRARIES = $(noinst_LTLIBRARIES)
-libzgcj_convenience_la_LIBADD =
-am__objects_2 = adler32.lo compress.lo crc32.lo deflate.lo gzio.lo \
-	infback.lo inffast.lo inflate.lo inftrees.lo trees.lo \
-	uncompr.lo zutil.lo
-@TARGET_LIBRARY_TRUE@am_libzgcj_convenience_la_OBJECTS =  \
-@TARGET_LIBRARY_TRUE@	$(am__objects_2)
-libzgcj_convenience_la_OBJECTS = $(am_libzgcj_convenience_la_OBJECTS)
-@TARGET_LIBRARY_TRUE@am_libzgcj_convenience_la_rpath =
-DEFAULT_INCLUDES = -I.@am__isrc@
-depcomp =
-am__depfiles_maybe =
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
-	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
-	$(LDFLAGS) -o $@
-SOURCES = $(libz_a_SOURCES) $(libzgcj_convenience_la_SOURCES)
-MULTISRCTOP = 
-MULTIBUILDTOP = 
-MULTIDIRS = 
-MULTISUBDIR = 
-MULTIDO = true
-MULTICLEAN = true
-ETAGS = etags
-CTAGS = ctags
-ACLOCAL = @ACLOCAL@
-AMTAR = @AMTAR@
-AR = @AR@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFLAGS = @CFLAGS@
-COMPPATH = @COMPPATH@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-DSYMUTIL = @DSYMUTIL@
-DUMPBIN = @DUMPBIN@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-EXEEXT = @EXEEXT@
-FGREP = @FGREP@
-GREP = @GREP@
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-LD = @LD@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LIPO = @LIPO@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-MAINT = @MAINT@
-MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
-NM = @NM@
-NMEDIT = @NMEDIT@
-OBJDUMP = @OBJDUMP@
-OBJEXT = @OBJEXT@
-OTOOL = @OTOOL@
-OTOOL64 = @OTOOL64@
-PACKAGE = @PACKAGE@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_URL = @PACKAGE_URL@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-RANLIB = @RANLIB@
-SED = @SED@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-STRIP = @STRIP@
-VERSION = @VERSION@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-builddir = @builddir@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-mkinstalldirs = @mkinstalldirs@
-multi_basedir = @multi_basedir@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
-sysconfdir = @sysconfdir@
-target = @target@
-target_alias = @target_alias@
-target_all = @target_all@
-target_cpu = @target_cpu@
-target_os = @target_os@
-target_vendor = @target_vendor@
-toolexecdir = @toolexecdir@
-toolexeclibdir = @toolexeclibdir@
-top_build_prefix = @top_build_prefix@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
-AUTOMAKE_OPTIONS = 1.8 cygnus
-ACLOCAL_AMFLAGS = -I .. -I ../config
-ZLIB_SOURCES = adler32.c compress.c crc32.c crc32.h deflate.c \
-deflate.h gzio.c infback.c inffast.c inffast.h inffixed.h inflate.c \
-inflate.h inftrees.c inftrees.h trees.c trees.h uncompr.c zconf.h \
-zconf.in.h zlib.h zutil.c zutil.h
-
-@TARGET_LIBRARY_TRUE@noinst_LTLIBRARIES = libzgcj_convenience.la
-@TARGET_LIBRARY_TRUE@libzgcj_convenience_la_SOURCES = $(ZLIB_SOURCES)
-@TARGET_LIBRARY_FALSE@toolexeclib_LIBRARIES = libz.a
-@TARGET_LIBRARY_FALSE@libz_a_SOURCES = $(ZLIB_SOURCES)
-@TARGET_LIBRARY_FALSE@libz_a_CFLAGS = $(AM_CFLAGS)
-
-# Work around what appears to be a GNU make bug handling MAKEFLAGS
-# values defined in terms of make variables, as is the case for CC and
-# friends when we are called from the top level Makefile.
-AM_MAKEFLAGS = \
-	"AR_FLAGS=$(AR_FLAGS)" \
-	"CC_FOR_BUILD=$(CC_FOR_BUILD)" \
-	"CFLAGS=$(CFLAGS)" \
-	"CXXFLAGS=$(CXXFLAGS)" \
-	"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)" \
-	"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)" \
-	"INSTALL=$(INSTALL)" \
-	"INSTALL_DATA=$(INSTALL_DATA)" \
-	"INSTALL_PROGRAM=$(INSTALL_PROGRAM)" \
-	"INSTALL_SCRIPT=$(INSTALL_SCRIPT)" \
-	"LDFLAGS=$(LDFLAGS)" \
-	"LIBCFLAGS=$(LIBCFLAGS)" \
-	"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)" \
-	"MAKE=$(MAKE)" \
-	"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)" \
-	"PICFLAG=$(PICFLAG)" \
-	"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)" \
-	"SHELL=$(SHELL)" \
-	"EXPECT=$(EXPECT)" \
-	"RUNTEST=$(RUNTEST)" \
-	"RUNTESTFLAGS=$(RUNTESTFLAGS)" \
-	"exec_prefix=$(exec_prefix)" \
-	"infodir=$(infodir)" \
-	"libdir=$(libdir)" \
-	"prefix=$(prefix)" \
-	"tooldir=$(tooldir)" \
-	"AR=$(AR)" \
-	"AS=$(AS)" \
-	"CC=$(CC)" \
-	"CXX=$(CXX)" \
-	"LD=$(LD)" \
-	"LIBCFLAGS=$(LIBCFLAGS)" \
-	"NM=$(NM)" \
-	"PICFLAG=$(PICFLAG)" \
-	"RANLIB=$(RANLIB)" \
-	"DESTDIR=$(DESTDIR)"
-
-all: all-am
-
-.SUFFIXES:
-.SUFFIXES: .c .lo .o .obj
-am--refresh:
-	@:
-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \
-	      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \
-		&& exit 0; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \
-	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --foreign Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    echo ' $(SHELL) ./config.status'; \
-	    $(SHELL) ./config.status;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	$(SHELL) ./config.status --recheck
-
-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
-	$(am__cd) $(srcdir) && $(AUTOCONF)
-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
-	$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
-$(am__aclocal_m4_deps):
-install-toolexeclibLIBRARIES: $(toolexeclib_LIBRARIES)
-	@$(NORMAL_INSTALL)
-	test -z "$(toolexeclibdir)" || $(MKDIR_P) "$(DESTDIR)$(toolexeclibdir)"
-	@list='$(toolexeclib_LIBRARIES)'; test -n "$(toolexeclibdir)" || list=; \
-	list2=; for p in $$list; do \
-	  if test -f $$p; then \
-	    list2="$$list2 $$p"; \
-	  else :; fi; \
-	done; \
-	test -z "$$list2" || { \
-	  echo " $(INSTALL_DATA) $$list2 '$(DESTDIR)$(toolexeclibdir)'"; \
-	  $(INSTALL_DATA) $$list2 "$(DESTDIR)$(toolexeclibdir)" || exit $$?; }
-	@$(POST_INSTALL)
-	@list='$(toolexeclib_LIBRARIES)'; test -n "$(toolexeclibdir)" || list=; \
-	for p in $$list; do \
-	  if test -f $$p; then \
-	    $(am__strip_dir) \
-	    echo " ( cd '$(DESTDIR)$(toolexeclibdir)' && $(RANLIB) $$f )"; \
-	    ( cd "$(DESTDIR)$(toolexeclibdir)" && $(RANLIB) $$f ) || exit $$?; \
-	  else :; fi; \
-	done
-
-uninstall-toolexeclibLIBRARIES:
-	@$(NORMAL_UNINSTALL)
-	@list='$(toolexeclib_LIBRARIES)'; test -n "$(toolexeclibdir)" || list=; \
-	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(toolexeclibdir)' && rm -f "$$files" )"; \
-	cd "$(DESTDIR)$(toolexeclibdir)" && rm -f $$files
-
-clean-toolexeclibLIBRARIES:
-	-test -z "$(toolexeclib_LIBRARIES)" || rm -f $(toolexeclib_LIBRARIES)
-libz.a: $(libz_a_OBJECTS) $(libz_a_DEPENDENCIES) 
-	-rm -f libz.a
-	$(libz_a_AR) libz.a $(libz_a_OBJECTS) $(libz_a_LIBADD)
-	$(RANLIB) libz.a
-
-clean-noinstLTLIBRARIES:
-	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
-	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
-	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
-	  test "$$dir" != "$$p" || dir=.; \
-	  echo "rm -f \"$${dir}/so_locations\""; \
-	  rm -f "$${dir}/so_locations"; \
-	done
-libzgcj_convenience.la: $(libzgcj_convenience_la_OBJECTS) $(libzgcj_convenience_la_DEPENDENCIES) 
-	$(LINK) $(am_libzgcj_convenience_la_rpath) $(libzgcj_convenience_la_OBJECTS) $(libzgcj_convenience_la_LIBADD) $(LIBS)
-
-mostlyclean-compile:
-	-rm -f *.$(OBJEXT)
-
-distclean-compile:
-	-rm -f *.tab.c
-
-.c.o:
-	$(COMPILE) -c $<
-
-.c.obj:
-	$(COMPILE) -c `$(CYGPATH_W) '$<'`
-
-.c.lo:
-	$(LTCOMPILE) -c -o $@ $<
-
-libz_a-adler32.o: adler32.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-adler32.o `test -f 'adler32.c' || echo '$(srcdir)/'`adler32.c
-
-libz_a-adler32.obj: adler32.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-adler32.obj `if test -f 'adler32.c'; then $(CYGPATH_W) 'adler32.c'; else $(CYGPATH_W) '$(srcdir)/adler32.c'; fi`
-
-libz_a-compress.o: compress.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-compress.o `test -f 'compress.c' || echo '$(srcdir)/'`compress.c
-
-libz_a-compress.obj: compress.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-compress.obj `if test -f 'compress.c'; then $(CYGPATH_W) 'compress.c'; else $(CYGPATH_W) '$(srcdir)/compress.c'; fi`
-
-libz_a-crc32.o: crc32.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-crc32.o `test -f 'crc32.c' || echo '$(srcdir)/'`crc32.c
-
-libz_a-crc32.obj: crc32.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-crc32.obj `if test -f 'crc32.c'; then $(CYGPATH_W) 'crc32.c'; else $(CYGPATH_W) '$(srcdir)/crc32.c'; fi`
-
-libz_a-deflate.o: deflate.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-deflate.o `test -f 'deflate.c' || echo '$(srcdir)/'`deflate.c
-
-libz_a-deflate.obj: deflate.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-deflate.obj `if test -f 'deflate.c'; then $(CYGPATH_W) 'deflate.c'; else $(CYGPATH_W) '$(srcdir)/deflate.c'; fi`
-
-libz_a-gzio.o: gzio.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-gzio.o `test -f 'gzio.c' || echo '$(srcdir)/'`gzio.c
-
-libz_a-gzio.obj: gzio.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-gzio.obj `if test -f 'gzio.c'; then $(CYGPATH_W) 'gzio.c'; else $(CYGPATH_W) '$(srcdir)/gzio.c'; fi`
-
-libz_a-infback.o: infback.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-infback.o `test -f 'infback.c' || echo '$(srcdir)/'`infback.c
-
-libz_a-infback.obj: infback.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-infback.obj `if test -f 'infback.c'; then $(CYGPATH_W) 'infback.c'; else $(CYGPATH_W) '$(srcdir)/infback.c'; fi`
-
-libz_a-inffast.o: inffast.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inffast.o `test -f 'inffast.c' || echo '$(srcdir)/'`inffast.c
-
-libz_a-inffast.obj: inffast.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inffast.obj `if test -f 'inffast.c'; then $(CYGPATH_W) 'inffast.c'; else $(CYGPATH_W) '$(srcdir)/inffast.c'; fi`
-
-libz_a-inflate.o: inflate.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inflate.o `test -f 'inflate.c' || echo '$(srcdir)/'`inflate.c
-
-libz_a-inflate.obj: inflate.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inflate.obj `if test -f 'inflate.c'; then $(CYGPATH_W) 'inflate.c'; else $(CYGPATH_W) '$(srcdir)/inflate.c'; fi`
-
-libz_a-inftrees.o: inftrees.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inftrees.o `test -f 'inftrees.c' || echo '$(srcdir)/'`inftrees.c
-
-libz_a-inftrees.obj: inftrees.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-inftrees.obj `if test -f 'inftrees.c'; then $(CYGPATH_W) 'inftrees.c'; else $(CYGPATH_W) '$(srcdir)/inftrees.c'; fi`
-
-libz_a-trees.o: trees.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-trees.o `test -f 'trees.c' || echo '$(srcdir)/'`trees.c
-
-libz_a-trees.obj: trees.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-trees.obj `if test -f 'trees.c'; then $(CYGPATH_W) 'trees.c'; else $(CYGPATH_W) '$(srcdir)/trees.c'; fi`
-
-libz_a-uncompr.o: uncompr.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-uncompr.o `test -f 'uncompr.c' || echo '$(srcdir)/'`uncompr.c
-
-libz_a-uncompr.obj: uncompr.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-uncompr.obj `if test -f 'uncompr.c'; then $(CYGPATH_W) 'uncompr.c'; else $(CYGPATH_W) '$(srcdir)/uncompr.c'; fi`
-
-libz_a-zutil.o: zutil.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-zutil.o `test -f 'zutil.c' || echo '$(srcdir)/'`zutil.c
-
-libz_a-zutil.obj: zutil.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libz_a_CFLAGS) $(CFLAGS) -c -o libz_a-zutil.obj `if test -f 'zutil.c'; then $(CYGPATH_W) 'zutil.c'; else $(CYGPATH_W) '$(srcdir)/zutil.c'; fi`
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-distclean-libtool:
-	-rm -f libtool config.lt
-
-# GNU Make needs to see an explicit $(MAKE) variable in the command it
-# runs to enable its job server during parallel builds.  Hence the
-# comments below.
-all-multi:
-	$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)
-install-multi:
-	$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)
-
-mostlyclean-multi:
-	$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)
-clean-multi:
-	$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)
-distclean-multi:
-	$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)
-maintainer-clean-multi:
-	$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
-
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	set x; \
-	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	shift; \
-	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  if test $$# -gt 0; then \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      "$$@" $$unique; \
-	  else \
-	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	      $$unique; \
-	  fi; \
-	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	test -z "$(CTAGS_ARGS)$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && $(am__cd) $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) "$$here"
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-check-am:
-check: check-am
-all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) all-multi
-installdirs:
-	for dir in "$(DESTDIR)$(toolexeclibdir)"; do \
-	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
-	done
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am clean-multi
-
-clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
-	clean-toolexeclibLIBRARIES mostlyclean-am
-
-distclean: distclean-am distclean-multi
-	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
-	-rm -f Makefile
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-libtool distclean-tags
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-html-am:
-
-info: info-am
-
-info-am:
-
-install-data-am:
-
-install-dvi: install-dvi-am
-
-install-dvi-am:
-
-install-exec-am: install-multi install-toolexeclibLIBRARIES
-
-install-html: install-html-am
-
-install-html-am:
-
-install-info: install-info-am
-
-install-info-am:
-
-install-man:
-
-install-pdf: install-pdf-am
-
-install-pdf-am:
-
-install-ps: install-ps-am
-
-install-ps-am:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am maintainer-clean-multi
-	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
-	-rm -rf $(top_srcdir)/autom4te.cache
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am mostlyclean-multi
-
-mostlyclean-am: mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am: uninstall-toolexeclibLIBRARIES
-
-.MAKE: all-multi clean-multi distclean-multi install-am install-multi \
-	install-strip maintainer-clean-multi mostlyclean-multi
-
-.PHONY: CTAGS GTAGS all all-am all-multi am--refresh check check-am \
-	clean clean-generic clean-libtool clean-multi \
-	clean-noinstLTLIBRARIES clean-toolexeclibLIBRARIES ctags \
-	distclean distclean-compile distclean-generic \
-	distclean-libtool distclean-multi distclean-tags dvi dvi-am \
-	html html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-multi install-pdf \
-	install-pdf-am install-ps install-ps-am install-strip \
-	install-toolexeclibLIBRARIES installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	maintainer-clean-multi mostlyclean mostlyclean-compile \
-	mostlyclean-generic mostlyclean-libtool mostlyclean-multi pdf \
-	pdf-am ps ps-am tags uninstall uninstall-am \
-	uninstall-toolexeclibLIBRARIES
-
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
diff -Nbaur gcc-4.6.3/zlib/make_vms.com gcc-4.6.3-psp/zlib/make_vms.com
--- gcc-4.6.3/zlib/make_vms.com	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/make_vms.com	1970-01-01 01:00:00.000000000 +0100
@@ -1,461 +0,0 @@
-$! make libz under VMS written by
-$! Martin P.J. Zinser
-$! <zinser@zinser.no-ip.info or zinser@sysdev.deutsche-boerse.com>
-$!
-$ on error then goto err_exit
-$!
-$!
-$! Just some general constants...
-$!
-$ true  = 1
-$ false = 0
-$ tmpnam = "temp_" + f$getjpi("","pid")
-$ SAY = "WRITE SYS$OUTPUT"
-$!
-$! Setup variables holding "config" information
-$!
-$ Make     = ""
-$ name     = "Zlib"
-$ version  = "?.?.?"
-$ v_string = "ZLIB_VERSION"
-$ v_file   = "zlib.h"
-$ ccopt    = ""
-$ lopts    = ""
-$ linkonly = false
-$ optfile  = name + ".opt"
-$ its_decc = false
-$ its_vaxc = false
-$ its_gnuc = false
-$ axp      = f$getsyi("HW_MODEL").ge.1024
-$ s_case   = false
-$! Check for MMK/MMS
-$!
-$ If F$Search ("Sys$System:MMS.EXE") .nes. "" Then Make = "MMS"
-$ If F$Type (MMK) .eqs. "STRING" Then Make = "MMK"
-$!
-$!
-$ gosub find_version
-$!
-$ gosub check_opts
-$!
-$! Look for the compiler used
-$!
-$ gosub check_compiler
-$ if its_decc
-$ then
-$   ccopt = "/prefix=all" + ccopt
-$   if f$trnlnm("SYS") .eqs. ""
-$   then
-$     if axp
-$     then
-$       define sys sys$library:
-$     else
-$       ccopt = "/decc" + ccopt
-$       define sys decc$library_include:
-$     endif
-$   endif
-$ endif
-$ if its_vaxc .or. its_gnuc
-$ then
-$    if f$trnlnm("SYS").eqs."" then define sys sys$library:
-$ endif
-$!
-$! Build the thing plain or with mms
-$!
-$ write sys$output "Compiling Zlib sources ..."
-$ if make.eqs.""
-$  then
-$   dele example.obj;*,minigzip.obj;*
-$   CALL MAKE adler32.OBJ "CC ''CCOPT' adler32" -
-                adler32.c zlib.h zconf.h
-$   CALL MAKE compress.OBJ "CC ''CCOPT' compress" -
-                compress.c zlib.h zconf.h
-$   CALL MAKE crc32.OBJ "CC ''CCOPT' crc32" -
-                crc32.c zlib.h zconf.h
-$   CALL MAKE deflate.OBJ "CC ''CCOPT' deflate" -
-                deflate.c deflate.h zutil.h zlib.h zconf.h
-$   CALL MAKE gzio.OBJ "CC ''CCOPT' gzio" -
-                gzio.c zutil.h zlib.h zconf.h
-$   CALL MAKE infback.OBJ "CC ''CCOPT' infback" -
-                infback.c zutil.h inftrees.h inflate.h inffast.h inffixed.h
-$   CALL MAKE inffast.OBJ "CC ''CCOPT' inffast" -
-                inffast.c zutil.h zlib.h zconf.h inffast.h
-$   CALL MAKE inflate.OBJ "CC ''CCOPT' inflate" -
-                inflate.c zutil.h zlib.h zconf.h infblock.h
-$   CALL MAKE inftrees.OBJ "CC ''CCOPT' inftrees" -
-                inftrees.c zutil.h zlib.h zconf.h inftrees.h
-$   CALL MAKE trees.OBJ "CC ''CCOPT' trees" -
-                trees.c deflate.h zutil.h zlib.h zconf.h
-$   CALL MAKE uncompr.OBJ "CC ''CCOPT' uncompr" -
-                uncompr.c zlib.h zconf.h
-$   CALL MAKE zutil.OBJ "CC ''CCOPT' zutil" -
-                zutil.c zutil.h zlib.h zconf.h
-$   write sys$output "Building Zlib ..."
-$   CALL MAKE libz.OLB "lib/crea libz.olb *.obj" *.OBJ
-$   write sys$output "Building example..."
-$   CALL MAKE example.OBJ "CC ''CCOPT' example" -
-                example.c zlib.h zconf.h
-$   call make example.exe "LINK example,libz.olb/lib" example.obj libz.olb
-$   if f$search("x11vms:xvmsutils.olb") .nes. ""
-$   then
-$     write sys$output "Building minigzip..."
-$     CALL MAKE minigzip.OBJ "CC ''CCOPT' minigzip" -
-                minigzip.c zlib.h zconf.h
-$     call make minigzip.exe -
-                "LINK minigzip,libz.olb/lib,x11vms:xvmsutils.olb/lib" -
-                minigzip.obj libz.olb
-$   endif
-$  else
-$   gosub crea_mms
-$   SAY "Make ''name' ''version' with ''Make' "
-$   'make'
-$  endif
-$!
-$! Alpha gets a shareable image
-$!
-$ If axp
-$ Then
-$   gosub crea_olist
-$   write sys$output "Creating libzshr.exe"
-$   call anal_obj_axp modules.opt _link.opt
-$   if s_case
-$   then
-$      open/append optf modules.opt
-$      write optf "case_sensitive=YES"
-$      close optf
-$   endif
-$   LINK_'lopts'/SHARE=libzshr.exe modules.opt/opt,_link.opt/opt
-$ endif
-$ write sys$output "Zlib build completed"
-$ exit
-$CC_ERR:
-$ write sys$output "C compiler required to build ''name'"
-$ goto err_exit
-$ERR_EXIT:
-$ set message/facil/ident/sever/text
-$ write sys$output "Exiting..."
-$ exit 2
-$!
-$!
-$MAKE: SUBROUTINE   !SUBROUTINE TO CHECK DEPENDENCIES
-$ V = 'F$Verify(0)
-$! P1 = What we are trying to make
-$! P2 = Command to make it
-$! P3 - P8  What it depends on
-$
-$ If F$Search(P1) .Eqs. "" Then Goto Makeit
-$ Time = F$CvTime(F$File(P1,"RDT"))
-$arg=3
-$Loop:
-$       Argument = P'arg
-$       If Argument .Eqs. "" Then Goto Exit
-$       El=0
-$Loop2:
-$       File = F$Element(El," ",Argument)
-$       If File .Eqs. " " Then Goto Endl
-$       AFile = ""
-$Loop3:
-$       OFile = AFile
-$       AFile = F$Search(File)
-$       If AFile .Eqs. "" .Or. AFile .Eqs. OFile Then Goto NextEl
-$       If F$CvTime(F$File(AFile,"RDT")) .Ges. Time Then Goto Makeit
-$       Goto Loop3
-$NextEL:
-$       El = El + 1
-$       Goto Loop2
-$EndL:
-$ arg=arg+1
-$ If arg .Le. 8 Then Goto Loop
-$ Goto Exit
-$
-$Makeit:
-$ VV=F$VERIFY(0)
-$ write sys$output P2
-$ 'P2
-$ VV='F$Verify(VV)
-$Exit:
-$ If V Then Set Verify
-$ENDSUBROUTINE
-$!------------------------------------------------------------------------------
-$!
-$! Check command line options and set symbols accordingly
-$!
-$ CHECK_OPTS:
-$ i = 1
-$ OPT_LOOP:
-$ if i .lt. 9
-$ then
-$   cparm = f$edit(p'i',"upcase")
-$   if cparm .eqs. "DEBUG"
-$   then
-$     ccopt = ccopt + "/noopt/deb"
-$     lopts = lopts + "/deb"
-$   endif
-$   if f$locate("CCOPT=",cparm) .lt. f$length(cparm)
-$   then
-$     start = f$locate("=",cparm) + 1
-$     len   = f$length(cparm) - start
-$     ccopt = ccopt + f$extract(start,len,cparm)
-$     if f$locate("AS_IS",f$edit(ccopt,"UPCASE")) .lt. f$length(ccopt) -
-         then s_case = true
-$   endif
-$   if cparm .eqs. "LINK" then linkonly = true
-$   if f$locate("LOPTS=",cparm) .lt. f$length(cparm)
-$   then
-$     start = f$locate("=",cparm) + 1
-$     len   = f$length(cparm) - start
-$     lopts = lopts + f$extract(start,len,cparm)
-$   endif
-$   if f$locate("CC=",cparm) .lt. f$length(cparm)
-$   then
-$     start  = f$locate("=",cparm) + 1
-$     len    = f$length(cparm) - start
-$     cc_com = f$extract(start,len,cparm)
-      if (cc_com .nes. "DECC") .and. -
-         (cc_com .nes. "VAXC") .and. -
-	 (cc_com .nes. "GNUC")
-$     then
-$       write sys$output "Unsupported compiler choice ''cc_com' ignored"
-$       write sys$output "Use DECC, VAXC, or GNUC instead"
-$     else
-$     	if cc_com .eqs. "DECC" then its_decc = true
-$     	if cc_com .eqs. "VAXC" then its_vaxc = true
-$     	if cc_com .eqs. "GNUC" then its_gnuc = true
-$     endif
-$   endif
-$   if f$locate("MAKE=",cparm) .lt. f$length(cparm)
-$   then
-$     start  = f$locate("=",cparm) + 1
-$     len    = f$length(cparm) - start
-$     mmks = f$extract(start,len,cparm)
-$     if (mmks .eqs. "MMK") .or. (mmks .eqs. "MMS")
-$     then
-$       make = mmks
-$     else
-$       write sys$output "Unsupported make choice ''mmks' ignored"
-$       write sys$output "Use MMK or MMS instead"
-$     endif
-$   endif
-$   i = i + 1
-$   goto opt_loop
-$ endif
-$ return
-$!------------------------------------------------------------------------------
-$!
-$! Look for the compiler used
-$!
-$CHECK_COMPILER:
-$ if (.not. (its_decc .or. its_vaxc .or. its_gnuc))
-$ then
-$   its_decc = (f$search("SYS$SYSTEM:DECC$COMPILER.EXE") .nes. "")
-$   its_vaxc = .not. its_decc .and. (F$Search("SYS$System:VAXC.Exe") .nes. "")
-$   its_gnuc = .not. (its_decc .or. its_vaxc) .and. (f$trnlnm("gnu_cc") .nes. "")
-$ endif
-$!
-$! Exit if no compiler available
-$!
-$ if (.not. (its_decc .or. its_vaxc .or. its_gnuc))
-$ then goto CC_ERR
-$ else
-$   if its_decc then write sys$output "CC compiler check ... Compaq C"
-$   if its_vaxc then write sys$output "CC compiler check ... VAX C"
-$   if its_gnuc then write sys$output "CC compiler check ... GNU C"
-$ endif
-$ return
-$!------------------------------------------------------------------------------
-$!
-$! If MMS/MMK are available dump out the descrip.mms if required
-$!
-$CREA_MMS:
-$ write sys$output "Creating descrip.mms..."
-$ create descrip.mms
-$ open/append out descrip.mms
-$ copy sys$input: out
-$ deck
-# descrip.mms: MMS description file for building zlib on VMS
-# written by Martin P.J. Zinser
-# <zinser@zinser.no-ip.info or zinser@sysdev.deutsche-boerse.com>
-
-OBJS = adler32.obj, compress.obj, crc32.obj, gzio.obj, uncompr.obj, infback.obj\
-       deflate.obj, trees.obj, zutil.obj, inflate.obj, \
-       inftrees.obj, inffast.obj
-
-$ eod
-$ write out "CFLAGS=", ccopt
-$ write out "LOPTS=", lopts
-$ copy sys$input: out
-$ deck
-
-all : example.exe minigzip.exe libz.olb
-        @ write sys$output " Example applications available"
-
-libz.olb : libz.olb($(OBJS))
-	@ write sys$output " libz available"
-
-example.exe : example.obj libz.olb
-              link $(LOPTS) example,libz.olb/lib
-
-minigzip.exe : minigzip.obj libz.olb
-              link $(LOPTS) minigzip,libz.olb/lib,x11vms:xvmsutils.olb/lib
-
-clean :
-	delete *.obj;*,libz.olb;*,*.opt;*,*.exe;*
-
-
-# Other dependencies.
-adler32.obj  : adler32.c zutil.h zlib.h zconf.h
-compress.obj : compress.c zlib.h zconf.h
-crc32.obj    : crc32.c zutil.h zlib.h zconf.h
-deflate.obj  : deflate.c deflate.h zutil.h zlib.h zconf.h
-example.obj  : example.c zlib.h zconf.h
-gzio.obj     : gzio.c zutil.h zlib.h zconf.h
-inffast.obj  : inffast.c zutil.h zlib.h zconf.h inftrees.h inffast.h
-inflate.obj  : inflate.c zutil.h zlib.h zconf.h
-inftrees.obj : inftrees.c zutil.h zlib.h zconf.h inftrees.h
-minigzip.obj : minigzip.c zlib.h zconf.h
-trees.obj    : trees.c deflate.h zutil.h zlib.h zconf.h
-uncompr.obj  : uncompr.c zlib.h zconf.h
-zutil.obj    : zutil.c zutil.h zlib.h zconf.h
-infback.obj  : infback.c zutil.h inftrees.h inflate.h inffast.h inffixed.h
-$ eod
-$ close out
-$ return
-$!------------------------------------------------------------------------------
-$!
-$! Read list of core library sources from makefile.in and create options
-$! needed to build shareable image
-$!
-$CREA_OLIST:
-$ open/read min makefile.in
-$ open/write mod modules.opt
-$ src_check = "OBJS ="
-$MRLOOP:
-$ read/end=mrdone min rec
-$ if (f$extract(0,6,rec) .nes. src_check) then goto mrloop
-$ rec = rec - src_check
-$ gosub extra_filnam
-$ if (f$element(1,"\",rec) .eqs. "\") then goto mrdone
-$MRSLOOP:
-$ read/end=mrdone min rec
-$ gosub extra_filnam
-$ if (f$element(1,"\",rec) .nes. "\") then goto mrsloop
-$MRDONE:
-$ close min
-$ close mod
-$ return
-$!------------------------------------------------------------------------------
-$!
-$! Take record extracted in crea_olist and split it into single filenames
-$!
-$EXTRA_FILNAM:
-$ myrec = f$edit(rec - "\", "trim,compress")
-$ i = 0
-$FELOOP:
-$ srcfil = f$element(i," ", myrec)
-$ if (srcfil .nes. " ")
-$ then
-$   write mod f$parse(srcfil,,,"NAME"), ".obj"
-$   i = i + 1
-$   goto feloop
-$ endif
-$ return
-$!------------------------------------------------------------------------------
-$!
-$! Find current Zlib version number
-$!
-$FIND_VERSION:
-$ open/read h_in 'v_file'
-$hloop:
-$ read/end=hdone h_in rec
-$ rec = f$edit(rec,"TRIM")
-$ if (f$extract(0,1,rec) .nes. "#") then goto hloop
-$ rec = f$edit(rec - "#", "TRIM")
-$ if f$element(0," ",rec) .nes. "define" then goto hloop
-$ if f$element(1," ",rec) .eqs. v_string
-$ then
-$   version = 'f$element(2," ",rec)'
-$   goto hdone
-$ endif
-$ goto hloop
-$hdone:
-$ close h_in
-$ return
-$!------------------------------------------------------------------------------
-$!
-$! Analyze Object files for OpenVMS AXP to extract Procedure and Data
-$! information to build a symbol vector for a shareable image
-$! All the "brains" of this logic was suggested by Hartmut Becker
-$! (Hartmut.Becker@compaq.com). All the bugs were introduced by me
-$! (zinser@decus.de), so if you do have problem reports please do not
-$! bother Hartmut/HP, but get in touch with me
-$!
-$ ANAL_OBJ_AXP: Subroutine
-$ V = 'F$Verify(0)
-$ SAY := "WRITE_ SYS$OUTPUT"
-$
-$ IF F$SEARCH("''P1'") .EQS. ""
-$ THEN
-$    SAY "ANAL_OBJ_AXP-E-NOSUCHFILE:  Error, inputfile ''p1' not available"
-$    goto exit_aa
-$ ENDIF
-$ IF "''P2'" .EQS. ""
-$ THEN
-$    SAY "ANAL_OBJ_AXP:  Error, no output file provided"
-$    goto exit_aa
-$ ENDIF
-$
-$ open/read in 'p1
-$ create a.tmp
-$ open/append atmp a.tmp
-$ loop:
-$ read/end=end_loop in line
-$ f= f$search(line)
-$ if f .eqs. ""
-$ then
-$	write sys$output "ANAL_OBJ_AXP-w-nosuchfile, ''line'"
-$	goto loop
-$ endif
-$ define/user sys$output nl:
-$ define/user sys$error nl:
-$ anal/obj/gsd 'f /out=x.tmp
-$ open/read xtmp x.tmp
-$ XLOOP:
-$ read/end=end_xloop xtmp xline
-$ xline = f$edit(xline,"compress")
-$ write atmp xline
-$ goto xloop
-$ END_XLOOP:
-$ close xtmp
-$ goto loop
-$ end_loop:
-$ close in
-$ close atmp
-$ if f$search("a.tmp") .eqs. "" -
-	then $ exit
-$ ! all global definitions
-$ search a.tmp "symbol:","EGSY$V_DEF 1","EGSY$V_NORM 1"/out=b.tmp
-$ ! all procedures
-$ search b.tmp "EGSY$V_NORM 1"/wind=(0,1) /out=c.tmp
-$ search c.tmp "symbol:"/out=d.tmp
-$ define/user sys$output nl:
-$ edito/edt/command=sys$input d.tmp
-sub/symbol: "/symbol_vector=(/whole
-sub/"/=PROCEDURE)/whole
-exit
-$ ! all data
-$ search b.tmp "EGSY$V_DEF 1"/wind=(0,1) /out=e.tmp
-$ search e.tmp "symbol:"/out=f.tmp
-$ define/user sys$output nl:
-$ edito/edt/command=sys$input f.tmp
-sub/symbol: "/symbol_vector=(/whole
-sub/"/=DATA)/whole
-exit
-$ sort/nodupl d.tmp,f.tmp 'p2'
-$ delete a.tmp;*,b.tmp;*,c.tmp;*,d.tmp;*,e.tmp;*,f.tmp;*
-$ if f$search("x.tmp") .nes. "" -
-	then $ delete x.tmp;*
-$!
-$ EXIT_AA:
-$ if V then set verify
-$ endsubroutine
-$!------------------------------------------------------------------------------
diff -Nbaur gcc-4.6.3/zlib/minigzip.c gcc-4.6.3-psp/zlib/minigzip.c
--- gcc-4.6.3/zlib/minigzip.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/minigzip.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,322 +0,0 @@
-/* minigzip.c -- simulate gzip using the zlib compression library
- * Copyright (C) 1995-2005 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- * minigzip is a minimal implementation of the gzip utility. This is
- * only an example of using zlib and isn't meant to replace the
- * full-featured gzip. No attempt is made to deal with file systems
- * limiting names to 14 or 8+3 characters, etc... Error checking is
- * very limited. So use minigzip only for testing; use gzip for the
- * real thing. On MSDOS, use only on file names without extension
- * or in pipe mode.
- */
-
-/* @(#) $Id: minigzip.c,v 1.1.1.2 2002/03/11 21:53:26 tromey Exp $ */
-
-#include <stdio.h>
-#include "zlib.h"
-
-#ifdef STDC
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-
-#ifdef USE_MMAP
-#  include <sys/types.h>
-#  include <sys/mman.h>
-#  include <sys/stat.h>
-#endif
-
-#if defined(MSDOS) || defined(OS2) || defined(WIN32) || defined(__CYGWIN__)
-#  include <fcntl.h>
-#  include <io.h>
-#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
-#else
-#  define SET_BINARY_MODE(file)
-#endif
-
-#ifdef VMS
-#  define unlink delete
-#  define GZ_SUFFIX "-gz"
-#endif
-#ifdef RISCOS
-#  define unlink remove
-#  define GZ_SUFFIX "-gz"
-#  define fileno(file) file->__file
-#endif
-#if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
-#  include <unix.h> /* for fileno */
-#endif
-
-#ifndef WIN32 /* unlink already in stdio.h for WIN32 */
-  extern int unlink OF((const char *));
-#endif
-
-#ifndef GZ_SUFFIX
-#  define GZ_SUFFIX ".gz"
-#endif
-#define SUFFIX_LEN (sizeof(GZ_SUFFIX)-1)
-
-#define BUFLEN      16384
-#define MAX_NAME_LEN 1024
-
-#ifdef MAXSEG_64K
-#  define local static
-   /* Needed for systems with limitation on stack size. */
-#else
-#  define local
-#endif
-
-char *prog;
-
-void error            OF((const char *msg));
-void gz_compress      OF((FILE   *in, gzFile out));
-#ifdef USE_MMAP
-int  gz_compress_mmap OF((FILE   *in, gzFile out));
-#endif
-void gz_uncompress    OF((gzFile in, FILE   *out));
-void file_compress    OF((char  *file, char *mode));
-void file_uncompress  OF((char  *file));
-int  main             OF((int argc, char *argv[]));
-
-/* ===========================================================================
- * Display error message and exit
- */
-void error(msg)
-    const char *msg;
-{
-    fprintf(stderr, "%s: %s\n", prog, msg);
-    exit(1);
-}
-
-/* ===========================================================================
- * Compress input to output then close both files.
- */
-
-void gz_compress(in, out)
-    FILE   *in;
-    gzFile out;
-{
-    local char buf[BUFLEN];
-    int len;
-    int err;
-
-#ifdef USE_MMAP
-    /* Try first compressing with mmap. If mmap fails (minigzip used in a
-     * pipe), use the normal fread loop.
-     */
-    if (gz_compress_mmap(in, out) == Z_OK) return;
-#endif
-    for (;;) {
-        len = (int)fread(buf, 1, sizeof(buf), in);
-        if (ferror(in)) {
-            perror("fread");
-            exit(1);
-        }
-        if (len == 0) break;
-
-        if (gzwrite(out, buf, (unsigned)len) != len) error(gzerror(out, &err));
-    }
-    fclose(in);
-    if (gzclose(out) != Z_OK) error("failed gzclose");
-}
-
-#ifdef USE_MMAP /* MMAP version, Miguel Albrecht <malbrech@eso.org> */
-
-/* Try compressing the input file at once using mmap. Return Z_OK if
- * if success, Z_ERRNO otherwise.
- */
-int gz_compress_mmap(in, out)
-    FILE   *in;
-    gzFile out;
-{
-    int len;
-    int err;
-    int ifd = fileno(in);
-    caddr_t buf;    /* mmap'ed buffer for the entire input file */
-    off_t buf_len;  /* length of the input file */
-    struct stat sb;
-
-    /* Determine the size of the file, needed for mmap: */
-    if (fstat(ifd, &sb) < 0) return Z_ERRNO;
-    buf_len = sb.st_size;
-    if (buf_len <= 0) return Z_ERRNO;
-
-    /* Now do the actual mmap: */
-    buf = mmap((caddr_t) 0, buf_len, PROT_READ, MAP_SHARED, ifd, (off_t)0);
-    if (buf == (caddr_t)(-1)) return Z_ERRNO;
-
-    /* Compress the whole file at once: */
-    len = gzwrite(out, (char *)buf, (unsigned)buf_len);
-
-    if (len != (int)buf_len) error(gzerror(out, &err));
-
-    munmap(buf, buf_len);
-    fclose(in);
-    if (gzclose(out) != Z_OK) error("failed gzclose");
-    return Z_OK;
-}
-#endif /* USE_MMAP */
-
-/* ===========================================================================
- * Uncompress input to output then close both files.
- */
-void gz_uncompress(in, out)
-    gzFile in;
-    FILE   *out;
-{
-    local char buf[BUFLEN];
-    int len;
-    int err;
-
-    for (;;) {
-        len = gzread(in, buf, sizeof(buf));
-        if (len < 0) error (gzerror(in, &err));
-        if (len == 0) break;
-
-        if ((int)fwrite(buf, 1, (unsigned)len, out) != len) {
-            error("failed fwrite");
-        }
-    }
-    if (fclose(out)) error("failed fclose");
-
-    if (gzclose(in) != Z_OK) error("failed gzclose");
-}
-
-
-/* ===========================================================================
- * Compress the given file: create a corresponding .gz file and remove the
- * original.
- */
-void file_compress(file, mode)
-    char  *file;
-    char  *mode;
-{
-    local char outfile[MAX_NAME_LEN];
-    FILE  *in;
-    gzFile out;
-
-    strcpy(outfile, file);
-    strcat(outfile, GZ_SUFFIX);
-
-    in = fopen(file, "rb");
-    if (in == NULL) {
-        perror(file);
-        exit(1);
-    }
-    out = gzopen(outfile, mode);
-    if (out == NULL) {
-        fprintf(stderr, "%s: can't gzopen %s\n", prog, outfile);
-        exit(1);
-    }
-    gz_compress(in, out);
-
-    unlink(file);
-}
-
-
-/* ===========================================================================
- * Uncompress the given file and remove the original.
- */
-void file_uncompress(file)
-    char  *file;
-{
-    local char buf[MAX_NAME_LEN];
-    char *infile, *outfile;
-    FILE  *out;
-    gzFile in;
-    uInt len = (uInt)strlen(file);
-
-    strcpy(buf, file);
-
-    if (len > SUFFIX_LEN && strcmp(file+len-SUFFIX_LEN, GZ_SUFFIX) == 0) {
-        infile = file;
-        outfile = buf;
-        outfile[len-3] = '\0';
-    } else {
-        outfile = file;
-        infile = buf;
-        strcat(infile, GZ_SUFFIX);
-    }
-    in = gzopen(infile, "rb");
-    if (in == NULL) {
-        fprintf(stderr, "%s: can't gzopen %s\n", prog, infile);
-        exit(1);
-    }
-    out = fopen(outfile, "wb");
-    if (out == NULL) {
-        perror(file);
-        exit(1);
-    }
-
-    gz_uncompress(in, out);
-
-    unlink(infile);
-}
-
-
-/* ===========================================================================
- * Usage:  minigzip [-d] [-f] [-h] [-r] [-1 to -9] [files...]
- *   -d : decompress
- *   -f : compress with Z_FILTERED
- *   -h : compress with Z_HUFFMAN_ONLY
- *   -r : compress with Z_RLE
- *   -1 to -9 : compression level
- */
-
-int main(argc, argv)
-    int argc;
-    char *argv[];
-{
-    int uncompr = 0;
-    gzFile file;
-    char outmode[20];
-
-    strcpy(outmode, "wb6 ");
-
-    prog = argv[0];
-    argc--, argv++;
-
-    while (argc > 0) {
-      if (strcmp(*argv, "-d") == 0)
-        uncompr = 1;
-      else if (strcmp(*argv, "-f") == 0)
-        outmode[3] = 'f';
-      else if (strcmp(*argv, "-h") == 0)
-        outmode[3] = 'h';
-      else if (strcmp(*argv, "-r") == 0)
-        outmode[3] = 'R';
-      else if ((*argv)[0] == '-' && (*argv)[1] >= '1' && (*argv)[1] <= '9' &&
-               (*argv)[2] == 0)
-        outmode[2] = (*argv)[1];
-      else
-        break;
-      argc--, argv++;
-    }
-    if (outmode[3] == ' ')
-        outmode[3] = 0;
-    if (argc == 0) {
-        SET_BINARY_MODE(stdin);
-        SET_BINARY_MODE(stdout);
-        if (uncompr) {
-            file = gzdopen(fileno(stdin), "rb");
-            if (file == NULL) error("can't gzdopen stdin");
-            gz_uncompress(file, stdout);
-        } else {
-            file = gzdopen(fileno(stdout), outmode);
-            if (file == NULL) error("can't gzdopen stdout");
-            gz_compress(stdin, file);
-        }
-    } else {
-        do {
-            if (uncompr) {
-                file_uncompress(*argv);
-            } else {
-                file_compress(*argv, outmode);
-            }
-        } while (argv++, --argc);
-    }
-    return 0;
-}
diff -Nbaur gcc-4.6.3/zlib/msdos/Makefile.bor gcc-4.6.3-psp/zlib/msdos/Makefile.bor
--- gcc-4.6.3/zlib/msdos/Makefile.bor	2004-10-11 19:45:43.000000000 +0100
+++ gcc-4.6.3-psp/zlib/msdos/Makefile.bor	1970-01-01 01:00:00.000000000 +0100
@@ -1,109 +0,0 @@
-# Makefile for zlib
-# Borland C++
-# Last updated: 15-Mar-2003
-
-# To use, do "make -fmakefile.bor"
-# To compile in small model, set below: MODEL=s
-
-# WARNING: the small model is supported but only for small values of
-# MAX_WBITS and MAX_MEM_LEVEL. For example:
-#    -DMAX_WBITS=11 -DDEF_WBITS=11 -DMAX_MEM_LEVEL=3
-# If you wish to reduce the memory requirements (default 256K for big
-# objects plus a few K), you can add to the LOC macro below:
-#   -DMAX_MEM_LEVEL=7 -DMAX_WBITS=14
-# See zconf.h for details about the memory requirements.
-
-# ------------ Turbo C++, Borland C++ ------------
-
-#    Optional nonstandard preprocessor flags (e.g. -DMAX_MEM_LEVEL=7)
-#    should be added to the environment via "set LOCAL_ZLIB=-DFOO" or added
-#    to the declaration of LOC here:
-LOC = $(LOCAL_ZLIB)
-
-# type for CPU required: 0: 8086, 1: 80186, 2: 80286, 3: 80386, etc.
-CPU_TYP = 0
-
-# memory model: one of s, m, c, l (small, medium, compact, large)
-MODEL=l
-
-# replace bcc with tcc for Turbo C++ 1.0, with bcc32 for the 32 bit version
-CC=bcc
-LD=bcc
-AR=tlib
-
-# compiler flags
-# replace "-O2" by "-O -G -a -d" for Turbo C++ 1.0
-CFLAGS=-O2 -Z -m$(MODEL) $(LOC)
-
-LDFLAGS=-m$(MODEL) -f-
-
-
-# variables
-ZLIB_LIB = zlib_$(MODEL).lib
-
-OBJ1 = adler32.obj compress.obj crc32.obj deflate.obj gzio.obj infback.obj
-OBJ2 = inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj
-OBJP1 = +adler32.obj+compress.obj+crc32.obj+deflate.obj+gzio.obj+infback.obj
-OBJP2 = +inffast.obj+inflate.obj+inftrees.obj+trees.obj+uncompr.obj+zutil.obj
-
-
-# targets
-all: $(ZLIB_LIB) example.exe minigzip.exe
-
-.c.obj:
-	$(CC) -c $(CFLAGS) $*.c
-
-adler32.obj: adler32.c zlib.h zconf.h
-
-compress.obj: compress.c zlib.h zconf.h
-
-crc32.obj: crc32.c zlib.h zconf.h crc32.h
-
-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h
-
-gzio.obj: gzio.c zutil.h zlib.h zconf.h
-
-infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h
-
-inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h
-
-trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h
-
-uncompr.obj: uncompr.c zlib.h zconf.h
-
-zutil.obj: zutil.c zutil.h zlib.h zconf.h
-
-example.obj: example.c zlib.h zconf.h
-
-minigzip.obj: minigzip.c zlib.h zconf.h
-
-
-# the command line is cut to fit in the MS-DOS 128 byte limit:
-$(ZLIB_LIB): $(OBJ1) $(OBJ2)
-	-del $(ZLIB_LIB)
-	$(AR) $(ZLIB_LIB) $(OBJP1)
-	$(AR) $(ZLIB_LIB) $(OBJP2)
-
-example.exe: example.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) example.obj $(ZLIB_LIB)
-
-minigzip.exe: minigzip.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) minigzip.obj $(ZLIB_LIB)
-
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d
-
-clean:
-	-del *.obj
-	-del *.lib
-	-del *.exe
-	-del zlib_*.bak
-	-del foo.gz
diff -Nbaur gcc-4.6.3/zlib/msdos/Makefile.dj2 gcc-4.6.3-psp/zlib/msdos/Makefile.dj2
--- gcc-4.6.3/zlib/msdos/Makefile.dj2	2004-10-11 19:45:43.000000000 +0100
+++ gcc-4.6.3-psp/zlib/msdos/Makefile.dj2	1970-01-01 01:00:00.000000000 +0100
@@ -1,104 +0,0 @@
-# Makefile for zlib.  Modified for djgpp v2.0 by F. J. Donahoe, 3/15/96.
-# Copyright (C) 1995-1998 Jean-loup Gailly.
-# For conditions of distribution and use, see copyright notice in zlib.h
-
-# To compile, or to compile and test, type:
-#
-#   make -fmakefile.dj2;  make test -fmakefile.dj2
-#
-# To install libz.a, zconf.h and zlib.h in the djgpp directories, type:
-#
-#    make install -fmakefile.dj2
-#
-# after first defining LIBRARY_PATH and INCLUDE_PATH in djgpp.env as
-# in the sample below if the pattern of the DJGPP distribution is to
-# be followed.  Remember that, while <sp>'es around <=> are ignored in
-# makefiles, they are *not* in batch files or in djgpp.env.
-# - - - - -
-# [make]
-# INCLUDE_PATH=%\>;INCLUDE_PATH%%\DJDIR%\include
-# LIBRARY_PATH=%\>;LIBRARY_PATH%%\DJDIR%\lib
-# BUTT=-m486
-# - - - - -
-# Alternately, these variables may be defined below, overriding the values
-# in djgpp.env, as
-# INCLUDE_PATH=c:\usr\include
-# LIBRARY_PATH=c:\usr\lib
-
-CC=gcc
-
-#CFLAGS=-MMD -O
-#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7
-#CFLAGS=-MMD -g -DDEBUG
-CFLAGS=-MMD -O3 $(BUTT) -Wall -Wwrite-strings -Wpointer-arith -Wconversion \
-             -Wstrict-prototypes -Wmissing-prototypes
-
-# If cp.exe is available, replace "copy /Y" with "cp -fp" .
-CP=copy /Y
-# If gnu install.exe is available, replace $(CP) with ginstall.
-INSTALL=$(CP)
-# The default value of RM is "rm -f."  If "rm.exe" is found, comment out:
-RM=del
-LDLIBS=-L. -lz
-LD=$(CC) -s -o
-LDSHARED=$(CC)
-
-INCL=zlib.h zconf.h
-LIBS=libz.a
-
-AR=ar rcs
-
-prefix=/usr/local
-exec_prefix = $(prefix)
-
-OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \
-       zutil.o inflate.o infback.o inftrees.o inffast.o
-
-OBJA =
-# to use the asm code: make OBJA=match.o
-
-TEST_OBJS = example.o minigzip.o
-
-all: example.exe minigzip.exe
-
-check: test
-test: all
-	./example
-	echo hello world | .\minigzip | .\minigzip -d
-
-%.o : %.c
-	$(CC) $(CFLAGS) -c $< -o $@
-
-libz.a: $(OBJS) $(OBJA)
-	$(AR) $@ $(OBJS) $(OBJA)
-
-%.exe : %.o $(LIBS)
-	$(LD) $@ $< $(LDLIBS)
-
-# INCLUDE_PATH and LIBRARY_PATH were set for [make] in djgpp.env .
-
-.PHONY : uninstall clean
-
-install: $(INCL) $(LIBS)
-	-@if not exist $(INCLUDE_PATH)\nul mkdir $(INCLUDE_PATH)
-	-@if not exist $(LIBRARY_PATH)\nul mkdir $(LIBRARY_PATH)
-	$(INSTALL) zlib.h $(INCLUDE_PATH)
-	$(INSTALL) zconf.h $(INCLUDE_PATH)
-	$(INSTALL) libz.a $(LIBRARY_PATH)
-
-uninstall:
-	$(RM) $(INCLUDE_PATH)\zlib.h
-	$(RM) $(INCLUDE_PATH)\zconf.h
-	$(RM) $(LIBRARY_PATH)\libz.a
-
-clean:
-	$(RM) *.d
-	$(RM) *.o
-	$(RM) *.exe
-	$(RM) libz.a
-	$(RM) foo.gz
-
-DEPS := $(wildcard *.d)
-ifneq ($(DEPS),)
-include $(DEPS)
-endif
diff -Nbaur gcc-4.6.3/zlib/msdos/Makefile.emx gcc-4.6.3-psp/zlib/msdos/Makefile.emx
--- gcc-4.6.3/zlib/msdos/Makefile.emx	2004-10-11 19:45:43.000000000 +0100
+++ gcc-4.6.3-psp/zlib/msdos/Makefile.emx	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-# Makefile for zlib.  Modified for emx 0.9c by Chr. Spieler, 6/17/98.
-# Copyright (C) 1995-1998 Jean-loup Gailly.
-# For conditions of distribution and use, see copyright notice in zlib.h
-
-# To compile, or to compile and test, type:
-#
-#   make -fmakefile.emx;  make test -fmakefile.emx
-#
-
-CC=gcc
-
-#CFLAGS=-MMD -O
-#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7
-#CFLAGS=-MMD -g -DDEBUG
-CFLAGS=-MMD -O3 $(BUTT) -Wall -Wwrite-strings -Wpointer-arith -Wconversion \
-             -Wstrict-prototypes -Wmissing-prototypes
-
-# If cp.exe is available, replace "copy /Y" with "cp -fp" .
-CP=copy /Y
-# If gnu install.exe is available, replace $(CP) with ginstall.
-INSTALL=$(CP)
-# The default value of RM is "rm -f."  If "rm.exe" is found, comment out:
-RM=del
-LDLIBS=-L. -lzlib
-LD=$(CC) -s -o
-LDSHARED=$(CC)
-
-INCL=zlib.h zconf.h
-LIBS=zlib.a
-
-AR=ar rcs
-
-prefix=/usr/local
-exec_prefix = $(prefix)
-
-OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \
-       zutil.o inflate.o infback.o inftrees.o inffast.o
-
-TEST_OBJS = example.o minigzip.o
-
-all: example.exe minigzip.exe
-
-test: all
-	./example
-	echo hello world | .\minigzip | .\minigzip -d
-
-%.o : %.c
-	$(CC) $(CFLAGS) -c $< -o $@
-
-zlib.a: $(OBJS)
-	$(AR) $@ $(OBJS)
-
-%.exe : %.o $(LIBS)
-	$(LD) $@ $< $(LDLIBS)
-
-
-.PHONY : clean
-
-clean:
-	$(RM) *.d
-	$(RM) *.o
-	$(RM) *.exe
-	$(RM) zlib.a
-	$(RM) foo.gz
-
-DEPS := $(wildcard *.d)
-ifneq ($(DEPS),)
-include $(DEPS)
-endif
diff -Nbaur gcc-4.6.3/zlib/msdos/Makefile.msc gcc-4.6.3-psp/zlib/msdos/Makefile.msc
--- gcc-4.6.3/zlib/msdos/Makefile.msc	2004-10-11 19:45:43.000000000 +0100
+++ gcc-4.6.3-psp/zlib/msdos/Makefile.msc	1970-01-01 01:00:00.000000000 +0100
@@ -1,106 +0,0 @@
-# Makefile for zlib
-# Microsoft C 5.1 or later
-# Last updated: 19-Mar-2003
-
-# To use, do "make makefile.msc"
-# To compile in small model, set below: MODEL=S
-
-# If you wish to reduce the memory requirements (default 256K for big
-# objects plus a few K), you can add to the LOC macro below:
-#   -DMAX_MEM_LEVEL=7 -DMAX_WBITS=14
-# See zconf.h for details about the memory requirements.
-
-# ------------- Microsoft C 5.1 and later -------------
-
-#    Optional nonstandard preprocessor flags (e.g. -DMAX_MEM_LEVEL=7)
-#    should be added to the environment via "set LOCAL_ZLIB=-DFOO" or added
-#    to the declaration of LOC here:
-LOC = $(LOCAL_ZLIB)
-
-# Type for CPU required: 0: 8086, 1: 80186, 2: 80286, 3: 80386, etc.
-CPU_TYP = 0
-
-# Memory model: one of S, M, C, L (small, medium, compact, large)
-MODEL=L
-
-CC=cl
-CFLAGS=-nologo -A$(MODEL) -G$(CPU_TYP) -W3 -Oait -Gs $(LOC)
-#-Ox generates bad code with MSC 5.1
-LIB_CFLAGS=-Zl $(CFLAGS)
-
-LD=link
-LDFLAGS=/noi/e/st:0x1500/noe/farcall/packcode
-# "/farcall/packcode" are only useful for `large code' memory models
-# but should be a "no-op" for small code models.
-
-
-# variables
-ZLIB_LIB = zlib_$(MODEL).lib
-
-OBJ1 = adler32.obj compress.obj crc32.obj deflate.obj gzio.obj infback.obj
-OBJ2 = inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj
-
-
-# targets
-all:  $(ZLIB_LIB) example.exe minigzip.exe
-
-.c.obj:
-	$(CC) -c $(LIB_CFLAGS) $*.c
-
-adler32.obj: adler32.c zlib.h zconf.h
-
-compress.obj: compress.c zlib.h zconf.h
-
-crc32.obj: crc32.c zlib.h zconf.h crc32.h
-
-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h
-
-gzio.obj: gzio.c zutil.h zlib.h zconf.h
-
-infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h
-
-inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h
-
-trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h
-
-uncompr.obj: uncompr.c zlib.h zconf.h
-
-zutil.obj: zutil.c zutil.h zlib.h zconf.h
-
-example.obj: example.c zlib.h zconf.h
-	$(CC) -c $(CFLAGS) $*.c
-
-minigzip.obj: minigzip.c zlib.h zconf.h
-	$(CC) -c $(CFLAGS) $*.c
-
-
-# the command line is cut to fit in the MS-DOS 128 byte limit:
-$(ZLIB_LIB): $(OBJ1) $(OBJ2)
-	if exist $(ZLIB_LIB) del $(ZLIB_LIB)
-	lib $(ZLIB_LIB) $(OBJ1);
-	lib $(ZLIB_LIB) $(OBJ2);
-
-example.exe: example.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) example.obj,,,$(ZLIB_LIB);
-
-minigzip.exe: minigzip.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) minigzip.obj,,,$(ZLIB_LIB);
-
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d
-
-clean:
-	-del *.obj
-	-del *.lib
-	-del *.exe
-	-del *.map
-	-del zlib_*.bak
-	-del foo.gz
diff -Nbaur gcc-4.6.3/zlib/msdos/Makefile.tc gcc-4.6.3-psp/zlib/msdos/Makefile.tc
--- gcc-4.6.3/zlib/msdos/Makefile.tc	2004-10-11 19:45:43.000000000 +0100
+++ gcc-4.6.3-psp/zlib/msdos/Makefile.tc	1970-01-01 01:00:00.000000000 +0100
@@ -1,94 +0,0 @@
-# Makefile for zlib
-# Turbo C 2.01, Turbo C++ 1.01
-# Last updated: 15-Mar-2003
-
-# To use, do "make -fmakefile.tc"
-# To compile in small model, set below: MODEL=s
-
-# WARNING: the small model is supported but only for small values of
-# MAX_WBITS and MAX_MEM_LEVEL. For example:
-#    -DMAX_WBITS=11 -DMAX_MEM_LEVEL=3
-# If you wish to reduce the memory requirements (default 256K for big
-# objects plus a few K), you can add to CFLAGS below:
-#   -DMAX_MEM_LEVEL=7 -DMAX_WBITS=14
-# See zconf.h for details about the memory requirements.
-
-# ------------ Turbo C 2.01, Turbo C++ 1.01 ------------
-MODEL=l
-CC=tcc
-LD=tcc
-AR=tlib
-# CFLAGS=-O2 -G -Z -m$(MODEL) -DMAX_WBITS=11 -DMAX_MEM_LEVEL=3
-CFLAGS=-O2 -G -Z -m$(MODEL)
-LDFLAGS=-m$(MODEL) -f-
-
-
-# variables
-ZLIB_LIB = zlib_$(MODEL).lib
-
-OBJ1 = adler32.obj compress.obj crc32.obj deflate.obj gzio.obj infback.obj
-OBJ2 = inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj
-OBJP1 = +adler32.obj+compress.obj+crc32.obj+deflate.obj+gzio.obj+infback.obj
-OBJP2 = +inffast.obj+inflate.obj+inftrees.obj+trees.obj+uncompr.obj+zutil.obj
-
-
-# targets
-all: $(ZLIB_LIB) example.exe minigzip.exe
-
-.c.obj:
-	$(CC) -c $(CFLAGS) $*.c
-
-adler32.obj: adler32.c zlib.h zconf.h
-
-compress.obj: compress.c zlib.h zconf.h
-
-crc32.obj: crc32.c zlib.h zconf.h crc32.h
-
-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h
-
-gzio.obj: gzio.c zutil.h zlib.h zconf.h
-
-infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h
-
-inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h
-
-trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h
-
-uncompr.obj: uncompr.c zlib.h zconf.h
-
-zutil.obj: zutil.c zutil.h zlib.h zconf.h
-
-example.obj: example.c zlib.h zconf.h
-
-minigzip.obj: minigzip.c zlib.h zconf.h
-
-
-# the command line is cut to fit in the MS-DOS 128 byte limit:
-$(ZLIB_LIB): $(OBJ1) $(OBJ2)
-	-del $(ZLIB_LIB)
-	$(AR) $(ZLIB_LIB) $(OBJP1)
-	$(AR) $(ZLIB_LIB) $(OBJP2)
-
-example.exe: example.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) example.obj $(ZLIB_LIB)
-
-minigzip.exe: minigzip.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) minigzip.obj $(ZLIB_LIB)
-
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d
-
-clean:
-	-del *.obj
-	-del *.lib
-	-del *.exe
-	-del zlib_*.bak
-	-del foo.gz
diff -Nbaur gcc-4.6.3/zlib/old/descrip.mms gcc-4.6.3-psp/zlib/old/descrip.mms
--- gcc-4.6.3/zlib/old/descrip.mms	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/old/descrip.mms	1970-01-01 01:00:00.000000000 +0100
@@ -1,48 +0,0 @@
-# descrip.mms: MMS description file for building zlib on VMS
-# written by Martin P.J. Zinser <m.zinser@gsi.de>
-
-cc_defs =
-c_deb =
-
-.ifdef __DECC__
-pref = /prefix=all
-.endif
-
-OBJS = adler32.obj, compress.obj, crc32.obj, gzio.obj, uncompr.obj,\
-       deflate.obj, trees.obj, zutil.obj, inflate.obj, infblock.obj,\
-       inftrees.obj, infcodes.obj, infutil.obj, inffast.obj
-
-CFLAGS= $(C_DEB) $(CC_DEFS) $(PREF)
-
-all : example.exe minigzip.exe
-        @ write sys$output " Example applications available"
-libz.olb : libz.olb($(OBJS))
-	@ write sys$output " libz available"
-
-example.exe : example.obj libz.olb
-              link example,libz.olb/lib
-
-minigzip.exe : minigzip.obj libz.olb
-              link minigzip,libz.olb/lib,x11vms:xvmsutils.olb/lib
-
-clean :
-	delete *.obj;*,libz.olb;*
-
-
-# Other dependencies.
-adler32.obj : zutil.h zlib.h zconf.h
-compress.obj : zlib.h zconf.h
-crc32.obj : zutil.h zlib.h zconf.h
-deflate.obj : deflate.h zutil.h zlib.h zconf.h
-example.obj : zlib.h zconf.h
-gzio.obj : zutil.h zlib.h zconf.h
-infblock.obj : zutil.h zlib.h zconf.h infblock.h inftrees.h infcodes.h infutil.h
-infcodes.obj : zutil.h zlib.h zconf.h inftrees.h infutil.h infcodes.h inffast.h
-inffast.obj : zutil.h zlib.h zconf.h inftrees.h infutil.h inffast.h
-inflate.obj : zutil.h zlib.h zconf.h infblock.h
-inftrees.obj : zutil.h zlib.h zconf.h inftrees.h
-infutil.obj : zutil.h zlib.h zconf.h inftrees.h infutil.h
-minigzip.obj : zlib.h zconf.h
-trees.obj : deflate.h zutil.h zlib.h zconf.h
-uncompr.obj : zlib.h zconf.h
-zutil.obj : zutil.h zlib.h zconf.h
diff -Nbaur gcc-4.6.3/zlib/old/Makefile.riscos gcc-4.6.3-psp/zlib/old/Makefile.riscos
--- gcc-4.6.3/zlib/old/Makefile.riscos	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/old/Makefile.riscos	1970-01-01 01:00:00.000000000 +0100
@@ -1,151 +0,0 @@
-# Project:   zlib_1_03
-# Patched for zlib 1.1.2 rw@shadow.org.uk 19980430
-# test works out-of-the-box, installs `somewhere' on demand
-
-# Toolflags:
-CCflags = -c -depend !Depend -IC: -g -throwback  -DRISCOS  -fah
-C++flags = -c -depend !Depend -IC: -throwback
-Linkflags = -aif -c++ -o $@
-ObjAsmflags = -throwback -NoCache -depend !Depend
-CMHGflags =
-LibFileflags = -c -l -o $@
-Squeezeflags = -o $@
-
-# change the line below to where _you_ want the library installed.
-libdest = lib:zlib
-
-# Final targets:
-@.lib:   @.o.adler32 @.o.compress @.o.crc32 @.o.deflate @.o.gzio \
-        @.o.infblock @.o.infcodes @.o.inffast @.o.inflate @.o.inftrees @.o.infutil @.o.trees \
-        @.o.uncompr @.o.zutil
-        LibFile $(LibFileflags) @.o.adler32 @.o.compress @.o.crc32 @.o.deflate \
-        @.o.gzio @.o.infblock @.o.infcodes @.o.inffast @.o.inflate @.o.inftrees @.o.infutil \
-        @.o.trees @.o.uncompr @.o.zutil
-test:   @.minigzip @.example @.lib
-	@copy @.lib @.libc  A~C~DF~L~N~P~Q~RS~TV
-	@echo running tests: hang on.
-	@/@.minigzip -f -9 libc
-	@/@.minigzip -d libc-gz
-	@/@.minigzip -f -1 libc
-	@/@.minigzip -d libc-gz
-	@/@.minigzip -h -9 libc
-	@/@.minigzip -d libc-gz
-	@/@.minigzip -h -1 libc
-	@/@.minigzip -d libc-gz
-	@/@.minigzip -9 libc
-	@/@.minigzip -d libc-gz
-	@/@.minigzip -1 libc
-	@/@.minigzip -d libc-gz
-	@diff @.lib @.libc
-	@echo that should have reported '@.lib and @.libc identical' if you have diff.
-	@/@.example @.fred @.fred
-	@echo that will have given lots of hello!'s.
-
-@.minigzip:   @.o.minigzip @.lib C:o.Stubs
-        Link $(Linkflags) @.o.minigzip @.lib C:o.Stubs
-@.example:   @.o.example @.lib C:o.Stubs
-        Link $(Linkflags) @.o.example @.lib C:o.Stubs
-
-install: @.lib
-	cdir $(libdest)
-	cdir $(libdest).h
-	@copy @.h.zlib $(libdest).h.zlib A~C~DF~L~N~P~Q~RS~TV
-	@copy @.h.zconf $(libdest).h.zconf A~C~DF~L~N~P~Q~RS~TV
-	@copy @.lib $(libdest).lib  A~C~DF~L~N~P~Q~RS~TV
-	@echo okay, installed zlib in $(libdest)
-
-clean:; remove @.minigzip
-	remove @.example
-	remove @.libc
-	-wipe @.o.* F~r~cV
-	remove @.fred
-
-# User-editable dependencies:
-.c.o:
-        cc $(ccflags) -o $@ $<
-
-# Static dependencies:
-
-# Dynamic dependencies:
-o.example:	c.example
-o.example:	h.zlib
-o.example:	h.zconf
-o.minigzip:	c.minigzip
-o.minigzip:	h.zlib
-o.minigzip:	h.zconf
-o.adler32:	c.adler32
-o.adler32:	h.zlib
-o.adler32:	h.zconf
-o.compress:	c.compress
-o.compress:	h.zlib
-o.compress:	h.zconf
-o.crc32:	c.crc32
-o.crc32:	h.zlib
-o.crc32:	h.zconf
-o.deflate:	c.deflate
-o.deflate:	h.deflate
-o.deflate:	h.zutil
-o.deflate:	h.zlib
-o.deflate:	h.zconf
-o.gzio:	c.gzio
-o.gzio:	h.zutil
-o.gzio:	h.zlib
-o.gzio:	h.zconf
-o.infblock:	c.infblock
-o.infblock:	h.zutil
-o.infblock:	h.zlib
-o.infblock:	h.zconf
-o.infblock:	h.infblock
-o.infblock:	h.inftrees
-o.infblock:	h.infcodes
-o.infblock:	h.infutil
-o.infcodes:	c.infcodes
-o.infcodes:	h.zutil
-o.infcodes:	h.zlib
-o.infcodes:	h.zconf
-o.infcodes:	h.inftrees
-o.infcodes:	h.infblock
-o.infcodes:	h.infcodes
-o.infcodes:	h.infutil
-o.infcodes:	h.inffast
-o.inffast:	c.inffast
-o.inffast:	h.zutil
-o.inffast:	h.zlib
-o.inffast:	h.zconf
-o.inffast:	h.inftrees
-o.inffast:	h.infblock
-o.inffast:	h.infcodes
-o.inffast:	h.infutil
-o.inffast:	h.inffast
-o.inflate:	c.inflate
-o.inflate:	h.zutil
-o.inflate:	h.zlib
-o.inflate:	h.zconf
-o.inflate:	h.infblock
-o.inftrees:	c.inftrees
-o.inftrees:	h.zutil
-o.inftrees:	h.zlib
-o.inftrees:	h.zconf
-o.inftrees:	h.inftrees
-o.inftrees:	h.inffixed
-o.infutil:	c.infutil
-o.infutil:	h.zutil
-o.infutil:	h.zlib
-o.infutil:	h.zconf
-o.infutil:	h.infblock
-o.infutil:	h.inftrees
-o.infutil:	h.infcodes
-o.infutil:	h.infutil
-o.trees:	c.trees
-o.trees:	h.deflate
-o.trees:	h.zutil
-o.trees:	h.zlib
-o.trees:	h.zconf
-o.trees:	h.trees
-o.uncompr:	c.uncompr
-o.uncompr:	h.zlib
-o.uncompr:	h.zconf
-o.zutil:	c.zutil
-o.zutil:	h.zutil
-o.zutil:	h.zlib
-o.zutil:	h.zconf
diff -Nbaur gcc-4.6.3/zlib/old/os2/Makefile.os2 gcc-4.6.3-psp/zlib/old/os2/Makefile.os2
--- gcc-4.6.3/zlib/old/os2/Makefile.os2	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/old/os2/Makefile.os2	1970-01-01 01:00:00.000000000 +0100
@@ -1,136 +0,0 @@
-# Makefile for zlib under OS/2 using GCC (PGCC)
-# For conditions of distribution and use, see copyright notice in zlib.h
-
-# To compile and test, type:
-#   cp Makefile.os2 ..
-#   cd ..
-#   make -f Makefile.os2 test
-
-# This makefile will build a static library z.lib, a shared library
-# z.dll and a import library zdll.lib. You can use either z.lib or
-# zdll.lib by specifying either -lz or -lzdll on gcc's command line
-
-CC=gcc -Zomf -s
-
-CFLAGS=-O6 -Wall
-#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7
-#CFLAGS=-g -DDEBUG
-#CFLAGS=-O3 -Wall -Wwrite-strings -Wpointer-arith -Wconversion \
-#           -Wstrict-prototypes -Wmissing-prototypes
-
-#################### BUG WARNING: #####################
-## infcodes.c hits a bug in pgcc-1.0, so you have to use either
-## -O# where # <= 4 or one of (-fno-ommit-frame-pointer or -fno-force-mem)
-## This bug is reportedly fixed in pgcc >1.0, but this was not tested
-CFLAGS+=-fno-force-mem
-
-LDFLAGS=-s -L. -lzdll -Zcrtdll
-LDSHARED=$(CC) -s -Zomf -Zdll -Zcrtdll
-
-VER=1.1.0
-ZLIB=z.lib
-SHAREDLIB=z.dll
-SHAREDLIBIMP=zdll.lib
-LIBS=$(ZLIB) $(SHAREDLIB) $(SHAREDLIBIMP)
-
-AR=emxomfar cr
-IMPLIB=emximp
-RANLIB=echo
-TAR=tar
-SHELL=bash
-
-prefix=/usr/local
-exec_prefix = $(prefix)
-
-OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \
-       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o
-
-TEST_OBJS = example.o minigzip.o
-
-DISTFILES = README INDEX ChangeLog configure Make*[a-z0-9] *.[ch] descrip.mms \
-  algorithm.txt zlib.3 msdos/Make*[a-z0-9] msdos/zlib.def msdos/zlib.rc \
-  nt/Makefile.nt nt/zlib.dnt  contrib/README.contrib contrib/*.txt \
-  contrib/asm386/*.asm contrib/asm386/*.c \
-  contrib/asm386/*.bat contrib/asm386/zlibvc.d?? contrib/iostream/*.cpp \
-  contrib/iostream/*.h  contrib/iostream2/*.h contrib/iostream2/*.cpp \
-  contrib/untgz/Makefile contrib/untgz/*.c contrib/untgz/*.w32
-
-all: example.exe minigzip.exe
-
-test: all
-	@LD_LIBRARY_PATH=.:$(LD_LIBRARY_PATH) ; export LD_LIBRARY_PATH; \
-	echo hello world | ./minigzip | ./minigzip -d || \
-	  echo '		*** minigzip test FAILED ***' ; \
-	if ./example; then \
-	  echo '		*** zlib test OK ***'; \
-	else \
-	  echo '		*** zlib test FAILED ***'; \
-	fi
-
-$(ZLIB): $(OBJS)
-	$(AR) $@ $(OBJS)
-	-@ ($(RANLIB) $@ || true) >/dev/null 2>&1
-
-$(SHAREDLIB): $(OBJS) os2/z.def
-	$(LDSHARED) -o $@ $^
-
-$(SHAREDLIBIMP): os2/z.def
-	$(IMPLIB) -o $@ $^
-
-example.exe: example.o $(LIBS)
-	$(CC) $(CFLAGS) -o $@ example.o $(LDFLAGS)
-
-minigzip.exe: minigzip.o $(LIBS)
-	$(CC) $(CFLAGS) -o $@ minigzip.o $(LDFLAGS)
-
-clean:
-	rm -f *.o *~ example minigzip libz.a libz.so* foo.gz
-
-distclean:	clean
-
-zip:
-	mv Makefile Makefile~; cp -p Makefile.in Makefile
-	rm -f test.c ztest*.c
-	v=`sed -n -e 's/\.//g' -e '/VERSION "/s/.*"\(.*\)".*/\1/p' < zlib.h`;\
-	zip -ul9 zlib$$v $(DISTFILES)
-	mv Makefile~ Makefile
-
-dist:
-	mv Makefile Makefile~; cp -p Makefile.in Makefile
-	rm -f test.c ztest*.c
-	d=zlib-`sed -n '/VERSION "/s/.*"\(.*\)".*/\1/p' < zlib.h`;\
-	rm -f $$d.tar.gz; \
-	if test ! -d ../$$d; then rm -f ../$$d; ln -s `pwd` ../$$d; fi; \
-	files=""; \
-	for f in $(DISTFILES); do files="$$files $$d/$$f"; done; \
-	cd ..; \
-	GZIP=-9 $(TAR) chofz $$d/$$d.tar.gz $$files; \
-	if test ! -d $$d; then rm -f $$d; fi
-	mv Makefile~ Makefile
-
-tags:
-	etags *.[ch]
-
-depend:
-	makedepend -- $(CFLAGS) -- *.[ch]
-
-# DO NOT DELETE THIS LINE -- make depend depends on it.
-
-adler32.o: zlib.h zconf.h
-compress.o: zlib.h zconf.h
-crc32.o: zlib.h zconf.h
-deflate.o: deflate.h zutil.h zlib.h zconf.h
-example.o: zlib.h zconf.h
-gzio.o: zutil.h zlib.h zconf.h
-infblock.o: infblock.h inftrees.h infcodes.h infutil.h zutil.h zlib.h zconf.h
-infcodes.o: zutil.h zlib.h zconf.h
-infcodes.o: inftrees.h infblock.h infcodes.h infutil.h inffast.h
-inffast.o: zutil.h zlib.h zconf.h inftrees.h
-inffast.o: infblock.h infcodes.h infutil.h inffast.h
-inflate.o: zutil.h zlib.h zconf.h infblock.h
-inftrees.o: zutil.h zlib.h zconf.h inftrees.h
-infutil.o: zutil.h zlib.h zconf.h infblock.h inftrees.h infcodes.h infutil.h
-minigzip.o: zlib.h zconf.h
-trees.o: deflate.h zutil.h zlib.h zconf.h trees.h
-uncompr.o: zlib.h zconf.h
-zutil.o: zutil.h zlib.h zconf.h
diff -Nbaur gcc-4.6.3/zlib/old/os2/zlib.def gcc-4.6.3-psp/zlib/old/os2/zlib.def
--- gcc-4.6.3/zlib/old/os2/zlib.def	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/old/os2/zlib.def	1970-01-01 01:00:00.000000000 +0100
@@ -1,51 +0,0 @@
-;
-; Slightly modified version of ../nt/zlib.dnt :-)
-;
-
-LIBRARY		Z
-DESCRIPTION	"Zlib compression library for OS/2"
-CODE		PRELOAD MOVEABLE DISCARDABLE
-DATA		PRELOAD MOVEABLE MULTIPLE
-
-EXPORTS
-    adler32
-    compress
-    crc32
-    deflate
-    deflateCopy
-    deflateEnd
-    deflateInit2_
-    deflateInit_
-    deflateParams
-    deflateReset
-    deflateSetDictionary
-    gzclose
-    gzdopen
-    gzerror
-    gzflush
-    gzopen
-    gzread
-    gzwrite
-    inflate
-    inflateEnd
-    inflateInit2_
-    inflateInit_
-    inflateReset
-    inflateSetDictionary
-    inflateSync
-    uncompress
-    zlibVersion
-    gzprintf
-    gzputc
-    gzgetc
-    gzseek
-    gzrewind
-    gztell
-    gzeof
-    gzsetparams
-    zError
-    inflateSyncPoint
-    get_crc_table
-    compress2
-    gzputs
-    gzgets
diff -Nbaur gcc-4.6.3/zlib/old/README gcc-4.6.3-psp/zlib/old/README
--- gcc-4.6.3/zlib/old/README	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/old/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-This directory contains files that have not been updated for zlib 1.2.x
-
-(Volunteers are encouraged to help clean this up.  Thanks.)
diff -Nbaur gcc-4.6.3/zlib/old/visual-basic.txt gcc-4.6.3-psp/zlib/old/visual-basic.txt
--- gcc-4.6.3/zlib/old/visual-basic.txt	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/old/visual-basic.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,160 +0,0 @@
-See below some functions declarations for Visual Basic.
-
-Frequently Asked Question:
-
-Q: Each time I use the compress function I get the -5 error (not enough
-   room in the output buffer).
-
-A: Make sure that the length of the compressed buffer is passed by
-   reference ("as any"), not by value ("as long"). Also check that
-   before the call of compress this length is equal to the total size of
-   the compressed buffer and not zero.
-
-
-From: "Jon Caruana" <jon-net@usa.net>
-Subject: Re: How to port zlib declares to vb?
-Date: Mon, 28 Oct 1996 18:33:03 -0600
-
-Got the answer! (I haven't had time to check this but it's what I got, and
-looks correct):
-
-He has the following routines working:
-        compress
-        uncompress
-        gzopen
-        gzwrite
-        gzread
-        gzclose
-
-Declares follow: (Quoted from Carlos Rios <c_rios@sonda.cl>, in Vb4 form)
-
-#If Win16 Then   'Use Win16 calls.
-Declare Function compress Lib "ZLIB.DLL" (ByVal compr As
-        String, comprLen As Any, ByVal buf As String, ByVal buflen
-        As Long) As Integer
-Declare Function uncompress Lib "ZLIB.DLL" (ByVal uncompr
-        As String, uncomprLen As Any, ByVal compr As String, ByVal
-        lcompr As Long) As Integer
-Declare Function gzopen Lib "ZLIB.DLL" (ByVal filePath As
-        String, ByVal mode As String) As Long
-Declare Function gzread Lib "ZLIB.DLL" (ByVal file As
-        Long, ByVal uncompr As String, ByVal uncomprLen As Integer)
-        As Integer
-Declare Function gzwrite Lib "ZLIB.DLL" (ByVal file As
-        Long, ByVal uncompr As String, ByVal uncomprLen As Integer)
-        As Integer
-Declare Function gzclose Lib "ZLIB.DLL" (ByVal file As
-        Long) As Integer
-#Else
-Declare Function compress Lib "ZLIB32.DLL"
-        (ByVal compr As String, comprLen As Any, ByVal buf As
-        String, ByVal buflen As Long) As Integer
-Declare Function uncompress Lib "ZLIB32.DLL"
-        (ByVal uncompr As String, uncomprLen As Any, ByVal compr As
-        String, ByVal lcompr As Long) As Long
-Declare Function gzopen Lib "ZLIB32.DLL"
-        (ByVal file As String, ByVal mode As String) As Long
-Declare Function gzread Lib "ZLIB32.DLL"
-        (ByVal file As Long, ByVal uncompr As String, ByVal
-        uncomprLen As Long) As Long
-Declare Function gzwrite Lib "ZLIB32.DLL"
-        (ByVal file As Long, ByVal uncompr As String, ByVal
-        uncomprLen As Long) As Long
-Declare Function gzclose Lib "ZLIB32.DLL"
-        (ByVal file As Long) As Long
-#End If
-
--Jon Caruana
-jon-net@usa.net
-Microsoft Sitebuilder Network Level 1 Member - HTML Writer's Guild Member
-
-
-Here is another example from Michael <michael_borgsys@hotmail.com> that he
-says conforms to the VB guidelines, and that solves the problem of not
-knowing the uncompressed size by storing it at the end of the file:
-
-'Calling the functions:
-'bracket meaning: <parameter> [optional] {Range of possible values}
-'Call subCompressFile(<path with filename to compress> [, <path with
-filename to write to>, [level of compression {1..9}]])
-'Call subUncompressFile(<path with filename to compress>)
-
-Option Explicit
-Private lngpvtPcnSml As Long 'Stores value for 'lngPercentSmaller'
-Private Const SUCCESS As Long = 0
-Private Const strFilExt As String = ".cpr"
-Private Declare Function lngfncCpr Lib "zlib.dll" Alias "compress2" (ByRef
-dest As Any, ByRef destLen As Any, ByRef src As Any, ByVal srcLen As Long,
-ByVal level As Integer) As Long
-Private Declare Function lngfncUcp Lib "zlib.dll" Alias "uncompress" (ByRef
-dest As Any, ByRef destLen As Any, ByRef src As Any, ByVal srcLen As Long)
-As Long
-
-Public Sub subCompressFile(ByVal strargOriFilPth As String, Optional ByVal
-strargCprFilPth As String, Optional ByVal intLvl As Integer = 9)
-    Dim strCprPth As String
-    Dim lngOriSiz As Long
-    Dim lngCprSiz As Long
-    Dim bytaryOri() As Byte
-    Dim bytaryCpr() As Byte
-    lngOriSiz = FileLen(strargOriFilPth)
-    ReDim bytaryOri(lngOriSiz - 1)
-    Open strargOriFilPth For Binary Access Read As #1
-        Get #1, , bytaryOri()
-    Close #1
-    strCprPth = IIf(strargCprFilPth = "", strargOriFilPth, strargCprFilPth)
-'Select file path and name
-    strCprPth = strCprPth & IIf(Right(strCprPth, Len(strFilExt)) =
-strFilExt, "", strFilExt) 'Add file extension if not exists
-    lngCprSiz = (lngOriSiz * 1.01) + 12 'Compression needs temporary a bit
-more space then original file size
-    ReDim bytaryCpr(lngCprSiz - 1)
-    If lngfncCpr(bytaryCpr(0), lngCprSiz, bytaryOri(0), lngOriSiz, intLvl) =
-SUCCESS Then
-        lngpvtPcnSml = (1# - (lngCprSiz / lngOriSiz)) * 100
-        ReDim Preserve bytaryCpr(lngCprSiz - 1)
-        Open strCprPth For Binary Access Write As #1
-            Put #1, , bytaryCpr()
-            Put #1, , lngOriSiz 'Add the the original size value to the end
-(last 4 bytes)
-        Close #1
-    Else
-        MsgBox "Compression error"
-    End If
-    Erase bytaryCpr
-    Erase bytaryOri
-End Sub
-
-Public Sub subUncompressFile(ByVal strargFilPth As String)
-    Dim bytaryCpr() As Byte
-    Dim bytaryOri() As Byte
-    Dim lngOriSiz As Long
-    Dim lngCprSiz As Long
-    Dim strOriPth As String
-    lngCprSiz = FileLen(strargFilPth)
-    ReDim bytaryCpr(lngCprSiz - 1)
-    Open strargFilPth For Binary Access Read As #1
-        Get #1, , bytaryCpr()
-    Close #1
-    'Read the original file size value:
-    lngOriSiz = bytaryCpr(lngCprSiz - 1) * (2 ^ 24) _
-              + bytaryCpr(lngCprSiz - 2) * (2 ^ 16) _
-              + bytaryCpr(lngCprSiz - 3) * (2 ^ 8) _
-              + bytaryCpr(lngCprSiz - 4)
-    ReDim Preserve bytaryCpr(lngCprSiz - 5) 'Cut of the original size value
-    ReDim bytaryOri(lngOriSiz - 1)
-    If lngfncUcp(bytaryOri(0), lngOriSiz, bytaryCpr(0), lngCprSiz) = SUCCESS
-Then
-        strOriPth = Left(strargFilPth, Len(strargFilPth) - Len(strFilExt))
-        Open strOriPth For Binary Access Write As #1
-            Put #1, , bytaryOri()
-        Close #1
-    Else
-        MsgBox "Uncompression error"
-    End If
-    Erase bytaryCpr
-    Erase bytaryOri
-End Sub
-Public Property Get lngPercentSmaller() As Long
-    lngPercentSmaller = lngpvtPcnSml
-End Property
diff -Nbaur gcc-4.6.3/zlib/old/zlib.html gcc-4.6.3-psp/zlib/old/zlib.html
--- gcc-4.6.3/zlib/old/zlib.html	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/old/zlib.html	1970-01-01 01:00:00.000000000 +0100
@@ -1,971 +0,0 @@
-<html>
-<head>
- <title>
- zlib general purpose compression library version 1.1.4
- </title>
-</head>
-<body bgcolor="White" text="Black" vlink="Red" alink="Navy" link="Red">
-<!-- background="zlibbg.gif" -->
-
-<h1> zlib 1.1.4 Manual </h1>
-<hr>
-<a name="Contents"><h2>Contents</h2>
-<ol type="I">
-<li> <a href="#Prologue">Prologue</a>
-<li> <a href="#Introduction">Introduction</a>
-<li> <a href="#Utility functions">Utility functions</a>
-<li> <a href="#Basic functions">Basic functions</a>
-<li> <a href="#Advanced functions">Advanced functions</a>
-<li> <a href="#Constants">Constants</a>
-<li> <a href="#struct z_stream_s">struct z_stream_s</a>
-<li> <a href="#Checksum functions">Checksum functions</a>
-<li> <a href="#Misc">Misc</a>
-</ol>
-<hr>
-<a name="Prologue"><h2> Prologue </h2>
-  'zlib' general purpose compression library version 1.1.4, March 11th, 2002
-  <p>
-  Copyright (C) 1995-2002 Jean-loup Gailly and Mark Adler
-  <p>
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-  <p>
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-  <ol>
-   <li> The origin of this software must not be misrepresented ; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-   <li> Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-   <li> This notice may not be removed or altered from any source distribution.
-  </ol>
-
-  <dl>
-  <dt>Jean-loup Gailly
-  <dd><a href="mailto:jloup@gzip.org">jloup@gzip.org</a>
-  <dt>Mark Adler
-  <dd><a href="mailto:madler@alumni.caltech.edu">madler@alumni.caltech.edu</a>
-  </dl>
-
-  The data format used by the zlib library is described by RFCs (Request for
-  Comments) 1950 to 1952 in the files
-  <a href="ftp://ds.internic.net/rfc/rfc1950.txt">
-  ftp://ds.internic.net/rfc/rfc1950.txt </a>
-  (zlib format),
-  <a href="ftp://ds.internic.net/rfc/rfc1951.txt">
-  rfc1951.txt </a>
-  (<a href="#deflate">deflate</a> format) and
-  <a href="ftp://ds.internic.net/rfc/rfc1952.txt">
-  rfc1952.txt </a>
-  (gzip format).
-  <p>
-  This manual is converted from zlib.h by
-  <a href="mailto:piaip@csie.ntu.edu.tw"> piaip </a>
-  <p>
-  Visit <a href="http://ftp.cdrom.com/pub/infozip/zlib/">
-  http://ftp.cdrom.com/pub/infozip/zlib/</a>
-  for the official zlib web page.
-  <p>
-
-<hr>
-<a name="Introduction"><h2> Introduction </h2>
-     The 'zlib' compression library provides in-memory compression and
-  decompression functions, including integrity checks of the uncompressed
-  data.  This version of the library supports only one compression method
-  (deflation) but other algorithms will be added later and will have the same
-  stream interface.
-  <p>
-
-     Compression can be done in a single step if the buffers are large
-  enough (for example if an input file is mmap'ed), or can be done by
-  repeated calls of the compression function.  In the latter case, the
-  application must provide more input and/or consume the output
-  (providing more output space) before each call.
-  <p>
-
-     The library also supports reading and writing files in gzip (.gz) format
-  with an interface similar to that of stdio.
-  <p>
-
-     The library does not install any signal handler. The decoder checks
-  the consistency of the compressed data, so the library should never
-  crash even in case of corrupted input.
-  <p>
-
-<hr>
-<a name="Utility functions"><h2> Utility functions </h2>
-     The following utility functions are implemented on top of the
-   <a href="#Basic functions">basic stream-oriented functions</a>.
-   To simplify the interface, some
-   default options are assumed (compression level and memory usage,
-   standard memory allocation functions). The source code of these
-   utility functions can easily be modified if you need special options.
-<h3> Function list </h3>
-<ul>
-<li> int  <a href="#compress">compress</a> (Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen);
-<li> int  <a href="#compress2">compress2</a> (Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen, int level);
-<li> int  <a href="#uncompress">uncompress</a> (Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen);
-<li> typedef voidp gzFile;
-<li>  gzFile  <a href="#gzopen">gzopen</a>  (const char *path, const char *mode);
-<li> gzFile  <a href="#gzdopen">gzdopen</a>  (int fd, const char *mode);
-<li> int  <a href="#gzsetparams">gzsetparams</a> (gzFile file, int level, int strategy);
-<li> int     <a href="#gzread">gzread</a>  (gzFile file, voidp buf, unsigned len);
-<li> int     <a href="#gzwrite">gzwrite</a> (gzFile file, const voidp buf, unsigned len);
-<li> int VA   <a href="#gzprintf">gzprintf</a> (gzFile file, const char *format, ...);
-<li> int  <a href="#gzputs">gzputs</a> (gzFile file, const char *s);
-<li> char *  <a href="#gzgets">gzgets</a> (gzFile file, char *buf, int len);
-<li> int     <a href="#gzputc">gzputc</a> (gzFile file, int c);
-<li> int     <a href="#gzgetc">gzgetc</a> (gzFile file);
-<li> int     <a href="#gzflush">gzflush</a> (gzFile file, int flush);
-<li> z_off_t     <a href="#gzseek">gzseek</a> (gzFile file, z_off_t offset, int whence);
-<li> z_off_t     <a href="#gztell">gztell</a> (gzFile file);
-<li> int     <a href="#gzrewind">gzrewind</a> (gzFile file);
-<li> int  <a href="#gzeof">gzeof</a> (gzFile file);
-<li> int     <a href="#gzclose">gzclose</a> (gzFile file);
-<li> const char *  <a href="#gzerror">gzerror</a> (gzFile file, int *errnum);
-</ul>
-<h3> Function description </h3>
-<dl>
-<font color="Blue"><dt> int  <a name="compress">compress</a> (Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen);</font>
-<dd>
-     Compresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer. Upon entry, destLen is the total
-   size of the destination buffer, which must be at least 0.1% larger than
-   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
-   compressed buffer.<p>
-     This function can be used to <a href="#compress">compress</a> a whole file at once if the
-   input file is mmap'ed.<p>
-     <a href="#compress">compress</a> returns <a href="#Z_OK">Z_OK</a> if success, <a href="#Z_MEM_ERROR">Z_MEM_ERROR</a> if there was not
-   enough memory, <a href="#Z_BUF_ERROR">Z_BUF_ERROR</a> if there was not enough room in the output
-   buffer.<p>
-
-<font color="Blue"><dt> int  <a name="compress2">compress2</a> (Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen, int level);</font>
-<dd>
-     Compresses the source buffer into the destination buffer. The level
-   parameter has the same meaning as in <a href="#deflateInit">deflateInit</a>.  sourceLen is the byte
-   length of the source buffer. Upon entry, destLen is the total size of the
-   destination buffer, which must be at least 0.1% larger than sourceLen plus
-   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
-   <p>
-
-     <a href="#compress2">compress2</a> returns <a href="#Z_OK">Z_OK</a> if success, <a href="#Z_MEM_ERROR">Z_MEM_ERROR</a> if there was not enough
-   memory, <a href="#Z_BUF_ERROR">Z_BUF_ERROR</a> if there was not enough room in the output buffer,
-   <a href="#Z_STREAM_ERROR">Z_STREAM_ERROR</a> if the level parameter is invalid.
-   <p>
-
-<font color="Blue"><dt> int  <a name="uncompress">uncompress</a> (Bytef *dest,   uLongf *destLen, const Bytef *source, uLong sourceLen);</font>
-<dd>
-     Decompresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer. Upon entry, destLen is the total
-   size of the destination buffer, which must be large enough to hold the
-   entire uncompressed data. (The size of the uncompressed data must have
-   been saved previously by the compressor and transmitted to the decompressor
-   by some mechanism outside the scope of this compression library.)
-   Upon exit, destLen is the actual size of the compressed buffer. <p>
-     This function can be used to decompress a whole file at once if the
-   input file is mmap'ed.
-   <p>
-
-     <a href="#uncompress">uncompress</a> returns <a href="#Z_OK">Z_OK</a> if success, <a href="#Z_MEM_ERROR">Z_MEM_ERROR</a> if there was not
-   enough memory, <a href="#Z_BUF_ERROR">Z_BUF_ERROR</a> if there was not enough room in the output
-   buffer, or <a href="#Z_DATA_ERROR">Z_DATA_ERROR</a> if the input data was corrupted.
-   <p>
-
-<dt> typedef voidp gzFile;
-<dd> <p>
-
-<font color="Blue"><dt>  gzFile  <a name="gzopen">gzopen</a>  (const char *path, const char *mode);</font>
-<dd>
-     Opens a gzip (.gz) file for reading or writing. The mode parameter
-   is as in fopen ("rb" or "wb") but can also include a compression level
-   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
-   Huffman only compression as in "wb1h". (See the description
-   of <a href="#deflateInit2">deflateInit2</a> for more information about the strategy parameter.)
-   <p>
-
-     <a href="#gzopen">gzopen</a> can be used to read a file which is not in gzip format ; in this
-   case <a href="#gzread">gzread</a> will directly read from the file without decompression.
-   <p>
-
-     <a href="#gzopen">gzopen</a> returns NULL if the file could not be opened or if there was
-   insufficient memory to allocate the (de)compression <a href="#state">state</a> ; errno
-   can be checked to distinguish the two cases (if errno is zero, the
-   zlib error is <a href="#Z_MEM_ERROR">Z_MEM_ERROR</a>).
-   <p>
-
-<font color="Blue"><dt> gzFile  <a name="gzdopen">gzdopen</a>  (int fd, const char *mode);</font>
-<dd>
-     <a href="#gzdopen">gzdopen</a>() associates a gzFile with the file descriptor fd.  File
-   descriptors are obtained from calls like open, dup, creat, pipe or
-   fileno (in the file has been previously opened with fopen).
-   The mode parameter is as in <a href="#gzopen">gzopen</a>.
-   <p>
-     The next call of <a href="#gzclose">gzclose</a> on the returned gzFile will also close the
-   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
-   descriptor fd. If you want to keep fd open, use <a href="#gzdopen">gzdopen</a>(dup(fd), mode).
-   <p>
-     <a href="#gzdopen">gzdopen</a> returns NULL if there was insufficient memory to allocate
-   the (de)compression <a href="#state">state</a>.
-   <p>
-
-<font color="Blue"><dt> int  <a name="gzsetparams">gzsetparams</a> (gzFile file, int level, int strategy);</font>
-<dd>
-     Dynamically update the compression level or strategy. See the description
-   of <a href="#deflateInit2">deflateInit2</a> for the meaning of these parameters.
-   <p>
-     <a href="#gzsetparams">gzsetparams</a> returns <a href="#Z_OK">Z_OK</a> if success, or <a href="#Z_STREAM_ERROR">Z_STREAM_ERROR</a> if the file was not
-   opened for writing.
-   <p>
-
-<font color="Blue"><dt> int     <a name="gzread">gzread</a>  (gzFile file, voidp buf, unsigned len);</font>
-<dd>
-     Reads the given number of uncompressed bytes from the compressed file.
-   If the input file was not in gzip format, <a href="#gzread">gzread</a> copies the given number
-   of bytes into the buffer.
-   <p>
-     <a href="#gzread">gzread</a> returns the number of uncompressed bytes actually read (0 for
-   end of file, -1 for error).
-   <p>
-
-<font color="Blue"><dt> int     <a name="gzwrite">gzwrite</a> (gzFile file, const voidp buf, unsigned len);</font>
-<dd>
-     Writes the given number of uncompressed bytes into the compressed file.
-   <a href="#gzwrite">gzwrite</a> returns the number of uncompressed bytes actually written
-   (0 in case of error).
-   <p>
-
-<font color="Blue"><dt> int VA   <a name="gzprintf">gzprintf</a> (gzFile file, const char *format, ...);</font>
-<dd>
-     Converts, formats, and writes the args to the compressed file under
-   control of the format string, as in fprintf. <a href="#gzprintf">gzprintf</a> returns the number of
-   uncompressed bytes actually written (0 in case of error).
-   <p>
-
-<font color="Blue"><dt> int  <a name="gzputs">gzputs</a> (gzFile file, const char *s);</font>
-<dd>
-      Writes the given null-terminated string to the compressed file, excluding
-   the terminating null character.
-   <p>
-      <a href="#gzputs">gzputs</a> returns the number of characters written, or -1 in case of error.
-      <p>
-
-<font color="Blue"><dt> char *  <a name="gzgets">gzgets</a> (gzFile file, char *buf, int len);</font>
-<dd>
-      Reads bytes from the compressed file until len-1 characters are read, or
-   a newline character is read and transferred to buf, or an end-of-file
-   condition is encountered.  The string is then terminated with a null
-   character.
-   <p>
-      <a href="#gzgets">gzgets</a> returns buf, or <a href="#Z_NULL">Z_NULL</a> in case of error.
-      <p>
-
-<font color="Blue"><dt> int     <a name="gzputc">gzputc</a> (gzFile file, int c);</font>
-<dd>
-      Writes c, converted to an unsigned char, into the compressed file.
-   <a href="#gzputc">gzputc</a> returns the value that was written, or -1 in case of error.
-   <p>
-
-<font color="Blue"><dt> int     <a name="gzgetc">gzgetc</a> (gzFile file);</font>
-<dd>
-      Reads one byte from the compressed file. <a href="#gzgetc">gzgetc</a> returns this byte
-   or -1 in case of end of file or error.
-   <p>
-
-<font color="Blue"><dt> int     <a name="gzflush">gzflush</a> (gzFile file, int flush);</font>
-<dd>
-     Flushes all pending output into the compressed file. The parameter
-   flush is as in the <a href="#deflate">deflate</a>() function. The return value is the zlib
-   error number (see function <a href="#gzerror">gzerror</a> below). <a href="#gzflush">gzflush</a> returns <a href="#Z_OK">Z_OK</a> if
-   the flush parameter is <a href="#Z_FINISH">Z_FINISH</a> and all output could be flushed.
-   <p>
-     <a href="#gzflush">gzflush</a> should be called only when strictly necessary because it can
-   degrade compression.
-   <p>
-
-<font color="Blue"><dt> z_off_t     <a name="gzseek">gzseek</a> (gzFile file, z_off_t offset, int whence);</font>
-<dd>
-      Sets the starting position for the next <a href="#gzread">gzread</a> or <a href="#gzwrite">gzwrite</a> on the
-   given compressed file. The offset represents a number of bytes in the
-   uncompressed data stream. The whence parameter is defined as in lseek(2);
-   the value SEEK_END is not supported.
-   <p>
-     If the file is opened for reading, this function is emulated but can be
-   extremely slow. If the file is opened for writing, only forward seeks are
-   supported ; <a href="#gzseek">gzseek</a> then compresses a sequence of zeroes up to the new
-   starting position.
-   <p>
-      <a href="#gzseek">gzseek</a> returns the resulting offset location as measured in bytes from
-   the beginning of the uncompressed stream, or -1 in case of error, in
-   particular if the file is opened for writing and the new starting position
-   would be before the current position.
-   <p>
-
-<font color="Blue"><dt> int     <a name="gzrewind">gzrewind</a> (gzFile file);</font>
-<dd>
-     Rewinds the given file. This function is supported only for reading.
-     <p>
-   <a href="#gzrewind">gzrewind</a>(file) is equivalent to (int)<a href="#gzseek">gzseek</a>(file, 0L, SEEK_SET)
-   <p>
-
-<font color="Blue"><dt> z_off_t     <a name="gztell">gztell</a> (gzFile file);</font>
-<dd>
-     Returns the starting position for the next <a href="#gzread">gzread</a> or <a href="#gzwrite">gzwrite</a> on the
-   given compressed file. This position represents a number of bytes in the
-   uncompressed data stream.
-   <p>
-
-   <a href="#gztell">gztell</a>(file) is equivalent to <a href="#gzseek">gzseek</a>(file, 0L, SEEK_CUR)
-   <p>
-
-<font color="Blue"><dt> int  <a name="gzeof">gzeof</a> (gzFile file);</font>
-<dd>
-     Returns 1 when EOF has previously been detected reading the given
-   input stream, otherwise zero.
-   <p>
-
-<font color="Blue"><dt> int     <a name="gzclose">gzclose</a> (gzFile file);</font>
-<dd>
-     Flushes all pending output if necessary, closes the compressed file
-   and deallocates all the (de)compression <a href="#state">state</a>. The return value is the zlib
-   error number (see function <a href="#gzerror">gzerror</a> below).
-   <p>
-
-<font color="Blue"><dt> const char *  <a name="gzerror">gzerror</a> (gzFile file, int *errnum);</font>
-<dd>
-     Returns the error message for the last error which occurred on the
-   given compressed file. errnum is set to zlib error number. If an
-   error occurred in the file system and not in the compression library,
-   errnum is set to <a href="#Z_ERRNO">Z_ERRNO</a> and the application may consult errno
-   to get the exact error code.
-   <p>
-</dl>
-<hr>
-<a name="Basic functions"><h2> Basic functions </h2>
-<h3> Function list </h3>
-<ul>
-<li>  const char *  <a href="#zlibVersion">zlibVersion</a> (void);
-<li>  int  <a href="#deflateInit">deflateInit</a> (<a href="#z_streamp">z_streamp</a> strm, int level);
-<li>  int  <a href="#deflate">deflate</a> (<a href="#z_streamp">z_streamp</a> strm, int flush);
-<li>  int  <a href="#deflateEnd">deflateEnd</a> (<a href="#z_streamp">z_streamp</a> strm);
-<li>  int  <a href="#inflateInit">inflateInit</a> (<a href="#z_streamp">z_streamp</a> strm);
-<li>  int  <a href="#inflate">inflate</a> (<a href="#z_streamp">z_streamp</a> strm, int flush);
-<li>  int  <a href="#inflateEnd">inflateEnd</a> (<a href="#z_streamp">z_streamp</a> strm);
-</ul>
-
-<h3> Function description </h3>
-<dl>
-<font color="Blue"><dt>  const char *  <a name="zlibVersion">zlibVersion</a> (void);</font>
-<dd> The application can compare <a href="#zlibVersion">zlibVersion</a> and ZLIB_VERSION for consistency.
-   If the first character differs, the library code actually used is
-   not compatible with the zlib.h header file used by the application.
-   This check is automatically made by <a href="#deflateInit">deflateInit</a> and <a href="#inflateInit">inflateInit</a>.
-   <p>
-
-<font color="Blue"><dt> int  <a name="deflateInit">deflateInit</a> (<a href="#z_streamp">z_streamp</a> strm, int level);</font>
-<dd>
-     Initializes the internal stream <a href="#state">state</a> for compression. The fields
-   <a href="#zalloc">zalloc</a>, <a href="#zfree">zfree</a> and <a href="#opaque">opaque</a> must be initialized before by the caller.
-   If <a href="#zalloc">zalloc</a> and <a href="#zfree">zfree</a> are set to <a href="#Z_NULL">Z_NULL</a>, <a href="#deflateInit">deflateInit</a> updates them to
-   use default allocation functions.
-   <p>
-
-     The compression level must be <a href="#Z_DEFAULT_COMPRESSION">Z_DEFAULT_COMPRESSION</a>, or between 0 and 9:
-   1 gives best speed, 9 gives best compression, 0 gives no compression at
-   all (the input data is simply copied a block at a time).
-   <p>
-
-   <a href="#Z_DEFAULT_COMPRESSION">Z_DEFAULT_COMPRESSION</a> requests a default compromise between speed and
-   compression (currently equivalent to level 6).
-   <p>
-
-     <a href="#deflateInit">deflateInit</a> returns <a href="#Z_OK">Z_OK</a> if success, <a href="#Z_MEM_ERROR">Z_MEM_ERROR</a> if there was not
-   enough memory, <a href="#Z_STREAM_ERROR">Z_STREAM_ERROR</a> if level is not a valid compression level,
-   <a href="#Z_VERSION_ERROR">Z_VERSION_ERROR</a> if the zlib library version (<a href="#zlib_version">zlib_version</a>) is incompatible
-   with the version assumed by the caller (ZLIB_VERSION).
-   <a href="#msg">msg</a> is set to null if there is no error message.  <a href="#deflateInit">deflateInit</a> does not
-   perform any compression: this will be done by <a href="#deflate">deflate</a>().
-   <p>
-
-<font color="Blue"><dt>  int  <a name="deflate">deflate</a> (<a href="#z_streamp">z_streamp</a> strm, int flush);</font>
-<dd>
-    <a href="#deflate">deflate</a> compresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full. It may introduce some
-  output latency (reading input without producing any output) except when
-  forced to flush.<p>
-
-    The detailed semantics are as follows. <a href="#deflate">deflate</a> performs one or both of the
-  following actions:
-
-  <ul>
-  <li> Compress more input starting at <a href="#next_in">next_in</a> and update <a href="#next_in">next_in</a> and <a href="#avail_in">avail_in</a>
-    accordingly. If not all input can be processed (because there is not
-    enough room in the output buffer), <a href="#next_in">next_in</a> and <a href="#avail_in">avail_in</a> are updated and
-    processing will resume at this point for the next call of <a href="#deflate">deflate</a>().
-
-  <li>
-    Provide more output starting at <a href="#next_out">next_out</a> and update <a href="#next_out">next_out</a> and <a href="#avail_out">avail_out</a>
-    accordingly. This action is forced if the parameter flush is non zero.
-    Forcing flush frequently degrades the compression ratio, so this parameter
-    should be set only when necessary (in interactive applications).
-    Some output may be provided even if flush is not set.
-  </ul> <p>
-
-  Before the call of <a href="#deflate">deflate</a>(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming
-  more output, and updating <a href="#avail_in">avail_in</a> or <a href="#avail_out">avail_out</a> accordingly ; <a href="#avail_out">avail_out</a>
-  should never be zero before the call. The application can consume the
-  compressed output when it wants, for example when the output buffer is full
-  (<a href="#avail_out">avail_out</a> == 0), or after each call of <a href="#deflate">deflate</a>(). If <a href="#deflate">deflate</a> returns <a href="#Z_OK">Z_OK</a>
-  and with zero <a href="#avail_out">avail_out</a>, it must be called again after making room in the
-  output buffer because there might be more output pending.
-  <p>
-
-    If the parameter flush is set to <a href="#Z_SYNC_FLUSH">Z_SYNC_FLUSH</a>, all pending output is
-  flushed to the output buffer and the output is aligned on a byte boundary, so
-  that the decompressor can get all input data available so far. (In particular
-  <a href="#avail_in">avail_in</a> is zero after the call if enough output space has been provided
-  before the call.)  Flushing may degrade compression for some compression
-  algorithms and so it should be used only when necessary.
-  <p>
-
-    If flush is set to <a href="#Z_FULL_FLUSH">Z_FULL_FLUSH</a>, all output is flushed as with
-  <a href="#Z_SYNC_FLUSH">Z_SYNC_FLUSH</a>, and the compression <a href="#state">state</a> is reset so that decompression can
-  restart from this point if previous compressed data has been damaged or if
-  random access is desired. Using <a href="#Z_FULL_FLUSH">Z_FULL_FLUSH</a> too often can seriously degrade
-  the compression.
-  <p>
-
-    If <a href="#deflate">deflate</a> returns with <a href="#avail_out">avail_out</a> == 0, this function must be called again
-  with the same value of the flush parameter and more output space (updated
-  <a href="#avail_out">avail_out</a>), until the flush is complete (<a href="#deflate">deflate</a> returns with non-zero
-  <a href="#avail_out">avail_out</a>).
-  <p>
-
-    If the parameter flush is set to <a href="#Z_FINISH">Z_FINISH</a>, pending input is processed,
-  pending output is flushed and <a href="#deflate">deflate</a> returns with <a href="#Z_STREAM_END">Z_STREAM_END</a> if there
-  was enough output space ; if <a href="#deflate">deflate</a> returns with <a href="#Z_OK">Z_OK</a>, this function must be
-  called again with <a href="#Z_FINISH">Z_FINISH</a> and more output space (updated <a href="#avail_out">avail_out</a>) but no
-  more input data, until it returns with <a href="#Z_STREAM_END">Z_STREAM_END</a> or an error. After
-  <a href="#deflate">deflate</a> has returned <a href="#Z_STREAM_END">Z_STREAM_END</a>, the only possible operations on the
-  stream are <a href="#deflateReset">deflateReset</a> or <a href="#deflateEnd">deflateEnd</a>.
-  <p>
-
-    <a href="#Z_FINISH">Z_FINISH</a> can be used immediately after <a href="#deflateInit">deflateInit</a> if all the compression
-  is to be done in a single step. In this case, <a href="#avail_out">avail_out</a> must be at least
-  0.1% larger than <a href="#avail_in">avail_in</a> plus 12 bytes.  If <a href="#deflate">deflate</a> does not return
-  <a href="#Z_STREAM_END">Z_STREAM_END</a>, then it must be called again as described above.
-  <p>
-
-    <a href="#deflate">deflate</a>() sets strm-&gt <a href="#adler">adler</a> to the <a href="#adler32">adler32</a> checksum of all input read
-  so far (that is, <a href="#total_in">total_in</a> bytes).
-  <p>
-
-    <a href="#deflate">deflate</a>() may update <a href="#data_type">data_type</a> if it can make a good guess about
-  the input data type (<a href="#Z_ASCII">Z_ASCII</a> or <a href="#Z_BINARY">Z_BINARY</a>). In doubt, the data is considered
-  binary. This field is only for information purposes and does not affect
-  the compression algorithm in any manner.
-  <p>
-
-    <a href="#deflate">deflate</a>() returns <a href="#Z_OK">Z_OK</a> if some progress has been made (more input
-  processed or more output produced), <a href="#Z_STREAM_END">Z_STREAM_END</a> if all input has been
-  consumed and all output has been produced (only when flush is set to
-  <a href="#Z_FINISH">Z_FINISH</a>), <a href="#Z_STREAM_ERROR">Z_STREAM_ERROR</a> if the stream <a href="#state">state</a> was inconsistent (for example
-  if <a href="#next_in">next_in</a> or <a href="#next_out">next_out</a> was NULL), <a href="#Z_BUF_ERROR">Z_BUF_ERROR</a> if no progress is possible
-  (for example <a href="#avail_in">avail_in</a> or <a href="#avail_out">avail_out</a> was zero).
-  <p>
-
-<font color="Blue"><dt>  int  <a name="deflateEnd">deflateEnd</a> (<a href="#z_streamp">z_streamp</a> strm);</font>
-<dd>
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any
-   pending output.
-   <p>
-
-     <a href="#deflateEnd">deflateEnd</a> returns <a href="#Z_OK">Z_OK</a> if success, <a href="#Z_STREAM_ERROR">Z_STREAM_ERROR</a> if the
-   stream <a href="#state">state</a> was inconsistent, <a href="#Z_DATA_ERROR">Z_DATA_ERROR</a> if the stream was freed
-   prematurely (some input or output was discarded). In the error case,
-   <a href="#msg">msg</a> may be set but then points to a static string (which must not be
-   deallocated).
-   <p>
-
-<font color="Blue"><dt>  int  <a name="inflateInit">inflateInit</a> (<a href="#z_streamp">z_streamp</a> strm);</font>
-<dd>
-	Initializes the internal stream <a href="#state">state</a> for decompression. The fields
-   <a href="#next_in">next_in</a>, <a href="#avail_in">avail_in</a>, <a href="#zalloc">zalloc</a>, <a href="#zfree">zfree</a> and <a href="#opaque">opaque</a> must be initialized before by
-   the caller. If <a href="#next_in">next_in</a> is not <a href="#Z_NULL">Z_NULL</a> and <a href="#avail_in">avail_in</a> is large enough (the exact
-   value depends on the compression method), <a href="#inflateInit">inflateInit</a> determines the
-   compression method from the zlib header and allocates all data structures
-   accordingly ; otherwise the allocation will be deferred to the first call of
-   <a href="#inflate">inflate</a>.  If <a href="#zalloc">zalloc</a> and <a href="#zfree">zfree</a> are set to <a href="#Z_NULL">Z_NULL</a>, <a href="#inflateInit">inflateInit</a> updates them to
-   use default allocation functions.
-   <p>
-
-     <a href="#inflateInit">inflateInit</a> returns <a href="#Z_OK">Z_OK</a> if success, <a href="#Z_MEM_ERROR">Z_MEM_ERROR</a> if there was not enough
-   memory, <a href="#Z_VERSION_ERROR">Z_VERSION_ERROR</a> if the zlib library version is incompatible with the
-   version assumed by the caller.  <a href="#msg">msg</a> is set to null if there is no error
-   message. <a href="#inflateInit">inflateInit</a> does not perform any decompression apart from reading
-   the zlib header if present: this will be done by <a href="#inflate">inflate</a>().  (So <a href="#next_in">next_in</a> and
-   <a href="#avail_in">avail_in</a> may be modified, but <a href="#next_out">next_out</a> and <a href="#avail_out">avail_out</a> are unchanged.)
-   <p>
-
-<font color="Blue"><dt>  int  <a name="inflate">inflate</a> (<a href="#z_streamp">z_streamp</a> strm, int flush);</font>
-<dd>
-    <a href="#inflate">inflate</a> decompresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full. It may some
-  introduce some output latency (reading input without producing any output)
-  except when forced to flush.
-  <p>
-
-  The detailed semantics are as follows. <a href="#inflate">inflate</a> performs one or both of the
-  following actions:
-
-  <ul>
-  <li> Decompress more input starting at <a href="#next_in">next_in</a> and update <a href="#next_in">next_in</a> and <a href="#avail_in">avail_in</a>
-    accordingly. If not all input can be processed (because there is not
-    enough room in the output buffer), <a href="#next_in">next_in</a> is updated and processing
-    will resume at this point for the next call of <a href="#inflate">inflate</a>().
-
-  <li> Provide more output starting at <a href="#next_out">next_out</a> and update <a href="#next_out">next_out</a> and
-    <a href="#avail_out">avail_out</a> accordingly.  <a href="#inflate">inflate</a>() provides as much output as possible,
-    until there is no more input data or no more space in the output buffer
-    (see below about the flush parameter).
-  </ul> <p>
-
-  Before the call of <a href="#inflate">inflate</a>(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming
-  more output, and updating the next_* and avail_* values accordingly.
-  The application can consume the uncompressed output when it wants, for
-  example when the output buffer is full (<a href="#avail_out">avail_out</a> == 0), or after each
-  call of <a href="#inflate">inflate</a>(). If <a href="#inflate">inflate</a> returns <a href="#Z_OK">Z_OK</a> and with zero <a href="#avail_out">avail_out</a>, it
-  must be called again after making room in the output buffer because there
-  might be more output pending.
-  <p>
-
-    If the parameter flush is set to <a href="#Z_SYNC_FLUSH">Z_SYNC_FLUSH</a>, <a href="#inflate">inflate</a> flushes as much
-  output as possible to the output buffer. The flushing behavior of <a href="#inflate">inflate</a> is
-  not specified for values of the flush parameter other than <a href="#Z_SYNC_FLUSH">Z_SYNC_FLUSH</a>
-  and <a href="#Z_FINISH">Z_FINISH</a>, but the current implementation actually flushes as much output
-  as possible anyway.
-  <p>
-
-    <a href="#inflate">inflate</a>() should normally be called until it returns <a href="#Z_STREAM_END">Z_STREAM_END</a> or an
-  error. However if all decompression is to be performed in a single step
-  (a single call of <a href="#inflate">inflate</a>), the parameter flush should be set to
-  <a href="#Z_FINISH">Z_FINISH</a>. In this case all pending input is processed and all pending
-  output is flushed ; <a href="#avail_out">avail_out</a> must be large enough to hold all the
-  uncompressed data. (The size of the uncompressed data may have been saved
-  by the compressor for this purpose.) The next operation on this stream must
-  be <a href="#inflateEnd">inflateEnd</a> to deallocate the decompression <a href="#state">state</a>. The use of <a href="#Z_FINISH">Z_FINISH</a>
-  is never required, but can be used to inform <a href="#inflate">inflate</a> that a faster routine
-  may be used for the single <a href="#inflate">inflate</a>() call.
-  <p>
-
-     If a preset dictionary is needed at this point (see <a href="#inflateSetDictionary">inflateSetDictionary</a>
-  below), <a href="#inflate">inflate</a> sets strm-<a href="#adler">adler</a> to the <a href="#adler32">adler32</a> checksum of the
-  dictionary chosen by the compressor and returns <a href="#Z_NEED_DICT">Z_NEED_DICT</a> ; otherwise
-  it sets strm-&gt <a href="#adler">adler</a> to the <a href="#adler32">adler32</a> checksum of all output produced
-  so far (that is, <a href="#total_out">total_out</a> bytes) and returns <a href="#Z_OK">Z_OK</a>, <a href="#Z_STREAM_END">Z_STREAM_END</a> or
-  an error code as described below. At the end of the stream, <a href="#inflate">inflate</a>()
-  checks that its computed <a href="#adler32">adler32</a> checksum is equal to that saved by the
-  compressor and returns <a href="#Z_STREAM_END">Z_STREAM_END</a> only if the checksum is correct.
-  <p>
-
-    <a href="#inflate">inflate</a>() returns <a href="#Z_OK">Z_OK</a> if some progress has been made (more input processed
-  or more output produced), <a href="#Z_STREAM_END">Z_STREAM_END</a> if the end of the compressed data has
-  been reached and all uncompressed output has been produced, <a href="#Z_NEED_DICT">Z_NEED_DICT</a> if a
-  preset dictionary is needed at this point, <a href="#Z_DATA_ERROR">Z_DATA_ERROR</a> if the input data was
-  corrupted (input stream not conforming to the zlib format or incorrect
-  <a href="#adler32">adler32</a> checksum), <a href="#Z_STREAM_ERROR">Z_STREAM_ERROR</a> if the stream structure was inconsistent
-  (for example if <a href="#next_in">next_in</a> or <a href="#next_out">next_out</a> was NULL), <a href="#Z_MEM_ERROR">Z_MEM_ERROR</a> if there was not
-  enough memory, <a href="#Z_BUF_ERROR">Z_BUF_ERROR</a> if no progress is possible or if there was not
-  enough room in the output buffer when <a href="#Z_FINISH">Z_FINISH</a> is used. In the <a href="#Z_DATA_ERROR">Z_DATA_ERROR</a>
-  case, the application may then call <a href="#inflateSync">inflateSync</a> to look for a good
-  compression block.
-  <p>
-
-<font color="Blue"><dt>  int  <a name="inflateEnd">inflateEnd</a> (<a href="#z_streamp">z_streamp</a> strm);</font>
-<dd>
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any
-   pending output.
-   <p>
-
-     <a href="#inflateEnd">inflateEnd</a> returns <a href="#Z_OK">Z_OK</a> if success, <a href="#Z_STREAM_ERROR">Z_STREAM_ERROR</a> if the stream <a href="#state">state</a>
-   was inconsistent. In the error case, <a href="#msg">msg</a> may be set but then points to a
-   static string (which must not be deallocated).
-</dl>
-<hr>
-<a name="Advanced functions"><h2> Advanced functions </h2>
-    The following functions are needed only in some special applications.
-<h3> Function list </h3>
-<ul>
-<li>  int  <a href="#deflateInit2">deflateInit2</a> (<a href="#z_streamp">z_streamp</a> strm,
-<li> int  <a href="#deflateSetDictionary">deflateSetDictionary</a> (<a href="#z_streamp">z_streamp</a> strm, const Bytef *dictionary, uInt  dictLength);
-<li> int  <a href="#deflateCopy">deflateCopy</a> (<a href="#z_streamp">z_streamp</a> dest, <a href="#z_streamp">z_streamp</a> source);
-<li> int  <a href="#deflateReset">deflateReset</a> (<a href="#z_streamp">z_streamp</a> strm);
-<li> int  <a href="#deflateParams">deflateParams</a> (<a href="#z_streamp">z_streamp</a> strm, int level, int strategy);
-<li> int  <a href="#inflateInit2">inflateInit2</a> (<a href="#z_streamp">z_streamp</a> strm, int  windowBits);
-<li>  int  <a href="#inflateSetDictionary">inflateSetDictionary</a> (<a href="#z_streamp">z_streamp</a> strm, const Bytef *dictionary, uInt  dictLength);
-<li> int  <a href="#inflateSync">inflateSync</a> (<a href="#z_streamp">z_streamp</a> strm);
-<li> int  <a href="#inflateReset">inflateReset</a> (<a href="#z_streamp">z_streamp</a> strm);
-
-</ul>
-<h3> Function description </h3>
-<dl>
-<font color="Blue"><dt>  int  <a name="deflateInit2">deflateInit2</a> (<a href="#z_streamp">z_streamp</a> strm, int  level, int  method, int  windowBits, int  memLevel, int  strategy);</font>
-
-<dd> This is another version of <a href="#deflateInit">deflateInit</a> with more compression options. The
-   fields <a href="#next_in">next_in</a>, <a href="#zalloc">zalloc</a>, <a href="#zfree">zfree</a> and <a href="#opaque">opaque</a> must be initialized before by
-   the caller.<p>
-
-     The method parameter is the compression method. It must be <a href="#Z_DEFLATED">Z_DEFLATED</a> in
-   this version of the library.<p>
-
-     The windowBits parameter is the base two logarithm of the window size
-   (the size of the history buffer).  It should be in the range 8..15 for this
-   version of the library. Larger values of this parameter result in better
-   compression at the expense of memory usage. The default value is 15 if
-   <a href="#deflateInit">deflateInit</a> is used instead.<p>
-
-     The memLevel parameter specifies how much memory should be allocated
-   for the internal compression <a href="#state">state</a>. memLevel=1 uses minimum memory but
-   is slow and reduces compression ratio ; memLevel=9 uses maximum memory
-   for optimal speed. The default value is 8. See zconf.h for total memory
-   usage as a function of windowBits and memLevel.<p>
-
-     The strategy parameter is used to tune the compression algorithm. Use the
-   value <a href="#Z_DEFAULT_STRATEGY">Z_DEFAULT_STRATEGY</a> for normal data, <a href="#Z_FILTERED">Z_FILTERED</a> for data produced by a
-   filter (or predictor), or <a href="#Z_HUFFMAN_ONLY">Z_HUFFMAN_ONLY</a> to force Huffman encoding only (no
-   string match).  Filtered data consists mostly of small values with a
-   somewhat random distribution. In this case, the compression algorithm is
-   tuned to <a href="#compress">compress</a> them better. The effect of <a href="#Z_FILTERED">Z_FILTERED</a> is to force more
-   Huffman coding and less string matching ; it is somewhat intermediate
-   between Z_DEFAULT and <a href="#Z_HUFFMAN_ONLY">Z_HUFFMAN_ONLY</a>. The strategy parameter only affects
-   the compression ratio but not the correctness of the compressed output even
-   if it is not set appropriately.<p>
-
-      <a href="#deflateInit2">deflateInit2</a> returns <a href="#Z_OK">Z_OK</a> if success, <a href="#Z_MEM_ERROR">Z_MEM_ERROR</a> if there was not enough
-   memory, <a href="#Z_STREAM_ERROR">Z_STREAM_ERROR</a> if a parameter is invalid (such as an invalid
-   method). <a href="#msg">msg</a> is set to null if there is no error message.  <a href="#deflateInit2">deflateInit2</a> does
-   not perform any compression: this will be done by <a href="#deflate">deflate</a>().<p>
-
-<font color="Blue"><dt> int  <a name="deflateSetDictionary">deflateSetDictionary</a> (<a href="#z_streamp">z_streamp</a> strm, const Bytef *dictionary, uInt  dictLength);</font>
-<dd>
-     Initializes the compression dictionary from the given byte sequence
-   without producing any compressed output. This function must be called
-   immediately after <a href="#deflateInit">deflateInit</a>, <a href="#deflateInit2">deflateInit2</a> or <a href="#deflateReset">deflateReset</a>, before any
-   call of <a href="#deflate">deflate</a>. The compressor and decompressor must use exactly the same
-   dictionary (see <a href="#inflateSetDictionary">inflateSetDictionary</a>).<p>
-
-     The dictionary should consist of strings (byte sequences) that are likely
-   to be encountered later in the data to be compressed, with the most commonly
-   used strings preferably put towards the end of the dictionary. Using a
-   dictionary is most useful when the data to be compressed is short and can be
-   predicted with good accuracy ; the data can then be compressed better than
-   with the default empty dictionary.<p>
-
-     Depending on the size of the compression data structures selected by
-   <a href="#deflateInit">deflateInit</a> or <a href="#deflateInit2">deflateInit2</a>, a part of the dictionary may in effect be
-   discarded, for example if the dictionary is larger than the window size in
-   <a href="#deflate">deflate</a> or deflate2. Thus the strings most likely to be useful should be
-   put at the end of the dictionary, not at the front.<p>
-
-     Upon return of this function, strm-&gt <a href="#adler">adler</a> is set to the Adler32 value
-   of the dictionary ; the decompressor may later use this value to determine
-   which dictionary has been used by the compressor. (The Adler32 value
-   applies to the whole dictionary even if only a subset of the dictionary is
-   actually used by the compressor.)<p>
-
-     <a href="#deflateSetDictionary">deflateSetDictionary</a> returns <a href="#Z_OK">Z_OK</a> if success, or <a href="#Z_STREAM_ERROR">Z_STREAM_ERROR</a> if a
-   parameter is invalid (such as NULL dictionary) or the stream <a href="#state">state</a> is
-   inconsistent (for example if <a href="#deflate">deflate</a> has already been called for this stream
-   or if the compression method is bsort). <a href="#deflateSetDictionary">deflateSetDictionary</a> does not
-   perform any compression: this will be done by <a href="#deflate">deflate</a>().<p>
-
-<font color="Blue"><dt> int  <a name="deflateCopy">deflateCopy</a> (<a href="#z_streamp">z_streamp</a> dest, <a href="#z_streamp">z_streamp</a> source);</font>
-<dd>
-     Sets the destination stream as a complete copy of the source stream.<p>
-
-     This function can be useful when several compression strategies will be
-   tried, for example when there are several ways of pre-processing the input
-   data with a filter. The streams that will be discarded should then be freed
-   by calling <a href="#deflateEnd">deflateEnd</a>.  Note that <a href="#deflateCopy">deflateCopy</a> duplicates the internal
-   compression <a href="#state">state</a> which can be quite large, so this strategy is slow and
-   can consume lots of memory.<p>
-
-     <a href="#deflateCopy">deflateCopy</a> returns <a href="#Z_OK">Z_OK</a> if success, <a href="#Z_MEM_ERROR">Z_MEM_ERROR</a> if there was not
-   enough memory, <a href="#Z_STREAM_ERROR">Z_STREAM_ERROR</a> if the source stream <a href="#state">state</a> was inconsistent
-   (such as <a href="#zalloc">zalloc</a> being NULL). <a href="#msg">msg</a> is left unchanged in both source and
-   destination.<p>
-
-<font color="Blue"><dt> int  <a name="deflateReset">deflateReset</a> (<a href="#z_streamp">z_streamp</a> strm);</font>
-<dd>     This function is equivalent to <a href="#deflateEnd">deflateEnd</a> followed by <a href="#deflateInit">deflateInit</a>,
-   but does not free and reallocate all the internal compression <a href="#state">state</a>.
-   The stream will keep the same compression level and any other attributes
-   that may have been set by <a href="#deflateInit2">deflateInit2</a>.<p>
-
-      <a href="#deflateReset">deflateReset</a> returns <a href="#Z_OK">Z_OK</a> if success, or <a href="#Z_STREAM_ERROR">Z_STREAM_ERROR</a> if the source
-   stream <a href="#state">state</a> was inconsistent (such as <a href="#zalloc">zalloc</a> or <a href="#state">state</a> being NULL).<p>
-
-<font color="Blue"><dt> int  <a name="deflateParams">deflateParams</a> (<a href="#z_streamp">z_streamp</a> strm, int level, int strategy);</font>
-<dd>
-     Dynamically update the compression level and compression strategy.  The
-   interpretation of level and strategy is as in <a href="#deflateInit2">deflateInit2</a>.  This can be
-   used to switch between compression and straight copy of the input data, or
-   to switch to a different kind of input data requiring a different
-   strategy. If the compression level is changed, the input available so far
-   is compressed with the old level (and may be flushed); the new level will
-   take effect only at the next call of <a href="#deflate">deflate</a>().<p>
-
-     Before the call of <a href="#deflateParams">deflateParams</a>, the stream <a href="#state">state</a> must be set as for
-   a call of <a href="#deflate">deflate</a>(), since the currently available input may have to
-   be compressed and flushed. In particular, strm-&gt <a href="#avail_out">avail_out</a> must be
-   non-zero.<p>
-
-     <a href="#deflateParams">deflateParams</a> returns <a href="#Z_OK">Z_OK</a> if success, <a href="#Z_STREAM_ERROR">Z_STREAM_ERROR</a> if the source
-   stream <a href="#state">state</a> was inconsistent or if a parameter was invalid, <a href="#Z_BUF_ERROR">Z_BUF_ERROR</a>
-   if strm-&gtavail_out was zero.<p>
-
-<font color="Blue"><dt> int  <a name="inflateInit2">inflateInit2</a> (<a href="#z_streamp">z_streamp</a> strm, int  windowBits);</font>
-
-<dd>     This is another version of <a href="#inflateInit">inflateInit</a> with an extra parameter. The
-   fields <a href="#next_in">next_in</a>, <a href="#avail_in">avail_in</a>, <a href="#zalloc">zalloc</a>, <a href="#zfree">zfree</a> and <a href="#opaque">opaque</a> must be initialized
-   before by the caller.<p>
-
-     The windowBits parameter is the base two logarithm of the maximum window
-   size (the size of the history buffer).  It should be in the range 8..15 for
-   this version of the library. The default value is 15 if <a href="#inflateInit">inflateInit</a> is used
-   instead. If a compressed stream with a larger window size is given as
-   input, <a href="#inflate">inflate</a>() will return with the error code <a href="#Z_DATA_ERROR">Z_DATA_ERROR</a> instead of
-   trying to allocate a larger window.<p>
-
-      <a href="#inflateInit2">inflateInit2</a> returns <a href="#Z_OK">Z_OK</a> if success, <a href="#Z_MEM_ERROR">Z_MEM_ERROR</a> if there was not enough
-   memory, <a href="#Z_STREAM_ERROR">Z_STREAM_ERROR</a> if a parameter is invalid (such as a negative
-   memLevel). <a href="#msg">msg</a> is set to null if there is no error message.  <a href="#inflateInit2">inflateInit2</a>
-   does not perform any decompression apart from reading the zlib header if
-   present: this will be done by <a href="#inflate">inflate</a>(). (So <a href="#next_in">next_in</a> and <a href="#avail_in">avail_in</a> may be
-   modified, but <a href="#next_out">next_out</a> and <a href="#avail_out">avail_out</a> are unchanged.)<p>
-
-<font color="Blue"><dt>  int  <a name="inflateSetDictionary">inflateSetDictionary</a> (<a href="#z_streamp">z_streamp</a> strm, const Bytef *dictionary, uInt  dictLength);</font>
-<dd>
-     Initializes the decompression dictionary from the given uncompressed byte
-   sequence. This function must be called immediately after a call of <a href="#inflate">inflate</a>
-   if this call returned <a href="#Z_NEED_DICT">Z_NEED_DICT</a>. The dictionary chosen by the compressor
-   can be determined from the Adler32 value returned by this call of
-   <a href="#inflate">inflate</a>. The compressor and decompressor must use exactly the same
-   dictionary (see <a href="#deflateSetDictionary">deflateSetDictionary</a>).<p>
-
-     <a href="#inflateSetDictionary">inflateSetDictionary</a> returns <a href="#Z_OK">Z_OK</a> if success, <a href="#Z_STREAM_ERROR">Z_STREAM_ERROR</a> if a
-   parameter is invalid (such as NULL dictionary) or the stream <a href="#state">state</a> is
-   inconsistent, <a href="#Z_DATA_ERROR">Z_DATA_ERROR</a> if the given dictionary doesn't match the
-   expected one (incorrect Adler32 value). <a href="#inflateSetDictionary">inflateSetDictionary</a> does not
-   perform any decompression: this will be done by subsequent calls of
-   <a href="#inflate">inflate</a>().<p>
-
-<font color="Blue"><dt> int  <a name="inflateSync">inflateSync</a> (<a href="#z_streamp">z_streamp</a> strm);</font>
-
-<dd>    Skips invalid compressed data until a full flush point (see above the
-  description of <a href="#deflate">deflate</a> with <a href="#Z_FULL_FLUSH">Z_FULL_FLUSH</a>) can be found, or until all
-  available input is skipped. No output is provided.<p>
-
-    <a href="#inflateSync">inflateSync</a> returns <a href="#Z_OK">Z_OK</a> if a full flush point has been found, <a href="#Z_BUF_ERROR">Z_BUF_ERROR</a>
-  if no more input was provided, <a href="#Z_DATA_ERROR">Z_DATA_ERROR</a> if no flush point has been found,
-  or <a href="#Z_STREAM_ERROR">Z_STREAM_ERROR</a> if the stream structure was inconsistent. In the success
-  case, the application may save the current current value of <a href="#total_in">total_in</a> which
-  indicates where valid compressed data was found. In the error case, the
-  application may repeatedly call <a href="#inflateSync">inflateSync</a>, providing more input each time,
-  until success or end of the input data.<p>
-
-<font color="Blue"><dt> int  <a name="inflateReset">inflateReset</a> (<a href="#z_streamp">z_streamp</a> strm);</font>
-<dd>
-     This function is equivalent to <a href="#inflateEnd">inflateEnd</a> followed by <a href="#inflateInit">inflateInit</a>,
-   but does not free and reallocate all the internal decompression <a href="#state">state</a>.
-   The stream will keep attributes that may have been set by <a href="#inflateInit2">inflateInit2</a>.
-   <p>
-
-      <a href="#inflateReset">inflateReset</a> returns <a href="#Z_OK">Z_OK</a> if success, or <a href="#Z_STREAM_ERROR">Z_STREAM_ERROR</a> if the source
-   stream <a href="#state">state</a> was inconsistent (such as <a href="#zalloc">zalloc</a> or <a href="#state">state</a> being NULL).
-   <p>
-</dl>
-
-<hr>
-<a name="Checksum functions"><h2> Checksum functions </h2>
-     These functions are not related to compression but are exported
-   anyway because they might be useful in applications using the
-   compression library.
-<h3> Function list </h3>
-<ul>
-<li> uLong  <a href="#adler32">adler32</a> (uLong <a href="#adler">adler</a>, const Bytef *buf, uInt len);
-<li> uLong  <a href="#crc32">crc32</a>   (uLong crc, const Bytef *buf, uInt len);
-</ul>
-<h3> Function description </h3>
-<dl>
-<font color="Blue"><dt> uLong  <a name="adler32">adler32</a> (uLong <a href="#adler">adler</a>, const Bytef *buf, uInt len);</font>
-<dd>
-     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
-   return the updated checksum. If buf is NULL, this function returns
-   the required initial value for the checksum.
-   <p>
-   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
-   much faster. Usage example:
-   <pre>
-
-     uLong <a href="#adler">adler</a> = <a href="#adler32">adler32</a>(0L, <a href="#Z_NULL">Z_NULL</a>, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       <a href="#adler">adler</a> = <a href="#adler32">adler32</a>(<a href="#adler">adler</a>, buffer, length);
-     }
-     if (<a href="#adler">adler</a> != original_adler) error();
-   </pre>
-
-<font color="Blue"><dt> uLong  <a name="crc32">crc32</a>   (uLong crc, const Bytef *buf, uInt len);</font>
-<dd>
-     Update a running crc with the bytes buf[0..len-1] and return the updated
-   crc. If buf is NULL, this function returns the required initial value
-   for the crc. Pre- and post-conditioning (one's complement) is performed
-   within this function so it shouldn't be done by the application.
-   Usage example:
-   <pre>
-
-     uLong crc = <a href="#crc32">crc32</a>(0L, <a href="#Z_NULL">Z_NULL</a>, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       crc = <a href="#crc32">crc32</a>(crc, buffer, length);
-     }
-     if (crc != original_crc) error();
-   </pre>
-</dl>
-<hr>
-<a name="struct z_stream_s"><h2> struct z_stream_s </h2>
-<font color="Blue">
-<a name="z_stream_s">
-<pre>
-typedef struct z_stream_s {
-    Bytef    *<a name="next_in">next_in</a>;  /* next input byte */
-    uInt     <a name="avail_in">avail_in</a>;  /* number of bytes available at <a href="#next_in">next_in</a> */
-    uLong    <a name="total_in">total_in</a>;  /* total nb of input bytes read so far */
-
-    Bytef    *<a name="next_out">next_out</a>; /* next output byte should be put there */
-    uInt     <a name="avail_out">avail_out</a>; /* remaining free space at <a href="#next_out">next_out</a> */
-    uLong    <a name="total_out">total_out</a>; /* total nb of bytes output so far */
-
-    char     *<a name="msg">msg</a>;      /* last error message, NULL if no error */
-    struct internal_state FAR *<a name="state">state</a>; /* not visible by applications */
-
-    alloc_func <a name="zalloc">zalloc</a>;  /* used to allocate the internal <a href="#state">state</a> */
-    free_func  <a name="zfree">zfree</a>;   /* used to free the internal <a href="#state">state</a> */
-    voidpf     <a name="opaque">opaque</a>;  /* private data object passed to <a href="#zalloc">zalloc</a> and <a href="#zfree">zfree</a> */
-
-    int     <a name="data_type">data_type</a>;  /* best guess about the data type: ascii or binary */
-    uLong   <a name="adler">adler</a>;      /* <a href="#adler32">adler32</a> value of the uncompressed data */
-    uLong   <a name="reserved">reserved</a>;   /* <a href="#reserved">reserved</a> for future use */
-} <a href="#z_stream_s">z_stream</a> ;
-
-typedef <a href="#z_stream_s">z_stream</a> FAR * <a name="z_streamp">z_streamp</a>;  
-</pre>
-</font>
-   The application must update <a href="#next_in">next_in</a> and <a href="#avail_in">avail_in</a> when <a href="#avail_in">avail_in</a> has
-   dropped to zero. It must update <a href="#next_out">next_out</a> and <a href="#avail_out">avail_out</a> when <a href="#avail_out">avail_out</a>
-   has dropped to zero. The application must initialize <a href="#zalloc">zalloc</a>, <a href="#zfree">zfree</a> and
-   <a href="#opaque">opaque</a> before calling the init function. All other fields are set by the
-   compression library and must not be updated by the application. <p>
-
-   The <a href="#opaque">opaque</a> value provided by the application will be passed as the first
-   parameter for calls of <a href="#zalloc">zalloc</a> and <a href="#zfree">zfree</a>. This can be useful for custom
-   memory management. The compression library attaches no meaning to the
-   <a href="#opaque">opaque</a> value. <p>
-
-   <a href="#zalloc">zalloc</a> must return <a href="#Z_NULL">Z_NULL</a> if there is not enough memory for the object.
-   If zlib is used in a multi-threaded application, <a href="#zalloc">zalloc</a> and <a href="#zfree">zfree</a> must be
-   thread safe. <p>
-
-   On 16-bit systems, the functions <a href="#zalloc">zalloc</a> and <a href="#zfree">zfree</a> must be able to allocate
-   exactly 65536 bytes, but will not be required to allocate more than this
-   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
-   pointers returned by <a href="#zalloc">zalloc</a> for objects of exactly 65536 bytes *must*
-   have their offset normalized to zero. The default allocation function
-   provided by this library ensures this (see zutil.c). To reduce memory
-   requirements and avoid any allocation of 64K objects, at the expense of
-   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
-   <p>
-
-   The fields <a href="#total_in">total_in</a> and <a href="#total_out">total_out</a> can be used for statistics or
-   progress reports. After compression, <a href="#total_in">total_in</a> holds the total size of
-   the uncompressed data and may be saved for use in the decompressor
-   (particularly if the decompressor wants to decompress everything in
-   a single step). <p>
-
-<hr>
-<a name="Constants"><h2> Constants </h2>
-<font color="Blue">
-<pre>
-#define <a name="Z_NO_FLUSH">Z_NO_FLUSH</a>      0
-#define <a name="Z_PARTIAL_FLUSH">Z_PARTIAL_FLUSH</a> 1
-	/* will be removed, use <a href="#Z_SYNC_FLUSH">Z_SYNC_FLUSH</a> instead */
-#define <a name="Z_SYNC_FLUSH">Z_SYNC_FLUSH</a>    2
-#define <a name="Z_FULL_FLUSH">Z_FULL_FLUSH</a>    3
-#define <a name="Z_FINISH">Z_FINISH</a>        4
-/* Allowed flush values ; see <a href="#deflate">deflate</a>() below for details */
-
-#define <a name="Z_OK">Z_OK</a>            0
-#define <a name="Z_STREAM_END">Z_STREAM_END</a>    1
-#define <a name="Z_NEED_DICT">Z_NEED_DICT</a>     2
-#define <a name="Z_ERRNO">Z_ERRNO</a>        (-1)
-#define <a name="Z_STREAM_ERROR">Z_STREAM_ERROR</a> (-2)
-#define <a name="Z_DATA_ERROR">Z_DATA_ERROR</a>   (-3)
-#define <a name="Z_MEM_ERROR">Z_MEM_ERROR</a>    (-4)
-#define <a name="Z_BUF_ERROR">Z_BUF_ERROR</a>    (-5)
-#define <a name="Z_VERSION_ERROR">Z_VERSION_ERROR</a> (-6)
-/* Return codes for the compression/decompression functions. Negative
- * values are errors, positive values are used for special but normal events.
- */
-
-#define <a name="Z_NO_COMPRESSION">Z_NO_COMPRESSION</a>         0
-#define <a name="Z_BEST_SPEED">Z_BEST_SPEED</a>             1
-#define <a name="Z_BEST_COMPRESSION">Z_BEST_COMPRESSION</a>       9
-#define <a name="Z_DEFAULT_COMPRESSION">Z_DEFAULT_COMPRESSION</a>  (-1)
-/* compression levels */
-
-#define <a name="Z_FILTERED">Z_FILTERED</a>            1
-#define <a name="Z_HUFFMAN_ONLY">Z_HUFFMAN_ONLY</a>        2
-#define <a name="Z_DEFAULT_STRATEGY">Z_DEFAULT_STRATEGY</a>    0
-/* compression strategy ; see <a href="#deflateInit2">deflateInit2</a>() below for details */
-
-#define <a name="Z_BINARY">Z_BINARY</a>   0
-#define <a name="Z_ASCII">Z_ASCII</a>    1
-#define <a name="Z_UNKNOWN">Z_UNKNOWN</a>  2
-/* Possible values of the <a href="#data_type">data_type</a> field */
-
-#define <a name="Z_DEFLATED">Z_DEFLATED</a>   8
-/* The <a href="#deflate">deflate</a> compression method (the only one supported in this version) */
-
-#define <a name="Z_NULL">Z_NULL</a>  0  /* for initializing <a href="#zalloc">zalloc</a>, <a href="#zfree">zfree</a>, <a href="#opaque">opaque</a> */
-
-#define <a name="zlib_version">zlib_version</a> <a href="#zlibVersion">zlibVersion</a>()
-/* for compatibility with versions less than 1.0.2 */
-</pre>
-</font>
-
-<hr>
-<a name="Misc"><h2> Misc </h2>
- <a href="#deflateInit">deflateInit</a> and <a href="#inflateInit">inflateInit</a> are macros to allow checking the zlib version
- and the compiler's view of <a href="#z_stream_s">z_stream</a>.
- <p>
- Other functions:
- <dl>
- <font color="Blue"><dt> const char   *  <a name="zError">zError</a>           (int err);</font>
- <font color="Blue"><dt> int             <a name="inflateSyncPoint">inflateSyncPoint</a> (<a href="#z_streamp">z_streamp</a> z);</font>
- <font color="Blue"><dt> const uLongf *  <a name="get_crc_table">get_crc_table</a>    (void);</font>
- </dl>
- <hr>
- <font size="-1">
- Last update: Wed Oct 13 20:42:34 1999<br>
- piapi@csie.ntu.edu.tw
- </font>
-
-</body>
-</html>
diff -Nbaur gcc-4.6.3/zlib/projects/README.projects gcc-4.6.3-psp/zlib/projects/README.projects
--- gcc-4.6.3/zlib/projects/README.projects	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/projects/README.projects	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-This directory contains project files for building zlib under various
-Integrated Development Environments (IDE).
-
-If you wish to submit a new project to this directory, you should comply
-to the following requirements.  Otherwise (e.g. if you wish to integrate
-a custom piece of code that changes the zlib interface or its behavior),
-please consider submitting the project to the contrib directory.
-
-
-Requirements
-============
-
-- The project must build zlib using the source files from the official
-  zlib source distribution, exclusively.
-
-- If the project produces redistributable builds (e.g. shared objects
-  or DLL files), these builds must be compatible to those produced by
-  makefiles, if such makefiles exist in the zlib distribution.
-  In particular, if the project produces a DLL build for the Win32
-  platform, this build must comply to the officially-ammended Win32 DLL
-  Application Binary Interface (ABI), described in win32/DLL_FAQ.txt.
-
-- The project may provide additional build targets, which depend on
-  3rd-party (unofficially-supported) software, present in the contrib
-  directory.  For example, it is possible to provide an "ASM build",
-  besides the officially-supported build, and have ASM source files
-  among its dependencies.
-
-- If there are significant differences between the project files created
-  by different versions of an IDE (e.g. Visual C++ 6.0 vs. 7.0), the name
-  of the project directory should contain the version number of the IDE
-  for which the project is intended (e.g. "visualc6" for Visual C++ 6.0,
-  or "visualc7" for Visual C++ 7.0 and 7.1).
-
-
-Current projects
-================
-
-visualc6/   by Simon-Pierre Cadieux <methodex@methodex.ca>
-            and Cosmin Truta <cosmint@cs.ubbcluj.ro>
-        Project for Microsoft Visual C++ 6.0
diff -Nbaur gcc-4.6.3/zlib/projects/visualc6/example.dsp gcc-4.6.3-psp/zlib/projects/visualc6/example.dsp
--- gcc-4.6.3/zlib/projects/visualc6/example.dsp	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/projects/visualc6/example.dsp	1970-01-01 01:00:00.000000000 +0100
@@ -1,278 +0,0 @@
-# Microsoft Developer Studio Project File - Name="example" - Package Owner=<4>
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE "Win32 (x86) Console Application" 0x0103
-
-CFG=example - Win32 LIB Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f "example.mak".
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f "example.mak" CFG="example - Win32 LIB Debug"
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE "example - Win32 DLL Release" (based on "Win32 (x86) Console Application")
-!MESSAGE "example - Win32 DLL Debug" (based on "Win32 (x86) Console Application")
-!MESSAGE "example - Win32 DLL ASM Release" (based on "Win32 (x86) Console Application")
-!MESSAGE "example - Win32 DLL ASM Debug" (based on "Win32 (x86) Console Application")
-!MESSAGE "example - Win32 LIB Release" (based on "Win32 (x86) Console Application")
-!MESSAGE "example - Win32 LIB Debug" (based on "Win32 (x86) Console Application")
-!MESSAGE "example - Win32 LIB ASM Release" (based on "Win32 (x86) Console Application")
-!MESSAGE "example - Win32 LIB ASM Debug" (based on "Win32 (x86) Console Application")
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName ""
-# PROP Scc_LocalPath ""
-CPP=cl.exe
-RSC=rc.exe
-
-!IF  "$(CFG)" == "example - Win32 DLL Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "example___Win32_DLL_Release"
-# PROP BASE Intermediate_Dir "example___Win32_DLL_Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Win32_DLL_Release"
-# PROP Intermediate_Dir "Win32_DLL_Release"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT BASE CPP /YX
-# ADD CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 /nologo /subsystem:console /machine:I386
-
-!ELSEIF  "$(CFG)" == "example - Win32 DLL Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "example___Win32_DLL_Debug"
-# PROP BASE Intermediate_Dir "example___Win32_DLL_Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Win32_DLL_Debug"
-# PROP Intermediate_Dir "Win32_DLL_Debug"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT BASE CPP /YX
-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-
-!ELSEIF  "$(CFG)" == "example - Win32 DLL ASM Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "example___Win32_DLL_ASM_Release"
-# PROP BASE Intermediate_Dir "example___Win32_DLL_ASM_Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Win32_DLL_ASM_Release"
-# PROP Intermediate_Dir "Win32_DLL_ASM_Release"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT BASE CPP /YX
-# ADD CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 /nologo /subsystem:console /machine:I386
-
-!ELSEIF  "$(CFG)" == "example - Win32 DLL ASM Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "example___Win32_DLL_ASM_Debug"
-# PROP BASE Intermediate_Dir "example___Win32_DLL_ASM_Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Win32_DLL_ASM_Debug"
-# PROP Intermediate_Dir "Win32_DLL_ASM_Debug"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT BASE CPP /YX
-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-
-!ELSEIF  "$(CFG)" == "example - Win32 LIB Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "example___Win32_LIB_Release"
-# PROP BASE Intermediate_Dir "example___Win32_LIB_Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Win32_LIB_Release"
-# PROP Intermediate_Dir "Win32_LIB_Release"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT BASE CPP /YX
-# ADD CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 /nologo /subsystem:console /machine:I386
-
-!ELSEIF  "$(CFG)" == "example - Win32 LIB Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "example___Win32_LIB_Debug"
-# PROP BASE Intermediate_Dir "example___Win32_LIB_Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Win32_LIB_Debug"
-# PROP Intermediate_Dir "Win32_LIB_Debug"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT BASE CPP /YX
-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-
-!ELSEIF  "$(CFG)" == "example - Win32 LIB ASM Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "example___Win32_LIB_ASM_Release"
-# PROP BASE Intermediate_Dir "example___Win32_LIB_ASM_Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Win32_LIB_ASM_Release"
-# PROP Intermediate_Dir "Win32_LIB_ASM_Release"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT BASE CPP /YX
-# ADD CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 /nologo /subsystem:console /machine:I386
-
-!ELSEIF  "$(CFG)" == "example - Win32 LIB ASM Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "example___Win32_LIB_ASM_Debug"
-# PROP BASE Intermediate_Dir "example___Win32_LIB_ASM_Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Win32_LIB_ASM_Debug"
-# PROP Intermediate_Dir "Win32_LIB_ASM_Debug"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT BASE CPP /YX
-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-
-!ENDIF 
-
-# Begin Target
-
-# Name "example - Win32 DLL Release"
-# Name "example - Win32 DLL Debug"
-# Name "example - Win32 DLL ASM Release"
-# Name "example - Win32 DLL ASM Debug"
-# Name "example - Win32 LIB Release"
-# Name "example - Win32 LIB Debug"
-# Name "example - Win32 LIB ASM Release"
-# Name "example - Win32 LIB ASM Debug"
-# Begin Group "Source Files"
-
-# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-# Begin Source File
-
-SOURCE=..\..\example.c
-# End Source File
-# End Group
-# Begin Group "Header Files"
-
-# PROP Default_Filter "h;hpp;hxx;hm;inl"
-# Begin Source File
-
-SOURCE=..\..\zconf.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\zlib.h
-# End Source File
-# End Group
-# End Target
-# End Project
diff -Nbaur gcc-4.6.3/zlib/projects/visualc6/minigzip.dsp gcc-4.6.3-psp/zlib/projects/visualc6/minigzip.dsp
--- gcc-4.6.3/zlib/projects/visualc6/minigzip.dsp	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/projects/visualc6/minigzip.dsp	1970-01-01 01:00:00.000000000 +0100
@@ -1,278 +0,0 @@
-# Microsoft Developer Studio Project File - Name="minigzip" - Package Owner=<4>
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE "Win32 (x86) Console Application" 0x0103
-
-CFG=minigzip - Win32 LIB Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f "minigzip.mak".
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f "minigzip.mak" CFG="minigzip - Win32 LIB Debug"
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE "minigzip - Win32 DLL Release" (based on "Win32 (x86) Console Application")
-!MESSAGE "minigzip - Win32 DLL Debug" (based on "Win32 (x86) Console Application")
-!MESSAGE "minigzip - Win32 DLL ASM Release" (based on "Win32 (x86) Console Application")
-!MESSAGE "minigzip - Win32 DLL ASM Debug" (based on "Win32 (x86) Console Application")
-!MESSAGE "minigzip - Win32 LIB Release" (based on "Win32 (x86) Console Application")
-!MESSAGE "minigzip - Win32 LIB Debug" (based on "Win32 (x86) Console Application")
-!MESSAGE "minigzip - Win32 LIB ASM Release" (based on "Win32 (x86) Console Application")
-!MESSAGE "minigzip - Win32 LIB ASM Debug" (based on "Win32 (x86) Console Application")
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName ""
-# PROP Scc_LocalPath ""
-CPP=cl.exe
-RSC=rc.exe
-
-!IF  "$(CFG)" == "minigzip - Win32 DLL Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "minigzip___Win32_DLL_Release"
-# PROP BASE Intermediate_Dir "minigzip___Win32_DLL_Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Win32_DLL_Release"
-# PROP Intermediate_Dir "Win32_DLL_Release"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT BASE CPP /YX
-# ADD CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 /nologo /subsystem:console /machine:I386
-
-!ELSEIF  "$(CFG)" == "minigzip - Win32 DLL Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "minigzip___Win32_DLL_Debug"
-# PROP BASE Intermediate_Dir "minigzip___Win32_DLL_Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Win32_DLL_Debug"
-# PROP Intermediate_Dir "Win32_DLL_Debug"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT BASE CPP /YX
-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-
-!ELSEIF  "$(CFG)" == "minigzip - Win32 DLL ASM Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "minigzip___Win32_DLL_ASM_Release"
-# PROP BASE Intermediate_Dir "minigzip___Win32_DLL_ASM_Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Win32_DLL_ASM_Release"
-# PROP Intermediate_Dir "Win32_DLL_ASM_Release"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT BASE CPP /YX
-# ADD CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 /nologo /subsystem:console /machine:I386
-
-!ELSEIF  "$(CFG)" == "minigzip - Win32 DLL ASM Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "minigzip___Win32_DLL_ASM_Debug"
-# PROP BASE Intermediate_Dir "minigzip___Win32_DLL_ASM_Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Win32_DLL_ASM_Debug"
-# PROP Intermediate_Dir "Win32_DLL_ASM_Debug"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT BASE CPP /YX
-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-
-!ELSEIF  "$(CFG)" == "minigzip - Win32 LIB Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "minigzip___Win32_LIB_Release"
-# PROP BASE Intermediate_Dir "minigzip___Win32_LIB_Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Win32_LIB_Release"
-# PROP Intermediate_Dir "Win32_LIB_Release"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT BASE CPP /YX
-# ADD CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 /nologo /subsystem:console /machine:I386
-
-!ELSEIF  "$(CFG)" == "minigzip - Win32 LIB Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "minigzip___Win32_LIB_Debug"
-# PROP BASE Intermediate_Dir "minigzip___Win32_LIB_Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Win32_LIB_Debug"
-# PROP Intermediate_Dir "Win32_LIB_Debug"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT BASE CPP /YX
-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-
-!ELSEIF  "$(CFG)" == "minigzip - Win32 LIB ASM Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "minigzip___Win32_LIB_ASM_Release"
-# PROP BASE Intermediate_Dir "minigzip___Win32_LIB_ASM_Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Win32_LIB_ASM_Release"
-# PROP Intermediate_Dir "Win32_LIB_ASM_Release"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT BASE CPP /YX
-# ADD CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 /nologo /subsystem:console /machine:I386
-
-!ELSEIF  "$(CFG)" == "minigzip - Win32 LIB ASM Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "minigzip___Win32_LIB_ASM_Debug"
-# PROP BASE Intermediate_Dir "minigzip___Win32_LIB_ASM_Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Win32_LIB_ASM_Debug"
-# PROP Intermediate_Dir "Win32_LIB_ASM_Debug"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT BASE CPP /YX
-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT CPP /YX
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-
-!ENDIF 
-
-# Begin Target
-
-# Name "minigzip - Win32 DLL Release"
-# Name "minigzip - Win32 DLL Debug"
-# Name "minigzip - Win32 DLL ASM Release"
-# Name "minigzip - Win32 DLL ASM Debug"
-# Name "minigzip - Win32 LIB Release"
-# Name "minigzip - Win32 LIB Debug"
-# Name "minigzip - Win32 LIB ASM Release"
-# Name "minigzip - Win32 LIB ASM Debug"
-# Begin Group "Source Files"
-
-# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-# Begin Source File
-
-SOURCE=..\..\minigzip.c
-# End Source File
-# End Group
-# Begin Group "Header Files"
-
-# PROP Default_Filter "h;hpp;hxx;hm;inl"
-# Begin Source File
-
-SOURCE=..\..\zconf.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\zlib.h
-# End Source File
-# End Group
-# End Target
-# End Project
diff -Nbaur gcc-4.6.3/zlib/projects/visualc6/README.txt gcc-4.6.3-psp/zlib/projects/visualc6/README.txt
--- gcc-4.6.3/zlib/projects/visualc6/README.txt	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/projects/visualc6/README.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,73 +0,0 @@
-Microsoft Developer Studio Project Files, Format Version 6.00 for zlib.
-
-Copyright (C) 2000-2004 Simon-Pierre Cadieux.
-Copyright (C) 2004 Cosmin Truta.
-For conditions of distribution and use, see copyright notice in zlib.h.
-
-
-This project builds the zlib binaries as follows:
-
-* Win32_DLL_Release\zlib1.dll       DLL build
-* Win32_DLL_Debug\zlib1d.dll        DLL build (debug version)
-* Win32_DLL_ASM_Release\zlib1.dll   DLL build using ASM code
-* Win32_DLL_ASM_Debug\zlib1d.dll    DLL build using ASM code (debug version)
-* Win32_LIB_Release\zlib.lib        static build
-* Win32_LIB_Debug\zlibd.lib         static build (debug version)
-* Win32_LIB_ASM_Release\zlib.lib    static build using ASM code
-* Win32_LIB_ASM_Debug\zlibd.lib     static build using ASM code (debug version)
-
-
-For more information regarding the DLL builds, please see the DLL FAQ
-in ..\..\win32\DLL_FAQ.txt.
-
-
-To build and test:
-
-1) On the main menu, select "File | Open Workspace".
-   Open "zlib.dsw".
-
-2) Select "Build | Set Active Configuration".
-   Choose the configuration you wish to build.
-
-3) Select "Build | Clean".
-
-4) Select "Build | Build ... (F7)".  Ignore warning messages about
-   not being able to find certain include files (e.g. alloc.h).
-
-5) If you built one of the sample programs (example or minigzip),
-   select "Build | Execute ... (Ctrl+F5)".
-
-
-To use:
-
-1) Select "Project | Settings (Alt+F7)".
-   Make note of the configuration names used in your project.
-   Usually, these names are "Win32 Release" and "Win32 Debug".
-
-2) In the Workspace window, select the "FileView" tab.
-   Right-click on the root item "Workspace '...'".
-   Select "Insert Project into Workspace".
-   Switch on the checkbox "Dependency of:", and select the name
-   of your project.  Open "zlib.dsp".
-
-3) Select "Build | Configurations".
-   For each configuration of your project:
-   3.1) Choose the zlib configuration you wish to use.
-   3.2) Click on "Add".
-   3.3) Set the new zlib configuration name to the name used by
-        the configuration from the current iteration.
-
-4) Select "Build | Set Active Configuration".
-   Choose the configuration you wish to build.
-
-5) Select "Build | Build ... (F7)".
-
-6) If you built an executable program, select
-   "Build | Execute ... (Ctrl+F5)".
-
-
-Note:
-
-To build the ASM-enabled code, you need Microsoft Assembler
-(ML.EXE).  You can get it by downloading and installing the
-latest Processor Pack for Visual C++ 6.0.
diff -Nbaur gcc-4.6.3/zlib/projects/visualc6/zlib.dsp gcc-4.6.3-psp/zlib/projects/visualc6/zlib.dsp
--- gcc-4.6.3/zlib/projects/visualc6/zlib.dsp	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/projects/visualc6/zlib.dsp	1970-01-01 01:00:00.000000000 +0100
@@ -1,609 +0,0 @@
-# Microsoft Developer Studio Project File - Name="zlib" - Package Owner=<4>
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
-# TARGTYPE "Win32 (x86) Static Library" 0x0104
-
-CFG=zlib - Win32 LIB Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f "zlib.mak".
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f "zlib.mak" CFG="zlib - Win32 LIB Debug"
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE "zlib - Win32 DLL Release" (based on "Win32 (x86) Dynamic-Link Library")
-!MESSAGE "zlib - Win32 DLL Debug" (based on "Win32 (x86) Dynamic-Link Library")
-!MESSAGE "zlib - Win32 DLL ASM Release" (based on "Win32 (x86) Dynamic-Link Library")
-!MESSAGE "zlib - Win32 DLL ASM Debug" (based on "Win32 (x86) Dynamic-Link Library")
-!MESSAGE "zlib - Win32 LIB Release" (based on "Win32 (x86) Static Library")
-!MESSAGE "zlib - Win32 LIB Debug" (based on "Win32 (x86) Static Library")
-!MESSAGE "zlib - Win32 LIB ASM Release" (based on "Win32 (x86) Static Library")
-!MESSAGE "zlib - Win32 LIB ASM Debug" (based on "Win32 (x86) Static Library")
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName ""
-# PROP Scc_LocalPath ""
-
-!IF  "$(CFG)" == "zlib - Win32 DLL Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "zlib___Win32_DLL_Release"
-# PROP BASE Intermediate_Dir "zlib___Win32_DLL_Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Win32_DLL_Release"
-# PROP Intermediate_Dir "Win32_DLL_Release"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-CPP=cl.exe
-# ADD BASE CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT BASE CPP /YX /Yc /Yu
-# ADD CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT CPP /YX /Yc /Yu
-MTL=midl.exe
-# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
-# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
-RSC=rc.exe
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
-# ADD LINK32 /nologo /dll /machine:I386 /out:"Win32_DLL_Release\zlib1.dll"
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 DLL Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "zlib___Win32_DLL_Debug"
-# PROP BASE Intermediate_Dir "zlib___Win32_DLL_Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Win32_DLL_Debug"
-# PROP Intermediate_Dir "Win32_DLL_Debug"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-CPP=cl.exe
-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT BASE CPP /YX /Yc /Yu
-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT CPP /YX /Yc /Yu
-MTL=midl.exe
-# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
-# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
-RSC=rc.exe
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 /nologo /dll /debug /machine:I386 /out:"Win32_DLL_Debug\zlib1d.dll" /pdbtype:sept
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 DLL ASM Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "zlib___Win32_DLL_ASM_Release"
-# PROP BASE Intermediate_Dir "zlib___Win32_DLL_ASM_Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Win32_DLL_ASM_Release"
-# PROP Intermediate_Dir "Win32_DLL_ASM_Release"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-CPP=cl.exe
-# ADD BASE CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT BASE CPP /YX /Yc /Yu
-# ADD CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /D "ASMV" /D "ASMINF" /FD /c
-# SUBTRACT CPP /YX /Yc /Yu
-MTL=midl.exe
-# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
-# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
-RSC=rc.exe
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
-# ADD LINK32 /nologo /dll /machine:I386 /out:"Win32_DLL_ASM_Release\zlib1.dll"
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 DLL ASM Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "zlib___Win32_DLL_ASM_Debug"
-# PROP BASE Intermediate_Dir "zlib___Win32_DLL_ASM_Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Win32_DLL_ASM_Debug"
-# PROP Intermediate_Dir "Win32_DLL_ASM_Debug"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-CPP=cl.exe
-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT BASE CPP /YX /Yc /Yu
-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /D "ASMV" /D "ASMINF" /FD /GZ /c
-# SUBTRACT CPP /YX /Yc /Yu
-MTL=midl.exe
-# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
-# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
-RSC=rc.exe
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 /nologo /dll /debug /machine:I386 /out:"Win32_DLL_ASM_Debug\zlib1d.dll" /pdbtype:sept
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "zlib___Win32_LIB_Release"
-# PROP BASE Intermediate_Dir "zlib___Win32_LIB_Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Win32_LIB_Release"
-# PROP Intermediate_Dir "Win32_LIB_Release"
-# PROP Target_Dir ""
-CPP=cl.exe
-# ADD BASE CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT BASE CPP /YX /Yc /Yu
-# ADD CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT CPP /YX /Yc /Yu
-RSC=rc.exe
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LIB32=link.exe -lib
-# ADD BASE LIB32 /nologo
-# ADD LIB32 /nologo
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "zlib___Win32_LIB_Debug"
-# PROP BASE Intermediate_Dir "zlib___Win32_LIB_Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Win32_LIB_Debug"
-# PROP Intermediate_Dir "Win32_LIB_Debug"
-# PROP Target_Dir ""
-CPP=cl.exe
-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT BASE CPP /YX /Yc /Yu
-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT CPP /YX /Yc /Yu
-RSC=rc.exe
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LIB32=link.exe -lib
-# ADD BASE LIB32 /nologo
-# ADD LIB32 /nologo /out:"Win32_LIB_Debug\zlibd.lib"
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB ASM Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "zlib___Win32_LIB_ASM_Release"
-# PROP BASE Intermediate_Dir "zlib___Win32_LIB_ASM_Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Win32_LIB_ASM_Release"
-# PROP Intermediate_Dir "Win32_LIB_ASM_Release"
-# PROP Target_Dir ""
-CPP=cl.exe
-# ADD BASE CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /FD /c
-# SUBTRACT BASE CPP /YX /Yc /Yu
-# ADD CPP /nologo /MD /W3 /O2 /D "WIN32" /D "NDEBUG" /D "ASMV" /D "ASMINF" /FD /c
-# SUBTRACT CPP /YX /Yc /Yu
-RSC=rc.exe
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LIB32=link.exe -lib
-# ADD BASE LIB32 /nologo
-# ADD LIB32 /nologo
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB ASM Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "zlib___Win32_LIB_ASM_Debug"
-# PROP BASE Intermediate_Dir "zlib___Win32_LIB_ASM_Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Win32_LIB_ASM_Debug"
-# PROP Intermediate_Dir "Win32_LIB_ASM_Debug"
-# PROP Target_Dir ""
-CPP=cl.exe
-# ADD BASE CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /FD /GZ /c
-# SUBTRACT BASE CPP /YX /Yc /Yu
-# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /D "WIN32" /D "_DEBUG" /D "ASMV" /D "ASMINF" /FD /GZ /c
-# SUBTRACT CPP /YX /Yc /Yu
-RSC=rc.exe
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LIB32=link.exe -lib
-# ADD BASE LIB32 /nologo
-# ADD LIB32 /nologo /out:"Win32_LIB_ASM_Debug\zlibd.lib"
-
-!ENDIF 
-
-# Begin Target
-
-# Name "zlib - Win32 DLL Release"
-# Name "zlib - Win32 DLL Debug"
-# Name "zlib - Win32 DLL ASM Release"
-# Name "zlib - Win32 DLL ASM Debug"
-# Name "zlib - Win32 LIB Release"
-# Name "zlib - Win32 LIB Debug"
-# Name "zlib - Win32 LIB ASM Release"
-# Name "zlib - Win32 LIB ASM Debug"
-# Begin Group "Source Files"
-
-# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-# Begin Source File
-
-SOURCE=..\..\adler32.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\compress.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\crc32.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\deflate.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\gzio.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\infback.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\inffast.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\inflate.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\inftrees.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\trees.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\uncompr.c
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\win32\zlib.def
-
-!IF  "$(CFG)" == "zlib - Win32 DLL Release"
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 DLL Debug"
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 DLL ASM Release"
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 DLL ASM Debug"
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB Release"
-
-# PROP Exclude_From_Build 1
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB Debug"
-
-# PROP Exclude_From_Build 1
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB ASM Release"
-
-# PROP Exclude_From_Build 1
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB ASM Debug"
-
-# PROP Exclude_From_Build 1
-
-!ENDIF 
-
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\zutil.c
-# End Source File
-# End Group
-# Begin Group "Header Files"
-
-# PROP Default_Filter "h;hpp;hxx;hm;inl"
-# Begin Source File
-
-SOURCE=..\..\crc32.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\deflate.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\inffast.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\inffixed.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\inflate.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\inftrees.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\trees.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\zconf.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\zlib.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\zutil.h
-# End Source File
-# End Group
-# Begin Group "Resource Files"
-
-# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
-# Begin Source File
-
-SOURCE=..\..\win32\zlib1.rc
-# End Source File
-# End Group
-# Begin Group "Assembler Files (Unsupported)"
-
-# PROP Default_Filter "asm;obj;c;cpp;cxx;h;hpp;hxx"
-# Begin Source File
-
-SOURCE=..\..\contrib\masmx86\gvmat32.asm
-
-!IF  "$(CFG)" == "zlib - Win32 DLL Release"
-
-# PROP Exclude_From_Build 1
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 DLL Debug"
-
-# PROP Exclude_From_Build 1
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 DLL ASM Release"
-
-# Begin Custom Build - Assembling...
-IntDir=.\Win32_DLL_ASM_Release
-InputPath=..\..\contrib\masmx86\gvmat32.asm
-InputName=gvmat32
-
-"$(IntDir)\$(InputName).obj" : $(SOURCE) "$(INTDIR)" "$(OUTDIR)"
-	ml.exe /nologo /c /coff /Cx /Fo"$(IntDir)\$(InputName).obj" "$(InputPath)"
-
-# End Custom Build
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 DLL ASM Debug"
-
-# Begin Custom Build - Assembling...
-IntDir=.\Win32_DLL_ASM_Debug
-InputPath=..\..\contrib\masmx86\gvmat32.asm
-InputName=gvmat32
-
-"$(IntDir)\$(InputName).obj" : $(SOURCE) "$(INTDIR)" "$(OUTDIR)"
-	ml.exe /nologo /c /coff /Cx /Zi /Fo"$(IntDir)\$(InputName).obj" "$(InputPath)"
-
-# End Custom Build
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB Release"
-
-# PROP Exclude_From_Build 1
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB Debug"
-
-# PROP Exclude_From_Build 1
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB ASM Release"
-
-# Begin Custom Build - Assembling...
-IntDir=.\Win32_LIB_ASM_Release
-InputPath=..\..\contrib\masmx86\gvmat32.asm
-InputName=gvmat32
-
-"$(IntDir)\$(InputName).obj" : $(SOURCE) "$(INTDIR)" "$(OUTDIR)"
-	ml.exe /nologo /c /coff /Cx /Fo"$(IntDir)\$(InputName).obj" "$(InputPath)"
-
-# End Custom Build
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB ASM Debug"
-
-# Begin Custom Build - Assembling...
-IntDir=.\Win32_LIB_ASM_Debug
-InputPath=..\..\contrib\masmx86\gvmat32.asm
-InputName=gvmat32
-
-"$(IntDir)\$(InputName).obj" : $(SOURCE) "$(INTDIR)" "$(OUTDIR)"
-	ml.exe /nologo /c /coff /Cx /Zi /Fo"$(IntDir)\$(InputName).obj" "$(InputPath)"
-
-# End Custom Build
-
-!ENDIF 
-
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\contrib\masmx86\gvmat32c.c
-
-!IF  "$(CFG)" == "zlib - Win32 DLL Release"
-
-# PROP Exclude_From_Build 1
-# ADD CPP /I "..\.."
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 DLL Debug"
-
-# PROP Exclude_From_Build 1
-# ADD CPP /I "..\.."
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 DLL ASM Release"
-
-# ADD CPP /I "..\.."
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 DLL ASM Debug"
-
-# ADD CPP /I "..\.."
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB Release"
-
-# PROP Exclude_From_Build 1
-# ADD CPP /I "..\.."
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB Debug"
-
-# PROP Exclude_From_Build 1
-# ADD CPP /I "..\.."
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB ASM Release"
-
-# ADD CPP /I "..\.."
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB ASM Debug"
-
-# ADD CPP /I "..\.."
-
-!ENDIF 
-
-# End Source File
-# Begin Source File
-
-SOURCE=..\..\contrib\masmx86\inffas32.asm
-
-!IF  "$(CFG)" == "zlib - Win32 DLL Release"
-
-# PROP Exclude_From_Build 1
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 DLL Debug"
-
-# PROP Exclude_From_Build 1
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 DLL ASM Release"
-
-# Begin Custom Build - Assembling...
-IntDir=.\Win32_DLL_ASM_Release
-InputPath=..\..\contrib\masmx86\inffas32.asm
-InputName=inffas32
-
-"$(IntDir)\$(InputName).obj" : $(SOURCE) "$(INTDIR)" "$(OUTDIR)"
-	ml.exe /nologo /c /coff /Cx /Fo"$(IntDir)\$(InputName).obj" "$(InputPath)"
-
-# End Custom Build
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 DLL ASM Debug"
-
-# Begin Custom Build - Assembling...
-IntDir=.\Win32_DLL_ASM_Debug
-InputPath=..\..\contrib\masmx86\inffas32.asm
-InputName=inffas32
-
-"$(IntDir)\$(InputName).obj" : $(SOURCE) "$(INTDIR)" "$(OUTDIR)"
-	ml.exe /nologo /c /coff /Cx /Zi /Fo"$(IntDir)\$(InputName).obj" "$(InputPath)"
-
-# End Custom Build
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB Release"
-
-# PROP Exclude_From_Build 1
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB Debug"
-
-# PROP Exclude_From_Build 1
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB ASM Release"
-
-# Begin Custom Build - Assembling...
-IntDir=.\Win32_LIB_ASM_Release
-InputPath=..\..\contrib\masmx86\inffas32.asm
-InputName=inffas32
-
-"$(IntDir)\$(InputName).obj" : $(SOURCE) "$(INTDIR)" "$(OUTDIR)"
-	ml.exe /nologo /c /coff /Cx /Fo"$(IntDir)\$(InputName).obj" "$(InputPath)"
-
-# End Custom Build
-
-!ELSEIF  "$(CFG)" == "zlib - Win32 LIB ASM Debug"
-
-# Begin Custom Build - Assembling...
-IntDir=.\Win32_LIB_ASM_Debug
-InputPath=..\..\contrib\masmx86\inffas32.asm
-InputName=inffas32
-
-"$(IntDir)\$(InputName).obj" : $(SOURCE) "$(INTDIR)" "$(OUTDIR)"
-	ml.exe /nologo /c /coff /Cx /Zi /Fo"$(IntDir)\$(InputName).obj" "$(InputPath)"
-
-# End Custom Build
-
-!ENDIF 
-
-# End Source File
-# End Group
-# Begin Source File
-
-SOURCE=.\README.txt
-# End Source File
-# End Target
-# End Project
diff -Nbaur gcc-4.6.3/zlib/projects/visualc6/zlib.dsw gcc-4.6.3-psp/zlib/projects/visualc6/zlib.dsw
--- gcc-4.6.3/zlib/projects/visualc6/zlib.dsw	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/projects/visualc6/zlib.dsw	1970-01-01 01:00:00.000000000 +0100
@@ -1,59 +0,0 @@
-Microsoft Developer Studio Workspace File, Format Version 6.00
-# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
-
-###############################################################################
-
-Project: "example"=.\example.dsp - Package Owner=<4>
-
-Package=<5>
-{{{
-}}}
-
-Package=<4>
-{{{
-    Begin Project Dependency
-    Project_Dep_Name zlib
-    End Project Dependency
-}}}
-
-###############################################################################
-
-Project: "minigzip"=.\minigzip.dsp - Package Owner=<4>
-
-Package=<5>
-{{{
-}}}
-
-Package=<4>
-{{{
-    Begin Project Dependency
-    Project_Dep_Name zlib
-    End Project Dependency
-}}}
-
-###############################################################################
-
-Project: "zlib"=.\zlib.dsp - Package Owner=<4>
-
-Package=<5>
-{{{
-}}}
-
-Package=<4>
-{{{
-}}}
-
-###############################################################################
-
-Global:
-
-Package=<5>
-{{{
-}}}
-
-Package=<3>
-{{{
-}}}
-
-###############################################################################
-
diff -Nbaur gcc-4.6.3/zlib/qnx/package.qpg gcc-4.6.3-psp/zlib/qnx/package.qpg
--- gcc-4.6.3/zlib/qnx/package.qpg	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/qnx/package.qpg	1970-01-01 01:00:00.000000000 +0100
@@ -1,141 +0,0 @@
-<QPG:Generation>
-   <QPG:Options>
-      <QPG:User unattended="no" verbosity="2" listfiles="yes"/>
-      <QPG:Defaults type="qnx_package"/>
-      <QPG:Source></QPG:Source>
-      <QPG:Release number="+"/>
-      <QPG:Build></QPG:Build>
-      <QPG:FileSorting strip="yes"/>
-      <QPG:Package targets="combine"/>
-      <QPG:Repository generate="yes"/>
-      <QPG:FinalDir></QPG:FinalDir>
-      <QPG:Cleanup></QPG:Cleanup>
-   </QPG:Options>
-
-   <QPG:Responsible>
-      <QPG:Company></QPG:Company>
-      <QPG:Department></QPG:Department>
-      <QPG:Group></QPG:Group>
-      <QPG:Team></QPG:Team>
-      <QPG:Employee></QPG:Employee>
-      <QPG:EmailAddress></QPG:EmailAddress>
-   </QPG:Responsible>
-
-   <QPG:Values>
-      <QPG:Files>
-         <QPG:Add file="../zconf.h" install="/opt/include/" user="root:sys" permission="644"/>
-         <QPG:Add file="../zlib.h" install="/opt/include/" user="root:sys" permission="644"/>
-         <QPG:Add file="../libz.so.1.2.3" install="/opt/lib/" user="root:bin" permission="644"/>
-         <QPG:Add file="libz.so" install="/opt/lib/" component="dev" filetype="symlink" linkto="libz.so.1.2.3"/>
-         <QPG:Add file="libz.so.1" install="/opt/lib/" filetype="symlink" linkto="libz.so.1.2.3"/>
-         <QPG:Add file="../libz.so.1.2.3" install="/opt/lib/" component="slib"/>
-      </QPG:Files>
-
-      <QPG:PackageFilter>
-         <QPM:PackageManifest>
-            <QPM:PackageDescription>
-               <QPM:PackageType>Library</QPM:PackageType>
-               <QPM:PackageReleaseNotes></QPM:PackageReleaseNotes>
-               <QPM:PackageReleaseUrgency>Medium</QPM:PackageReleaseUrgency>
-               <QPM:PackageRepository></QPM:PackageRepository>
-               <QPM:FileVersion>2.0</QPM:FileVersion>
-            </QPM:PackageDescription>
-
-            <QPM:ProductDescription>
-               <QPM:ProductName>zlib</QPM:ProductName>
-               <QPM:ProductIdentifier>zlib</QPM:ProductIdentifier>
-               <QPM:ProductEmail>alain.bonnefoy@icbt.com</QPM:ProductEmail>
-               <QPM:VendorName>Public</QPM:VendorName>
-               <QPM:VendorInstallName>public</QPM:VendorInstallName>
-               <QPM:VendorURL>www.gzip.org/zlib</QPM:VendorURL>
-               <QPM:VendorEmbedURL></QPM:VendorEmbedURL>
-               <QPM:VendorEmail></QPM:VendorEmail>
-               <QPM:AuthorName>Jean-Loup Gailly,Mark Adler</QPM:AuthorName>
-               <QPM:AuthorURL>www.gzip.org/zlib</QPM:AuthorURL>
-               <QPM:AuthorEmbedURL></QPM:AuthorEmbedURL>
-               <QPM:AuthorEmail>zlib@gzip.org</QPM:AuthorEmail>
-               <QPM:ProductIconSmall></QPM:ProductIconSmall>
-               <QPM:ProductIconLarge></QPM:ProductIconLarge>
-               <QPM:ProductDescriptionShort>A massively spiffy yet delicately unobtrusive compression library.</QPM:ProductDescriptionShort>
-               <QPM:ProductDescriptionLong>zlib is designed to be a free, general-purpose, legally unencumbered, lossless data compression library for use on virtually any computer hardware and operating system.</QPM:ProductDescriptionLong>
-               <QPM:ProductDescriptionURL>http://www.gzip.org/zlib</QPM:ProductDescriptionURL>
-               <QPM:ProductDescriptionEmbedURL></QPM:ProductDescriptionEmbedURL>
-            </QPM:ProductDescription>
-
-            <QPM:ReleaseDescription>
-               <QPM:ReleaseVersion>1.2.3</QPM:ReleaseVersion>
-               <QPM:ReleaseUrgency>Medium</QPM:ReleaseUrgency>
-               <QPM:ReleaseStability>Stable</QPM:ReleaseStability>
-               <QPM:ReleaseNoteMinor></QPM:ReleaseNoteMinor>
-               <QPM:ReleaseNoteMajor></QPM:ReleaseNoteMajor>
-               <QPM:ExcludeCountries>
-                  <QPM:Country></QPM:Country>
-               </QPM:ExcludeCountries>
-
-               <QPM:ReleaseCopyright>No License</QPM:ReleaseCopyright>
-            </QPM:ReleaseDescription>
-
-            <QPM:ContentDescription>
-               <QPM:ContentTopic xmlmultiple="true">Software Development/Libraries and Extensions/C Libraries</QPM:ContentTopic>
-               <QPM:ContentKeyword>zlib,compression</QPM:ContentKeyword>
-               <QPM:TargetOS>qnx6</QPM:TargetOS>
-               <QPM:HostOS>qnx6</QPM:HostOS>
-               <QPM:DisplayEnvironment xmlmultiple="true">None</QPM:DisplayEnvironment>
-               <QPM:TargetAudience xmlmultiple="true">Developer</QPM:TargetAudience>
-            </QPM:ContentDescription>
-         </QPM:PackageManifest>
-      </QPG:PackageFilter>
-
-      <QPG:PackageFilter proc="none" target="none">
-         <QPM:PackageManifest>
-            <QPM:ProductInstallationDependencies>
-               <QPM:ProductRequirements></QPM:ProductRequirements>
-            </QPM:ProductInstallationDependencies>
-
-            <QPM:ProductInstallationProcedure>
-               <QPM:Script xmlmultiple="true">
-                  <QPM:ScriptName></QPM:ScriptName>
-                  <QPM:ScriptType>Install</QPM:ScriptType>
-                  <QPM:ScriptTiming>Post</QPM:ScriptTiming>
-                  <QPM:ScriptBlocking>No</QPM:ScriptBlocking>
-                  <QPM:ScriptResult>Ignore</QPM:ScriptResult>
-                  <QPM:ShortDescription></QPM:ShortDescription>
-                  <QPM:UseBinaries>No</QPM:UseBinaries>
-                  <QPM:Priority>Optional</QPM:Priority>
-               </QPM:Script>
-            </QPM:ProductInstallationProcedure>
-         </QPM:PackageManifest>
-
-         <QPM:Launch>
-         </QPM:Launch>
-      </QPG:PackageFilter>
-
-      <QPG:PackageFilter type="core" component="none">
-         <QPM:PackageManifest>
-            <QPM:ProductInstallationProcedure>
-	       <QPM:OrderDependency xmlmultiple="true">
-	          <QPM:Order>InstallOver</QPM:Order>
-	          <QPM:Product>zlib</QPM:Product>
-	       </QPM:OrderDependency>
-            </QPM:ProductInstallationProcedure>
-         </QPM:PackageManifest>
-
-         <QPM:Launch>
-         </QPM:Launch>
-      </QPG:PackageFilter>
-
-      <QPG:PackageFilter type="core" component="dev">
-         <QPM:PackageManifest>
-            <QPM:ProductInstallationProcedure>
-	       <QPM:OrderDependency xmlmultiple="true">
-	          <QPM:Order>InstallOver</QPM:Order>
-	          <QPM:Product>zlib-dev</QPM:Product>
-	       </QPM:OrderDependency>
-            </QPM:ProductInstallationProcedure>
-         </QPM:PackageManifest>
-
-         <QPM:Launch>
-         </QPM:Launch>
-      </QPG:PackageFilter>
-   </QPG:Values>
-</QPG:Generation>
diff -Nbaur gcc-4.6.3/zlib/README gcc-4.6.3-psp/zlib/README
--- gcc-4.6.3/zlib/README	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,128 +0,0 @@
-This directory contains the zlib package, which is not part of GCC but
-shipped with GCC as convenience.
-
-ZLIB DATA COMPRESSION LIBRARY
-
-zlib 1.2.3 is a general purpose data compression library.  All the code is
-thread safe.  The data format used by the zlib library is described by RFCs
-(Request for Comments) 1950 to 1952 in the files
-http://www.ietf.org/rfc/rfc1950.txt (zlib format), rfc1951.txt (deflate format)
-and rfc1952.txt (gzip format). These documents are also available in other
-formats from ftp://ftp.uu.net/graphics/png/documents/zlib/zdoc-index.html
-
-All functions of the compression library are documented in the file zlib.h
-(volunteer to write man pages welcome, contact zlib@gzip.org). A usage example
-of the library is given in the file example.c which also tests that the library
-is working correctly. Another example is given in the file minigzip.c. The
-compression library itself is composed of all source files except example.c and
-minigzip.c.
-
-To compile all files and run the test program, follow the instructions given at
-the top of Makefile. In short "make test; make install" should work for most
-machines. For Unix: "./configure; make test; make install". For MSDOS, use one
-of the special makefiles such as Makefile.msc. For VMS, use make_vms.com.
-
-Questions about zlib should be sent to <zlib@gzip.org>, or to Gilles Vollant
-<info@winimage.com> for the Windows DLL version. The zlib home page is
-http://www.zlib.org or http://www.gzip.org/zlib/ Before reporting a problem,
-please check this site to verify that you have the latest version of zlib;
-otherwise get the latest version and check whether the problem still exists or
-not.
-
-PLEASE read the zlib FAQ http://www.gzip.org/zlib/zlib_faq.html before asking
-for help.
-
-Mark Nelson <markn@ieee.org> wrote an article about zlib for the Jan. 1997
-issue of  Dr. Dobb's Journal; a copy of the article is available in
-http://dogma.net/markn/articles/zlibtool/zlibtool.htm
-
-The changes made in version 1.2.3 are documented in the file ChangeLog.
-
-Unsupported third party contributions are provided in directory "contrib".
-
-A Java implementation of zlib is available in the Java Development Kit
-http://java.sun.com/j2se/1.4.2/docs/api/java/util/zip/package-summary.html
-See the zlib home page http://www.zlib.org for details.
-
-A Perl interface to zlib written by Paul Marquess <pmqs@cpan.org> is in the
-CPAN (Comprehensive Perl Archive Network) sites
-http://www.cpan.org/modules/by-module/Compress/
-
-A Python interface to zlib written by A.M. Kuchling <amk@amk.ca> is
-available in Python 1.5 and later versions, see
-http://www.python.org/doc/lib/module-zlib.html
-
-A zlib binding for TCL written by Andreas Kupries <a.kupries@westend.com> is
-availlable at http://www.oche.de/~akupries/soft/trf/trf_zip.html
-
-An experimental package to read and write files in .zip format, written on top
-of zlib by Gilles Vollant <info@winimage.com>, is available in the
-contrib/minizip directory of zlib.
-
-
-Notes for some targets:
-
-- For Windows DLL versions, please see win32/DLL_FAQ.txt
-
-- For 64-bit Irix, deflate.c must be compiled without any optimization. With
-  -O, one libpng test fails. The test works in 32 bit mode (with the -n32
-  compiler flag). The compiler bug has been reported to SGI.
-
-- zlib doesn't work with gcc 2.6.3 on a DEC 3000/300LX under OSF/1 2.1 it works
-  when compiled with cc.
-
-- On Digital Unix 4.0D (formely OSF/1) on AlphaServer, the cc option -std1 is
-  necessary to get gzprintf working correctly. This is done by configure.
-
-- zlib doesn't work on HP-UX 9.05 with some versions of /bin/cc. It works with
-  other compilers. Use "make test" to check your compiler.
-
-- gzdopen is not supported on RISCOS, BEOS and by some Mac compilers.
-
-- For PalmOs, see http://palmzlib.sourceforge.net/
-
-- When building a shared, i.e. dynamic library on Mac OS X, the library must be
-  installed before testing (do "make install" before "make test"), since the
-  library location is specified in the library.
-
-
-Acknowledgments:
-
-  The deflate format used by zlib was defined by Phil Katz. The deflate
-  and zlib specifications were written by L. Peter Deutsch. Thanks to all the
-  people who reported problems and suggested various improvements in zlib;
-  they are too numerous to cite here.
-
-Copyright notice:
-
- (C) 1995-2004 Jean-loup Gailly and Mark Adler
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Jean-loup Gailly        Mark Adler
-  jloup@gzip.org          madler@alumni.caltech.edu
-
-If you use the zlib library in a product, we would appreciate *not*
-receiving lengthy legal documents to sign. The sources are provided
-for free but without warranty of any kind.  The library has been
-entirely written by Jean-loup Gailly and Mark Adler; it does not
-include third-party code.
-
-If you redistribute modified sources, we would appreciate that you include
-in the file ChangeLog history information documenting your changes. Please
-read the FAQ for more information on the distribution of modified source
-versions.
diff -Nbaur gcc-4.6.3/zlib/trees.c gcc-4.6.3-psp/zlib/trees.c
--- gcc-4.6.3/zlib/trees.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/trees.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1219 +0,0 @@
-/* trees.c -- output deflated data using Huffman coding
- * Copyright (C) 1995-2005 Jean-loup Gailly
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/*
- *  ALGORITHM
- *
- *      The "deflation" process uses several Huffman trees. The more
- *      common source values are represented by shorter bit sequences.
- *
- *      Each code tree is stored in a compressed form which is itself
- * a Huffman encoding of the lengths of all the code strings (in
- * ascending order by source values).  The actual code strings are
- * reconstructed from the lengths in the inflate process, as described
- * in the deflate specification.
- *
- *  REFERENCES
- *
- *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
- *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
- *
- *      Storer, James A.
- *          Data Compression:  Methods and Theory, pp. 49-50.
- *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
- *
- *      Sedgewick, R.
- *          Algorithms, p290.
- *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
- */
-
-/* @(#) $Id: trees.c,v 1.1.1.2 2002/03/11 21:53:27 tromey Exp $ */
-
-/* #define GEN_TREES_H */
-
-#include "deflate.h"
-
-#ifdef DEBUG
-#  include <ctype.h>
-#endif
-
-/* ===========================================================================
- * Constants
- */
-
-#define MAX_BL_BITS 7
-/* Bit length codes must not exceed MAX_BL_BITS bits */
-
-#define END_BLOCK 256
-/* end of block literal code */
-
-#define REP_3_6      16
-/* repeat previous bit length 3-6 times (2 bits of repeat count) */
-
-#define REPZ_3_10    17
-/* repeat a zero length 3-10 times  (3 bits of repeat count) */
-
-#define REPZ_11_138  18
-/* repeat a zero length 11-138 times  (7 bits of repeat count) */
-
-local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
-   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
-
-local const int extra_dbits[D_CODES] /* extra bits for each distance code */
-   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
-
-local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
-   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
-
-local const uch bl_order[BL_CODES]
-   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
-/* The lengths of the bit length codes are sent in order of decreasing
- * probability, to avoid transmitting the lengths for unused bit length codes.
- */
-
-#define Buf_size (8 * 2*sizeof(char))
-/* Number of bits used within bi_buf. (bi_buf might be implemented on
- * more than 16 bits on some systems.)
- */
-
-/* ===========================================================================
- * Local data. These are initialized only once.
- */
-
-#define DIST_CODE_LEN  512 /* see definition of array dist_code below */
-
-#if defined(GEN_TREES_H) || !defined(STDC)
-/* non ANSI compilers may not accept trees.h */
-
-local ct_data static_ltree[L_CODES+2];
-/* The static literal tree. Since the bit lengths are imposed, there is no
- * need for the L_CODES extra codes used during heap construction. However
- * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
- * below).
- */
-
-local ct_data static_dtree[D_CODES];
-/* The static distance tree. (Actually a trivial tree since all codes use
- * 5 bits.)
- */
-
-uch _dist_code[DIST_CODE_LEN];
-/* Distance codes. The first 256 values correspond to the distances
- * 3 .. 258, the last 256 values correspond to the top 8 bits of
- * the 15 bit distances.
- */
-
-uch _length_code[MAX_MATCH-MIN_MATCH+1];
-/* length code for each normalized match length (0 == MIN_MATCH) */
-
-local int base_length[LENGTH_CODES];
-/* First normalized length for each code (0 = MIN_MATCH) */
-
-local int base_dist[D_CODES];
-/* First normalized distance for each code (0 = distance of 1) */
-
-#else
-#  include "trees.h"
-#endif /* GEN_TREES_H */
-
-struct static_tree_desc_s {
-    const ct_data *static_tree;  /* static tree or NULL */
-    const intf *extra_bits;      /* extra bits for each code or NULL */
-    int     extra_base;          /* base index for extra_bits */
-    int     elems;               /* max number of elements in the tree */
-    int     max_length;          /* max bit length for the codes */
-};
-
-local static_tree_desc  static_l_desc =
-{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
-
-local static_tree_desc  static_d_desc =
-{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
-
-local static_tree_desc  static_bl_desc =
-{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
-
-/* ===========================================================================
- * Local (static) routines in this file.
- */
-
-local void tr_static_init OF((void));
-local void init_block     OF((deflate_state *s));
-local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
-local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
-local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
-local void build_tree     OF((deflate_state *s, tree_desc *desc));
-local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
-local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
-local int  build_bl_tree  OF((deflate_state *s));
-local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
-                              int blcodes));
-local void compress_block OF((deflate_state *s, ct_data *ltree,
-                              ct_data *dtree));
-local void set_data_type  OF((deflate_state *s));
-local unsigned bi_reverse OF((unsigned value, int length));
-local void bi_windup      OF((deflate_state *s));
-local void bi_flush       OF((deflate_state *s));
-local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
-                              int header));
-
-#ifdef GEN_TREES_H
-local void gen_trees_header OF((void));
-#endif
-
-#ifndef DEBUG
-#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
-   /* Send a code of the given tree. c and tree must not have side effects */
-
-#else /* DEBUG */
-#  define send_code(s, c, tree) \
-     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
-       send_bits(s, tree[c].Code, tree[c].Len); }
-#endif
-
-/* ===========================================================================
- * Output a short LSB first on the stream.
- * IN assertion: there is enough room in pendingBuf.
- */
-#define put_short(s, w) { \
-    put_byte(s, (uch)((w) & 0xff)); \
-    put_byte(s, (uch)((ush)(w) >> 8)); \
-}
-
-/* ===========================================================================
- * Send a value on a given number of bits.
- * IN assertion: length <= 16 and value fits in length bits.
- */
-#ifdef DEBUG
-local void send_bits      OF((deflate_state *s, int value, int length));
-
-local void send_bits(s, value, length)
-    deflate_state *s;
-    int value;  /* value to send */
-    int length; /* number of bits */
-{
-    Tracevv((stderr," l %2d v %4x ", length, value));
-    Assert(length > 0 && length <= 15, "invalid length");
-    s->bits_sent += (ulg)length;
-
-    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
-     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
-     * unused bits in value.
-     */
-    if (s->bi_valid > (int)Buf_size - length) {
-        s->bi_buf |= (value << s->bi_valid);
-        put_short(s, s->bi_buf);
-        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
-        s->bi_valid += length - Buf_size;
-    } else {
-        s->bi_buf |= value << s->bi_valid;
-        s->bi_valid += length;
-    }
-}
-#else /* !DEBUG */
-
-#define send_bits(s, value, length) \
-{ int len = length;\
-  if (s->bi_valid > (int)Buf_size - len) {\
-    int val = value;\
-    s->bi_buf |= (val << s->bi_valid);\
-    put_short(s, s->bi_buf);\
-    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
-    s->bi_valid += len - Buf_size;\
-  } else {\
-    s->bi_buf |= (value) << s->bi_valid;\
-    s->bi_valid += len;\
-  }\
-}
-#endif /* DEBUG */
-
-
-/* the arguments must not have side effects */
-
-/* ===========================================================================
- * Initialize the various 'constant' tables.
- */
-local void tr_static_init()
-{
-#if defined(GEN_TREES_H) || !defined(STDC)
-    static int static_init_done = 0;
-    int n;        /* iterates over tree elements */
-    int bits;     /* bit counter */
-    int length;   /* length value */
-    int code;     /* code value */
-    int dist;     /* distance index */
-    ush bl_count[MAX_BITS+1];
-    /* number of codes at each bit length for an optimal tree */
-
-    if (static_init_done) return;
-
-    /* For some embedded targets, global variables are not initialized: */
-    static_l_desc.static_tree = static_ltree;
-    static_l_desc.extra_bits = extra_lbits;
-    static_d_desc.static_tree = static_dtree;
-    static_d_desc.extra_bits = extra_dbits;
-    static_bl_desc.extra_bits = extra_blbits;
-
-    /* Initialize the mapping length (0..255) -> length code (0..28) */
-    length = 0;
-    for (code = 0; code < LENGTH_CODES-1; code++) {
-        base_length[code] = length;
-        for (n = 0; n < (1<<extra_lbits[code]); n++) {
-            _length_code[length++] = (uch)code;
-        }
-    }
-    Assert (length == 256, "tr_static_init: length != 256");
-    /* Note that the length 255 (match length 258) can be represented
-     * in two different ways: code 284 + 5 bits or code 285, so we
-     * overwrite length_code[255] to use the best encoding:
-     */
-    _length_code[length-1] = (uch)code;
-
-    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
-    dist = 0;
-    for (code = 0 ; code < 16; code++) {
-        base_dist[code] = dist;
-        for (n = 0; n < (1<<extra_dbits[code]); n++) {
-            _dist_code[dist++] = (uch)code;
-        }
-    }
-    Assert (dist == 256, "tr_static_init: dist != 256");
-    dist >>= 7; /* from now on, all distances are divided by 128 */
-    for ( ; code < D_CODES; code++) {
-        base_dist[code] = dist << 7;
-        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
-            _dist_code[256 + dist++] = (uch)code;
-        }
-    }
-    Assert (dist == 256, "tr_static_init: 256+dist != 512");
-
-    /* Construct the codes of the static literal tree */
-    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
-    n = 0;
-    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
-    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
-    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
-    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
-    /* Codes 286 and 287 do not exist, but we must include them in the
-     * tree construction to get a canonical Huffman tree (longest code
-     * all ones)
-     */
-    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
-
-    /* The static distance tree is trivial: */
-    for (n = 0; n < D_CODES; n++) {
-        static_dtree[n].Len = 5;
-        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
-    }
-    static_init_done = 1;
-
-#  ifdef GEN_TREES_H
-    gen_trees_header();
-#  endif
-#endif /* defined(GEN_TREES_H) || !defined(STDC) */
-}
-
-/* ===========================================================================
- * Genererate the file trees.h describing the static trees.
- */
-#ifdef GEN_TREES_H
-#  ifndef DEBUG
-#    include <stdio.h>
-#  endif
-
-#  define SEPARATOR(i, last, width) \
-      ((i) == (last)? "\n};\n\n" :    \
-       ((i) % (width) == (width)-1 ? ",\n" : ", "))
-
-void gen_trees_header()
-{
-    FILE *header = fopen("trees.h", "w");
-    int i;
-
-    Assert (header != NULL, "Can't open trees.h");
-    fprintf(header,
-            "/* header created automatically with -DGEN_TREES_H */\n\n");
-
-    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
-    for (i = 0; i < L_CODES+2; i++) {
-        fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
-                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
-    }
-
-    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
-    for (i = 0; i < D_CODES; i++) {
-        fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
-                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
-    }
-
-    fprintf(header, "const uch _dist_code[DIST_CODE_LEN] = {\n");
-    for (i = 0; i < DIST_CODE_LEN; i++) {
-        fprintf(header, "%2u%s", _dist_code[i],
-                SEPARATOR(i, DIST_CODE_LEN-1, 20));
-    }
-
-    fprintf(header, "const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
-    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
-        fprintf(header, "%2u%s", _length_code[i],
-                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
-    }
-
-    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
-    for (i = 0; i < LENGTH_CODES; i++) {
-        fprintf(header, "%1u%s", base_length[i],
-                SEPARATOR(i, LENGTH_CODES-1, 20));
-    }
-
-    fprintf(header, "local const int base_dist[D_CODES] = {\n");
-    for (i = 0; i < D_CODES; i++) {
-        fprintf(header, "%5u%s", base_dist[i],
-                SEPARATOR(i, D_CODES-1, 10));
-    }
-
-    fclose(header);
-}
-#endif /* GEN_TREES_H */
-
-/* ===========================================================================
- * Initialize the tree data structures for a new zlib stream.
- */
-void _tr_init(s)
-    deflate_state *s;
-{
-    tr_static_init();
-
-    s->l_desc.dyn_tree = s->dyn_ltree;
-    s->l_desc.stat_desc = &static_l_desc;
-
-    s->d_desc.dyn_tree = s->dyn_dtree;
-    s->d_desc.stat_desc = &static_d_desc;
-
-    s->bl_desc.dyn_tree = s->bl_tree;
-    s->bl_desc.stat_desc = &static_bl_desc;
-
-    s->bi_buf = 0;
-    s->bi_valid = 0;
-    s->last_eob_len = 8; /* enough lookahead for inflate */
-#ifdef DEBUG
-    s->compressed_len = 0L;
-    s->bits_sent = 0L;
-#endif
-
-    /* Initialize the first block of the first file: */
-    init_block(s);
-}
-
-/* ===========================================================================
- * Initialize a new block.
- */
-local void init_block(s)
-    deflate_state *s;
-{
-    int n; /* iterates over tree elements */
-
-    /* Initialize the trees. */
-    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
-    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
-    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
-
-    s->dyn_ltree[END_BLOCK].Freq = 1;
-    s->opt_len = s->static_len = 0L;
-    s->last_lit = s->matches = 0;
-}
-
-#define SMALLEST 1
-/* Index within the heap array of least frequent node in the Huffman tree */
-
-
-/* ===========================================================================
- * Remove the smallest element from the heap and recreate the heap with
- * one less element. Updates heap and heap_len.
- */
-#define pqremove(s, tree, top) \
-{\
-    top = s->heap[SMALLEST]; \
-    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
-    pqdownheap(s, tree, SMALLEST); \
-}
-
-/* ===========================================================================
- * Compares to subtrees, using the tree depth as tie breaker when
- * the subtrees have equal frequency. This minimizes the worst case length.
- */
-#define smaller(tree, n, m, depth) \
-   (tree[n].Freq < tree[m].Freq || \
-   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
-
-/* ===========================================================================
- * Restore the heap property by moving down the tree starting at node k,
- * exchanging a node with the smallest of its two sons if necessary, stopping
- * when the heap property is re-established (each father smaller than its
- * two sons).
- */
-local void pqdownheap(s, tree, k)
-    deflate_state *s;
-    ct_data *tree;  /* the tree to restore */
-    int k;               /* node to move down */
-{
-    int v = s->heap[k];
-    int j = k << 1;  /* left son of k */
-    while (j <= s->heap_len) {
-        /* Set j to the smallest of the two sons: */
-        if (j < s->heap_len &&
-            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
-            j++;
-        }
-        /* Exit if v is smaller than both sons */
-        if (smaller(tree, v, s->heap[j], s->depth)) break;
-
-        /* Exchange v with the smallest son */
-        s->heap[k] = s->heap[j];  k = j;
-
-        /* And continue down the tree, setting j to the left son of k */
-        j <<= 1;
-    }
-    s->heap[k] = v;
-}
-
-/* ===========================================================================
- * Compute the optimal bit lengths for a tree and update the total bit length
- * for the current block.
- * IN assertion: the fields freq and dad are set, heap[heap_max] and
- *    above are the tree nodes sorted by increasing frequency.
- * OUT assertions: the field len is set to the optimal bit length, the
- *     array bl_count contains the frequencies for each bit length.
- *     The length opt_len is updated; static_len is also updated if stree is
- *     not null.
- */
-local void gen_bitlen(s, desc)
-    deflate_state *s;
-    tree_desc *desc;    /* the tree descriptor */
-{
-    ct_data *tree        = desc->dyn_tree;
-    int max_code         = desc->max_code;
-    const ct_data *stree = desc->stat_desc->static_tree;
-    const intf *extra    = desc->stat_desc->extra_bits;
-    int base             = desc->stat_desc->extra_base;
-    int max_length       = desc->stat_desc->max_length;
-    int h;              /* heap index */
-    int n, m;           /* iterate over the tree elements */
-    int bits;           /* bit length */
-    int xbits;          /* extra bits */
-    ush f;              /* frequency */
-    int overflow = 0;   /* number of elements with bit length too large */
-
-    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
-
-    /* In a first pass, compute the optimal bit lengths (which may
-     * overflow in the case of the bit length tree).
-     */
-    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
-
-    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
-        n = s->heap[h];
-        bits = tree[tree[n].Dad].Len + 1;
-        if (bits > max_length) bits = max_length, overflow++;
-        tree[n].Len = (ush)bits;
-        /* We overwrite tree[n].Dad which is no longer needed */
-
-        if (n > max_code) continue; /* not a leaf node */
-
-        s->bl_count[bits]++;
-        xbits = 0;
-        if (n >= base) xbits = extra[n-base];
-        f = tree[n].Freq;
-        s->opt_len += (ulg)f * (bits + xbits);
-        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
-    }
-    if (overflow == 0) return;
-
-    Trace((stderr,"\nbit length overflow\n"));
-    /* This happens for example on obj2 and pic of the Calgary corpus */
-
-    /* Find the first bit length which could increase: */
-    do {
-        bits = max_length-1;
-        while (s->bl_count[bits] == 0) bits--;
-        s->bl_count[bits]--;      /* move one leaf down the tree */
-        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
-        s->bl_count[max_length]--;
-        /* The brother of the overflow item also moves one step up,
-         * but this does not affect bl_count[max_length]
-         */
-        overflow -= 2;
-    } while (overflow > 0);
-
-    /* Now recompute all bit lengths, scanning in increasing frequency.
-     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
-     * lengths instead of fixing only the wrong ones. This idea is taken
-     * from 'ar' written by Haruhiko Okumura.)
-     */
-    for (bits = max_length; bits != 0; bits--) {
-        n = s->bl_count[bits];
-        while (n != 0) {
-            m = s->heap[--h];
-            if (m > max_code) continue;
-            if ((unsigned) tree[m].Len != (unsigned) bits) {
-                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
-                s->opt_len += ((long)bits - (long)tree[m].Len)
-                              *(long)tree[m].Freq;
-                tree[m].Len = (ush)bits;
-            }
-            n--;
-        }
-    }
-}
-
-/* ===========================================================================
- * Generate the codes for a given tree and bit counts (which need not be
- * optimal).
- * IN assertion: the array bl_count contains the bit length statistics for
- * the given tree and the field len is set for all tree elements.
- * OUT assertion: the field code is set for all tree elements of non
- *     zero code length.
- */
-local void gen_codes (tree, max_code, bl_count)
-    ct_data *tree;             /* the tree to decorate */
-    int max_code;              /* largest code with non zero frequency */
-    ushf *bl_count;            /* number of codes at each bit length */
-{
-    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
-    ush code = 0;              /* running code value */
-    int bits;                  /* bit index */
-    int n;                     /* code index */
-
-    /* The distribution counts are first used to generate the code values
-     * without bit reversal.
-     */
-    for (bits = 1; bits <= MAX_BITS; bits++) {
-        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
-    }
-    /* Check that the bit counts in bl_count are consistent. The last code
-     * must be all ones.
-     */
-    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
-            "inconsistent bit counts");
-    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
-
-    for (n = 0;  n <= max_code; n++) {
-        int len = tree[n].Len;
-        if (len == 0) continue;
-        /* Now reverse the bits */
-        tree[n].Code = bi_reverse(next_code[len]++, len);
-
-        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
-             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
-    }
-}
-
-/* ===========================================================================
- * Construct one Huffman tree and assigns the code bit strings and lengths.
- * Update the total bit length for the current block.
- * IN assertion: the field freq is set for all tree elements.
- * OUT assertions: the fields len and code are set to the optimal bit length
- *     and corresponding code. The length opt_len is updated; static_len is
- *     also updated if stree is not null. The field max_code is set.
- */
-local void build_tree(s, desc)
-    deflate_state *s;
-    tree_desc *desc; /* the tree descriptor */
-{
-    ct_data *tree         = desc->dyn_tree;
-    const ct_data *stree  = desc->stat_desc->static_tree;
-    int elems             = desc->stat_desc->elems;
-    int n, m;          /* iterate over heap elements */
-    int max_code = -1; /* largest code with non zero frequency */
-    int node;          /* new node being created */
-
-    /* Construct the initial heap, with least frequent element in
-     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
-     * heap[0] is not used.
-     */
-    s->heap_len = 0, s->heap_max = HEAP_SIZE;
-
-    for (n = 0; n < elems; n++) {
-        if (tree[n].Freq != 0) {
-            s->heap[++(s->heap_len)] = max_code = n;
-            s->depth[n] = 0;
-        } else {
-            tree[n].Len = 0;
-        }
-    }
-
-    /* The pkzip format requires that at least one distance code exists,
-     * and that at least one bit should be sent even if there is only one
-     * possible code. So to avoid special checks later on we force at least
-     * two codes of non zero frequency.
-     */
-    while (s->heap_len < 2) {
-        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
-        tree[node].Freq = 1;
-        s->depth[node] = 0;
-        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
-        /* node is 0 or 1 so it does not have extra bits */
-    }
-    desc->max_code = max_code;
-
-    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
-     * establish sub-heaps of increasing lengths:
-     */
-    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
-
-    /* Construct the Huffman tree by repeatedly combining the least two
-     * frequent nodes.
-     */
-    node = elems;              /* next internal node of the tree */
-    do {
-        pqremove(s, tree, n);  /* n = node of least frequency */
-        m = s->heap[SMALLEST]; /* m = node of next least frequency */
-
-        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
-        s->heap[--(s->heap_max)] = m;
-
-        /* Create a new node father of n and m */
-        tree[node].Freq = tree[n].Freq + tree[m].Freq;
-        s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
-                                s->depth[n] : s->depth[m]) + 1);
-        tree[n].Dad = tree[m].Dad = (ush)node;
-#ifdef DUMP_BL_TREE
-        if (tree == s->bl_tree) {
-            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
-                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
-        }
-#endif
-        /* and insert the new node in the heap */
-        s->heap[SMALLEST] = node++;
-        pqdownheap(s, tree, SMALLEST);
-
-    } while (s->heap_len >= 2);
-
-    s->heap[--(s->heap_max)] = s->heap[SMALLEST];
-
-    /* At this point, the fields freq and dad are set. We can now
-     * generate the bit lengths.
-     */
-    gen_bitlen(s, (tree_desc *)desc);
-
-    /* The field len is now set, we can generate the bit codes */
-    gen_codes ((ct_data *)tree, max_code, s->bl_count);
-}
-
-/* ===========================================================================
- * Scan a literal or distance tree to determine the frequencies of the codes
- * in the bit length tree.
- */
-local void scan_tree (s, tree, max_code)
-    deflate_state *s;
-    ct_data *tree;   /* the tree to be scanned */
-    int max_code;    /* and its largest code of non zero frequency */
-{
-    int n;                     /* iterates over all tree elements */
-    int prevlen = -1;          /* last emitted length */
-    int curlen;                /* length of current code */
-    int nextlen = tree[0].Len; /* length of next code */
-    int count = 0;             /* repeat count of the current code */
-    int max_count = 7;         /* max repeat count */
-    int min_count = 4;         /* min repeat count */
-
-    if (nextlen == 0) max_count = 138, min_count = 3;
-    tree[max_code+1].Len = (ush)0xffff; /* guard */
-
-    for (n = 0; n <= max_code; n++) {
-        curlen = nextlen; nextlen = tree[n+1].Len;
-        if (++count < max_count && curlen == nextlen) {
-            continue;
-        } else if (count < min_count) {
-            s->bl_tree[curlen].Freq += count;
-        } else if (curlen != 0) {
-            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
-            s->bl_tree[REP_3_6].Freq++;
-        } else if (count <= 10) {
-            s->bl_tree[REPZ_3_10].Freq++;
-        } else {
-            s->bl_tree[REPZ_11_138].Freq++;
-        }
-        count = 0; prevlen = curlen;
-        if (nextlen == 0) {
-            max_count = 138, min_count = 3;
-        } else if (curlen == nextlen) {
-            max_count = 6, min_count = 3;
-        } else {
-            max_count = 7, min_count = 4;
-        }
-    }
-}
-
-/* ===========================================================================
- * Send a literal or distance tree in compressed form, using the codes in
- * bl_tree.
- */
-local void send_tree (s, tree, max_code)
-    deflate_state *s;
-    ct_data *tree; /* the tree to be scanned */
-    int max_code;       /* and its largest code of non zero frequency */
-{
-    int n;                     /* iterates over all tree elements */
-    int prevlen = -1;          /* last emitted length */
-    int curlen;                /* length of current code */
-    int nextlen = tree[0].Len; /* length of next code */
-    int count = 0;             /* repeat count of the current code */
-    int max_count = 7;         /* max repeat count */
-    int min_count = 4;         /* min repeat count */
-
-    /* tree[max_code+1].Len = -1; */  /* guard already set */
-    if (nextlen == 0) max_count = 138, min_count = 3;
-
-    for (n = 0; n <= max_code; n++) {
-        curlen = nextlen; nextlen = tree[n+1].Len;
-        if (++count < max_count && curlen == nextlen) {
-            continue;
-        } else if (count < min_count) {
-            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
-
-        } else if (curlen != 0) {
-            if (curlen != prevlen) {
-                send_code(s, curlen, s->bl_tree); count--;
-            }
-            Assert(count >= 3 && count <= 6, " 3_6?");
-            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);
-
-        } else if (count <= 10) {
-            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);
-
-        } else {
-            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
-        }
-        count = 0; prevlen = curlen;
-        if (nextlen == 0) {
-            max_count = 138, min_count = 3;
-        } else if (curlen == nextlen) {
-            max_count = 6, min_count = 3;
-        } else {
-            max_count = 7, min_count = 4;
-        }
-    }
-}
-
-/* ===========================================================================
- * Construct the Huffman tree for the bit lengths and return the index in
- * bl_order of the last bit length code to send.
- */
-local int build_bl_tree(s)
-    deflate_state *s;
-{
-    int max_blindex;  /* index of last bit length code of non zero freq */
-
-    /* Determine the bit length frequencies for literal and distance trees */
-    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
-    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
-
-    /* Build the bit length tree: */
-    build_tree(s, (tree_desc *)(&(s->bl_desc)));
-    /* opt_len now includes the length of the tree representations, except
-     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
-     */
-
-    /* Determine the number of bit length codes to send. The pkzip format
-     * requires that at least 4 bit length codes be sent. (appnote.txt says
-     * 3 but the actual value used is 4.)
-     */
-    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
-        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
-    }
-    /* Update opt_len to include the bit length tree and counts */
-    s->opt_len += 3*(max_blindex+1) + 5+5+4;
-    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
-            s->opt_len, s->static_len));
-
-    return max_blindex;
-}
-
-/* ===========================================================================
- * Send the header for a block using dynamic Huffman trees: the counts, the
- * lengths of the bit length codes, the literal tree and the distance tree.
- * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
- */
-local void send_all_trees(s, lcodes, dcodes, blcodes)
-    deflate_state *s;
-    int lcodes, dcodes, blcodes; /* number of codes for each tree */
-{
-    int rank;                    /* index in bl_order */
-
-    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
-    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
-            "too many codes");
-    Tracev((stderr, "\nbl counts: "));
-    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
-    send_bits(s, dcodes-1,   5);
-    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
-    for (rank = 0; rank < blcodes; rank++) {
-        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
-        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
-    }
-    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
-
-    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
-    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
-
-    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
-    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
-}
-
-/* ===========================================================================
- * Send a stored block
- */
-void _tr_stored_block(s, buf, stored_len, eof)
-    deflate_state *s;
-    charf *buf;       /* input block */
-    ulg stored_len;   /* length of input block */
-    int eof;          /* true if this is the last block for a file */
-{
-    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
-#ifdef DEBUG
-    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
-    s->compressed_len += (stored_len + 4) << 3;
-#endif
-    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
-}
-
-/* ===========================================================================
- * Send one empty static block to give enough lookahead for inflate.
- * This takes 10 bits, of which 7 may remain in the bit buffer.
- * The current inflate code requires 9 bits of lookahead. If the
- * last two codes for the previous block (real code plus EOB) were coded
- * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
- * the last real code. In this case we send two empty static blocks instead
- * of one. (There are no problems if the previous block is stored or fixed.)
- * To simplify the code, we assume the worst case of last real code encoded
- * on one bit only.
- */
-void _tr_align(s)
-    deflate_state *s;
-{
-    send_bits(s, STATIC_TREES<<1, 3);
-    send_code(s, END_BLOCK, static_ltree);
-#ifdef DEBUG
-    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
-#endif
-    bi_flush(s);
-    /* Of the 10 bits for the empty block, we have already sent
-     * (10 - bi_valid) bits. The lookahead for the last real code (before
-     * the EOB of the previous block) was thus at least one plus the length
-     * of the EOB plus what we have just sent of the empty static block.
-     */
-    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
-        send_bits(s, STATIC_TREES<<1, 3);
-        send_code(s, END_BLOCK, static_ltree);
-#ifdef DEBUG
-        s->compressed_len += 10L;
-#endif
-        bi_flush(s);
-    }
-    s->last_eob_len = 7;
-}
-
-/* ===========================================================================
- * Determine the best encoding for the current block: dynamic trees, static
- * trees or store, and output the encoded block to the zip file.
- */
-void _tr_flush_block(s, buf, stored_len, eof)
-    deflate_state *s;
-    charf *buf;       /* input block, or NULL if too old */
-    ulg stored_len;   /* length of input block */
-    int eof;          /* true if this is the last block for a file */
-{
-    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
-    int max_blindex = 0;  /* index of last bit length code of non zero freq */
-
-    /* Build the Huffman trees unless a stored block is forced */
-    if (s->level > 0) {
-
-        /* Check if the file is binary or text */
-        if (stored_len > 0 && s->strm->data_type == Z_UNKNOWN)
-            set_data_type(s);
-
-        /* Construct the literal and distance trees */
-        build_tree(s, (tree_desc *)(&(s->l_desc)));
-        Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
-                s->static_len));
-
-        build_tree(s, (tree_desc *)(&(s->d_desc)));
-        Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
-                s->static_len));
-        /* At this point, opt_len and static_len are the total bit lengths of
-         * the compressed block data, excluding the tree representations.
-         */
-
-        /* Build the bit length tree for the above two trees, and get the index
-         * in bl_order of the last bit length code to send.
-         */
-        max_blindex = build_bl_tree(s);
-
-        /* Determine the best encoding. Compute the block lengths in bytes. */
-        opt_lenb = (s->opt_len+3+7)>>3;
-        static_lenb = (s->static_len+3+7)>>3;
-
-        Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
-                opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
-                s->last_lit));
-
-        if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
-
-    } else {
-        Assert(buf != (char*)0, "lost buf");
-        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
-    }
-
-#ifdef FORCE_STORED
-    if (buf != (char*)0) { /* force stored block */
-#else
-    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
-                       /* 4: two words for the lengths */
-#endif
-        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
-         * Otherwise we can't have processed more than WSIZE input bytes since
-         * the last block flush, because compression would have been
-         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
-         * transform a block into a stored block.
-         */
-        _tr_stored_block(s, buf, stored_len, eof);
-
-#ifdef FORCE_STATIC
-    } else if (static_lenb >= 0) { /* force static trees */
-#else
-    } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {
-#endif
-        send_bits(s, (STATIC_TREES<<1)+eof, 3);
-        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
-#ifdef DEBUG
-        s->compressed_len += 3 + s->static_len;
-#endif
-    } else {
-        send_bits(s, (DYN_TREES<<1)+eof, 3);
-        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
-                       max_blindex+1);
-        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
-#ifdef DEBUG
-        s->compressed_len += 3 + s->opt_len;
-#endif
-    }
-    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
-    /* The above check is made mod 2^32, for files larger than 512 MB
-     * and uLong implemented on 32 bits.
-     */
-    init_block(s);
-
-    if (eof) {
-        bi_windup(s);
-#ifdef DEBUG
-        s->compressed_len += 7;  /* align on byte boundary */
-#endif
-    }
-    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
-           s->compressed_len-7*eof));
-}
-
-/* ===========================================================================
- * Save the match info and tally the frequency counts. Return true if
- * the current block must be flushed.
- */
-int _tr_tally (s, dist, lc)
-    deflate_state *s;
-    unsigned dist;  /* distance of matched string */
-    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
-{
-    s->d_buf[s->last_lit] = (ush)dist;
-    s->l_buf[s->last_lit++] = (uch)lc;
-    if (dist == 0) {
-        /* lc is the unmatched char */
-        s->dyn_ltree[lc].Freq++;
-    } else {
-        s->matches++;
-        /* Here, lc is the match length - MIN_MATCH */
-        dist--;             /* dist = match distance - 1 */
-        Assert((ush)dist < (ush)MAX_DIST(s) &&
-               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
-               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
-
-        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
-        s->dyn_dtree[d_code(dist)].Freq++;
-    }
-
-#ifdef TRUNCATE_BLOCK
-    /* Try to guess if it is profitable to stop the current block here */
-    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
-        /* Compute an upper bound for the compressed length */
-        ulg out_length = (ulg)s->last_lit*8L;
-        ulg in_length = (ulg)((long)s->strstart - s->block_start);
-        int dcode;
-        for (dcode = 0; dcode < D_CODES; dcode++) {
-            out_length += (ulg)s->dyn_dtree[dcode].Freq *
-                (5L+extra_dbits[dcode]);
-        }
-        out_length >>= 3;
-        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
-               s->last_lit, in_length, out_length,
-               100L - out_length*100L/in_length));
-        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
-    }
-#endif
-    return (s->last_lit == s->lit_bufsize-1);
-    /* We avoid equality with lit_bufsize because of wraparound at 64K
-     * on 16 bit machines and because stored blocks are restricted to
-     * 64K-1 bytes.
-     */
-}
-
-/* ===========================================================================
- * Send the block data compressed using the given Huffman trees
- */
-local void compress_block(s, ltree, dtree)
-    deflate_state *s;
-    ct_data *ltree; /* literal tree */
-    ct_data *dtree; /* distance tree */
-{
-    unsigned dist;      /* distance of matched string */
-    int lc;             /* match length or unmatched char (if dist == 0) */
-    unsigned lx = 0;    /* running index in l_buf */
-    unsigned code;      /* the code to send */
-    int extra;          /* number of extra bits to send */
-
-    if (s->last_lit != 0) do {
-        dist = s->d_buf[lx];
-        lc = s->l_buf[lx++];
-        if (dist == 0) {
-            send_code(s, lc, ltree); /* send a literal byte */
-            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
-        } else {
-            /* Here, lc is the match length - MIN_MATCH */
-            code = _length_code[lc];
-            send_code(s, code+LITERALS+1, ltree); /* send the length code */
-            extra = extra_lbits[code];
-            if (extra != 0) {
-                lc -= base_length[code];
-                send_bits(s, lc, extra);       /* send the extra length bits */
-            }
-            dist--; /* dist is now the match distance - 1 */
-            code = d_code(dist);
-            Assert (code < D_CODES, "bad d_code");
-
-            send_code(s, code, dtree);       /* send the distance code */
-            extra = extra_dbits[code];
-            if (extra != 0) {
-                dist -= base_dist[code];
-                send_bits(s, dist, extra);   /* send the extra distance bits */
-            }
-        } /* literal or match pair ? */
-
-        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
-        Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
-               "pendingBuf overflow");
-
-    } while (lx < s->last_lit);
-
-    send_code(s, END_BLOCK, ltree);
-    s->last_eob_len = ltree[END_BLOCK].Len;
-}
-
-/* ===========================================================================
- * Set the data type to BINARY or TEXT, using a crude approximation:
- * set it to Z_TEXT if all symbols are either printable characters (33 to 255)
- * or white spaces (9 to 13, or 32); or set it to Z_BINARY otherwise.
- * IN assertion: the fields Freq of dyn_ltree are set.
- */
-local void set_data_type(s)
-    deflate_state *s;
-{
-    int n;
-
-    for (n = 0; n < 9; n++)
-        if (s->dyn_ltree[n].Freq != 0)
-            break;
-    if (n == 9)
-        for (n = 14; n < 32; n++)
-            if (s->dyn_ltree[n].Freq != 0)
-                break;
-    s->strm->data_type = (n == 32) ? Z_TEXT : Z_BINARY;
-}
-
-/* ===========================================================================
- * Reverse the first len bits of a code, using straightforward code (a faster
- * method would use a table)
- * IN assertion: 1 <= len <= 15
- */
-local unsigned bi_reverse(code, len)
-    unsigned code; /* the value to invert */
-    int len;       /* its bit length */
-{
-    register unsigned res = 0;
-    do {
-        res |= code & 1;
-        code >>= 1, res <<= 1;
-    } while (--len > 0);
-    return res >> 1;
-}
-
-/* ===========================================================================
- * Flush the bit buffer, keeping at most 7 bits in it.
- */
-local void bi_flush(s)
-    deflate_state *s;
-{
-    if (s->bi_valid == 16) {
-        put_short(s, s->bi_buf);
-        s->bi_buf = 0;
-        s->bi_valid = 0;
-    } else if (s->bi_valid >= 8) {
-        put_byte(s, (Byte)s->bi_buf);
-        s->bi_buf >>= 8;
-        s->bi_valid -= 8;
-    }
-}
-
-/* ===========================================================================
- * Flush the bit buffer and align the output on a byte boundary
- */
-local void bi_windup(s)
-    deflate_state *s;
-{
-    if (s->bi_valid > 8) {
-        put_short(s, s->bi_buf);
-    } else if (s->bi_valid > 0) {
-        put_byte(s, (Byte)s->bi_buf);
-    }
-    s->bi_buf = 0;
-    s->bi_valid = 0;
-#ifdef DEBUG
-    s->bits_sent = (s->bits_sent+7) & ~7;
-#endif
-}
-
-/* ===========================================================================
- * Copy a stored block, storing first the length and its
- * one's complement if requested.
- */
-local void copy_block(s, buf, len, header)
-    deflate_state *s;
-    charf    *buf;    /* the input data */
-    unsigned len;     /* its length */
-    int      header;  /* true if block header must be written */
-{
-    bi_windup(s);        /* align on byte boundary */
-    s->last_eob_len = 8; /* enough lookahead for inflate */
-
-    if (header) {
-        put_short(s, (ush)len);
-        put_short(s, (ush)~len);
-#ifdef DEBUG
-        s->bits_sent += 2*16;
-#endif
-    }
-#ifdef DEBUG
-    s->bits_sent += (ulg)len<<3;
-#endif
-    while (len--) {
-        put_byte(s, *buf++);
-    }
-}
diff -Nbaur gcc-4.6.3/zlib/trees.h gcc-4.6.3-psp/zlib/trees.h
--- gcc-4.6.3/zlib/trees.h	2005-09-12 18:02:07.000000000 +0100
+++ gcc-4.6.3-psp/zlib/trees.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,128 +0,0 @@
-/* header created automatically with -DGEN_TREES_H */
-
-local const ct_data static_ltree[L_CODES+2] = {
-{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
-{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
-{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
-{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
-{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
-{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
-{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
-{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
-{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
-{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
-{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
-{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
-{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
-{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
-{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
-{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
-{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
-{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
-{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
-{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
-{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
-{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
-{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
-{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
-{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
-{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
-{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
-{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
-{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
-{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
-{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
-{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
-{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
-{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
-{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
-{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
-{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
-{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
-{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
-{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
-{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
-{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
-{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
-{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
-{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
-{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
-{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
-{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
-{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
-{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
-{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
-{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
-{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
-{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
-{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
-{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
-{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
-{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
-};
-
-local const ct_data static_dtree[D_CODES] = {
-{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
-{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
-{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
-{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
-{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
-{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
-};
-
-const uch _dist_code[DIST_CODE_LEN] = {
- 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
- 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
-10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
-11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
-12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
-13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
-15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
-18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
-23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
-28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
-29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
-};
-
-const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {
- 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
-13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
-17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
-19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
-21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
-22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
-23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
-25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
-25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
-};
-
-local const int base_length[LENGTH_CODES] = {
-0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
-64, 80, 96, 112, 128, 160, 192, 224, 0
-};
-
-local const int base_dist[D_CODES] = {
-    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
-   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
- 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
-};
-
diff -Nbaur gcc-4.6.3/zlib/uncompr.c gcc-4.6.3-psp/zlib/uncompr.c
--- gcc-4.6.3/zlib/uncompr.c	2005-09-12 18:02:07.000000000 +0100
+++ gcc-4.6.3-psp/zlib/uncompr.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,61 +0,0 @@
-/* uncompr.c -- decompress a memory buffer
- * Copyright (C) 1995-2003 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id: uncompr.c,v 1.1.1.2 2002/03/11 21:53:27 tromey Exp $ */
-
-#define ZLIB_INTERNAL
-#include "zlib.h"
-
-/* ===========================================================================
-     Decompresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer. Upon entry, destLen is the total
-   size of the destination buffer, which must be large enough to hold the
-   entire uncompressed data. (The size of the uncompressed data must have
-   been saved previously by the compressor and transmitted to the decompressor
-   by some mechanism outside the scope of this compression library.)
-   Upon exit, destLen is the actual size of the compressed buffer.
-     This function can be used to decompress a whole file at once if the
-   input file is mmap'ed.
-
-     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer, or Z_DATA_ERROR if the input data was corrupted.
-*/
-int ZEXPORT uncompress (dest, destLen, source, sourceLen)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-{
-    z_stream stream;
-    int err;
-
-    stream.next_in = (Bytef*)source;
-    stream.avail_in = (uInt)sourceLen;
-    /* Check for source > 64K on 16-bit machine: */
-    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
-
-    stream.next_out = dest;
-    stream.avail_out = (uInt)*destLen;
-    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
-
-    stream.zalloc = (alloc_func)0;
-    stream.zfree = (free_func)0;
-
-    err = inflateInit(&stream);
-    if (err != Z_OK) return err;
-
-    err = inflate(&stream, Z_FINISH);
-    if (err != Z_STREAM_END) {
-        inflateEnd(&stream);
-        if (err == Z_NEED_DICT || (err == Z_BUF_ERROR && stream.avail_in == 0))
-            return Z_DATA_ERROR;
-        return err;
-    }
-    *destLen = stream.total_out;
-
-    err = inflateEnd(&stream);
-    return err;
-}
diff -Nbaur gcc-4.6.3/zlib/win32/DLL_FAQ.txt gcc-4.6.3-psp/zlib/win32/DLL_FAQ.txt
--- gcc-4.6.3/zlib/win32/DLL_FAQ.txt	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/win32/DLL_FAQ.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,397 +0,0 @@
-
-            Frequently Asked Questions about ZLIB1.DLL
-
-
-This document describes the design, the rationale, and the usage
-of the official DLL build of zlib, named ZLIB1.DLL.  If you have
-general questions about zlib, you should see the file "FAQ" found
-in the zlib distribution, or at the following location:
-  http://www.gzip.org/zlib/zlib_faq.html
-
-
- 1. What is ZLIB1.DLL, and how can I get it?
-
-  - ZLIB1.DLL is the official build of zlib as a DLL.
-    (Please remark the character '1' in the name.)
-
-    Pointers to a precompiled ZLIB1.DLL can be found in the zlib
-    web site at:
-      http://www.zlib.org/
-
-    Applications that link to ZLIB1.DLL can rely on the following
-    specification:
-
-    * The exported symbols are exclusively defined in the source
-      files "zlib.h" and "zlib.def", found in an official zlib
-      source distribution.
-    * The symbols are exported by name, not by ordinal.
-    * The exported names are undecorated.
-    * The calling convention of functions is "C" (CDECL).
-    * The ZLIB1.DLL binary is linked to MSVCRT.DLL.
-
-    The archive in which ZLIB1.DLL is bundled contains compiled
-    test programs that must run with a valid build of ZLIB1.DLL.
-    It is recommended to download the prebuilt DLL from the zlib
-    web site, instead of building it yourself, to avoid potential
-    incompatibilities that could be introduced by your compiler
-    and build settings.  If you do build the DLL yourself, please
-    make sure that it complies with all the above requirements,
-    and it runs with the precompiled test programs, bundled with
-    the original ZLIB1.DLL distribution.
-
-    If, for any reason, you need to build an incompatible DLL,
-    please use a different file name.
-
-
- 2. Why did you change the name of the DLL to ZLIB1.DLL?
-    What happened to the old ZLIB.DLL?
-
-  - The old ZLIB.DLL, built from zlib-1.1.4 or earlier, required
-    compilation settings that were incompatible to those used by
-    a static build.  The DLL settings were supposed to be enabled
-    by defining the macro ZLIB_DLL, before including "zlib.h".
-    Incorrect handling of this macro was silently accepted at
-    build time, resulting in two major problems:
-
-    * ZLIB_DLL was missing from the old makefile.  When building
-      the DLL, not all people added it to the build options.  In
-      consequence, incompatible incarnations of ZLIB.DLL started
-      to circulate around the net.
-
-    * When switching from using the static library to using the
-      DLL, applications had to define the ZLIB_DLL macro and
-      to recompile all the sources that contained calls to zlib
-      functions.  Failure to do so resulted in creating binaries
-      that were unable to run with the official ZLIB.DLL build.
-
-    The only possible solution that we could foresee was to make
-    a binary-incompatible change in the DLL interface, in order to
-    remove the dependency on the ZLIB_DLL macro, and to release
-    the new DLL under a different name.
-
-    We chose the name ZLIB1.DLL, where '1' indicates the major
-    zlib version number.  We hope that we will not have to break
-    the binary compatibility again, at least not as long as the
-    zlib-1.x series will last.
-
-    There is still a ZLIB_DLL macro, that can trigger a more
-    efficient build and use of the DLL, but compatibility no
-    longer dependents on it.
-
-
- 3. Can I build ZLIB.DLL from the new zlib sources, and replace
-    an old ZLIB.DLL, that was built from zlib-1.1.4 or earlier?
-
-  - In principle, you can do it by assigning calling convention
-    keywords to the macros ZEXPORT and ZEXPORTVA.  In practice,
-    it depends on what you mean by "an old ZLIB.DLL", because the
-    old DLL exists in several mutually-incompatible versions.
-    You have to find out first what kind of calling convention is
-    being used in your particular ZLIB.DLL build, and to use the
-    same one in the new build.  If you don't know what this is all
-    about, you might be better off if you would just leave the old
-    DLL intact.
-
-
- 4. Can I compile my application using the new zlib interface, and
-    link it to an old ZLIB.DLL, that was built from zlib-1.1.4 or
-    earlier?
-
-  - The official answer is "no"; the real answer depends again on
-    what kind of ZLIB.DLL you have.  Even if you are lucky, this
-    course of action is unreliable.
-
-    If you rebuild your application and you intend to use a newer
-    version of zlib (post- 1.1.4), it is strongly recommended to
-    link it to the new ZLIB1.DLL.
-
-
- 5. Why are the zlib symbols exported by name, and not by ordinal?
-
-  - Although exporting symbols by ordinal is a little faster, it
-    is risky.  Any single glitch in the maintenance or use of the
-    DEF file that contains the ordinals can result in incompatible
-    builds and frustrating crashes.  Simply put, the benefits of
-    exporting symbols by ordinal do not justify the risks.
-
-    Technically, it should be possible to maintain ordinals in
-    the DEF file, and still export the symbols by name.  Ordinals
-    exist in every DLL, and even if the dynamic linking performed
-    at the DLL startup is searching for names, ordinals serve as
-    hints, for a faster name lookup.  However, if the DEF file
-    contains ordinals, the Microsoft linker automatically builds
-    an implib that will cause the executables linked to it to use
-    those ordinals, and not the names.  It is interesting to
-    notice that the GNU linker for Win32 does not suffer from this
-    problem.
-
-    It is possible to avoid the DEF file if the exported symbols
-    are accompanied by a "__declspec(dllexport)" attribute in the
-    source files.  You can do this in zlib by predefining the
-    ZLIB_DLL macro.
-
-
- 6. I see that the ZLIB1.DLL functions use the "C" (CDECL) calling
-    convention.  Why not use the STDCALL convention?
-    STDCALL is the standard convention in Win32, and I need it in
-    my Visual Basic project!
-
-    (For readability, we use CDECL to refer to the convention
-     triggered by the "__cdecl" keyword, STDCALL to refer to
-     the convention triggered by "__stdcall", and FASTCALL to
-     refer to the convention triggered by "__fastcall".)
-
-  - Most of the native Windows API functions (without varargs) use
-    indeed the WINAPI convention (which translates to STDCALL in
-    Win32), but the standard C functions use CDECL.  If a user
-    application is intrinsically tied to the Windows API (e.g.
-    it calls native Windows API functions such as CreateFile()),
-    sometimes it makes sense to decorate its own functions with
-    WINAPI.  But if ANSI C or POSIX portability is a goal (e.g.
-    it calls standard C functions such as fopen()), it is not a
-    sound decision to request the inclusion of <windows.h>, or to
-    use non-ANSI constructs, for the sole purpose to make the user
-    functions STDCALL-able.
-
-    The functionality offered by zlib is not in the category of
-    "Windows functionality", but is more like "C functionality".
-
-    Technically, STDCALL is not bad; in fact, it is slightly
-    faster than CDECL, and it works with variable-argument
-    functions, just like CDECL.  It is unfortunate that, in spite
-    of using STDCALL in the Windows API, it is not the default
-    convention used by the C compilers that run under Windows.
-    The roots of the problem reside deep inside the unsafety of
-    the K&R-style function prototypes, where the argument types
-    are not specified; but that is another story for another day.
-
-    The remaining fact is that CDECL is the default convention.
-    Even if an explicit convention is hard-coded into the function
-    prototypes inside C headers, problems may appear.  The
-    necessity to expose the convention in users' callbacks is one
-    of these problems.
-
-    The calling convention issues are also important when using
-    zlib in other programming languages.  Some of them, like Ada
-    (GNAT) and Fortran (GNU G77), have C bindings implemented
-    initially on Unix, and relying on the C calling convention.
-    On the other hand, the pre- .NET versions of Microsoft Visual
-    Basic require STDCALL, while Borland Delphi prefers, although
-    it does not require, FASTCALL.
-
-    In fairness to all possible uses of zlib outside the C
-    programming language, we choose the default "C" convention.
-    Anyone interested in different bindings or conventions is
-    encouraged to maintain specialized projects.  The "contrib/"
-    directory from the zlib distribution already holds a couple
-    of foreign bindings, such as Ada, C++, and Delphi.
-
-
- 7. I need a DLL for my Visual Basic project.  What can I do?
-
-  - Define the ZLIB_WINAPI macro before including "zlib.h", when
-    building both the DLL and the user application (except that
-    you don't need to define anything when using the DLL in Visual
-    Basic).  The ZLIB_WINAPI macro will switch on the WINAPI
-    (STDCALL) convention.  The name of this DLL must be different
-    than the official ZLIB1.DLL.
-
-    Gilles Vollant has contributed a build named ZLIBWAPI.DLL,
-    with the ZLIB_WINAPI macro turned on, and with the minizip
-    functionality built in.  For more information, please read
-    the notes inside "contrib/vstudio/readme.txt", found in the
-    zlib distribution.
-
-
- 8. I need to use zlib in my Microsoft .NET project.  What can I
-    do?
-
-  - Henrik Ravn has contributed a .NET wrapper around zlib.  Look
-    into contrib/dotzlib/, inside the zlib distribution.
-
-
- 9. If my application uses ZLIB1.DLL, should I link it to
-    MSVCRT.DLL?  Why?
-
-  - It is not required, but it is recommended to link your
-    application to MSVCRT.DLL, if it uses ZLIB1.DLL.
-
-    The executables (.EXE, .DLL, etc.) that are involved in the
-    same process and are using the C run-time library (i.e. they
-    are calling standard C functions), must link to the same
-    library.  There are several libraries in the Win32 system:
-    CRTDLL.DLL, MSVCRT.DLL, the static C libraries, etc.
-    Since ZLIB1.DLL is linked to MSVCRT.DLL, the executables that
-    depend on it should also be linked to MSVCRT.DLL.
-
-
-10. Why are you saying that ZLIB1.DLL and my application should
-    be linked to the same C run-time (CRT) library?  I linked my
-    application and my DLLs to different C libraries (e.g. my
-    application to a static library, and my DLLs to MSVCRT.DLL),
-    and everything works fine.
-
-  - If a user library invokes only pure Win32 API (accessible via
-    <windows.h> and the related headers), its DLL build will work
-    in any context.  But if this library invokes standard C API,
-    things get more complicated.
-
-    There is a single Win32 library in a Win32 system.  Every
-    function in this library resides in a single DLL module, that
-    is safe to call from anywhere.  On the other hand, there are
-    multiple versions of the C library, and each of them has its
-    own separate internal state.  Standalone executables and user
-    DLLs that call standard C functions must link to a C run-time
-    (CRT) library, be it static or shared (DLL).  Intermixing
-    occurs when an executable (not necessarily standalone) and a
-    DLL are linked to different CRTs, and both are running in the
-    same process.
-
-    Intermixing multiple CRTs is possible, as long as their
-    internal states are kept intact.  The Microsoft Knowledge Base
-    articles KB94248 "HOWTO: Use the C Run-Time" and KB140584
-    "HOWTO: Link with the Correct C Run-Time (CRT) Library"
-    mention the potential problems raised by intermixing.
-
-    If intermixing works for you, it's because your application
-    and DLLs are avoiding the corruption of each of the CRTs'
-    internal states, maybe by careful design, or maybe by fortune.
-
-    Also note that linking ZLIB1.DLL to non-Microsoft CRTs, such
-    as those provided by Borland, raises similar problems.
-
-
-11. Why are you linking ZLIB1.DLL to MSVCRT.DLL?
-
-  - MSVCRT.DLL exists on every Windows 95 with a new service pack
-    installed, or with Microsoft Internet Explorer 4 or later, and
-    on all other Windows 4.x or later (Windows 98, Windows NT 4,
-    or later).  It is freely distributable; if not present in the
-    system, it can be downloaded from Microsoft or from other
-    software provider for free.
-
-    The fact that MSVCRT.DLL does not exist on a virgin Windows 95
-    is not so problematic.  Windows 95 is scarcely found nowadays,
-    Microsoft ended its support a long time ago, and many recent
-    applications from various vendors, including Microsoft, do not
-    even run on it.  Furthermore, no serious user should run
-    Windows 95 without a proper update installed.
-
-
-12. Why are you not linking ZLIB1.DLL to
-    <<my favorite C run-time library>> ?
-
-  - We considered and abandoned the following alternatives:
-
-    * Linking ZLIB1.DLL to a static C library (LIBC.LIB, or
-      LIBCMT.LIB) is not a good option.  People are using the DLL
-      mainly to save disk space.  If you are linking your program
-      to a static C library, you may as well consider linking zlib
-      in statically, too.
-
-    * Linking ZLIB1.DLL to CRTDLL.DLL looks appealing, because
-      CRTDLL.DLL is present on every Win32 installation.
-      Unfortunately, it has a series of problems: it does not
-      work properly with Microsoft's C++ libraries, it does not
-      provide support for 64-bit file offsets, (and so on...),
-      and Microsoft discontinued its support a long time ago.
-
-    * Linking ZLIB1.DLL to MSVCR70.DLL or MSVCR71.DLL, supplied
-      with the Microsoft .NET platform, and Visual C++ 7.0/7.1,
-      raises problems related to the status of ZLIB1.DLL as a
-      system component.  According to the Microsoft Knowledge Base
-      article KB326922 "INFO: Redistribution of the Shared C
-      Runtime Component in Visual C++ .NET", MSVCR70.DLL and
-      MSVCR71.DLL are not supposed to function as system DLLs,
-      because they may clash with MSVCRT.DLL.  Instead, the
-      application's installer is supposed to put these DLLs
-      (if needed) in the application's private directory.
-      If ZLIB1.DLL depends on a non-system runtime, it cannot
-      function as a redistributable system component.
-
-    * Linking ZLIB1.DLL to non-Microsoft runtimes, such as
-      Borland's, or Cygwin's, raises problems related to the
-      reliable presence of these runtimes on Win32 systems.
-      It's easier to let the DLL build of zlib up to the people
-      who distribute these runtimes, and who may proceed as
-      explained in the answer to Question 14.
-
-
-13. If ZLIB1.DLL cannot be linked to MSVCR70.DLL or MSVCR71.DLL,
-    how can I build/use ZLIB1.DLL in Microsoft Visual C++ 7.0
-    (Visual Studio .NET) or newer?
-
-  - Due to the problems explained in the Microsoft Knowledge Base
-    article KB326922 (see the previous answer), the C runtime that
-    comes with the VC7 environment is no longer considered a
-    system component.  That is, it should not be assumed that this
-    runtime exists, or may be installed in a system directory.
-    Since ZLIB1.DLL is supposed to be a system component, it may
-    not depend on a non-system component.
-
-    In order to link ZLIB1.DLL and your application to MSVCRT.DLL
-    in VC7, you need the library of Visual C++ 6.0 or older.  If
-    you don't have this library at hand, it's probably best not to
-    use ZLIB1.DLL.
-
-    We are hoping that, in the future, Microsoft will provide a
-    way to build applications linked to a proper system runtime,
-    from the Visual C++ environment.  Until then, you have a
-    couple of alternatives, such as linking zlib in statically.
-    If your application requires dynamic linking, you may proceed
-    as explained in the answer to Question 14.
-
-
-14. I need to link my own DLL build to a CRT different than
-    MSVCRT.DLL.  What can I do?
-
-  - Feel free to rebuild the DLL from the zlib sources, and link
-    it the way you want.  You should, however, clearly state that
-    your build is unofficial.  You should give it a different file
-    name, and/or install it in a private directory that can be
-    accessed by your application only, and is not visible to the
-    others (e.g. it's not in the SYSTEM or the SYSTEM32 directory,
-    and it's not in the PATH).  Otherwise, your build may clash
-    with applications that link to the official build.
-
-    For example, in Cygwin, zlib is linked to the Cygwin runtime
-    CYGWIN1.DLL, and it is distributed under the name CYGZ.DLL.
-
-
-15. May I include additional pieces of code that I find useful,
-    link them in ZLIB1.DLL, and export them?
-
-  - No.  A legitimate build of ZLIB1.DLL must not include code
-    that does not originate from the official zlib source code.
-    But you can make your own private DLL build, under a different
-    file name, as suggested in the previous answer.
-
-    For example, zlib is a part of the VCL library, distributed
-    with Borland Delphi and C++ Builder.  The DLL build of VCL
-    is a redistributable file, named VCLxx.DLL.
-
-
-16. May I remove some functionality out of ZLIB1.DLL, by enabling
-    macros like NO_GZCOMPRESS or NO_GZIP at compile time?
-
-  - No.  A legitimate build of ZLIB1.DLL must provide the complete
-    zlib functionality, as implemented in the official zlib source
-    code.  But you can make your own private DLL build, under a
-    different file name, as suggested in the previous answer.
-
-
-17. I made my own ZLIB1.DLL build.  Can I test it for compliance?
-
-  - We prefer that you download the official DLL from the zlib
-    web site.  If you need something peculiar from this DLL, you
-    can send your suggestion to the zlib mailing list.
-
-    However, in case you do rebuild the DLL yourself, you can run
-    it with the test programs found in the DLL distribution.
-    Running these test programs is not a guarantee of compliance,
-    but a failure can imply a detected problem.
-
-**
-
-This document is written and maintained by
-Cosmin Truta <cosmint@cs.ubbcluj.ro>
diff -Nbaur gcc-4.6.3/zlib/win32/Makefile.bor gcc-4.6.3-psp/zlib/win32/Makefile.bor
--- gcc-4.6.3/zlib/win32/Makefile.bor	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/win32/Makefile.bor	1970-01-01 01:00:00.000000000 +0100
@@ -1,107 +0,0 @@
-# Makefile for zlib
-# Borland C++ for Win32
-#
-# Updated for zlib 1.2.x by Cosmin Truta, 11-Mar-2003
-# Last updated: 28-Aug-2003
-#
-# Usage:
-#  make -f win32/Makefile.bor
-#  make -f win32/Makefile.bor LOCAL_ZLIB=-DASMV OBJA=match.obj OBJPA=+match.obj
-
-# ------------ Borland C++ ------------
-
-# Optional nonstandard preprocessor flags (e.g. -DMAX_MEM_LEVEL=7)
-# should be added to the environment via "set LOCAL_ZLIB=-DFOO" or
-# added to the declaration of LOC here:
-LOC = $(LOCAL_ZLIB)
-
-CC = bcc32
-AS = bcc32
-LD = bcc32
-AR = tlib
-CFLAGS  = -a -d -k- -O2 $(LOC)
-ASFLAGS = $(LOC)
-LDFLAGS = $(LOC)
-
-
-# variables
-ZLIB_LIB = zlib.lib
-
-OBJ1  = adler32.obj compress.obj crc32.obj deflate.obj gzio.obj infback.obj
-OBJ2  = inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj
-#OBJA =
-OBJP1 = +adler32.obj+compress.obj+crc32.obj+deflate.obj+gzio.obj+infback.obj
-OBJP2 = +inffast.obj+inflate.obj+inftrees.obj+trees.obj+uncompr.obj+zutil.obj
-#OBJPA=
-
-
-# targets
-all: $(ZLIB_LIB) example.exe minigzip.exe
-
-.c.obj:
-	$(CC) -c $(CFLAGS) $<
-
-.asm.obj:
-	$(AS) -c $(ASFLAGS) $<
-
-adler32.obj: adler32.c zlib.h zconf.h
-
-compress.obj: compress.c zlib.h zconf.h
-
-crc32.obj: crc32.c zlib.h zconf.h crc32.h
-
-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h
-
-gzio.obj: gzio.c zutil.h zlib.h zconf.h
-
-infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h
-
-inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
- inffast.h inffixed.h
-
-inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h
-
-trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h
-
-uncompr.obj: uncompr.c zlib.h zconf.h
-
-zutil.obj: zutil.c zutil.h zlib.h zconf.h
-
-example.obj: example.c zlib.h zconf.h
-
-minigzip.obj: minigzip.c zlib.h zconf.h
-
-
-# For the sake of the old Borland make,
-# the command line is cut to fit in the MS-DOS 128 byte limit:
-$(ZLIB_LIB): $(OBJ1) $(OBJ2) $(OBJA)
-	-del $(ZLIB_LIB)
-	$(AR) $(ZLIB_LIB) $(OBJP1)
-	$(AR) $(ZLIB_LIB) $(OBJP2)
-	$(AR) $(ZLIB_LIB) $(OBJPA)
-
-
-# testing
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d
-
-example.exe: example.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) example.obj $(ZLIB_LIB)
-
-minigzip.exe: minigzip.obj $(ZLIB_LIB)
-	$(LD) $(LDFLAGS) minigzip.obj $(ZLIB_LIB)
-
-
-# cleanup
-clean:
-	-del *.obj
-	-del *.lib
-	-del *.exe
-	-del *.tds
-	-del zlib.bak
-	-del foo.gz
diff -Nbaur gcc-4.6.3/zlib/win32/Makefile.emx gcc-4.6.3-psp/zlib/win32/Makefile.emx
--- gcc-4.6.3/zlib/win32/Makefile.emx	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/win32/Makefile.emx	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-# Makefile for zlib.  Modified for emx/rsxnt by Chr. Spieler, 6/16/98.
-# Copyright (C) 1995-1998 Jean-loup Gailly.
-# For conditions of distribution and use, see copyright notice in zlib.h
-
-# To compile, or to compile and test, type:
-#
-#   make -fmakefile.emx;  make test -fmakefile.emx
-#
-
-CC=gcc -Zwin32
-
-#CFLAGS=-MMD -O
-#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7
-#CFLAGS=-MMD -g -DDEBUG
-CFLAGS=-MMD -O3 $(BUTT) -Wall -Wwrite-strings -Wpointer-arith -Wconversion \
-             -Wstrict-prototypes -Wmissing-prototypes
-
-# If cp.exe is available, replace "copy /Y" with "cp -fp" .
-CP=copy /Y
-# If gnu install.exe is available, replace $(CP) with ginstall.
-INSTALL=$(CP)
-# The default value of RM is "rm -f."  If "rm.exe" is found, comment out:
-RM=del
-LDLIBS=-L. -lzlib
-LD=$(CC) -s -o
-LDSHARED=$(CC)
-
-INCL=zlib.h zconf.h
-LIBS=zlib.a
-
-AR=ar rcs
-
-prefix=/usr/local
-exec_prefix = $(prefix)
-
-OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \
-       zutil.o inflate.o infback.o inftrees.o inffast.o
-
-TEST_OBJS = example.o minigzip.o
-
-all: example.exe minigzip.exe
-
-test: all
-	./example
-	echo hello world | .\minigzip | .\minigzip -d
-
-%.o : %.c
-	$(CC) $(CFLAGS) -c $< -o $@
-
-zlib.a: $(OBJS)
-	$(AR) $@ $(OBJS)
-
-%.exe : %.o $(LIBS)
-	$(LD) $@ $< $(LDLIBS)
-
-
-.PHONY : clean
-
-clean:
-	$(RM) *.d
-	$(RM) *.o
-	$(RM) *.exe
-	$(RM) zlib.a
-	$(RM) foo.gz
-
-DEPS := $(wildcard *.d)
-ifneq ($(DEPS),)
-include $(DEPS)
-endif
diff -Nbaur gcc-4.6.3/zlib/win32/Makefile.gcc gcc-4.6.3-psp/zlib/win32/Makefile.gcc
--- gcc-4.6.3/zlib/win32/Makefile.gcc	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/win32/Makefile.gcc	1970-01-01 01:00:00.000000000 +0100
@@ -1,141 +0,0 @@
-# Makefile for zlib, derived from Makefile.dj2.
-# Modified for mingw32 by C. Spieler, 6/16/98.
-# Updated for zlib 1.2.x by Christian Spieler and Cosmin Truta, Mar-2003.
-# Last updated: 1-Aug-2003.
-# Tested under Cygwin and MinGW.
-
-# Copyright (C) 1995-2003 Jean-loup Gailly.
-# For conditions of distribution and use, see copyright notice in zlib.h
-
-# To compile, or to compile and test, type:
-#
-#   make -fmakefile.gcc;  make test testdll -fmakefile.gcc
-#
-# To use the asm code, type:
-#   cp contrib/asm?86/match.S ./match.S
-#   make LOC=-DASMV OBJA=match.o -fmakefile.gcc
-#
-# To install libz.a, zconf.h and zlib.h in the system directories, type:
-#
-#   make install -fmakefile.gcc
-
-# Note:
-# If the platform is *not* MinGW (e.g. it is Cygwin or UWIN),
-# the DLL name should be changed from "zlib1.dll".
-
-STATICLIB = libz.a
-SHAREDLIB = zlib1.dll
-IMPLIB    = libzdll.a
-
-#LOC = -DASMV
-#LOC = -DDEBUG -g
-
-CC = gcc
-CFLAGS = $(LOC) -O3 -Wall
-
-AS = $(CC)
-ASFLAGS = $(LOC) -Wall
-
-LD = $(CC)
-LDFLAGS = $(LOC) -s
-
-AR = ar
-ARFLAGS = rcs
-
-RC = windres
-RCFLAGS = --define GCC_WINDRES
-
-CP = cp -fp
-# If GNU install is available, replace $(CP) with install.
-INSTALL = $(CP)
-RM = rm -f
-
-prefix = /usr/local
-exec_prefix = $(prefix)
-
-OBJS = adler32.o compress.o crc32.o deflate.o gzio.o infback.o \
-       inffast.o inflate.o inftrees.o trees.o uncompr.o zutil.o
-OBJA =
-
-all: $(STATICLIB) $(SHAREDLIB) $(IMPLIB) example minigzip example_d minigzip_d
-
-test: example minigzip
-	./example
-	echo hello world | ./minigzip | ./minigzip -d
-
-testdll: example_d minigzip_d
-	./example_d
-	echo hello world | ./minigzip_d | ./minigzip_d -d
-
-.c.o:
-	$(CC) $(CFLAGS) -c -o $@ $<
-
-.S.o:
-	$(AS) $(ASFLAGS) -c -o $@ $<
-
-$(STATICLIB): $(OBJS) $(OBJA)
-	$(AR) $(ARFLAGS) $@ $(OBJS) $(OBJA)
-
-$(IMPLIB): $(SHAREDLIB)
-
-$(SHAREDLIB): win32/zlib.def $(OBJS) $(OBJA) zlibrc.o
-	dllwrap --driver-name $(CC) --def win32/zlib.def \
-	  --implib $(IMPLIB) -o $@ $(OBJS) $(OBJA) zlibrc.o
-	strip $@
-
-example: example.o $(STATICLIB)
-	$(LD) $(LDFLAGS) -o $@ example.o $(STATICLIB)
-
-minigzip: minigzip.o $(STATICLIB)
-	$(LD) $(LDFLAGS) -o $@ minigzip.o $(STATICLIB)
-
-example_d: example.o $(IMPLIB)
-	$(LD) $(LDFLAGS) -o $@ example.o $(IMPLIB)
-
-minigzip_d: minigzip.o $(IMPLIB)
-	$(LD) $(LDFLAGS) -o $@ minigzip.o $(IMPLIB)
-
-zlibrc.o: win32/zlib1.rc
-	$(RC) $(RCFLAGS) -o $@ win32/zlib1.rc
-
-
-# INCLUDE_PATH and LIBRARY_PATH must be set.
-
-.PHONY: install uninstall clean
-
-install: zlib.h zconf.h $(LIB)
-	-@if not exist $(INCLUDE_PATH)/nul mkdir $(INCLUDE_PATH)
-	-@if not exist $(LIBRARY_PATH)/nul mkdir $(LIBRARY_PATH)
-	-$(INSTALL) zlib.h $(INCLUDE_PATH)
-	-$(INSTALL) zconf.h $(INCLUDE_PATH)
-	-$(INSTALL) $(STATICLIB) $(LIBRARY_PATH)
-	-$(INSTALL) $(IMPLIB) $(LIBRARY_PATH)
-
-uninstall:
-	-$(RM) $(INCLUDE_PATH)/zlib.h
-	-$(RM) $(INCLUDE_PATH)/zconf.h
-	-$(RM) $(LIBRARY_PATH)/$(STATICLIB)
-	-$(RM) $(LIBRARY_PATH)/$(IMPLIB)
-
-clean:
-	-$(RM) $(STATICLIB)
-	-$(RM) $(SHAREDLIB)
-	-$(RM) $(IMPLIB)
-	-$(RM) *.o
-	-$(RM) *.exe
-	-$(RM) foo.gz
-
-adler32.o: zlib.h zconf.h
-compress.o: zlib.h zconf.h
-crc32.o: crc32.h zlib.h zconf.h
-deflate.o: deflate.h zutil.h zlib.h zconf.h
-example.o: zlib.h zconf.h
-gzio.o: zutil.h zlib.h zconf.h
-inffast.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-inflate.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-infback.o: zutil.h zlib.h zconf.h inftrees.h inflate.h inffast.h
-inftrees.o: zutil.h zlib.h zconf.h inftrees.h
-minigzip.o: zlib.h zconf.h
-trees.o: deflate.h zutil.h zlib.h zconf.h trees.h
-uncompr.o: zlib.h zconf.h
-zutil.o: zutil.h zlib.h zconf.h
diff -Nbaur gcc-4.6.3/zlib/win32/Makefile.msc gcc-4.6.3-psp/zlib/win32/Makefile.msc
--- gcc-4.6.3/zlib/win32/Makefile.msc	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/win32/Makefile.msc	1970-01-01 01:00:00.000000000 +0100
@@ -1,126 +0,0 @@
-# Makefile for zlib -- Microsoft (Visual) C
-#
-# Authors:
-#   Cosmin Truta, 11-Mar-2003
-#   Christian Spieler, 19-Mar-2003
-#
-# Last updated:
-#   Cosmin Truta, 27-Aug-2003
-#
-# Usage:
-#   nmake -f win32/Makefile.msc            (standard build)
-#   nmake -f win32/Makefile.msc LOC=-DFOO  (nonstandard build)
-#   nmake -f win32/Makefile.msc LOC=-DASMV OBJA=match.obj  (use ASM code)
-
-
-# optional build flags
-LOC =
-
-
-# variables
-STATICLIB = zlib.lib
-SHAREDLIB = zlib1.dll
-IMPLIB    = zdll.lib
-
-CC = cl
-AS = ml
-LD = link
-AR = lib
-RC = rc
-CFLAGS  = -nologo -MD -O2 $(LOC)
-ASFLAGS = -coff
-LDFLAGS = -nologo -release
-ARFLAGS = -nologo
-RCFLAGS = /dWIN32 /r
-
-OBJS = adler32.obj compress.obj crc32.obj deflate.obj gzio.obj infback.obj \
-       inffast.obj inflate.obj inftrees.obj trees.obj uncompr.obj zutil.obj
-OBJA =
-
-
-# targets
-all: $(STATICLIB) $(SHAREDLIB) $(IMPLIB) \
-     example.exe minigzip.exe example_d.exe minigzip_d.exe
-
-$(STATICLIB): $(OBJS) $(OBJA)
-	$(AR) $(ARFLAGS) -out:$@ $(OBJS) $(OBJA)
-
-$(IMPLIB): $(SHAREDLIB)
-
-$(SHAREDLIB): win32/zlib.def $(OBJS) $(OBJA) zlib1.res
-	$(LD) $(LDFLAGS) -def:win32/zlib.def -dll -implib:$(IMPLIB) \
-	  -out:$@ $(OBJS) $(OBJA) zlib1.res
-
-example.exe: example.obj $(STATICLIB)
-	$(LD) $(LDFLAGS) example.obj $(STATICLIB)
-
-minigzip.exe: minigzip.obj $(STATICLIB)
-	$(LD) $(LDFLAGS) minigzip.obj $(STATICLIB)
-
-example_d.exe: example.obj $(IMPLIB)
-	$(LD) $(LDFLAGS) -out:$@ example.obj $(IMPLIB)
-
-minigzip_d.exe: minigzip.obj $(IMPLIB)
-	$(LD) $(LDFLAGS) -out:$@ minigzip.obj $(IMPLIB)
-
-.c.obj:
-	$(CC) -c $(CFLAGS) $<
-
-.asm.obj:
-	$(AS) -c $(ASFLAGS) $<
-
-adler32.obj: adler32.c zlib.h zconf.h
-
-compress.obj: compress.c zlib.h zconf.h
-
-crc32.obj: crc32.c zlib.h zconf.h crc32.h
-
-deflate.obj: deflate.c deflate.h zutil.h zlib.h zconf.h
-
-gzio.obj: gzio.c zutil.h zlib.h zconf.h
-
-infback.obj: infback.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
-             inffast.h inffixed.h
-
-inffast.obj: inffast.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
-             inffast.h
-
-inflate.obj: inflate.c zutil.h zlib.h zconf.h inftrees.h inflate.h \
-             inffast.h inffixed.h
-
-inftrees.obj: inftrees.c zutil.h zlib.h zconf.h inftrees.h
-
-trees.obj: trees.c zutil.h zlib.h zconf.h deflate.h trees.h
-
-uncompr.obj: uncompr.c zlib.h zconf.h
-
-zutil.obj: zutil.c zutil.h zlib.h zconf.h
-
-example.obj: example.c zlib.h zconf.h
-
-minigzip.obj: minigzip.c zlib.h zconf.h
-
-zlib1.res: win32/zlib1.rc
-	$(RC) $(RCFLAGS) /fo$@ win32/zlib1.rc
-
-
-# testing
-test: example.exe minigzip.exe
-	example
-	echo hello world | minigzip | minigzip -d
-
-testdll: example_d.exe minigzip_d.exe
-	example_d
-	echo hello world | minigzip_d | minigzip_d -d
-
-
-# cleanup
-clean:
-	-del $(STATICLIB)
-	-del $(SHAREDLIB)
-	-del $(IMPLIB)
-	-del *.obj
-	-del *.res
-	-del *.exp
-	-del *.exe
-	-del foo.gz
diff -Nbaur gcc-4.6.3/zlib/win32/VisualC.txt gcc-4.6.3-psp/zlib/win32/VisualC.txt
--- gcc-4.6.3/zlib/win32/VisualC.txt	2005-09-12 18:03:48.000000000 +0100
+++ gcc-4.6.3-psp/zlib/win32/VisualC.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-
-To build zlib using the Microsoft Visual C++ environment,
-use the appropriate project from the projects/ directory.
diff -Nbaur gcc-4.6.3/zlib/win32/zlib1.rc gcc-4.6.3-psp/zlib/win32/zlib1.rc
--- gcc-4.6.3/zlib/win32/zlib1.rc	2005-09-12 18:04:02.000000000 +0100
+++ gcc-4.6.3-psp/zlib/win32/zlib1.rc	1970-01-01 01:00:00.000000000 +0100
@@ -1,39 +0,0 @@
-#include <windows.h>
-
-#ifdef GCC_WINDRES
-VS_VERSION_INFO		VERSIONINFO
-#else
-VS_VERSION_INFO		VERSIONINFO	MOVEABLE IMPURE LOADONCALL DISCARDABLE
-#endif
-  FILEVERSION		1,2,2,0
-  PRODUCTVERSION	1,2,2,0
-  FILEFLAGSMASK		VS_FFI_FILEFLAGSMASK
-#ifdef _DEBUG
-  FILEFLAGS		1
-#else
-  FILEFLAGS		0
-#endif
-  FILEOS		VOS_DOS_WINDOWS32
-  FILETYPE		VFT_DLL
-  FILESUBTYPE		0	// not used
-BEGIN
-  BLOCK "StringFileInfo"
-  BEGIN
-    BLOCK "040904E4"
-    //language ID = U.S. English, char set = Windows, Multilingual
-    BEGIN
-      VALUE "FileDescription",	"zlib data compression library\0"
-      VALUE "FileVersion",	"1.2.3\0"
-      VALUE "InternalName",	"zlib1.dll\0"
-      VALUE "LegalCopyright",	"(C) 1995-2004 Jean-loup Gailly & Mark Adler\0"
-      VALUE "OriginalFilename",	"zlib1.dll\0"
-      VALUE "ProductName",	"zlib\0"
-      VALUE "ProductVersion",	"1.2.3\0"
-      VALUE "Comments","DLL support by Alessandro Iacopetti & Gilles Vollant\0"
-    END
-  END
-  BLOCK "VarFileInfo"
-  BEGIN
-    VALUE "Translation", 0x0409, 1252
-  END
-END
diff -Nbaur gcc-4.6.3/zlib/win32/zlib.def gcc-4.6.3-psp/zlib/win32/zlib.def
--- gcc-4.6.3/zlib/win32/zlib.def	2004-10-11 18:44:11.000000000 +0100
+++ gcc-4.6.3-psp/zlib/win32/zlib.def	1970-01-01 01:00:00.000000000 +0100
@@ -1,60 +0,0 @@
-LIBRARY
-; zlib data compression library
-
-EXPORTS
-; basic functions
-    zlibVersion
-    deflate
-    deflateEnd
-    inflate
-    inflateEnd
-; advanced functions
-    deflateSetDictionary
-    deflateCopy
-    deflateReset
-    deflateParams
-    deflateBound
-    deflatePrime
-    inflateSetDictionary
-    inflateSync
-    inflateCopy
-    inflateReset
-    inflateBack
-    inflateBackEnd
-    zlibCompileFlags
-; utility functions
-    compress
-    compress2
-    compressBound
-    uncompress
-    gzopen
-    gzdopen
-    gzsetparams
-    gzread
-    gzwrite
-    gzprintf
-    gzputs
-    gzgets
-    gzputc
-    gzgetc
-    gzungetc
-    gzflush
-    gzseek
-    gzrewind
-    gztell
-    gzeof
-    gzclose
-    gzerror
-    gzclearerr
-; checksum functions
-    adler32
-    crc32
-; various hacks, don't look :)
-    deflateInit_
-    deflateInit2_
-    inflateInit_
-    inflateInit2_
-    inflateBackInit_
-    inflateSyncPoint
-    get_crc_table
-    zError
diff -Nbaur gcc-4.6.3/zlib/zconf.h gcc-4.6.3-psp/zlib/zconf.h
--- gcc-4.6.3/zlib/zconf.h	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/zconf.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,348 +0,0 @@
-/* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995-2005 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id: zconf.h,v 1.1.1.2 2002/03/11 21:53:27 tromey Exp $ */
-
-#ifndef ZCONF_H
-#define ZCONF_H
-
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- */
-#ifdef Z_PREFIX
-#  define deflateInit_          z_deflateInit_
-#  define deflate               z_deflate
-#  define deflateEnd            z_deflateEnd
-#  define inflateInit_          z_inflateInit_
-#  define inflate               z_inflate
-#  define inflateEnd            z_inflateEnd
-#  define deflateInit2_         z_deflateInit2_
-#  define deflateSetDictionary  z_deflateSetDictionary
-#  define deflateCopy           z_deflateCopy
-#  define deflateReset          z_deflateReset
-#  define deflateParams         z_deflateParams
-#  define deflateBound          z_deflateBound
-#  define deflatePrime          z_deflatePrime
-#  define inflateInit2_         z_inflateInit2_
-#  define inflateSetDictionary  z_inflateSetDictionary
-#  define inflateSync           z_inflateSync
-#  define inflateSyncPoint      z_inflateSyncPoint
-#  define inflateCopy           z_inflateCopy
-#  define inflateReset          z_inflateReset
-#  define inflateBack           z_inflateBack
-#  define inflateBackEnd        z_inflateBackEnd
-#  define compress              z_compress
-#  define compress2             z_compress2
-#  define compressBound         z_compressBound
-#  define uncompress            z_uncompress
-#  define adler32               z_adler32
-#  define crc32                 z_crc32
-#  define get_crc_table         z_get_crc_table
-#  define zError                z_zError
-
-#  define alloc_func            z_alloc_func
-#  define free_func             z_free_func
-#  define in_func               z_in_func
-#  define out_func              z_out_func
-#  define Byte                  z_Byte
-#  define uInt                  z_uInt
-#  define uLong                 z_uLong
-#  define Bytef                 z_Bytef
-#  define charf                 z_charf
-#  define intf                  z_intf
-#  define uIntf                 z_uIntf
-#  define uLongf                z_uLongf
-#  define voidpf                z_voidpf
-#  define voidp                 z_voidp
-#endif
-
-#if defined(__MSDOS__) && !defined(MSDOS)
-#  define MSDOS
-#endif
-#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
-#  define OS2
-#endif
-#if defined(_WINDOWS) && !defined(WINDOWS)
-#  define WINDOWS
-#endif
-#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
-#  ifndef WIN32
-#    define WIN32
-#  endif
-#endif
-#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
-#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
-#    ifndef SYS16BIT
-#      define SYS16BIT
-#    endif
-#  endif
-#endif
-
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- */
-#ifdef SYS16BIT
-#  define MAXSEG_64K
-#endif
-#ifdef MSDOS
-#  define UNALIGNED_OK
-#endif
-
-#ifdef __STDC_VERSION__
-#  ifndef STDC
-#    define STDC
-#  endif
-#  if __STDC_VERSION__ >= 199901L
-#    ifndef STDC99
-#      define STDC99
-#    endif
-#  endif
-#endif
-#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
-#  define STDC
-#endif
-
-#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
-#  define STDC
-#endif
-
-#ifndef STDC
-#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
-#    define const       /* note: need a more gentle solution here */
-#  endif
-#endif
-
-/* Some Mac compilers merge all .h files incorrectly: */
-#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
-#  define NO_DUMMY_DECL
-#endif
-
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-
-/* The memory requirements for deflate are (in bytes):
-            (1 << (windowBits+2)) +  (1 << (memLevel+9))
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus a few kilobytes
- for small objects.
-*/
-
-                        /* Type declarations */
-
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-
-/* The following definitions for FAR are needed only for MSDOS mixed
- * model programming (small or medium model with some far allocations).
- * This was tested only with MSC; for other MSDOS compilers you may have
- * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
- * just define FAR to be empty.
- */
-#ifdef SYS16BIT
-#  if defined(M_I86SM) || defined(M_I86MM)
-     /* MSC small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef _MSC_VER
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#  if (defined(__SMALL__) || defined(__MEDIUM__))
-     /* Turbo C small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef __BORLANDC__
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#endif
-
-#if defined(WINDOWS) || defined(WIN32)
-   /* If building or using zlib as a DLL, define ZLIB_DLL.
-    * This is not mandatory, but it offers a little performance increase.
-    */
-#  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA WINAPIV
-#    else
-#      define ZEXPORTVA FAR CDECL
-#    endif
-#  endif
-#endif
-
-#if defined (__BEOS__)
-#  ifdef ZLIB_DLL
-#    ifdef ZLIB_INTERNAL
-#      define ZEXPORT   __declspec(dllexport)
-#      define ZEXPORTVA __declspec(dllexport)
-#    else
-#      define ZEXPORT   __declspec(dllimport)
-#      define ZEXPORTVA __declspec(dllimport)
-#    endif
-#  endif
-#endif
-
-#ifndef ZEXTERN
-#  define ZEXTERN extern
-#endif
-#ifndef ZEXPORT
-#  define ZEXPORT
-#endif
-#ifndef ZEXPORTVA
-#  define ZEXPORTVA
-#endif
-
-#ifndef FAR
-#  define FAR
-#endif
-
-#if !defined(__MACTYPES__)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-
-#ifdef SMALL_MEDIUM
-   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
-#  define Bytef Byte FAR
-#else
-   typedef Byte  FAR Bytef;
-#endif
-typedef char  FAR charf;
-typedef int   FAR intf;
-typedef uInt  FAR uIntf;
-typedef uLong FAR uLongf;
-
-#ifdef STDC
-   typedef void const *voidpc;
-   typedef void FAR   *voidpf;
-   typedef void       *voidp;
-#else
-   typedef Byte const *voidpc;
-   typedef Byte FAR   *voidpf;
-   typedef Byte       *voidp;
-#endif
-
-#if 0           /* HAVE_UNISTD_H -- this line is updated by ./configure */
-#  include <sys/types.h> /* for off_t */
-#  include <unistd.h>    /* for SEEK_* and off_t */
-#  ifdef VMS
-#    include <unixio.h>   /* for off_t */
-#  endif
-#  define z_off_t off_t
-#endif
-#ifndef SEEK_SET
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-#ifndef z_off_t
-#  define z_off_t long
-#endif
-
-#if defined(__OS400__)
-#  define NO_vsnprintf
-#endif
-
-#if defined(__MVS__)
-#  define NO_vsnprintf
-#  ifdef FAR
-#    undef FAR
-#  endif
-#endif
-
-/* MVS linker does not support external names larger than 8 bytes */
-#if defined(__MVS__)
-#   pragma map(deflateInit_,"DEIN")
-#   pragma map(deflateInit2_,"DEIN2")
-#   pragma map(deflateEnd,"DEEND")
-#   pragma map(deflateBound,"DEBND")
-#   pragma map(inflateInit_,"ININ")
-#   pragma map(inflateInit2_,"ININ2")
-#   pragma map(inflateEnd,"INEND")
-#   pragma map(inflateSync,"INSY")
-#   pragma map(inflateSetDictionary,"INSEDI")
-#   pragma map(compressBound,"CMBND")
-#   pragma map(inflate_table,"INTABL")
-#   pragma map(inflate_fast,"INFA")
-#   pragma map(inflate_copyright,"INCOPY")
-#endif
-
-/* Solaris 2.5.1 doesn't have vsnprintf */
-#if defined(__sun) && defined(__svr4__)
-#include <sys/feature_tests.h>
-#if _XOPEN_VERSION < 3
-#define NO_vsnprintf
-#endif
-#endif
-
-/* Tru64 UNIX V4.0 neither */
-#if defined(__alpha) && defined(__osf__)
-#include <unistd.h>
-#if _XOPEN_VERSION < 500
-#define NO_vsnprintf
-#endif
-#endif
-
-#endif /* ZCONF_H */
diff -Nbaur gcc-4.6.3/zlib/zconf.in.h gcc-4.6.3-psp/zlib/zconf.in.h
--- gcc-4.6.3/zlib/zconf.in.h	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/zconf.in.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,332 +0,0 @@
-/* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995-2005 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#ifndef ZCONF_H
-#define ZCONF_H
-
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- */
-#ifdef Z_PREFIX
-#  define deflateInit_          z_deflateInit_
-#  define deflate               z_deflate
-#  define deflateEnd            z_deflateEnd
-#  define inflateInit_          z_inflateInit_
-#  define inflate               z_inflate
-#  define inflateEnd            z_inflateEnd
-#  define deflateInit2_         z_deflateInit2_
-#  define deflateSetDictionary  z_deflateSetDictionary
-#  define deflateCopy           z_deflateCopy
-#  define deflateReset          z_deflateReset
-#  define deflateParams         z_deflateParams
-#  define deflateBound          z_deflateBound
-#  define deflatePrime          z_deflatePrime
-#  define inflateInit2_         z_inflateInit2_
-#  define inflateSetDictionary  z_inflateSetDictionary
-#  define inflateSync           z_inflateSync
-#  define inflateSyncPoint      z_inflateSyncPoint
-#  define inflateCopy           z_inflateCopy
-#  define inflateReset          z_inflateReset
-#  define inflateBack           z_inflateBack
-#  define inflateBackEnd        z_inflateBackEnd
-#  define compress              z_compress
-#  define compress2             z_compress2
-#  define compressBound         z_compressBound
-#  define uncompress            z_uncompress
-#  define adler32               z_adler32
-#  define crc32                 z_crc32
-#  define get_crc_table         z_get_crc_table
-#  define zError                z_zError
-
-#  define alloc_func            z_alloc_func
-#  define free_func             z_free_func
-#  define in_func               z_in_func
-#  define out_func              z_out_func
-#  define Byte                  z_Byte
-#  define uInt                  z_uInt
-#  define uLong                 z_uLong
-#  define Bytef                 z_Bytef
-#  define charf                 z_charf
-#  define intf                  z_intf
-#  define uIntf                 z_uIntf
-#  define uLongf                z_uLongf
-#  define voidpf                z_voidpf
-#  define voidp                 z_voidp
-#endif
-
-#if defined(__MSDOS__) && !defined(MSDOS)
-#  define MSDOS
-#endif
-#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
-#  define OS2
-#endif
-#if defined(_WINDOWS) && !defined(WINDOWS)
-#  define WINDOWS
-#endif
-#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
-#  ifndef WIN32
-#    define WIN32
-#  endif
-#endif
-#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
-#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
-#    ifndef SYS16BIT
-#      define SYS16BIT
-#    endif
-#  endif
-#endif
-
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- */
-#ifdef SYS16BIT
-#  define MAXSEG_64K
-#endif
-#ifdef MSDOS
-#  define UNALIGNED_OK
-#endif
-
-#ifdef __STDC_VERSION__
-#  ifndef STDC
-#    define STDC
-#  endif
-#  if __STDC_VERSION__ >= 199901L
-#    ifndef STDC99
-#      define STDC99
-#    endif
-#  endif
-#endif
-#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
-#  define STDC
-#endif
-
-#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
-#  define STDC
-#endif
-
-#ifndef STDC
-#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
-#    define const       /* note: need a more gentle solution here */
-#  endif
-#endif
-
-/* Some Mac compilers merge all .h files incorrectly: */
-#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
-#  define NO_DUMMY_DECL
-#endif
-
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-
-/* The memory requirements for deflate are (in bytes):
-            (1 << (windowBits+2)) +  (1 << (memLevel+9))
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus a few kilobytes
- for small objects.
-*/
-
-                        /* Type declarations */
-
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-
-/* The following definitions for FAR are needed only for MSDOS mixed
- * model programming (small or medium model with some far allocations).
- * This was tested only with MSC; for other MSDOS compilers you may have
- * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
- * just define FAR to be empty.
- */
-#ifdef SYS16BIT
-#  if defined(M_I86SM) || defined(M_I86MM)
-     /* MSC small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef _MSC_VER
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#  if (defined(__SMALL__) || defined(__MEDIUM__))
-     /* Turbo C small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef __BORLANDC__
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#endif
-
-#if defined(WINDOWS) || defined(WIN32)
-   /* If building or using zlib as a DLL, define ZLIB_DLL.
-    * This is not mandatory, but it offers a little performance increase.
-    */
-#  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA WINAPIV
-#    else
-#      define ZEXPORTVA FAR CDECL
-#    endif
-#  endif
-#endif
-
-#if defined (__BEOS__)
-#  ifdef ZLIB_DLL
-#    ifdef ZLIB_INTERNAL
-#      define ZEXPORT   __declspec(dllexport)
-#      define ZEXPORTVA __declspec(dllexport)
-#    else
-#      define ZEXPORT   __declspec(dllimport)
-#      define ZEXPORTVA __declspec(dllimport)
-#    endif
-#  endif
-#endif
-
-#ifndef ZEXTERN
-#  define ZEXTERN extern
-#endif
-#ifndef ZEXPORT
-#  define ZEXPORT
-#endif
-#ifndef ZEXPORTVA
-#  define ZEXPORTVA
-#endif
-
-#ifndef FAR
-#  define FAR
-#endif
-
-#if !defined(__MACTYPES__)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-
-#ifdef SMALL_MEDIUM
-   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
-#  define Bytef Byte FAR
-#else
-   typedef Byte  FAR Bytef;
-#endif
-typedef char  FAR charf;
-typedef int   FAR intf;
-typedef uInt  FAR uIntf;
-typedef uLong FAR uLongf;
-
-#ifdef STDC
-   typedef void const *voidpc;
-   typedef void FAR   *voidpf;
-   typedef void       *voidp;
-#else
-   typedef Byte const *voidpc;
-   typedef Byte FAR   *voidpf;
-   typedef Byte       *voidp;
-#endif
-
-#if 0           /* HAVE_UNISTD_H -- this line is updated by ./configure */
-#  include <sys/types.h> /* for off_t */
-#  include <unistd.h>    /* for SEEK_* and off_t */
-#  ifdef VMS
-#    include <unixio.h>   /* for off_t */
-#  endif
-#  define z_off_t off_t
-#endif
-#ifndef SEEK_SET
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-#ifndef z_off_t
-#  define z_off_t long
-#endif
-
-#if defined(__OS400__)
-#  define NO_vsnprintf
-#endif
-
-#if defined(__MVS__)
-#  define NO_vsnprintf
-#  ifdef FAR
-#    undef FAR
-#  endif
-#endif
-
-/* MVS linker does not support external names larger than 8 bytes */
-#if defined(__MVS__)
-#   pragma map(deflateInit_,"DEIN")
-#   pragma map(deflateInit2_,"DEIN2")
-#   pragma map(deflateEnd,"DEEND")
-#   pragma map(deflateBound,"DEBND")
-#   pragma map(inflateInit_,"ININ")
-#   pragma map(inflateInit2_,"ININ2")
-#   pragma map(inflateEnd,"INEND")
-#   pragma map(inflateSync,"INSY")
-#   pragma map(inflateSetDictionary,"INSEDI")
-#   pragma map(compressBound,"CMBND")
-#   pragma map(inflate_table,"INTABL")
-#   pragma map(inflate_fast,"INFA")
-#   pragma map(inflate_copyright,"INCOPY")
-#endif
-
-#endif /* ZCONF_H */
diff -Nbaur gcc-4.6.3/zlib/zlib.3 gcc-4.6.3-psp/zlib/zlib.3
--- gcc-4.6.3/zlib/zlib.3	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/zlib.3	1970-01-01 01:00:00.000000000 +0100
@@ -1,159 +0,0 @@
-.TH ZLIB 3 "18 July 2005"
-.SH NAME
-zlib \- compression/decompression library
-.SH SYNOPSIS
-[see
-.I zlib.h
-for full description]
-.SH DESCRIPTION
-The
-.I zlib
-library is a general purpose data compression library.
-The code is thread safe.
-It provides in-memory compression and decompression functions,
-including integrity checks of the uncompressed data.
-This version of the library supports only one compression method (deflation)
-but other algorithms will be added later
-and will have the same stream interface.
-.LP
-Compression can be done in a single step if the buffers are large enough
-(for example if an input file is mmap'ed),
-or can be done by repeated calls of the compression function.
-In the latter case,
-the application must provide more input and/or consume the output
-(providing more output space) before each call.
-.LP
-The library also supports reading and writing files in
-.IR gzip (1)
-(.gz) format
-with an interface similar to that of stdio.
-.LP
-The library does not install any signal handler.
-The decoder checks the consistency of the compressed data,
-so the library should never crash even in case of corrupted input.
-.LP
-All functions of the compression library are documented in the file
-.IR zlib.h .
-The distribution source includes examples of use of the library
-in the files
-.I example.c
-and
-.IR minigzip.c .
-.LP
-Changes to this version are documented in the file
-.I ChangeLog
-that accompanies the source,
-and are concerned primarily with bug fixes and portability enhancements.
-.LP
-A Java implementation of
-.I zlib
-is available in the Java Development Kit 1.1:
-.IP
-http://www.javasoft.com/products/JDK/1.1/docs/api/Package-java.util.zip.html
-.LP
-A Perl interface to
-.IR zlib ,
-written by Paul Marquess (pmqs@cpan.org),
-is available at CPAN (Comprehensive Perl Archive Network) sites,
-including:
-.IP
-http://www.cpan.org/modules/by-module/Compress/
-.LP
-A Python interface to
-.IR zlib ,
-written by A.M. Kuchling (amk@magnet.com),
-is available in Python 1.5 and later versions:
-.IP
-http://www.python.org/doc/lib/module-zlib.html
-.LP
-A
-.I zlib
-binding for
-.IR tcl (1),
-written by Andreas Kupries (a.kupries@westend.com),
-is availlable at:
-.IP
-http://www.westend.com/~kupries/doc/trf/man/man.html
-.LP
-An experimental package to read and write files in .zip format,
-written on top of
-.I zlib
-by Gilles Vollant (info@winimage.com),
-is available at:
-.IP
-http://www.winimage.com/zLibDll/unzip.html
-and also in the
-.I contrib/minizip
-directory of the main
-.I zlib
-web site.
-.SH "SEE ALSO"
-The
-.I zlib
-web site can be found at either of these locations:
-.IP
-http://www.zlib.org
-.br
-http://www.gzip.org/zlib/
-.LP
-The data format used by the zlib library is described by RFC
-(Request for Comments) 1950 to 1952 in the files:
-.IP
-http://www.ietf.org/rfc/rfc1950.txt (concerning zlib format)
-.br
-http://www.ietf.org/rfc/rfc1951.txt (concerning deflate format)
-.br
-http://www.ietf.org/rfc/rfc1952.txt (concerning gzip format)
-.LP
-These documents are also available in other formats from:
-.IP
-ftp://ftp.uu.net/graphics/png/documents/zlib/zdoc-index.html
-.LP
-Mark Nelson (markn@ieee.org) wrote an article about
-.I zlib
-for the Jan. 1997 issue of  Dr. Dobb's Journal;
-a copy of the article is available at:
-.IP
-http://dogma.net/markn/articles/zlibtool/zlibtool.htm
-.SH "REPORTING PROBLEMS"
-Before reporting a problem,
-please check the
-.I zlib
-web site to verify that you have the latest version of
-.IR zlib ;
-otherwise,
-obtain the latest version and see if the problem still exists.
-Please read the
-.I zlib
-FAQ at:
-.IP
-http://www.gzip.org/zlib/zlib_faq.html
-.LP
-before asking for help.
-Send questions and/or comments to zlib@gzip.org,
-or (for the Windows DLL version) to Gilles Vollant (info@winimage.com).
-.SH AUTHORS
-Version 1.2.3
-Copyright (C) 1995-2005 Jean-loup Gailly (jloup@gzip.org)
-and Mark Adler (madler@alumni.caltech.edu).
-.LP
-This software is provided "as-is,"
-without any express or implied warranty.
-In no event will the authors be held liable for any damages
-arising from the use of this software.
-See the distribution directory with respect to requirements
-governing redistribution.
-The deflate format used by
-.I zlib
-was defined by Phil Katz.
-The deflate and
-.I zlib
-specifications were written by L. Peter Deutsch.
-Thanks to all the people who reported problems and suggested various
-improvements in
-.IR zlib ;
-who are too numerous to cite here.
-.LP
-UNIX manual page by R. P. C. Rodgers,
-U.S. National Library of Medicine (rodgers@nlm.nih.gov).
-.\" end of man page
diff -Nbaur gcc-4.6.3/zlib/zlib.h gcc-4.6.3-psp/zlib/zlib.h
--- gcc-4.6.3/zlib/zlib.h	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/zlib.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,1357 +0,0 @@
-/* zlib.h -- interface of the 'zlib' general purpose compression library
-  version 1.2.3, July 18th, 2005
-
-  Copyright (C) 1995-2005 Jean-loup Gailly and Mark Adler
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Jean-loup Gailly        Mark Adler
-  jloup@gzip.org          madler@alumni.caltech.edu
-
-
-  The data format used by the zlib library is described by RFCs (Request for
-  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt
-  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
-*/
-
-#ifndef ZLIB_H
-#define ZLIB_H
-
-#include "zconf.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define ZLIB_VERSION "1.2.3"
-#define ZLIB_VERNUM 0x1230
-
-/*
-     The 'zlib' compression library provides in-memory compression and
-  decompression functions, including integrity checks of the uncompressed
-  data.  This version of the library supports only one compression method
-  (deflation) but other algorithms will be added later and will have the same
-  stream interface.
-
-     Compression can be done in a single step if the buffers are large
-  enough (for example if an input file is mmap'ed), or can be done by
-  repeated calls of the compression function.  In the latter case, the
-  application must provide more input and/or consume the output
-  (providing more output space) before each call.
-
-     The compressed data format used by default by the in-memory functions is
-  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
-  around a deflate stream, which is itself documented in RFC 1951.
-
-     The library also supports reading and writing files in gzip (.gz) format
-  with an interface similar to that of stdio using the functions that start
-  with "gz".  The gzip format is different from the zlib format.  gzip is a
-  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
-
-     This library can optionally read and write gzip streams in memory as well.
-
-     The zlib format was designed to be compact and fast for use in memory
-  and on communications channels.  The gzip format was designed for single-
-  file compression on file systems, has a larger header than zlib to maintain
-  directory information, and uses a different, slower check method than zlib.
-
-     The library does not install any signal handler. The decoder checks
-  the consistency of the compressed data, so the library should never
-  crash even in case of corrupted input.
-*/
-
-typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
-typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
-
-struct internal_state;
-
-typedef struct z_stream_s {
-    Bytef    *next_in;  /* next input byte */
-    uInt     avail_in;  /* number of bytes available at next_in */
-    uLong    total_in;  /* total nb of input bytes read so far */
-
-    Bytef    *next_out; /* next output byte should be put there */
-    uInt     avail_out; /* remaining free space at next_out */
-    uLong    total_out; /* total nb of bytes output so far */
-
-    char     *msg;      /* last error message, NULL if no error */
-    struct internal_state FAR *state; /* not visible by applications */
-
-    alloc_func zalloc;  /* used to allocate the internal state */
-    free_func  zfree;   /* used to free the internal state */
-    voidpf     opaque;  /* private data object passed to zalloc and zfree */
-
-    int     data_type;  /* best guess about the data type: binary or text */
-    uLong   adler;      /* adler32 value of the uncompressed data */
-    uLong   reserved;   /* reserved for future use */
-} z_stream;
-
-typedef z_stream FAR *z_streamp;
-
-/*
-     gzip header information passed to and from zlib routines.  See RFC 1952
-  for more details on the meanings of these fields.
-*/
-typedef struct gz_header_s {
-    int     text;       /* true if compressed data believed to be text */
-    uLong   time;       /* modification time */
-    int     xflags;     /* extra flags (not used when writing a gzip file) */
-    int     os;         /* operating system */
-    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
-    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
-    uInt    extra_max;  /* space at extra (only when reading header) */
-    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
-    uInt    name_max;   /* space at name (only when reading header) */
-    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
-    uInt    comm_max;   /* space at comment (only when reading header) */
-    int     hcrc;       /* true if there was or will be a header crc */
-    int     done;       /* true when done reading gzip header (not used
-                           when writing a gzip file) */
-} gz_header;
-
-typedef gz_header FAR *gz_headerp;
-
-/*
-   The application must update next_in and avail_in when avail_in has
-   dropped to zero. It must update next_out and avail_out when avail_out
-   has dropped to zero. The application must initialize zalloc, zfree and
-   opaque before calling the init function. All other fields are set by the
-   compression library and must not be updated by the application.
-
-   The opaque value provided by the application will be passed as the first
-   parameter for calls of zalloc and zfree. This can be useful for custom
-   memory management. The compression library attaches no meaning to the
-   opaque value.
-
-   zalloc must return Z_NULL if there is not enough memory for the object.
-   If zlib is used in a multi-threaded application, zalloc and zfree must be
-   thread safe.
-
-   On 16-bit systems, the functions zalloc and zfree must be able to allocate
-   exactly 65536 bytes, but will not be required to allocate more than this
-   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
-   pointers returned by zalloc for objects of exactly 65536 bytes *must*
-   have their offset normalized to zero. The default allocation function
-   provided by this library ensures this (see zutil.c). To reduce memory
-   requirements and avoid any allocation of 64K objects, at the expense of
-   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
-
-   The fields total_in and total_out can be used for statistics or
-   progress reports. After compression, total_in holds the total size of
-   the uncompressed data and may be saved for use in the decompressor
-   (particularly if the decompressor wants to decompress everything in
-   a single step).
-*/
-
-                        /* constants */
-
-#define Z_NO_FLUSH      0
-#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
-#define Z_SYNC_FLUSH    2
-#define Z_FULL_FLUSH    3
-#define Z_FINISH        4
-#define Z_BLOCK         5
-/* Allowed flush values; see deflate() and inflate() below for details */
-
-#define Z_OK            0
-#define Z_STREAM_END    1
-#define Z_NEED_DICT     2
-#define Z_ERRNO        (-1)
-#define Z_STREAM_ERROR (-2)
-#define Z_DATA_ERROR   (-3)
-#define Z_MEM_ERROR    (-4)
-#define Z_BUF_ERROR    (-5)
-#define Z_VERSION_ERROR (-6)
-/* Return codes for the compression/decompression functions. Negative
- * values are errors, positive values are used for special but normal events.
- */
-
-#define Z_NO_COMPRESSION         0
-#define Z_BEST_SPEED             1
-#define Z_BEST_COMPRESSION       9
-#define Z_DEFAULT_COMPRESSION  (-1)
-/* compression levels */
-
-#define Z_FILTERED            1
-#define Z_HUFFMAN_ONLY        2
-#define Z_RLE                 3
-#define Z_FIXED               4
-#define Z_DEFAULT_STRATEGY    0
-/* compression strategy; see deflateInit2() below for details */
-
-#define Z_BINARY   0
-#define Z_TEXT     1
-#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
-#define Z_UNKNOWN  2
-/* Possible values of the data_type field (though see inflate()) */
-
-#define Z_DEFLATED   8
-/* The deflate compression method (the only one supported in this version) */
-
-#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
-
-#define zlib_version zlibVersion()
-/* for compatibility with versions < 1.0.2 */
-
-                        /* basic functions */
-
-ZEXTERN const char * ZEXPORT zlibVersion OF((void));
-/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
-   If the first character differs, the library code actually used is
-   not compatible with the zlib.h header file used by the application.
-   This check is automatically made by deflateInit and inflateInit.
- */
-
-/*
-ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
-
-     Initializes the internal stream state for compression. The fields
-   zalloc, zfree and opaque must be initialized before by the caller.
-   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
-   use default allocation functions.
-
-     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
-   1 gives best speed, 9 gives best compression, 0 gives no compression at
-   all (the input data is simply copied a block at a time).
-   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
-   compression (currently equivalent to level 6).
-
-     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
-   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
-   with the version assumed by the caller (ZLIB_VERSION).
-   msg is set to null if there is no error message.  deflateInit does not
-   perform any compression: this will be done by deflate().
-*/
-
-
-ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
-/*
-    deflate compresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full. It may introduce some
-  output latency (reading input without producing any output) except when
-  forced to flush.
-
-    The detailed semantics are as follows. deflate performs one or both of the
-  following actions:
-
-  - Compress more input starting at next_in and update next_in and avail_in
-    accordingly. If not all input can be processed (because there is not
-    enough room in the output buffer), next_in and avail_in are updated and
-    processing will resume at this point for the next call of deflate().
-
-  - Provide more output starting at next_out and update next_out and avail_out
-    accordingly. This action is forced if the parameter flush is non zero.
-    Forcing flush frequently degrades the compression ratio, so this parameter
-    should be set only when necessary (in interactive applications).
-    Some output may be provided even if flush is not set.
-
-  Before the call of deflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming
-  more output, and updating avail_in or avail_out accordingly; avail_out
-  should never be zero before the call. The application can consume the
-  compressed output when it wants, for example when the output buffer is full
-  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
-  and with zero avail_out, it must be called again after making room in the
-  output buffer because there might be more output pending.
-
-    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
-  decide how much data to accumualte before producing output, in order to
-  maximize compression.
-
-    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
-  flushed to the output buffer and the output is aligned on a byte boundary, so
-  that the decompressor can get all input data available so far. (In particular
-  avail_in is zero after the call if enough output space has been provided
-  before the call.)  Flushing may degrade compression for some compression
-  algorithms and so it should be used only when necessary.
-
-    If flush is set to Z_FULL_FLUSH, all output is flushed as with
-  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
-  restart from this point if previous compressed data has been damaged or if
-  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
-  compression.
-
-    If deflate returns with avail_out == 0, this function must be called again
-  with the same value of the flush parameter and more output space (updated
-  avail_out), until the flush is complete (deflate returns with non-zero
-  avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
-  avail_out is greater than six to avoid repeated flush markers due to
-  avail_out == 0 on return.
-
-    If the parameter flush is set to Z_FINISH, pending input is processed,
-  pending output is flushed and deflate returns with Z_STREAM_END if there
-  was enough output space; if deflate returns with Z_OK, this function must be
-  called again with Z_FINISH and more output space (updated avail_out) but no
-  more input data, until it returns with Z_STREAM_END or an error. After
-  deflate has returned Z_STREAM_END, the only possible operations on the
-  stream are deflateReset or deflateEnd.
-
-    Z_FINISH can be used immediately after deflateInit if all the compression
-  is to be done in a single step. In this case, avail_out must be at least
-  the value returned by deflateBound (see below). If deflate does not return
-  Z_STREAM_END, then it must be called again as described above.
-
-    deflate() sets strm->adler to the adler32 checksum of all input read
-  so far (that is, total_in bytes).
-
-    deflate() may update strm->data_type if it can make a good guess about
-  the input data type (Z_BINARY or Z_TEXT). In doubt, the data is considered
-  binary. This field is only for information purposes and does not affect
-  the compression algorithm in any manner.
-
-    deflate() returns Z_OK if some progress has been made (more input
-  processed or more output produced), Z_STREAM_END if all input has been
-  consumed and all output has been produced (only when flush is set to
-  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
-  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
-  (for example avail_in or avail_out was zero). Note that Z_BUF_ERROR is not
-  fatal, and deflate() can be called again with more input and more output
-  space to continue compressing.
-*/
-
-
-ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any
-   pending output.
-
-     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
-   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
-   prematurely (some input or output was discarded). In the error case,
-   msg may be set but then points to a static string (which must not be
-   deallocated).
-*/
-
-
-/*
-ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
-
-     Initializes the internal stream state for decompression. The fields
-   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
-   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
-   value depends on the compression method), inflateInit determines the
-   compression method from the zlib header and allocates all data structures
-   accordingly; otherwise the allocation will be deferred to the first call of
-   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
-   use default allocation functions.
-
-     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller.  msg is set to null if there is no error
-   message. inflateInit does not perform any decompression apart from reading
-   the zlib header if present: this will be done by inflate().  (So next_in and
-   avail_in may be modified, but next_out and avail_out are unchanged.)
-*/
-
-
-ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
-/*
-    inflate decompresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full. It may introduce
-  some output latency (reading input without producing any output) except when
-  forced to flush.
-
-  The detailed semantics are as follows. inflate performs one or both of the
-  following actions:
-
-  - Decompress more input starting at next_in and update next_in and avail_in
-    accordingly. If not all input can be processed (because there is not
-    enough room in the output buffer), next_in is updated and processing
-    will resume at this point for the next call of inflate().
-
-  - Provide more output starting at next_out and update next_out and avail_out
-    accordingly.  inflate() provides as much output as possible, until there
-    is no more input data or no more space in the output buffer (see below
-    about the flush parameter).
-
-  Before the call of inflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming
-  more output, and updating the next_* and avail_* values accordingly.
-  The application can consume the uncompressed output when it wants, for
-  example when the output buffer is full (avail_out == 0), or after each
-  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
-  must be called again after making room in the output buffer because there
-  might be more output pending.
-
-    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,
-  Z_FINISH, or Z_BLOCK. Z_SYNC_FLUSH requests that inflate() flush as much
-  output as possible to the output buffer. Z_BLOCK requests that inflate() stop
-  if and when it gets to the next deflate block boundary. When decoding the
-  zlib or gzip format, this will cause inflate() to return immediately after
-  the header and before the first block. When doing a raw inflate, inflate()
-  will go ahead and process the first block, and will return when it gets to
-  the end of that block, or when it runs out of data.
-
-    The Z_BLOCK option assists in appending to or combining deflate streams.
-  Also to assist in this, on return inflate() will set strm->data_type to the
-  number of unused bits in the last byte taken from strm->next_in, plus 64
-  if inflate() is currently decoding the last block in the deflate stream,
-  plus 128 if inflate() returned immediately after decoding an end-of-block
-  code or decoding the complete header up to just before the first byte of the
-  deflate stream. The end-of-block will not be indicated until all of the
-  uncompressed data from that block has been written to strm->next_out.  The
-  number of unused bits may in general be greater than seven, except when
-  bit 7 of data_type is set, in which case the number of unused bits will be
-  less than eight.
-
-    inflate() should normally be called until it returns Z_STREAM_END or an
-  error. However if all decompression is to be performed in a single step
-  (a single call of inflate), the parameter flush should be set to
-  Z_FINISH. In this case all pending input is processed and all pending
-  output is flushed; avail_out must be large enough to hold all the
-  uncompressed data. (The size of the uncompressed data may have been saved
-  by the compressor for this purpose.) The next operation on this stream must
-  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
-  is never required, but can be used to inform inflate that a faster approach
-  may be used for the single inflate() call.
-
-     In this implementation, inflate() always flushes as much output as
-  possible to the output buffer, and always uses the faster approach on the
-  first call. So the only effect of the flush parameter in this implementation
-  is on the return value of inflate(), as noted below, or when it returns early
-  because Z_BLOCK is used.
-
-     If a preset dictionary is needed after this call (see inflateSetDictionary
-  below), inflate sets strm->adler to the adler32 checksum of the dictionary
-  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
-  strm->adler to the adler32 checksum of all output produced so far (that is,
-  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
-  below. At the end of the stream, inflate() checks that its computed adler32
-  checksum is equal to that saved by the compressor and returns Z_STREAM_END
-  only if the checksum is correct.
-
-    inflate() will decompress and check either zlib-wrapped or gzip-wrapped
-  deflate data.  The header type is detected automatically.  Any information
-  contained in the gzip header is not retained, so applications that need that
-  information should instead use raw inflate, see inflateInit2() below, or
-  inflateBack() and perform their own processing of the gzip header and
-  trailer.
-
-    inflate() returns Z_OK if some progress has been made (more input processed
-  or more output produced), Z_STREAM_END if the end of the compressed data has
-  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
-  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
-  corrupted (input stream not conforming to the zlib format or incorrect check
-  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
-  if next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
-  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
-  output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and
-  inflate() can be called again with more input and more output space to
-  continue decompressing. If Z_DATA_ERROR is returned, the application may then
-  call inflateSync() to look for a good compression block if a partial recovery
-  of the data is desired.
-*/
-
-
-ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any
-   pending output.
-
-     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
-   was inconsistent. In the error case, msg may be set but then points to a
-   static string (which must not be deallocated).
-*/
-
-                        /* Advanced functions */
-
-/*
-    The following functions are needed only in some special applications.
-*/
-
-/*
-ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
-                                     int  level,
-                                     int  method,
-                                     int  windowBits,
-                                     int  memLevel,
-                                     int  strategy));
-
-     This is another version of deflateInit with more compression options. The
-   fields next_in, zalloc, zfree and opaque must be initialized before by
-   the caller.
-
-     The method parameter is the compression method. It must be Z_DEFLATED in
-   this version of the library.
-
-     The windowBits parameter is the base two logarithm of the window size
-   (the size of the history buffer). It should be in the range 8..15 for this
-   version of the library. Larger values of this parameter result in better
-   compression at the expense of memory usage. The default value is 15 if
-   deflateInit is used instead.
-
-     windowBits can also be -8..-15 for raw deflate. In this case, -windowBits
-   determines the window size. deflate() will then generate raw deflate data
-   with no zlib header or trailer, and will not compute an adler32 check value.
-
-     windowBits can also be greater than 15 for optional gzip encoding. Add
-   16 to windowBits to write a simple gzip header and trailer around the
-   compressed data instead of a zlib wrapper. The gzip header will have no
-   file name, no extra data, no comment, no modification time (set to zero),
-   no header crc, and the operating system will be set to 255 (unknown).  If a
-   gzip stream is being written, strm->adler is a crc32 instead of an adler32.
-
-     The memLevel parameter specifies how much memory should be allocated
-   for the internal compression state. memLevel=1 uses minimum memory but
-   is slow and reduces compression ratio; memLevel=9 uses maximum memory
-   for optimal speed. The default value is 8. See zconf.h for total memory
-   usage as a function of windowBits and memLevel.
-
-     The strategy parameter is used to tune the compression algorithm. Use the
-   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
-   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
-   string match), or Z_RLE to limit match distances to one (run-length
-   encoding). Filtered data consists mostly of small values with a somewhat
-   random distribution. In this case, the compression algorithm is tuned to
-   compress them better. The effect of Z_FILTERED is to force more Huffman
-   coding and less string matching; it is somewhat intermediate between
-   Z_DEFAULT and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as fast as
-   Z_HUFFMAN_ONLY, but give better compression for PNG image data. The strategy
-   parameter only affects the compression ratio but not the correctness of the
-   compressed output even if it is not set appropriately.  Z_FIXED prevents the
-   use of dynamic Huffman codes, allowing for a simpler decoder for special
-   applications.
-
-      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
-   method). msg is set to null if there is no error message.  deflateInit2 does
-   not perform any compression: this will be done by deflate().
-*/
-
-ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the compression dictionary from the given byte sequence
-   without producing any compressed output. This function must be called
-   immediately after deflateInit, deflateInit2 or deflateReset, before any
-   call of deflate. The compressor and decompressor must use exactly the same
-   dictionary (see inflateSetDictionary).
-
-     The dictionary should consist of strings (byte sequences) that are likely
-   to be encountered later in the data to be compressed, with the most commonly
-   used strings preferably put towards the end of the dictionary. Using a
-   dictionary is most useful when the data to be compressed is short and can be
-   predicted with good accuracy; the data can then be compressed better than
-   with the default empty dictionary.
-
-     Depending on the size of the compression data structures selected by
-   deflateInit or deflateInit2, a part of the dictionary may in effect be
-   discarded, for example if the dictionary is larger than the window size in
-   deflate or deflate2. Thus the strings most likely to be useful should be
-   put at the end of the dictionary, not at the front. In addition, the
-   current implementation of deflate will use at most the window size minus
-   262 bytes of the provided dictionary.
-
-     Upon return of this function, strm->adler is set to the adler32 value
-   of the dictionary; the decompressor may later use this value to determine
-   which dictionary has been used by the compressor. (The adler32 value
-   applies to the whole dictionary even if only a subset of the dictionary is
-   actually used by the compressor.) If a raw deflate was requested, then the
-   adler32 value is not computed and strm->adler is not set.
-
-     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
-   parameter is invalid (such as NULL dictionary) or the stream state is
-   inconsistent (for example if deflate has already been called for this stream
-   or if the compression method is bsort). deflateSetDictionary does not
-   perform any compression: this will be done by deflate().
-*/
-
-ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-
-     This function can be useful when several compression strategies will be
-   tried, for example when there are several ways of pre-processing the input
-   data with a filter. The streams that will be discarded should then be freed
-   by calling deflateEnd.  Note that deflateCopy duplicates the internal
-   compression state which can be quite large, so this strategy is slow and
-   can consume lots of memory.
-
-     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being NULL). msg is left unchanged in both source and
-   destination.
-*/
-
-ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to deflateEnd followed by deflateInit,
-   but does not free and reallocate all the internal compression state.
-   The stream will keep the same compression level and any other attributes
-   that may have been set by deflateInit2.
-
-      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being NULL).
-*/
-
-ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
-                                      int level,
-                                      int strategy));
-/*
-     Dynamically update the compression level and compression strategy.  The
-   interpretation of level and strategy is as in deflateInit2.  This can be
-   used to switch between compression and straight copy of the input data, or
-   to switch to a different kind of input data requiring a different
-   strategy. If the compression level is changed, the input available so far
-   is compressed with the old level (and may be flushed); the new level will
-   take effect only at the next call of deflate().
-
-     Before the call of deflateParams, the stream state must be set as for
-   a call of deflate(), since the currently available input may have to
-   be compressed and flushed. In particular, strm->avail_out must be non-zero.
-
-     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
-   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
-   if strm->avail_out was zero.
-*/
-
-ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
-                                    int good_length,
-                                    int max_lazy,
-                                    int nice_length,
-                                    int max_chain));
-/*
-     Fine tune deflate's internal compression parameters.  This should only be
-   used by someone who understands the algorithm used by zlib's deflate for
-   searching for the best matching string, and even then only by the most
-   fanatic optimizer trying to squeeze out the last compressed bit for their
-   specific input data.  Read the deflate.c source code for the meaning of the
-   max_lazy, good_length, nice_length, and max_chain parameters.
-
-     deflateTune() can be called after deflateInit() or deflateInit2(), and
-   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
- */
-
-ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
-                                       uLong sourceLen));
-/*
-     deflateBound() returns an upper bound on the compressed size after
-   deflation of sourceLen bytes.  It must be called after deflateInit()
-   or deflateInit2().  This would be used to allocate an output buffer
-   for deflation in a single pass, and so would be called before deflate().
-*/
-
-ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
-                                     int bits,
-                                     int value));
-/*
-     deflatePrime() inserts bits in the deflate output stream.  The intent
-  is that this function is used to start off the deflate output with the
-  bits leftover from a previous deflate stream when appending to it.  As such,
-  this function can only be used for raw deflate, and must be used before the
-  first deflate() call after a deflateInit2() or deflateReset().  bits must be
-  less than or equal to 16, and that many of the least significant bits of
-  value will be inserted in the output.
-
-      deflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
-                                         gz_headerp head));
-/*
-      deflateSetHeader() provides gzip header information for when a gzip
-   stream is requested by deflateInit2().  deflateSetHeader() may be called
-   after deflateInit2() or deflateReset() and before the first call of
-   deflate().  The text, time, os, extra field, name, and comment information
-   in the provided gz_header structure are written to the gzip header (xflag is
-   ignored -- the extra flags are set according to the compression level).  The
-   caller must assure that, if not Z_NULL, name and comment are terminated with
-   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
-   available there.  If hcrc is true, a gzip header crc is included.  Note that
-   the current versions of the command-line version of gzip (up through version
-   1.3.x) do not support header crc's, and will report that it is a "multi-part
-   gzip file" and give up.
-
-      If deflateSetHeader is not used, the default gzip header has text false,
-   the time set to zero, and os set to 255, with no extra, name, or comment
-   fields.  The gzip header is returned to the default state by deflateReset().
-
-      deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-/*
-ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
-                                     int  windowBits));
-
-     This is another version of inflateInit with an extra parameter. The
-   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
-   before by the caller.
-
-     The windowBits parameter is the base two logarithm of the maximum window
-   size (the size of the history buffer).  It should be in the range 8..15 for
-   this version of the library. The default value is 15 if inflateInit is used
-   instead. windowBits must be greater than or equal to the windowBits value
-   provided to deflateInit2() while compressing, or it must be equal to 15 if
-   deflateInit2() was not used. If a compressed stream with a larger window
-   size is given as input, inflate() will return with the error code
-   Z_DATA_ERROR instead of trying to allocate a larger window.
-
-     windowBits can also be -8..-15 for raw inflate. In this case, -windowBits
-   determines the window size. inflate() will then process raw deflate data,
-   not looking for a zlib or gzip header, not generating a check value, and not
-   looking for any check values for comparison at the end of the stream. This
-   is for use with other formats that use the deflate compressed data format
-   such as zip.  Those formats provide their own check values. If a custom
-   format is developed using the raw deflate format for compressed data, it is
-   recommended that a check value such as an adler32 or a crc32 be applied to
-   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
-   most applications, the zlib format should be used as is. Note that comments
-   above on the use in deflateInit2() applies to the magnitude of windowBits.
-
-     windowBits can also be greater than 15 for optional gzip decoding. Add
-   32 to windowBits to enable zlib and gzip decoding with automatic header
-   detection, or add 16 to decode only the gzip format (the zlib format will
-   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is
-   a crc32 instead of an adler32.
-
-     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if a parameter is invalid (such as a null strm). msg
-   is set to null if there is no error message.  inflateInit2 does not perform
-   any decompression apart from reading the zlib header if present: this will
-   be done by inflate(). (So next_in and avail_in may be modified, but next_out
-   and avail_out are unchanged.)
-*/
-
-ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the decompression dictionary from the given uncompressed byte
-   sequence. This function must be called immediately after a call of inflate,
-   if that call returned Z_NEED_DICT. The dictionary chosen by the compressor
-   can be determined from the adler32 value returned by that call of inflate.
-   The compressor and decompressor must use exactly the same dictionary (see
-   deflateSetDictionary).  For raw inflate, this function can be called
-   immediately after inflateInit2() or inflateReset() and before any call of
-   inflate() to set the dictionary.  The application must insure that the
-   dictionary that was used for compression is provided.
-
-     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
-   parameter is invalid (such as NULL dictionary) or the stream state is
-   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
-   expected one (incorrect adler32 value). inflateSetDictionary does not
-   perform any decompression: this will be done by subsequent calls of
-   inflate().
-*/
-
-ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
-/*
-    Skips invalid compressed data until a full flush point (see above the
-  description of deflate with Z_FULL_FLUSH) can be found, or until all
-  available input is skipped. No output is provided.
-
-    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
-  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
-  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
-  case, the application may save the current current value of total_in which
-  indicates where valid compressed data was found. In the error case, the
-  application may repeatedly call inflateSync, providing more input each time,
-  until success or end of the input data.
-*/
-
-ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-
-     This function can be useful when randomly accessing a large stream.  The
-   first pass through the stream can periodically record the inflate state,
-   allowing restarting inflate at those points when randomly accessing the
-   stream.
-
-     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being NULL). msg is left unchanged in both source and
-   destination.
-*/
-
-ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to inflateEnd followed by inflateInit,
-   but does not free and reallocate all the internal decompression state.
-   The stream will keep attributes that may have been set by inflateInit2.
-
-      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being NULL).
-*/
-
-ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
-                                     int bits,
-                                     int value));
-/*
-     This function inserts bits in the inflate input stream.  The intent is
-  that this function is used to start inflating at a bit position in the
-  middle of a byte.  The provided bits will be used before any bytes are used
-  from next_in.  This function should only be used with raw inflate, and
-  should be used before the first inflate() call after inflateInit2() or
-  inflateReset().  bits must be less than or equal to 16, and that many of the
-  least significant bits of value will be inserted in the input.
-
-      inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
-                                         gz_headerp head));
-/*
-      inflateGetHeader() requests that gzip header information be stored in the
-   provided gz_header structure.  inflateGetHeader() may be called after
-   inflateInit2() or inflateReset(), and before the first call of inflate().
-   As inflate() processes the gzip stream, head->done is zero until the header
-   is completed, at which time head->done is set to one.  If a zlib stream is
-   being decoded, then head->done is set to -1 to indicate that there will be
-   no gzip header information forthcoming.  Note that Z_BLOCK can be used to
-   force inflate() to return immediately after header processing is complete
-   and before any actual data is decompressed.
-
-      The text, time, xflags, and os fields are filled in with the gzip header
-   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
-   was valid if done is set to one.)  If extra is not Z_NULL, then extra_max
-   contains the maximum number of bytes to write to extra.  Once done is true,
-   extra_len contains the actual extra field length, and extra contains the
-   extra field, or that field truncated if extra_max is less than extra_len.
-   If name is not Z_NULL, then up to name_max characters are written there,
-   terminated with a zero unless the length is greater than name_max.  If
-   comment is not Z_NULL, then up to comm_max characters are written there,
-   terminated with a zero unless the length is greater than comm_max.  When
-   any of extra, name, or comment are not Z_NULL and the respective field is
-   not present in the header, then that field is set to Z_NULL to signal its
-   absence.  This allows the use of deflateSetHeader() with the returned
-   structure to duplicate the header.  However if those fields are set to
-   allocated memory, then the application will need to save those pointers
-   elsewhere so that they can be eventually freed.
-
-      If inflateGetHeader is not used, then the header information is simply
-   discarded.  The header is always checked for validity, including the header
-   CRC if present.  inflateReset() will reset the process to discard the header
-   information.  The application would need to call inflateGetHeader() again to
-   retrieve the header from the next gzip stream.
-
-      inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-/*
-ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
-                                        unsigned char FAR *window));
-
-     Initialize the internal stream state for decompression using inflateBack()
-   calls.  The fields zalloc, zfree and opaque in strm must be initialized
-   before the call.  If zalloc and zfree are Z_NULL, then the default library-
-   derived memory allocation routines are used.  windowBits is the base two
-   logarithm of the window size, in the range 8..15.  window is a caller
-   supplied buffer of that size.  Except for special applications where it is
-   assured that deflate was used with small window sizes, windowBits must be 15
-   and a 32K byte window must be supplied to be able to decompress general
-   deflate streams.
-
-     See inflateBack() for the usage of these routines.
-
-     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
-   the paramaters are invalid, Z_MEM_ERROR if the internal state could not
-   be allocated, or Z_VERSION_ERROR if the version of the library does not
-   match the version of the header file.
-*/
-
-typedef unsigned (*in_func) OF((void FAR *, unsigned char FAR * FAR *));
-typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
-
-ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
-                                    in_func in, void FAR *in_desc,
-                                    out_func out, void FAR *out_desc));
-/*
-     inflateBack() does a raw inflate with a single call using a call-back
-   interface for input and output.  This is more efficient than inflate() for
-   file i/o applications in that it avoids copying between the output and the
-   sliding window by simply making the window itself the output buffer.  This
-   function trusts the application to not change the output buffer passed by
-   the output function, at least until inflateBack() returns.
-
-     inflateBackInit() must be called first to allocate the internal state
-   and to initialize the state with the user-provided window buffer.
-   inflateBack() may then be used multiple times to inflate a complete, raw
-   deflate stream with each call.  inflateBackEnd() is then called to free
-   the allocated state.
-
-     A raw deflate stream is one with no zlib or gzip header or trailer.
-   This routine would normally be used in a utility that reads zip or gzip
-   files and writes out uncompressed files.  The utility would decode the
-   header and process the trailer on its own, hence this routine expects
-   only the raw deflate stream to decompress.  This is different from the
-   normal behavior of inflate(), which expects either a zlib or gzip header and
-   trailer around the deflate stream.
-
-     inflateBack() uses two subroutines supplied by the caller that are then
-   called by inflateBack() for input and output.  inflateBack() calls those
-   routines until it reads a complete deflate stream and writes out all of the
-   uncompressed data, or until it encounters an error.  The function's
-   parameters and return types are defined above in the in_func and out_func
-   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
-   number of bytes of provided input, and a pointer to that input in buf.  If
-   there is no input available, in() must return zero--buf is ignored in that
-   case--and inflateBack() will return a buffer error.  inflateBack() will call
-   out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()
-   should return zero on success, or non-zero on failure.  If out() returns
-   non-zero, inflateBack() will return with an error.  Neither in() nor out()
-   are permitted to change the contents of the window provided to
-   inflateBackInit(), which is also the buffer that out() uses to write from.
-   The length written by out() will be at most the window size.  Any non-zero
-   amount of input may be provided by in().
-
-     For convenience, inflateBack() can be provided input on the first call by
-   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
-   in() will be called.  Therefore strm->next_in must be initialized before
-   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
-   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
-   must also be initialized, and then if strm->avail_in is not zero, input will
-   initially be taken from strm->next_in[0 .. strm->avail_in - 1].
-
-     The in_desc and out_desc parameters of inflateBack() is passed as the
-   first parameter of in() and out() respectively when they are called.  These
-   descriptors can be optionally used to pass any information that the caller-
-   supplied in() and out() functions need to do their job.
-
-     On return, inflateBack() will set strm->next_in and strm->avail_in to
-   pass back any unused input that was provided by the last in() call.  The
-   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
-   if in() or out() returned an error, Z_DATA_ERROR if there was a format
-   error in the deflate stream (in which case strm->msg is set to indicate the
-   nature of the error), or Z_STREAM_ERROR if the stream was not properly
-   initialized.  In the case of Z_BUF_ERROR, an input or output error can be
-   distinguished using strm->next_in which will be Z_NULL only if in() returned
-   an error.  If strm->next is not Z_NULL, then the Z_BUF_ERROR was due to
-   out() returning non-zero.  (in() will always be called before out(), so
-   strm->next_in is assured to be defined if out() returns non-zero.)  Note
-   that inflateBack() cannot return Z_OK.
-*/
-
-ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
-/*
-     All memory allocated by inflateBackInit() is freed.
-
-     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
-   state was inconsistent.
-*/
-
-ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
-/* Return flags indicating compile-time options.
-
-    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
-     1.0: size of uInt
-     3.2: size of uLong
-     5.4: size of voidpf (pointer)
-     7.6: size of z_off_t
-
-    Compiler, assembler, and debug options:
-     8: DEBUG
-     9: ASMV or ASMINF -- use ASM code
-     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
-     11: 0 (reserved)
-
-    One-time table building (smaller code, but not thread-safe if true):
-     12: BUILDFIXED -- build static block decoding tables when needed
-     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
-     14,15: 0 (reserved)
-
-    Library content (indicates missing functionality):
-     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
-                          deflate code when not needed)
-     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
-                    and decode gzip streams (to avoid linking crc code)
-     18-19: 0 (reserved)
-
-    Operation variations (changes in library functionality):
-     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
-     21: FASTEST -- deflate algorithm with only one, lowest compression level
-     22,23: 0 (reserved)
-
-    The sprintf variant used by gzprintf (zero is best):
-     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
-     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
-     26: 0 = returns value, 1 = void -- 1 means inferred string length returned
-
-    Remainder:
-     27-31: 0 (reserved)
- */
-
-
-                        /* utility functions */
-
-/*
-     The following utility functions are implemented on top of the
-   basic stream-oriented functions. To simplify the interface, some
-   default options are assumed (compression level and memory usage,
-   standard memory allocation functions). The source code of these
-   utility functions can easily be modified if you need special options.
-*/
-
-ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
-                                 const Bytef *source, uLong sourceLen));
-/*
-     Compresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer. Upon entry, destLen is the total
-   size of the destination buffer, which must be at least the value returned
-   by compressBound(sourceLen). Upon exit, destLen is the actual size of the
-   compressed buffer.
-     This function can be used to compress a whole file at once if the
-   input file is mmap'ed.
-     compress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer.
-*/
-
-ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
-                                  const Bytef *source, uLong sourceLen,
-                                  int level));
-/*
-     Compresses the source buffer into the destination buffer. The level
-   parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer. Upon entry, destLen is the total size of the
-   destination buffer, which must be at least the value returned by
-   compressBound(sourceLen). Upon exit, destLen is the actual size of the
-   compressed buffer.
-
-     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
-   Z_STREAM_ERROR if the level parameter is invalid.
-*/
-
-ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
-/*
-     compressBound() returns an upper bound on the compressed size after
-   compress() or compress2() on sourceLen bytes.  It would be used before
-   a compress() or compress2() call to allocate the destination buffer.
-*/
-
-ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
-                                   const Bytef *source, uLong sourceLen));
-/*
-     Decompresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer. Upon entry, destLen is the total
-   size of the destination buffer, which must be large enough to hold the
-   entire uncompressed data. (The size of the uncompressed data must have
-   been saved previously by the compressor and transmitted to the decompressor
-   by some mechanism outside the scope of this compression library.)
-   Upon exit, destLen is the actual size of the compressed buffer.
-     This function can be used to decompress a whole file at once if the
-   input file is mmap'ed.
-
-     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.
-*/
-
-
-typedef voidp gzFile;
-
-ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
-/*
-     Opens a gzip (.gz) file for reading or writing. The mode parameter
-   is as in fopen ("rb" or "wb") but can also include a compression level
-   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
-   Huffman only compression as in "wb1h", or 'R' for run-length encoding
-   as in "wb1R". (See the description of deflateInit2 for more information
-   about the strategy parameter.)
-
-     gzopen can be used to read a file which is not in gzip format; in this
-   case gzread will directly read from the file without decompression.
-
-     gzopen returns NULL if the file could not be opened or if there was
-   insufficient memory to allocate the (de)compression state; errno
-   can be checked to distinguish the two cases (if errno is zero, the
-   zlib error is Z_MEM_ERROR).  */
-
-ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
-/*
-     gzdopen() associates a gzFile with the file descriptor fd.  File
-   descriptors are obtained from calls like open, dup, creat, pipe or
-   fileno (in the file has been previously opened with fopen).
-   The mode parameter is as in gzopen.
-     The next call of gzclose on the returned gzFile will also close the
-   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
-   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
-     gzdopen returns NULL if there was insufficient memory to allocate
-   the (de)compression state.
-*/
-
-ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
-/*
-     Dynamically update the compression level or strategy. See the description
-   of deflateInit2 for the meaning of these parameters.
-     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
-   opened for writing.
-*/
-
-ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
-/*
-     Reads the given number of uncompressed bytes from the compressed file.
-   If the input file was not in gzip format, gzread copies the given number
-   of bytes into the buffer.
-     gzread returns the number of uncompressed bytes actually read (0 for
-   end of file, -1 for error). */
-
-ZEXTERN int ZEXPORT    gzwrite OF((gzFile file,
-                                   voidpc buf, unsigned len));
-/*
-     Writes the given number of uncompressed bytes into the compressed file.
-   gzwrite returns the number of uncompressed bytes actually written
-   (0 in case of error).
-*/
-
-ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
-/*
-     Converts, formats, and writes the args to the compressed file under
-   control of the format string, as in fprintf. gzprintf returns the number of
-   uncompressed bytes actually written (0 in case of error).  The number of
-   uncompressed bytes written is limited to 4095. The caller should assure that
-   this limit is not exceeded. If it is exceeded, then gzprintf() will return
-   return an error (0) with nothing written. In this case, there may also be a
-   buffer overflow with unpredictable consequences, which is possible only if
-   zlib was compiled with the insecure functions sprintf() or vsprintf()
-   because the secure snprintf() or vsnprintf() functions were not available.
-*/
-
-ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
-/*
-      Writes the given null-terminated string to the compressed file, excluding
-   the terminating null character.
-      gzputs returns the number of characters written, or -1 in case of error.
-*/
-
-ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
-/*
-      Reads bytes from the compressed file until len-1 characters are read, or
-   a newline character is read and transferred to buf, or an end-of-file
-   condition is encountered.  The string is then terminated with a null
-   character.
-      gzgets returns buf, or Z_NULL in case of error.
-*/
-
-ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
-/*
-      Writes c, converted to an unsigned char, into the compressed file.
-   gzputc returns the value that was written, or -1 in case of error.
-*/
-
-ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
-/*
-      Reads one byte from the compressed file. gzgetc returns this byte
-   or -1 in case of end of file or error.
-*/
-
-ZEXTERN int ZEXPORT    gzungetc OF((int c, gzFile file));
-/*
-      Push one character back onto the stream to be read again later.
-   Only one character of push-back is allowed.  gzungetc() returns the
-   character pushed, or -1 on failure.  gzungetc() will fail if a
-   character has been pushed but not read yet, or if c is -1. The pushed
-   character will be discarded if the stream is repositioned with gzseek()
-   or gzrewind().
-*/
-
-ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
-/*
-     Flushes all pending output into the compressed file. The parameter
-   flush is as in the deflate() function. The return value is the zlib
-   error number (see function gzerror below). gzflush returns Z_OK if
-   the flush parameter is Z_FINISH and all output could be flushed.
-     gzflush should be called only when strictly necessary because it can
-   degrade compression.
-*/
-
-ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
-                                      z_off_t offset, int whence));
-/*
-      Sets the starting position for the next gzread or gzwrite on the
-   given compressed file. The offset represents a number of bytes in the
-   uncompressed data stream. The whence parameter is defined as in lseek(2);
-   the value SEEK_END is not supported.
-     If the file is opened for reading, this function is emulated but can be
-   extremely slow. If the file is opened for writing, only forward seeks are
-   supported; gzseek then compresses a sequence of zeroes up to the new
-   starting position.
-
-      gzseek returns the resulting offset location as measured in bytes from
-   the beginning of the uncompressed stream, or -1 in case of error, in
-   particular if the file is opened for writing and the new starting position
-   would be before the current position.
-*/
-
-ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
-/*
-     Rewinds the given file. This function is supported only for reading.
-
-   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
-*/
-
-ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
-/*
-     Returns the starting position for the next gzread or gzwrite on the
-   given compressed file. This position represents a number of bytes in the
-   uncompressed data stream.
-
-   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
-*/
-
-ZEXTERN int ZEXPORT gzeof OF((gzFile file));
-/*
-     Returns 1 when EOF has previously been detected reading the given
-   input stream, otherwise zero.
-*/
-
-ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
-/*
-     Returns 1 if file is being read directly without decompression, otherwise
-   zero.
-*/
-
-ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
-/*
-     Flushes all pending output if necessary, closes the compressed file
-   and deallocates all the (de)compression state. The return value is the zlib
-   error number (see function gzerror below).
-*/
-
-ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
-/*
-     Returns the error message for the last error which occurred on the
-   given compressed file. errnum is set to zlib error number. If an
-   error occurred in the file system and not in the compression library,
-   errnum is set to Z_ERRNO and the application may consult errno
-   to get the exact error code.
-*/
-
-ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
-/*
-     Clears the error and end-of-file flags for file. This is analogous to the
-   clearerr() function in stdio. This is useful for continuing to read a gzip
-   file that is being written concurrently.
-*/
-
-                        /* checksum functions */
-
-/*
-     These functions are not related to compression but are exported
-   anyway because they might be useful in applications using the
-   compression library.
-*/
-
-ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
-/*
-     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
-   return the updated checksum. If buf is NULL, this function returns
-   the required initial value for the checksum.
-   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
-   much faster. Usage example:
-
-     uLong adler = adler32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       adler = adler32(adler, buffer, length);
-     }
-     if (adler != original_adler) error();
-*/
-
-ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
-                                          z_off_t len2));
-/*
-     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
-   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
-   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
-   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.
-*/
-
-ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
-/*
-     Update a running CRC-32 with the bytes buf[0..len-1] and return the
-   updated CRC-32. If buf is NULL, this function returns the required initial
-   value for the for the crc. Pre- and post-conditioning (one's complement) is
-   performed within this function so it shouldn't be done by the application.
-   Usage example:
-
-     uLong crc = crc32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       crc = crc32(crc, buffer, length);
-     }
-     if (crc != original_crc) error();
-*/
-
-ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));
-
-/*
-     Combine two CRC-32 check values into one.  For two sequences of bytes,
-   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
-   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
-   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
-   len2.
-*/
-
-
-                        /* various hacks, don't look :) */
-
-/* deflateInit and inflateInit are macros to allow checking the zlib version
- * and the compiler's view of z_stream:
- */
-ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
-                                      int windowBits, int memLevel,
-                                      int strategy, const char *version,
-                                      int stream_size));
-ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
-                                      const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
-                                         unsigned char FAR *window,
-                                         const char *version,
-                                         int stream_size));
-#define deflateInit(strm, level) \
-        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
-#define inflateInit(strm) \
-        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
-#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
-        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
-                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
-#define inflateInit2(strm, windowBits) \
-        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
-#define inflateBackInit(strm, windowBits, window) \
-        inflateBackInit_((strm), (windowBits), (window), \
-        ZLIB_VERSION, sizeof(z_stream))
-
-
-#if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)
-    struct internal_state {int dummy;}; /* hack for buggy compilers */
-#endif
-
-ZEXTERN const char   * ZEXPORT zError           OF((int));
-ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
-ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZLIB_H */
diff -Nbaur gcc-4.6.3/zlib/zutil.c gcc-4.6.3-psp/zlib/zutil.c
--- gcc-4.6.3/zlib/zutil.c	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/zutil.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,318 +0,0 @@
-/* zutil.c -- target dependent utility functions for the compression library
- * Copyright (C) 1995-2005 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id: zutil.c,v 1.1.1.2 2002/03/11 21:53:27 tromey Exp $ */
-
-#include "zutil.h"
-
-#ifndef NO_DUMMY_DECL
-struct internal_state      {int dummy;}; /* for buggy compilers */
-#endif
-
-const char * const z_errmsg[10] = {
-"need dictionary",     /* Z_NEED_DICT       2  */
-"stream end",          /* Z_STREAM_END      1  */
-"",                    /* Z_OK              0  */
-"file error",          /* Z_ERRNO         (-1) */
-"stream error",        /* Z_STREAM_ERROR  (-2) */
-"data error",          /* Z_DATA_ERROR    (-3) */
-"insufficient memory", /* Z_MEM_ERROR     (-4) */
-"buffer error",        /* Z_BUF_ERROR     (-5) */
-"incompatible version",/* Z_VERSION_ERROR (-6) */
-""};
-
-
-const char * ZEXPORT zlibVersion()
-{
-    return ZLIB_VERSION;
-}
-
-uLong ZEXPORT zlibCompileFlags()
-{
-    uLong flags;
-
-    flags = 0;
-    switch (sizeof(uInt)) {
-    case 2:     break;
-    case 4:     flags += 1;     break;
-    case 8:     flags += 2;     break;
-    default:    flags += 3;
-    }
-    switch (sizeof(uLong)) {
-    case 2:     break;
-    case 4:     flags += 1 << 2;        break;
-    case 8:     flags += 2 << 2;        break;
-    default:    flags += 3 << 2;
-    }
-    switch (sizeof(voidpf)) {
-    case 2:     break;
-    case 4:     flags += 1 << 4;        break;
-    case 8:     flags += 2 << 4;        break;
-    default:    flags += 3 << 4;
-    }
-    switch (sizeof(z_off_t)) {
-    case 2:     break;
-    case 4:     flags += 1 << 6;        break;
-    case 8:     flags += 2 << 6;        break;
-    default:    flags += 3 << 6;
-    }
-#ifdef DEBUG
-    flags += 1 << 8;
-#endif
-#if defined(ASMV) || defined(ASMINF)
-    flags += 1 << 9;
-#endif
-#ifdef ZLIB_WINAPI
-    flags += 1 << 10;
-#endif
-#ifdef BUILDFIXED
-    flags += 1 << 12;
-#endif
-#ifdef DYNAMIC_CRC_TABLE
-    flags += 1 << 13;
-#endif
-#ifdef NO_GZCOMPRESS
-    flags += 1L << 16;
-#endif
-#ifdef NO_GZIP
-    flags += 1L << 17;
-#endif
-#ifdef PKZIP_BUG_WORKAROUND
-    flags += 1L << 20;
-#endif
-#ifdef FASTEST
-    flags += 1L << 21;
-#endif
-#ifdef STDC
-#  ifdef NO_vsnprintf
-        flags += 1L << 25;
-#    ifdef HAS_vsprintf_void
-        flags += 1L << 26;
-#    endif
-#  else
-#    ifdef HAS_vsnprintf_void
-        flags += 1L << 26;
-#    endif
-#  endif
-#else
-        flags += 1L << 24;
-#  ifdef NO_snprintf
-        flags += 1L << 25;
-#    ifdef HAS_sprintf_void
-        flags += 1L << 26;
-#    endif
-#  else
-#    ifdef HAS_snprintf_void
-        flags += 1L << 26;
-#    endif
-#  endif
-#endif
-    return flags;
-}
-
-#ifdef DEBUG
-
-#  ifndef verbose
-#    define verbose 0
-#  endif
-int z_verbose = verbose;
-
-void z_error (m)
-    char *m;
-{
-    fprintf(stderr, "%s\n", m);
-    exit(1);
-}
-#endif
-
-/* exported to allow conversion of error code to string for compress() and
- * uncompress()
- */
-const char * ZEXPORT zError(err)
-    int err;
-{
-    return ERR_MSG(err);
-}
-
-#if defined(_WIN32_WCE)
-    /* The Microsoft C Run-Time Library for Windows CE doesn't have
-     * errno.  We define it as a global variable to simplify porting.
-     * Its value is always 0 and should not be used.
-     */
-    int errno = 0;
-#endif
-
-#ifndef HAVE_MEMCPY
-
-void zmemcpy(dest, source, len)
-    Bytef* dest;
-    const Bytef* source;
-    uInt  len;
-{
-    if (len == 0) return;
-    do {
-        *dest++ = *source++; /* ??? to be unrolled */
-    } while (--len != 0);
-}
-
-int zmemcmp(s1, s2, len)
-    const Bytef* s1;
-    const Bytef* s2;
-    uInt  len;
-{
-    uInt j;
-
-    for (j = 0; j < len; j++) {
-        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
-    }
-    return 0;
-}
-
-void zmemzero(dest, len)
-    Bytef* dest;
-    uInt  len;
-{
-    if (len == 0) return;
-    do {
-        *dest++ = 0;  /* ??? to be unrolled */
-    } while (--len != 0);
-}
-#endif
-
-
-#ifdef SYS16BIT
-
-#ifdef __TURBOC__
-/* Turbo C in 16-bit mode */
-
-#  define MY_ZCALLOC
-
-/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
- * and farmalloc(64K) returns a pointer with an offset of 8, so we
- * must fix the pointer. Warning: the pointer must be put back to its
- * original form in order to free it, use zcfree().
- */
-
-#define MAX_PTR 10
-/* 10*64K = 640K */
-
-local int next_ptr = 0;
-
-typedef struct ptr_table_s {
-    voidpf org_ptr;
-    voidpf new_ptr;
-} ptr_table;
-
-local ptr_table table[MAX_PTR];
-/* This table is used to remember the original form of pointers
- * to large buffers (64K). Such pointers are normalized with a zero offset.
- * Since MSDOS is not a preemptive multitasking OS, this table is not
- * protected from concurrent access. This hack doesn't work anyway on
- * a protected system like OS/2. Use Microsoft C instead.
- */
-
-voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
-{
-    voidpf buf = opaque; /* just to make some compilers happy */
-    ulg bsize = (ulg)items*size;
-
-    /* If we allocate less than 65520 bytes, we assume that farmalloc
-     * will return a usable pointer which doesn't have to be normalized.
-     */
-    if (bsize < 65520L) {
-        buf = farmalloc(bsize);
-        if (*(ush*)&buf != 0) return buf;
-    } else {
-        buf = farmalloc(bsize + 16L);
-    }
-    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
-    table[next_ptr].org_ptr = buf;
-
-    /* Normalize the pointer to seg:0 */
-    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
-    *(ush*)&buf = 0;
-    table[next_ptr++].new_ptr = buf;
-    return buf;
-}
-
-void  zcfree (voidpf opaque, voidpf ptr)
-{
-    int n;
-    if (*(ush*)&ptr != 0) { /* object < 64K */
-        farfree(ptr);
-        return;
-    }
-    /* Find the original pointer */
-    for (n = 0; n < next_ptr; n++) {
-        if (ptr != table[n].new_ptr) continue;
-
-        farfree(table[n].org_ptr);
-        while (++n < next_ptr) {
-            table[n-1] = table[n];
-        }
-        next_ptr--;
-        return;
-    }
-    ptr = opaque; /* just to make some compilers happy */
-    Assert(0, "zcfree: ptr not found");
-}
-
-#endif /* __TURBOC__ */
-
-
-#ifdef M_I86
-/* Microsoft C in 16-bit mode */
-
-#  define MY_ZCALLOC
-
-#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
-#  define _halloc  halloc
-#  define _hfree   hfree
-#endif
-
-voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
-{
-    if (opaque) opaque = 0; /* to make compiler happy */
-    return _halloc((long)items, size);
-}
-
-void  zcfree (voidpf opaque, voidpf ptr)
-{
-    if (opaque) opaque = 0; /* to make compiler happy */
-    _hfree(ptr);
-}
-
-#endif /* M_I86 */
-
-#endif /* SYS16BIT */
-
-
-#ifndef MY_ZCALLOC /* Any system without a special alloc function */
-
-#ifndef STDC
-extern voidp  malloc OF((uInt size));
-extern voidp  calloc OF((uInt items, uInt size));
-extern void   free   OF((voidpf ptr));
-#endif
-
-voidpf zcalloc (opaque, items, size)
-    voidpf opaque;
-    unsigned items;
-    unsigned size;
-{
-    if (opaque) items += size - size; /* make compiler happy */
-    return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
-                              (voidpf)calloc(items, size);
-}
-
-void  zcfree (opaque, ptr)
-    voidpf opaque;
-    voidpf ptr;
-{
-    free(ptr);
-    if (opaque) return; /* make compiler happy */
-}
-
-#endif /* MY_ZCALLOC */
diff -Nbaur gcc-4.6.3/zlib/zutil.h gcc-4.6.3-psp/zlib/zutil.h
--- gcc-4.6.3/zlib/zutil.h	2005-09-12 18:42:53.000000000 +0100
+++ gcc-4.6.3-psp/zlib/zutil.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,269 +0,0 @@
-/* zutil.h -- internal interface and configuration of the compression library
- * Copyright (C) 1995-2005 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-
-/* @(#) $Id: zutil.h,v 1.1.1.2 2002/03/11 21:53:28 tromey Exp $ */
-
-#ifndef ZUTIL_H
-#define ZUTIL_H
-
-#define ZLIB_INTERNAL
-#include "zlib.h"
-
-#ifdef STDC
-#  ifndef _WIN32_WCE
-#    include <stddef.h>
-#  endif
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-#ifdef NO_ERRNO_H
-#   ifdef _WIN32_WCE
-      /* The Microsoft C Run-Time Library for Windows CE doesn't have
-       * errno.  We define it as a global variable to simplify porting.
-       * Its value is always 0 and should not be used.  We rename it to
-       * avoid conflict with other libraries that use the same workaround.
-       */
-#     define errno z_errno
-#   endif
-    extern int errno;
-#else
-#  ifndef _WIN32_WCE
-#    include <errno.h>
-#  endif
-#endif
-
-#ifndef local
-#  define local static
-#endif
-/* compile with -Dlocal if your debugger can't find static symbols */
-
-typedef unsigned char  uch;
-typedef uch FAR uchf;
-typedef unsigned short ush;
-typedef ush FAR ushf;
-typedef unsigned long  ulg;
-
-extern const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
-/* (size given to avoid silly warnings with Visual C++) */
-
-#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
-
-#define ERR_RETURN(strm,err) \
-  return (strm->msg = (char*)ERR_MSG(err), (err))
-/* To be used only when the state is known to be valid */
-
-        /* common constants */
-
-#ifndef DEF_WBITS
-#  define DEF_WBITS MAX_WBITS
-#endif
-/* default windowBits for decompression. MAX_WBITS is for compression only */
-
-#if MAX_MEM_LEVEL >= 8
-#  define DEF_MEM_LEVEL 8
-#else
-#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#endif
-/* default memLevel */
-
-#define STORED_BLOCK 0
-#define STATIC_TREES 1
-#define DYN_TREES    2
-/* The three kinds of block type */
-
-#define MIN_MATCH  3
-#define MAX_MATCH  258
-/* The minimum and maximum match lengths */
-
-#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */
-
-        /* target dependencies */
-
-#if defined(MSDOS) || (defined(WINDOWS) && !defined(WIN32))
-#  define OS_CODE  0x00
-#  if defined(__TURBOC__) || defined(__BORLANDC__)
-#    if(__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
-       /* Allow compilation with ANSI keywords only enabled */
-       void _Cdecl farfree( void *block );
-       void *_Cdecl farmalloc( unsigned long nbytes );
-#    else
-#      include <alloc.h>
-#    endif
-#  else /* MSC or DJGPP */
-#    include <malloc.h>
-#  endif
-#endif
-
-#ifdef AMIGA
-#  define OS_CODE  0x01
-#endif
-
-#if defined(VAXC) || defined(VMS)
-#  define OS_CODE  0x02
-#  define F_OPEN(name, mode) \
-     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
-#endif
-
-#if defined(ATARI) || defined(atarist)
-#  define OS_CODE  0x05
-#endif
-
-#ifdef OS2
-#  define OS_CODE  0x06
-#  ifdef M_I86
-     #include <malloc.h>
-#  endif
-#endif
-
-#if defined(MACOS) || defined(TARGET_OS_MAC)
-#  define OS_CODE  0x07
-#  if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
-#    include <unix.h> /* for fdopen */
-#  else
-#    ifndef fdopen
-#      define fdopen(fd,mode) NULL /* No fdopen() */
-#    endif
-#  endif
-#endif
-
-#ifdef TOPS20
-#  define OS_CODE  0x0a
-#endif
-
-#ifdef WIN32
-#  ifndef __CYGWIN__  /* Cygwin is Unix, not Win32 */
-#    define OS_CODE  0x0b
-#  endif
-#endif
-
-#ifdef __50SERIES /* Prime/PRIMOS */
-#  define OS_CODE  0x0f
-#endif
-
-#if defined(_BEOS_) || defined(RISCOS)
-#  define fdopen(fd,mode) NULL /* No fdopen() */
-#endif
-
-#if (defined(_MSC_VER) && (_MSC_VER > 600))
-#  if defined(_WIN32_WCE)
-#    define fdopen(fd,mode) NULL /* No fdopen() */
-#    ifndef _PTRDIFF_T_DEFINED
-       typedef int ptrdiff_t;
-#      define _PTRDIFF_T_DEFINED
-#    endif
-#  else
-#    define fdopen(fd,type)  _fdopen(fd,type)
-#  endif
-#endif
-
-        /* common defaults */
-
-#ifndef OS_CODE
-#  define OS_CODE  0x03  /* assume Unix */
-#endif
-
-#ifndef F_OPEN
-#  define F_OPEN(name, mode) fopen((name), (mode))
-#endif
-
-         /* functions */
-
-#if defined(STDC99) || (defined(__TURBOC__) && __TURBOC__ >= 0x550)
-#  ifndef HAVE_VSNPRINTF
-#    define HAVE_VSNPRINTF
-#  endif
-#endif
-#if defined(__CYGWIN__)
-#  ifndef HAVE_VSNPRINTF
-#    define HAVE_VSNPRINTF
-#  endif
-#endif
-#ifndef HAVE_VSNPRINTF
-#  ifdef MSDOS
-     /* vsnprintf may exist on some MS-DOS compilers (DJGPP?),
-        but for now we just assume it doesn't. */
-#    define NO_vsnprintf
-#  endif
-#  ifdef __TURBOC__
-#    define NO_vsnprintf
-#  endif
-#  ifdef WIN32
-     /* In Win32, vsnprintf is available as the "non-ANSI" _vsnprintf. */
-#    if !defined(vsnprintf) && !defined(NO_vsnprintf)
-#      define vsnprintf _vsnprintf
-#    endif
-#  endif
-#  ifdef __SASC
-#    define NO_vsnprintf
-#  endif
-#endif
-#ifdef VMS
-#  define NO_vsnprintf
-#endif
-
-#if defined(pyr)
-#  define NO_MEMCPY
-#endif
-#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
- /* Use our own functions for small and medium model with MSC <= 5.0.
-  * You may have to use the same strategy for Borland C (untested).
-  * The __SC__ check is for Symantec.
-  */
-#  define NO_MEMCPY
-#endif
-#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
-#  define HAVE_MEMCPY
-#endif
-#ifdef HAVE_MEMCPY
-#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
-#    define zmemcpy _fmemcpy
-#    define zmemcmp _fmemcmp
-#    define zmemzero(dest, len) _fmemset(dest, 0, len)
-#  else
-#    define zmemcpy memcpy
-#    define zmemcmp memcmp
-#    define zmemzero(dest, len) memset(dest, 0, len)
-#  endif
-#else
-   extern void zmemcpy  OF((Bytef* dest, const Bytef* source, uInt len));
-   extern int  zmemcmp  OF((const Bytef* s1, const Bytef* s2, uInt len));
-   extern void zmemzero OF((Bytef* dest, uInt len));
-#endif
-
-/* Diagnostic functions */
-#ifdef DEBUG
-#  include <stdio.h>
-   extern int z_verbose;
-   extern void z_error    OF((char *m));
-#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
-#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
-#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
-#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
-#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
-#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
-#else
-#  define Assert(cond,msg)
-#  define Trace(x)
-#  define Tracev(x)
-#  define Tracevv(x)
-#  define Tracec(c,x)
-#  define Tracecv(c,x)
-#endif
-
-
-voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
-void   zcfree  OF((voidpf opaque, voidpf ptr));
-
-#define ZALLOC(strm, items, size) \
-           (*((strm)->zalloc))((strm)->opaque, (items), (size))
-#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
-#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
-
-#endif /* ZUTIL_H */
